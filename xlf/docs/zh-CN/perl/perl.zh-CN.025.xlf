<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2fabb550524d3e9edaaeec56458f89ae111e042a" translate="yes" xml:space="preserve">
          <source>For improved performance, include:</source>
          <target state="translated">为了提高性能,包括:</target>
        </trans-unit>
        <trans-unit id="c1b48d4e66bee46bcdb174582c112372d1e36d74" translate="yes" xml:space="preserve">
          <source>For including perl header files this function simply prints:</source>
          <target state="translated">对于包含perl头文件,这个函数只需打印。</target>
        </trans-unit>
        <trans-unit id="b8b2246aaa2d68e99fd635ee467d71b09bb4bd64" translate="yes" xml:space="preserve">
          <source>For information on OO programming with Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">有关使用Perl进行OO编程的信息，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;和&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a44b4f224e3945a9a157e926bd85c54a2b806624" translate="yes" xml:space="preserve">
          <source>For information on compilers on older versions of AIX, see &lt;a href=&quot;#Compiling-Perl-5-on-older-AIX-versions-up-to-4.3.3&quot;&gt;Compiling Perl 5 on older AIX versions up to 4.3.3&lt;/a&gt;.</source>
          <target state="translated">有关旧版AIX上的编译器的信息，请参阅&lt;a href=&quot;#Compiling-Perl-5-on-older-AIX-versions-up-to-4.3.3&quot;&gt;在4.3.3之前的旧版AIX上编译Perl 5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e475bfd513c3fa5a177d8f4cb9e523eea02595c6" translate="yes" xml:space="preserve">
          <source>For installation of the Unix emulation, read the appropriate docs.</source>
          <target state="translated">关于Unix模拟器的安装,请阅读相关文档。</target>
        </trans-unit>
        <trans-unit id="82185638546b1e3be3173f75a2cb122a36a8e321" translate="yes" xml:space="preserve">
          <source>For instance in</source>
          <target state="translated">例如,在</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="d9622af028e4033dfcc0d167b46ab4c597968052" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;\p{Uppercase}&lt;/code&gt; matches any single character with the Unicode &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; property, while &lt;code&gt;\p{L}&lt;/code&gt; matches any character with a &lt;code&gt;General_Category&lt;/code&gt; of &lt;code&gt;&quot;L&quot;&lt;/code&gt; (letter) property (see &lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt; below). Brackets are not required for single letter property names, so &lt;code&gt;\p{L}&lt;/code&gt; is equivalent to &lt;code&gt;\pL&lt;/code&gt; .</source>
          <target state="translated">例如， &lt;code&gt;\p{Uppercase}&lt;/code&gt; 与Unicode &lt;code&gt;&quot;Uppercase&quot;&lt;/code&gt; 属性匹配任何单个字符，而 &lt;code&gt;\p{L}&lt;/code&gt; 与 &lt;code&gt;General_Category&lt;/code&gt; 为 &lt;code&gt;&quot;L&quot;&lt;/code&gt; （字母）属性的任何字符匹配（请参见下面的&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;）。单字母属性名称不需要括号，因此 &lt;code&gt;\p{L}&lt;/code&gt; 等效于 &lt;code&gt;\pL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c14488c9703c3faf25c072547bcce9b9c6d026a" translate="yes" xml:space="preserve">
          <source>For instance, here's part of the report from the</source>
          <target state="translated">例如,以下是报告的部分内容。</target>
        </trans-unit>
        <trans-unit id="7503b0a59ae7cf568e520699d192f582d8728a5a" translate="yes" xml:space="preserve">
          <source>For instance, if B = 10000, the number 1234567890 is represented internally as [3456, 7890, 12].</source>
          <target state="translated">例如,如果B=10000,数字1234567890在内部表示为[3456,7890,12]。</target>
        </trans-unit>
        <trans-unit id="0a5b8d1bb99d582e6babc450d597df94876d661f" translate="yes" xml:space="preserve">
          <source>For instance, if the object $obj represents the hexadecimal number 0xabcde, then &lt;code&gt;_rsft($obj, 2, 16)&lt;/code&gt; returns an object representing the number 0xabc. The &quot;remainer&quot;, 0xde, is discarded and not returned.</source>
          <target state="translated">例如，如果对象$ obj表示十六进制数0xabcde，则 &lt;code&gt;_rsft($obj, 2, 16)&lt;/code&gt; 返回表示数字0xabc的对象。&amp;ldquo;剩余&amp;rdquo; 0xde被丢弃，不返回。</target>
        </trans-unit>
        <trans-unit id="3ec9b07fa26c1960352cc0e11e6a493987aa28ff" translate="yes" xml:space="preserve">
          <source>For instance, the &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; routine which computes the square root of its argument is only defined for non-negative real numbers and yields a non-negative real number (it is an application from &lt;b&gt;R+&lt;/b&gt; to &lt;b&gt;R+&lt;/b&gt;). If we allow it to return a complex number, then it can be extended to negative real numbers to become an application from &lt;b&gt;R&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt; (the set of complex numbers):</source>
          <target state="translated">例如，计算其参数平方根的 &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt&lt;/a&gt;&lt;/code&gt; 例程仅针对非负实数定义，并产生非负实数（这是从&lt;b&gt;R +&lt;/b&gt;到&lt;b&gt;R +的应用&lt;/b&gt;）。如果我们允许它返回一个复数，则可以将其扩展为负实数，从而成为从&lt;b&gt;R&lt;/b&gt;到&lt;b&gt;C&lt;/b&gt;（复数的集合）的应用程序：</target>
        </trans-unit>
        <trans-unit id="c71534a4a55ea4fd39c101e16a7e78a572754ea2" translate="yes" xml:space="preserve">
          <source>For instance, the MGVTBL structure called &lt;code&gt;vtbl_sv&lt;/code&gt; (which corresponds to an &lt;code&gt;mg_type&lt;/code&gt; of &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; ) contains:</source>
          <target state="translated">例如，名为 &lt;code&gt;vtbl_sv&lt;/code&gt; 的MGVTBL结构（对应于 &lt;code&gt;mg_type&lt;/code&gt; 的 &lt;code&gt;PERL_MAGIC_sv&lt;/code&gt; ）包含：</target>
        </trans-unit>
        <trans-unit id="9ed32d78c1e09dbba1a9af89bf4a97865e921d05" translate="yes" xml:space="preserve">
          <source>For instance, to make our report order case-insensitive, we use &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; to lowercase the keys before comparing them:</source>
          <target state="translated">例如，为了使我们的报告顺序不区分大小写，我们在比较键之前使用 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 来使其小写：</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="7cfc93ae0f30aa1f0666b1f4bcb636c1b64a91aa" translate="yes" xml:space="preserve">
          <source>For integer conversions, specifying a precision implies that the output of the number itself should be zero-padded to this width, where the 0 flag is ignored:</source>
          <target state="translated">对于整数转换来说,指定一个精度意味着数字本身的输出应该被零填充到这个宽度,其中0标志被忽略。</target>
        </trans-unit>
        <trans-unit id="ecd617b52663df6a2cd98775b9d0bdd10ec28a70" translate="yes" xml:space="preserve">
          <source>For intrepid programmers, the indispensable textbook is</source>
          <target state="translated">对于无畏的程序员来说,不可缺少的教科书是</target>
        </trans-unit>
        <trans-unit id="d3c8026914e8193ab94f632a808acbe08f5e1e3d" translate="yes" xml:space="preserve">
          <source>For licensing inquiries, contact the author at:</source>
          <target state="translated">有关许可证的询问,请与提交人联系:</target>
        </trans-unit>
        <trans-unit id="ce2ac808344a2fda3717bca04925f57752ba466c" translate="yes" xml:space="preserve">
          <source>For licensing the easiest way is to use the same licensing as Perl itself:</source>
          <target state="translated">对于授权,最简单的方法是使用与Perl本身相同的授权。</target>
        </trans-unit>
        <trans-unit id="22eb832a816ecf29dad84d085c065a38bc3edb22" translate="yes" xml:space="preserve">
          <source>For locales available in your system, consult also</source>
          <target state="translated">关于您的系统中可用的区域,也请咨询</target>
        </trans-unit>
        <trans-unit id="863f28adc13f8c8f63960f8d4f2a4b8a92bd94fd" translate="yes" xml:space="preserve">
          <source>For lookup of</source>
          <target state="translated">用于查询</target>
        </trans-unit>
        <trans-unit id="34229681f9d4faff26200baa4f876a94429acced" translate="yes" xml:space="preserve">
          <source>For low-level access to the formatting mechanism, you may use formline() and access &lt;code&gt;$^A&lt;/code&gt; (the $ACCUMULATOR variable) directly.</source>
          <target state="translated">要对格式设置机制进行低级访问，可以使用formline（）并直接访问 &lt;code&gt;$^A&lt;/code&gt; （$ ACCUMULATOR变量）。</target>
        </trans-unit>
        <trans-unit id="dda78cd120d71d7294ab5327cc0bc80f1754e64b" translate="yes" xml:space="preserve">
          <source>For lower-level direct manipulation of &lt;code&gt;op_sibparent&lt;/code&gt; and &lt;code&gt;op_moresib&lt;/code&gt; , see &lt;code&gt;OpMORESIB_set&lt;/code&gt; , &lt;code&gt;OpLASTSIB_set&lt;/code&gt; , &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; .</source>
          <target state="translated">有关 &lt;code&gt;op_sibparent&lt;/code&gt; 和 &lt;code&gt;op_moresib&lt;/code&gt; 的较低级别的直接操作，请参见 &lt;code&gt;OpMORESIB_set&lt;/code&gt; ， &lt;code&gt;OpLASTSIB_set&lt;/code&gt; 和 &lt;code&gt;OpMAYBESIB_set&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a2710d99c8e59b0ca1361e7bf2da876fb54697f" translate="yes" xml:space="preserve">
          <source>For maintenance clarity, no functions are exported by default. These functions are available for backwards compatibility only and are best avoided in favor of &lt;code&gt;load_file&lt;/code&gt; .</source>
          <target state="translated">为了维护清晰起见，默认情况下不导出任何功能。这些函数仅可用于向后兼容，最好避免使用 &lt;code&gt;load_file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66d2d5bbea31d0eff0a07151ddd0f30d9798a0b6" translate="yes" xml:space="preserve">
          <source>For many Perl functions, the CORE package contains real subroutines. This feature is new in Perl 5.16. You can take references to these and make aliases. However, some can only be called as barewords; i.e., you cannot use ampersand syntax (&lt;code&gt;&amp;amp;foo&lt;/code&gt; ) or call them through references. See the &lt;code&gt;shove&lt;/code&gt; example above. These subroutines exist for all keywords except the following:</source>
          <target state="translated">对于许多Perl函数，CORE包包含实际的子例程。此功能是Perl 5.16中的新增功能。您可以引用这些文件并做别名。但是，有些只能称为裸词；即，您不能使用＆语法（ &lt;code&gt;&amp;amp;foo&lt;/code&gt; ）或通过引用对其进行调用。请参阅上面的 &lt;code&gt;shove&lt;/code&gt; 例。这些子例程适用于除以下内容以外的所有关键字：</target>
        </trans-unit>
        <trans-unit id="8ef8504526bafcd83f659e5d29383951a3389b63" translate="yes" xml:space="preserve">
          <source>For many common uses of the module, the read cache is a liability. For example, a program that inserts a single record, or that scans the file once, will have a cache hit rate of zero. This suggests a major optimization: The cache should be initially disabled. Here's a hybrid approach: Initially, the cache is disabled, but the cache code maintains statistics about how high the hit rate would be *if* it were enabled. When it sees the hit rate get high enough, it enables itself. The STAT comments in this code are the beginning of an implementation of this.</source>
          <target state="translated">对于该模块的许多常见用途,读缓存是个累赘。例如,一个只插入一条记录的程序,或者扫描一次文件的程序,其缓存命中率为零。这说明需要进行重大优化。缓存应该被初始化。这里有一个混合方法。起初,缓存是被禁用的,但缓存代码会维护统计 如果它被启用,命中率会有多高。当它看到命中率变得足够高时,它就会自己启用。这段代码中的STAT注释是实现这个的开始。</target>
        </trans-unit>
        <trans-unit id="e0f179826fe2c92a37ede899dfe2a03f1a5c458a" translate="yes" xml:space="preserve">
          <source>For many functions, you can also query &lt;code&gt;%Config&lt;/code&gt; , exported by default from the &lt;code&gt;Config&lt;/code&gt; module. For example, to check whether the platform has the &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, check &lt;code&gt;$Config{d_lstat}&lt;/code&gt; . See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for a full description of available variables.</source>
          <target state="translated">对于许多功能，您还可以查询默认情况下从 &lt;code&gt;Config&lt;/code&gt; 模块导出的 &lt;code&gt;%Config&lt;/code&gt; 。例如，要检查平台是否具有 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 调用，请检查 &lt;code&gt;$Config{d_lstat}&lt;/code&gt; 。有关可用变量的完整说明，请参见&lt;a href=&quot;config&quot;&gt;配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efd5a9c50ebfeb1864b8fd6e6ed8e999df584565" translate="yes" xml:space="preserve">
          <source>For many people, Perl serves as a great replacement for shell scripting. For others, it serves as a convenient, high-level replacement for most of what they'd program in low-level languages like C or C++. It's ultimately up to you (and possibly your management) which tasks you'll use Perl for and which you won't.</source>
          <target state="translated">对许多人来说,Perl是shell脚本的最佳替代品。对其他人来说,它可以方便地、高级地替代他们用C或C++等低级语言编程的大部分内容。哪些任务要用Perl,哪些不用,最终取决于你(可能还有你的管理层)。</target>
        </trans-unit>
        <trans-unit id="9b046ce891b8b5f7d7f37e47256b7841d3461b86" translate="yes" xml:space="preserve">
          <source>For many typemap examples, refer to the core typemap file that can be found in the perl source tree at</source>
          <target state="translated">关于许多类型地图的例子,请参考核心类型地图文件,该文件可以在perl源代码树中找到,网址是</target>
        </trans-unit>
        <trans-unit id="a0610ac0b02cfa9a7d3209596fa010908429083d" translate="yes" xml:space="preserve">
          <source>For maximum security, endeavour always to avoid ever looking at, touching, or even imputing the existence of the filename. You do not know that that filename is connected to the same file as the handle you have, and attempts to check this can only trigger more race conditions. It's far more secure to use the filehandle alone and dispense with the filename altogether.</source>
          <target state="translated">为了最大限度的安全起见,尽量避免查看、触摸、甚至推断文件名的存在,你不知道那个文件名与你的句柄连接在一起,而试图检查这一点只会引发更多的竞赛条件。你不知道那个文件名与你所拥有的句柄连接在同一个文件上,而试图检查这一点只会引发更多的竞赛条件。单独使用filehandle而完全不使用文件名,要安全得多。</target>
        </trans-unit>
        <trans-unit id="220ffe1d077d6e4643b22c57e942ba4049701e75" translate="yes" xml:space="preserve">
          <source>For measuring time in better granularity than one second, use the &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module from Perl 5.8 onwards (or from CPAN before then), or, if you have gettimeofday(2), you may be able to use the &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface of Perl. See &lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">要以比一秒更好的粒度来测量时间，请使用Perl 5.8及更高版本（或之前的CPAN）中的&lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;模块，或者，如果您具有gettimeofday（2），则可以使用Perl 的 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 界面。有关详细信息，请参见&lt;a href=&quot;../perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b053fd32cc090c58c85994234835bd9b44b038f0" translate="yes" xml:space="preserve">
          <source>For measuring time in better granularity than one second, use the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module from Perl 5.8 onwards (or from CPAN before then), or, if you have gettimeofday(2), you may be able to use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; interface of Perl. See &lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt; for details.</source>
          <target state="translated">要以比一秒更好的粒度来测量时间，请使用Perl 5.8及更高版本（或之前的CPAN）中的&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;模块，或者，如果您具有gettimeofday（2），则可以使用Perl 的 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 界面。有关详细信息，请参见&lt;a href=&quot;perlfaq8&quot;&gt;perlfaq8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a7dc3da9f9150a0f4e59b825d03d586115ca6af" translate="yes" xml:space="preserve">
          <source>For modules which ARE classes, and need to handle inherited methods, stubs are needed to ensure that the method inheritance mechanism works properly. You can load the stubs into the module at 'require' time, by adding the statement 'SelfLoader-&amp;gt;load_stubs();' to the module to do this.</source>
          <target state="translated">对于属于ARE类且需要处理继承方法的模块，需要存根以确保方法继承机制正常运行。您可以在'require'时通过添加语句'SelfLoader-&amp;gt; load_stubs（）;'将存根加载到模块中。到模块执行此操作。</target>
        </trans-unit>
        <trans-unit id="25217607f7b7b4f54ca08eb0f1fc36241da39944" translate="yes" xml:space="preserve">
          <source>For modules which are not classes, this section is not relevant. This section is only relevant if you have methods which could be inherited.</source>
          <target state="translated">对于不是类的模块,本节与之无关。只有当你的方法可以被继承的时候,本节才是相关的。</target>
        </trans-unit>
        <trans-unit id="29a15f44066dff1f2c0c9c7cbcbbd443cbb90819" translate="yes" xml:space="preserve">
          <source>For modules, get the CGI or LWP modules from CPAN. For textbooks, see the two especially dedicated to web stuff in the question on books. For problems and questions related to the web, like &quot;Why do I get 500 Errors&quot; or &quot;Why doesn't it run from the browser right when it runs fine on the command line&quot;, see the troubleshooting guides and references in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; or in the CGI MetaFAQ:</source>
          <target state="translated">对于模块，请从CPAN获取CGI或LWP模块。对于教科书，请参阅书本问题中的两本专门针对网络内容的书。对于与Web有关的问题，例如&amp;ldquo;为什么我会出现500个错误&amp;rdquo;或&amp;ldquo;为什么它无法在命令行上正常运行时不能从浏览器中正确运行&amp;rdquo;，请参见&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;或CGI MetaFAQ：</target>
        </trans-unit>
        <trans-unit id="c19610a9a975a0cf5248edf9977288237aa0d121" translate="yes" xml:space="preserve">
          <source>For more about scripts versus blocks, see UAX#24 &quot;Unicode Script Property&quot;: &lt;a href=&quot;http://www.unicode.org/reports/tr24&quot;&gt;http://www.unicode.org/reports/tr24&lt;/a&gt;</source>
          <target state="translated">有关脚本与块的更多信息，请参见UAX＃24&amp;ldquo; Unicode脚本属性&amp;rdquo;：&lt;a href=&quot;http://www.unicode.org/reports/tr24&quot;&gt;http&lt;/a&gt; : //www.unicode.org/reports/tr24</target>
        </trans-unit>
        <trans-unit id="a0f84e3d4e18aa471a205e575dceae5b441a5a9b" translate="yes" xml:space="preserve">
          <source>For more benchmark results see &lt;a href=&quot;http://bloodgate.com/perl/benchmarks.html&quot;&gt;http://bloodgate.com/perl/benchmarks.html&lt;/a&gt;.</source>
          <target state="translated">有关更多基准测试结果，请参见&lt;a href=&quot;http://bloodgate.com/perl/benchmarks.html&quot;&gt;http://bloodgate.com/perl/benchmarks.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7a12676c43bab4536e6ed20980a2aaf16b4eccc1" translate="yes" xml:space="preserve">
          <source>For more complex signal handling, you might see the standard POSIX module. Lamentably, this is almost entirely undocumented, but the</source>
          <target state="translated">对于更复杂的信号处理,你可能会看到标准的POSIX模块。遗憾的是,这个模块几乎完全没有被记录下来,但是</target>
        </trans-unit>
        <trans-unit id="be1e0dddb201330ac943f0c7f8b66035ebd2739a" translate="yes" xml:space="preserve">
          <source>For more detail on each item in this checklist, see below.</source>
          <target state="translated">关于本检查表中每个项目的详细情况,请见下文。</target>
        </trans-unit>
        <trans-unit id="b905a813e9b57da3dea6d150de2f4e3eac205961" translate="yes" xml:space="preserve">
          <source>For more detail on looping constructs (and some that weren't mentioned in this overview) see &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">有关循环构造（以及本概述中未提到的一些构造）的更多详细信息，请参见&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9cce3d22b488b424d06498a184d62a8579f8068a" translate="yes" xml:space="preserve">
          <source>For more detailed explanation of the available commands and output formats, see your own local documentation of</source>
          <target state="translated">关于可用命令和输出格式的更多详细说明,请参见您自己的本地文档中的</target>
        </trans-unit>
        <trans-unit id="191b44055a5c64626669b9bb810cf968868b2305" translate="yes" xml:space="preserve">
          <source>For more detailed information, see &lt;a href=&quot;http://unicode.org/reports/tr15/&quot;&gt;http://unicode.org/reports/tr15/&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;http://unicode.org/reports/tr15/&quot;&gt;http://unicode.org/reports/tr15/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71e7ea87ff241717fc4e23b38966813c9a86baa7" translate="yes" xml:space="preserve">
          <source>For more details (FAQ), check out the home of DJGPP at:</source>
          <target state="translated">更多详情(常见问题解答),请查看DJGPP的主页:。</target>
        </trans-unit>
        <trans-unit id="2b7ea18856481cbfb2fbce20aa82b169672d93cb" translate="yes" xml:space="preserve">
          <source>For more details on Unicode properties, see &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Unicode Character Properties in perlunicode&lt;/a&gt;; for a complete list of possible properties, see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;, which notes all forms that have &lt;code&gt;/i&lt;/code&gt; differences. It is also possible to define your own properties. This is discussed in &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">有关Unicode属性的更多详细信息，请参见&lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;perlunicode中的Unicode字符属性&lt;/a&gt;。有关可能的属性的完整列表，请参见&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perluniprops中可通过\ p {}和\ P {}访问的属性&lt;/a&gt;，其中记录了所有具有 &lt;code&gt;/i&lt;/code&gt; 差异的形式。也可以定义自己的属性。&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;在perlunicode&lt;/a&gt;中的用户定义字符属性中对此进行了讨论。</target>
        </trans-unit>
        <trans-unit id="2cbbe4fe0a4baf76f7b9458c97576bdbd741475c" translate="yes" xml:space="preserve">
          <source>For more details on regular expression efficiency, see</source>
          <target state="translated">关于正则表达式效率的更多细节,请参见</target>
        </trans-unit>
        <trans-unit id="ebe9afb005e64603315c0b4b48ed47e449ce83f7" translate="yes" xml:space="preserve">
          <source>For more details on the mechanics of skip and todo tests see &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">有关跳过和待办事项测试机制的更多详细信息，请参见&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7baab4b3bb4b02cd4142daf0edbd11721551241c" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f61d1799248ab35eaa772a394c6295835033e37c" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;sources&lt;/code&gt; parameter in &lt;a href=&quot;parser#new&quot;&gt;new in TAP::Parser&lt;/a&gt;, &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, and &lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;parser#new&quot;&gt;TAP :: Parser&lt;/a&gt;，&lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;和&lt;a href=&quot;parser/iteratorfactory&quot;&gt;TAP :: Parser :: IteratorFactory&lt;/a&gt;中new的 &lt;code&gt;sources&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="8d792a0910cc22b1db3814d0f9e477cca4ea1652" translate="yes" xml:space="preserve">
          <source>For more details, see the documentation and code of &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; and &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;base&quot;&gt;base&lt;/a&gt;和&lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt;的文档和代码。</target>
        </trans-unit>
        <trans-unit id="e28556232fac8aa9e7b56eb26466d9231a13cb3c" translate="yes" xml:space="preserve">
          <source>For more details, see the individual descriptions at &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">有关更多详细信息，请参见 &lt;code&gt;$@&lt;/code&gt; ， &lt;code&gt;$!&lt;/code&gt; 中的个别说明。， &lt;code&gt;$^E&lt;/code&gt; 和 &lt;code&gt;$?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cfca851970ab4784648ba74e553f012851bc695" translate="yes" xml:space="preserve">
          <source>For more information about case mappings see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21&quot;&gt;http://www.unicode.org/unicode/reports/tr21&lt;/a&gt;</source>
          <target state="translated">有关案例映射的更多信息，请参见&lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21&quot;&gt;http://www.unicode.org/unicode/reports/tr21&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a52fba09ce9a3f5f4483e33536b3e5c091d8d89a" translate="yes" xml:space="preserve">
          <source>For more information about case mappings see &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;</source>
          <target state="translated">有关案例映射的更多信息，请参见&lt;a href=&quot;http://www.unicode.org/unicode/reports/tr21/&quot;&gt;http://www.unicode.org/unicode/reports/tr21/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a7f733567279e64844bd80ab92f020d566ce85e" translate="yes" xml:space="preserve">
          <source>For more information about encodings--for instance, to learn what</source>
          <target state="translated">有关编码的更多信息--例如,要了解什么是</target>
        </trans-unit>
        <trans-unit id="2561ce48ee706059d4bfdc21d19fd5f166cfc40f" translate="yes" xml:space="preserve">
          <source>For more information about the portability of these functions, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; and other available platform-specific documentation.</source>
          <target state="translated">有关这些功能的可移植性的更多信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;和其他可用的平台特定文档。</target>
        </trans-unit>
        <trans-unit id="e0b48a366c382047ff56f3b46da60ad7835f72b7" translate="yes" xml:space="preserve">
          <source>For more information on Pod, check out &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; and &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">有关Pod的更多信息，请查看&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;和&lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7368b700a1d6f50c9c2914d3baee02fbd55cba3c" translate="yes" xml:space="preserve">
          <source>For more information on any of these modules, please see its respective documentation.</source>
          <target state="translated">有关这些模块的更多信息,请参见其各自的文档。</target>
        </trans-unit>
        <trans-unit id="416652247fb1fd02b42bcffea330cb4fb44ecfe8" translate="yes" xml:space="preserve">
          <source>For more information on file locking, see also &lt;a href=&quot;perlopentut#File-Locking&quot;&gt;File Locking in perlopentut&lt;/a&gt; if you have it (new for 5.6).</source>
          <target state="translated">有关文件锁定的更多信息，请参阅&lt;a href=&quot;perlopentut#File-Locking&quot;&gt;perlopentut中的文件锁定（&lt;/a&gt;如果有的话）（5.6新增功能）。</target>
        </trans-unit>
        <trans-unit id="099e98950b7e5d3724fc0c2a1b6e16e56fceb5bc" translate="yes" xml:space="preserve">
          <source>For more information on output layers, see the entries for &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and the &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; module documentation.</source>
          <target state="translated">有关输出层的更多信息，请参见 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 和在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;的条目以及&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;模块文档。</target>
        </trans-unit>
        <trans-unit id="e818032a9be9224ab5cbe363750ba1600bb48228" translate="yes" xml:space="preserve">
          <source>For more information on references and blessings, consult &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">有关参考和祝福的更多信息，请参阅&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3875443a1c771cfef5af62913463726b3c0dc4e" translate="yes" xml:space="preserve">
          <source>For more information on the Perl internals, please see the documents listed at &lt;a href=&quot;perl#Internals-and-C-Language-Interface&quot;&gt;Internals and C Language Interface in perl&lt;/a&gt;.</source>
          <target state="translated">有关Perl内部结构的更多信息，请参阅&lt;a href=&quot;perl#Internals-and-C-Language-Interface&quot;&gt;perl&lt;/a&gt;中内部结构和C语言接口中列出的文档。</target>
        </trans-unit>
        <trans-unit id="7e1c38bc7063ae4d32b5c046d7a962931ee4b2aa" translate="yes" xml:space="preserve">
          <source>For more information on the matching &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; and substitution &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operators, see &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. For information on the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operation, see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">有关匹配的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 和替代 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp Quote-Like运算符&lt;/a&gt;。有关 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 操作的信息，请参见&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d861195f361843be9490e2a15ea16594084c17c5" translate="yes" xml:space="preserve">
          <source>For more information on these options, you can run &lt;code&gt;perldoc perlrun&lt;/code&gt; .</source>
          <target state="translated">有关这些选项的更多信息，可以运行 &lt;code&gt;perldoc perlrun&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae1bf8b301cb7d0e378d5bfae6b8ca1419913f8d" translate="yes" xml:space="preserve">
          <source>For more information on writing subroutines, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">有关编写子例程的更多信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54bca26b413776465d316ff152cfba7e50928bfd" translate="yes" xml:space="preserve">
          <source>For more information see &quot;man strptime&quot;, which should be on all unix systems.</source>
          <target state="translated">更多信息请参见 &quot;man strptime&quot;,它应该在所有的unix系统上使用。</target>
        </trans-unit>
        <trans-unit id="e1baf9669b89021435a3869d8ee27cb001b8531d" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a8c608dc66ccc771771da6fa1ec2512b26eb2f6" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f020267b66a1cdd001af710aa00960332272626" translate="yes" xml:space="preserve">
          <source>For more information, consult &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请查阅&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;，&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;，&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;，&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34baaca1017f55f5261393ae901ca335f5962ac3" translate="yes" xml:space="preserve">
          <source>For more information, consult &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请查阅&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d20dd1c8dbc4552d5c14d5ca92e5a6e145a49a2" translate="yes" xml:space="preserve">
          <source>For more information, including instructions for other platforms such as Windows and Mac OS, read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，包括Windows和Mac OS等其他平台的说明，请阅读&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f6b2985afc24c6ba2ce53974a41c02581d47c16" translate="yes" xml:space="preserve">
          <source>For more on references see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;</source>
          <target state="translated">有关参考的更多信息，请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;和&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="570bd0b65c4a2212785bd93937b2532931fb04d1" translate="yes" xml:space="preserve">
          <source>For more on the implications and differences between character semantics and byte semantics, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">有关字符语义和字节语义之间的含义和区别的更多信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db99609d275f010ab9ef2f1e664305363a10f9ac" translate="yes" xml:space="preserve">
          <source>For more on this, see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;和&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="272ef40c7df3b1032622640835458da768522456" translate="yes" xml:space="preserve">
          <source>For more up-to-date information, see &lt;a href=&quot;https://metacpan.org/release/ExtUtils-MakeMaker&quot;&gt;https://metacpan.org/release/ExtUtils-MakeMaker&lt;/a&gt;.</source>
          <target state="translated">有关更多最新信息，请参见&lt;a href=&quot;https://metacpan.org/release/ExtUtils-MakeMaker&quot;&gt;https://metacpan.org/release/ExtUtils-MakeMaker&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc54ba1fbc7345fca3a79ce3cc6b3a13627fa07b" translate="yes" xml:space="preserve">
          <source>For most list operators, the check function expects all the kid ops to be present already, so calling &lt;code&gt;newLISTOP(OP_JOIN, ...)&lt;/code&gt; (e.g.) is not appropriate. What you want to do in that case is create an op of type OP_LIST, append more children to it, and then call &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt;. See &lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt; for more information.</source>
          <target state="translated">对于大多数列表运算符，检查功能希望所有孩子操作都已经存在，因此调用 &lt;code&gt;newLISTOP(OP_JOIN, ...)&lt;/code&gt; （例如）是不合适的。在这种情况下，您要执行的操作是创建类型为OP_LIST的op，为其添加更多子代，然后调用&lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt;。有关更多信息，请参见&lt;a href=&quot;#op_convert_list&quot;&gt;op_convert_list&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="641019bad56b8716009f9130458dd08e4eb5dd36" translate="yes" xml:space="preserve">
          <source>For most purposes, access to Unicode properties from the Perl core is through regular expression matches, as described in the next section. For some special purposes, and to access the properties that are not suitable for regular expression matching, all the Unicode character properties that Perl handles are accessible via the standard &lt;a href=&quot;unicode/ucd&quot;&gt;Unicode::UCD&lt;/a&gt; module, as described in the section &lt;a href=&quot;#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">对于大多数目的，从Perl内核访问Unicode属性是通过正则表达式匹配，如下一节所述。出于某些特殊目的，并且为了访问不适用于正则表达式匹配的属性，可以通过标准&lt;a href=&quot;unicode/ucd&quot;&gt;Unicode :: UCD&lt;/a&gt;模块访问Perl处理的所有Unicode字符属性，如&lt;a href=&quot;#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;通过Unicode :: UCD访问的属性&lt;/a&gt;一节中所述。。</target>
        </trans-unit>
        <trans-unit id="8d5ede1c7a0a1dfb0fe304691530ed6a243c7af0" translate="yes" xml:space="preserve">
          <source>For most use-cases the behavior described above is acceptable (this module and it's predecessor, &lt;code&gt;Compress::Zlib&lt;/code&gt; , have used it for over 10 years without an issue), but in a few very specific use-cases the amount of memory required for &lt;code&gt;$output&lt;/code&gt; can prohibitively large. For example, if the compressed data stream contains the same pattern repeated thousands of times, a relatively small compressed data stream can uncompress into hundreds of megabytes. Remember &lt;code&gt;inflate&lt;/code&gt; will keep allocating memory until</source>
          <target state="translated">在大多数用例中，上述行为是可以接受的（此模块及其前身 &lt;code&gt;Compress::Zlib&lt;/code&gt; 使用了10多年没有问题），但是在一些非常特定的用例中，所需的内存量 &lt;code&gt;$output&lt;/code&gt; 可能会过大。例如，如果压缩数据流包含重复数千次的相同模式，则相对较小的压缩数据流可以解压缩为数百兆字节。记住 &lt;code&gt;inflate&lt;/code&gt; 会一直分配内存，直到</target>
        </trans-unit>
        <trans-unit id="a47940c15fef4c6625772cdc1427a983c441c3c1" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Bzip2 object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Compress :: Bzip2对象被销毁（无论是显式的还是由引用该对象的变量超出范围），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="adee5e79d5d3d779e5af1d2aba42639fd752741d" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Deflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Compress :: Deflate对象被销毁（无论是显式的还是由引用该对象的变量超出范围），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="ddb04253a83c249a7e883f277739dcda8e2faecb" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Gzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Compress :: Gzip对象被销毁（无论是显式的还是由引用该对象超出范围的变量），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="4db349e7c47820dab5028b29921ade4c7bb32501" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::RawDeflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Compress :: RawDeflate对象被销毁（无论是显式的还是由引用该对象超出范围的变量），此方法将自动被调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="8861e38ef9ff01891126a94c9ec532f08b55ad77" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Compress::Zip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Compress :: Zip对象被销毁（无论是显式的还是由引用该对象超出范围的变量），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="1a5826884fe147f7ccc4745dc4c0dec56e5a8942" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::AnyInflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: AnyInflate对象被销毁（无论是显式的还是由引用该对象超出范围的变量），该方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="000b46928e33aec75c1330e3f6828a697055beec" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::AnyUncompress object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: AnyUncompress对象被销毁（无论是显式的还是由引用该对象的变量超出范围），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="621ae7f532cdf338357018b0efb4e6b8937e23cb" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Bunzip2 object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: Bunzip2对象被销毁（无论是显式的还是由引用该对象超出范围的变量），此方法将自动被调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="5ebe07c14944aa0924ad00011dbfa6cf95fcffd3" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Gunzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: Gunzip对象被销毁（无论是显式的还是由引用该对象超出范围的变量），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="02829219c19fdbb8502226558182b539540ef773" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Inflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: Inflate对象被销毁（显式或由引用对象的变量超出范围），该方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="39bac215cf7e9ee43af43133ee6260672e9eebea" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::RawInflate object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: RawInflate对象被销毁（无论是显式的还是由引用该对象的变量超出范围），此方法将被自动调用。 Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但是要等到程序终止时全局销毁所有活动对象后，才会自动调用close方法。</target>
        </trans-unit>
        <trans-unit id="a0e9e60d5738504f44dbe5db42b611750817984b" translate="yes" xml:space="preserve">
          <source>For most versions of Perl this method will be automatically invoked if the IO::Uncompress::Unzip object is destroyed (either explicitly or by the variable with the reference to the object going out of scope). The exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In these cases, the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method will be called automatically, but not until global destruction of all live objects when the program is terminating.</source>
          <target state="translated">对于大多数版本的Perl，如果IO :: Uncompress :: Unzip对象被销毁（显式地或通过引用对象的变量超出范围），该方法将被自动调用。Perl版本5.005至5.00504和5.8.0除外。在这些情况下，将自动调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法，但要等到程序终止时全局调用所有活动对象后，该方法才会被自动调用。</target>
        </trans-unit>
        <trans-unit id="ebd39cf1198af939c9fe739680f896002c72f24d" translate="yes" xml:space="preserve">
          <source>For much more detail on using git with the Perl repository, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;.</source>
          <target state="translated">有关在Perl存储库中使用git的更多详细信息，请参见&lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd2242f4fd4838cfce99d23a663a50e2e5c87ecf" translate="yes" xml:space="preserve">
          <source>For multilevel structures, you may wish to use an approach more like this one. It uses the CPAN module &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt;:</source>
          <target state="translated">对于多层结构，您可能希望使用一种类似这种方法。它使用CPAN模块&lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4aaeeb42eefa8440218480ef685b6c057da2ebd8" translate="yes" xml:space="preserve">
          <source>For native multibyte encodings (either fixed or variable length), the current implementation of the regular expressions may introduce recoding errors for regular expression literals longer than 127 bytes.</source>
          <target state="translated">对于本机多字节编码(无论是固定长度还是可变长度),当前正则表达式的实现可能会对长度超过127字节的正则表达式字元引入重编码错误。</target>
        </trans-unit>
        <trans-unit id="db0739f14c22b332e1c9ef31d85863c468a6ec30" translate="yes" xml:space="preserve">
          <source>For natural language processing (so that, for example, apostrophes are included in words), use instead &lt;code&gt;\b{wb}&lt;/code&gt;</source>
          <target state="translated">对于自然语言处理（例如，单词中包含撇号），请改用 &lt;code&gt;\b{wb}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34e4b4c1e84670ba2445432138762ce8b98922fa" translate="yes" xml:space="preserve">
          <source>For negative numbers in base see also &lt;a href=&quot;#brsft()&quot;&gt;brsft&lt;/a&gt;.</source>
          <target state="translated">有关基数中的负数，另请参见&lt;a href=&quot;#brsft()&quot;&gt;brsft&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="11739ff4ce5853fede0de1666a77252b4cca5762" translate="yes" xml:space="preserve">
          <source>For numbers in the range 160 (0x00A0) to 255 (0x00FF), this maps from the character code for a Latin-1 character (like 233 for lowercase e-acute) to the US-ASCII character that best aproximates it (like &quot;e&quot;). You may find this useful if you are rendering POD in a format that you think deals well only with US-ASCII characters.</source>
          <target state="translated">对于 160 (0x00A0)到 255 (0x00FF)范围内的数字,这是从拉丁文 1 字符的字符代码 (如 233 的小写 e-acute)映射到最接近它的 US-ASCII 字符 (如 &quot;e&quot;)。如果您在渲染POD时使用的格式是您认为仅能处理US-ASCII字符的格式,您可能会发现这很有用。</target>
        </trans-unit>
        <trans-unit id="0418167b8295aaa112b520d273cbff7734fb4037" translate="yes" xml:space="preserve">
          <source>For numeric conversions, you can specify the size to interpret the number as using &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; . For integer conversions (&lt;code&gt;d u o x X b i D U O&lt;/code&gt; ), numbers are usually assumed to be whatever the default integer size is on your platform (usually 32 or 64 bits), but you can override this to use instead one of the standard C types, as supported by the compiler used to build Perl:</source>
          <target state="translated">对于数字转换，您可以使用 &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; 或 &lt;code&gt;ll&lt;/code&gt; 指定大小来解释数字。对于整数转换（ &lt;code&gt;d u o x X b i D U O&lt;/code&gt; ），通常假定数字为平台上默认整数的大小（通常为32或64位），但是您可以覆盖此值以替代使用标准C类型之一（受支持）由用于构建Perl的编译器：</target>
        </trans-unit>
        <trans-unit id="3f073c1258e51f971ca716359b2a89c0272776c0" translate="yes" xml:space="preserve">
          <source>For numeric conversions, you can specify the size to interpret the number as using &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; , or &lt;code&gt;ll&lt;/code&gt; . For integer conversions (&lt;code&gt;d u o x X b i D U O&lt;/code&gt; ), numbers are usually assumed to be whatever the default integer size is on your platform (usually 32 or 64 bits), but you can override this to use instead one of the standard C types, as supported by the compiler used to build Perl:</source>
          <target state="translated">对于数字转换，您可以使用 &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; 或 &lt;code&gt;ll&lt;/code&gt; 指定大小来解释数字。对于整数转换（ &lt;code&gt;d u o x X b i D U O&lt;/code&gt; ），通常假定数字为平台上默认整数的大小（通常为32或64位），但是您可以覆盖此值以替代使用标准C类型之一（受支持）由用于构建Perl的编译器：</target>
        </trans-unit>
        <trans-unit id="59b31b25c9f5d592cd415ce42cd1cd5b58c1c703" translate="yes" xml:space="preserve">
          <source>For objects, a method, &lt;code&gt;CARP_TRACE&lt;/code&gt; , will be called, if it exists. If this method doesn't exist, or it recurses into &lt;code&gt;Carp&lt;/code&gt; , or it otherwise throws an exception, this is skipped, and Carp moves on to the next option, otherwise checking stops and the string returned is used. It is recommended that the object's type is part of the string to make debugging easier.</source>
          <target state="translated">对于对象，将调用 &lt;code&gt;CARP_TRACE&lt;/code&gt; 方法（如果存在）。如果此方法不存在，或者递归到 &lt;code&gt;Carp&lt;/code&gt; 中，或者抛出异常，则将其跳过，然后Carp转到下一个选项，否则检查停止并使用返回的字符串。建议对象的类型是字符串的一部分，以使调试更加容易。</target>
        </trans-unit>
        <trans-unit id="34e2a99f6a2eb99d86babea525e84b0d07848c0f" translate="yes" xml:space="preserve">
          <source>For old code and interim backwards compatibility, the &lt;code&gt;Thread&lt;/code&gt; module has been reworked to function as a frontend for the new interpreter threads (</source>
          <target state="translated">为了实现旧代码和临时向后兼容，对 &lt;code&gt;Thread&lt;/code&gt; 模块进行了重新设计，使其可以用作新解释器线程的前端（</target>
        </trans-unit>
        <trans-unit id="54678b0f46a42f75ba9339772dde807022e3f850" translate="yes" xml:space="preserve">
          <source>For options that take list or hash values, it is necessary to indicate this by appending an &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; sign after the type:</source>
          <target state="translated">对于采用列表或哈希值的选项，有必要通过在类型之后附加 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 符号来表明这一点：</target>
        </trans-unit>
        <trans-unit id="ed4fe0865e6bc07b5c076581d59bd74aedec7133" translate="yes" xml:space="preserve">
          <source>For options that take values it must be specified whether the option value is required or not, and what kind of value the option expects.</source>
          <target state="translated">对于取值的期权,必须指定是否需要期权值,以及期权期望的值是什么样的。</target>
        </trans-unit>
        <trans-unit id="14b3ef641443710b672e456ac43669f979bd2658" translate="yes" xml:space="preserve">
          <source>For ordinary files you can also use the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">对于普通文件，您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="18923d06b00ab1b78a669fe54fca08f48f38928d" translate="yes" xml:space="preserve">
          <source>For other Perl-based conversion options see the &lt;code&gt;Convert::*&lt;/code&gt; modules on CPAN.</source>
          <target state="translated">有关其他基于Perl的转换选项，请参见CPAN上的 &lt;code&gt;Convert::*&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="ecf4231003ccccf0ccb3fdcd4e5a986799fbca1f" translate="yes" xml:space="preserve">
          <source>For other filetypes, like &lt;code&gt;chardevs&lt;/code&gt; and &lt;code&gt;blockdevs&lt;/code&gt; we'll warn that the extraction of this particular item didn't work.</source>
          <target state="translated">对于其它文件类型，如 &lt;code&gt;chardevs&lt;/code&gt; 和 &lt;code&gt;blockdevs&lt;/code&gt; 我们会警告说，这个特殊项目的提取没有工作。</target>
        </trans-unit>
        <trans-unit id="a61d39f00af378aaa32b4a9a3dedd635bdcf3408" translate="yes" xml:space="preserve">
          <source>For other locales, starting in Perl 5.16, you can specify</source>
          <target state="translated">对于其他地区,从Perl 5.16开始,你可以指定使用</target>
        </trans-unit>
        <trans-unit id="55153fcdbe0c92eb8adc0abec175ecdf7f05a3ca" translate="yes" xml:space="preserve">
          <source>For other termination statuses, the severity portion of the subprocess's exit status is used: if the severity was success or informational, these bits are all 0; if the severity was warning, they contain a value of 1; if the severity was error or fatal error, they contain the actual severity bits, which turns out to be a value of 2 for error and 4 for severe_error. Fatal is another term for the severe_error status.</source>
          <target state="translated">对于其他终止状态,则使用子进程退出状态的severity部分:如果severity是成功或信息,这些位都是0;如果severity是警告,则包含1的值;如果severity是错误或致命错误,则包含实际的severity位,原来错误的值是2,severe_error的值是4。fatal是severe_error状态的另一个术语。</target>
        </trans-unit>
        <trans-unit id="d9c9ebb36f114d2e29800b2f2a876e7e2d770bfb" translate="yes" xml:space="preserve">
          <source>For our File::MP3 class, we can check to make sure that the path we're given ends with &quot;.mp3&quot;:</source>
          <target state="translated">对于我们的File::MP3类,我们可以检查我们所给的路径是否以&quot;.mp3 &quot;结尾。</target>
        </trans-unit>
        <trans-unit id="90aad3aef5b3704234dd7e152135fa69067f60cd" translate="yes" xml:space="preserve">
          <source>For our example, we want to be able to emit debugging info to help in tracing during development. We keep also one convenience function around internally to help print out warnings; whowasi() returns the function name that calls it.</source>
          <target state="translated">在我们的例子中,我们希望能够发出调试信息,以帮助在开发过程中进行跟踪。我们还在内部保留了一个方便的函数来帮助打印警告;whowasi()返回调用它的函数名。</target>
        </trans-unit>
        <trans-unit id="aa18cdabf84f58c0c8a60b20d7ee4d847450d128" translate="yes" xml:space="preserve">
          <source>For our example, we're using a real hash so we'll do just the simple thing, but we'll have to go through the LIST field indirectly.</source>
          <target state="translated">对于我们的例子,我们使用的是真正的哈希,所以我们只做简单的事情,但我们必须通过LIST字段间接进行。</target>
        </trans-unit>
        <trans-unit id="a68ea5110cc4475ea5587d223e48012123b172f2" translate="yes" xml:space="preserve">
          <source>For packing floating point numbers you have the choice between the pack codes &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; pack into (or unpack from) single-precision or double-precision representation as it is provided by your system. If your systems supports it, &lt;code&gt;D&lt;/code&gt; can be used to pack and unpack (&lt;code&gt;long double&lt;/code&gt; ) values, which can offer even more resolution than &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; . &lt;b&gt;Note that there are different long double formats.&lt;/b&gt;</source>
          <target state="translated">对于打包浮点数，可以在打包代码 &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 之间选择。 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 打包成系统提供的单精度或双精度表示形式（或从中解包）。如果您的系统支持，则 &lt;code&gt;D&lt;/code&gt; 可用于打包和解包（ &lt;code&gt;long double&lt;/code&gt; ）值，这可以提供比 &lt;code&gt;f&lt;/code&gt; 或 &lt;code&gt;d&lt;/code&gt; 更高的分辨率。&lt;b&gt;请注意，有不同的长双精度格式。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="66df4e6482b9f11564ff3b3f20d96a2cc85b3ceb" translate="yes" xml:space="preserve">
          <source>For parsing or generating CSV, though, using &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt; rather than implementing it yourself is highly recommended; you'll save yourself odd bugs popping up later by just using code which has already been tried and tested in production for years.</source>
          <target state="translated">但是，强烈建议您使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text :: CSV&lt;/a&gt;来解析或生成CSV 而不是自己实现；您只需使用已经在生产中进行了多年尝试和测试的代码，就可以避免以后出现的奇怪错误。</target>
        </trans-unit>
        <trans-unit id="6ee0891ac5c639e853c5a4e5edc84af67afe5f45" translate="yes" xml:space="preserve">
          <source>For platforms that do not support the L</source>
          <target state="translated">对于不支持L</target>
        </trans-unit>
        <trans-unit id="6ef063b83223c50f839dae38551b2b8ac38cb283" translate="yes" xml:space="preserve">
          <source>For portability do not assume that the result of inet_aton() is 32 bits wide, in other words, that it would contain only the IPv4 address in network order.</source>
          <target state="translated">为了便于移植,不要假设inet_aton()的结果是32位宽,换句话说,它只包含网络顺序的IPv4地址。</target>
        </trans-unit>
        <trans-unit id="a2f756b0930efbec9e5ee4bb36d81103dee350c4" translate="yes" xml:space="preserve">
          <source>For portability, when using features that may not be implemented on every machine, test the construct in an eval to see if it fails. If you know what version or patchlevel a particular feature was implemented, you can test &lt;code&gt;$]&lt;/code&gt; (&lt;code&gt;$PERL_VERSION&lt;/code&gt; in &lt;code&gt;English&lt;/code&gt; ) to see if it will be there. The &lt;code&gt;Config&lt;/code&gt; module will also let you interrogate values determined by the &lt;b&gt;Configure&lt;/b&gt; program when Perl was installed.</source>
          <target state="translated">为了实现可移植性，当使用并非在每台计算机上都可能实现的功能时，请评估一次该构造以查看其是否失败。如果您知道实现了特定功能的版本或 &lt;code&gt;$PERL_VERSION&lt;/code&gt; ，则可以测试 &lt;code&gt;$]&lt;/code&gt; （ &lt;code&gt;English&lt;/code&gt; $ PERL_VERSION）以查看它是否在那里。当安装Perl时， &lt;code&gt;Config&lt;/code&gt; 模块还将允许您询问由&lt;b&gt;Configure&lt;/b&gt;程序确定的值。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2535552b980c53cc7ba860a8dd5bb061008869b5" translate="yes" xml:space="preserve">
          <source>For portably packed integers, either use the formats &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; or else use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers described immediately below. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;.</source>
          <target state="translated">对于可移植打包的整数，请使用 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 格式，或者使用下面立即描述的 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符。另请参见&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f894cb82cd4f998730f7156c0afde9903978c5fb" translate="yes" xml:space="preserve">
          <source>For portably packed integers, either use the formats &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; or else use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers described immediately below. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;.</source>
          <target state="translated">对于可移植打包的整数，请使用 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 格式，或者使用下面立即描述的 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符。另请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b632d6b9c2c212334172ecdd5444e30d59c76fb4" translate="yes" xml:space="preserve">
          <source>For purposes for forward compatibility, any result which does not match the following grammar is currently referred to as &lt;a href=&quot;result/unknown&quot;&gt;TAP::Parser::Result::Unknown&lt;/a&gt;. It is</source>
          <target state="translated">为了向前兼容，当前与以下语法不匹配的任何结果都称为&lt;a href=&quot;result/unknown&quot;&gt;TAP :: Parser :: Result :: Unknown&lt;/a&gt;。它是</target>
        </trans-unit>
        <trans-unit id="abd99590407faa93008cdde9678d67dea3d2be33" translate="yes" xml:space="preserve">
          <source>For purposes of Pod processing, there are four types of paragraphs in a Pod block:</source>
          <target state="translated">在花苞处理中,一个花苞块有四种类型的段落。</target>
        </trans-unit>
        <trans-unit id="7c27afbc45a634cfd67eaae651454448b0cf48fa" translate="yes" xml:space="preserve">
          <source>For reading RFC 1950 files/buffers, see the companion module &lt;a href=&quot;../uncompress/inflate&quot;&gt;IO::Uncompress::Inflate&lt;/a&gt;.</source>
          <target state="translated">有关读取RFC 1950文件/缓冲区的信息，请参见配套模块&lt;a href=&quot;../uncompress/inflate&quot;&gt;IO :: Uncompress :: Inflate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a855ff5b11238f17f076a8b7ebdcff40a540c026" translate="yes" xml:space="preserve">
          <source>For reading RFC 1951 files/buffers, see the companion module &lt;a href=&quot;../uncompress/rawinflate&quot;&gt;IO::Uncompress::RawInflate&lt;/a&gt;.</source>
          <target state="translated">有关读取RFC 1951文件/缓冲区的信息，请参见配套模块&lt;a href=&quot;../uncompress/rawinflate&quot;&gt;IO :: Uncompress :: RawInflate&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7c1e04df00546215699a3d4161d10f783f59e5d" translate="yes" xml:space="preserve">
          <source>For reading RFC 1952 files/buffers, see the companion module &lt;a href=&quot;../uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">有关读取RFC 1952文件/缓冲区的信息，请参见配套模块&lt;a href=&quot;../uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45f2b20453bc89baeb5e50beb84ad2c8f70cd376" translate="yes" xml:space="preserve">
          <source>For reading bzip2 files/buffers, see the companion module &lt;a href=&quot;../uncompress/bunzip2&quot;&gt;IO::Uncompress::Bunzip2&lt;/a&gt;.</source>
          <target state="translated">有关读取bzip2文件/缓冲区的信息，请参见配套模块&lt;a href=&quot;../uncompress/bunzip2&quot;&gt;IO :: Uncompress :: Bunzip2&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="187e155fdbfcf5fc691664f658b9590cb0a606e3" translate="yes" xml:space="preserve">
          <source>For reading zip files/buffers, see the companion module &lt;a href=&quot;../uncompress/unzip&quot;&gt;IO::Uncompress::Unzip&lt;/a&gt;.</source>
          <target state="translated">有关读取zip文件/缓冲区的信息，请参见配套模块&lt;a href=&quot;../uncompress/unzip&quot;&gt;IO :: Uncompress :: Unzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bd2eb9a3cc8fd3a8df073b0ec5e2b4d099b5a11" translate="yes" xml:space="preserve">
          <source>For reference &lt;code&gt;Name_hash&lt;/code&gt; in &lt;a href=&quot;#Example-1&quot;&gt;Example 1&lt;/a&gt; shows the standard implementation of a simple class &lt;code&gt;Name&lt;/code&gt; in the well-known hash based way. It also demonstrates the predictable failure to construct a common subclass &lt;code&gt;NamedFile&lt;/code&gt; of &lt;code&gt;Name&lt;/code&gt; and the class &lt;code&gt;IO::File&lt;/code&gt; (whose objects</source>
          <target state="translated">作为参考，&lt;a href=&quot;#Example-1&quot;&gt;示例1&lt;/a&gt;中的 &lt;code&gt;Name_hash&lt;/code&gt; 以众所周知的基于哈希的方式显示了简单类 &lt;code&gt;Name&lt;/code&gt; 的标准实现。这也表明在可预见的故障，构建一个共同的子类 &lt;code&gt;NamedFile&lt;/code&gt; 的 &lt;code&gt;Name&lt;/code&gt; 和类 &lt;code&gt;IO::File&lt;/code&gt; （其对象</target>
        </trans-unit>
        <trans-unit id="c814c526315b7581980ad4c15539a698f43dc88e" translate="yes" xml:space="preserve">
          <source>For reference on how regular expressions are used in matching operations, plus various examples of the same, see discussions of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;??&lt;/code&gt; in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">有关在匹配操作中如何使用正则表达式的参考以及相同示例的各种示例，请参见对 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;??&lt;/code&gt; 的讨论。&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perexp&lt;/a&gt;中的Regexp Quote-like运算符中。</target>
        </trans-unit>
        <trans-unit id="fad7e87806bab30783c3c4927bdef95cd0d3e97d" translate="yes" xml:space="preserve">
          <source>For resolving Pod E&amp;lt;...&amp;gt; sequences</source>
          <target state="translated">用于解析Pod E &amp;lt;...&amp;gt;序列</target>
        </trans-unit>
        <trans-unit id="6b992296626805bd58c646a7af77319599bf4d43" translate="yes" xml:space="preserve">
          <source>For results that are less &quot;raw&quot; than this function returns, or to get the values for any property, not just the few covered by this function, use the &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; function.</source>
          <target state="translated">对于比该函数返回的&amp;ldquo;原始&amp;rdquo;结果更小的结果，或者要获取任何属性的值，而不仅仅是此函数覆盖的属性，请使用&lt;a href=&quot;#charprop()&quot;&gt;charprop（）&lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="5465aa0069dd7e57a3ecfdd26acfc8c3e9bcb5cc" translate="yes" xml:space="preserve">
          <source>For scripts see UTR #24: &lt;a href=&quot;http://www.unicode.org/unicode/reports/tr24/&quot;&gt;http://www.unicode.org/unicode/reports/tr24/&lt;/a&gt;</source>
          <target state="translated">有关脚本，请参见UTR＃24：&lt;a href=&quot;http://www.unicode.org/unicode/reports/tr24/&quot;&gt;http&lt;/a&gt;：//www.unicode.org/unicode/reports/tr24/</target>
        </trans-unit>
        <trans-unit id="fbe77ef0bb7f245eb32b185bc4ca0da0057fd61e" translate="yes" xml:space="preserve">
          <source>For security reasons, which are probably detailed in your system's documentation for the C library &lt;code&gt;tmpnam()&lt;/code&gt; function, this interface should not be used; instead see &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">出于安全原因，您的系统文档中可能包含C库 &lt;code&gt;tmpnam()&lt;/code&gt; 函数的详细信息，因此不应使用此接口。相反，请参阅&lt;a href=&quot;file/temp&quot;&gt;File :: Temp&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="804ad42eea097048c3a5ad09bc9b03cdfa4b060a" translate="yes" xml:space="preserve">
          <source>For sequential data set access try:</source>
          <target state="translated">对于顺序数据集的访问尝试。</target>
        </trans-unit>
        <trans-unit id="ef5bb90320f25f28778d12700a90184c79a71a09" translate="yes" xml:space="preserve">
          <source>For simple names like 'foo', when the normal search fails to find a matching page, a search with the &quot;perl&quot; prefix is tried as well. So &quot;perldoc intro&quot; is enough to find/render &quot;perlintro.pod&quot;.</source>
          <target state="translated">对于像'foo'这样简单的名字,当普通搜索找不到匹配页面时,也会尝试用 &quot;perl &quot;前缀搜索。所以 &quot;perldoc intro &quot;就可以找到/重现 &quot;perlintro.pod&quot;。</target>
        </trans-unit>
        <trans-unit id="556d75ad92e978ff3b11a57397aef51991f4ff7e" translate="yes" xml:space="preserve">
          <source>For simple uses, &lt;a href=&quot;spec/functions&quot;&gt;File::Spec::Functions&lt;/a&gt; provides convenient functional forms of these methods.</source>
          <target state="translated">为简单起见，&lt;a href=&quot;spec/functions&quot;&gt;File :: Spec :: Functions&lt;/a&gt;提供了这些方法的便捷功能形式。</target>
        </trans-unit>
        <trans-unit id="9d03e819dd2058b21b6af8f56092068c3f695190" translate="yes" xml:space="preserve">
          <source>For single-byte locales, Perl generally takes the tack to use locale rules on code points that can fit in a single byte, and Unicode rules for those that can't (though this isn't uniformly applied, see the note at the end of this section). This prevents many problems in locales that aren't UTF-8. Suppose the locale is ISO8859-7, Greek. The character at 0xD7 there is a capital Chi. But in the ISO8859-1 locale, Latin1, it is a multiplication sign. The POSIX regular expression character class &lt;code&gt;[[:alpha:]]&lt;/code&gt; will magically match 0xD7 in the Greek locale but not in the Latin one.</source>
          <target state="translated">对于单字节语言环境，Perl通常会在可容纳单个字节的代码点上使用语言环境规则，而对于不能适应的代码点则使用Unicode规则（尽管这不是统一适用的，请参阅结尾处的注释）。本节的内容）。这样可以防止在不是UTF-8的语言环境中出现许多问题。假设语言环境为ISO8859-7（希腊文）。0xD7处的字符有大写Chi。但是在ISO8859-1语言环境Latin1中，它是一个乘法符号。POSIX正则表达式字符类 &lt;code&gt;[[:alpha:]]&lt;/code&gt; 在希腊语言环境中会神奇地匹配0xD7，而在拉丁语言环境中不会。</target>
        </trans-unit>
        <trans-unit id="380d5b1307da78e3f0b19da4a2093d734fd7d578" translate="yes" xml:space="preserve">
          <source>For small inputs asin() and acos() may return complex numbers even when real numbers would be enough and correct, this happens because of floating-point inaccuracies. You can see these inaccuracies for example by trying theses:</source>
          <target state="translated">对于较小的输入,asin()和acos()可能会返回复杂的数字,即使是实数也是足够的,而且是正确的,这是因为浮点运算不准确。你可以通过下面的例子来了解这些不准确的地方。</target>
        </trans-unit>
        <trans-unit id="b0bc5ddd0ee51281e4f9659982e9a429afe81e41" translate="yes" xml:space="preserve">
          <source>For small systems, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt; both provide minimal object systems that take care of basic boilerplate for you.</source>
          <target state="translated">对于小型系统，&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt;都提供了最少的对象系统，可以为您处理基本的样板。</target>
        </trans-unit>
        <trans-unit id="649df46c734150d637b1c77793718377fdc210a4" translate="yes" xml:space="preserve">
          <source>For some applications, the Perl parser mangles constants too much. It is possible to hook into this process via &lt;code&gt;overload::constant()&lt;/code&gt; and &lt;code&gt;overload::remove_constant()&lt;/code&gt; functions.</source>
          <target state="translated">对于某些应用程序，Perl解析器过多地处理常量。可以通过 &lt;code&gt;overload::constant()&lt;/code&gt; 和 &lt;code&gt;overload::remove_constant()&lt;/code&gt; 函数进入此过程。</target>
        </trans-unit>
        <trans-unit id="8c75f56e634e770bcbf3c0f23b36b82ec0fc811d" translate="yes" xml:space="preserve">
          <source>For some combinations of base character and modifiers, there are</source>
          <target state="translated">对于一些基本字符和修饰符的组合,有的是</target>
        </trans-unit>
        <trans-unit id="5b2480bf16f6be7c86b401cccabe7d726d8e24b1" translate="yes" xml:space="preserve">
          <source>For some concrete examples, see the implementation of the first() and reduce() functions of List::Util 1.18. There you will also find a header file that emulates the multicall API on older versions of perl.</source>
          <target state="translated">关于一些具体的例子,请参见 List::Util 1.18 中的 first()和 reduce()函数的实现。在那里你还可以找到一个头文件,它模拟了旧版本 perl 上的 multicall API。</target>
        </trans-unit>
        <trans-unit id="2c83ee66f318d1a73763c0a4e4314ae7b7e4530e" translate="yes" xml:space="preserve">
          <source>For some dual-life modules, it has not yet been determined if the CPAN version or the blead source is canonical. Until that is done, those modules should be in</source>
          <target state="translated">对于一些双寿命模块,尚未确定CPAN版本或出血源是否为标准版本。在确定之前,这些模块应处于以下状态</target>
        </trans-unit>
        <trans-unit id="52922f69d414d9ab836b3e1640882c87c88c29f9" translate="yes" xml:space="preserve">
          <source>For some languages this issue may never come up (Danish is rarely expressed as &quot;da-DK&quot;, but instead is just &quot;da&quot;). And for other languages, the whole concept of a &quot;generic&quot; form may verge on being uselessly vague, particularly for interfaces involving voice media in forms of Arabic or Chinese.</source>
          <target state="translated">对于某些语言来说,这个问题可能永远不会出现(丹麦语很少用 &quot;da-DK &quot;来表示,而只是用 &quot;da&quot;)。而对于其他语言来说,&quot;通用 &quot;形式的整个概念可能接近于无用的模糊,特别是对于涉及阿拉伯语或中文形式的语音媒体的界面。</target>
        </trans-unit>
        <trans-unit id="8df7b58f3cdc3f5432c07cbb3014a32ed5bbfa9f" translate="yes" xml:space="preserve">
          <source>For some methods, the first parameter can be modified. That includes the possibility that you return a reference to a completely different object instead. Although keeping the reference and just changing its contents is preferred over creating and returning a different reference.</source>
          <target state="translated">对于一些方法,第一个参数可以被修改。这包括你可以返回一个完全不同的对象的引用。虽然保留引用并只是改变其内容比创建和返回一个不同的引用更可取。</target>
        </trans-unit>
        <trans-unit id="91b1402159268a636b935e75a5ef943d82112546" translate="yes" xml:space="preserve">
          <source>For some reason which I forget, Unix machines like to have PERL_DL_NONLAZY set for tests.</source>
          <target state="translated">由于某些我忘记了的原因,Unix机器喜欢把PERL_DL_NONLAZY设置为测试用。</target>
        </trans-unit>
        <trans-unit id="a7901ef2b61f75100e0830a3d919762868ec72c6" translate="yes" xml:space="preserve">
          <source>For some reason, the Fahrenheit to Celsius conversion fails to return the expected output. This is what it does:</source>
          <target state="translated">由于某些原因,华氏到摄氏度的转换未能返回预期的输出。这就是它所做的。</target>
        </trans-unit>
        <trans-unit id="6836cb564e9866aa0dd506ea484f1257d833a6cb" translate="yes" xml:space="preserve">
          <source>For some reason, this table is incomplete! Several countries are missing from it, and I cannot find them anywhere on the UN site. I no longer use this as a source of data.</source>
          <target state="translated">由于某种原因,这个表格不完整!其中缺少几个国家,我在联合国网站上也找不到这些国家。我已不再将此表作为数据来源。</target>
        </trans-unit>
        <trans-unit id="b7a2085644f6e69e810ea72163b3697d3339d4a3" translate="yes" xml:space="preserve">
          <source>For some specific applications, you can use one of the DBM modules. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;. More generically, you should consult the &lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;FreezeThaw&lt;/a&gt; or &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; modules from CPAN. Starting from Perl 5.8, &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; is part of the standard distribution. Here's one example using &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;'s &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; functions:</source>
          <target state="translated">对于某些特定的应用程序，您可以使用一个DBM模块。参见&lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;。更&lt;a href=&quot;http://search.cpan.org/perldoc/FreezeThaw&quot;&gt;一般而言&lt;/a&gt;，您应该查阅CPAN 的FreezeThaw或&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;模块。从Perl 5.8开始，&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;是标准发行版的一部分。这是一个使用&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;的 &lt;code&gt;store&lt;/code&gt; 和 &lt;code&gt;retrieve&lt;/code&gt; 功能的示例：</target>
        </trans-unit>
        <trans-unit id="51552d3184ebb138bb755fdbaf9df407078be4d9" translate="yes" xml:space="preserve">
          <source>For special considerations when Perl is embedded in a C program, see &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;Using embedded Perl with POSIX locales in perlembed&lt;/a&gt;.</source>
          <target state="translated">有关将Perl嵌入C程序中的特殊注意事项，请参阅&lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;perlembed中的POSIX语言环境使用嵌入式Perl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="db2592239bcf5cba780f2c2b2c780b3dad39ed83" translate="yes" xml:space="preserve">
          <source>For state vars, SVs_PADSTALE is overloaded to mean 'not yet initialised', but this internal state is stored in a separate pad entry.</source>
          <target state="translated">对于状态变量,SVs_PADSTALE被重载为 &quot;尚未初始化 &quot;的意思,但这个内部状态被存储在一个单独的pad条目中。</target>
        </trans-unit>
        <trans-unit id="f0dd4dac3c9b3c360654ba0693c4a0d4f581ae73" translate="yes" xml:space="preserve">
          <source>For streams all in the same encoding, don't use encode/decode; instead set the file encoding when you open the file or immediately after with &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; as described later below.</source>
          <target state="translated">对于全部采用相同编码的流​​，请勿使用编码/解码；而是在打开文件时或紧接在 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 之后设置文件编码，如下所述。</target>
        </trans-unit>
        <trans-unit id="1dfae2e55787ddda9febdb90b2ecaeb6ae6a59fe" translate="yes" xml:space="preserve">
          <source>For streams being handed</source>
          <target state="translated">对于移交的溪流</target>
        </trans-unit>
        <trans-unit id="9dedf3c911e70154c6e95a2be8f174842c7bae09" translate="yes" xml:space="preserve">
          <source>For streams coming</source>
          <target state="translated">对于即将到来的溪流</target>
        </trans-unit>
        <trans-unit id="e0011302da40ab3a00fabe609704d25b18704f41" translate="yes" xml:space="preserve">
          <source>For string conversions, specifying a precision truncates the string to fit the specified width:</source>
          <target state="translated">对于字符串转换,指定一个精度可以截断字符串以适应指定的宽度。</target>
        </trans-unit>
        <trans-unit id="715b9be15d81e36207f8641c990be0fb81823314" translate="yes" xml:space="preserve">
          <source>For string values, &lt;code&gt;%&lt;/code&gt; returns the sum of the byte values saving you the trouble of a sum loop with &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">对于字符串值， &lt;code&gt;%&lt;/code&gt; 返回字节值的总和，从而 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; 了使用substr和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 进行求和循环的麻烦：</target>
        </trans-unit>
        <trans-unit id="2c32ad512fb42bb2f5a39ca4f1c4f07aae935ceb" translate="yes" xml:space="preserve">
          <source>For successful testing you may need to turn on the sticky bit for your world readable /tmp directory if you have not already done so (see man chmod).</source>
          <target state="translated">为了成功的测试,你可能需要打开你的世界可读/tmp目录的粘性位,如果你还没有这样做的话(见man chmod)。</target>
        </trans-unit>
        <trans-unit id="992f6aafd7fd171cd3b566817c93beb472bf462c" translate="yes" xml:space="preserve">
          <source>For such purposes we have &lt;code&gt;use_ok&lt;/code&gt; and &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">为此，我们有 &lt;code&gt;use_ok&lt;/code&gt; 和 &lt;code&gt;require_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d0546a793b6579ee297b5975d16d0d21606bafc" translate="yes" xml:space="preserve">
          <source>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless $no_file is true or a trailing separator or /. or /.. is present. On Unix this means that $no_file true makes this return ( '', $path, '' ).</source>
          <target state="translated">对于没有区分文件名和目录的语法的系统,假设最后一个文件是一个路径,除非$no_file为真或存在尾部分隔符或/.或/...。在Unix系统中,这意味着如果$no_file为真,则返回('',$path,'' )。</target>
        </trans-unit>
        <trans-unit id="7b23c14e40a72fd26594732c2e008c8f7079954f" translate="yes" xml:space="preserve">
          <source>For systems with no syntax differentiating filenames from directories, assumes that the last file is a path unless &lt;code&gt;$no_file&lt;/code&gt; is true or a trailing separator or</source>
          <target state="translated">对于没有语法区分文件名和目录的语法的系统，除非 &lt;code&gt;$no_file&lt;/code&gt; 为true或结尾的分隔符，否则假定最后一个文件为路径。</target>
        </trans-unit>
        <trans-unit id="41699a22da98ee5d514ab051852b7fdbdda93994" translate="yes" xml:space="preserve">
          <source>For tab indents, you'd use a tab character:</source>
          <target state="translated">对于制表符缩进,你会使用制表符。</target>
        </trans-unit>
        <trans-unit id="873e054c44e61faf311e2453c2e600c934773fe0" translate="yes" xml:space="preserve">
          <source>For that use &lt;a href=&quot;http://search.cpan.org/perldoc/Shell::Command&quot;&gt;Shell::Command&lt;/a&gt;.</source>
          <target state="translated">为此，使用&lt;a href=&quot;http://search.cpan.org/perldoc/Shell::Command&quot;&gt;Shell :: Command&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f8e31e8dfe4611868531ce4559928a6d1882ff0a" translate="yes" xml:space="preserve">
          <source>For the</source>
          <target state="translated">对于</target>
        </trans-unit>
        <trans-unit id="9111ece894932df874025e3e103411a73321fa27" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , the argument cannot be &lt;code&gt;0&lt;/code&gt; (zero). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;1&lt;/code&gt; (one). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-1&lt;/code&gt; (minus one). For the &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;sech&lt;/code&gt; , the argument cannot be</source>
          <target state="translated">对于 &lt;code&gt;csc&lt;/code&gt; ， &lt;code&gt;cot&lt;/code&gt; ， &lt;code&gt;asec&lt;/code&gt; ， &lt;code&gt;acsc&lt;/code&gt; ， &lt;code&gt;acot&lt;/code&gt; ， &lt;code&gt;csch&lt;/code&gt; ， &lt;code&gt;coth&lt;/code&gt; ， &lt;code&gt;asech&lt;/code&gt; ， &lt;code&gt;acsch&lt;/code&gt; ，该参数不能为 &lt;code&gt;0&lt;/code&gt; （零）。对于 &lt;code&gt;atanh&lt;/code&gt; ， &lt;code&gt;acoth&lt;/code&gt; ，参数不能为 &lt;code&gt;1&lt;/code&gt; （一）。对于 &lt;code&gt;atanh&lt;/code&gt; ， &lt;code&gt;acoth&lt;/code&gt; ，参数不能为 &lt;code&gt;-1&lt;/code&gt; （减一）。对于 &lt;code&gt;tan&lt;/code&gt; ， &lt;code&gt;sec&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ， &lt;code&gt;sech&lt;/code&gt; ，参数不能为</target>
        </trans-unit>
        <trans-unit id="18728ff4c7a96c743723724ec7c8d3bf1df62e46" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;csc&lt;/code&gt; , &lt;code&gt;cot&lt;/code&gt; , &lt;code&gt;asec&lt;/code&gt; , &lt;code&gt;acsc&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , &lt;code&gt;csch&lt;/code&gt; , &lt;code&gt;coth&lt;/code&gt; , &lt;code&gt;asech&lt;/code&gt; , &lt;code&gt;acsch&lt;/code&gt; , the argument cannot be &lt;code&gt;0&lt;/code&gt; (zero). For the logarithmic functions and the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;1&lt;/code&gt; (one). For the &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-1&lt;/code&gt; (minus one). For the &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acot&lt;/code&gt; , the argument cannot be &lt;code&gt;i&lt;/code&gt; (the imaginary unit). For the &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;acoth&lt;/code&gt; , the argument cannot be &lt;code&gt;-i&lt;/code&gt; (the negative imaginary unit). For the &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;sec&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , the argument cannot be</source>
          <target state="translated">对于 &lt;code&gt;csc&lt;/code&gt; ， &lt;code&gt;cot&lt;/code&gt; ， &lt;code&gt;asec&lt;/code&gt; ， &lt;code&gt;acsc&lt;/code&gt; ， &lt;code&gt;acot&lt;/code&gt; ， &lt;code&gt;csch&lt;/code&gt; ， &lt;code&gt;coth&lt;/code&gt; ， &lt;code&gt;asech&lt;/code&gt; ， &lt;code&gt;acsch&lt;/code&gt; ，该参数不能为 &lt;code&gt;0&lt;/code&gt; （零）。对于对数函数和 &lt;code&gt;atanh&lt;/code&gt; ， &lt;code&gt;acoth&lt;/code&gt; ，参数不能为 &lt;code&gt;1&lt;/code&gt; （一）。对于 &lt;code&gt;atanh&lt;/code&gt; ， &lt;code&gt;acoth&lt;/code&gt; ，参数不能为 &lt;code&gt;-1&lt;/code&gt; （减一）。对于 &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;acot&lt;/code&gt; ，参数不能为 &lt;code&gt;i&lt;/code&gt; （虚数单位）。对于 &lt;code&gt;atan&lt;/code&gt; ， &lt;code&gt;acoth&lt;/code&gt; ，参数不能为 &lt;code&gt;-i&lt;/code&gt; （负虚数单位）。对于 &lt;code&gt;tan&lt;/code&gt; ， &lt;code&gt;sec&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ，参数不能为</target>
        </trans-unit>
        <trans-unit id="83159320f2b2918a98eed25d2752aaca30a22922" translate="yes" xml:space="preserve">
          <source>For the DynaLoader developer/porter there is a similar debugging variable added to the C code (see dlutils.c) and enabled if Perl was built with the &lt;b&gt;-DDEBUGGING&lt;/b&gt; flag. This can also be set via the PERL_DL_DEBUG environment variable. Set to 1 for minimal information or higher for more.</source>
          <target state="translated">对于DynaLoader开发人员/ porter，将类似的调试变量添加到C代码中（请参阅dlutils.c），如果Perl是使用&lt;b&gt;-DDEBUGGING&lt;/b&gt;标志构建的，则启用该调试变量。也可以通过PERL_DL_DEBUG环境变量进行设置。设置为1可获取最少的信息，设置为1可获取更多信息。</target>
        </trans-unit>
        <trans-unit id="df6005966cffcf3e4fd44657df74e3aab23993c1" translate="yes" xml:space="preserve">
          <source>For the above line, the explanation is</source>
          <target state="translated">对于上面这一行,解释为</target>
        </trans-unit>
        <trans-unit id="1b868cb4c593515bd8834adf9737c636cf76ddff" translate="yes" xml:space="preserve">
          <source>For the block property, new-style block names are returned (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">对于block属性，返回新样式的块名称（请参阅&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式的块名称与新样式的块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2e62a0b0dfb533953b1b1d8670e578cf8cef3f43" translate="yes" xml:space="preserve">
          <source>For the constructs except here-docs, single characters are used as starting and ending delimiters. If the starting delimiter is an opening punctuation (that is &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;, or &lt;code&gt;&amp;lt;&lt;/code&gt; ), the ending delimiter is the corresponding closing punctuation (that is &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, or &lt;code&gt;&amp;gt;&lt;/code&gt;). If the starting delimiter is an unpaired character like &lt;code&gt;/&lt;/code&gt; or a closing punctuation, the ending delimiter is the same as the starting delimiter. Therefore a &lt;code&gt;/&lt;/code&gt; terminates a &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; construct, while a &lt;code&gt;]&lt;/code&gt; terminates both &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq[]&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq]]&lt;/a&gt;&lt;/code&gt; constructs.</source>
          <target state="translated">对于此处文档以外的结构，单个字符用作开始和结束定界符。如果起始定界符是开头标点（即 &lt;code&gt;(&lt;/code&gt; ， &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;{&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; ），则结束分隔符是相应的结束标点（即 &lt;code&gt;)&lt;/code&gt; ， &lt;code&gt;]&lt;/code&gt; ， &lt;code&gt;}&lt;/code&gt; 或 &lt;code&gt;&amp;gt;&lt;/code&gt; ）。如果起始定界符是不配对的字符，例如 &lt;code&gt;/&lt;/code&gt; 或结束标点，则结束定界符与起始定界符相同。因此，a &lt;code&gt;/&lt;/code&gt; 终止 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 构造，而a &lt;code&gt;]&lt;/code&gt; 终止 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq[]&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq]]&lt;/a&gt;&lt;/code&gt; 结构体。</target>
        </trans-unit>
        <trans-unit id="e4f199a5411adb8b18d5dcd3eca491b6d0afa516" translate="yes" xml:space="preserve">
          <source>For the details of the current situation with calling external programs, see &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;2 (and DOS) programs under Perl in Starting OS&lt;/a&gt;. Set us mention a couple of features:</source>
          <target state="translated">有关调用外部程序的当前情况的详细信息，请参阅&amp;ldquo; &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;启动OS&amp;rdquo;中Perl下的2个（和DOS）程序&lt;/a&gt;。让我们提到几个功能：</target>
        </trans-unit>
        <trans-unit id="f1218216e6666aa08fea7db0711070bf940dc1b0" translate="yes" xml:space="preserve">
          <source>For the example above, this produces the key &quot;13 1 2 3 4 5 6 7&quot;.</source>
          <target state="translated">对于上面的例子,这将产生 &quot;13 1 2 3 4 5 6 7 &quot;的键。</target>
        </trans-unit>
        <trans-unit id="bbb3be8f56df5259eb022c810ec0d5fe6e171757" translate="yes" xml:space="preserve">
          <source>For the full and latest information about Unicode see the latest Unicode standard, or the Unicode Consortium's website &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</source>
          <target state="translated">有关Unicode的完整和最新信息，请参见最新的Unicode标准，或Unicode联盟的网站&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8668a856ebdec95f7f9bedf605f00147e6a5c893" translate="yes" xml:space="preserve">
          <source>For the inverse cosine operation, you may use the &lt;code&gt;Math::Trig::acos()&lt;/code&gt; function, or use this relation:</source>
          <target state="translated">对于反余弦运算，可以使用 &lt;code&gt;Math::Trig::acos()&lt;/code&gt; 函数，或使用以下关系：</target>
        </trans-unit>
        <trans-unit id="a905ba655e6e826aa1adf29366a4b3be68fc4622" translate="yes" xml:space="preserve">
          <source>For the inverse sine operation, you may use the &lt;code&gt;Math::Trig::asin&lt;/code&gt; function, or use this relation:</source>
          <target state="translated">对于反正弦运算，可以使用 &lt;code&gt;Math::Trig::asin&lt;/code&gt; 函数，或使用以下关系：</target>
        </trans-unit>
        <trans-unit id="6876721cfa8799910e64a479d1896bac8905fc75" translate="yes" xml:space="preserve">
          <source>For the long explanation, see David Goldberg's &quot;What Every Computer Scientist Should Know About Floating-Point Arithmetic&quot; (&lt;a href=&quot;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&quot;&gt;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&lt;/a&gt;).</source>
          <target state="translated">有关详细的解释，请参见David Goldberg的&amp;ldquo;每位计算机科学家应了解的浮点运算法则&amp;rdquo;（&lt;a href=&quot;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&quot;&gt;http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ab2b9b857d720a0495db321b12b78ce4f7c0fe32" translate="yes" xml:space="preserve">
          <source>For the most part, everything should just work.</source>
          <target state="translated">在大多数情况下,一切都应该只是工作。</target>
        </trans-unit>
        <trans-unit id="64bfdda2355e6cc7b725609cd6e4467f4aa79c60" translate="yes" xml:space="preserve">
          <source>For the most part, the &lt;b&gt;Pod::Parser&lt;/b&gt; base class should be able to do most of the input parsing for you and leave you free to worry about how to interpret the commands and translate the result.</source>
          <target state="translated">在大多数情况下，&lt;b&gt;Pod :: Parser&lt;/b&gt;基类应该能够为您完成大部分输入解析，而让您不必担心如何解释命令和转换结果。</target>
        </trans-unit>
        <trans-unit id="9a0e7967ce42595fba722f8b428604ad3ef68e4c" translate="yes" xml:space="preserve">
          <source>For the pattern of regex operators (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;), the quoting from &lt;code&gt;\Q&lt;/code&gt; is applied after interpolation is processed, but before escapes are processed. This allows the pattern to match literally (except for &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; ). For example, the following matches:</source>
          <target state="translated">对于正则表达式运算符（ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ）的模式，在处理内插之后但在处理转义之前应用来自 &lt;code&gt;\Q&lt;/code&gt; 的引用。这允许模式按字 &lt;code&gt;$&lt;/code&gt; 进行匹配（$和 &lt;code&gt;@&lt;/code&gt; 除外）。例如，以下匹配：</target>
        </trans-unit>
        <trans-unit id="3962dca7589f77e8258212e6709cb6dc2b855dcb" translate="yes" xml:space="preserve">
          <source>For the purpose of inheritance every overloaded package behaves as if &lt;code&gt;fallback&lt;/code&gt; is present (possibly undefined). This may create interesting effects if some package is not overloaded, but inherits from two overloaded packages.</source>
          <target state="translated">出于继承的目的，每个重载的包的行为都好像存在 &lt;code&gt;fallback&lt;/code&gt; （可能未定义）。如果某些程序包未超载，但从两个重载的包继承，则可能会产生有趣的效果。</target>
        </trans-unit>
        <trans-unit id="82c1e221649c157f620843ea4889acff34e37d34" translate="yes" xml:space="preserve">
          <source>For the purpose of this pragma, interpolation of precompiled regular expressions (i.e., the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) is</source>
          <target state="translated">出于此编译指示的目的，预编译正则表达式（即 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 的结果）的插值为</target>
        </trans-unit>
        <trans-unit id="ba3e421d172c8c68f6d89fe7339af35a2610b123" translate="yes" xml:space="preserve">
          <source>For the regular expression, /\bPerl\b/, there has to be a word boundary before the &quot;P&quot; and after the &quot;l&quot;. As long as something other than a word character precedes the &quot;P&quot; and succeeds the &quot;l&quot;, the pattern will match. These strings match /\bPerl\b/.</source>
          <target state="translated">对于正则表达式,/\bPerlb/,在 &quot;P &quot;之前和 &quot;l &quot;之后必须有一个字的边界。只要在 &quot;P &quot;之前和 &quot;l &quot;之后有一个字以外的字符,这个模式就会匹配。这些字符串符合/b/Perlb/。</target>
        </trans-unit>
        <trans-unit id="6f420a434584dca0d2af03f0912dee0967b4dc89" translate="yes" xml:space="preserve">
          <source>For the reverse of stringifying, see the &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; .</source>
          <target state="translated">有关反串化的信息，请参见 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;emake&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb38c53d822d8e08d87924c605322b6766068193" translate="yes" xml:space="preserve">
          <source>For the reverse operation, we'll have to determine the number of items in the buffer before we can let &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; rip it apart:</source>
          <target state="translated">对于相反的操作，我们必须确定缓冲区中的项目数，然后才能 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 包装将其拆开：</target>
        </trans-unit>
        <trans-unit id="4dc883c9ac944705d2c3538c7663a30491ff44ec" translate="yes" xml:space="preserve">
          <source>For the reverse, see &lt;a href=&quot;#chr&quot;&gt;chr&lt;/a&gt;. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more about Unicode.</source>
          <target state="translated">相反，请参见&lt;a href=&quot;#chr&quot;&gt;chr&lt;/a&gt;。有关Unicode的更多信息，请参见&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="60cbf2eafc92f15723736c9c72868093d76361c9" translate="yes" xml:space="preserve">
          <source>For the reverse, see &lt;a href=&quot;chr&quot;&gt;chr&lt;/a&gt;. See &lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more about Unicode.</source>
          <target state="translated">相反，请参见&lt;a href=&quot;chr&quot;&gt;chr&lt;/a&gt;。有关Unicode的更多信息，请参见&lt;a href=&quot;../perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="467ceafc8b99b23ed78b230316a1d2fd5db20386" translate="yes" xml:space="preserve">
          <source>For the reverse, use &lt;a href=&quot;#ord&quot;&gt;ord&lt;/a&gt;.</source>
          <target state="translated">相反，请使用&lt;a href=&quot;#ord&quot;&gt;ord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6051659642df2e97b5594ae4ac7df1aad97530d" translate="yes" xml:space="preserve">
          <source>For the reverse, use &lt;a href=&quot;ord&quot;&gt;ord&lt;/a&gt;.</source>
          <target state="translated">相反，请使用&lt;a href=&quot;ord&quot;&gt;ord&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7f75a65f093671232956735031c2585d37439c1" translate="yes" xml:space="preserve">
          <source>For the rounding mode, see &lt;a href=&quot;#fegetround&quot;&gt;fegetround&lt;/a&gt;.</source>
          <target state="translated">有关舍入模式，请参见&lt;a href=&quot;#fegetround&quot;&gt;fegetround&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="94a7023212a15791913a95ba1c43764471fafd45" translate="yes" xml:space="preserve">
          <source>For the sake of speed and efficiency, most of the encodings are now supported via a</source>
          <target state="translated">为了提高速度和效率,现在大部分编码都是通过一个</target>
        </trans-unit>
        <trans-unit id="ad21271dd49f14dc112f37ba2aaf54b53f9fb3d0" translate="yes" xml:space="preserve">
          <source>For the sake of speed for a common case, in the above algorithms backslashes in the command name are not considered as shell metacharacters.</source>
          <target state="translated">为了普通情况下的速度,在上述算法中,命令名中的反斜杠不视为shell元字符。</target>
        </trans-unit>
        <trans-unit id="13bb8b6279ccfe0d9f624beb9c39acf42987a9f6" translate="yes" xml:space="preserve">
          <source>For the tangent operation, you may use the &lt;code&gt;Math::Trig::tan&lt;/code&gt; function, or use the familiar relation:</source>
          <target state="translated">对于切线运算，可以使用 &lt;code&gt;Math::Trig::tan&lt;/code&gt; 函数，或使用熟悉的关系：</target>
        </trans-unit>
        <trans-unit id="2285c9ff17a7e14c88876a7216e0b2f44e88a62a" translate="yes" xml:space="preserve">
          <source>For the time being, any necessary padding must be done by the user. Fortunately, this is a simple operation: if the length of a Base64-encoded digest isn't a multiple of 4, simply append &quot;=&quot; characters to the end of the digest until it is:</source>
          <target state="translated">目前,任何必要的填充都必须由用户来完成。幸运的是,这是一个简单的操作:如果一个Base64编码的摘要的长度不是4的倍数,只需在摘要的末尾添加&quot;=&quot;字符,直到它是。</target>
        </trans-unit>
        <trans-unit id="08b2d3f59edd8b61350507d43c91115b5897da2d" translate="yes" xml:space="preserve">
          <source>For the various values of PERLIO see &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;.</source>
          <target state="translated">有关PERLIO的各种值，请参见&lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrun中的PERLIO&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8844b265400f6667c325f1ddff5acf01441d43a0" translate="yes" xml:space="preserve">
          <source>For these purposes &quot;formats&quot; are a kind-of CV; eval&quot;&quot;s are too (except they're not callable at will and are always thrown away after the eval&quot;&quot; is done executing). Require'd files are simply evals without any outer lexical scope.</source>
          <target state="translated">为了这些目的,&quot;format &quot;是一种CV;eval&quot;&quot;也是(除了它们不能随意调用,而且总是在eval&quot;&quot;执行完毕后被扔掉)。Require'd文件是简单的eval,没有任何外部的词法范围。</target>
        </trans-unit>
        <trans-unit id="ce3d10f5200fd9f35eb39a2e2f3aff9e21a56d2a" translate="yes" xml:space="preserve">
          <source>For this discussion, we'll implement an array whose elements are a fixed size at creation. If you try to create an element larger than the fixed size, you'll take an exception. For example:</source>
          <target state="translated">在这个讨论中,我们将实现一个数组,其元素在创建时是固定大小的。如果你试图创建一个大于固定大小的元素,你将会采取一个异常。例如,我们将实现一个数组,其元素在创建时是固定大小的。</target>
        </trans-unit>
        <trans-unit id="5ffd7f12ddaa1b6fb60aa095946c012384bca946" translate="yes" xml:space="preserve">
          <source>For this grouping operator there is no need to describe the ordering, since only whether or not &lt;code&gt;S&lt;/code&gt; can match is important.</source>
          <target state="translated">对于此分组运算符，无需描述排序，因为仅 &lt;code&gt;S&lt;/code&gt; 是否可以匹配很重要。</target>
        </trans-unit>
        <trans-unit id="cc327a8066a607761f2f00ba1baa6fe5fc670e29" translate="yes" xml:space="preserve">
          <source>For this particular case an INIT: keyword would generate the same C code as the PREINIT: keyword. Another correct, but error-prone example:</source>
          <target state="translated">对于这种特殊情况,INIT:关键字会产生与PREINIT:关键字相同的C代码。另一个正确但容易出错的例子。</target>
        </trans-unit>
        <trans-unit id="145862e7b4274977f12fe15b3504a6befbd27f0c" translate="yes" xml:space="preserve">
          <source>For this reason, Unicode strings need to be converted to UTF-8-encoded bytestrings before they are handed off to &lt;code&gt;add_data()&lt;/code&gt; :</source>
          <target state="translated">因此，在将Unicode字符串传递给 &lt;code&gt;add_data()&lt;/code&gt; 之前，需要将其转换为UTF-8编码的字节字符串：</target>
        </trans-unit>
        <trans-unit id="d2b9d5527f46d12ea221667541772074c58883c4" translate="yes" xml:space="preserve">
          <source>For this reason, the use of &lt;code&gt;END&lt;/code&gt; blocks in threads is &lt;b&gt;strongly&lt;/b&gt; discouraged.</source>
          <target state="translated">因此，&lt;b&gt;强烈&lt;/b&gt;建议不要在线程中使用 &lt;code&gt;END&lt;/code&gt; 块。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e04b91b7b687e03cffdfdf3a54823d050aa6f6b" translate="yes" xml:space="preserve">
          <source>For this to happen, the class must not be inverted (see &lt;a href=&quot;#Negation&quot;&gt;Negation&lt;/a&gt;) and the character must be explicitly specified, and not be part of a multi-character range (not even as one of its endpoints). (&lt;a href=&quot;#Character-Ranges&quot;&gt;Character Ranges&lt;/a&gt; will be explained shortly.) Therefore,</source>
          <target state="translated">为此，必须禁止反转类（请参见&lt;a href=&quot;#Negation&quot;&gt;Negation&lt;/a&gt;），并且必须明确指定字符，并且该字符不属于多字符范围（甚至不作为其端点之一）。（&lt;a href=&quot;#Character-Ranges&quot;&gt;字符范围&lt;/a&gt;将在稍后说明。）因此，</target>
        </trans-unit>
        <trans-unit id="e5f1c25c243913e44f46f14a2a6685401a32ac3f" translate="yes" xml:space="preserve">
          <source>For those grammatical pedants out there, there's an &lt;code&gt;isn't()&lt;/code&gt; function which is an alias of &lt;code&gt;isnt()&lt;/code&gt; .</source>
          <target state="translated">对于那些在那里的语法学究的人，有一个 &lt;code&gt;isn't()&lt;/code&gt; 函数，它是 &lt;code&gt;isnt()&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="0194baebcc4ad338a3d27044bda911227e0fa177" translate="yes" xml:space="preserve">
          <source>For those of you who don't like additional global variables being created, &lt;code&gt;getopt()&lt;/code&gt; and &lt;code&gt;getopts()&lt;/code&gt; will also accept a hash reference as an optional second argument. Hash keys will be &lt;code&gt;x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) with key values the value of the argument or &lt;code&gt;1&lt;/code&gt; if no argument is specified.</source>
          <target state="translated">对于不喜欢创建其他全局变量的人， &lt;code&gt;getopt()&lt;/code&gt; 和 &lt;code&gt;getopts()&lt;/code&gt; 还将接受哈希引用作为可选的第二个参数。哈希键将是 &lt;code&gt;x&lt;/code&gt; （其中 &lt;code&gt;x&lt;/code&gt; 是开关名称），键值是参数的值；如果未指定参数，则为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b7b01e9b9a30ca0a332a8ff42ff01fc2ab10b42" translate="yes" xml:space="preserve">
          <source>For those preferring a higher-level interface to socket programming, the IO::Socket module provides an object-oriented approach. If for some reason you lack this module, you can just fetch IO::Socket from CPAN, where you'll also find modules providing easy interfaces to the following systems: DNS, FTP, Ident (RFC 931), NIS and NISPlus, NNTP, Ping, POP3, SMTP, SNMP, SSLeay, Telnet, and Time--to name just a few.</source>
          <target state="translated">对于那些喜欢更高级别的套接字编程接口的人,IO::Socket模块提供了一种面向对象的方法。如果你缺少这个模块,你可以从CPAN中获取IO::Socket,在CPAN中你还可以找到提供以下系统简易接口的模块。DNS、FTP、Ident (RFC 931)、NIS和NISPlus、NNTP、Ping、POP3、SMTP、SNMP、SSLeay、Telnet和Tim--只是其中的几个例子。</target>
        </trans-unit>
        <trans-unit id="e42062d65775a1867386b08263976fa1b5777e72" translate="yes" xml:space="preserve">
          <source>For those times when it is necessary to have platform-specific code, consider keeping the platform-specific code in one place, making porting to other platforms easier. Use the &lt;code&gt;Config&lt;/code&gt; module and the special variable &lt;code&gt;$^O&lt;/code&gt; to differentiate platforms, as described in &lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;.</source>
          <target state="translated">在那些需要特定于平台的代码的时代，请考虑将特定于平台的代码放在一个位置，从而更轻松地移植到其他平台。使用 &lt;code&gt;Config&lt;/code&gt; 模块和特殊变量 &lt;code&gt;$^O&lt;/code&gt; 来区分平台，如&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84af40bcdd6cb4fcbd3aceb5a4aa3593a23036aa" translate="yes" xml:space="preserve">
          <source>For those to work, the Pod-processing subclass of Pod::Simple::PullParser has to have defined a $parser-&amp;gt;run method -- so it is advised that all Pod::Simple::PullParser subclasses do so. See the Synopsis above, or the source for Pod::Simple::RTF.</source>
          <target state="translated">为了使这些工作，Pod :: Simple :: PullParser的Pod处理子类必须定义一个$ parser-&amp;gt; run方法-因此建议所有Pod :: Simple :: PullParser子类都这样做。请参阅上面的摘要，或Pod :: Simple :: RTF的源代码。</target>
        </trans-unit>
        <trans-unit id="57708cdc23a61a116a94a02091f20a5743825ee2" translate="yes" xml:space="preserve">
          <source>For those variables that have an &lt;b&gt;awk&lt;/b&gt; version, both long and short English alternatives are provided. For example, the &lt;code&gt;$/&lt;/code&gt; variable can be referred to either $RS or $INPUT_RECORD_SEPARATOR if you are using the English module.</source>
          <target state="translated">对于具有&lt;b&gt;awk&lt;/b&gt;版本的那些变量，提供了长英文替代形式。例如，如果您使用的是英语模块，则可以将 &lt;code&gt;$/&lt;/code&gt; 变量引用为$ RS或$ INPUT_RECORD_SEPARATOR。</target>
        </trans-unit>
        <trans-unit id="d9a0a89c68e7b08863ca5af8b26671ca9622ae82" translate="yes" xml:space="preserve">
          <source>For thread safety, modules should not write directly to this array. Instead, use the function &lt;a href=&quot;#wrap_op_checker&quot;&gt;wrap_op_checker&lt;/a&gt;.</source>
          <target state="translated">为了线程安全，模块不应直接写入此数组。而是使用功能&lt;a href=&quot;#wrap_op_checker&quot;&gt;wrap_op_checker&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cacce03e577b17c33a4569c50a9b7a97dcf2d96" translate="yes" xml:space="preserve">
          <source>For threaded builds, perl requires the context pointer for the current thread, without &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; , perl will call a function to retrieve the context.</source>
          <target state="translated">对于线程构建，perl需要当前线程的上下文指针，而没有 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; ，perl将调用一个函数来检索上下文。</target>
        </trans-unit>
        <trans-unit id="5847b93f0e1805fa116eb823dc4911eae257671b" translate="yes" xml:space="preserve">
          <source>For three or more arguments if MODE is &lt;code&gt;|-&lt;/code&gt; , the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt; , the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt; ) with the command. See &lt;a href=&quot;../perlipc#Using-open()-for-IPC&quot;&gt;Using open() for IPC in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to a command that pipes both in</source>
          <target state="translated">对于三个或更多参数，如果MODE为 &lt;code&gt;|-&lt;/code&gt; ，则文件名解释为将输出传递到的命令，如果MODE为 &lt;code&gt;-|&lt;/code&gt; 。，文件名将解释为通过管道将输出传递给我们的命令。在二参数（和一参数）形式中，应使用命令替换破折号（ &lt;code&gt;-&lt;/code&gt; ）。有关更多示例，请参见&lt;a href=&quot;../perlipc#Using-open()-for-IPC&quot;&gt;在perlipc中将open（）用于IPC&lt;/a&gt;。（不允许您 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 同时将两个</target>
        </trans-unit>
        <trans-unit id="6dd4431238a703da90497fd4857cf48e6171b713" translate="yes" xml:space="preserve">
          <source>For three or more arguments if MODE is &lt;code&gt;|-&lt;/code&gt;, the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt;, the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt; ) with the command. See &lt;a href=&quot;perlipc#Using-open()-for-IPC&quot;&gt;Using open() for IPC in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to a command that pipes both in</source>
          <target state="translated">对于三个或更多参数，如果MODE为 &lt;code&gt;|-&lt;/code&gt; ，则文件名解释为将输出传递到的命令，如果MODE为 &lt;code&gt;-|&lt;/code&gt; 。，文件名将解释为通过管道将输出传递给我们的命令。在二参数（和一参数）形式中，应使用命令替换破折号（ &lt;code&gt;-&lt;/code&gt; ）。有关更多示例，请参见&lt;a href=&quot;perlipc#Using-open()-for-IPC&quot;&gt;在perlipc中&lt;/a&gt;为IPC使用open（）。 （不允许您 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 同时将两个</target>
        </trans-unit>
        <trans-unit id="bf83195223f53cdba1b00e5a9f41ecd342d04331" translate="yes" xml:space="preserve">
          <source>For typed lexicals PadnameTYPE points at the type stash. For &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lexicals, PadnameOURSTASH points at the stash of the associated global (so that duplicate &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations in the same package can be detected). PadnameGEN is sometimes used to store the generation number during compilation.</source>
          <target state="translated">对于键入的词法，PadnameTYPE指向隐藏类型。对于 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 词汇，PadnameOURSTASH指向关联的全局存储区（以便可以检测到 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 在同一程序包中的重复声明）。PadnameGEN有时在编译期间用于存储世代号。</target>
        </trans-unit>
        <trans-unit id="91986aaa66a7c1fc5ea1ae9b7846d756f92bfc49" translate="yes" xml:space="preserve">
          <source>For various reasons &lt;code&gt;\K&lt;/code&gt; may be significantly more efficient than the equivalent &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; construct, and it is especially useful in situations where you want to efficiently remove something following something else in a string. For instance</source>
          <target state="translated">由于各种原因， &lt;code&gt;\K&lt;/code&gt; 可能比等效的 &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; 构造要有效得多，它在想要有效删除字符串中其他内容之后的内容时特别有用。例如</target>
        </trans-unit>
        <trans-unit id="177cf62cd78233abf54102693c9e9acbadd8394b" translate="yes" xml:space="preserve">
          <source>For versions &amp;lt; 5.6.0, the changes are. - no use of 'our' (uses 'use vars' instead) - no 'use warnings'</source>
          <target state="translated">对于版本低于5.6.0的更改。-不使用&amp;ldquo;我们的&amp;rdquo;（改用&amp;ldquo;使用vars&amp;rdquo;）-不使用&amp;ldquo;使用警告&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="60941c7eb5c54adfbab7ac22e457a8c4e15f2100" translate="yes" xml:space="preserve">
          <source>For writing RFC 1950 files/buffers, see the companion module IO::Compress::Deflate.</source>
          <target state="translated">关于RFC 1950文件/缓冲区的编写,请参见配套模块IO::Compress::Deflate。</target>
        </trans-unit>
        <trans-unit id="685182a7768729bc793033bd0e68d3c4f3af5f73" translate="yes" xml:space="preserve">
          <source>For writing RFC 1951 files/buffers, see the companion module IO::Compress::RawDeflate.</source>
          <target state="translated">关于RFC 1951文件/缓冲区的编写,请参见配套模块IO::Compress::RawDeflate。</target>
        </trans-unit>
        <trans-unit id="9243b703bb54f6641362690a1ee88fd13adf9954" translate="yes" xml:space="preserve">
          <source>For writing RFC 1952 files/buffers, see the companion module IO::Compress::Gzip.</source>
          <target state="translated">关于RFC 1952文件/缓冲区的编写,请参见配套模块IO::Compress::Gzip。</target>
        </trans-unit>
        <trans-unit id="9bf658d02b726edd2f1c254066ded7736fd6d5a9" translate="yes" xml:space="preserve">
          <source>For writing bzip2 files/buffers, see the companion module IO::Compress::Bzip2.</source>
          <target state="translated">关于编写bzip2文件/缓冲区,请参见配套模块IO::Compress::Bzip2。</target>
        </trans-unit>
        <trans-unit id="e13d75b855f37f1330f6f4c1ef3a45768526e035" translate="yes" xml:space="preserve">
          <source>For writing zip files/buffers, see the companion module IO::Compress::Zip.</source>
          <target state="translated">关于编写zip文件/缓冲区,请参见配套模块IO::Compress::Zip。</target>
        </trans-unit>
        <trans-unit id="535406d475920b171aa234460dc25648f86b16d6" translate="yes" xml:space="preserve">
          <source>For your convenience, Perl has added the &lt;code&gt;Non_Canonical&lt;/code&gt; decomposition type to mean any of the several compatibility decompositions.</source>
          <target state="translated">为了方便起见，Perl添加了 &lt;code&gt;Non_Canonical&lt;/code&gt; 分解类型以表示几种兼容性分解中的任何一种。</target>
        </trans-unit>
        <trans-unit id="53ad46f1c41b22f84b5d3b3f5d59b0ffd2ec8775" translate="yes" xml:space="preserve">
          <source>For your convenience, Perl sets up a few special filehandles that are already open when you run. These include &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;STDERR&lt;/code&gt; , and &lt;code&gt;ARGV&lt;/code&gt; . Since those are pre-opened, you can use them right away without having to go to the trouble of opening them yourself:</source>
          <target state="translated">为了方便起见，Perl设置了一些特殊的文件句柄，这些文件句柄在您运行时已经打开。这些包括 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; ， &lt;code&gt;STDERR&lt;/code&gt; 和 &lt;code&gt;ARGV&lt;/code&gt; 。由于这些是预先打开的，因此您可以立即使用它们，而不必麻烦自己打开它们：</target>
        </trans-unit>
        <trans-unit id="30e11a0cc028d202d8463cc9e66bddef5da4b46a" translate="yes" xml:space="preserve">
          <source>For, begin, and end will let you have regions of text/code/data that are not generally interpreted as normal Pod text, but are passed directly to particular formatters, or are otherwise special. A formatter that can use that format will use the region, otherwise it will be completely ignored.</source>
          <target state="translated">For、begin和end将让你拥有文本/代码/数据的区域,这些区域一般不会被解释为正常的Pod文本,而是直接传递给特定的格式器,或者是其他特殊的格式。可以使用该格式的格式器将使用该区域,否则将被完全忽略。</target>
        </trans-unit>
        <trans-unit id="75b520175307f045a1bd5432ec6c11ebe784b1ea" translate="yes" xml:space="preserve">
          <source>Force a title for the page (don't try to determine it from the content). The value of this string should already be &amp;amp;-escaped.</source>
          <target state="translated">强制页面的标题（不要尝试从内容中确定它）。此字符串的值应该已经＆换码了。</target>
        </trans-unit>
        <trans-unit id="000583668b82be86fbb138b24c7dd36579b394a2" translate="yes" xml:space="preserve">
          <source>Force bsd_glob() to return an error when it encounters a directory it cannot open or read. Ordinarily bsd_glob() continues to find matches.</source>
          <target state="translated">当遇到一个无法打开或读取的目录时,强制bsd_glob()返回一个错误。通常bsd_glob()会继续寻找匹配的目录。</target>
        </trans-unit>
        <trans-unit id="f44e8f61765329d123a6aeba46d29dc380866fc3" translate="yes" xml:space="preserve">
          <source>Force byte semantics rather than character semantics</source>
          <target state="translated">强制使用字节语义而不是字符语义。</target>
        </trans-unit>
        <trans-unit id="e13bf2b7599ac8779de2f3726115bde91fbbaded" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task it would normally refuse to do. Force takes as arguments a method name to be invoked and any number of additional arguments to pass that method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">强制CPAN执行通常会拒绝执行的任务。Force将要调用的方法名称和传递该方法的任意数量的其他参数作为参数。对象的内部结构将获得所需的更改，以使CPAN.pm不会拒绝执行该操作。另请参见上述关于部分 &lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;fforce&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="6824e435b9c0d512ec0dbbda74a3d74da3f722c9" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task that it normally would have refused to do. Force takes as arguments a method name to be called and any number of additional arguments that should be passed to the called method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">强制CPAN执行通常会拒绝执行的任务。Force将要调用的方法名称和应传递给被调用方法的任意数量的其他参数作为参数。对象的内部结构将获得所需的更改，以使CPAN.pm不会拒绝执行该操作。另请参见上述关于部分 &lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;fforce&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="5c9a0d4c05ea685c4b81ce563d38fd33d0aeea12" translate="yes" xml:space="preserve">
          <source>Forces CPAN to perform a task that it normally would have refused to do. Force takes as arguments a method name to be called and any number of additional arguments that should be passed to the called method. The internals of the object get the needed changes so that CPAN.pm does not refuse to take the action. The &lt;code&gt;force&lt;/code&gt; is passed recursively to all contained objects. See also the section above on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">强制CPAN执行通常会拒绝执行的任务。 Force将要调用的方法名称和应传递给被调用方法的任意数量的其他参数作为参数。对象的内部结构将获得所需的更改，以使CPAN.pm不会拒绝执行该操作。该 &lt;code&gt;force&lt;/code&gt; 递归传递给所有包含的对象。另请参见上述关于部分 &lt;code&gt;force&lt;/code&gt; 和 &lt;code&gt;fforce&lt;/code&gt; 编译。</target>
        </trans-unit>
        <trans-unit id="f116ab22ad8af5d1edf47652c0fde4ebe02b3188" translate="yes" xml:space="preserve">
          <source>Forces EXPR to be interpreted in scalar context and returns the value of EXPR.</source>
          <target state="translated">强制在标量上下文中解释EXPR,并返回EXPR的值。</target>
        </trans-unit>
        <trans-unit id="500df2d2fe4d1817ceeca100a5e6d863aec7944d" translate="yes" xml:space="preserve">
          <source>Forces a reload of all indices.</source>
          <target state="translated">强制重新加载所有指数。</target>
        </trans-unit>
        <trans-unit id="ec27ff3ecad1733cd6196463fe06ab0d70361cc8" translate="yes" xml:space="preserve">
          <source>Forcing AutoLoader to Load a Function</source>
          <target state="translated">强制自动加载器加载一个函数</target>
        </trans-unit>
        <trans-unit id="4a87f71febe991ae2954e6d639d10481ac9e6d2d" translate="yes" xml:space="preserve">
          <source>Forcing Unicode in Perl (Or Unforcing Unicode in Perl)</source>
          <target state="translated">在Perl中强制使用Unicode(或在Perl中取消强制使用Unicode)。</target>
        </trans-unit>
        <trans-unit id="fa74775094fcf161164e8e879c58a4b633ace5dd" translate="yes" xml:space="preserve">
          <source>Forcing a Stack Trace</source>
          <target state="translated">强制堆栈跟踪</target>
        </trans-unit>
        <trans-unit id="f6c5999fd3e671fe9fe9df464e28ef5ab21206ca" translate="yes" xml:space="preserve">
          <source>Forcing big- or little-endian byte-order on floating-point values for data exchange can work only if all platforms use the same binary representation such as IEEE floating-point. Even if all platforms are using IEEE, there may still be subtle differences. Being able to use &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on floating-point values can be useful, but also dangerous if you don't know exactly what you're doing. It is not a general way to portably store floating-point values.</source>
          <target state="translated">仅当所有平台都使用相同的二进制表示形式（例如IEEE浮点数）时，才能在浮点值上强制使用大尾数字节顺序或小尾数字节顺序进行数据交换。即使所有平台都使用IEEE，也可能存在细微的差异。能够在浮点值上使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 可能会很有用，但是如果您不确切知道自己在做什么，那也很危险。这不是可移植地存储浮点值的通用方法。</target>
        </trans-unit>
        <trans-unit id="4fbdd84d18aabd3608a03167cf0b04d250e02a5e" translate="yes" xml:space="preserve">
          <source>Foreach Loops</source>
          <target state="translated">Foreach Loops</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="3142b84bb5d35f3314b7947362fd81b2dce6a441" translate="yes" xml:space="preserve">
          <source>Forking pipe open() constructs will be supported in future.</source>
          <target state="translated">今后将支持叉管打开()构造。</target>
        </trans-unit>
        <trans-unit id="c82bb36a64035b3b3d413194135e78450e65b2bf" translate="yes" xml:space="preserve">
          <source>Format Pod as RTF</source>
          <target state="translated">格式化Pod为RTF</target>
        </trans-unit>
        <trans-unit id="fee1af11bb1eb0f8161a549c43ed448ab786fe6a" translate="yes" xml:space="preserve">
          <source>Format Pod as plaintext</source>
          <target state="translated">将Pod格式化为纯文本</target>
        </trans-unit>
        <trans-unit id="7740187b3e5d9aaa6412746917f4e8aaed9600e7" translate="yes" xml:space="preserve">
          <source>Format Pod as validating XHTML</source>
          <target state="translated">格式化Pod作为验证XHTML</target>
        </trans-unit>
        <trans-unit id="13163280307f8765d0afe577cafca7728ff8779c" translate="yes" xml:space="preserve">
          <source>Format Variables</source>
          <target state="translated">格式变量</target>
        </trans-unit>
        <trans-unit id="3a1ad455810d4298663c009286d3773850b6eb92" translate="yes" xml:space="preserve">
          <source>Format defined.</source>
          <target state="translated">格式定义:</target>
        </trans-unit>
        <trans-unit id="45682ea5e61958bde7db300ab1675b68475b3238" translate="yes" xml:space="preserve">
          <source>Format the output with ANSI color escape sequences. Using this option requires that Term::ANSIColor be installed on your system.</source>
          <target state="translated">用ANSI颜色转义序列格式化输出。使用此选项需要在系统中安装Term::ANSIColor。</target>
        </trans-unit>
        <trans-unit id="d1b6f323b8fa9a716a3f6f4fbd038ac4ec784196" translate="yes" xml:space="preserve">
          <source>Format the output with overstrike printing. Bold text is rendered as character, backspace, character. Italics and file names are rendered as underscore, backspace, character. Many pagers, such as &lt;b&gt;less&lt;/b&gt;, know how to convert this to bold or underlined text.</source>
          <target state="translated">使用过大字体打印来格式化输出。粗体文本呈现为字符，退格键，字符。斜体和文件名呈现为下划线，退格键，字符。许多寻呼机（例如&lt;b&gt;less&lt;/b&gt;）都知道如何将其转换为粗体或带下划线的文本。</target>
        </trans-unit>
        <trans-unit id="0070c0e56a4846d0ff72c495dfd2d1f1c3c98911" translate="yes" xml:space="preserve">
          <source>Formats and prints the specified arguments to &lt;code&gt;STDOUT&lt;/code&gt; . See also &lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;.</source>
          <target state="translated">格式化指定的参数并将其输出到 &lt;code&gt;STDOUT&lt;/code&gt; 。另请参见&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3359bd12a9edc6e1c703375835a3905e7b83f91" translate="yes" xml:space="preserve">
          <source>Formats, like packages and subroutines, are declared rather than executed, so they may occur at any point in your program. (Usually it's best to keep them all together though.) They have their own namespace apart from all the other &quot;types&quot; in Perl. This means that if you have a function named &quot;Foo&quot;, it is not the same thing as having a format named &quot;Foo&quot;. However, the default name for the format associated with a given filehandle is the same as the name of the filehandle. Thus, the default format for STDOUT is named &quot;STDOUT&quot;, and the default format for filehandle TEMP is named &quot;TEMP&quot;. They just look the same. They aren't.</source>
          <target state="translated">格式,就像包和子程序一样,是被声明的,而不是被执行的,所以它们可能会出现在你的程序中的任何一点。(通常最好把它们放在一起。)它们有自己的命名空间,与Perl中的其他 &quot;类型 &quot;不同。这意味着,如果你有一个名为 &quot;Foo &quot;的函数,这和有一个名为 &quot;Foo &quot;的格式是不同的。然而,与给定文件柄相关联的格式的默认名称与文件柄的名称相同。因此,STDOUT的默认格式被命名为 &quot;STDOUT&quot;,文件柄TEMP的默认格式被命名为 &quot;TEMP&quot;。它们只是看起来一样。其实不然。</target>
        </trans-unit>
        <trans-unit id="7065a0ba158c8bf72a9807e17d920ae802c062cf" translate="yes" xml:space="preserve">
          <source>Formatted Printing of IVs, UVs, and NVs</source>
          <target state="translated">静脉、UV和NV的格式化印刷。</target>
        </trans-unit>
        <trans-unit id="7de31570e601ac2cf7d8ef74834052348b7c4a16" translate="yes" xml:space="preserve">
          <source>Formatters may also choose to note errors/warnings as comments, besides or instead of emitting them otherwise (as in messages to STDERR, or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing).</source>
          <target state="translated">格式化程序还可以选择将错误/警告记录为注释，除此之外或代替其他方式（例如，发给STDERR的消息或 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ）发送错误/警告。</target>
        </trans-unit>
        <trans-unit id="4dc6255b00d803dd218371c361f3f87de9be4719" translate="yes" xml:space="preserve">
          <source>Formatters may also insert additional comments, including: the release date of the Pod formatter program, the contact address for the author(s) of the formatter, the current time, the name of input file, the formatting options in effect, version of Perl used, etc.</source>
          <target state="translated">格式化程序还可以插入额外的注释,包括:Pod格式化程序的发布日期、格式化程序作者的联系地址、当前时间、输入文件的名称、有效的格式化选项、使用的Perl版本等。</target>
        </trans-unit>
        <trans-unit id="6d3ccf37c71280b1f96c4a2ec7fbdbe45afef9e1" translate="yes" xml:space="preserve">
          <source>Formatters may choose to ignore the markup for purposes of resolving the link and use only the renderable characters in the section name, as in:</source>
          <target state="translated">格式化人员可以选择为了解析链接而忽略标记,只在部分名称中使用可渲染的字符,如。</target>
        </trans-unit>
        <trans-unit id="a4aca088317275f96f5f54edc120b828492554a8" translate="yes" xml:space="preserve">
          <source>Formatters may choose to just not support the S format code, especially in cases where the output format simply has no NBSP character/code and no code for &quot;don't break this stuff across lines&quot;.</source>
          <target state="translated">格式化程序可能会选择干脆不支持S格式代码,特别是在输出格式根本没有NBSP字符/代码,也没有 &quot;不要跨行打断这个东西 &quot;的代码的情况下。</target>
        </trans-unit>
        <trans-unit id="699f62e78d3e814aa9e7d06b34b37d145e111b38" translate="yes" xml:space="preserve">
          <source>Formatting Codes</source>
          <target state="translated">格式化代码</target>
        </trans-unit>
        <trans-unit id="ff5d2a34321adb03892b713850bf4a3ad301ed8c" translate="yes" xml:space="preserve">
          <source>Formatting base class</source>
          <target state="translated">格式化基类</target>
        </trans-unit>
        <trans-unit id="ff9c8d057ff674339898e634f59656ac3a52e2b6" translate="yes" xml:space="preserve">
          <source>Formatting codes absolutely cannot span paragraphs. If a code is opened in one paragraph, and no closing code is found by the end of that paragraph, the Pod parser must close that formatting code, and should complain (as in &quot;Unterminated I code in the paragraph starting at line 123: 'Time objects are not...'&quot;). So these two paragraphs:</source>
          <target state="translated">格式化代码绝对不能跨越段落。如果在一个段落中打开了一个代码,到该段结束时还没有找到关闭代码,那么Pod解析器必须关闭该格式代码,并且应该抱怨(如 &quot;从第123行开始的段落中的未结束I代码:'时间对象不是...'&quot;)。所以这两段。</target>
        </trans-unit>
        <trans-unit id="7b18147368e5bdc22767f902bd572f166454ac0e" translate="yes" xml:space="preserve">
          <source>Formerly &quot;ji&quot;. Usually in Hebrew script.</source>
          <target state="translated">原为 &quot;ji&quot;。通常用希伯来文字。</target>
        </trans-unit>
        <trans-unit id="57f396d4904134a67c253fe83cd6c2ee5405024e" translate="yes" xml:space="preserve">
          <source>Formerly, a reference to an array whose initial element happens to hold a reference to a hash. You used to be able to treat a pseudohash reference as either an array reference or a hash reference. Pseduohashes are no longer supported.</source>
          <target state="translated">以前,一个数组的引用,其初始元素恰好持有一个哈希引用。以前你可以把伪哈希引用当作一个数组引用或哈希引用。现在不再支持 Pseduohash。</target>
        </trans-unit>
        <trans-unit id="966aae1b0b42de1dff8ae5df0d18d67c8938fc59" translate="yes" xml:space="preserve">
          <source>Fortunately, all TAP output is perfect. In the event that it is not, this method will return parser errors. Note that a junk line which the parser does not recognize is &lt;code&gt;not&lt;/code&gt; an error. This allows this parser to handle future versions of TAP. The following are all TAP errors reported by the parser:</source>
          <target state="translated">幸运的是，所有TAP输出都是完美的。如果不是，则此方法将返回解析器错误。请注意，解析器无法识别的垃圾线 &lt;code&gt;not&lt;/code&gt; 错误。这使该解析器可以处理TAP的将来版本。以下是解析器报告的所有TAP错误：</target>
        </trans-unit>
        <trans-unit id="87a70390fb6164a360255317db997a9d16310113" translate="yes" xml:space="preserve">
          <source>Fortunately, all encodings that come with &lt;code&gt;Encode&lt;/code&gt; core are &lt;code&gt;PerlIO&lt;/code&gt; -savvy except for &lt;code&gt;hz&lt;/code&gt; and &lt;code&gt;ISO-2022-kr&lt;/code&gt; . For the gory details, see &lt;a href=&quot;encode/encoding&quot;&gt;Encode::Encoding&lt;/a&gt; and &lt;a href=&quot;encode/perlio&quot;&gt;Encode::PerlIO&lt;/a&gt;.</source>
          <target state="translated">幸运的是，除了 &lt;code&gt;hz&lt;/code&gt; 和 &lt;code&gt;ISO-2022-kr&lt;/code&gt; 之外， &lt;code&gt;Encode&lt;/code&gt; 核心 &lt;code&gt;PerlIO&lt;/code&gt; 所有编码都支持 PerlIO 。有关详细信息，请参见&lt;a href=&quot;encode/encoding&quot;&gt;Encode :: Encoding&lt;/a&gt;和&lt;a href=&quot;encode/perlio&quot;&gt;Encode :: PerlIO&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="97fed1654379ec219795384ff23955f1b1779107" translate="yes" xml:space="preserve">
          <source>Fortunately, most web servers for the mainframe will correctly translate the &lt;code&gt;\n&lt;/code&gt; in the following statement to its ASCII equivalent (&lt;code&gt;\r&lt;/code&gt; is the same under both Unix and z/OS):</source>
          <target state="translated">幸运的是，大多数大型机的Web服务器都可以将以下语句中的 &lt;code&gt;\n&lt;/code&gt; 正确转换为等效的ASCII码（Unix和z / OS下的 &lt;code&gt;\r&lt;/code&gt; 是相同的）：</target>
        </trans-unit>
        <trans-unit id="f8866d15529a7057b903143f3bead50cd0b88e71" translate="yes" xml:space="preserve">
          <source>Fortunately, sometimes this kernel &quot;feature&quot; can be disabled. Unfortunately, there are two ways to disable it. The system can simply outlaw scripts with any set-id bit set, which doesn't help much. Alternately, it can simply ignore the set-id bits on scripts.</source>
          <target state="translated">幸运的是,有时候这个内核 &quot;功能 &quot;是可以被禁用的。不幸的是,有两种方法可以禁用它。系统可以简单地取缔任何设置了set-id位的脚本,这并没有什么帮助。另外,它也可以直接忽略脚本上的set-id位。</target>
        </trans-unit>
        <trans-unit id="43f164c645e50a4c0c3f29fb561f1f66b8762dff" translate="yes" xml:space="preserve">
          <source>Fortunately, you only need to know 10% of what's in the main page to get 90% of the benefit. This page will show you that 10%.</source>
          <target state="translated">幸运的是,你只需要知道主页面中10%的内容,就能获得90%的好处。本页将告诉你这10%的内容。</target>
        </trans-unit>
        <trans-unit id="c005499309629c2dd1540384f9d88388c2791d54" translate="yes" xml:space="preserve">
          <source>Forums</source>
          <target state="translated">Forums</target>
        </trans-unit>
        <trans-unit id="7babeb8dda00cbd2717c46859a597a0ac26af8c6" translate="yes" xml:space="preserve">
          <source>Frame Listing Output Examples</source>
          <target state="translated">帧列表输出示例</target>
        </trans-unit>
        <trans-unit id="e7de308f5cb42aaa93cfde86991651a82d8099b3" translate="yes" xml:space="preserve">
          <source>Framework for localization</source>
          <target state="translated">本地化框架</target>
        </trans-unit>
        <trans-unit id="3b8bd7caa7cebf02d88ee7c7bdba92155a41dbde" translate="yes" xml:space="preserve">
          <source>Framework for parsing Pod</source>
          <target state="translated">Pod解析框架</target>
        </trans-unit>
        <trans-unit id="53885018ee90a10b7bc48c0249fdec51585e188f" translate="yes" xml:space="preserve">
          <source>Free (as in beer) books</source>
          <target state="translated">免费(啤酒)书籍</target>
        </trans-unit>
        <trans-unit id="2045f9df7f3ddf3a7ca6cf0c4237136b9a9c596f" translate="yes" xml:space="preserve">
          <source>Free an op. Only use this when an op is no longer linked to from any optree.</source>
          <target state="translated">释放一个opt。只有当一个optree不再与任何optree链接时,才可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="eb0e32e0a58271635c4ef7fbb31d2d946383137e" translate="yes" xml:space="preserve">
          <source>Free any magic storage used by the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">释放SV使用的所有魔术存储。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e846928fcc144c7bd2db6d810b3f5976c347e3ce" translate="yes" xml:space="preserve">
          <source>Free the SV at offset po in the current pad.</source>
          <target state="translated">释放当前焊盘中偏移量po处的SV。</target>
        </trans-unit>
        <trans-unit id="7da50e46bbfce92aaf6cbf3942c4d4d8527613b3" translate="yes" xml:space="preserve">
          <source>Free the storage associated with the tied handle referenced by</source>
          <target state="translated">释放与由</target>
        </trans-unit>
        <trans-unit id="97f264039513cfe75ea6d652749d14c6132a0656" translate="yes" xml:space="preserve">
          <source>Free the storage associated with the tied scalar referenced by</source>
          <target state="translated">释放与由</target>
        </trans-unit>
        <trans-unit id="7b25f5206df2f27aaf3f69eecf641cc773e18f45" translate="yes" xml:space="preserve">
          <source>FreeBSD core dumps from readdir_r with ithreads</source>
          <target state="translated">用ithreads从readdir_r中提取FreeBSD核心转储。</target>
        </trans-unit>
        <trans-unit id="fffe09c3013e58f78e37a3579c3723dc99001d0b" translate="yes" xml:space="preserve">
          <source>Freely available locale definitions</source>
          <target state="translated">免费提供的地点定义</target>
        </trans-unit>
        <trans-unit id="1a3d88c35190d4b2447d53bf45570277fd2a7644" translate="yes" xml:space="preserve">
          <source>Frees the all the elements of a hash, leaving it empty. The XS equivalent of &lt;code&gt;%hash = ()&lt;/code&gt; . See also &lt;a href=&quot;#hv_undef&quot;&gt;hv_undef&lt;/a&gt;.</source>
          <target state="translated">释放哈希的所有元素，将其保留为空。等同于 &lt;code&gt;%hash = ()&lt;/code&gt; 的XS 。另请参见&lt;a href=&quot;#hv_undef&quot;&gt;hv_undef&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ef04d800d79b6e48aac64a67f720581e376f905" translate="yes" xml:space="preserve">
          <source>Frequently Asked Question (although not necessarily frequently answered, especially if the answer appears in the Perl FAQ shipped standard with Perl).</source>
          <target state="translated">常见问题(虽然不一定经常回答,特别是当答案出现在Perl标准的FAQ中时)。</target>
        </trans-unit>
        <trans-unit id="36c4bb75f29e144b11648c4e613d655770d581ce" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions About MakeMaker</source>
          <target state="translated">关于MakeMaker的常见问题</target>
        </trans-unit>
        <trans-unit id="760b682e1618036dbf7afb1d053c8ac3b71a79ee" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions about IO::Compress</source>
          <target state="translated">关于IO::Compress的常见问题</target>
        </trans-unit>
        <trans-unit id="af90cef80988974dd76636b3adb5f472768f785d" translate="yes" xml:space="preserve">
          <source>Frequently asked questions</source>
          <target state="translated">常见的问题</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="82bcb61f5c6950aaf9895e515089a465e02bfa4c" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;http://www.hp.com/products1/evolution/9000/faqs.html&quot;&gt;http://www.hp.com/products1/evolution/9000/faqs.html&lt;/a&gt;</source>
          <target state="translated">来自&lt;a href=&quot;http://www.hp.com/products1/evolution/9000/faqs.html&quot;&gt;http://www.hp.com/products1/evolution/9000/faqs.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="448f239f3b8eb7ee92d28473b865c15012705b26" translate="yes" xml:space="preserve">
          <source>From C this function will be called with the following statements.</source>
          <target state="translated">在C语言中,这个函数将用以下语句调用。</target>
        </trans-unit>
        <trans-unit id="bc39bc50c4c934bc3c2b768db25fc832488e05a0" translate="yes" xml:space="preserve">
          <source>From Greek &amp;sigma;ύ&amp;nu;&amp;tau;&amp;alpha;&amp;xi;&amp;iota;&amp;sigmaf;, &amp;ldquo;with-arrangement&amp;rdquo;. How things (particularly symbols) are put together with each other.</source>
          <target state="translated">源自希腊语&amp;sigma;ύ&amp;nu;&amp;tau;&amp;alpha;&amp;xi;&amp;iota;&amp;sigmaf;，&amp;ldquo;有序&amp;rdquo;。事物（尤其是符号）如何相互放置在一起。</target>
        </trans-unit>
        <trans-unit id="42d1e5fd6ff04686a3ddd2292e038e6c2c64eded" translate="yes" xml:space="preserve">
          <source>From Help Consulting, for Windows.</source>
          <target state="translated">来自帮助咨询公司,适用于Windows。</target>
        </trans-unit>
        <trans-unit id="1cd8946f3bf218d8104a97d7a0815f8406dc267b" translate="yes" xml:space="preserve">
          <source>From Swift: someone who eats eggs big end first. Also used of computers that store the most significant &lt;b&gt;byte&lt;/b&gt; of a word at a lower byte address than the least significant byte. Often considered superior to little-endian machines. See also &lt;b&gt;little-endian&lt;/b&gt;.</source>
          <target state="translated">来自Swift：首先吃鸡蛋的人。也用于将单词的最高有效&lt;b&gt;字节&lt;/b&gt;存储在比最低有效字节低的字节地址处的计算机。通常被认为优于小端机器。另请参见&lt;b&gt;little-endian&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="38010d6f3cc7fb3edd4ad08b9ae938ebd7fc3879" translate="yes" xml:space="preserve">
          <source>From Swift: someone who eats eggs little end first. Also used of computers that store the least significant &lt;b&gt;byte&lt;/b&gt; of a word at a lower byte address than the most significant byte. Often considered superior to big-endian machines. See also &lt;b&gt;big-endian&lt;/b&gt;.</source>
          <target state="translated">来自Swift：吃鸡蛋的人很少有收获。也用于将单词的最低有效&lt;b&gt;字节&lt;/b&gt;存储在比最高有效字节低的字节地址处的计算机。通常被认为优于大端机。另请参见&lt;b&gt;big-endian&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="326d38f7c69627e156c632c28265510708e39ea4" translate="yes" xml:space="preserve">
          <source>From how far away you can see a variable, looking through one. Perl has two visibility mechanisms. It does &lt;b&gt;dynamic scoping&lt;/b&gt; of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;&lt;b&gt;variables&lt;/b&gt;, meaning that the rest of the &lt;b&gt;block&lt;/b&gt;, and any &lt;b&gt;subroutines&lt;/b&gt; that are called by the rest of the block, can see the variables that are local to the block. Perl does &lt;b&gt;lexical scoping&lt;/b&gt; of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, meaning that the rest of the block can see the variable, but other subroutines called by the block</source>
          <target state="translated">您可以从多远的地方看到一个变量，通过一个变量进行查看。Perl有两种​​可见性机制。它&lt;b&gt;动态作用域&lt;/b&gt;的 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; &lt;b&gt;变量&lt;/b&gt;，这意味着其余&lt;b&gt;块&lt;/b&gt;，任何&lt;b&gt;子程序&lt;/b&gt;由该块的其余部分调用，可以看到是本地的块中的变量。Perl并&lt;b&gt;词法范围&lt;/b&gt;的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量，这意味着该块的其余部分可以看到该变量，而是由块调用的其他子程序</target>
        </trans-unit>
        <trans-unit id="3d95a8fc94b9e55edd8dcfe43899b426ece0c816" translate="yes" xml:space="preserve">
          <source>From the command line, you can use the &lt;code&gt;cpan&lt;/code&gt; command's &lt;code&gt;-l&lt;/code&gt; switch:</source>
          <target state="translated">在命令行中，可以使用 &lt;code&gt;cpan&lt;/code&gt; 命令的 &lt;code&gt;-l&lt;/code&gt; 开关：</target>
        </trans-unit>
        <trans-unit id="0863cef08a10ff845303e3c15c48a839f8d3f9f0" translate="yes" xml:space="preserve">
          <source>From the command line, you can use the djtar utility provided with DJGPP to unpack and expand these files. For example:</source>
          <target state="translated">在命令行中,您可以使用DJGPP提供的djtar工具来解压和展开这些文件。例如:</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="translated">在命令行中:</target>
        </trans-unit>
        <trans-unit id="d445d94e4dd2201f89b37cfbbd3453a506d83550" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl array. From the C level this is a pointer to an AV.</source>
          <target state="translated">从perl层来看,这是一个指向perl数组的引用。从C层来看,这是一个指向AV的指针。</target>
        </trans-unit>
        <trans-unit id="7f363a7d4784c758d110ec4bcb974b6c5c5684cc" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl array. From the C level this is a pointer to an AV. This is a fixed variant of T_AVREF that decrements the refcount appropriately when returning an AV*. Introduced in perl 5.15.4.</source>
          <target state="translated">从perl层来看,这是一个指向perl数组的引用。从C层来看,这是一个指向AV的指针。这是T_AVREF的一个固定变体,当返回一个AV*时,会适当地减少refcount。在 perl 5.15.4 中引入。</target>
        </trans-unit>
        <trans-unit id="c48843f42734f52f4bf8423d32ddff93043f82f2" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl hash. From the C level this is a pointer to an HV.</source>
          <target state="translated">从 perl 级别来看,这是一个指向 perl 哈希的引用。从C层来看,这是一个指向HV的指针。</target>
        </trans-unit>
        <trans-unit id="ea09196132f236e8b94218aff14a881b8e5f0e36" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl hash. From the C level this is a pointer to an HV. This is a fixed variant of T_HVREF that decrements the refcount appropriately when returning an HV*. Introduced in perl 5.15.4.</source>
          <target state="translated">从 perl 级别来看,这是一个指向 perl 哈希的引用。从 C 层来看,这是一个指向 HV 的指针。这是 T_HVREF 的一个固定变体,当返回 HV*时,会适当地减少 refcount。在 perl 5.15.4 中引入。</target>
        </trans-unit>
        <trans-unit id="65032422ec42df48f1031883e99a8b1b19f04fbb" translate="yes" xml:space="preserve">
          <source>From the perl level this is a reference to a perl subroutine (e.g. $sub = sub { 1 };). From the C level this is a pointer to a CV.</source>
          <target state="translated">从 perl 级别来看,这是一个指向 perl 子程序的引用 (例如,$sub=sub{1 };)。在C层,这是一个指向CV的指针。</target>
        </trans-unit>
        <trans-unit id="5b7e3054d443080121c5abde91b6e93c7323ccbd" translate="yes" xml:space="preserve">
          <source>From the shell, saying</source>
          <target state="translated">从壳里出来,说</target>
        </trans-unit>
        <trans-unit id="856c187ed12caf89813ef33a23ce9aead8f27ac1" translate="yes" xml:space="preserve">
          <source>From the viewpoint of parsing, lexical variable scope and closures,</source>
          <target state="translated">从解析、词汇变量范围和闭包的角度来看。</target>
        </trans-unit>
        <trans-unit id="c5f6042fc1cf780179e4cf386ecd882f23297382" translate="yes" xml:space="preserve">
          <source>From then on, you use the &lt;code&gt;maketext&lt;/code&gt; function to access entries in whatever lexicon(s) belong to the language handle you got. So, this:</source>
          <target state="translated">从那时起，您可以使用 &lt;code&gt;maketext&lt;/code&gt; 函数来访问属于您所获得的语言句柄的任何词典中的条目。所以这：</target>
        </trans-unit>
        <trans-unit id="cb76778ecb1d96c51a66d0bba753022fa7deeffa" translate="yes" xml:space="preserve">
          <source>From there we can get more complex. If the hash values are the same, we can provide a secondary sort on the hash key.</source>
          <target state="translated">从那里我们可以变得更复杂。如果哈希值相同,我们可以在哈希键上提供二次排序。</target>
        </trans-unit>
        <trans-unit id="be6cd2dadd81d9d30843c2caf56c66b7990b6773" translate="yes" xml:space="preserve">
          <source>From this version on the typical SCM (software configuration management) directories are ignored. These are: RCS, CVS, SCCS, .svn, .hg, .git, .sync</source>
          <target state="translated">从这个版本开始,典型的SCM(软件配置管理)目录将被忽略。这些目录是:RCS、CVS、SCCS、.svn、.hg、.git、.sync。RCS,CVS,SCCS,.svn,.hg,.git,.sync.</target>
        </trans-unit>
        <trans-unit id="71c8fee3496d71438c7692e0f92208858f4356f7" translate="yes" xml:space="preserve">
          <source>From this, we can see that the date column stretches from column 1 to column 10 - ten characters wide. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;-ese for &quot;character&quot; is &lt;code&gt;A&lt;/code&gt; , and ten of them are &lt;code&gt;A10&lt;/code&gt; . So if we just wanted to extract the dates, we could say this:</source>
          <target state="translated">由此可见，日期列从第1列延伸到第10列-十个字符宽。&amp;ldquo;字符&amp;rdquo; 的 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; - ese为 &lt;code&gt;A&lt;/code&gt; ，其中十个为 &lt;code&gt;A10&lt;/code&gt; 。因此，如果我们只想提取日期，可以这样说：</target>
        </trans-unit>
        <trans-unit id="05d91e5e8ffd6992838dcbb57817947850fffcf4" translate="yes" xml:space="preserve">
          <source>From time to time, we may mark language constructs and features which we consider to have been mistakes as &lt;b&gt;discouraged&lt;/b&gt;. Discouraged features aren't currently candidates for removal, but we may later deprecate them if they're found to stand in the way of a significant improvement to the Perl core.</source>
          <target state="translated">我们会不时标记&lt;b&gt;不鼓励&lt;/b&gt;我们认为是错误的语言结构和功能。不推荐使用的功能目前尚不建议删除，但是如果发现它们阻碍了Perl核心的重大改进，我们可能会不建议使用。</target>
        </trans-unit>
        <trans-unit id="593b03925f9977503d5df5613ab598e54813e4e2" translate="yes" xml:space="preserve">
          <source>Full Listing of Core Typemaps</source>
          <target state="translated">核心类型图的完整列表</target>
        </trans-unit>
        <trans-unit id="d09e10be00d851e0182ce329905088abb2292e7d" translate="yes" xml:space="preserve">
          <source>Full path to the file that contains the module</source>
          <target state="translated">包含该模块的文件的完整路径</target>
        </trans-unit>
        <trans-unit id="fa7054d0e0a5e06ed1cc20f1f072c76f977dd60d" translate="yes" xml:space="preserve">
          <source>Full-Text Searching in Perl</source>
          <target state="translated">在Perl中进行全文检索</target>
        </trans-unit>
        <trans-unit id="d52b0f8730cd0cb1d50429fd4e409ebd2910fe3a" translate="yes" xml:space="preserve">
          <source>Full-fledged support for I/O layers is now implemented provided Perl is configured to use PerlIO as its IO system (which is now the default).</source>
          <target state="translated">现在,只要 Perl 被配置为使用 PerlIO 作为其 IO 系统(现在是默认的),就可以实现对 I/O 层的全面支持。</target>
        </trans-unit>
        <trans-unit id="950f94e743e045d06f1163691f50c811b3f47b68" translate="yes" xml:space="preserve">
          <source>Fully build and test the Perl distribution. Make sure that no tests are failing with &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;aout_test&lt;/code&gt; targets; fix the bugs in Perl and the Perl test suite detected by these tests. Make sure that &lt;code&gt;all_test&lt;/code&gt; make target runs as clean as possible. Check that</source>
          <target state="translated">完全构建和测试Perl发行版。确保 &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;aout_test&lt;/code&gt; 目标没有任何测试失败；修复Perl和这些测试检测到的Perl测试套件中的错误。确保 &lt;code&gt;all_test&lt;/code&gt; 使目标运行得尽可能干净。检查一下</target>
        </trans-unit>
        <trans-unit id="f1bfa995d978ef3acade5580113154220abfa2db" translate="yes" xml:space="preserve">
          <source>Fully install Perl, including &lt;code&gt;installcmd&lt;/code&gt; target. Copy the generated DLLs to &lt;code&gt;LIBPATH&lt;/code&gt; ; copy the numbered Perl executables (as in</source>
          <target state="translated">完全安装Perl，包括 &lt;code&gt;installcmd&lt;/code&gt; 目标。将生成的DLL复制到 &lt;code&gt;LIBPATH&lt;/code&gt; ；复制编号的Perl可执行文件（如</target>
        </trans-unit>
        <trans-unit id="1ca8ebe0f337f78ac7630965aa7b6d0b1fa91b13" translate="yes" xml:space="preserve">
          <source>Fully qualified name of currently executing subroutine.</source>
          <target state="translated">当前正在执行的子程序的全称。</target>
        </trans-unit>
        <trans-unit id="4e532a9d21737b951917e92fa5d156c715111a5d" translate="yes" xml:space="preserve">
          <source>Fully qualified subroutine names are also supported. For example,</source>
          <target state="translated">也支持完全限定的子程序名。例如:</target>
        </trans-unit>
        <trans-unit id="7135f28e774ac1a9fabb4c75a3d1bb1ada58e29b" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;DumpArray()&lt;/code&gt; allows dumping of multiple values (useful when you need to analyze returns of functions).</source>
          <target state="translated">函数 &lt;code&gt;DumpArray()&lt;/code&gt; 允许转储多个值（在您需要分析函数的返回值时很有用）。</target>
        </trans-unit>
        <trans-unit id="5d11bb00bc4644e08a9be122f115fe39fdd04b5f" translate="yes" xml:space="preserve">
          <source>Function Interface</source>
          <target state="translated">功能接口</target>
        </trans-unit>
        <trans-unit id="89ef743a3244fbdb65d0570367a96fdb2440073a" translate="yes" xml:space="preserve">
          <source>Function Templates</source>
          <target state="translated">功能模板</target>
        </trans-unit>
        <trans-unit id="91de2ff9bd67512188b1968893d91c44f301c251" translate="yes" xml:space="preserve">
          <source>Function and method names seem to work best as all lowercase. E.g., &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; .</source>
          <target state="translated">函数名和方法名似乎都用小写，效果最好。例如， &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c032df1ce97ecae06d159792d2c62e3c02159e83" translate="yes" xml:space="preserve">
          <source>Function and method names seem to work best as all lowercase. e.g., &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; .</source>
          <target state="translated">函数名和方法名似乎都用小写，效果最好。例如， &lt;code&gt;$obj-&amp;gt;as_string()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7563cdfec9156bd4ab2730b5c15af3243697fb62" translate="yes" xml:space="preserve">
          <source>Function called by &lt;code&gt;do_readline&lt;/code&gt; to spawn a glob (or do the glob inside perl on VMS). This code used to be inline, but now perl uses &lt;code&gt;File::Glob&lt;/code&gt; this glob starter is only used by miniperl during the build process. Moving it away shrinks pp_hot.c; shrinking pp_hot.c helps speed perl up.</source>
          <target state="translated">由 &lt;code&gt;do_readline&lt;/code&gt; 调用的函数可产生一个glob（或在VMS的perl内执行glob）。这段代码曾经是内联的，但是现在perl使用 &lt;code&gt;File::Glob&lt;/code&gt; 这个glob启动器仅在构建过程中由miniperl使用。移走它会缩小pp_hot.c; 缩小pp_hot.c有助于加快perl的速度。</target>
        </trans-unit>
        <trans-unit id="9280dd949d70767204a52eb0931da78deffc83d9" translate="yes" xml:space="preserve">
          <source>Function must be called with an already existing SV like</source>
          <target state="translated">函数必须与已经存在的SV一起调用,如</target>
        </trans-unit>
        <trans-unit id="4c163bb94cadf4c0b267646fb2499c8ab2b33874" translate="yes" xml:space="preserve">
          <source>Function pointer, pointing at a function used to handle extended keywords. The function should be declared as</source>
          <target state="translated">函数指针,指向一个用于处理扩展关键字的函数。该函数应声明为</target>
        </trans-unit>
        <trans-unit id="280143fbedd7265a424b9acd0af7c98a66e476a6" translate="yes" xml:space="preserve">
          <source>Functional Interface</source>
          <target state="translated">功能界面</target>
        </trans-unit>
        <trans-unit id="7def83b37bed0c4a472856ea76a2171ece16649f" translate="yes" xml:space="preserve">
          <source>Functional style</source>
          <target state="translated">功能性风格</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="1c61e24efc6706988ce877b75d28b4c69b714a46" translate="yes" xml:space="preserve">
          <source>Functions Returning &lt;code&gt;B::OP&lt;/code&gt; objects or for walking op trees</source>
          <target state="translated">返回 &lt;code&gt;B::OP&lt;/code&gt; 对象或用于行走op树的函数</target>
        </trans-unit>
        <trans-unit id="32ee6f99309a14456cfb212326be3dca1a77b910" translate="yes" xml:space="preserve">
          <source>Functions Returning &lt;code&gt;B::SV&lt;/code&gt; , &lt;code&gt;B::AV&lt;/code&gt; , &lt;code&gt;B::HV&lt;/code&gt; , and &lt;code&gt;B::CV&lt;/code&gt; objects</source>
          <target state="translated">返回 &lt;code&gt;B::SV&lt;/code&gt; ， &lt;code&gt;B::AV&lt;/code&gt; ， &lt;code&gt;B::HV&lt;/code&gt; 和 &lt;code&gt;B::CV&lt;/code&gt; 对象的函数</target>
        </trans-unit>
        <trans-unit id="854549ed50f6375d5b5e7597bbf2e5898d7693ff" translate="yes" xml:space="preserve">
          <source>Functions Returning B::OP objects or for walking op trees</source>
          <target state="translated">函数返回B::OP对象或用于行走的op树。</target>
        </trans-unit>
        <trans-unit id="19372f8fa99b3b7135ba966c21643aafea9c2467" translate="yes" xml:space="preserve">
          <source>Functions Returning B::SV, B::AV, B::HV, and B::CV objects</source>
          <target state="translated">函数返回B::SV、B::AV、B::HV和B::CV对象。</target>
        </trans-unit>
        <trans-unit id="d40a33bf3fa3ed923717e0c5ea11d6e647e8b77a" translate="yes" xml:space="preserve">
          <source>Functions and Attributes</source>
          <target state="translated">功能和属性</target>
        </trans-unit>
        <trans-unit id="5348c5a5b62cd5dc86c5b99972e10885f9a1a5b3" translate="yes" xml:space="preserve">
          <source>Functions called in list context are assumed to have failed if they return an empty list, or a list consisting only of a single undef element.</source>
          <target state="translated">如果在list上下文中调用的函数返回的是一个空列表,或者是一个仅由单个undef元素组成的列表,则被认为是失败的。</target>
        </trans-unit>
        <trans-unit id="6c4c388285c500f1aeb8119de16be0528856e0bc" translate="yes" xml:space="preserve">
          <source>Functions for Examining the Symbol Table</source>
          <target state="translated">检查符号表的功能</target>
        </trans-unit>
        <trans-unit id="7759ffd239fd25b45ca1d91bf1c8ce464ea7bb64" translate="yes" xml:space="preserve">
          <source>Functions for dealing with RFC3066-style language tags</source>
          <target state="translated">用于处理RFC3066风格的语言标签的函数。</target>
        </trans-unit>
        <trans-unit id="88e6ab13b92c2e1e7592687e44e6735c69ae3aad" translate="yes" xml:space="preserve">
          <source>Functions to support Perl's traditional &quot;fast&quot; access to the buffer.</source>
          <target state="translated">支持Perl传统的 &quot;快速 &quot;访问缓冲区的函数。</target>
        </trans-unit>
        <trans-unit id="f616156f7ca62c9f603c623fae3a49e7426583da" translate="yes" xml:space="preserve">
          <source>Functions with a prototype of &lt;code&gt;()&lt;/code&gt; are potential candidates for inlining. If the result after optimization and constant folding is either a constant or a lexically-scoped scalar which has no other references, then it will be used in place of function calls made without &lt;code&gt;&amp;amp;&lt;/code&gt; . Calls made using &lt;code&gt;&amp;amp;&lt;/code&gt; are never inlined. (See</source>
          <target state="translated">具有 &lt;code&gt;()&lt;/code&gt; 原型的函数可能是内联的候选对象。如果优化和常量折叠后的结果是常量或没有其他引用的词法范围标量，则将使用它代替不带 &lt;code&gt;&amp;amp;&lt;/code&gt; 进行的函数调用。使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 进行的呼叫永远不会内联。 （看到</target>
        </trans-unit>
        <trans-unit id="052d8ad81d99f33b2eb06e6d194282b8675fb201" translate="yes" xml:space="preserve">
          <source>Fundamentals</source>
          <target state="translated">Fundamentals</target>
        </trans-unit>
        <trans-unit id="a9d8d1b8ae4349b8a01d7c63e451fd799a9b7f8b" translate="yes" xml:space="preserve">
          <source>Funnies Section</source>
          <target state="translated">有趣的部分</target>
        </trans-unit>
        <trans-unit id="04c4c0235c4dcde402f292623ee26bd9ccce865c" translate="yes" xml:space="preserve">
          <source>Further Resources</source>
          <target state="translated">更多资源</target>
        </trans-unit>
        <trans-unit id="a4850790bffd17894b4ec0822c491be3c4610fd3" translate="yes" xml:space="preserve">
          <source>Further examples of process-scope changes include &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; and changing uids and gids.</source>
          <target state="translated">进程范围更改的其他示例包括 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask()&lt;/a&gt;&lt;/code&gt; 以及更改的uid和gid。</target>
        </trans-unit>
        <trans-unit id="5e8e4bbb1cbc5567f472983c6110b377f52c0cca" translate="yes" xml:space="preserve">
          <source>Further reading can be found using the modules and links below.</source>
          <target state="translated">可通过以下模块和链接进行进一步阅读。</target>
        </trans-unit>
        <trans-unit id="ae0759b489099f7e983a5855b98b07fd1e2ddbe3" translate="yes" xml:space="preserve">
          <source>Further, the first element in a range never needs adjustment, as the adjustment would be just adding 0.</source>
          <target state="translated">此外,一个范围内的第一个元素永远不需要调整,因为调整只是加0。</target>
        </trans-unit>
        <trans-unit id="33028254f3093deff3764d716f328fa4ad9e5425" translate="yes" xml:space="preserve">
          <source>Further:</source>
          <target state="translated">Further:</target>
        </trans-unit>
        <trans-unit id="a080bfabfc41a91686c46efc096f30ef4fbf522d" translate="yes" xml:space="preserve">
          <source>Furthermore, Perl inspects the operands of logical operators to decide whether to use smartmatching for each one by applying the above test to the operands:</source>
          <target state="translated">此外,Perl还检查逻辑运算符的操作数,通过对操作数应用上述测试来决定是否对每个操作数使用智能匹配。</target>
        </trans-unit>
        <trans-unit id="51adfdfc6e30f15b7ff308a0a13705b1d26d399a" translate="yes" xml:space="preserve">
          <source>Furthermore, don't forget the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; in there, as &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $kv (%hash) {}&lt;/code&gt; iterates over the keys and values, and is generally not useful ($kv would be a key, then a value, and so on).</source>
          <target state="translated">此外，不要忘记其中的 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;functions/foreach&quot;&gt;foreach&lt;/a&gt; &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $kv (%hash) {}&lt;/code&gt; 会在键和值上进行迭代，并且通常没有用（$ kv是键，然后是值，依此类推） 。</target>
        </trans-unit>
        <trans-unit id="db93480872e46ff5e0a7c8f5556d4345f41eef53" translate="yes" xml:space="preserve">
          <source>Furthermore, even if you have enabled this feature to be compiled, you need to enable it in runtime with an environment variable: &lt;code&gt;PERL_C_BACKTRACE_ON_ERROR=10&lt;/code&gt; . It must be an integer higher than zero, telling the desired frame count.</source>
          <target state="translated">此外，即使已启用此功能，也需要在运行时使用环境变量 &lt;code&gt;PERL_C_BACKTRACE_ON_ERROR=10&lt;/code&gt; 启用它。它必须是大于零的整数，以告知所需的帧数。</target>
        </trans-unit>
        <trans-unit id="79dbf7bed4736677573eda1bcecd5ea72126d919" translate="yes" xml:space="preserve">
          <source>Furthermore, for doing normal I/O you might need these:</source>
          <target state="translated">此外,对于做普通的I/O,你可能需要这些。</target>
        </trans-unit>
        <trans-unit id="48cc69c08fdaa003e83ba71f62025b569c3f16f4" translate="yes" xml:space="preserve">
          <source>Furthermore, ftp uris only support anonymous connections, so no named user/password pair can be passed along.</source>
          <target state="translated">此外,ftp uris只支持匿名连接,所以不能传递命名用户/密码对。</target>
        </trans-unit>
        <trans-unit id="524b0aff95e7ba2007348850646d7ceb43e068a9" translate="yes" xml:space="preserve">
          <source>Furthermore, remember that this caveat also applies to fork(), which is emulated by threads on Win32.</source>
          <target state="translated">此外,请记住,这个注意事项也适用于fork(),它是由Win32上的线程模拟的。</target>
        </trans-unit>
        <trans-unit id="d309a10ab62a5f76770beb2bdc55a4d79f7053a2" translate="yes" xml:space="preserve">
          <source>Furthermore, some evil vendors will claim 1003.1 compliance, but in fact are not so: they will not pass the PCTS (POSIX Compliance Test Suites). For example, one vendor may not define &lt;code&gt;EDEADLK&lt;/code&gt; , or the semantics of the errno values set by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(2)&lt;/a&gt;&lt;/code&gt; might not be quite right. Perl does not attempt to verify POSIX compliance. That means you can currently successfully say &quot;use POSIX&quot;, and then later in your program you find that your vendor has been lax and there's no usable &lt;code&gt;ICANON&lt;/code&gt; macro after all. This could be construed to be a bug.</source>
          <target state="translated">此外，一些邪恶的供应商会声称其符合1003.1标准，但实际上并非如此：它们不会通过PCTS（POSIX兼容性测试套件）。例如，一个供应商可能未定义 &lt;code&gt;EDEADLK&lt;/code&gt; ，或者由 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open(2)&lt;/a&gt;&lt;/code&gt; 设置的errno值的语义可能不太正确。Perl不会尝试验证POSIX合规性。这意味着您当前可以成功地说出&amp;ldquo; use POSIX&amp;rdquo;，然后在程序中以后发现供应商松懈，根本没有可用的 &lt;code&gt;ICANON&lt;/code&gt; 宏。这可以解释为一个错误。</target>
        </trans-unit>
        <trans-unit id="13d4a69739d0088cb136cc4c16c74a337aabc059" translate="yes" xml:space="preserve">
          <source>Furthermore, special values, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;prenormalized&quot;&lt;/code&gt; , can be used, though they are not concerned with &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; .</source>
          <target state="translated">此外，可以使用特殊值 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&quot;prenormalized&quot;&lt;/code&gt; ，尽管它们与 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 无关。</target>
        </trans-unit>
        <trans-unit id="8a481ff3ccbda516b9f33c8d20b42f50467089ec" translate="yes" xml:space="preserve">
          <source>Furthermore, when called from within the DB package in list context, and with an argument, caller returns more detailed information: it sets the list variable &lt;code&gt;@DB::args&lt;/code&gt; to be the arguments with which the subroutine was invoked.</source>
          <target state="translated">此外，在列表上下文中从DB包内部调用并带有参数时，调用者返回更详细的信息：它将列表变量 &lt;code&gt;@DB::args&lt;/code&gt; 设置为调用子例程的参数。</target>
        </trans-unit>
        <trans-unit id="3f058db7875f38874b1a8c89b542a4bd6a932573" translate="yes" xml:space="preserve">
          <source>Furthermore, you should make sure that during &lt;code&gt;make test&lt;/code&gt; you do not have any GNU tool packages in your path: some toolkits like Unixutils include some tools (&lt;code&gt;type&lt;/code&gt; for instance) which override the Windows ones and makes tests fail. Remove them from your path while testing to avoid these errors.</source>
          <target state="translated">此外，您应该确保在进行 &lt;code&gt;make test&lt;/code&gt; 期间您的路径中没有任何GNU工具包：某些工具包（例如Unixutils）包括一些工具（例如 &lt;code&gt;type&lt;/code&gt; ），它们会覆盖Windows的工具并使测试失败。在测试时将其从您的路径中删除，以避免出现这些错误。</target>
        </trans-unit>
        <trans-unit id="d46735054f3a821c36d8dc0e38be2dc8069424e8" translate="yes" xml:space="preserve">
          <source>Future Plans and PERL_IMPLICIT_SYS</source>
          <target state="translated">未来计划和PERL_IMPLICIT_SYS。</target>
        </trans-unit>
        <trans-unit id="3da52a1809c9844f72a921784eef8acaa0a30f71" translate="yes" xml:space="preserve">
          <source>Future versions of Test::Builder will have a way to turn history off.</source>
          <target state="translated">Test::Builder 的未来版本将有一个关闭历史记录的方法。</target>
        </trans-unit>
        <trans-unit id="51696f9d78549516d07f8c451e43127c08733e4f" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may add additional commands.</source>
          <target state="translated">本规范的未来版本可能会增加其他命令。</target>
        </trans-unit>
        <trans-unit id="ca223e70a348b74c3e34848e1279271aecf5c237" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may add additional formatting codes.</source>
          <target state="translated">本规范的未来版本可能会增加额外的格式化代码。</target>
        </trans-unit>
        <trans-unit id="258ec93021438421e3c2a77885ab95a5bc2085a3" translate="yes" xml:space="preserve">
          <source>Future versions of this specification may specify how Pod can accept other encodings. Presumably treatment of other encodings in Pod parsing would be as in XML parsing: whatever the encoding declared by a particular Pod file, content is to be stored in memory as Unicode characters.</source>
          <target state="translated">本规范的未来版本可能会规定Pod如何接受其他编码。据推测,在Pod解析中对其他编码的处理将与XML解析一样:无论特定Pod文件声明的编码是什么,内容都将作为Unicode字符存储在内存中。</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="349a5bc532bd3c593d57694baf4470fa82e87c0e" translate="yes" xml:space="preserve">
          <source>GAMESRVR.DLL</source>
          <target state="translated">GAMESRVR.DLL</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="0ba6cc1e2d0d56ce9630a0f34e6f5f991c2e2104" translate="yes" xml:space="preserve">
          <source>GCC gcov Profiling</source>
          <target state="translated">GCC gcov Profiling</target>
        </trans-unit>
        <trans-unit id="3f0f4dcc948d6cb707fe551e6eeba47a39180607" translate="yes" xml:space="preserve">
          <source>GCC/mingw32 support was added in 5.005 (Nick Ing-Simmons).</source>
          <target state="translated">在5.005中增加了对GCC/mingw32的支持(Nick Ing-Simmons)。</target>
        </trans-unit>
        <trans-unit id="33a96db7f69918beb1bb533b8df7e3de1b7deb54" translate="yes" xml:space="preserve">
          <source>GDBM and Threads on HP-UX</source>
          <target state="translated">HP-UX上的GDBM和线程</target>
        </trans-unit>
        <trans-unit id="905e76d37d3d8721076484b8d01762ed235eeb6a" translate="yes" xml:space="preserve">
          <source>GDBM is available for Cygwin.</source>
          <target state="translated">GDBM适用于Cygwin。</target>
        </trans-unit>
        <trans-unit id="ae00d8f3134d79b137732c9cb7f102d8f0802921" translate="yes" xml:space="preserve">
          <source>GENERAL GUIDELINES</source>
          <target state="translated">一般准则</target>
        </trans-unit>
        <trans-unit id="3b652c3125ece0a5e5b4b20d19c89323f6ee9348" translate="yes" xml:space="preserve">
          <source>GETTING HELP</source>
          <target state="translated">获得帮助</target>
        </trans-unit>
        <trans-unit id="cd86c073f225f3fdc6eca764a69478ae8ba27649" translate="yes" xml:space="preserve">
          <source>GETTING THE PERL SOURCE</source>
          <target state="translated">获取PERL资源</target>
        </trans-unit>
        <trans-unit id="d957a2be14a1b162437963fe1ed8dc23e8a068b0" translate="yes" xml:space="preserve">
          <source>GIT DATA</source>
          <target state="translated">GIT数据</target>
        </trans-unit>
        <trans-unit id="bf98dc1a3b408b3c50c0a64164f6cbb372e44595" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLES</source>
          <target state="translated">全球变量</target>
        </trans-unit>
        <trans-unit id="f25bdd9f8631b9874b5643e6065c3d9abb3ebbf0" translate="yes" xml:space="preserve">
          <source>GLOSSARY</source>
          <target state="translated">GLOSSARY</target>
        </trans-unit>
        <trans-unit id="edd4b1d28d6fabbd459aa39cee2bc60f4dc2cacf" translate="yes" xml:space="preserve">
          <source>GNU &lt;code&gt;info&lt;/code&gt; files</source>
          <target state="translated">GNU &lt;code&gt;info&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="9d091b9a5e4c37cafcd83a2e7be1ecc3c772330b" translate="yes" xml:space="preserve">
          <source>GNU C Library documentation on syslog, &lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&quot;&gt;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&lt;/a&gt;</source>
          <target state="translated">有关syslog的GNU C库文档，&lt;a href=&quot;http://www.gnu.org/software/libc/manual/html_node/Syslog.html&quot;&gt;http：//www.gnu.org/software/libc/manual/html_node/Syslog.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f329865e118f755d9ae2897c3d1036d691b75a09" translate="yes" xml:space="preserve">
          <source>GNU Tar authors have expressed their intention to become completely POSIX-compatible; &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;&gt;http://www.gnu.org/software/tar/manual/html_node/Formats.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">GNU Tar作者已经表达了完全兼容POSIX的意图。 &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;&gt;http://www.gnu.org/software/tar/manual/html_node/Formats.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b96a59e926131797b97a5280ca47b763871d9867" translate="yes" xml:space="preserve">
          <source>GNU as and GNU ld</source>
          <target state="translated">GNU as 和 GNU ld</target>
        </trans-unit>
        <trans-unit id="ffac9623e4fbfd01208662e12093c3420e35fe08" translate="yes" xml:space="preserve">
          <source>GNU info files</source>
          <target state="translated">GNU信息文件</target>
        </trans-unit>
        <trans-unit id="a602c9a5bb16737d2d0e6f0af42d0ffbca2fd496" translate="yes" xml:space="preserve">
          <source>GNU make for OS/390, which is recommended for the build of perl (as well as building CPAN modules and extensions), is available from the &lt;a href=&quot;#Tools&quot;&gt;Tools&lt;/a&gt;.</source>
          <target state="translated">可从&lt;a href=&quot;#Tools&quot;&gt;Tools中&lt;/a&gt;获得建议用于Perl构建（以及构建CPAN模块和扩展）的GNU make for OS / 390 。</target>
        </trans-unit>
        <trans-unit id="a9e95dc9b959dea83d9c2c4412bad8dbf6a30b36" translate="yes" xml:space="preserve">
          <source>GNV$UNIX_SHELL</source>
          <target state="translated">GNV$UNIX_SHELL</target>
        </trans-unit>
        <trans-unit id="d7332b9fd2e3b51ce3e0b297993ed332c301d3b1" translate="yes" xml:space="preserve">
          <source>GOODIES</source>
          <target state="translated">GOODIES</target>
        </trans-unit>
        <trans-unit id="5c3f2689267efedfd1b8d32a4de8ae076b08ae19" translate="yes" xml:space="preserve">
          <source>GOTCHAS</source>
          <target state="translated">GOTCHAS</target>
        </trans-unit>
        <trans-unit id="fe0ce1b835b0b5932a5c8ab2b59f416e1e42dc46" translate="yes" xml:space="preserve">
          <source>GOVERNANCE</source>
          <target state="translated">GOVERNANCE</target>
        </trans-unit>
        <trans-unit id="a0dce8feda03c8a60940891df8a100aa6d34a49e" translate="yes" xml:space="preserve">
          <source>GREAT CIRCLE DISTANCES AND DIRECTIONS</source>
          <target state="translated">大圆圈的距离和方向</target>
        </trans-unit>
        <trans-unit id="f33d85ab379fda0c05941052326738c9fe2a1ea5" translate="yes" xml:space="preserve">
          <source>GSM0338 is for GSM handsets. Though it shares alphanumerals with ASCII, control character ranges and other parts are mapped very differently, mainly to store Greek characters. There are also escape sequences (starting with 0x1B) to cover e.g. the Euro sign.</source>
          <target state="translated">GSM0338是用于GSM手机的。虽然它与ASCII码共享字母数字,但控制字符范围和其他部分的映射非常不同,主要是为了存储希腊字符。还有一些转义序列(从0x1B开始)来覆盖欧元符号等。</target>
        </trans-unit>
        <trans-unit id="c0cf065d2bd69adbe2ec92fa3feabfd7bf3b9886" translate="yes" xml:space="preserve">
          <source>GUI editor written in Perl using wxWidgets and Scintilla with lots of smaller features. Aims for a UI based on Perl principles like TIMTOWTDI and &quot;easy things should be easy, hard things should be possible&quot;.</source>
          <target state="translated">使用wxWidgets和Scintilla用Perl编写的GUI编辑器,有很多小功能。基于 Perl 的原则,如 TIMTOWTDI 和 &quot;简单的事情应该是容易的,困难的事情应该是可能的&quot;,来设计用户界面。</target>
        </trans-unit>
        <trans-unit id="8e8d08c08351d6aca5a776c4b8922b52fb3e13e8" translate="yes" xml:space="preserve">
          <source>GUIs</source>
          <target state="translated">GUIs</target>
        </trans-unit>
        <trans-unit id="65f937109da9f4d01ac30946e434018e19ee2dcd" translate="yes" xml:space="preserve">
          <source>GUTS</source>
          <target state="translated">GUTS</target>
        </trans-unit>
        <trans-unit id="870b564576a2966c189631c03afc2f57fdfb6686" translate="yes" xml:space="preserve">
          <source>GV Functions</source>
          <target state="translated">GV功能</target>
        </trans-unit>
        <trans-unit id="e717e9026bec8b632428e734dfdc5a2ec21c2f4d" translate="yes" xml:space="preserve">
          <source>GV_SUPER indicates that we want to look up the method in the superclasses of the &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">GV_SUPER表示我们要查找的方法中的超 &lt;code&gt;stash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93253898f4f199634af1de90ddc5528b941ce169" translate="yes" xml:space="preserve">
          <source>GVs are usually found as values in stashes (symbol table hashes) where Perl stores its global variables.</source>
          <target state="translated">GVs通常是作为值出现在Perl存储其全局变量的stashes(符号表哈希)中。</target>
        </trans-unit>
        <trans-unit id="da99bf684e2839f1607c7a6984181f3b8083a1e7" translate="yes" xml:space="preserve">
          <source>GZIP INTERFACE</source>
          <target state="translated">GZIP接口</target>
        </trans-unit>
        <trans-unit id="cb13f819c9cca26bbe274d82fa237ae5e6a86319" translate="yes" xml:space="preserve">
          <source>G_ARRAY</source>
          <target state="translated">G_ARRAY</target>
        </trans-unit>
        <trans-unit id="c9afb596821a60db6f147bb13345cb27d6cd8acd" translate="yes" xml:space="preserve">
          <source>G_DISCARD</source>
          <target state="translated">G_DISCARD</target>
        </trans-unit>
        <trans-unit id="7c0c17b4a676352405579500514e68a451e3e0e0" translate="yes" xml:space="preserve">
          <source>G_EVAL</source>
          <target state="translated">G_EVAL</target>
        </trans-unit>
        <trans-unit id="336b3ba483f4b583d3b8e432539a535eec3195ef" translate="yes" xml:space="preserve">
          <source>G_KEEPERR</source>
          <target state="translated">G_KEEPERR</target>
        </trans-unit>
        <trans-unit id="0d759ade2aa36ab678fa55030c3ec31bde1a4c30" translate="yes" xml:space="preserve">
          <source>G_NOARGS</source>
          <target state="translated">G_NOARGS</target>
        </trans-unit>
        <trans-unit id="f4700a48056cc6ff4268baa6339552754ce5bf82" translate="yes" xml:space="preserve">
          <source>G_SCALAR</source>
          <target state="translated">G_SCALAR</target>
        </trans-unit>
        <trans-unit id="ad1ccfc7340540dee07e8608d1a88363df56cc05" translate="yes" xml:space="preserve">
          <source>G_VOID</source>
          <target state="translated">G_VOID</target>
        </trans-unit>
        <trans-unit id="7a9bbda071163c5693883e06db98012930631d19" translate="yes" xml:space="preserve">
          <source>Garbage collection can be confusing when keys are created in a field hash from normal scalars as well as references. Once a reference is</source>
          <target state="translated">当在字段哈希中从普通标量以及引用中创建键时,垃圾收集可能会很混乱。一旦一个引用被</target>
        </trans-unit>
        <trans-unit id="fc30f25cde3aea2004fdaffc34ec529a477f5957" translate="yes" xml:space="preserve">
          <source>Garbage collection in a field hash means that entries will &quot;spontaneously&quot; disappear when the object that created them disappears. That must be borne in mind, especially when looping over a field hash. If anything you do inside the loop could cause an object to go out of scope, a random key may be deleted from the hash you are looping over. That can throw the loop iterator, so it's best to cache a consistent snapshot of the keys and/or values and loop over that. You will still have to check that a cached entry still exists when you get to it.</source>
          <target state="translated">字段哈希中的垃圾收集意味着当创建它们的对象消失时,条目将 &quot;自发 &quot;消失。这一点必须牢记,尤其是在循环处理一个字段哈希时。如果你在循环中做的任何事情都可能导致一个对象离开范围,那么一个随机键可能会从你正在循环的哈希中被删除。这可能会抛出循环迭代器,所以最好是缓存一个一致的键和/或值的快照,然后在上面循环。当你到达缓存的条目时,你仍然需要检查它是否仍然存在。</target>
        </trans-unit>
        <trans-unit id="fc5702bf94c050f203b549ef0c85e9b81b70dad0" translate="yes" xml:space="preserve">
          <source>Garbage-Collected Hashes</source>
          <target state="translated">垃圾收集的哈希值</target>
        </trans-unit>
        <trans-unit id="2ec6ebf4fdb8455b53f8d6215ef9f6363a9f9d67" translate="yes" xml:space="preserve">
          <source>Gather package and POD information from perl module files</source>
          <target state="translated">从perl模块文件中收集包和POD信息。</target>
        </trans-unit>
        <trans-unit id="ff0ce44a9b44893e7937aae11d3bb72fdbd54b73" translate="yes" xml:space="preserve">
          <source>Gathered below are notes describing details of Perl 5's behavior on VMS. They are a supplement to the regular Perl 5 documentation, so we have focussed on the ways in which Perl 5 functions differently under VMS than it does under Unix, and on the interactions between Perl and the rest of the operating system. We haven't tried to duplicate complete descriptions of Perl features from the main Perl documentation, which can be found in the</source>
          <target state="translated">下面收集了描述 Perl 5 在 VMS 上的行为细节的说明。它们是对常规的Perl 5文档的补充,因此我们将重点放在Perl 5在VMS下的功能与在Unix下的不同之处,以及Perl与操作系统其他部分之间的相互作用上。我们并没有试图重复Perl主文档中对Perl特性的完整描述,主文档可以在下面的文档中找到。</target>
        </trans-unit>
        <trans-unit id="b4330768b6cbb368cf11bfc2a1aa3b4b4975bf79" translate="yes" xml:space="preserve">
          <source>Gathers meta data about the &lt;a href=&quot;#raw&quot;&gt;raw&lt;/a&gt; source, stashes it in &lt;a href=&quot;#meta&quot;&gt;meta&lt;/a&gt; and returns it as a hashref. This is done so that the &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s don't have to repeat common checks. Currently this includes:</source>
          <target state="translated">收集有关&lt;a href=&quot;#raw&quot;&gt;原始&lt;/a&gt;源的元数据，将其存储在&lt;a href=&quot;#meta&quot;&gt;meta中&lt;/a&gt;，并将其作为hashref返回。这样做是为了使&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;不必重复常规检查。目前，这包括：</target>
        </trans-unit>
        <trans-unit id="0a7877a5c7bf9a390ddf2644ce8f01d2dd749296" translate="yes" xml:space="preserve">
          <source>Gee, yet another template code - as if we hadn't plenty. But &lt;code&gt;@&lt;/code&gt; saves our day by enabling us to specify the offset from the beginning of the pack buffer to the next item: This is just the value the &lt;code&gt;offsetof&lt;/code&gt; macro (defined in &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ) returns when given a &lt;code&gt;struct&lt;/code&gt; type and one of its field names (&quot;member-designator&quot; in C standardese).</source>
          <target state="translated">e，还有另一个模板代码-好像我们还不多。但是 &lt;code&gt;@&lt;/code&gt; 通过使我们能够指定从包缓冲区的开始到下一个项目的偏移量来节省我们的一天：这只是给定 &lt;code&gt;struct&lt;/code&gt; 类型和以下类型之一时， &lt;code&gt;offsetof&lt;/code&gt; 宏（在 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 中定义）返回的值。它的字段名称（用C语言标准的&amp;ldquo;成员指示符&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="7264840e686c65159ebed179560079a997c941c5" translate="yes" xml:space="preserve">
          <source>General 32-bit vs. 64-bit issues.</source>
          <target state="translated">一般32位与64位的问题。</target>
        </trans-unit>
        <trans-unit id="0b01c727a71003b8392c50d5e2ddffdc179cdf34" translate="yes" xml:space="preserve">
          <source>General Notes</source>
          <target state="translated">一般说明</target>
        </trans-unit>
        <trans-unit id="7bafdc805eb49ade4dcc8f1b7c25df23aa8d76e7" translate="yes" xml:space="preserve">
          <source>General Perl style guide</source>
          <target state="translated">一般Perl风格指南</target>
        </trans-unit>
        <trans-unit id="c4a42d220d26c466f9dbb535a2b1b9eda4a1fde7" translate="yes" xml:space="preserve">
          <source>General Thread Utility Routines</source>
          <target state="translated">一般线程实用程序</target>
        </trans-unit>
        <trans-unit id="faddfc843ac71019b3393df672837907ac7bbcab" translate="yes" xml:space="preserve">
          <source>General Variables</source>
          <target state="translated">一般变量</target>
        </trans-unit>
        <trans-unit id="f183e804ff54f5c70fea1801cabc1af8c1ecfaeb" translate="yes" xml:space="preserve">
          <source>General behaviour in list contexts</source>
          <target state="translated">列表背景下的一般行为</target>
        </trans-unit>
        <trans-unit id="c3adf35af62fa854c8d064fa3f4201bca217f3c3" translate="yes" xml:space="preserve">
          <source>General behaviour in scalar and void contexts</source>
          <target state="translated">标量和虚空情况下的一般行为。</target>
        </trans-unit>
        <trans-unit id="f87d868ae9e6c5e095ed3921aff5b72a01552118" translate="yes" xml:space="preserve">
          <source>General examples:</source>
          <target state="translated">一般例子:</target>
        </trans-unit>
        <trans-unit id="1fa7d4327fa3fac797d2494a8dbdc1859972a516" translate="yes" xml:space="preserve">
          <source>General explanations on cross-compiling WinCE</source>
          <target state="translated">交叉编译WinCE的一般说明</target>
        </trans-unit>
        <trans-unit id="93ab49617e74fefea30381e0a0b013db01a2c54c" translate="yes" xml:space="preserve">
          <source>General tools</source>
          <target state="translated">一般工具</target>
        </trans-unit>
        <trans-unit id="bc589851c4083a051730b622221b86c22bbd8a1c" translate="yes" xml:space="preserve">
          <source>Generalized quotes. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">广义引号。请参阅&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c176de14201d5eb9a9b50ccc11298ef3cd109ef6" translate="yes" xml:space="preserve">
          <source>Generalized quotes. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">广义引号。请参阅&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad57f21ae3c6ac53ed83e3da2f741a3990c73305" translate="yes" xml:space="preserve">
          <source>Generally anything not exported is still accessible from outside the module using the &lt;code&gt;YourModule::item_name&lt;/code&gt; (or &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) syntax. By convention you can use a leading underscore on names to informally indicate that they are 'internal' and not for public use.</source>
          <target state="translated">通常，仍可以使用 &lt;code&gt;YourModule::item_name&lt;/code&gt; （或 &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ）语法从模块外部访问未导出的任何内容。按照惯例，您可以在名称上使用前导下划线来非正式地表明它们是&amp;ldquo;内部&amp;rdquo;而不是供公众使用。</target>
        </trans-unit>
        <trans-unit id="80cc2c98f271588e14fc9b40a4be695fc7549ee7" translate="yes" xml:space="preserve">
          <source>Generally anything not exported is still accessible from outside the module using the ModuleName::item_name (or &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ) syntax. By convention you can use a leading underscore on names to indicate informally that they are 'internal' and not for public use.</source>
          <target state="translated">通常，仍可以使用ModuleName :: item_name（或 &lt;code&gt;$blessed_ref-&amp;gt;method&lt;/code&gt; ）语法从模块外部访问未导出的任何内容。按照惯例，您可以在名称上使用前导下划线，以非正式地表明它们是&amp;ldquo;内部&amp;rdquo;而不是供公众使用。</target>
        </trans-unit>
        <trans-unit id="a1fe2ca53692f111e8f5344d4ee32097c8e139d1" translate="yes" xml:space="preserve">
          <source>Generally one only needs to call the &lt;code&gt;WriteConstants&lt;/code&gt; function, and then</source>
          <target state="translated">通常，只需要调用 &lt;code&gt;WriteConstants&lt;/code&gt; 函数，然后</target>
        </trans-unit>
        <trans-unit id="327b665fa95397f25e3867f7836460cb799d0a0c" translate="yes" xml:space="preserve">
          <source>Generally used in a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block at the end of a loop to clear variables and reset &lt;code&gt;??&lt;/code&gt; searches so that they work again. The expression is interpreted as a list of single characters (hyphens allowed for ranges). All variables and arrays beginning with one of those letters are reset to their pristine state. If the expression is omitted, one-match searches (&lt;code&gt;?pattern?&lt;/code&gt; ) are reset to match again. Only resets variables or searches in the current package. Always returns 1. Examples:</source>
          <target state="translated">通常用于在 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 在一个循环来明确变量和复位结束块 &lt;code&gt;??&lt;/code&gt; 搜索，以便它们再次工作。该表达式被解释为单个字符的列表（范围中允许使用连字符）。以这些字母之一开头的所有变量和数组都将重置为原始状态。如果省略表达式，则将一次匹配搜索（ &lt;code&gt;?pattern?&lt;/code&gt; ）重置为再次匹配。仅重置变量或在当前程序包中搜索。始终返回1。</target>
        </trans-unit>
        <trans-unit id="6ed5d2aaf3ce44a61b56b98845df66b1842be7d7" translate="yes" xml:space="preserve">
          <source>Generally used in a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block at the end of a loop to clear variables and reset &lt;code&gt;??&lt;/code&gt; searches so that they work again. The expression is interpreted as a list of single characters (hyphens allowed for ranges). All variables and arrays beginning with one of those letters are reset to their pristine state. If the expression is omitted, one-match searches (&lt;code&gt;?pattern?&lt;/code&gt; ) are reset to match again. Only resets variables or searches in the current package. Always returns 1. Examples:</source>
          <target state="translated">通常用于在 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 在一个循环来明确变量和复位结束块 &lt;code&gt;??&lt;/code&gt; 搜索，以便它们再次工作。该表达式被解释为单个字符的列表（范围中允许使用连字符）。以这些字母之一开头的所有变量和数组都将重置为原始状态。如果省略表达式，则将一次匹配搜索（ &lt;code&gt;?pattern?&lt;/code&gt; ）重置为再次匹配。仅重置变量或在当前程序包中搜索。始终返回1。</target>
        </trans-unit>
        <trans-unit id="0d7b613cee2366987a969166247d56f35fe8603c" translate="yes" xml:space="preserve">
          <source>Generally, a collection of procedures. In ancient days, referred to a collection of subroutines in a</source>
          <target state="translated">一般是指程序的集合。在古代,指的是一个子程序的集合,在一个。</target>
        </trans-unit>
        <trans-unit id="f3328c5ae4397dc3c4222ba39a73bb9ae82f5a28" translate="yes" xml:space="preserve">
          <source>Generally, any &lt;b&gt;token&lt;/b&gt; or &lt;b&gt;metasymbol&lt;/b&gt;. Often used more specifically to mean the sort of name you might find in a &lt;b&gt;symbol table&lt;/b&gt;.</source>
          <target state="translated">通常，任何&lt;b&gt;令牌&lt;/b&gt;或&lt;b&gt;元符号&lt;/b&gt;。通常更专门用来表示您在&lt;b&gt;符号表中&lt;/b&gt;可以找到的名称。</target>
        </trans-unit>
        <trans-unit id="b4a6c168526aaa7b030a8b864e61338267716f45" translate="yes" xml:space="preserve">
          <source>Generally, each argument has one leading &quot;:&quot; and one trailing &quot;:&quot; removed (if any). They are then joined together by a &quot;:&quot;. Special treatment applies for arguments denoting updir paths like &quot;::lib:&quot;, see (4), or arguments consisting solely of colons (&quot;colon paths&quot;), see (5).</source>
          <target state="translated">一般来说,每个参数都去掉一个前导的&quot;:&quot;和一个尾部的&quot;:&quot;(如果有的话)。然后用&quot;:&quot;将它们连接在一起。对于表示upir路径的参数,如&quot;::lib:&quot;,见(4),或者只由冒号组成的参数(&quot;冒号路径&quot;),见(5)。</target>
        </trans-unit>
        <trans-unit id="dbca80a0f1b382deb6a1f5ce103056435b9b61d1" translate="yes" xml:space="preserve">
          <source>Generally, if you want to store an undefined value in an AV or HV, you should not use &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; , but rather create a new undefined value using the &lt;code&gt;newSV&lt;/code&gt; function, for example:</source>
          <target state="translated">通常，如果要在AV或HV中存储未定义的值，则不应使用 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ，而应使用 &lt;code&gt;newSV&lt;/code&gt; 函数创建新的未定义的值，例如：</target>
        </trans-unit>
        <trans-unit id="a7888dab6e27a5d395183c226ba655dd95d81794" translate="yes" xml:space="preserve">
          <source>Generate C code for XS modules' constants.</source>
          <target state="translated">为XS模块的常量生成C代码。</target>
        </trans-unit>
        <trans-unit id="55b679a0cfa0771f77ea49b9d53b6db25d85485e" translate="yes" xml:space="preserve">
          <source>Generate C/C++ code for the XS initializer function.</source>
          <target state="translated">为XS初始化函数生成C/C++代码。</target>
        </trans-unit>
        <trans-unit id="6d7a20114b9e2f4adde607a7de6cdc77812cd5c3" translate="yes" xml:space="preserve">
          <source>Generate MYMETA information as a hash either from an existing CPAN Meta file (META.json or META.yml) or from internal data.</source>
          <target state="translated">从现有的CPAN元文件(META.json或META.yml)或内部数据生成MYMETA信息作为哈希值。</target>
        </trans-unit>
        <trans-unit id="fad9ff08051acbfd579989fe7d09533be58fc8b2" translate="yes" xml:space="preserve">
          <source>Generate XS code to import C header constants</source>
          <target state="translated">生成XS代码以导入C头常量。</target>
        </trans-unit>
        <trans-unit id="cf1ca662ada637e9d6d3c74e2b646acad00573f4" translate="yes" xml:space="preserve">
          <source>Generate a summary file called</source>
          <target state="translated">生成一个名为</target>
        </trans-unit>
        <trans-unit id="a58e7b39e158d6f21c17511a146b04839f328ccd" translate="yes" xml:space="preserve">
          <source>Generate an accessor method for each element of structs and unions. The generated methods are named after the element name; will return the current value of the element if called without additional arguments; and will set the element to the supplied value (and return the new value) if called with an additional argument. Embedded structures and unions are returned as a pointer rather than the complete structure, to facilitate chained calls.</source>
          <target state="translated">为结构体和联合体的每个元素生成一个访问方法。生成的方法以元素名称命名;如果没有附加参数,将返回元素的当前值;如果有附加参数,将把元素设置为提供的值(并返回新值)。嵌入的结构和联合体会以指针而不是完整的结构返回,以方便链式调用。</target>
        </trans-unit>
        <trans-unit id="37ce6c2156457df8501e4c1fb83210aa39acfaeb" translate="yes" xml:space="preserve">
          <source>Generate an index at the top of the HTML file (default behaviour).</source>
          <target state="translated">在HTML文件的顶部生成一个索引(默认行为)。</target>
        </trans-unit>
        <trans-unit id="da1068fe142a5298b63a98d32acd80f4a76500cb" translate="yes" xml:space="preserve">
          <source>Generate an index at the top of the HTML file. This is the default behaviour.</source>
          <target state="translated">在HTML文件的顶部生成一个索引。这是默认的行为。</target>
        </trans-unit>
        <trans-unit id="255b7210c6594b83b698aa3fb4e69e8ff01d426e" translate="yes" xml:space="preserve">
          <source>Generate and return a fresh cop hints hash containing no entries.</source>
          <target state="translated">生成并返回一个不包含任何条目的新的cop hints hash。</target>
        </trans-unit>
        <trans-unit id="d85a3b5f2926e3396853e594219b817c7146a9d2" translate="yes" xml:space="preserve">
          <source>Generate stubs for a SelfLoading module</source>
          <target state="translated">为SelfLoading模块生成存根。</target>
        </trans-unit>
        <trans-unit id="0ba19194216be13c7f866968bcf3a987117cf5e8" translate="yes" xml:space="preserve">
          <source>Generate test reports if CPAN::Reporter is installed (yes/no)?</source>
          <target state="translated">如果安装了CPAN::Reporter,则生成测试报告(是/否)?</target>
        </trans-unit>
        <trans-unit id="548e0abe962fe7973873ce7fe29b5c45581f9fb6" translate="yes" xml:space="preserve">
          <source>Generate the Makefile and run make. Change the test number in Mytest.t to &quot;9&quot; and add the following tests:</source>
          <target state="translated">生成Makefile并运行make。将Mytest.t中的测试编号改为 &quot;9&quot;,并添加以下测试。</target>
        </trans-unit>
        <trans-unit id="2e30a1f598292d25659b6f3a250f216bc967e7e7" translate="yes" xml:space="preserve">
          <source>Generate the default target 'all'.</source>
          <target state="translated">生成默认目标'全部'。</target>
        </trans-unit>
        <trans-unit id="4d962473f477d6b33e6a92b907153b952636d0f9" translate="yes" xml:space="preserve">
          <source>Generate the metafile target.</source>
          <target state="translated">生成元文件目标。</target>
        </trans-unit>
        <trans-unit id="4db92d1f5198cc69e763847675b8fcf87ee5935e" translate="yes" xml:space="preserve">
          <source>Generate the signature target.</source>
          <target state="translated">生成签名目标。</target>
        </trans-unit>
        <trans-unit id="de5fc6d42feef255045834472628eb831eead292" translate="yes" xml:space="preserve">
          <source>Generated internally. Is zero or undefined if name is 7 bit ASCII, &quot;no&quot; if the name is 8 bit (and so should only match if SvUTF8() is false), &quot;yes&quot; if the name is utf8 encoded.</source>
          <target state="translated">内部生成的,如果名字是7位ASCII码,则为0或未定义,如果名字是8位,则为 &quot;no&quot;(因此只有在SvUTF8(false)的情况下才会匹配。如果名字是7位ASCII码,则为0或未定义;如果名字是8位,则为 &quot;no&quot;(因此只有在SvUTF8()为false时才会匹配);如果名字是utf8编码,则为 &quot;yes&quot;。</target>
        </trans-unit>
        <trans-unit id="95fc43dc3dce502b8d3a439f3daa647aaa660090" translate="yes" xml:space="preserve">
          <source>Generates</source>
          <target state="translated">Generates</target>
        </trans-unit>
        <trans-unit id="c167e00e247a5f64156fc2c863e8097c40ce0f9e" translate="yes" xml:space="preserve">
          <source>Generates Foo__Bar.3 style man page names</source>
          <target state="translated">生成Foo__Bar.3风格的man页面名称。</target>
        </trans-unit>
        <trans-unit id="43bc892fe6a292ae97df44de7203d863e807362e" translate="yes" xml:space="preserve">
          <source>Generates a .pm file which is backwards compatible with the specified perl version.</source>
          <target state="translated">生成一个向后兼容指定perl版本的.pm文件。</target>
        </trans-unit>
        <trans-unit id="e7c963d48f673cb2a0857ed31de8d6aa72aa362b" translate="yes" xml:space="preserve">
          <source>Generates a make fragment defining all the macros initialized in init_dist.</source>
          <target state="translated">生成一个make片段,定义init_dist中初始化的所有宏。</target>
        </trans-unit>
        <trans-unit id="17a9c3599652e9b94156636fc524075142b2c6bc" translate="yes" xml:space="preserve">
          <source>Generates a set of @commands which print the $text to a $file.</source>
          <target state="translated">生成一组@命令,将$文本打印到$文件中。</target>
        </trans-unit>
        <trans-unit id="790a5b36d77c0cf3beb51e493e823c8123ef2b5c" translate="yes" xml:space="preserve">
          <source>Generates and returns a &lt;code&gt;HV *&lt;/code&gt; representing the content of a &lt;code&gt;refcounted_he&lt;/code&gt; chain.</source>
          <target state="translated">生成并返回表示 &lt;code&gt;refcounted_he&lt;/code&gt; 链内容的 &lt;code&gt;HV *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcbbd96d2dbbc6700210cc4fb74779eab56f16fe" translate="yes" xml:space="preserve">
          <source>Generates and returns a standard Perl hash representing the full set of hint entries in the cop</source>
          <target state="translated">生成并返回一个标准的Perl哈希,代表cop中的全部提示项。</target>
        </trans-unit>
        <trans-unit id="1421406c3adcfc5c7625f4edebffbd408bd80ab6" translate="yes" xml:space="preserve">
          <source>Generates and returns a standard Perl hash representing the full set of key/value pairs in the cop hints hash</source>
          <target state="translated">生成并返回一个标准的Perl哈希,表示cop hints哈希中的全部键/值对。</target>
        </trans-unit>
        <trans-unit id="855ea3ad4660369a0d200ca547e9d16bbf1aed26" translate="yes" xml:space="preserve">
          <source>Generates cross reference reports for Perl programs</source>
          <target state="translated">为Perl程序生成交叉引用报告</target>
        </trans-unit>
        <trans-unit id="e3de133c1c2ce09b6435425a01ca3e82f3c58065" translate="yes" xml:space="preserve">
          <source>Generates one copy of</source>
          <target state="translated">生成一份</target>
        </trans-unit>
        <trans-unit id="1d207670d95f5fc2643606a3d629315363ac612b" translate="yes" xml:space="preserve">
          <source>Generates one fewer copies of</source>
          <target state="translated">少生成一份</target>
        </trans-unit>
        <trans-unit id="28d7a6917a623daf227d101d7b6ed8834cb89f78" translate="yes" xml:space="preserve">
          <source>Generates prototype code for all xsubs. Default is false.</source>
          <target state="translated">为所有x子生成原型代码。默认为false。</target>
        </trans-unit>
        <trans-unit id="2960b94d28c15d7a694d51b3079b6bc63fbdd48f" translate="yes" xml:space="preserve">
          <source>Generates targets to create the specified directories and set its permission to PERM_DIR.</source>
          <target state="translated">生成目标来创建指定的目录,并将其权限设置为PERM_DIR。</target>
        </trans-unit>
        <trans-unit id="d6e4b3f200d78c6e8a91d9d2272c0f5fb9f6e05c" translate="yes" xml:space="preserve">
          <source>Generates the distmeta target to add META.yml and META.json to the MANIFEST in the distdir.</source>
          <target state="translated">生成distmeta目标,将META.yml和META.json添加到distdir的MANIFEST中。</target>
        </trans-unit>
        <trans-unit id="b310c6f5942ab86898d599d13d2e861f310c17d2" translate="yes" xml:space="preserve">
          <source>Generates the distsignature target to add SIGNATURE to the MANIFEST in the distdir.</source>
          <target state="translated">生成distsignature目标,将SIGNATURE添加到distdir的MANIFEST中。</target>
        </trans-unit>
        <trans-unit id="3730e292a86874c44122818bef743a546bb5f8f3" translate="yes" xml:space="preserve">
          <source>Generates the manifypods target. This target generates man pages from all POD files in MAN1PODS and MAN3PODS.</source>
          <target state="translated">生成manifypods目标。该目标从MAN1PODS和MAN3PODS的所有POD文件中生成man页。</target>
        </trans-unit>
        <trans-unit id="91c589b5a085cc257f1fe2c1088920f6a3260335" translate="yes" xml:space="preserve">
          <source>Generates the path name for the controlling terminal.</source>
          <target state="translated">生成控制终端的路径名。</target>
        </trans-unit>
        <trans-unit id="aa78442f98d8c0e48e911fd577f2432ab2e641a7" translate="yes" xml:space="preserve">
          <source>Generates the value of</source>
          <target state="translated">产生的价值</target>
        </trans-unit>
        <trans-unit id="b08e002657b5f8d224393deee9469ccf8c547be4" translate="yes" xml:space="preserve">
          <source>Generating Combined Tags</source>
          <target state="translated">生成组合标签</target>
        </trans-unit>
        <trans-unit id="2a21214ce61b2e34bac827b1129511447eeb1d87" translate="yes" xml:space="preserve">
          <source>Generating the Makefile and running &lt;code&gt;make&lt;/code&gt; created a directory called blib (which stands for &quot;build library&quot;) in the current working directory. This directory will contain the shared library that we will build. Once we have tested it, we can install it into its final location.</source>
          <target state="translated">生成Makefile并运行 &lt;code&gt;make&lt;/code&gt; 在当前工作目录中创建了一个名为blib的目录（代表&amp;ldquo;构建库&amp;rdquo;）。该目录将包含我们将构建的共享库。测试完之后，我们可以将其安装到最终位置。</target>
        </trans-unit>
        <trans-unit id="bb265528826c32e783457930a0be091d852e5fb2" translate="yes" xml:space="preserve">
          <source>Generating this fatal compile error is one of the main advantages of using the constants interface, since you'll immediately know if you mistype a color name.</source>
          <target state="translated">生成这个致命的编译错误是使用常量接口的主要优势之一,因为如果你输入错误的颜色名称,你会立即知道。</target>
        </trans-unit>
        <trans-unit id="94d49b2add1a84693cb6f6742d43aadc63779926" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF ARRAYS</source>
          <target state="translated">生成哈希数组</target>
        </trans-unit>
        <trans-unit id="b10605adc6dd4bbb3891b18fa40d3ef6fd2660e3" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF COMPLEX RECORDS</source>
          <target state="translated">复杂记录哈希的生成过程</target>
        </trans-unit>
        <trans-unit id="c99d686abb8c25c079ecc27374e7ae409f23b172" translate="yes" xml:space="preserve">
          <source>Generation of a HASH OF HASHES</source>
          <target state="translated">生成HASH OF HASHES</target>
        </trans-unit>
        <trans-unit id="a9893d509c65cb98b9af7180a27be528798c38c2" translate="yes" xml:space="preserve">
          <source>Generation of an ARRAY OF ARRAYS</source>
          <target state="translated">生成数组的数组。</target>
        </trans-unit>
        <trans-unit id="36fe3d03032c0fb4a7e4a93e553c5c4b5ad3dfa9" translate="yes" xml:space="preserve">
          <source>Generation of an ARRAY OF HASHES</source>
          <target state="translated">生成数组散列</target>
        </trans-unit>
        <trans-unit id="812c1b37318e9ec5939e34ef662accc038427024" translate="yes" xml:space="preserve">
          <source>Generic interface to Perl Compiler backends</source>
          <target state="translated">Perl编译器后端通用接口</target>
        </trans-unit>
        <trans-unit id="bc3a1464aaf3caaf7316afc754a4e8005c14f861" translate="yes" xml:space="preserve">
          <source>Get &lt;code&gt;REMOTE_FILE&lt;/code&gt; from the server and store locally. &lt;code&gt;LOCAL_FILE&lt;/code&gt; may be a filename or a filehandle. If not specified, the file will be stored in the current directory with the same leafname as the remote file.</source>
          <target state="translated">从服务器获取 &lt;code&gt;REMOTE_FILE&lt;/code&gt; 并存储在本地。 &lt;code&gt;LOCAL_FILE&lt;/code&gt; 可以是文件名或文件句柄。如果未指定，则文件将以与远程文件相同的叶名存储在当前目录中。</target>
        </trans-unit>
        <trans-unit id="d0dc372b2e257044afda97bb0f77031c7a35e177" translate="yes" xml:space="preserve">
          <source>Get a directory listing of &lt;code&gt;DIR&lt;/code&gt; , or the current directory in long format.</source>
          <target state="translated">获取目录列表 &lt;code&gt;DIR&lt;/code&gt; 或长格式的当前目录。</target>
        </trans-unit>
        <trans-unit id="7ec34cee796d547d14608ac7cf6e0f3edbd159c0" translate="yes" xml:space="preserve">
          <source>Get a directory listing of &lt;code&gt;DIR&lt;/code&gt; , or the current directory.</source>
          <target state="translated">获取目录列表 &lt;code&gt;DIR&lt;/code&gt; 或当前目录。</target>
        </trans-unit>
        <trans-unit id="374636ae19b296dfea98703295aaecfbdd2c1a97" translate="yes" xml:space="preserve">
          <source>Get a line from the filehandle and store it into the SV, optionally appending to the currently-stored string. If &lt;code&gt;append&lt;/code&gt; is not 0, the line is appended to the SV instead of overwriting it. &lt;code&gt;append&lt;/code&gt; should be set to the byte offset that the appended string should start at in the SV (typically, &lt;code&gt;SvCUR(sv)&lt;/code&gt; is a suitable choice).</source>
          <target state="translated">从文件句柄中获取一行并将其存储到SV中，可以选择将其追加到当前存储的字符串之后。如果 &lt;code&gt;append&lt;/code&gt; 不为0，则将行附加到SV而不是覆盖它。 &lt;code&gt;append&lt;/code&gt; 应该设置为SV中附加字符串应从其开始的字节偏移量（通常， &lt;code&gt;SvCUR(sv)&lt;/code&gt; 是合适的选择）。</target>
        </trans-unit>
        <trans-unit id="c598cea0161d91f18f52f5688b3c025ff94ad39c" translate="yes" xml:space="preserve">
          <source>Get a list of all remaining tests.</source>
          <target state="translated">获取所有剩余测试的列表。</target>
        </trans-unit>
        <trans-unit id="63a593cb77f2c61ac75772edd049eee1d24e24f8" translate="yes" xml:space="preserve">
          <source>Get a list of all the currently enabled pragmas:</source>
          <target state="translated">获取当前所有启用的实用程序列表。</target>
        </trans-unit>
        <trans-unit id="7b7cd7f6b002e314d08f78b71b5b591a4f70ba81" translate="yes" xml:space="preserve">
          <source>Get a login for the Perl Authors Upload Server (PAUSE) if you don't already have one: &lt;a href=&quot;http://pause.perl.org&quot;&gt;http://pause.perl.org&lt;/a&gt;</source>
          <target state="translated">如果您还没有Perl作者上载服务器（PAUSE），请登录：&lt;a href=&quot;http://pause.perl.org&quot;&gt;http&lt;/a&gt; : //pause.perl.org</target>
        </trans-unit>
        <trans-unit id="d5bbade2b6657ae3b6cb3e4431498e73906ee530" translate="yes" xml:space="preserve">
          <source>Get a sensible string out of the SV somehow. A private implementation of the &lt;code&gt;SvPV_force&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">以某种方式从SV中获取明智的字符串。 &lt;code&gt;SvPV_force&lt;/code&gt; 宏的私有实现，用于无法处理复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="64dbc32740e54d691c9e2c5cda1ba05449ef3105" translate="yes" xml:space="preserve">
          <source>Get a sensible string out of the SV somehow. If &lt;code&gt;flags&lt;/code&gt; has &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_get&lt;/code&gt; on &lt;code&gt;sv&lt;/code&gt; if appropriate, else not. &lt;code&gt;sv_pvn_force&lt;/code&gt; and &lt;code&gt;sv_pvn_force_nomg&lt;/code&gt; are implemented in terms of this function. You normally want to use the various wrapper macros instead: see &lt;code&gt;SvPV_force&lt;/code&gt; and &lt;code&gt;SvPV_force_nomg&lt;/code&gt;</source>
          <target state="translated">以某种方式从SV中获取明智的字符串。如果 &lt;code&gt;flags&lt;/code&gt; 有 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 位设置，将 &lt;code&gt;mg_get&lt;/code&gt; 在 &lt;code&gt;sv&lt;/code&gt; 如果合适，否则不行。 &lt;code&gt;sv_pvn_force&lt;/code&gt; 和 &lt;code&gt;sv_pvn_force_nomg&lt;/code&gt; 是根据此功能实现的。通常，您通常要使用各种包装宏：请参见 &lt;code&gt;SvPV_force&lt;/code&gt; 和 &lt;code&gt;SvPV_force_nomg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e7220eec11b9f4342ece5e624c0e6dd46adeb9c" translate="yes" xml:space="preserve">
          <source>Get a single character</source>
          <target state="translated">获取单个字符</target>
        </trans-unit>
        <trans-unit id="b607b471bd641ae0bad56d53e93561f4a5dcc663" translate="yes" xml:space="preserve">
          <source>Get a single word describing the status of the aggregated tests. Depending on the outcome of the tests returns 'PASS', 'FAIL' or 'NOTESTS'. This token is understood by &lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Reporter&quot;&gt;CPAN::Reporter&lt;/a&gt;.</source>
          <target state="translated">获得一个描述聚合测试状态的单词。根据测试结果，返回&amp;ldquo;通过&amp;rdquo;，&amp;ldquo;失败&amp;rdquo;或&amp;ldquo;提示&amp;rdquo;。该令牌由&lt;a href=&quot;http://search.cpan.org/perldoc/CPAN::Reporter&quot;&gt;CPAN :: Reporter&lt;/a&gt;理解。</target>
        </trans-unit>
        <trans-unit id="94e908780575d3c7b13c6f58aed85812783fe4af" translate="yes" xml:space="preserve">
          <source>Get all remaining lines from the file. It will croak() if accidentally called in a scalar context.</source>
          <target state="translated">从文件中获取所有剩余的行。如果在标量上下文中不小心调用,它会呱呱叫()。</target>
        </trans-unit>
        <trans-unit id="aed3f8067239d43cc5fd9e2c71aefda5e7ddcfa2" translate="yes" xml:space="preserve">
          <source>Get an a list of file handles which can be passed to &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; to determine the readiness of this parser.</source>
          <target state="translated">获取一个文件句柄列表，可以传递该文件句柄以进行 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 以确定该解析器的就绪状态。</target>
        </trans-unit>
        <trans-unit id="57c71ad46ac7b3fc7bffe5d8abfd2437d2bcda85" translate="yes" xml:space="preserve">
          <source>Get an array of descriptions in the order in which they were added to the aggregator.</source>
          <target state="translated">获取一个描述的数组,按照它们被添加到聚合器的顺序。</target>
        </trans-unit>
        <trans-unit id="4fd330b00e5fd43c7facb1ce40b15978badf9d49" translate="yes" xml:space="preserve">
          <source>Get current value of extended library search path. If &lt;code&gt;type&lt;/code&gt; is present and positive, works with &lt;code&gt;END_LIBPATH&lt;/code&gt; , if negative, works with &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; , otherwise with &lt;code&gt;BEGIN_LIBPATH&lt;/code&gt; .</source>
          <target state="translated">获取扩展库搜索路径的当前值。如果 &lt;code&gt;type&lt;/code&gt; 存在且为正，则与 &lt;code&gt;END_LIBPATH&lt;/code&gt; 一起使用；如果为负，则与 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 一起使用，否则与 &lt;code&gt;BEGIN_LIBPATH&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="00cf4729c08b5fcd57e241d25d2cbdeb99dcc776" translate="yes" xml:space="preserve">
          <source>Get feedback before publishing</source>
          <target state="translated">在发布前获得反馈</target>
        </trans-unit>
        <trans-unit id="7db8371110606460ae544aa3da9ce0f0de1a1f3f" translate="yes" xml:space="preserve">
          <source>Get file status. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; . The data returned is identical to the data from Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">获取文件状态。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。返回的数据与Perl内置的 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 函数中的数据相同。</target>
        </trans-unit>
        <trans-unit id="fa68e261aa81f581b5a90ba1e9bfd725ef59d405" translate="yes" xml:space="preserve">
          <source>Get name of current operating system.</source>
          <target state="translated">获取当前操作系统的名称。</target>
        </trans-unit>
        <trans-unit id="689e6ea9037095052aff1101fdfdc680b6e214b0" translate="yes" xml:space="preserve">
          <source>Get numeric formatting information. Returns a reference to a hash containing the current underlying locale's formatting values. Users of this function should also read &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;, which provides a comprehensive discussion of Perl locale handling, including &lt;a href=&quot;perllocale#The-localeconv-function&quot;&gt;a section devoted to this function&lt;/a&gt;.</source>
          <target state="translated">获取数字格式信息。返回对包含当前基础语言环境的格式值的哈希的引用。使用此功能的用户还应该阅读&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;，它提供了有关Perl语言环境处理的全面讨论，包括&lt;a href=&quot;perllocale#The-localeconv-function&quot;&gt;专门介绍此功能的部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1f984cefe527deb4addc8cf500f9c5727ae40d0" translate="yes" xml:space="preserve">
          <source>Get option associated with the socket. Other levels than SOL_SOCKET may be specified here.</source>
          <target state="translated">获取与SOL_SOCKET相关的选项。除了SOL_SOCKET之外,还可以在这里指定其他级别。</target>
        </trans-unit>
        <trans-unit id="0d1c28860360a4fa7e9af6746bedcb431787f46a" translate="yes" xml:space="preserve">
          <source>Get or set a pragma. To get the state of a pragma:</source>
          <target state="translated">获取或设置一个pragma。获取一个pragma的状态。</target>
        </trans-unit>
        <trans-unit id="77c12013a4f3faabdfd45c20cf7f2e5379d28bb4" translate="yes" xml:space="preserve">
          <source>Get or set the list of extensions that files must have in order to be considered tests. Defaults to ['.t'].</source>
          <target state="translated">获取或设置文件必须具有的扩展名列表,以便被视为测试。默认值为['.t']。</target>
        </trans-unit>
        <trans-unit id="b3f02dbc79ab20b0a28ad615d9d491d7daece201" translate="yes" xml:space="preserve">
          <source>Get pathname of current working directory</source>
          <target state="translated">获取当前工作目录的路径名</target>
        </trans-unit>
        <trans-unit id="fe08fded31b445465eb024604de34561803ebc20" translate="yes" xml:space="preserve">
          <source>Get terminal control attributes.</source>
          <target state="translated">获取终端控制属性。</target>
        </trans-unit>
        <trans-unit id="a59623bd1c16560f3bf3b733cb7fef045dc9eb39" translate="yes" xml:space="preserve">
          <source>Get the &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt; module from CPAN.</source>
          <target state="translated">从CPAN 获取&lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="f445ac9afb3e26b0227b0cd9d1470f0c1289598c" translate="yes" xml:space="preserve">
          <source>Get the &lt;a href=&quot;http://www.cpan.org/modules/by-module/Roman&quot;&gt;http://www.cpan.org/modules/by-module/Roman&lt;/a&gt; module.</source>
          <target state="translated">获取&lt;a href=&quot;http://www.cpan.org/modules/by-module/Roman&quot;&gt;http://www.cpan.org/modules/by-module/Roman&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="006addc7b486481a4d34e5ae872451f7b6a5b8f4" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; of a capture variable. There's a special callback for this so that Perl doesn't have to do a FETCH and run &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; on the result, since the length is (in Perl's case) known from an offset stored in &lt;code&gt;rx-&amp;gt;offs&lt;/code&gt; , this is much more efficient:</source>
          <target state="translated">获取捕获变量的 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。为此有一个特殊的回调，因此Perl不必执行FETCH并在结果上运行 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ，因为从 &lt;code&gt;rx-&amp;gt;offs&lt;/code&gt; 中存储的偏移量中可以知道长度（在Perl的情况下），因此效率更高：</target>
        </trans-unit>
        <trans-unit id="a11deed8b7fb50959590945fa161672220265d44" translate="yes" xml:space="preserve">
          <source>Get the EMX development suite and gzip/tar, from either Hobbes ( &lt;a href=&quot;http://hobbes.nmsu.edu&quot;&gt;http://hobbes.nmsu.edu&lt;/a&gt; ) or Leo ( &lt;a href=&quot;http://www.leo.org&quot;&gt;http://www.leo.org&lt;/a&gt; ), and then follow the instructions for Unix.</source>
          <target state="translated">从Hobbes（&lt;a href=&quot;http://hobbes.nmsu.edu&quot;&gt;http://hobbes.nmsu.edu&lt;/a&gt;）或Leo（&lt;a href=&quot;http://www.leo.org&quot;&gt;http://www.leo.org&lt;/a&gt;）获取EMX开发套件和gzip / tar，然后按照Unix上的说明进行操作。</target>
        </trans-unit>
        <trans-unit id="bd4becd7b8dc2161e4cfcda2010cf7c1c881bcda" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator's process.</source>
          <target state="translated">获取该迭代器进程的退出状态。</target>
        </trans-unit>
        <trans-unit id="84b89fd72831dd053c82f16626d634a48a2598fb" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator. Always returns zero.</source>
          <target state="translated">获取该迭代器的退出状态。始终返回0。</target>
        </trans-unit>
        <trans-unit id="f3a54d4a203ed01a0cc006bea81ab1571b475a38" translate="yes" xml:space="preserve">
          <source>Get the exit status for this iterator. For an array iterator this will always be zero.</source>
          <target state="translated">获取这个迭代器的退出状态。对于一个数组迭代器来说,这个状态永远是0。</target>
        </trans-unit>
        <trans-unit id="133e8c41853aab1cbe28dc6fb07183856dc1f08a" translate="yes" xml:space="preserve">
          <source>Get the header and the first &lt;code&gt;NUMLINES&lt;/code&gt; of the body for the message &lt;code&gt;MSGNUM&lt;/code&gt; . Returns a reference to an array which contains the lines of text read from the server.</source>
          <target state="translated">获取标题 &lt;code&gt;NUMLINES&lt;/code&gt; 和正文的第一个 &lt;code&gt;MSGNUM&lt;/code&gt; 。返回对包含从服务器读取的文本行的数组的引用。</target>
        </trans-unit>
        <trans-unit id="a54ca3db20c68a6648a2c8195a312d093894414c" translate="yes" xml:space="preserve">
          <source>Get the login name of the owner of the current process.</source>
          <target state="translated">获取当前进程的所有者的登录名。</target>
        </trans-unit>
        <trans-unit id="e120bfbb1d3603fe717d8918b14899076a8087c1" translate="yes" xml:space="preserve">
          <source>Get the message &lt;code&gt;MSGNUM&lt;/code&gt; from the remote mailbox. If &lt;code&gt;FH&lt;/code&gt; is not given then get returns a reference to an array which contains the lines of text read from the server. If &lt;code&gt;FH&lt;/code&gt; is given then the lines returned from the server are printed to the filehandle &lt;code&gt;FH&lt;/code&gt; .</source>
          <target state="translated">从远程邮箱获取消息 &lt;code&gt;MSGNUM&lt;/code&gt; 。如果未提供 &lt;code&gt;FH&lt;/code&gt; ,则get返回对数组的引用，该数组包含从服务器读取的文本行。如果给出 &lt;code&gt;FH&lt;/code&gt; ,则从服务器返回的行将打印到文件句柄 &lt;code&gt;FH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="171a80b6f7c9c9b0de0c2c1387e261c225bb5f1c" translate="yes" xml:space="preserve">
          <source>Get the results of the last test run. Returns a &lt;code&gt;result_class()&lt;/code&gt; instance.</source>
          <target state="translated">获取上次测试运行的结果。返回一个 &lt;code&gt;result_class()&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="90d44fbd255026683b10ff974054e3d86ff08631" translate="yes" xml:space="preserve">
          <source>Get the shebang line for a script file.</source>
          <target state="translated">获取脚本文件的shebang行。</target>
        </trans-unit>
        <trans-unit id="697c2b6a1d382211fc2dd0bca44da6d75975210e" translate="yes" xml:space="preserve">
          <source>Get the text content of Pod</source>
          <target state="translated">获取Pod的文本内容</target>
        </trans-unit>
        <trans-unit id="8a6470e93add70210e01a18515324d36b81b5961" translate="yes" xml:space="preserve">
          <source>Get the value at offset</source>
          <target state="translated">获取偏移量的值</target>
        </trans-unit>
        <trans-unit id="b4b20b8862126ed2accf702e1ec733c901c8db4d" translate="yes" xml:space="preserve">
          <source>Get the value at offset &lt;code&gt;po&lt;/code&gt; in the current pad</source>
          <target state="translated">获取当前焊盘中偏移 &lt;code&gt;po&lt;/code&gt; 处的值</target>
        </trans-unit>
        <trans-unit id="72cc9b87213c59838a0c486fddb38c60d8bcb990" translate="yes" xml:space="preserve">
          <source>Get the value from slot &lt;code&gt;po&lt;/code&gt; in the base (DEPTH=1) pad of a padlist</source>
          <target state="translated">从填充列表的基础（DEPTH = 1）填充中的插槽 &lt;code&gt;po&lt;/code&gt; 获取值</target>
        </trans-unit>
        <trans-unit id="c15dfba3a3a5eb3e6fb48d7c0b41882c9028755a" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator's process.</source>
          <target state="translated">获取该迭代器进程的等待状态。</target>
        </trans-unit>
        <trans-unit id="a8e5109ddd83023961a33c488ce31369f7a956bb" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator. Always returns zero.</source>
          <target state="translated">获取该迭代器的等待状态。始终返回0。</target>
        </trans-unit>
        <trans-unit id="dd379b83821718a59329d33da5c3c07390f8df61" translate="yes" xml:space="preserve">
          <source>Get the wait status for this iterator. For an array iterator this will always be zero.</source>
          <target state="translated">获取这个迭代器的等待状态。对于一个数组迭代器来说,这个状态永远是0。</target>
        </trans-unit>
        <trans-unit id="3a194d016da71ce2734ee5b70b1ec1fd4e7b2f88" translate="yes" xml:space="preserve">
          <source>Get your book listed</source>
          <target state="translated">让您的书上市</target>
        </trans-unit>
        <trans-unit id="a862124c43c274d34647a9768c5732fb7edcd167" translate="yes" xml:space="preserve">
          <source>Get/set subroutine or variable attributes</source>
          <target state="translated">获取/设置子程序或变量属性。</target>
        </trans-unit>
        <trans-unit id="d95e69f9c878364f21361c49a01e8572507003e4" translate="yes" xml:space="preserve">
          <source>GetFileContents</source>
          <target state="translated">GetFileContents</target>
        </trans-unit>
        <trans-unit id="0e09541d86291862cd9e2e7048d551c2058e9bb4" translate="yes" xml:space="preserve">
          <source>GetOptions does not return a false result when an option is not supplied</source>
          <target state="translated">当没有提供选项时,GetOptions不会返回一个错误的结果。</target>
        </trans-unit>
        <trans-unit id="87d3b5ae9087dfd036d22e3daee54391ea6d78e7" translate="yes" xml:space="preserve">
          <source>GetOptions does not split the command line correctly</source>
          <target state="translated">GetOptions不能正确分割命令行</target>
        </trans-unit>
        <trans-unit id="46612c2fb2a3f4d1528e0cd7f5288c84da4524f8" translate="yes" xml:space="preserve">
          <source>GetOptions returns true to indicate success. It returns false when the function detected one or more errors during option parsing. These errors are signalled using warn() and can be trapped with &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; .</source>
          <target state="translated">GetOptions返回true表示成功。当函数在选项解析期间检测到一个或多个错误时，它将返回false。这些错误使用warn（）发出信号，并可以用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 捕获。</target>
        </trans-unit>
        <trans-unit id="6b726fe0f0e4cd3ba3741be1513769194ec024e4" translate="yes" xml:space="preserve">
          <source>GetOptions() will not interpret a leading &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; as option starters if the next argument is a reference. To force &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as option starters, use &lt;code&gt;&quot;&amp;gt;&amp;lt;&quot;&lt;/code&gt; . Confusing? Well, &lt;b&gt;using a starter argument is strongly deprecated&lt;/b&gt; anyway.</source>
          <target state="translated">如果下一个参数是引用，则GetOptions（）不会将前导 &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; 解释为选项启动器。要强制将 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 用作选项启动器，请使用 &lt;code&gt;&quot;&amp;gt;&amp;lt;&quot;&lt;/code&gt; 。令人困惑？好吧，无论如何&lt;b&gt;强烈建议不要使用入门参数&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b9732e721546ff2bc7ea74a9d199d6d228afae46" translate="yes" xml:space="preserve">
          <source>GetOptions() will return a true value if the command line could be processed successfully. Otherwise, it will write error messages using die() and warn(), and return a false result.</source>
          <target state="translated">如果命令行可以成功处理,GetOptions()将返回一个真值。否则,它将使用die()和war()写入错误信息,并返回一个false结果。</target>
        </trans-unit>
        <trans-unit id="d3750099056a52cd3d76c09c5969009aae1b2738" translate="yes" xml:space="preserve">
          <source>Getopt::Long</source>
          <target state="translated">Getopt::Long</target>
        </trans-unit>
        <trans-unit id="ee86fdfdf70c8935b9943d5d042784e3c2ea2b52" translate="yes" xml:space="preserve">
          <source>Getopt::Long - Extended processing of command line options</source>
          <target state="translated">Getopt::Long-命令行选项的扩展处理。</target>
        </trans-unit>
        <trans-unit id="9f1cb7796236a18d5a48dd6147f6ef96a3c237e4" translate="yes" xml:space="preserve">
          <source>Getopt::Long can be configured by calling subroutine Getopt::Long::Configure(). This subroutine takes a list of quoted strings, each specifying a configuration option to be enabled, e.g. &lt;code&gt;ignore_case&lt;/code&gt; , or disabled, e.g. &lt;code&gt;no_ignore_case&lt;/code&gt; . Case does not matter. Multiple calls to Configure() are possible.</source>
          <target state="translated">可以通过调用子例程Getopt :: Long :: Configure（）来配置Getopt :: Long。该子例程采用带引号的字符串列表，每个字符串都指定要启用的配置选项，例如 &lt;code&gt;ignore_case&lt;/code&gt; ，或禁用的配置选项，例如 &lt;code&gt;no_ignore_case&lt;/code&gt; 。大小写无所谓。可以多次调用Configure（）。</target>
        </trans-unit>
        <trans-unit id="7e500819062670bf30da6e44490f24a19a2b2b19" translate="yes" xml:space="preserve">
          <source>Getopt::Long can be used in an object oriented way as well:</source>
          <target state="translated">Getopt::Long也可以以面向对象的方式使用。</target>
        </trans-unit>
        <trans-unit id="edc4bf4d0ae35771f0ba93156da87e25f9c34e7d" translate="yes" xml:space="preserve">
          <source>Getopt::Long encourages the use of Pod::Usage to produce help messages. For example:</source>
          <target state="translated">Getopt::Long鼓励使用Pod::Usage来产生帮助信息。例如</target>
        </trans-unit>
        <trans-unit id="b2e568fc541602443fba9f2e2602a6ef4699382b" translate="yes" xml:space="preserve">
          <source>Getopt::Long is the Perl5 successor of &lt;code&gt;newgetopt.pl&lt;/code&gt; . This was the first Perl module that provided support for handling the new style of command line options, in particular long option names, hence the Perl5 name Getopt::Long. This module also supports single-character options and bundling.</source>
          <target state="translated">Getopt :: Long是 &lt;code&gt;newgetopt.pl&lt;/code&gt; 的Perl5继承者。这是第一个为处理新样式的命令行选项（特别是长选项名称）提供支持的Perl模块，因此Perl5名称为Getopt :: Long。该模块还支持单字符选项和捆绑。</target>
        </trans-unit>
        <trans-unit id="baeccd76f672aaa366456df8bb56a2d544addefb" translate="yes" xml:space="preserve">
          <source>Getopt::Long is thread safe when using ithreads as of Perl 5.8. It is</source>
          <target state="translated">Getopt::Long 在使用 Perl 5.8 的ithreads 时是线程安全的。它是</target>
        </trans-unit>
        <trans-unit id="0969a40bae8913a7683a1a070a431edeaeab53a5" translate="yes" xml:space="preserve">
          <source>Getopt::Long supports three styles of bundling. To enable bundling, a call to Getopt::Long::Configure is required.</source>
          <target state="translated">Getopt::Long 支持三种捆绑方式。要启用捆绑,需要调用 Getopt::Long::Configure。</target>
        </trans-unit>
        <trans-unit id="c364d3e4d70b8c945dae76119e75bf89e0b572cc" translate="yes" xml:space="preserve">
          <source>Getopt::Long supports two useful variants of simple options:</source>
          <target state="translated">Getopt::Long支持两个简单选项的有用变体。</target>
        </trans-unit>
        <trans-unit id="35548099a37e6129ad92eb2599c19e8e81824308" translate="yes" xml:space="preserve">
          <source>Getopt::Long will provide a help message using module &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. The message, derived from the SYNOPSIS POD section, will be written to standard output and processing will terminate.</source>
          <target state="translated">Getopt :: Long将使用模块&lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage&lt;/a&gt;提供帮助消息。从&amp;ldquo;概要POD&amp;rdquo;部分派生的消息将被写入标准输出，并且处理将终止。</target>
        </trans-unit>
        <trans-unit id="23debd03657a7e0cf1c9081bd9b34c843df29188" translate="yes" xml:space="preserve">
          <source>Getopt::Long will provide a standard version message that includes the program name, its version (if $main::VERSION is defined), and the versions of Getopt::Long and Perl. The message will be written to standard output and processing will terminate.</source>
          <target state="translated">Getopt::Long 将提供一个标准版本消息,其中包括程序名称、它的版本(如果定义了 $main::VERSION)以及 Getopt::Long 和 Perl 的版本。该消息将被写入标准输出并终止处理。</target>
        </trans-unit>
        <trans-unit id="231784d11e2ac3af47374629249969cb6df988d0" translate="yes" xml:space="preserve">
          <source>Getopt::Std</source>
          <target state="translated">Getopt::Std</target>
        </trans-unit>
        <trans-unit id="050f7a7a02c0f512f89945ac517880bcdb5ae514" translate="yes" xml:space="preserve">
          <source>Gets or sets the number of concurrent test runs the harness is handling. By default, this value is 1 -- for parallel testing, this should be set higher.</source>
          <target state="translated">获取或设置线束正在处理的并发测试运行次数。默认情况下,这个值是1--对于并行测试,这个值应该设置得更高。</target>
        </trans-unit>
        <trans-unit id="daa629c55c1f0a45358dee6010d69ea52181b0b2" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;mro_isarev&lt;/code&gt; for this class, returned as an arrayref of class names. These are every class that &quot;isa&quot; the given class name, even if the isa relationship is indirect. This is used internally by the MRO code to keep track of method/MRO cache invalidations.</source>
          <target state="translated">获取 &lt;code&gt;mro_isarev&lt;/code&gt; 的mro_isarev，以类名称的arrayref返回。这些都是&amp;ldquo; isa&amp;rdquo;给定类名的每个类，即使isa关系是间接的。MRO代码在内部使用它来跟踪方法/ MRO缓存无效。</target>
        </trans-unit>
        <trans-unit id="fd14d8ab490abe0a698ffc2511ce53075831cc54" translate="yes" xml:space="preserve">
          <source>Gets/sets the current test number we're on. You usually shouldn't have to set this.</source>
          <target state="translated">Gets/sets the current test number we're on.通常情况下,你不应该设置这个。</target>
        </trans-unit>
        <trans-unit id="3706dd8132de9e8897f7e90d7114484c9d4b2bb9" translate="yes" xml:space="preserve">
          <source>Gets/sets the number of tests we expect this test to run and prints out the appropriate headers.</source>
          <target state="translated">Gets/sets the number of tests we expect this test to run and printts out the appropriate headers.</target>
        </trans-unit>
        <trans-unit id="f884a4b1be1eb753e1154cd093d629796012ffc9" translate="yes" xml:space="preserve">
          <source>Getter/setter for frontend object. Method just allows to subclass CPAN.pm.</source>
          <target state="translated">前台对象的getter/setter。该方法只允许子类CPAN.pm.Getter/setter。</target>
        </trans-unit>
        <trans-unit id="1acf2787a8aee315df9ae150576ddc4f44be77a7" translate="yes" xml:space="preserve">
          <source>Getter/setter for the &quot;generation&quot; of the test suite run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">测试套件运行的 &quot;代 &quot;的getter/setter。第一代是1(1),随后的世代是2、3等。</target>
        </trans-unit>
        <trans-unit id="df0821c683786b3a185e90a15a8887e90823f964" translate="yes" xml:space="preserve">
          <source>Getter/setter for the instance of the &lt;code&gt;state_class&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;state_class&lt;/code&gt; 实例的Getter / setter 。</target>
        </trans-unit>
        <trans-unit id="9d0a2a42561baa9a96f6b60d628e8035a5add88f" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for maintaining state. This class should either subclass from &lt;code&gt;App::Prove::State&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">获取器/设置器，用于维护状态的类的名称。此类应为 &lt;code&gt;App::Prove::State&lt;/code&gt; 子类，或提供相同的接口。</target>
        </trans-unit>
        <trans-unit id="f5b0e960fe4e828ae0c4af986bdc86fc8e330536" translate="yes" xml:space="preserve">
          <source>Getter/setter for the name of the class used for tracking test results. This class should either subclass from &lt;code&gt;App::Prove::State::Result&lt;/code&gt; or provide an identical interface.</source>
          <target state="translated">用于跟踪测试结果的类的名称的Getter / setter。此类应为 &lt;code&gt;App::Prove::State::Result&lt;/code&gt; 子类，或提供相同的接口。</target>
        </trans-unit>
        <trans-unit id="eabe8c9a6205eacd9d12103fd632a371642529ec" translate="yes" xml:space="preserve">
          <source>Getter/setter for the time of the test suite run.</source>
          <target state="translated">测试套件运行时间的getter/setter。</target>
        </trans-unit>
        <trans-unit id="6796c34d6d781e2d3a0ac04017b688fdbad6d325" translate="yes" xml:space="preserve">
          <source>Getting Started with Getopt::Long</source>
          <target state="translated">Getopt::Long入门</target>
        </trans-unit>
        <trans-unit id="1252190bfc7e0e95dec199e97b41cd19bd2e58b1" translate="yes" xml:space="preserve">
          <source>Getting changes into a maint branch</source>
          <target state="translated">将变更纳入主分支</target>
        </trans-unit>
        <trans-unit id="36235f076eea8a428b643f4a70d6dbb8c2bed724" translate="yes" xml:space="preserve">
          <source>Getting perl source</source>
          <target state="translated">获取perl源代码</target>
        </trans-unit>
        <trans-unit id="dfa7f5176d7ce9da792b1bc4befb42509ca613ce" translate="yes" xml:space="preserve">
          <source>Getting the Perl Source for AmigaOS</source>
          <target state="translated">获取AmigaOS的Perl源代码</target>
        </trans-unit>
        <trans-unit id="ca13f2cfdfff6452c98f50feff43bb9608b60008" translate="yes" xml:space="preserve">
          <source>Getting the fat out of XSUBs</source>
          <target state="translated">去除XSUB的脂肪</target>
        </trans-unit>
        <trans-unit id="1e5b964707fd03837f1c6270f09aa1a8d502762e" translate="yes" xml:space="preserve">
          <source>Getting this message indicates that the outcome of the match arguably should have been the opposite of what actually happened. If you think that is the case, you may wish to make the &lt;code&gt;non_unicode&lt;/code&gt; warnings category fatal; if you agree with Perl's decision, you may wish to turn off this category.</source>
          <target state="translated">收到此消息表明，比赛的结果可能与实际发生的情况相反。如果您认为是这种情况，则不妨将 &lt;code&gt;non_unicode&lt;/code&gt; 警告类别设为致命类别；如果您同意Perl的决定，则不妨关闭此类别。</target>
        </trans-unit>
        <trans-unit id="c57b1bd007b42e02300f16d8e99034836448a153" translate="yes" xml:space="preserve">
          <source>Getting your patch accepted</source>
          <target state="translated">让您的补丁被接受</target>
        </trans-unit>
        <trans-unit id="80db569e43bb9df0657e208673f0728aa476a744" translate="yes" xml:space="preserve">
          <source>Gigantic thanks to Jarkko Hietaniemi, for agreeing to put this in the core when I hadn't written it yet, and for generally being helpful, supportive, and competent. (Usually the rule is &quot;choose any one.&quot;) Also big thanks to Abhijit Menon-Sen for all of the same things.</source>
          <target state="translated">非常感谢Jarkko Hietaniemi,在我还没有写的时候,他同意把这个放在核心区,并感谢他的帮助、支持和称职。(通常的规则是 &quot;任选其一&quot;。)也非常感谢Abhijit Menon-Sen,感谢他所做的同样的事情。</target>
        </trans-unit>
        <trans-unit id="c447f4baf429b1b41a12ae13b0f7bf296acd86b4" translate="yes" xml:space="preserve">
          <source>Gisle Aas &amp;lt;gisle@aas.no&amp;gt;</source>
          <target state="translated">吉斯尔&amp;middot;亚斯（Gisle Aas）&amp;lt;gisle@aas.no&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e2bf29bf784713e55d54fd683f2ddb22d16ebc1e" translate="yes" xml:space="preserve">
          <source>Gisle Aas made a number of improvements to the documentation for 2.07 and his advice and assistance is also greatly appreciated.</source>
          <target state="translated">Gisle Aas对2.07版本的文档做了一些改进,他的建议和帮助也非常感谢。</target>
        </trans-unit>
        <trans-unit id="d5205d4410276cc0ebead8a23281418d320e5d50" translate="yes" xml:space="preserve">
          <source>Gisle Aas's &quot;illustrated perlguts&quot;, also known as</source>
          <target state="translated">Gisle Aas的 &quot;插图perlguts&quot;,也就是所谓的</target>
        </trans-unit>
        <trans-unit id="8a1336646a79e293474d5da63f8a9e49f7c504c4" translate="yes" xml:space="preserve">
          <source>Give a seed the pseudorandom number generator, see &lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;.</source>
          <target state="translated">给种子提供伪随机数生成器，请参阅&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ecbf54e25625127b374bd97fb6bf30d58f7f39f4" translate="yes" xml:space="preserve">
          <source>Give examples of use in your documentation</source>
          <target state="translated">举例说明在您的文件中的使用情况</target>
        </trans-unit>
        <trans-unit id="576b2bd7a5f1aafe83cdf1ff1d6086595bd3253e" translate="yes" xml:space="preserve">
          <source>Give meaningful error messages when a test fails.</source>
          <target state="translated">当测试失败时,给出有意义的错误信息。</target>
        </trans-unit>
        <trans-unit id="22362db21ca02fd220365037ef3ce1c3ae84669f" translate="yes" xml:space="preserve">
          <source>Give some example uses of the program or function. Don't skimp; users often find this the most useful part of the documentation. The examples are generally given as verbatim paragraphs.</source>
          <target state="translated">给出一些程序或函数的使用实例。不要吝啬;用户往往发现这是文档中最有用的部分。例子一般以逐字段的形式给出。</target>
        </trans-unit>
        <trans-unit id="50b41e662ea9282912cd0935127aa4fdcf1ffa2b" translate="yes" xml:space="preserve">
          <source>Give the module a version/issue/release number.</source>
          <target state="translated">给予该模块一个版本/问题/发布号。</target>
        </trans-unit>
        <trans-unit id="280f5d0aaefd1eefc611f50ae84a5b211fd8c124" translate="yes" xml:space="preserve">
          <source>Given 'tests' and optional 'rules' as input, returns a new &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; object. Each member of &lt;code&gt;@tests&lt;/code&gt; should be either a a test file name, or a two element arrayref, where the first element is a test file name, and the second element is a test description. By default, we'll use the test name as the description.</source>
          <target state="translated">给定&amp;ldquo;测试&amp;rdquo;和可选的&amp;ldquo;规则&amp;rdquo;作为输入，返回一个新的 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 对象。 &lt;code&gt;@tests&lt;/code&gt; 的每个成员应该是一个测试文件名，或者是两个元素的arrayref，其中第一个元素是测试文件名，第二个元素是测试描述。默认情况下，我们将测试名称用作描述。</target>
        </trans-unit>
        <trans-unit id="88ad438932c9bdde0a7a6699aa6fd02d2661a215" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, returns the value &lt;code&gt;x - n*y&lt;/code&gt; , where &lt;code&gt;n&lt;/code&gt; is the integer closest to &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt;. [C99]</source>
          <target state="translated">给定 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; ，返回值 &lt;code&gt;x - n*y&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是最接近 &lt;code&gt;&lt;a href=&quot;functions/x&quot;&gt;x/y&lt;/a&gt;&lt;/code&gt; 的整数。[C99]</target>
        </trans-unit>
        <trans-unit id="4516641ce73c8bc0e4fc5ba5d53992584effc072" translate="yes" xml:space="preserve">
          <source>Given a $parser that's an object of class Pod::Simple::PullParser (or a subclass)...</source>
          <target state="translated">给定一个$parser是类Pod::Simple::PullParser(或子类)的对象...。</target>
        </trans-unit>
        <trans-unit id="8f7ab85a46c82118f02884a07c3492a612ad0bc1" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, detects what kind of source it is and returns</source>
          <target state="translated">给定&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，检测它是哪种类型的源并返回</target>
        </trans-unit>
        <trans-unit id="b116ea0f536335d3865a0d04bc8e08d1c2acb6e8" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;source&quot;&gt;TAP::Parser::Source&lt;/a&gt;, finds the most suitable &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; to use to create a &lt;a href=&quot;iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt; (see &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;). Dies on error.</source>
          <target state="translated">给定&lt;a href=&quot;source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt;，找到最合适的&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;来创建&lt;a href=&quot;iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;（请参见&lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt;）。死于错误。</target>
        </trans-unit>
        <trans-unit id="b30c1dfc72170a71448f9b395e9b03e816f03b3d" translate="yes" xml:space="preserve">
          <source>Given a PerlIO * create a 'native' FILE * suitable for passing to code expecting to be compiled and linked with ANSI C</source>
          <target state="translated">给定一个PerlIO *创建一个 &quot;native &quot;FILE *适合传递给期望被编译并与ANSI C链接的代码。</target>
        </trans-unit>
        <trans-unit id="34f965aed65d5f567330c1f887c60f3d7277e8d9" translate="yes" xml:space="preserve">
          <source>Given a chunk of memory, link it to the head of the list of arenas, and split it into a list of free SVs.</source>
          <target state="translated">给定一块内存,将其链接到场馆列表的头部,并将其分割成一个自由SV的列表。</target>
        </trans-unit>
        <trans-unit id="ea0db9ec916b80f6d45682cc0643494437b81c63" translate="yes" xml:space="preserve">
          <source>Given a function argument and the corresponding function value, store them into the cache.</source>
          <target state="translated">给定一个函数参数和相应的函数值,将它们存储到缓存中。</target>
        </trans-unit>
        <trans-unit id="368b29d6322d5568fa6515033d024e6d8d044278" translate="yes" xml:space="preserve">
          <source>Given a function argument, is the corresponding function value in the cache, and if so, is it fresh enough to use?</source>
          <target state="translated">给定一个函数参数,缓存中是否有相应的函数值,如果有,是否新鲜到可以使用?</target>
        </trans-unit>
        <trans-unit id="f996cfe932df1fdf5f95873d9c8a6b9f9b2d54ff" translate="yes" xml:space="preserve">
          <source>Given a function argument, look up the corresponding function value in the cache and return it.</source>
          <target state="translated">给定一个函数参数,在缓存中查找对应的函数值并返回。</target>
        </trans-unit>
        <trans-unit id="c3509e606900720895e02d9e89cbafec46d210bc" translate="yes" xml:space="preserve">
          <source>Given a key (&lt;code&gt;$key&lt;/code&gt; ) this method reads the value associated with it from the database. The value read from the database is returned in the &lt;code&gt;$value&lt;/code&gt; parameter.</source>
          <target state="translated">给定一个键（ &lt;code&gt;$key&lt;/code&gt; ），此方法从数据库中读取与其关联的值。从数据库读取的值将在 &lt;code&gt;$value&lt;/code&gt; 参数中返回。</target>
        </trans-unit>
        <trans-unit id="e7f4f0181b47fc4d73d9cd3bbfb5acee403880eb" translate="yes" xml:space="preserve">
          <source>Given a list of args get the names of tests that should run</source>
          <target state="translated">给定一个args列表,得到应该运行的测试名称。</target>
        </trans-unit>
        <trans-unit id="16258c75193474948085fd76ec96dab72f546f03" translate="yes" xml:space="preserve">
          <source>Given a list of file names, strip out those that refer to a parent directory. (Does not strip symlinks, only '.', '..', and equivalents.)</source>
          <target state="translated">给定一个文件名列表,剥离那些指向父目录的文件。(不删除符号链接,只删除'.'、'.'和等价物。)</target>
        </trans-unit>
        <trans-unit id="3f60dd44db71eb2a881f946f782f7b4489542b29" translate="yes" xml:space="preserve">
          <source>Given a list of scalars or reference variables, writes out their contents in perl syntax. The references can also be objects. The content of each variable is output in a single Perl statement. Handles self-referential structures correctly.</source>
          <target state="translated">给定一个标量或引用变量列表,用perl语法写出其内容。引用也可以是对象。每个变量的内容都会在一条Perl语句中输出。正确处理自引用结构。</target>
        </trans-unit>
        <trans-unit id="3e530c4f306640476d631e5c36d6a2f051774865" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the number of the Unicode character that this stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return 47, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;, whose Unicode number is 47. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定一个可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的Unicode字符的编号。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; 和 &lt;code&gt;e2char('057')&lt;/code&gt; 都返回47，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;，其Unicode编号为47。如果该名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或在语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;） &amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="2023da106c6aa26bd0acc5076b02991c20277361" translate="yes" xml:space="preserve">
          <source>Given a name or number that could appear in a &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; sequence, this returns the string that it stands for. For example, &lt;code&gt;e2char('sol')&lt;/code&gt; , &lt;code&gt;e2char('47')&lt;/code&gt; , &lt;code&gt;e2char('0x2F')&lt;/code&gt; , and &lt;code&gt;e2char('057')&lt;/code&gt; all return &quot;/&quot;, because &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; , and &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; , all mean &quot;/&quot;. If the name has no known value (as with a name of &quot;qacute&quot;) or is syntactically invalid (as with a name of &quot;1/4&quot;), this returns undef.</source>
          <target state="translated">给定可能以 &lt;code&gt;E&amp;lt;name_or_num&amp;gt;&lt;/code&gt; 序列出现的名称或数字，这将返回其代表的字符串。例如， &lt;code&gt;e2char('sol')&lt;/code&gt; ， &lt;code&gt;e2char('47')&lt;/code&gt; ， &lt;code&gt;e2char('0x2F')&lt;/code&gt; 和 &lt;code&gt;e2char('057')&lt;/code&gt; 都返回&amp;ldquo; /&amp;rdquo;，因为 &lt;code&gt;E&amp;lt;sol&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;47&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;0x2f&amp;gt;&lt;/code&gt; 和 &lt;code&gt;E&amp;lt;057&amp;gt;&lt;/code&gt; 均表示&amp;ldquo; /&amp;rdquo;。如果名称没有已知值（如名称&amp;ldquo; qacute&amp;rdquo;）或语法上无效（如名称&amp;ldquo; 1/4&amp;rdquo;），则返回undef。</target>
        </trans-unit>
        <trans-unit id="68ff8a7e4af810b7a363c9f43756d64a041cba7a" translate="yes" xml:space="preserve">
          <source>Given a packed socket address (such as from getsockname(), getpeername(), or returned by getaddrinfo() in a &lt;code&gt;addr&lt;/code&gt; field), returns the hostname and symbolic service name it represents. $flags may be a bitmask of &lt;code&gt;NI_*&lt;/code&gt; constants, or defaults to 0 if unspecified.</source>
          <target state="translated">给定一个压缩的套接字地址（例如从getsockname（），getpeername（）或在 &lt;code&gt;addr&lt;/code&gt; 字段中由getaddrinfo（）返回），返回其表示的主机名和符号服务名。$ flags可以是 &lt;code&gt;NI_*&lt;/code&gt; 常量的位掩码，如果未指定，则默认为0。</target>
        </trans-unit>
        <trans-unit id="b3ab833b08cd320284ae184893dbedaee3a8efff" translate="yes" xml:space="preserve">
          <source>Given a pointer to an &lt;code&gt;SV&lt;/code&gt; and an &lt;code&gt;=~&lt;/code&gt; operation (e.g., &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt;), substitute() modifies the string within the &lt;code&gt;SV&lt;/code&gt; as according to the operation, returning the number of substitutions made.</source>
          <target state="translated">给定指向 &lt;code&gt;SV&lt;/code&gt; 的指针和 &lt;code&gt;=~&lt;/code&gt; 操作（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/bob/robert/g&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[A-Z][a-z]&lt;/a&gt;&lt;/code&gt; ），replace（）会根据该操作修改 &lt;code&gt;SV&lt;/code&gt; 中的字符串，并返回替换。</target>
        </trans-unit>
        <trans-unit id="7df1b1c7c83c78e200c9f9cd553763264fc01f76" translate="yes" xml:space="preserve">
          <source>Given a string and a pattern (e.g., &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;/\b\w*\b/&lt;/code&gt; , which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</source>
          <target state="translated">给定一个字符串和一个模式（例如 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/clasp/&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;/\b\w*\b/&lt;/code&gt; ，在您的C程序中可能会显示为&amp;ldquo; / \\ b \\ w * \\ b /&amp;rdquo;），match（ ）如果字符串与模式匹配，则返回1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="cb2d005ca978881d5ba03242206b93769db89d30" translate="yes" xml:space="preserve">
          <source>Given a template, returns a filehandle to the temporary file and the name of the file.</source>
          <target state="translated">给定一个模板,返回一个临时文件的文件柄和文件名。</target>
        </trans-unit>
        <trans-unit id="f3247eafd3bd6b87dad8bb050e03ecb6550fab7f" translate="yes" xml:space="preserve">
          <source>Given an &lt;code&gt;SV&lt;/code&gt; , a pattern, and a pointer to an empty &lt;code&gt;AV&lt;/code&gt; , matches() evaluates &lt;code&gt;$string =~ $pattern&lt;/code&gt; in a list context, and fills in</source>
          <target state="translated">给定一个 &lt;code&gt;SV&lt;/code&gt; ，一个模式和一个指向空 &lt;code&gt;AV&lt;/code&gt; 的指针，matches（）在列表上下文中计算 &lt;code&gt;$string =~ $pattern&lt;/code&gt; ，并填写</target>
        </trans-unit>
        <trans-unit id="d73be34ecb8afbc83a1abc326b027cd0e5ff7367" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element of a hash, returns true if the specified element in the hash has ever been initialized, even if the corresponding value is undefined.</source>
          <target state="translated">给定一个表达式,指定一个哈希元素,如果哈希中指定的元素曾经被初始化,则返回true,即使对应的值是未定义的。</target>
        </trans-unit>
        <trans-unit id="3860c44bdd22a4566d9e655bb9fabca95c5a3818" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">给定一个指定元素或哈希切片的表达式， &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 将从该哈希中删除指定的元素，以便该元素上的exist（）不再返回true。将哈希元素设置为未定义的值不会删除其键，但是删除它会删除它。看到&lt;a href=&quot;exists&quot;&gt;存在&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c148d1ff0a7aebcb28822b3e1311889c861ad3aa" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies an element or slice of a hash, &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; deletes the specified elements from that hash so that exists() on that element no longer returns true. Setting a hash element to the undefined value does not remove its key, but deleting it does; see &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt;.</source>
          <target state="translated">给定一个指定元素或哈希切片的表达式， &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 将从该哈希中删除指定的元素，以便该元素上的exist（）不再返回true。将哈希元素设置为未定义的值不会删除其键，但是删除它会删除它。看到&lt;a href=&quot;#exists&quot;&gt;存在&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b769dfb6b889a385d12cb35d230597545507bff1" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">给定一个指定子例程名称的表达式，即使已声明了指定的子例程，即使未定义，也返回true。提及存在或已定义的子例程名称不算作声明它。请注意，不存在的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次调用时就存在；参见&lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1e2f23a5798654b28edd73d121507fc1d6cf61ce" translate="yes" xml:space="preserve">
          <source>Given an expression that specifies the name of a subroutine, returns true if the specified subroutine has ever been declared, even if it is undefined. Mentioning a subroutine name for exists or defined does not count as declaring it. Note that a subroutine that does not exist may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">给定一个指定子例程名称的表达式，即使已声明了指定的子例程，即使未定义，也返回true。提及存在或已定义的子例程名称不算作声明它。请注意，不存在的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次调用时就存在；参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec3e095107124a6ef85e395cac4af42d46355e9a" translate="yes" xml:space="preserve">
          <source>Given an object, return a Perl scalar number (int/float) representing this number.</source>
          <target state="translated">给定一个对象,返回一个代表这个数字的Perl标量数(int/float)。</target>
        </trans-unit>
        <trans-unit id="798afe5be4d4f8caba61172a6204d0e7a4433382" translate="yes" xml:space="preserve">
          <source>Given an open filehandle and the associated filename, make a safe unlink. This is achieved by first checking that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by stat() are compared). Then the filename is unlinked and the filehandle checked once again to verify that the number of links on that file is now 0. This is the closest you can come to making sure that the filename unlinked was the same as the file whose descriptor you hold.</source>
          <target state="translated">给定一个打开的文件柄和相关的文件名,进行安全的解除链接。首先检查文件名和filehandle最初是否指向同一个文件,并且该文件的链接数为1(比较stat()返回的所有字段)。然后解除文件名的链接,并再次检查filehandle,以验证该文件上的链接数现在为0。这是最接近于确保被解除链接的文件名与你持有的描述符的文件相同的方法。</target>
        </trans-unit>
        <trans-unit id="7c8d7de16830e305c76870f7520f278ced8e53b9" translate="yes" xml:space="preserve">
          <source>Given both a hostname and service name, this function attempts to resolve the host name into a list of network addresses, and the service name into a protocol and port number, and then returns a list of address structures suitable to connect() to it.</source>
          <target state="translated">给定主机名和服务名,该函数试图将主机名解析为网络地址列表,将服务名解析为协议和端口号,然后返回适合连接()到它的地址结构列表。</target>
        </trans-unit>
        <trans-unit id="ef7becd595d52be668be1e1f52b6edfa071be390" translate="yes" xml:space="preserve">
          <source>Given just a host name, this function attempts to resolve it to a list of network addresses, and then returns a list of address structures giving these addresses.</source>
          <target state="translated">只给定一个主机名,这个函数试图将其解析为一个网络地址列表,然后返回一个给出这些地址的地址结构列表。</target>
        </trans-unit>
        <trans-unit id="df00cd802473947a22a033a5fee10eaeb326c652" translate="yes" xml:space="preserve">
          <source>Given just a service name, this function attempts to resolve it to a protocol and port number, and then returns a list of address structures that represent it suitable to bind() to. This use should be combined with the &lt;code&gt;AI_PASSIVE&lt;/code&gt; flag; see below.</source>
          <target state="translated">仅提供服务名称，此函数尝试将其解析为协议和端口号，然后返回表示适合将其绑定到的地址结构的列表。此用法应与 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 标志结合使用；见下文。</target>
        </trans-unit>
        <trans-unit id="47c398084bf96dcff46eefda9cdadf3fedccfe90" translate="yes" xml:space="preserve">
          <source>Given neither name, it generates an error.</source>
          <target state="translated">给定两个名字都没有,就会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="4946a614ce699917e8a48264ad588e74a71edfe3" translate="yes" xml:space="preserve">
          <source>Given that the file glob is just a cut-down regular expression and that it has already done a lot of the hard work in pattern matching the filenames, wouldn't it be handy to be able to use the patterns in the fileglob to drive the new filename?</source>
          <target state="translated">考虑到文件glob只是一个裁剪下来的正则表达式,而且它已经在模式匹配文件名方面做了很多艰苦的工作,如果能够使用文件glob中的模式来驱动新的文件名,是不是很方便呢?</target>
        </trans-unit>
        <trans-unit id="1a0688e5deb209d4898cf79e8c4e93da364593b3" translate="yes" xml:space="preserve">
          <source>Given that we failed to load &lt;code&gt;Compress::Zlib&lt;/code&gt; and that the use of an external</source>
          <target state="translated">鉴于我们未能加载 &lt;code&gt;Compress::Zlib&lt;/code&gt; 并且使用了外部</target>
        </trans-unit>
        <trans-unit id="25d0946db041e6b8ec000e3934554230eea3d997" translate="yes" xml:space="preserve">
          <source>Given the filename and description of a test as scalars, returns a new &lt;a href=&quot;job&quot;&gt;TAP::Parser::Scheduler::Job&lt;/a&gt; object.</source>
          <target state="translated">给定文件名和描述为标量的测试，返回一个新的&lt;a href=&quot;job&quot;&gt;TAP :: Parser :: Scheduler :: Job&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="8321e912ffb7fc1712a163f5114b8b8cfc71ea6c" translate="yes" xml:space="preserve">
          <source>Given the following module, PerlIO::via::Hex :</source>
          <target state="translated">给出以下模块,PerlIO::via::Hex 。</target>
        </trans-unit>
        <trans-unit id="b1732b671f9a08843781c433880de7a9be2cae19" translate="yes" xml:space="preserve">
          <source>Given the following notations:</source>
          <target state="translated">鉴于以下记述:</target>
        </trans-unit>
        <trans-unit id="d2cba25d77a3267a4c7e81b67be7cfba4a549ed5" translate="yes" xml:space="preserve">
          <source>Given the name of a lexical variable, find its position in the currently-compiling pad.</source>
          <target state="translated">给定一个词汇变量的名称,找到它在当前编译垫中的位置。</target>
        </trans-unit>
        <trans-unit id="4e332da4ace4bc5d01c9ceda2ce9f67dcc253135" translate="yes" xml:space="preserve">
          <source>Given the root of an optree, link the tree in execution order using the &lt;code&gt;op_next&lt;/code&gt; pointers and return the first op executed. If this has already been done, it will not be redone, and &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; will be returned. If &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; is not already set,</source>
          <target state="translated">给定optree的根，使用 &lt;code&gt;op_next&lt;/code&gt; 指针按执行顺序链接树，并返回第一个执行的op。如果已经完成，则不会重做，并且将返回 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; 。如果尚未设置 &lt;code&gt;o-&amp;gt;op_next&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="084725aa23e7fe3c0d543b97b1c7320210101746" translate="yes" xml:space="preserve">
          <source>Given the sheer volume of Perl documentation, this isn't a trivial undertaking, but if you can point to documentation that suggests the behaviour you're seeing is</source>
          <target state="translated">考虑到Perl文档的数量,这并不是一项简单的工作,但如果你能指出你所看到的行为属于</target>
        </trans-unit>
        <trans-unit id="a51193d192cf9332f4f5d4257e036cab9b0cff3c" translate="yes" xml:space="preserve">
          <source>Given this as an input string in a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; would correctly return the string &quot;&amp;lt;&amp;lt;'EOMSG'\nThis is the message.\nEOMSG&quot;, leaving the string &quot; || die;\nexit;&quot; in the original variable. In other words, the two separate pieces of the here document are successfully extracted and concatenated.</source>
          <target state="translated">将此作为标量上下文中的输入字符串， &lt;code&gt;extract_quotelike&lt;/code&gt; 将正确返回字符串&amp;ldquo; &amp;lt;&amp;lt;'EOMSG'\ n这是消息。\ nEOMSG&amp;rdquo;，保留字符串&amp;ldquo; || die; \ nexit;&amp;rdquo; 在原始变量中。换句话说，此处文档的两个单独部分已成功提取并连接在一起。</target>
        </trans-unit>
        <trans-unit id="a8255eb67db18215cafd66b8bf6854ff058e58c2" translate="yes" xml:space="preserve">
          <source>Given two perl versions, this returns a list of pairs describing the changes in core module content between them. The list is suitable for storing in a hash. The keys are library names and the values are hashrefs. Each hashref has an entry for one or both of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; , giving the versions of the library in each of the left and right perl distributions.</source>
          <target state="translated">给定两个perl版本，这将返回一对列表，描述它们之间核心模块内容的变化。该列表适合存储在哈希中。键是库名，值是哈希引用。每个hashref都有一个用于 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 中的一个或两个的条目，从而在左侧和右侧的perl发行版中提供库的版本。</target>
        </trans-unit>
        <trans-unit id="d3e8e0d7ce171e4fc80eeb08f47d5a4cc76a6ae2" translate="yes" xml:space="preserve">
          <source>Given two versions of perl, this prints a human-readable table of all module changes between the two. The output format may change in the future, and is meant for</source>
          <target state="translated">给定两个版本的perl,这将打印出两个版本之间所有模块变化的可读表。输出格式可能会在将来发生变化,并且是用于</target>
        </trans-unit>
        <trans-unit id="d8e6036259b26c2d9989b981df7306264ca46f69" translate="yes" xml:space="preserve">
          <source>Gives a description of each test prior to performing it.</source>
          <target state="translated">在进行每项测试之前,对其进行描述。</target>
        </trans-unit>
        <trans-unit id="95e8be14901e94fb491dfdf5b70ee1b95c0f63d7" translate="yes" xml:space="preserve">
          <source>Gives more detailed information about each test, after it has been performed. Note that any failed tests ought to print out some extra information whether or not -v is thrown.</source>
          <target state="translated">在每个测试完成后,提供更详细的信息。注意,无论是否抛出-v,任何失败的测试都应该打印出一些额外的信息。</target>
        </trans-unit>
        <trans-unit id="8cd5accb9bbe824d3f2172984bdf0c7f749a0330" translate="yes" xml:space="preserve">
          <source>Gives the information about the Perl DLL or the DLL containing the C function bound to by &lt;code&gt;&amp;amp;xsub&lt;/code&gt; . The meaning of &lt;code&gt;how&lt;/code&gt; is: default (2): full name; 0: handle; 1: module name.</source>
          <target state="translated">提供有关Perl DLL或包含 &lt;code&gt;&amp;amp;xsub&lt;/code&gt; 绑定的C函数的DLL的信息。的含义 &lt;code&gt;how&lt;/code&gt; 为：默认（2）：全名; 0：句柄；1：模块名称。</target>
        </trans-unit>
        <trans-unit id="9ce00937b225bda0f6de7705049c711ca2d0c0b1" translate="yes" xml:space="preserve">
          <source>Gives the string value of &lt;code&gt;arg&lt;/code&gt; as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; , which is faster.</source>
          <target state="translated">在没有字符串化重载的情况下，给出 &lt;code&gt;arg&lt;/code&gt; 的字符串值。如果您使用它来获取引用的地址（用于检查两个引用是否指向同一事物），那么使用 &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; 可能会更好。</target>
        </trans-unit>
        <trans-unit id="cfe98f7aeaa456c4237c94f0fd4653d71593c9bc" translate="yes" xml:space="preserve">
          <source>Gives the type of hints used for previous answers. May be one of &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;recommended&lt;/code&gt; or &lt;code&gt;previous&lt;/code&gt; .</source>
          <target state="translated">提供用于先前答案的提示类型。可以是 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;recommended&lt;/code&gt; 或 &lt;code&gt;previous&lt;/code&gt; 的值之一。</target>
        </trans-unit>
        <trans-unit id="d71dccbe06d617b4160092d77a20fffa36b965b4" translate="yes" xml:space="preserve">
          <source>Giving a struct element a class type that is also a struct is how structs are nested. Here, &lt;code&gt;Timeval&lt;/code&gt; represents a time (seconds and microseconds), and &lt;code&gt;Rusage&lt;/code&gt; has two elements, each of which is of type &lt;code&gt;Timeval&lt;/code&gt; .</source>
          <target state="translated">给struct元素一个也是struct的类类型是struct嵌套的方式。在这里， &lt;code&gt;Timeval&lt;/code&gt; 表示一个时间（秒和微秒），而 &lt;code&gt;Rusage&lt;/code&gt; 具有两个元素，每个元素都是 &lt;code&gt;Timeval&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d166f9da4bac6d857f7dc131be5d65de1b02def6" translate="yes" xml:space="preserve">
          <source>Giving additional meanings to a symbol or construct. Actually, all languages do overloading to one extent or another, since people are good at figuring out things from &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">为符号或构造赋予其他含义。实际上，所有语言都会在某种程度上超载，因为人们善于从&lt;b&gt;上下文&lt;/b&gt;中找出事物。</target>
        </trans-unit>
        <trans-unit id="e8b8f975ca429de01bb46828d5e9ad364deeb90c" translate="yes" xml:space="preserve">
          <source>Giving an invalid value for &lt;code&gt;$sock_type&lt;/code&gt; will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">为 &lt;code&gt;$sock_type&lt;/code&gt; 赋予无效值将导致 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f57f0ea36677c92cf9afe99cb8959d03cc0961e" translate="yes" xml:space="preserve">
          <source>Giving up control</source>
          <target state="translated">放弃控制权</target>
        </trans-unit>
        <trans-unit id="ac34b82dc93bde9b29a5a3004c3ddbeef7e257a6" translate="yes" xml:space="preserve">
          <source>Glob elements can be extracted through the postfix dereferencing feature:</source>
          <target state="translated">Glob元素可以通过后缀去参考功能来提取。</target>
        </trans-unit>
        <trans-unit id="a2bba5393d5751445bbbac73e8d2d26ee97a6c53" translate="yes" xml:space="preserve">
          <source>Glob-style pattern matching for rules</source>
          <target state="translated">规则的Glob式模式匹配</target>
        </trans-unit>
        <trans-unit id="f4853985ae8961c644b701f3a4211e427659afca" translate="yes" xml:space="preserve">
          <source>Global Destruction</source>
          <target state="translated">全球毁灭</target>
        </trans-unit>
        <trans-unit id="d4326c5fc3d6b26143e4368742fe314ae01c47ca" translate="yes" xml:space="preserve">
          <source>Global Overriding</source>
          <target state="translated">全球覆盖</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="c74b56bb1057578230abe272aa56e202301adbc0" translate="yes" xml:space="preserve">
          <source>Global destruction.</source>
          <target state="translated">全球毁灭。</target>
        </trans-unit>
        <trans-unit id="e7f5c9eb53159b83da104e3bda376cd7346692a8" translate="yes" xml:space="preserve">
          <source>Global matching</source>
          <target state="translated">全球匹配</target>
        </trans-unit>
        <trans-unit id="3650821866c81f2ac2894b41d87da9c715e1e8ce" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for AnyDBM_File for Storable use</source>
          <target state="translated">为AnyDBM_File提供EXISTS胶水,以便存储使用。</target>
        </trans-unit>
        <trans-unit id="4909b3a46d83dbbf52b8710b4dc26c66ca78944e" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for NDBM_File for Storable use</source>
          <target state="translated">为NDBM_File提供EXISTS胶水,以供存储使用。</target>
        </trans-unit>
        <trans-unit id="d57f000cec87f12e43b8b27b36323279bd6bf351" translate="yes" xml:space="preserve">
          <source>Glue to provide EXISTS for SDBM_File for Storable use</source>
          <target state="translated">为SDBM_File提供EXISTS胶水,以供存储使用。</target>
        </trans-unit>
        <trans-unit id="1ef566e266fcd5938f2e20f4951576b582c8951b" translate="yes" xml:space="preserve">
          <source>Go and write your program. Everywhere in your program where you would say:</source>
          <target state="translated">去写你的程序。在你的程序中,凡是你会说的地方。</target>
        </trans-unit>
        <trans-unit id="17a5012f10d8e9cdb0ba165e243a06151fb8f234" translate="yes" xml:space="preserve">
          <source>Go into the newly-created directory and type:</source>
          <target state="translated">进入新创建的目录,并输入。</target>
        </trans-unit>
        <trans-unit id="29c6ec10417b35abc144d3f4a0729c76abf5e284" translate="yes" xml:space="preserve">
          <source>Going past the 70th column in a verbatim block might be ungracefully wrapped by some formatters.</source>
          <target state="translated">在逐字块中走过第70列,可能会被一些格式化的人不雅观地包装。</target>
        </trans-unit>
        <trans-unit id="4a647f902e0d765ea12195a96e4829f8b1e8aa9f" translate="yes" xml:space="preserve">
          <source>Good Practices</source>
          <target state="translated">良好做法</target>
        </trans-unit>
        <trans-unit id="7d80a18b9b9c68e6a7c1c8a8d0dbf303700b7763" translate="yes" xml:space="preserve">
          <source>Good example:</source>
          <target state="translated">好的例子。</target>
        </trans-unit>
        <trans-unit id="4143405b286941b2e4ea2b9f669d260327d04f9b" translate="yes" xml:space="preserve">
          <source>Good for tracking down why things don't work with your particular setup.</source>
          <target state="translated">很好地追踪为什么你的特定设置不能工作。</target>
        </trans-unit>
        <trans-unit id="f73c69efaf3df1b92a97b27aa347eb13fea306c3" translate="yes" xml:space="preserve">
          <source>Good patches (tight code, complete, correct) stand more chance of going in. Sloppy or incorrect patches might be placed on the back burner until the pumpking has time to fix, or might be discarded altogether without further notice.</source>
          <target state="translated">好的补丁(代码严密、完整、正确)有更多机会进入。马虎或不正确的补丁可能会被放在后面,直到南瓜有时间修复,或者可能会被完全丢弃而不另行通知。</target>
        </trans-unit>
        <trans-unit id="96e99dfa2e51dca66243d416a2cf4eff66499d06" translate="yes" xml:space="preserve">
          <source>Good places to look for pre-existing modules include &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; and &lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt; and asking on &lt;code&gt;module-authors@perl.org&lt;/code&gt; (&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list/module-authors.html&lt;/a&gt;).</source>
          <target state="translated">寻找预先存在的模块的好地方包括&lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;和&lt;a href=&quot;https://metacpan.org&quot;&gt;https://metacpan.org&lt;/a&gt;并询问 &lt;code&gt;module-authors@perl.org&lt;/code&gt; （&lt;a href=&quot;http://lists.perl.org/list/module-authors.html&quot;&gt;http://lists.perl.org/list /module-authors.html&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1707029b59612c93d147b82e0c5b435886ce180c" translate="yes" xml:space="preserve">
          <source>Gory details of parsing quoted constructs</source>
          <target state="translated">解析引用结构的血腥细节</target>
        </trans-unit>
        <trans-unit id="23f16c19388eabd103562554c9bfa091b6dac302" translate="yes" xml:space="preserve">
          <source>Got that? As of Perl 5.8.7, &lt;b&gt;&quot;UTF-8&quot;&lt;/b&gt; means UTF-8 in its current sense, which is conservative and strict and security-conscious, whereas &lt;b&gt;&quot;utf8&quot;&lt;/b&gt; means UTF-8 in its former sense, which was liberal and loose and lax. &lt;code&gt;Encode&lt;/code&gt; version 2.10 or later thus groks this subtle but critically important distinction between &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; and &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; .</source>
          <target state="translated">了解？从Perl 5.8.7开始，&lt;b&gt;&amp;ldquo; UTF-8&amp;rdquo;&lt;/b&gt;在当前意义上表示UTF-8，这是保守，严格和安全意识的，而&lt;b&gt;&amp;ldquo; utf8&amp;rdquo;&lt;/b&gt;在以前意义上表示UTF-8，其含义是自由，宽松和松懈。因此，对版本2.10或更高版本进行 &lt;code&gt;Encode&lt;/code&gt; 在 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 之间产生这种微妙但至关重要的区别。</target>
        </trans-unit>
        <trans-unit id="0b4fc0a0d78b25de463f95089769282373893971" translate="yes" xml:space="preserve">
          <source>Got that? Larry is always right, even when he was wrong. It's rare to see either Rule exercised, but they are often alluded to.</source>
          <target state="translated">明白了吗?拉里总是对的,即使他是错的。很少看到任何一条规则被执行,但它们经常被提及。</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="ca69ac23523fe10118230a18e01d42c76c8abcda" translate="yes" xml:space="preserve">
          <source>Goto celib-palm-3.0\inc\cewin32.h, search for</source>
          <target state="translated">Goto celib-palm-3.0\inc\cewin32.h,搜索</target>
        </trans-unit>
        <trans-unit id="5890e910925d55654694f7ac1d42c03b68abbff2" translate="yes" xml:space="preserve">
          <source>Gotta have a plan!</source>
          <target state="translated">得有个计划!</target>
        </trans-unit>
        <trans-unit id="df8da02e8026798b67902a6787a5e32f5d1a8e68" translate="yes" xml:space="preserve">
          <source>Gprof Profiling</source>
          <target state="translated">Gprof Profiling</target>
        </trans-unit>
        <trans-unit id="3259bccd5547a6fb8f77a4aaea022a14a41cb136" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;</target>
        </trans-unit>
        <trans-unit id="42879164d6188855410d722427bd053e05e54ab7" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3732fa7e665009645e9e3e4379dd15edc1deb872" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）&amp;lt;gbarr@pobox.com&amp;gt;，贾科（Jarkko Hietaniemi）&amp;lt;jhi@iki.fi&amp;gt;，马库斯&amp;middot;荷兰（Marcus Holland-Moritz）&amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04f7ed11e65f8179b2c21de31c70c0e5a2b54f2f" translate="yes" xml:space="preserve">
          <source>Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;, Marcus Holland-Moritz &amp;lt;mhx@cpan.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔&amp;lt;gbarr@pobox.com&amp;gt;，马库斯&amp;middot;荷兰&amp;middot;莫里茨&amp;lt;mhx@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7820aa7c6db183e706a7e84c2116e052f42811c0" translate="yes" xml:space="preserve">
          <source>Graham Barr, the original Configure script of libnet.</source>
          <target state="translated">Graham Barr,libnet的原始配置脚本。</target>
        </trans-unit>
        <trans-unit id="6433e49daadbc911a68d39c3c194d36d03e3dce3" translate="yes" xml:space="preserve">
          <source>Graham Barr. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）。目前由Perl Porters维护。请将所有错误报告给&amp;lt;perlbug@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="87a1ea2f5e9ab380ccaeb3b75aeec67585ecc358" translate="yes" xml:space="preserve">
          <source>Graham Barr. atmark() by Lincoln Stein. Currently maintained by the Perl Porters. Please report all bugs to &amp;lt;perlbug@perl.org&amp;gt;.</source>
          <target state="translated">格雷厄姆&amp;middot;巴尔（Graham Barr）。林肯&amp;middot;斯坦（Lincoln Stein）的atmark（）。目前由Perl Porters维护。请将所有错误报告给&amp;lt;perlbug@perl.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="851fd61fa3fb1f5808ef8c8f9dd236974160fdad" translate="yes" xml:space="preserve">
          <source>Graham Knop &amp;lt;haarg@haarg.org&amp;gt;</source>
          <target state="translated">格雷厄姆&amp;middot;诺普（Graham Knop）&amp;lt;haarg@haarg.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd17342cb47b948d64f169d73cfeec3f8b3e3f31" translate="yes" xml:space="preserve">
          <source>Grammar</source>
          <target state="translated">Grammar</target>
        </trans-unit>
        <trans-unit id="ca8c988917ca583e838e2647bffdc0dd152b9fb8" translate="yes" xml:space="preserve">
          <source>Grammatical note on local()</source>
          <target state="translated">关于local()的语法说明</target>
        </trans-unit>
        <trans-unit id="844b43fd71cbef7f18e867fe292f5c5684e1ab12" translate="yes" xml:space="preserve">
          <source>Great care is necessary when defining the command if quoting needs to be done. For instance, you would need to say:</source>
          <target state="translated">在定义命令时,如果需要引用,就需要非常小心。例如,你需要说</target>
        </trans-unit>
        <trans-unit id="8c5e7d8a89c7b18aac43a9485b1546ac5b284f75" translate="yes" xml:space="preserve">
          <source>Group ID&amp;mdash;in Unix, the numeric group ID that the &lt;b&gt;operating system&lt;/b&gt; uses to identify you and members of your &lt;b&gt;group&lt;/b&gt;.</source>
          <target state="translated">组ID-在Unix中，是&lt;b&gt;操作系统&lt;/b&gt;用来标识您和您的&lt;b&gt;组&lt;/b&gt;成员的数字组ID 。</target>
        </trans-unit>
        <trans-unit id="16a718e915556d62f893e87ee82787d36995c7e4" translate="yes" xml:space="preserve">
          <source>Group Perl's functions a la perlfunc.pod</source>
          <target state="translated">将Perl的函数进行分组,如perlfunc.pod。</target>
        </trans-unit>
        <trans-unit id="ba2d2b2b97d3fc7cff00f1012c3e7d17c04c2768" translate="yes" xml:space="preserve">
          <source>Group of languages collectively called &quot;Otom&amp;iacute;&quot;.</source>
          <target state="translated">一组语言统称为&amp;ldquo;Otom&amp;iacute;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="cb77c777665eaa5c9fc03cd1712f2d2993483948" translate="yes" xml:space="preserve">
          <source>Group ownwership of directories that already exist will not be changed.</source>
          <target state="translated">已经存在的目录的群组所有权将不会被改变。</target>
        </trans-unit>
        <trans-unit id="fc00408fdf05ce5150089b75b75b23c46962261d" translate="yes" xml:space="preserve">
          <source>Grouping things and hierarchical matching</source>
          <target state="translated">事物的分组和层次的匹配</target>
        </trans-unit>
        <trans-unit id="fee5f710c9ba7310f55f4c68e3911ad898f334f8" translate="yes" xml:space="preserve">
          <source>Growing Your Own</source>
          <target state="translated">自己种植</target>
        </trans-unit>
        <trans-unit id="7864c5c65bb01ac0a14a3115852b7c02219c584f" translate="yes" xml:space="preserve">
          <source>Guaran&amp;iacute;</source>
          <target state="translated">Guaran&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="23ca9988de5733d8c8247a3e4e4982df4f209ed4" translate="yes" xml:space="preserve">
          <source>Guess the name of this package by examining the working directory's name. MakeMaker calls this only if the developer has not supplied a NAME attribute.</source>
          <target state="translated">通过检查工作目录的名称来猜测这个包的名称。只有当开发者没有提供NAME属性时,MakeMaker才会调用这个功能。</target>
        </trans-unit>
        <trans-unit id="07aa51a012723e8368dc093b343c1ff642baa052" translate="yes" xml:space="preserve">
          <source>Guess.U</source>
          <target state="translated">Guess.U</target>
        </trans-unit>
        <trans-unit id="b6684e2eba17124bde1d0355e24c5684aef1bed6" translate="yes" xml:space="preserve">
          <source>Guesses encoding from data</source>
          <target state="translated">从数据中猜测编码</target>
        </trans-unit>
        <trans-unit id="73b139c37c0097cfe3599d3082c96b0c2aee8d6a" translate="yes" xml:space="preserve">
          <source>Guidelines for Converting Perl 4 Library Scripts into Modules</source>
          <target state="translated">将Perl 4库脚本转换为模块的指南</target>
        </trans-unit>
        <trans-unit id="c758bdbdcf1ca454825428e4f69546fbfdaf18d9" translate="yes" xml:space="preserve">
          <source>Guidelines for Module Creation</source>
          <target state="translated">模块创建指南</target>
        </trans-unit>
        <trans-unit id="5fc6aecec704586c9198ddc6d24910690ea4c4e4" translate="yes" xml:space="preserve">
          <source>Guidelines for Reusing Application Code</source>
          <target state="translated">应用程序代码的再利用指南</target>
        </trans-unit>
        <trans-unit id="9f22068b470b55c5659b24a529d486d165efe1e8" translate="yes" xml:space="preserve">
          <source>Gulliver's Travels</source>
          <target state="translated">格列佛游记</target>
        </trans-unit>
        <trans-unit id="d3d42475682a0666adb5abe77243023160ef0a45" translate="yes" xml:space="preserve">
          <source>Gunzip/gzip for OS/390 is discussed at:</source>
          <target state="translated">关于OS/390的Gunzip/gzip的讨论见:</target>
        </trans-unit>
        <trans-unit id="93a0fe097041b93e0be65ee154daffc6b1381bc9" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d960951b2cdfc9f9204beae43f12a4a11b295b41" translate="yes" xml:space="preserve">
          <source>Gurusamy Sarathy gsar@activestate.com</source>
          <target state="translated">Gurusamy Sarathy gsar@activestate.com</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="58edf605e14f939b5061c16becc3c237b2cf3c47" translate="yes" xml:space="preserve">
          <source>H.Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</source>
          <target state="translated">H.Merijn Brand &amp;lt;hmbrand@xs4all.nl&amp;gt; Jeff Okamoto &amp;lt;okamoto@corp.hp.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="47ce9e7227c5c88413414b245a64737d1d7aa032" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;autoflush( EXPR )</source>
          <target state="translated">处理-&amp;gt;自动冲洗（EXPR）</target>
        </trans-unit>
        <trans-unit id="e39692187e35b8d86da8462f683967a48317dea2" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_left(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_left(EXPR)</target>
        </trans-unit>
        <trans-unit id="209a918918c25cd99d83f2f0dbbc4f467dc693f1" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_lines_per_page(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_lines_per_page(EXPR)</target>
        </trans-unit>
        <trans-unit id="f1d2f9361bebc33157aeedef49dc5f8e73598847" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="0c9bdf53fa0c2bc01c5c44ec8066b07d741898ab" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_page_number(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_page_number(EXPR)</target>
        </trans-unit>
        <trans-unit id="7462f62c1d1e40bafc8b07b413de84a660ada74e" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;format_top_name(EXPR)</source>
          <target state="translated">HANDLE-&amp;gt;format_top_name(EXPR)</target>
        </trans-unit>
        <trans-unit id="69f09f09d96a3982a3608cf0a03c946ae72aee61" translate="yes" xml:space="preserve">
          <source>HANDLE-&amp;gt;input_line_number( EXPR )</source>
          <target state="translated">HANDLE-&amp;gt; input_line_number（EXPR）</target>
        </trans-unit>
        <trans-unit id="789c59b41e5418de142d321c95b023de4bdfe79e" translate="yes" xml:space="preserve">
          <source>HASHES OF ARRAYS</source>
          <target state="translated">阵列的ASHES</target>
        </trans-unit>
        <trans-unit id="530c7188bb0935938e3b58577815f4334a49e6ef" translate="yes" xml:space="preserve">
          <source>HASHES OF HASHES</source>
          <target state="translated">HASHES OF HASHES</target>
        </trans-unit>
        <trans-unit id="a880c390a6cf41f70f9a43af2b194442bbe8c615" translate="yes" xml:space="preserve">
          <source>HEY</source>
          <target state="translated">HEY</target>
        </trans-unit>
        <trans-unit id="fc5d4b9117ba9e87388174aee4f4970bdfe8d066" translate="yes" xml:space="preserve">
          <source>HH</source>
          <target state="translated">HH</target>
        </trans-unit>
        <trans-unit id="5b8cce18efcb259ac8ee29e1cd21dcc198081fdb" translate="yes" xml:space="preserve">
          <source>HHHH</source>
          <target state="translated">HHHH</target>
        </trans-unit>
        <trans-unit id="9c2ea135ec1db4f446c806f7895ae6f2c302104a" translate="yes" xml:space="preserve">
          <source>HINTS AND TIPS</source>
          <target state="translated">提示和技巧</target>
        </trans-unit>
        <trans-unit id="f6dc58f5e8036353a7ac15516c30ac562e23dc26" translate="yes" xml:space="preserve">
          <source>HISTORY</source>
          <target state="translated">HISTORY</target>
        </trans-unit>
        <trans-unit id="d0e8f9a5a2dbdd8722af6ec7f2972e1375fb801e" translate="yes" xml:space="preserve">
          <source>HMAC-SHA-1/224/256/384/512</source>
          <target state="translated">HMAC-SHA-1/224/256/384/512</target>
        </trans-unit>
        <trans-unit id="a76f8ee2872265eb6fe359928ee6904e71dc9d05" translate="yes" xml:space="preserve">
          <source>HOW IT WORKS</source>
          <target state="translated">如何工作</target>
        </trans-unit>
        <trans-unit id="eab9f433c21086a197b4e1c36ca01d70a2e0dffa" translate="yes" xml:space="preserve">
          <source>HOW TO USE MAKETEXT</source>
          <target state="translated">如何使用MAKETEXT</target>
        </trans-unit>
        <trans-unit id="6ab52b908787e3ae467e585a2243118089d23d99" translate="yes" xml:space="preserve">
          <source>HP Itanium 2 systems are usually referred to with model description &quot;HP Integrity&quot;.</source>
          <target state="translated">HP Itanium 2系统通常以型号说明 &quot;HP Integrity &quot;来表示。</target>
        </trans-unit>
        <trans-unit id="9e3417f4faadcebc07bb9497031485b632cc05e1" translate="yes" xml:space="preserve">
          <source>HP also ships servers with the 128-bit Itanium processor(s). The cx26x0 is told to have Madison 6. As of the date of this document's last update, the following systems contain Itanium or Itanium 2 chips (this is likely to be out of date):</source>
          <target state="translated">惠普公司还推出了采用128位Itanium处理器的服务器。据悉,cx26x0采用了Madison 6。截至本文档最后一次更新的日期,以下系统包含Itanium或Itanium 2芯片(这很可能是过时的)。</target>
        </trans-unit>
        <trans-unit id="2d0a2c854fdfe25037f6f2462163a3677a8c0d9a" translate="yes" xml:space="preserve">
          <source>HP has asked the porting centre to move Open Source binaries from /opt to /usr/local, so binaries produced since the start of July 2002 are located in /usr/local.</source>
          <target state="translated">HP已经要求移植中心将开放源码的二进制文件从/opt移到/usr/local,所以2002年7月开始制作的二进制文件位于/usr/local。</target>
        </trans-unit>
        <trans-unit id="a764a39116b67d584d0e922398f34d8a6157ce49" translate="yes" xml:space="preserve">
          <source>HP porting centre tries to keep up with customer demand and release updates from the Open Source community. Having precompiled Perl binaries available is obvious, though &quot;up-to-date&quot; is something relative. At the moment of writing only perl-5.10.1 was available (with 5.16.3 being the latest stable release from the porters point of view).</source>
          <target state="translated">HP 移植中心试图跟上客户的需求,并发布来自开源社区的更新。拥有预编译的Perl二进制文件是显而易见的,尽管 &quot;最新 &quot;是相对的。在写这篇文章的时候,只有 perl-5.10.1 是可用的 (从移植者的角度来看,5.16.3 是最新的稳定版本)。</target>
        </trans-unit>
        <trans-unit id="9dbd2af4559edefe4dd19c07c7c19b95825a0430" translate="yes" xml:space="preserve">
          <source>HP's HP9000 Unix systems run on HP's own Precision Architecture (PA-RISC) chip. HP-UX used to run on the Motorola MC68000 family of chips, but any machine with this chip in it is quite obsolete and this document will not attempt to address issues for compiling Perl on the Motorola chipset.</source>
          <target state="translated">HP公司的HP9000 Unix系统运行在HP公司自己的Precision Architecture(PA-RISC)芯片上。HP-UX曾经运行在Motorola MC68000系列芯片上,但任何装有这种芯片的机器都已经相当过时了,本文档将不试图解决在Motorola芯片组上编译Perl的问题。</target>
        </trans-unit>
        <trans-unit id="5d006886dc4fd65e0adca5c8c02c5767eb4d1359" translate="yes" xml:space="preserve">
          <source>HP-UX 11 Y2K patch &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 Patch Bundle&quot; has been reported to break the io/fs test #18 which tests whether utime() can change timestamps. The Y2K patch seems to break utime() so that over NFS the timestamps do not get changed (on local filesystems utime() still works). This has probably been fixed on your system by now.</source>
          <target state="translated">HP-UX 11 Y2K 补丁 &quot;Y2K-1100 B.11.00.B0125 HP-UX Core OS Year 2000 补丁包 &quot;被报告破坏了测试 utime()是否能改变时间戳的 io/fs 测试 #18。Y2K 补丁似乎破坏了 utime(),因此在 NFS 上时间戳不会被改变 (在本地文件系统上 utime()仍然有效)。这个问题在你的系统上可能已经被解决了。</target>
        </trans-unit>
        <trans-unit id="97187cfde6c75a8b8deebd75a13a60ae1c81f420" translate="yes" xml:space="preserve">
          <source>HP-UX 11i documentation on syslog, &lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http://docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</source>
          <target state="translated">有关syslog的HP-UX 11i文档，&lt;a href=&quot;http://docs.hp.com/en/B2355-60130/syslog.3C.html&quot;&gt;http：//docs.hp.com/en/B2355-60130/syslog.3C.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed2a9bb260e4ae72bbe1af113a3b7bdf4f05246c" translate="yes" xml:space="preserve">
          <source>HP-UX Kernel Parameters (maxdsiz) for Compiling Perl</source>
          <target state="translated">HP-UX编译Perl的内核参数(maxdsiz)</target>
        </trans-unit>
        <trans-unit id="83019d5a780dd0ff3c9db7fabc3a90c74127c6c2" translate="yes" xml:space="preserve">
          <source>HP-UX also runs on the new Itanium processor. This requires the use of a different version of HP-UX (currently 11.23 or 11i v2), and with the exception of a few differences detailed below and in later sections, Perl should compile with no problems.</source>
          <target state="translated">HP-UX还可以在新的Itanium处理器上运行。这就需要使用不同版本的HP-UX(目前是11.23或11i v2),除了下面和后面的章节中详述的一些差异外,Perl的编译应该没有问题。</target>
        </trans-unit>
        <trans-unit id="6054c4b79943ef67e4dcb28eb588b66781f366f6" translate="yes" xml:space="preserve">
          <source>HP-UX supports dynamically loadable libraries (shared libraries). Shared libraries end with the suffix .sl. On Itanium systems, they end with the suffix .so.</source>
          <target state="translated">HP-UX支持动态加载库(共享库)。共享库以后缀.sl结尾,在Itanium系统中,它们以后缀.so结尾。在Itanium系统中,它们以后缀.so结尾。</target>
        </trans-unit>
        <trans-unit id="b4319bb42f0da477a0906018447c3096d305eb37" translate="yes" xml:space="preserve">
          <source>HP-UX versions</source>
          <target state="translated">HP-UX版本</target>
        </trans-unit>
        <trans-unit id="0c355dad6ecf8b6970623574fcecedac49554b22" translate="yes" xml:space="preserve">
          <source>HP-UX versions before 10.30 require a separate installation of a POSIX threads library package. Two examples are the HP DCE package, available on &quot;HP-UX Hardware Extensions 3.0, Install and Core OS, Release 10.20, April 1999 (B3920-13941)&quot; or the Freely available PTH package, available on H.Merijn's site (&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http://mirrors.develooper.com/hpux/&lt;/a&gt;). The use of PTH will be unsupported in perl-5.12 and up and is rather buggy in 5.11.x.</source>
          <target state="translated">10.30之前的HP-UX版本需要单独安装POSIX线程库软件包。两个示例是可在&amp;ldquo; HP-UX硬件扩展3.0，安装和核心操作系统，版本10.20，1999年4月（B3920-13941）&amp;rdquo;上获得的HP DCE软件包，或可在H.Merijn的网站上获得的免费PTH软件包（&lt;a href=&quot;http://mirrors.develooper.com/hpux/&quot;&gt;http： //mirrors.develooper.com/hpux/&lt;/a&gt;）。在Perl-5.12及更高版本中将不支持PTH的使用，而在5.11.x中则相当容易出错。</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="9386c18987cda4e4b47eab3b2d462dd758250ce8" translate="yes" xml:space="preserve">
          <source>Ha! Try that with your garden variety regexp package...</source>
          <target state="translated">哈! 试试用你的花园品种regexp包...试着用你的花园品种regexp包......</target>
        </trans-unit>
        <trans-unit id="d88e3f220c919ffbf868396a7d774a5334f737c8" translate="yes" xml:space="preserve">
          <source>Hack, hack, hack. Keep in mind that Perl runs on many different platforms, with different operating systems that have different capabilities, different filesystem organizations, and even different character sets. &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; gives advice on this.</source>
          <target state="translated">哈克，哈克，哈克。请记住，Perl在许多不同的平台上运行，具有不同的操作系统，这些操作系统具有不同的功能，不同的文件系统组织，甚至不同的字符集。&lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips对此&lt;/a&gt;提供了建议。</target>
        </trans-unit>
        <trans-unit id="aa83b6b9d8de018c03b6e14834f7dbb735668abf" translate="yes" xml:space="preserve">
          <source>Hackathons</source>
          <target state="translated">Hackathons</target>
        </trans-unit>
        <trans-unit id="70b5ad218deb587375e9d9ea493155e8eea890e8" translate="yes" xml:space="preserve">
          <source>Hackathons are a very different kind of gathering where Perl hackers gather to do just that, hack nonstop for an extended (several day) period on a specific project or projects. Information about hackathons can be located in the same place as information about &lt;a href=&quot;#Workshops&quot;&gt;workshops&lt;/a&gt; as well as in &lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;irc://irc.perl.org/#perl&lt;/a&gt;.</source>
          <target state="translated">黑客马拉松是一种非常不同的聚会，Perl黑客聚集在一起做，在一个或多个特定项目上长时间（几天）不间断地进行黑客入侵。关于这种形式的比赛信息可以位于同一地点的有关信息&lt;a href=&quot;#Workshops&quot;&gt;研讨会&lt;/a&gt;，以及在&lt;a href=&quot;irc://irc.perl.org/#perl&quot;&gt;IRC：//irc.perl.org/#perl&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5b2f425b8ec6dc0f52bcfb2fe8c13331b8f6480" translate="yes" xml:space="preserve">
          <source>Hacking Perl to work on earlier Unicode versions (for very serious hackers only)</source>
          <target state="translated">黑进Perl,使其能在早期的Unicode版本上工作(仅供非常认真的黑客使用</target>
        </trans-unit>
        <trans-unit id="c241df4cb37e7ba32f33cd5ab23a83488a78b7ae" translate="yes" xml:space="preserve">
          <source>Hacking tools and documentation</source>
          <target state="translated">黑客工具和文件</target>
        </trans-unit>
        <trans-unit id="2cd3bee34e1e2aafe8cc6f8bcda061ef9d49610f" translate="yes" xml:space="preserve">
          <source>Half a &lt;b&gt;byte&lt;/b&gt;, equivalent to one &lt;b&gt;hexadecimal&lt;/b&gt; digit, and worth four &lt;b&gt;bits&lt;/b&gt;.</source>
          <target state="translated">半&lt;b&gt;字节&lt;/b&gt;，相当于一个&lt;b&gt;十六进制&lt;/b&gt;数字，值4 &lt;b&gt;位&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6d8ab5e201dd91380811a77b55a7a931f3d5eee4" translate="yes" xml:space="preserve">
          <source>Halfway between &lt;code&gt;ok()&lt;/code&gt; and &lt;code&gt;is()&lt;/code&gt; lies &lt;code&gt;cmp_ok()&lt;/code&gt; . This allows you to compare two arguments using any binary perl operator. The test passes if the comparison is true and fails otherwise.</source>
          <target state="translated">在 &lt;code&gt;ok()&lt;/code&gt; 和 &lt;code&gt;is()&lt;/code&gt; 之间的 &lt;code&gt;cmp_ok()&lt;/code&gt; 是cmp_ok（）。这使您可以使用任何二进制perl运算符比较两个参数。如果比较为真，则测试通过，否则为失败。</target>
        </trans-unit>
        <trans-unit id="86179df6c35646296ecd922e347bf8fb4cdc3c6c" translate="yes" xml:space="preserve">
          <source>Hand-editing</source>
          <target state="translated">Hand-editing</target>
        </trans-unit>
        <trans-unit id="2243466296e92364f7bf27ac345ae2a71eab76a8" translate="yes" xml:space="preserve">
          <source>Handle is open.</source>
          <target state="translated">手柄是打开的。</target>
        </trans-unit>
        <trans-unit id="9bb0ae5137688cc1b8e62808a86d332a61061726" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope entry. Arranges for hints to be restored on block exit and also handles pad sequence numbers to make lexical variables scope right. Returns a savestack index for use with &lt;code&gt;block_end&lt;/code&gt; .</source>
          <target state="translated">处理编译时范围条目。安排在块退出时恢复提示，并处理填充序列号以使词汇变量作用域正确。返回与使用savestack指数 &lt;code&gt;block_end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aadca6115d853e86175413031bcfebcbec35442a" translate="yes" xml:space="preserve">
          <source>Handles compile-time scope exit.</source>
          <target state="translated">处理编译时的作用域退出。</target>
        </trans-unit>
        <trans-unit id="a78a213e08f22079d0727d65ee7cd82040828af3" translate="yes" xml:space="preserve">
          <source>Handles that were opened write-only won't work. Handles that were opened read-only will work as long as you don't try to modify the array. Handles must be attached to seekable sources of data---that means no pipes or sockets. If &lt;code&gt;Tie::File&lt;/code&gt; can detect that you supplied a non-seekable handle, the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will throw an exception. (On Unix systems, it can detect this.)</source>
          <target state="translated">打开的只写句柄将不起作用。只要您不尝试修改数组，以只读方式打开的句柄就可以工作。必须将句柄附加到可搜索的数据源上，这意味着没有管道或插座。如果 &lt;code&gt;Tie::File&lt;/code&gt; 可以检测到您提供了不可搜索的句柄，则 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将引发异常。（在Unix系统上，它可以检测到这一点。）</target>
        </trans-unit>
        <trans-unit id="3dca08a90c7ec673523c972aeb9655cc6ba04e87" translate="yes" xml:space="preserve">
          <source>Handles the installing and uninstalling of perl modules, scripts, man pages, etc...</source>
          <target state="translated">处理perl模块、脚本、man页等的安装和卸载。</target>
        </trans-unit>
        <trans-unit id="caa1714db5e5ddfa607afe3449dc66f6283180d0" translate="yes" xml:space="preserve">
          <source>Handling Duplicate Keys</source>
          <target state="translated">处理重复的钥匙</target>
        </trans-unit>
        <trans-unit id="0f01c504507d7832a1cac719e698e1e7e8a378a8" translate="yes" xml:space="preserve">
          <source>Handling Malformed Data</source>
          <target state="translated">处理畸形数据</target>
        </trans-unit>
        <trans-unit id="f0f0fc76a1e441991cde68774fcefb6a0861fb18" translate="yes" xml:space="preserve">
          <source>Handling Unicode</source>
          <target state="translated">处理Unicode</target>
        </trans-unit>
        <trans-unit id="5c331b1b1b146d85b0798abcb652f4dbd9cc2a65" translate="yes" xml:space="preserve">
          <source>Handling Unicode is for the most part transparent: just use the strings as usual. Functions like &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; will work on the Unicode characters; regular expressions will work on the Unicode characters (see &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;).</source>
          <target state="translated">处理Unicode在大多数情况下是透明的：只需照常使用字符串即可。诸如 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 之类的函数将对Unicode字符起作用；正则表达式适用于Unicode字符（请参阅&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;和&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="88d69acff614c1d827ede2f260f6a46a48647c42" translate="yes" xml:space="preserve">
          <source>Handling simple options is straightforward:</source>
          <target state="translated">处理简单的选项是直接的。</target>
        </trans-unit>
        <trans-unit id="8e71d792bc3c7ca46b9ebe6e4e08dc39ffe6877b" translate="yes" xml:space="preserve">
          <source>Handling the SIGHUP Signal in Daemons</source>
          <target state="translated">处理Daemons中的SIGHUP信号</target>
        </trans-unit>
        <trans-unit id="6e120aed62a343cea2462c78b0c345bd93d57340" translate="yes" xml:space="preserve">
          <source>Handy Values</source>
          <target state="translated">便利值</target>
        </trans-unit>
        <trans-unit id="049503c569a7548e0e0aaf7ff650cdb7e260c634" translate="yes" xml:space="preserve">
          <source>Handy for putting in notes which might be useful for debugging, but don't indicate a problem.</source>
          <target state="translated">便于放入可能对调试有用的注释,但不表明问题。</target>
        </trans-unit>
        <trans-unit id="57d70b3a1b3e8f06b27f21ad6f5e77255bd44b1f" translate="yes" xml:space="preserve">
          <source>Handy for things like...</source>
          <target state="translated">方便的事情,如...</target>
        </trans-unit>
        <trans-unit id="04a45a64a65bd1462cbe3b6ef2c3619b7fc7d816" translate="yes" xml:space="preserve">
          <source>Handy for this sort of thing:</source>
          <target state="translated">对这种事情很方便。</target>
        </trans-unit>
        <trans-unit id="eb631afbbf9621a14aebc98eacec8ff594f19f3b" translate="yes" xml:space="preserve">
          <source>Handy tip: put &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; in your</source>
          <target state="translated">实用提示：将 &lt;code&gt;set PERLDOC=-ortf&lt;/code&gt; 放入您的</target>
        </trans-unit>
        <trans-unit id="951499a6cfa4736aa7a1d36a7019e79078429a7e" translate="yes" xml:space="preserve">
          <source>HangulSyllableType.txt</source>
          <target state="translated">HangulSyllableType.txt</target>
        </trans-unit>
        <trans-unit id="dc5f45cb92e25fd3e9f4ed85dddd70a19341bbf4" translate="yes" xml:space="preserve">
          <source>Hard and symbolic (&quot;soft&quot;) links; linkname should specify target.</source>
          <target state="translated">硬链接和符号链接(&quot;软&quot;);链接名应指定目标。</target>
        </trans-unit>
        <trans-unit id="cdae1ec5d05114509a53fe67f0320c6eadea6400" translate="yes" xml:space="preserve">
          <source>Hard links are implemented on Win32 under NTFS only. They are natively supported on Windows 2000 and later. On Windows NT they are implemented using the Windows POSIX subsystem support and the Perl process will need Administrator or Backup Operator privileges to create hard links.</source>
          <target state="translated">硬链接仅在NTFS下的Win32上实现。在Windows 2000及以后的版本中,硬链接是本地支持的。在Windows NT上,它们是通过Windows POSIX子系统支持来实现的,Perl进程需要管理员或备份操作员权限来创建硬链接。</target>
        </trans-unit>
        <trans-unit id="7cec0c304aaf210bfe25cbb78814c09191b199ee" translate="yes" xml:space="preserve">
          <source>Hard references are smart--they keep track of reference counts for you, automatically freeing the thing referred to when its reference count goes to zero. (Reference counts for values in self-referential or cyclic data structures may not go to zero without a little help; see &lt;a href=&quot;#Circular-References&quot;&gt;Circular References&lt;/a&gt; for a detailed explanation.) If that thing happens to be an object, the object is destructed. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more about objects. (In a sense, everything in Perl is an object, but we usually reserve the word for references to objects that have been officially &quot;blessed&quot; into a class package.)</source>
          <target state="translated">硬引用很聪明-他们为您跟踪引用计数，当引用计数变为零时会自动释放所引用的对象。（自引用或循环数据结构中值的引用计数在没有一点帮助的情况下可能不会为零；有关详细说明，请参见&lt;a href=&quot;#Circular-References&quot;&gt;循环引用&lt;/a&gt;。）如果该对象碰巧是一个对象，则该对象将被破坏。有关对象的更多信息，请参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。（从某种意义上说，Perl中的所有内容都是一个对象，但是我们通常保留该词用于引用已被正式&amp;ldquo;祝福&amp;rdquo;到类包中的对象。）</target>
        </trans-unit>
        <trans-unit id="66e944742ea0249f6f2a6fd52c3e9e415e65aaeb" translate="yes" xml:space="preserve">
          <source>Harness output delegate for default console output</source>
          <target state="translated">驾驭输出委托,实现默认的控制台输出</target>
        </trans-unit>
        <trans-unit id="2dd2c2e596e19cb5f6f12eac61588cccdf06ec03" translate="yes" xml:space="preserve">
          <source>Harness output delegate for file output</source>
          <target state="translated">驾驭输出委托,用于文件输出</target>
        </trans-unit>
        <trans-unit id="363bd8bca1592722722a3ac3fe8ee3189add2d7b" translate="yes" xml:space="preserve">
          <source>Harness output delegate for parallel console output</source>
          <target state="translated">驾驭输出委托,实现并行控制台输出</target>
        </trans-unit>
        <trans-unit id="ba951792ddfec9b17fd8944b4026a028108c3aa1" translate="yes" xml:space="preserve">
          <source>Has already been</source>
          <target state="translated">已经</target>
        </trans-unit>
        <trans-unit id="d8861f9d9089d32f3fb836f33024a00d9824a27b" translate="yes" xml:space="preserve">
          <source>Has global effect, persists after the application exits.</source>
          <target state="translated">具有全局性效果,在应用程序退出后持续存在。</target>
        </trans-unit>
        <trans-unit id="d791fc07c3f03c0d15e5cd282a309f1887be4bb0" translate="yes" xml:space="preserve">
          <source>Has it been done before?</source>
          <target state="translated">以前有做过吗?</target>
        </trans-unit>
        <trans-unit id="2929382f580bfdd31a77bfbbda12fefbb2e9c2b6" translate="yes" xml:space="preserve">
          <source>Has the same behavior as the match operator. Also, the left operand of &lt;code&gt;=~&lt;/code&gt; becomes tainted when a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect, if modified as a result of a substitution based on a regular expression match involving any of the things mentioned in the previous item, or of case-mapping, such as &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; ,&lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , or &lt;code&gt;\F&lt;/code&gt; .</source>
          <target state="translated">具有与match运算符相同的行为。同样，当包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境形式生效时， &lt;code&gt;=~&lt;/code&gt; 的左操作数也会受到污染，如果是基于涉及上一项提到的任何事情的正则表达式匹配的替换结果而进行修改的话， -mapping，如 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ，或 &lt;code&gt;\F&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2e911d125c069efa7d913b344e0f08f8969421a" translate="yes" xml:space="preserve">
          <source>Hash API Extensions</source>
          <target state="translated">哈希API扩展</target>
        </trans-unit>
        <trans-unit id="ffc5f6e94a276eeaf94de20a0e4f426d64a6723d" translate="yes" xml:space="preserve">
          <source>Hash Algorithm - Hash algorithms like the one used in Perl are well known to be vulnerable to collision attacks on their hash function. Such attacks involve constructing a set of keys which collide into the same bucket producing inefficient behavior. Such attacks often depend on discovering the seed of the hash function used to map the keys to buckets. That seed is then used to brute-force a key set which can be used to mount a denial of service attack. In Perl 5.8.1 changes were introduced to harden Perl to such attacks, and then later in Perl 5.18.0 these features were enhanced and additional protections added.</source>
          <target state="translated">散列算法-众所周知,像Perl中使用的散列算法在其散列函数上容易受到碰撞攻击。这种攻击涉及到构建一组密钥,这些密钥会碰撞到同一个桶中,从而产生低效率的行为。这种攻击通常依赖于发现用于将密钥映射到桶的哈希函数的种子。然后,这个种子就会被用来粗暴地强制执行一个密钥集,而这个密钥集可以用来发动拒绝服务攻击。在Perl 5.8.1中,我们引入了一些变化,以使Perl能够抵御这种攻击,后来在Perl 5.18.0中,这些功能得到了加强,并增加了额外的保护措施。</target>
        </trans-unit>
        <trans-unit id="f61062d96868959d8bad3f3f9d8706be2a8eb3f6" translate="yes" xml:space="preserve">
          <source>Hash Manipulation Functions</source>
          <target state="translated">哈希操作函数</target>
        </trans-unit>
        <trans-unit id="305905caf9fb73ce326146ab6da346f5a44d3d5e" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。</target>
        </trans-unit>
        <trans-unit id="38990845f56b0504f14a42e264d2e90a4529057f" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。在项的插入和删除方面，绑定的哈希行为可能与Perl的哈希有所不同。</target>
        </trans-unit>
        <trans-unit id="e9c5186b59e1d86cc131a1fce52452e4e4a1c3b7" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。</target>
        </trans-unit>
        <trans-unit id="c3ca36bf1a5daf8ef9f034a1d277717a3712e5c2" translate="yes" xml:space="preserve">
          <source>Hash entries are returned in an apparently random order. The actual random order is specific to a given hash; the exact same series of operations on two hashes may result in a different order for each hash. Any insertion into the hash may change the order, as will any deletion, with the exception that the most recent key returned by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; may be deleted without changing the order. So long as a given hash is unmodified you may rely on &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; to repeatedly return the same order as each other. See &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt; for details on why hash order is randomized. Aside from the guarantees provided here the exact details of Perl's hash algorithm and the hash traversal order are subject to change in any release of Perl. Tied hashes may behave differently to Perl's hashes with respect to changes in order on insertion and deletion of items.</source>
          <target state="translated">哈希条目以明显随机的顺序返回。实际的随机顺序特定于给定的哈希。对两个散列进行完全相同的一系列操作可能会导致每个散列的顺序不同。散列中的任何插入都可以更改顺序，删除操作也可以更改顺序，不同之处在于， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 返回的最新密钥可以在不更改顺序的情况下被删除。只要给定的哈希是未修改的，您就可以依赖 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 来重复返回彼此相同的顺序。请参阅&lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂度攻击&lt;/a&gt;有关为何哈希顺序随机化的详细信息。除了此处提供的保证外，在任何Perl版本中，Perl哈希算法的确切详细信息和哈希遍历顺序均可能发生变化。在项的插入和删除方面，绑定的哈希行为可能与Perl的哈希有所不同。</target>
        </trans-unit>
        <trans-unit id="450c7d18d41b71db86a014ec4874cb370e9139cb" translate="yes" xml:space="preserve">
          <source>Hash keys are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">哈希键&lt;b&gt;永远不会&lt;/b&gt;被污染。</target>
        </trans-unit>
        <trans-unit id="d3bb008d092d1635eab043a4b8199104071bf333" translate="yes" xml:space="preserve">
          <source>Hash keys are strings, so you can't really use a reference as the key. When you try to do that, perl turns the reference into its stringified form (for instance, &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ). From there you can't get back the reference from the stringified form, at least without doing some extra work on your own.</source>
          <target state="translated">哈希键是字符串，因此您不能真正使用引用作为键。当您尝试执行此操作时，perl会将引用转换为它的字符串化形式（例如 &lt;code&gt;HASH(0xDEADBEEF)&lt;/code&gt; ）。从那里，您至少不能自己做一些额外的工作，就无法从字符串化形式中获取引用。</target>
        </trans-unit>
        <trans-unit id="28bd740a5fed92f4652182fc91352eb825ae6b82" translate="yes" xml:space="preserve">
          <source>Hash subscripts are similar, only instead of square brackets curly brackets are used. For example:</source>
          <target state="translated">哈希下标也是类似的,只是不用方括号,而是用大括号。例如:</target>
        </trans-unit>
        <trans-unit id="0f05d6e4a748b9c8f33a3dd349b88ed9bc020a76" translate="yes" xml:space="preserve">
          <source>Hash values do not spring into existence upon mere reference.</source>
          <target state="translated">哈希值不会因为单纯的引用而产生。</target>
        </trans-unit>
        <trans-unit id="060e2951a35019d6292c77892149e6ae4655ab4b" translate="yes" xml:space="preserve">
          <source>Hash::Util</source>
          <target state="translated">Hash::Util</target>
        </trans-unit>
        <trans-unit id="6df60ce76a6dd2245295b960eb619bae5a40a333" translate="yes" xml:space="preserve">
          <source>Hash::Util - A selection of general-utility hash subroutines</source>
          <target state="translated">Hash::Util-一个通用的哈希子程序选择。</target>
        </trans-unit>
        <trans-unit id="fc6dfd7516cd148dfcfbc9b4b53977f84b109b02" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash</source>
          <target state="translated">Hash::Util::FieldHash</target>
        </trans-unit>
        <trans-unit id="2761eb764ac1f31cb8db8bfca9f4810ccd72d904" translate="yes" xml:space="preserve">
          <source>Hash::Util::FieldHash - Support for Inside-Out Classes</source>
          <target state="translated">Hash::Util::FieldHash-支持内外类。</target>
        </trans-unit>
        <trans-unit id="5003cfd9a645097d80f1b1984336d3badcf5c150" translate="yes" xml:space="preserve">
          <source>Hashes contain pairs of scalars: the first is the key, the second is the value. The key will be coerced to a string, although the value can be any kind of scalar: string, number, or reference. If a key &lt;code&gt;$key&lt;/code&gt; is present in %hash, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; will return true. The value for a given key can be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case &lt;code&gt;$hash{$key}&lt;/code&gt; will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; will return true. This corresponds to (&lt;code&gt;$key&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) being in the hash.</source>
          <target state="translated">散列包含成对的标量：第一个是键，第二个是值。尽管值可以是任何标量：字符串，数字或引用，但键将强制为字符串。如果％hash中 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists($hash{$key})&lt;/a&gt;&lt;/code&gt; 键 &lt;code&gt;$key&lt;/code&gt; ，则exist（$ hash {$ key}）将返回true。给定键的值可以是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在这种情况下 &lt;code&gt;$hash{$key}&lt;/code&gt; 将是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,而 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $hash{$key}&lt;/code&gt; 将返回true。这对应于（ &lt;code&gt;$key&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）在哈希中。</target>
        </trans-unit>
        <trans-unit id="a5674cfb04f68937d23325c6f7c4d9203e5e6faf" translate="yes" xml:space="preserve">
          <source>Hashes have no particular internal order, though you can sort the keys and loop through them.</source>
          <target state="translated">哈希值没有特定的内部顺序,尽管你可以对键进行排序和循环。</target>
        </trans-unit>
        <trans-unit id="11a5b7f57189106155ae1686164009308c7fb48e" translate="yes" xml:space="preserve">
          <source>Hashes were the first Perl data type to be tied (see dbmopen()). A class implementing a tied hash should define the following methods: TIEHASH is the constructor. FETCH and STORE access the key and value pairs. EXISTS reports whether a key is present in the hash, and DELETE deletes one. CLEAR empties the hash by deleting all the key and value pairs. FIRSTKEY and NEXTKEY implement the keys() and each() functions to iterate over all the keys. SCALAR is triggered when the tied hash is evaluated in scalar context. UNTIE is called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens, and DESTROY is called when the tied variable is garbage collected.</source>
          <target state="translated">哈希是第一个要绑定的Perl数据类型（请参见dbmopen（））。实现绑定哈希的类应定义以下方法：TIEHASH是构造函数。 FETCH和STORE访问键和值对。 EXISTS报告哈希中是否存在密钥，DELETE删除密钥。 CLEAR通过删除所有键和值对来清空哈希。 FIRSTKEY和NEXTKEY实现keys（）和each（）函数以迭代所有键。当在标量上下文中计算绑定哈希时，将触发SCALAR。发生 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 绑时调用UNTIE ，并在对绑定变量进行垃圾回收时调用DESTROY。</target>
        </trans-unit>
        <trans-unit id="00ee967aadbfebd86b3235daf9d26b53205682c3" translate="yes" xml:space="preserve">
          <source>Hashing order and checksums</source>
          <target state="translated">散列顺序和校验和</target>
        </trans-unit>
        <trans-unit id="3f4d761db68098a751847d9083882bbf309c01a1" translate="yes" xml:space="preserve">
          <source>Hashref of .pm files and *.pl files to be installed. e.g.</source>
          <target state="translated">要安装的.pm文件和*.pl文件的Hashref,如</target>
        </trans-unit>
        <trans-unit id="e654482e1464037d016cd8389b44c8067b3f7edd" translate="yes" xml:space="preserve">
          <source>Hashref of .xs files. MakeMaker will default this. e.g.</source>
          <target state="translated">.xs文件的Hashref。MakeMaker会默认这样做,例如:。</target>
        </trans-unit>
        <trans-unit id="54306e4b7a73d064c3f0a92d38a328cc3c6fc248" translate="yes" xml:space="preserve">
          <source>Hashref of pod-containing files. MakeMaker will default this to all EXE_FILES files that include POD directives. The files listed here will be converted to man pages and installed as was requested at Configure time.</source>
          <target state="translated">包含pod的文件的Hashref。MakeMaker将默认为所有包含POD指令的EXE_FILES文件。这里列出的文件将被转换为man页,并按照配置时的要求进行安装。</target>
        </trans-unit>
        <trans-unit id="e03929c9c89c518c1a46f519dc21b0db453de58a" translate="yes" xml:space="preserve">
          <source>Hashref of symbol names for routines to be made available as universal symbols. Each key/value pair consists of the package name and an array of routine names in that package. Used only under AIX, OS/2, VMS and Win32 at present. The routine names supplied will be expanded in the same way as XSUB names are expanded by the XS() macro. Defaults to</source>
          <target state="translated">将作为通用符号提供的例程的符号名称的哈希夫。每个键/值对由软件包名称和该软件包中的例程名称数组组成。目前只在AIX、OS/2、VMS和Win32下使用。提供的例程名称将以XSUB名称被XS()宏扩展的方式进行扩展。默认值为</target>
        </trans-unit>
        <trans-unit id="0e5b1d03af67cbc5ad483521c6061ce63fe7c5e2" translate="yes" xml:space="preserve">
          <source>Hashref that assigns to *.pm and *.pod files the files into which the manpages are to be written. MakeMaker parses all *.pod and *.pm files for POD directives. Files that contain POD will be the default keys of the MAN3PODS hashref. These will then be converted to man pages during &lt;code&gt;make&lt;/code&gt; and will be installed during &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">分配给* .pm和* .pod的Hashref文件将要写入手册页的文件。MakeMaker解析所有* .pod和* .pm文件以获取POD指令。包含POD的文件将是MAN3PODS hashref的默认键。然后，这些文件将在 &lt;code&gt;make&lt;/code&gt; 期间转换为手册页，并将在 &lt;code&gt;make install&lt;/code&gt; 期间安装。</target>
        </trans-unit>
        <trans-unit id="b7c40a20db4b296ec67dfa94b908457cfde4c540" translate="yes" xml:space="preserve">
          <source>Have a .ucm file ready. You can get it from somewhere or you can write your own from scratch or you can grab one from the Encode distribution and customize it. For the UCM format, see the next Chapter. In the example below, I'll call my theoretical encoding myascii, defined in</source>
          <target state="translated">准备好一个.ucm文件。你可以从某个地方得到它,或者你可以从头开始写你自己的文件,或者你可以从Encode发行版中抓取一个文件并进行定制。关于ucm格式,请看下一章。在下面的例子中,我将把我的理论编码称为myascii,定义为</target>
        </trans-unit>
        <trans-unit id="7e1aafb3365aa620ad71622b6d9e66ff51332860" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;code&gt;look&lt;/code&gt; (!) command.</source>
          <target state="translated">看一下 &lt;code&gt;look&lt;/code&gt; （！）命令。</target>
        </trans-unit>
        <trans-unit id="8d27c15838302800e87f5a9ade00864fd9b117bc" translate="yes" xml:space="preserve">
          <source>Have a look at the CPAN::Site module.</source>
          <target state="translated">请看一下CPAN::Site模块。</target>
        </trans-unit>
        <trans-unit id="2682f428ec2cd20e9cdf6753b7db50d45fa0c287" translate="yes" xml:space="preserve">
          <source>Have you got it right?</source>
          <target state="translated">你说对了吗?</target>
        </trans-unit>
        <trans-unit id="3d1c0002422cc934d4f43ea061dac2a317b36bcc" translate="yes" xml:space="preserve">
          <source>Have you looked at CPAN (see &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;)? The chances are that someone has already written a module that can solve your problem. Have you read the appropriate manpages? Here's a brief index:</source>
          <target state="translated">您是否看过CPAN（请参阅&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;）？可能是有人已经编写了可以解决您的问题的模块。您已阅读适当的手册页吗？这是一个简短的索引：</target>
        </trans-unit>
        <trans-unit id="fea81edd1a4ca564780d9031bb647dc99cf58fa7" translate="yes" xml:space="preserve">
          <source>Having 57 modules all called Sort will not make life easy for anyone (though having 23 called Sort::Quick is only marginally better :-). Imagine someone trying to install your module alongside many others. If in any doubt ask for suggestions in comp.lang.perl.misc.</source>
          <target state="translated">有57个模块都叫Sort,不会让任何人的生活变得轻松(虽然有23个叫Sort::Quick的模块只是稍微好一点:-)。想象一下,如果有人想把你的模块和其他许多模块一起安装,那就会很麻烦。如果有任何疑问,请在comp.lang.perl.misc.中寻求建议。</target>
        </trans-unit>
        <trans-unit id="d5c3a74f90c179abbbb2a8aabfd9df58154dbdba" translate="yes" xml:space="preserve">
          <source>Having PERLDOCDEBUG set to a positive integer will make perldoc emit even more descriptive output than the &lt;code&gt;-D&lt;/code&gt; switch does; the higher the number, the more it emits.</source>
          <target state="translated">将PERLDOCDEBUG设置为正整数将使perldoc发出比 &lt;code&gt;-D&lt;/code&gt; 开关更具描述性的输出。数字越高，它发出的光越多。</target>
        </trans-unit>
        <trans-unit id="475dd7f4c80bb5dca06b4bee66ecdd1370715023" translate="yes" xml:space="preserve">
          <source>Having RSX and the latest</source>
          <target state="translated">拥有RSX和最新的</target>
        </trans-unit>
        <trans-unit id="831389895e5cb7d92cb0b30b5f20a040e5b28ad0" translate="yes" xml:space="preserve">
          <source>Having a comma after the last element of an enum list</source>
          <target state="translated">在枚举列表的最后一个元素后面加上逗号。</target>
        </trans-unit>
        <trans-unit id="eb3a777ac79c8871a640c69bcf5b76d7b538148e" translate="yes" xml:space="preserve">
          <source>Having a meaning. Perl thinks that some of the things people try to do are devoid of meaning; in particular, making use of variables that have never been given a &lt;b&gt;value&lt;/b&gt; and performing certain operations on data that isn&amp;rsquo;t there. For example, if you try to read data past the end of a file, Perl will hand you back an undefined value. See also &lt;b&gt;false&lt;/b&gt; and the &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; entry in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">有意思。Perl认为人们试图做的某些事情没有意义。特别是，利用从未被赋予&lt;b&gt;值&lt;/b&gt;的变量并对不存在的数据执行某些操作。例如，如果您尝试读取文件末尾的数据，Perl将为您提供未定义的值。另请参见&lt;b&gt;false&lt;/b&gt;和Camel第27章&amp;ldquo;函数&amp;rdquo;中的已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 条目。</target>
        </trans-unit>
        <trans-unit id="cf9f1d17b3780ae4ae6a7c92cd0343417040db2e" translate="yes" xml:space="preserve">
          <source>Having done your bit, please be prepared to wait, to be told the bug is in your code, or possibly to get no reply at all. The volunteers who maintain Perl are busy folks, so if your problem is an obvious bug in your own code, is difficult to understand or is a duplicate of an existing report, you may not receive a personal reply.</source>
          <target state="translated">在做了您的工作之后,请准备好等待,被告知错误在您的代码中,或者可能根本没有得到回复。维护Perl的志愿者们都很忙,所以如果你的问题是你自己的代码中的一个明显的bug,很难理解,或者是与现有的报告重复,你可能不会收到个人回复。</target>
        </trans-unit>
        <trans-unit id="61dfbdc92422646f02edc5b064d4a445a5156276" translate="yes" xml:space="preserve">
          <source>Having multiple DBM implementations makes it trivial to copy database formats:</source>
          <target state="translated">有了多个DBM实现,复制数据库格式就变得轻而易举了。</target>
        </trans-unit>
        <trans-unit id="0a36716594c37d5edd82c337ce9f21f289c12c13" translate="yes" xml:space="preserve">
          <source>Having pseudo-process IDs be negative integers breaks down for the integer &lt;code&gt;-1&lt;/code&gt; because the wait() and waitpid() functions treat this number as being special. The tacit assumption in the current implementation is that the system never allocates a thread ID of &lt;code&gt;1&lt;/code&gt; for user threads. A better representation for pseudo-process IDs will be implemented in future.</source>
          <target state="translated">伪进程ID为负整数会分解为整数 &lt;code&gt;-1&lt;/code&gt; ,因为wait（）和waitpid（）函数将此数字视为特殊数字。当前实现中的默认假设是系统从不为用户线程分配线程ID &lt;code&gt;1&lt;/code&gt; 。将来将实现对伪进程ID的更好表示。</target>
        </trans-unit>
        <trans-unit id="fff5183df30472b7e88394295e20e9d8990e8e07" translate="yes" xml:space="preserve">
          <source>Having read &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; you will probably have already guessed that the error is caused by the extra copy of the tied object stored in &lt;code&gt;$X&lt;/code&gt; . If you haven't, then the problem boils down to the fact that the &lt;b&gt;DB_File&lt;/b&gt; destructor, DESTROY, will not be called until</source>
          <target state="translated">阅读&lt;a href=&quot;perltie&quot;&gt;perltie之后，&lt;/a&gt;您可能已经猜到该错误是由 &lt;code&gt;$X&lt;/code&gt; 存储的附加对象的额外副本引起的。如果您还没有这样做，那么问题就归结为以下事实：直到调用&lt;b&gt;DB_File&lt;/b&gt;析构函数DESTROY，</target>
        </trans-unit>
        <trans-unit id="893bf15d4ad790d3a646d05f171a2db30641c0d1" translate="yes" xml:space="preserve">
          <source>Having threads support requires all of Perl and all of the XS modules in the Perl installation to be rebuilt; it is not just a question of adding the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module (i.e., threaded and non-threaded Perls are binary incompatible).</source>
          <target state="translated">要获得线程支持，需要重建Perl安装中的所有Perl和所有XS模块。这不仅仅是添加&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;模块的问题（即，线程和非线程Perls是二进制不兼容的）。</target>
        </trans-unit>
        <trans-unit id="123977c7eddfac195115408ec1d6b6b93c199204" translate="yes" xml:space="preserve">
          <source>Having to do with numbers represented in base 2. That means there&amp;rsquo;s basically two numbers: 0 and 1. Also used to describe a file of &amp;ldquo;nontext&amp;rdquo;, presumably because such a file makes full use of all the binary bits in its bytes. With the advent of &lt;b&gt;Unicode&lt;/b&gt;, this distinction, already suspect, loses even more of its meaning.</source>
          <target state="translated">与基数2中表示的数字有关。这意味着基本上有两个数字：0和1。还用于描述&amp;ldquo;非文本&amp;rdquo;文件，大概是因为此类文件充分利用了其字节中的所有二进制位。随着&lt;b&gt;Unicode&lt;/b&gt;的出现，这种已经被怀疑的区别甚至失去了更多的含义。</target>
        </trans-unit>
        <trans-unit id="2a50b726078402c27e07b8c0e368389163cec09c" translate="yes" xml:space="preserve">
          <source>Having to even think about the &lt;code&gt;$^S&lt;/code&gt; variable in your exception handlers is simply wrong. &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; as currently implemented invites grievous and difficult to track down errors. Avoid it and use an &lt;code&gt;END{}&lt;/code&gt; or CORE::GLOBAL::die override instead.</source>
          <target state="translated">甚至必须在异常处理程序中考虑 &lt;code&gt;$^S&lt;/code&gt; 变量是完全错误的。当前实施的 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 且难以追踪错误。避免使用它，而是使用 &lt;code&gt;END{}&lt;/code&gt; 或CORE :: GLOBAL :: die替代。</target>
        </trans-unit>
        <trans-unit id="9dd5e433024c5701e895446816548ab95da2bc1b" translate="yes" xml:space="preserve">
          <source>Hawai'ian</source>
          <target state="translated">Hawai'ian</target>
        </trans-unit>
        <trans-unit id="fec5f9830205e3861054b7879046770547986753" translate="yes" xml:space="preserve">
          <source>Head.U</source>
          <target state="translated">Head.U</target>
        </trans-unit>
        <trans-unit id="0c0e898a8ae956ef15e057a684b77851cb08216e" translate="yes" xml:space="preserve">
          <source>Head1 through head4 produce headings, head1 being the highest level. The text in the rest of this paragraph is the content of the heading. For example:</source>
          <target state="translated">头1至头4产生标题,头1为最高级别。本段其余部分的文字就是标题的内容。例如:</target>
        </trans-unit>
        <trans-unit id="967ca9215da8ba98cad45c97fab5f98884cce72e" translate="yes" xml:space="preserve">
          <source>Heading Content&quot; command or to a &quot;=item Item Content&quot; command. This specification does not specify what behavior should be in the case of a given document having several things all seeming to produce the same</source>
          <target state="translated">Heading Content &quot;命令或&quot;=item Item Content &quot;命令。本规范没有指定在给定的文档中,如果有几个东西看起来都产生相同的内容,应该采取什么行为。</target>
        </trans-unit>
        <trans-unit id="7a7c06f07a69ec449fd37c3b79a4e6409f1c6971" translate="yes" xml:space="preserve">
          <source>Hearing the word &quot;in&quot; is an</source>
          <target state="translated">听到 &quot;在 &quot;字是一个</target>
        </trans-unit>
        <trans-unit id="7801d25365100494fe3fa68254035e723fdad847" translate="yes" xml:space="preserve">
          <source>Hebrew; now it doesn't.</source>
          <target state="translated">希伯来语;现在没有了。</target>
        </trans-unit>
        <trans-unit id="84135281bd9f7278283b58aab96226bf3b6fa87a" translate="yes" xml:space="preserve">
          <source>Heed the moderators.</source>
          <target state="translated">听从主持人的安排。</target>
        </trans-unit>
        <trans-unit id="a675c00310a9bb5810f1eb379886d21c46bbc50c" translate="yes" xml:space="preserve">
          <source>Help save the world! Share your code in a form that makes it easy to reuse.</source>
          <target state="translated">帮助拯救世界! 以易于重用的形式分享您的代码。</target>
        </trans-unit>
        <trans-unit id="72b65259063cf5501bdb369bad55680bb3e05273" translate="yes" xml:space="preserve">
          <source>Help testing test modules built with Test::Builder</source>
          <target state="translated">帮助测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="b604e9e00b8aff400d6b282c4559d7681123e27e" translate="yes" xml:space="preserve">
          <source>Helper class for PerlIO layers implemented in perl</source>
          <target state="translated">用perl实现的PerlIO层的辅助类。</target>
        </trans-unit>
        <trans-unit id="4057a75cb8ff5877d986e9f1a93f90da05a4393c" translate="yes" xml:space="preserve">
          <source>Helper for grok_number(), accepts various ways of spelling &quot;infinity&quot; or &quot;not a number&quot;, and returns one of the following flag combinations:</source>
          <target state="translated">grok_number()的帮助程序,接受 &quot;infinity &quot;或 &quot;not a number &quot;的各种拼写方式,并返回以下标志组合之一。</target>
        </trans-unit>
        <trans-unit id="5d886854c3e45c23f2a67ad8886bba6332d21933" translate="yes" xml:space="preserve">
          <source>Helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant的辅助函数。</target>
        </trans-unit>
        <trans-unit id="537e8e5aa520f3bdee23b191d8b4efb107769f00" translate="yes" xml:space="preserve">
          <source>Helper routine for MM-&amp;gt;fixin(), overridden because there's no such thing as an actual shebang line that will be interpreted by the shell, so we just prepend $Config{startperl} and preserve the shebang line argument for any switches it may contain.</source>
          <target state="translated">MM-&amp;gt; fixin（）的帮助程序，已被覆盖，因为没有诸如shell会解释的实际shebang行之类的东西，因此我们只需在$ Config {startperl}前面加上shebang line参数作为它可能包含的任何开关的参数。</target>
        </trans-unit>
        <trans-unit id="754ebef25d2322da9a737d155f7bf715f1ba74eb" translate="yes" xml:space="preserve">
          <source>Helper subroutine for subdirs</source>
          <target state="translated">子目录的辅助子程序。</target>
        </trans-unit>
        <trans-unit id="8a7149426bc5c4ad71c933b4d1d21cfffd9c3bea" translate="yes" xml:space="preserve">
          <source>Helpers for POD parsing and conversion</source>
          <target state="translated">POD解析和转换的辅助工具</target>
        </trans-unit>
        <trans-unit id="a1d186be4c77271bc365d307a5b69f017e030f41" translate="yes" xml:space="preserve">
          <source>Hence the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;unimport&lt;/code&gt; routines are called at &lt;b&gt;compile time&lt;/b&gt; for the user's code.</source>
          <target state="translated">因此，在&lt;b&gt;编译时会&lt;/b&gt;为用户代码调用 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;unimport&lt;/code&gt; 导入例程。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1698c95c1d69a8153fa73a579994fee537ea27f4" translate="yes" xml:space="preserve">
          <source>Hence you derive the following simple function to abstract that. It selects a random integer between the two given integers (inclusive). For example: &lt;code&gt;random_int_between(50,120)&lt;/code&gt; .</source>
          <target state="translated">因此，您可以导出以下简单函数来抽象该函数。它在两个给定的整数（包括两个整数）之间选择一个随机整数。例如： &lt;code&gt;random_int_between(50,120)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc265d279911dd3bbb1e57f33ddb7cc94242a04f" translate="yes" xml:space="preserve">
          <source>Hence, at this point, the start of the buffer that we allocated lives at &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; in memory and the PV pointer is pointing into the middle of this allocated storage.</source>
          <target state="translated">因此，在这一点上，我们分配的缓冲区的起始位置位于内存中的 &lt;code&gt;SvPVX(sv) - SvIV(sv)&lt;/code&gt; ，PV指针指向此已分配存储的中间位置。</target>
        </trans-unit>
        <trans-unit id="045ed35d9ead65236dd53e0cae88ac0c2f700143" translate="yes" xml:space="preserve">
          <source>Hence, checking &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; is the best way to see whether something is a scalar.</source>
          <target state="translated">因此，检查 &lt;code&gt;SvTYPE(sv) &amp;lt; SVt_PVAV&lt;/code&gt; 是查看某物是否为标量的最佳方法。</target>
        </trans-unit>
        <trans-unit id="cb8da77ebcbcb4587ef2329234538c69cccafa62" translate="yes" xml:space="preserve">
          <source>Hence, on Mac OS, both</source>
          <target state="translated">因此,在Mac OS上,无论是</target>
        </trans-unit>
        <trans-unit id="28d05e677bb92a81e181eb6f8a5252850baf1f6f" translate="yes" xml:space="preserve">
          <source>Hence, putting it all together:</source>
          <target state="translated">因此,把这一切。</target>
        </trans-unit>
        <trans-unit id="78ae19820d96f656888a032f8938f666eaec4599" translate="yes" xml:space="preserve">
          <source>Hence, the aim of of a call to &lt;code&gt;extract_multiple&lt;/code&gt; in a list context is to split the processed string into as many non-overlapping fields as possible, by repeatedly applying each of the specified extractors to the remainder of the string. Thus &lt;code&gt;extract_multiple&lt;/code&gt; is a generalized form of Perl's &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">因此，在列表上下文中调用 &lt;code&gt;extract_multiple&lt;/code&gt; 的目的是通过将每个指定的提取器重复应用到字符串的其余部分，将处理后的字符串分成尽可能多的非重叠字段。因此 &lt;code&gt;extract_multiple&lt;/code&gt; 是Perl的 &lt;code&gt;&lt;a href=&quot;../functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 子例程的通用形式。</target>
        </trans-unit>
        <trans-unit id="6e76b82b230d1b216ea5fc74faa050d88bd7bb1a" translate="yes" xml:space="preserve">
          <source>Henk P. Penning maintains a site that collects data about CPAN sites:</source>
          <target state="translated">Henk P.Penning维护着一个收集CPAN网站数据的网站。</target>
        </trans-unit>
        <trans-unit id="7f6138ce4b63e599ea6c8a23a9a9d862a811b01c" translate="yes" xml:space="preserve">
          <source>Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt; - for the suggestion of creating directories recursively.</source>
          <target state="translated">Henry Gabryjelski &amp;lt;henryg@WPI.EDU&amp;gt;-关于递归创建目录的建议。</target>
        </trans-unit>
        <trans-unit id="1f2206fdca717cfb115864c58cfc1242ec1e8f30" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;$ARTICLE&lt;/code&gt; 必须是一个全局（包）标量变量-不能用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="8ff0824227f04d195446a9ca4c80c3a2f4841adc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;$ARTICLE&lt;/code&gt; must be a global (package) scalar variable - not one declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这里 &lt;code&gt;$ARTICLE&lt;/code&gt; 必须是一个全局（包）标量变量-不能用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="7adfbace1a84aad46b6dc65bb49ec212586f4854" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;--verbose&lt;/code&gt; and &lt;code&gt;--quiet&lt;/code&gt; control the same variable &lt;code&gt;$verbose&lt;/code&gt; , but with opposite values.</source>
          <target state="translated">在这里 &lt;code&gt;--verbose&lt;/code&gt; 和 &lt;code&gt;--quiet&lt;/code&gt; 控制相同的变量 &lt;code&gt;$verbose&lt;/code&gt; ，但值相反。</target>
        </trans-unit>
        <trans-unit id="869e9b788a94b86ab899941e02856974518155a7" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; create a 'tag team' handoff of the string from one regexp to the other. Regexps with an independent subexpression are much like this, with a handoff of the string to the independent subexpression, and a handoff of the string back to the enclosing regexp.</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; 和 &lt;code&gt;\G&lt;/code&gt; 在这里创建字符串的&amp;ldquo;标签组&amp;rdquo;切换，从一个正则表达式到另一个正则表达式。具有独立子表达式的正则表达式很像这样，将字符串移交给独立子表达式，然后将字符串移交给封闭的正则表达式。</target>
        </trans-unit>
        <trans-unit id="4b495cc26b10b4cfa7edd523e971b1223bc39631" translate="yes" xml:space="preserve">
          <source>Here again Perl works just like the shell in that the &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; clobbers an existing file.</source>
          <target state="translated">在这里，Perl再次像shell一样工作，因为 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 替换了现有文件。</target>
        </trans-unit>
        <trans-unit id="0b249e3305de27f4ee7d8f5a9ef3f95983593269" translate="yes" xml:space="preserve">
          <source>Here are Perl's functions (including things that look like functions, like some keywords and named operators) arranged by category. Some functions appear in more than one place.</source>
          <target state="translated">这里是Perl的函数(包括看起来像函数的东西,比如一些关键字和命名运算符),按类别排列。有些函数出现在多个地方。</target>
        </trans-unit>
        <trans-unit id="86585cb3324adc532f3c4c9a1e007eedd102a2eb" translate="yes" xml:space="preserve">
          <source>Here are a collection of (possibly) useful canned recipes for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">这里是（可能）有用罐装配方集合 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="213525a9716fa0289377679cccd7e684d87732e5" translate="yes" xml:space="preserve">
          <source>Here are a couple of possibilities:</source>
          <target state="translated">这里有几种可能性。</target>
        </trans-unit>
        <trans-unit id="de690581aef8b0c61e87b43058be3d94a077aff4" translate="yes" xml:space="preserve">
          <source>Here are a few examples to demonstrate usage of Perl's benchmarking tools.</source>
          <target state="translated">下面是几个例子来演示Perl基准测试工具的使用。</target>
        </trans-unit>
        <trans-unit id="a8331c63f719d3fa459c3be0fc4500f91a2bc542" translate="yes" xml:space="preserve">
          <source>Here are a few examples which illustrate the key concepts - as such most of them are of little practical use.</source>
          <target state="translated">这里有几个例子可以说明关键的概念------因此,它们中的大多数都没有什么实际用途。</target>
        </trans-unit>
        <trans-unit id="6d45496eb99d38ab7ab859d9d23312ec9997a265" translate="yes" xml:space="preserve">
          <source>Here are a few hints for creating high-quality patches:</source>
          <target state="translated">这里有几个创建高质量补丁的提示。</target>
        </trans-unit>
        <trans-unit id="ee5bae63f174379946589f4804bf6cb746e57ff8" translate="yes" xml:space="preserve">
          <source>Here are a few notes on the C function</source>
          <target state="translated">下面是关于C函数的一些说明</target>
        </trans-unit>
        <trans-unit id="4cf9a82c924ee686ad6e561bd6e1b0affa2a2991" translate="yes" xml:space="preserve">
          <source>Here are a few simple examples. First, let's pass in several arrays to a function and have it &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; all of then, returning a new list of all their former last elements:</source>
          <target state="translated">这里有一些简单的例子。首先，让我们将几个数组传递给一个函数，然后将其 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ，然后返回所有其前最后一个元素的新列表：</target>
        </trans-unit>
        <trans-unit id="778c5e77d32e09526eea8078cdc25093f593316e" translate="yes" xml:space="preserve">
          <source>Here are a few ways, all painful, to deal with it:</source>
          <target state="translated">这里有几个方法,都是痛苦的处理方法。</target>
        </trans-unit>
        <trans-unit id="4d368f7513a7890d1d9530618552892450a6a185" translate="yes" xml:space="preserve">
          <source>Here are a few words taken from the Berkeley DB FAQ (at</source>
          <target state="translated">以下是伯克利DB常见问题中的一些话(在</target>
        </trans-unit>
        <trans-unit id="3de0d7b44e720bda0c9a25fbb58e38764c2a5fa0" translate="yes" xml:space="preserve">
          <source>Here are examples of &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; in action:</source>
          <target state="translated">这是实际中 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="b13167d0662ec600bc247b1050d48340c5a1f9fa" translate="yes" xml:space="preserve">
          <source>Here are examples of many kinds of file opens. Those using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; all assume that you've pulled in the constants from &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;:</source>
          <target state="translated">以下是许多文件打开示例。那些使用 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的人都假定您已经从&lt;a href=&quot;fcntl&quot;&gt;Fcntl中&lt;/a&gt;提取了常量：</target>
        </trans-unit>
        <trans-unit id="1b269a27d981a83ad06f7f43ed4b5271ebb95e10" translate="yes" xml:space="preserve">
          <source>Here are examples of the constructors and the valid options available for DB_HASH, DB_BTREE and DB_RECNO respectively.</source>
          <target state="translated">下面分别是DB_HASH、DB_BTREE和DB_RECNO的构造函数和有效选项的例子。</target>
        </trans-unit>
        <trans-unit id="feffd8fe1a5cbaddbff753bfdc84e56b03609303" translate="yes" xml:space="preserve">
          <source>Here are some code samples showing a possible usage of Storable:</source>
          <target state="translated">以下是一些代码示例,展示了Storable的可能用法。</target>
        </trans-unit>
        <trans-unit id="b97373427a9280cf0da7790f9dd7dc5b0d29339d" translate="yes" xml:space="preserve">
          <source>Here are some concerns to keep in mind when using an endianness modifier:</source>
          <target state="translated">以下是使用endianness修饰语时需要注意的一些问题。</target>
        </trans-unit>
        <trans-unit id="c18e94a9efc11f05f3d5f2b6edc571204b41c5d4" translate="yes" xml:space="preserve">
          <source>Here are some examples of how that works on an ASCII platform:</source>
          <target state="translated">下面是一些在ASCII平台上如何工作的例子。</target>
        </trans-unit>
        <trans-unit id="ca06cec84a9ef5e9ca766f7b0195777a639a43ed" translate="yes" xml:space="preserve">
          <source>Here are some examples of how to use these:</source>
          <target state="translated">下面是一些如何使用这些的例子。</target>
        </trans-unit>
        <trans-unit id="84bd37d6cce9f50a387d161b1db1876dd2e66de5" translate="yes" xml:space="preserve">
          <source>Here are some examples of that:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="eb016178c05ee24cc48ff8dddc178e709d61edd0" translate="yes" xml:space="preserve">
          <source>Here are some examples of usage of the &quot;cmd&quot; shell:</source>
          <target state="translated">下面是一些使用 &quot;cmd &quot;shell的例子。</target>
        </trans-unit>
        <trans-unit id="b17211739968de398ac6cabe7b5c9c6e7b2ffe53" translate="yes" xml:space="preserve">
          <source>Here are some examples that explain the reasons why certain results occur while handling infinity:</source>
          <target state="translated">下面是一些例子,解释了为什么在处理无穷大时出现某些结果的原因。</target>
        </trans-unit>
        <trans-unit id="5a87004d684b1273adb1c5dad1a3b884a901f693" translate="yes" xml:space="preserve">
          <source>Here are some examples that you should be able to type into your command shell:</source>
          <target state="translated">下面是一些例子,你应该可以在命令壳中输入。</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="1ffece14922bda83136b1a5ca004aee395c4815b" translate="yes" xml:space="preserve">
          <source>Here are some further observations based on experiments: The C runtime breaks arguments at spaces and passes them to programs in argc/argv. Double quotes can be used to prevent arguments with spaces in them from being split up. You can put a double quote in an argument by escaping it with a backslash and enclosing the whole argument within double quotes. The backslash and the pair of double quotes surrounding the argument will be stripped by the C runtime.</source>
          <target state="translated">下面是基于实验的一些进一步的观察。C语言的运行时会在空格处拆分参数,并将它们以argc/argv的形式传递给程序。双引号可以用来防止带空格的参数被拆分。你可以在一个参数中放入双引号,用反斜杠转义,并将整个参数包围在双引号内。反斜线和参数周围的一对双引号将被C语言运行时剥离。</target>
        </trans-unit>
        <trans-unit id="0b595570315b5625b2174cdd7459401aaf7451f5" translate="yes" xml:space="preserve">
          <source>Here are some more examples; be aware that when using an explicit index, the &lt;code&gt;$&lt;/code&gt; may need escaping:</source>
          <target state="translated">这里还有一些例子。请注意，在使用显式索引时， &lt;code&gt;$&lt;/code&gt; 可能需要转义：</target>
        </trans-unit>
        <trans-unit id="c694403eaca658591930c8c7c2bb34296f84a099" translate="yes" xml:space="preserve">
          <source>Here are some notable values:</source>
          <target state="translated">以下是一些值得注意的数值。</target>
        </trans-unit>
        <trans-unit id="cc7e40e86aef57a83594c5dfdd7f8a1c23f71b5f" translate="yes" xml:space="preserve">
          <source>Here are some other examples:</source>
          <target state="translated">下面是其他一些例子。</target>
        </trans-unit>
        <trans-unit id="5552dd4aff82cc5a2b99f42ba7a6d2949d5c6e2e" translate="yes" xml:space="preserve">
          <source>Here are some other functions:</source>
          <target state="translated">下面是其他一些功能。</target>
        </trans-unit>
        <trans-unit id="79024a11d0139db04c2facf9ae0e8d93da4c05aa" translate="yes" xml:space="preserve">
          <source>Here are some other more substantive style issues to think about:</source>
          <target state="translated">这里还有一些其他更实质性的风格问题需要思考。</target>
        </trans-unit>
        <trans-unit id="8de6ff6be7dbb16b2f90d46db02214f1b31982a4" translate="yes" xml:space="preserve">
          <source>Here are some samples of syntactically valid declarations, with annotation as to how they resolve internally into &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; invocations by perl. These examples are primarily useful to see how the &quot;appropriate package&quot; is found for the possible method lookups for package-defined attributes.</source>
          <target state="translated">这是一些语法有效声明的示例，并带有注释，说明它们如何内部解析为perl的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; attributes&lt;/code&gt; 调用。这些示例主要用于查看如何找到&amp;ldquo;适当的程序包&amp;rdquo;以进行程序包定义的属性的可能方法查找。</target>
        </trans-unit>
        <trans-unit id="3ef6c8462426b25783d9f2c73bd41688e54925d5" translate="yes" xml:space="preserve">
          <source>Here are some variants, most of which don't work:</source>
          <target state="translated">这里有一些变体,大部分都不能用。</target>
        </trans-unit>
        <trans-unit id="0361977099d002d67600facecf96ac617d8167ef" translate="yes" xml:space="preserve">
          <source>Here are the current possible types, with short descriptions:</source>
          <target state="translated">以下是目前可能的类型,并有简短的说明。</target>
        </trans-unit>
        <trans-unit id="67895007dd0c6840199574bcaf648ce79505acd6" translate="yes" xml:space="preserve">
          <source>Here are the methods for the DotFiles tied hash.</source>
          <target state="translated">下面是DotFiles绑定哈希的方法。</target>
        </trans-unit>
        <trans-unit id="bdd9e497208f79834038783c1e02aab82a664f8b" translate="yes" xml:space="preserve">
          <source>Here are the methods:</source>
          <target state="translated">下面是方法。</target>
        </trans-unit>
        <trans-unit id="308b3fd3c823fd8f4a8be7a1c05819c0bdbe51b4" translate="yes" xml:space="preserve">
          <source>Here are the places where Perl will assume &lt;code&gt;$_&lt;/code&gt; even if you don't use it:</source>
          <target state="translated">这是即使您不使用Perl也会假设 &lt;code&gt;$_&lt;/code&gt; 的地方：</target>
        </trans-unit>
        <trans-unit id="0a9a64ecb96bf415307190a704ba59f675ea62cc" translate="yes" xml:space="preserve">
          <source>Here are the possible keys for the hash:</source>
          <target state="translated">以下是哈希的可能密钥。</target>
        </trans-unit>
        <trans-unit id="133a7307c88c0ca94d0fd77ce650ab97042a4831" translate="yes" xml:space="preserve">
          <source>Here are the quote-like operators that apply to pattern matching and related activities.</source>
          <target state="translated">下面是适用于模式匹配和相关活动的引号式运算符。</target>
        </trans-unit>
        <trans-unit id="c59988c08aece7bd08debf7ada77c7366bd57099" translate="yes" xml:space="preserve">
          <source>Here are the rules that are used in &lt;code&gt;catdir()&lt;/code&gt; ; note that we try to be as compatible as possible to Unix:</source>
          <target state="translated">以下是 &lt;code&gt;catdir()&lt;/code&gt; 中使用的规则；请注意，我们尝试与Unix尽可能兼容：</target>
        </trans-unit>
        <trans-unit id="4aa7fef747fea48e4e4795cd9eaeefa09930bbdb" translate="yes" xml:space="preserve">
          <source>Here are the short and long forms of the values the &lt;code&gt;General Category&lt;/code&gt; property can have:</source>
          <target state="translated">以下是&amp;ldquo; &lt;code&gt;General Category&lt;/code&gt; 属性可以具有的值的长短形式：</target>
        </trans-unit>
        <trans-unit id="420394a2a2618e29901a0ab672922a30d23423d8" translate="yes" xml:space="preserve">
          <source>Here are the statistics for Perl 5.005_62 on my system:</source>
          <target state="translated">以下是我系统中Perl 5.005_62的统计数据。</target>
        </trans-unit>
        <trans-unit id="fd03473c869638bd902e9d6b0f20d91be736706a" translate="yes" xml:space="preserve">
          <source>Here are the suggested ways of modifying your include path, including environment variables, run-time switches, and in-code statements:</source>
          <target state="translated">以下是建议的修改include路径的方法,包括环境变量、运行时开关和代码内语句。</target>
        </trans-unit>
        <trans-unit id="c09b558fc05cb8053f5a3187154e8896a601ad3a" translate="yes" xml:space="preserve">
          <source>Here are the ways that Perl knows that a string should be treated as Unicode:</source>
          <target state="translated">以下是Perl知道一个字符串应该被视为Unicode的方法。</target>
        </trans-unit>
        <trans-unit id="4358e9bb262d19ae65de17de5c9b7a341e07eea3" translate="yes" xml:space="preserve">
          <source>Here are what those parameters to the new() constructor mean:</source>
          <target state="translated">下面是new()构造函数的这些参数的含义。</target>
        </trans-unit>
        <trans-unit id="d3c80c52da3a7596fb4bd95e7f557fcc03ea2102" translate="yes" xml:space="preserve">
          <source>Here documents are found in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. Check for these three things:</source>
          <target state="translated">这里的文档可以在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;中找到。检查以下三件事：</target>
        </trans-unit>
        <trans-unit id="484c5007fac2b871f4ec1de41d18168107149ae5" translate="yes" xml:space="preserve">
          <source>Here in our DotFiles example, we'll be careful not to let them try to overwrite the file unless they've called the clobber() method on the original object reference returned by tie().</source>
          <target state="translated">在我们的DotFiles例子中,我们要注意不要让他们试图覆盖文件,除非他们调用了 tie()返回的原始对象引用的 clobber()方法。</target>
        </trans-unit>
        <trans-unit id="47c02f53e38b9b0fb6a0ae2769d47d0a5b5b6556" translate="yes" xml:space="preserve">
          <source>Here is a DBM Filter that does it:</source>
          <target state="translated">这里有一个DBM过滤器可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="f525e8a25cabfe7d14de3785ff13475d1795d58b" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine which prints whatever parameters are passed to it.</source>
          <target state="translated">这里是一个Perl子程序,它可以打印传递给它的任何参数。</target>
        </trans-unit>
        <trans-unit id="45cd387e7d7083c724152df763a18216115c4120" translate="yes" xml:space="preserve">
          <source>Here is a Perl subroutine,</source>
          <target state="translated">下面是一个Perl子程序。</target>
        </trans-unit>
        <trans-unit id="badb362bb0ad7ef4caa28ee99b671c9b8a6d2d3a" translate="yes" xml:space="preserve">
          <source>Here is a brief checklist on how to use Maketext to localize applications:</source>
          <target state="translated">下面是一份关于如何使用Maketext进行本地化应用的简要清单。</target>
        </trans-unit>
        <trans-unit id="e180555a648403b54c19cc98b95102cc9c7da450" translate="yes" xml:space="preserve">
          <source>Here is a code snippet to tell what &quot;word&quot; characters are in the current locale, in that locale's order:</source>
          <target state="translated">这里有一段代码,用来告诉你当前locale中的 &quot;word &quot;字符是什么,按照locale的顺序。</target>
        </trans-unit>
        <trans-unit id="8cd600b00d9b275c1b848cf418f2f3dc7bc149f6" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface available:</source>
          <target state="translated">下面是可用接口的定义。</target>
        </trans-unit>
        <trans-unit id="4ffd58769a04701c527d60f25ae6cee8c3577aa1" translate="yes" xml:space="preserve">
          <source>Here is a definition of the interface:</source>
          <target state="translated">下面是接口的定义。</target>
        </trans-unit>
        <trans-unit id="86773bb3e419f5d3ec6cdc84464ead386b08f646" translate="yes" xml:space="preserve">
          <source>Here is a filter which a variation of the &lt;code&gt;Joe2Jim&lt;/code&gt; filter. As well as substituting all occurrences of &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; to &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; it keeps a count of the number of substitutions made in the context object.</source>
          <target state="translated">这是 &lt;code&gt;Joe2Jim&lt;/code&gt; 过滤器的变体。除了将所有出现的 &lt;code&gt;&quot;Joe&quot;&lt;/code&gt; 替换为 &lt;code&gt;&quot;Jim&quot;&lt;/code&gt; 它还会对上下文对象中进行的替换次数进行计数。</target>
        </trans-unit>
        <trans-unit id="4d0499c68821327c798829729804b1a0bcda02ab" translate="yes" xml:space="preserve">
          <source>Here is a formula to ensurrogate a Unicode character \x{10000} and above;</source>
          <target state="translated">以下是一个公式,用于代用Unicode字符\x{10000}及以上。</target>
        </trans-unit>
        <trans-unit id="5e13ad2f9de57b9ee78127b86f1be789cace5f69" translate="yes" xml:space="preserve">
          <source>Here is a less often used example:</source>
          <target state="translated">下面是一个不太常用的例子。</target>
        </trans-unit>
        <trans-unit id="b6f9d3fd360afdcd3acc8bec172ad26a0315b6d8" translate="yes" xml:space="preserve">
          <source>Here is a list of the common features of the anonymous sub and the &lt;code&gt;filter()&lt;/code&gt; method.</source>
          <target state="translated">这是匿名子和 &lt;code&gt;filter()&lt;/code&gt; 方法的常见功能列表。</target>
        </trans-unit>
        <trans-unit id="1832b72be8a1d9f95753e5f4c415597ea4ff02d1" translate="yes" xml:space="preserve">
          <source>Here is a list of the valid options:</source>
          <target state="translated">以下是有效选项的列表。</target>
        </trans-unit>
        <trans-unit id="8914294fa8d99540ed79b9d165dee16297f1d6a9" translate="yes" xml:space="preserve">
          <source>Here is a longer example of &lt;code&gt;given&lt;/code&gt; :</source>
          <target state="translated">这是 &lt;code&gt;given&lt;/code&gt; 一个更长的例子：</target>
        </trans-unit>
        <trans-unit id="b951146917555dc2bff07eaf853fe90ebe90da08" translate="yes" xml:space="preserve">
          <source>Here is a more complete description of how &lt;code&gt;carp&lt;/code&gt; and &lt;code&gt;croak&lt;/code&gt; work. What they do is search the call-stack for a function call stack where they have not been told that there shouldn't be an error. If every call is marked safe, they give up and give a full stack backtrace instead. In other words they presume that the first likely looking potential suspect is guilty. Their rules for telling whether a call shouldn't generate errors work as follows:</source>
          <target state="translated">下面是一个更完整的说明 &lt;code&gt;carp&lt;/code&gt; 和 &lt;code&gt;croak&lt;/code&gt; 工作。他们要做的是在调用堆栈中搜索一个函数调用堆栈，在该调用堆栈中没有被告知不应有错误。如果每个呼叫都被标记为安全，则他们放弃并给出完整的堆栈回溯。换句话说，他们认为第一个可能看似潜在的嫌犯是有罪的。他们用于判断呼叫是否不应产生错误的规则如下：</target>
        </trans-unit>
        <trans-unit id="e9d5f1ad420c45c5ca7b8cd720763979928a0e80" translate="yes" xml:space="preserve">
          <source>Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;).</source>
          <target state="translated">这是一个利用上述某些方法的更完整的示例。它还直接使用API​​接口（请参阅&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API接口&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="481b0824c1ad273d7763f1ffdf818909caa88617" translate="yes" xml:space="preserve">
          <source>Here is a possible workaround: create a toplevel</source>
          <target state="translated">这里有一个可能的变通方法:创建一个toplevel的</target>
        </trans-unit>
        <trans-unit id="aac02f3544d72b59392576f2e2d1edbb502cf904" translate="yes" xml:space="preserve">
          <source>Here is a real example. Netscape 2.0 keeps a record of the locations you visit along with the time you last visited them in a DB_HASH database. This is usually stored in the file</source>
          <target state="translated">这是一个真实的例子。Netscape 2.0在DB_HASH数据库中保留了您访问的地点以及您最后访问的时间的记录。这通常存储在文件</target>
        </trans-unit>
        <trans-unit id="645c6ed6c5edc9279cd1369bce1c3b76531901ff" translate="yes" xml:space="preserve">
          <source>Here is a sample chunk of code to break up and put back together again some fixed-format input lines, in this case from the output of a normal, Berkeley-style ps:</source>
          <target state="translated">这里是一个示例代码块,用于将一些固定格式的输入行打散并重新组合在一起,在这种情况下,它来自一个普通的、Berkeley式的ps的输出。</target>
        </trans-unit>
        <trans-unit id="38eab965034c311c9ba1e3fb718a8ef1f540a4a4" translate="yes" xml:space="preserve">
          <source>Here is a script that saves, redirects, and restores &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; using various methods:</source>
          <target state="translated">这是使用各种方法保存，重定向和还原 &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 的脚本：</target>
        </trans-unit>
        <trans-unit id="bf170b2ef98b6313890763a8318d77c620c61ec2" translate="yes" xml:space="preserve">
          <source>Here is a script which uses it:</source>
          <target state="translated">下面是一个使用它的脚本。</target>
        </trans-unit>
        <trans-unit id="d109e8133d36be8ec27bcf8a10b412b1b37621e9" translate="yes" xml:space="preserve">
          <source>Here is a short breakdown of perl's operation:</source>
          <target state="translated">下面简单介绍一下perl的操作。</target>
        </trans-unit>
        <trans-unit id="b641d2582f209503d29beece571a8e6d76517863" translate="yes" xml:space="preserve">
          <source>Here is a short example which shows how &lt;code&gt;IO::Select&lt;/code&gt; could be used to write a server which communicates with several sockets while also listening for more connections on a listen socket</source>
          <target state="translated">这是一个简短的示例，显示了如何使用 &lt;code&gt;IO::Select&lt;/code&gt; 编写服务器，该服务器与多个套接字通信，同时还在侦听套接字上侦听更多连接</target>
        </trans-unit>
        <trans-unit id="f42a88335a66627a85ff6a9bee66b1f0bc358b5d" translate="yes" xml:space="preserve">
          <source>Here is a short, but incomplete summary:</source>
          <target state="translated">下面是一个简短但不完整的总结。</target>
        </trans-unit>
        <trans-unit id="120acde3518e6786e0d2c79e05b71648be345e7b" translate="yes" xml:space="preserve">
          <source>Here is a simple XSUB which illustrates the mechanics of calling both the &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; methods from C.</source>
          <target state="translated">这是一个简单的XSUB，它说明了从C 调用 &lt;code&gt;PrintID&lt;/code&gt; 和 &lt;code&gt;Display&lt;/code&gt; 方法的机制。</target>
        </trans-unit>
        <trans-unit id="fe479990bde1cedb7827b08a0b51384331185af7" translate="yes" xml:space="preserve">
          <source>Here is a simple constructor:</source>
          <target state="translated">这里有一个简单的构造函数。</target>
        </trans-unit>
        <trans-unit id="8cf9fcb79a6528df89e621ddbe45b24482b8eaf2" translate="yes" xml:space="preserve">
          <source>Here is a simple example of how to add a new target to the generated Makefile:</source>
          <target state="translated">下面是一个简单的例子,说明如何在生成的Makefile中添加一个新的目标。</target>
        </trans-unit>
        <trans-unit id="40cda83fc05639dd468f5eab757cfe3f54097a29" translate="yes" xml:space="preserve">
          <source>Here is a simple example of the technique, using the &lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash::Util::FieldHash&lt;/a&gt; core module. This module was added to the core to support inside-out object implementations.</source>
          <target state="translated">这是使用&lt;a href=&quot;hash/util/fieldhash&quot;&gt;Hash :: Util :: FieldHash&lt;/a&gt;核心模块的简单方法示例。该模块已添加到核心以支持由内而外的对象实现。</target>
        </trans-unit>
        <trans-unit id="126689dd133c61c2158a4c313ed301c9a4876c96" translate="yes" xml:space="preserve">
          <source>Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;Extra RECNO Methods&lt;/a&gt; for a workaround).</source>
          <target state="translated">这是一个使用RECNO的简单示例（如果您使用的Perl版本早于5.004_57，则此示例将不起作用- 有关解决&lt;a href=&quot;#Extra-RECNO-Methods&quot;&gt;方法&lt;/a&gt;，请参见Extra RECNO Methods）。</target>
        </trans-unit>
        <trans-unit id="319b9d58a92f86f8037b1f0bce75684db1494b7b" translate="yes" xml:space="preserve">
          <source>Here is a skeleton for the</source>
          <target state="translated">这里是一个骨架,用于</target>
        </trans-unit>
        <trans-unit id="550484c98d2783ef867d760a633e2f2132a4d47b" translate="yes" xml:space="preserve">
          <source>Here is a snippet of XSUB which defines</source>
          <target state="translated">这里是XSUB的一个片段,它定义了</target>
        </trans-unit>
        <trans-unit id="002abcfd840947931c322494ad132e91e82ebd0f" translate="yes" xml:space="preserve">
          <source>Here is a snippet of code that is loosely based on Tom Christiansen's</source>
          <target state="translated">这里是一段代码,它大致基于Tom Christiansen的</target>
        </trans-unit>
        <trans-unit id="45cde31767fc2f9538502554458696cb23085fa9" translate="yes" xml:space="preserve">
          <source>Here is a trivial XSUB which prints the context in which it is currently executing.</source>
          <target state="translated">这里有一个琐碎的XSUB,它可以打印出当前正在执行的上下文。</target>
        </trans-unit>
        <trans-unit id="10eee1483a3720a88b88f2a6e6f0dd7de0f97165" translate="yes" xml:space="preserve">
          <source>Here is a trivial example of using &lt;code&gt;deflate&lt;/code&gt; . It simply reads standard input, deflates it and writes it to standard output.</source>
          <target state="translated">这是使用 &lt;code&gt;deflate&lt;/code&gt; 的简单示例。它只是读取标准输入，将其放气并将其写入标准输出。</target>
        </trans-unit>
        <trans-unit id="1868baee762e5828998b63475228ea8991afb128" translate="yes" xml:space="preserve">
          <source>Here is a very brief example of a policy module that expires each cache item after ten seconds.</source>
          <target state="translated">下面是一个非常简单的策略模块的例子,每个缓存项目在十秒后过期。</target>
        </trans-unit>
        <trans-unit id="7f88bfdf5db7c3c03b6f8f2495da889972cfe524" translate="yes" xml:space="preserve">
          <source>Here is a very spartan uudecoder that will work on EBCDIC:</source>
          <target state="translated">这里是一个非常简陋的uudecoder,可以在EBCDIC上工作。</target>
        </trans-unit>
        <trans-unit id="d946c977086b5be12c98dcb6ff1ce5c76b228d28" translate="yes" xml:space="preserve">
          <source>Here is an efficient way to delete all files that haven't been modified for at least a week:</source>
          <target state="translated">这里有一个有效的方法,可以删除所有至少一周内没有修改的文件。</target>
        </trans-unit>
        <trans-unit id="70fccfa6b6af36450513847e29399b60a48adeac" translate="yes" xml:space="preserve">
          <source>Here is an example from big5-eten.</source>
          <target state="translated">下面是big5-eten的一个例子。</target>
        </trans-unit>
        <trans-unit id="e9c9019a4b9d1c2c747c162dad5a190290c7d35f" translate="yes" xml:space="preserve">
          <source>Here is an example of backtracking: Let's say you want to find the word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:</source>
          <target state="translated">下面是一个回溯的例子。假设你想在 &quot;食物在福桌上 &quot;这个字符串中 找到 &quot;福 &quot;后面的单词。</target>
        </trans-unit>
        <trans-unit id="ea40af6afb8d235271ee69af60576e5fd7626d85" translate="yes" xml:space="preserve">
          <source>Here is an example of how to access the option name and value from within a subroutine:</source>
          <target state="translated">下面是一个如何在子程序中访问期权名称和值的例子。</target>
        </trans-unit>
        <trans-unit id="205e5e253d5e8d9713777fb82bdd5445436cb1b6" translate="yes" xml:space="preserve">
          <source>Here is an example of how your own code can go broken:</source>
          <target state="translated">下面是一个例子,说明自己的代码怎么会坏掉。</target>
        </trans-unit>
        <trans-unit id="748768cc7486ba197e2bf8648f0ea7277ae15d72" translate="yes" xml:space="preserve">
          <source>Here is an example of the script which &quot;calculates&quot; the side of circumscribed octagon using the above package:</source>
          <target state="translated">下面是一个使用上述软件包 &quot;计算 &quot;圆周八角形边的脚本示例。</target>
        </trans-unit>
        <trans-unit id="404268aa749a8cb74398fcef4885ddfb5e393936" translate="yes" xml:space="preserve">
          <source>Here is an example of these principles in action:</source>
          <target state="translated">下面是这些原则的一个实例。</target>
        </trans-unit>
        <trans-unit id="d36af1892ac909ba4b83e53e087863bb90d56692" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;NVtime&lt;/code&gt; from C:</source>
          <target state="translated">这是从C 使用 &lt;code&gt;NVtime&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="7c9994bdad12e2f359f710fa2f6ef403d1effd52" translate="yes" xml:space="preserve">
          <source>Here is an example of using &lt;code&gt;inflate&lt;/code&gt; .</source>
          <target state="translated">这是使用 &lt;code&gt;inflate&lt;/code&gt; 的示例。</target>
        </trans-unit>
        <trans-unit id="a6e2da397e1c17983df2e6041276a4e28620f94d" translate="yes" xml:space="preserve">
          <source>Here is an example of using an optional parameter to override the default buffer size.</source>
          <target state="translated">下面是一个使用可选参数来覆盖默认缓冲区大小的例子。</target>
        </trans-unit>
        <trans-unit id="8f3c57546ccedafc9770a8f0efa81f37adc91294" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">这是一个使用 &lt;code&gt;Compress::Raw::Zlib::Deflate&lt;/code&gt; 可选参数列表来覆盖默认缓冲区大小和压缩级别的示例。所有其他选项将采用其默认值。</target>
        </trans-unit>
        <trans-unit id="87545ecf0b6e7815b60232cfb74673f436cd6fe1" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;deflateInit&lt;/code&gt; optional parameter list to override the default buffer size and compression level. All other options will take their default values.</source>
          <target state="translated">这是一个使用 &lt;code&gt;deflateInit&lt;/code&gt; 可选参数列表覆盖默认缓冲区大小和压缩级别的示例。所有其他选项将采用其默认值。</target>
        </trans-unit>
        <trans-unit id="09d05a4a26dea0db21fa2d5b84da51786c319d41" translate="yes" xml:space="preserve">
          <source>Here is an example of using the &lt;code&gt;inflateInit&lt;/code&gt; optional parameter to override the default buffer size.</source>
          <target state="translated">这是一个使用 &lt;code&gt;inflateInit&lt;/code&gt; 可选参数来覆盖默认缓冲区大小的示例。</target>
        </trans-unit>
        <trans-unit id="c7cbd7a5ef78ce531e711de3f32a263a9851ff1b" translate="yes" xml:space="preserve">
          <source>Here is an example of using the filter:</source>
          <target state="translated">下面是一个使用过滤器的例子。</target>
        </trans-unit>
        <trans-unit id="e4ff3e36580b38b61c7a227d4955c81060aeb814" translate="yes" xml:space="preserve">
          <source>Here is an example script that uses &lt;code&gt;Filter::sh&lt;/code&gt; :</source>
          <target state="translated">这是一个使用 &lt;code&gt;Filter::sh&lt;/code&gt; 的示例脚本：</target>
        </trans-unit>
        <trans-unit id="012645975f14da1f34bb102f202aaf2953a30bc6" translate="yes" xml:space="preserve">
          <source>Here is an example script which uses the interface. It implements a</source>
          <target state="translated">这里是一个使用该接口的脚本示例。它实现了一个</target>
        </trans-unit>
        <trans-unit id="1cbf7c7be1c22fad45e3015eadd538010d85816f" translate="yes" xml:space="preserve">
          <source>Here is an example that makes use of this tie:</source>
          <target state="translated">下面是一个利用这个领带的例子。</target>
        </trans-unit>
        <trans-unit id="a8ff5767311ec468cc89661ca51ca82e04f18ab9" translate="yes" xml:space="preserve">
          <source>Here is an example that renames all c files to cpp.</source>
          <target state="translated">下面是一个将所有c文件重命名为cpp的例子。</target>
        </trans-unit>
        <trans-unit id="80e0e9e4bb3140e634ddeaa722387560a0149a79" translate="yes" xml:space="preserve">
          <source>Here is an example to illustrate how the bits actually fall in place:</source>
          <target state="translated">这里举个例子来说明位子到底是如何落地的。</target>
        </trans-unit>
        <trans-unit id="d0e29b3fe9551af38ec63a152fe4f4ef139ee92e" translate="yes" xml:space="preserve">
          <source>Here is an example where a string containing blank-separated words, numbers and single dashes is to be split into its components. Using &lt;code&gt;/\s+/&lt;/code&gt; alone won't work, because spaces are not required between dashes, or a word or a dash. Additional places for a split are established by looking ahead and behind:</source>
          <target state="translated">这是一个示例，其中包含以空格分隔的单词，数字和单破折号的字符串将被拆分成多个部分。单独使用 &lt;code&gt;/\s+/&lt;/code&gt; 行不通的，因为在破折号，单词或破折号之间不需要空格。通过向前和向后看，可以建立其他拆分位置：</target>
        </trans-unit>
        <trans-unit id="4b737180e2561bd5a0699f794a8b8783a4667057" translate="yes" xml:space="preserve">
          <source>Here is an example which illustrates the problem from a &lt;b&gt;DB_File&lt;/b&gt; perspective:</source>
          <target state="translated">这是一个从&lt;b&gt;DB_File&lt;/b&gt;角度说明问题的示例：</target>
        </trans-unit>
        <trans-unit id="f644e6370d9a6fe28106ff279c08d32f76b322b7" translate="yes" xml:space="preserve">
          <source>Here is an extreme example. Consider the Fibonacci sequence, defined by the following function:</source>
          <target state="translated">下面是一个极端的例子。考虑斐波那契序列,由以下函数定义。</target>
        </trans-unit>
        <trans-unit id="87cc084321780edd34384cbc3149445fe191a094" translate="yes" xml:space="preserve">
          <source>Here is an interesting idea that doesn't involve the Debug filter. Currently Perl subroutines have fairly limited support for formal parameter lists. You can specify the number of parameters and their type, but you still have to manually take them out of the &lt;code&gt;@_&lt;/code&gt; array yourself. Write a source filter that allows you to have a named parameter list. Such a filter would turn this:</source>
          <target state="translated">这是一个有趣的想法，它不涉及&amp;ldquo;调试&amp;rdquo;过滤器。当前，Perl子例程对形式参数列表的支持相当有限。您可以指定参数的数量及其类型，但是仍然必须手动将它们从 &lt;code&gt;@_&lt;/code&gt; 数组中取出。编写一个源过滤器，使您可以拥有一个命名参数列表。这样的过滤器会变成这样：</target>
        </trans-unit>
        <trans-unit id="cdf048c5ea517c38dde03f3aa3ec4c135c3bd31b" translate="yes" xml:space="preserve">
          <source>Here is another real-life example. By default, whenever Perl writes to a DBM database it always writes the key and value as strings. So when you use this:</source>
          <target state="translated">下面是另一个真实的例子。默认情况下,每当Perl写入DBM数据库时,它总是将键和值写成字符串。所以当你使用这个。</target>
        </trans-unit>
        <trans-unit id="25d95fcca3eab15fb28653dc8409bb9ada80176a" translate="yes" xml:space="preserve">
          <source>Here is how &lt;code&gt;Encode&lt;/code&gt; handles the UTF8 flag.</source>
          <target state="translated">这是 &lt;code&gt;Encode&lt;/code&gt; 处理UTF8标志的方式。</target>
        </trans-unit>
        <trans-unit id="89e87986f55aa1d049d1fc43e956c467b865ddf7" translate="yes" xml:space="preserve">
          <source>Here is how to query the database for the &lt;b&gt;de&lt;/b&gt; (Deutsch or German) locale.</source>
          <target state="translated">以下是在数据库中查询&lt;b&gt;de&lt;/b&gt;（德语或德语）语言环境的方法。</target>
        </trans-unit>
        <trans-unit id="b74dc5032afa362c898993b212d8c65907cee21d" translate="yes" xml:space="preserve">
          <source>Here is how to use this module.</source>
          <target state="translated">下面是这个模块的使用方法。</target>
        </trans-unit>
        <trans-unit id="e417973919b13f8ed343cc33d50cf8bf18dd96fb" translate="yes" xml:space="preserve">
          <source>Here is how to write your native data out using UTF-8 (or UTF-EBCDIC) and then read it back in.</source>
          <target state="translated">下面是如何使用UTF-8(或UTF-EBCDIC)将本地数据写出来,然后再读回来。</target>
        </trans-unit>
        <trans-unit id="e23347f9a27415c41076a210002eea6fcec860f7" translate="yes" xml:space="preserve">
          <source>Here is our &lt;code&gt;File&lt;/code&gt; class using &lt;code&gt;Moose&lt;/code&gt; :</source>
          <target state="translated">这是我们使用 &lt;code&gt;Moose&lt;/code&gt; 的 &lt;code&gt;File&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="3cd300984a980fc559dc1a1ab348f5e54e30db5c" translate="yes" xml:space="preserve">
          <source>Here is same snippet of code rewritten using &lt;code&gt;globmap&lt;/code&gt;</source>
          <target state="translated">这是使用 &lt;code&gt;globmap&lt;/code&gt; 重写的同一代码段</target>
        </trans-unit>
        <trans-unit id="9d1d9e97293f2045a09f6d838c3b2ec8fb4c6f77" translate="yes" xml:space="preserve">
          <source>Here is some explanation of that format:</source>
          <target state="translated">下面是对这种格式的一些解释。</target>
        </trans-unit>
        <trans-unit id="f6967e582bf81d06472d4e74fa87d3738c79e15a" translate="yes" xml:space="preserve">
          <source>Here is the Perl subroutine</source>
          <target state="translated">下面是Perl的子程序</target>
        </trans-unit>
        <trans-unit id="c14eb5e60796cb8513e72c1a3dc8468ba095c078" translate="yes" xml:space="preserve">
          <source>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded &lt;code&gt;.&lt;/code&gt;-operator will fall back to an existing overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; . Overloaded arithmetic operators</source>
          <target state="translated">这是练习的答案：在str（）的情况下，由于重载，我们不需要显式递归 &lt;code&gt;.&lt;/code&gt; -operator将退回到现有的重载运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。重载算术运算符</target>
        </trans-unit>
        <trans-unit id="0490d051b62ee770784e189641a4237c3b3f3c05" translate="yes" xml:space="preserve">
          <source>Here is the complete Debug filter:</source>
          <target state="translated">这里是完整的Debug过滤器。</target>
        </trans-unit>
        <trans-unit id="1389bf6f29596689df97762593fe5eec3e652d54" translate="yes" xml:space="preserve">
          <source>Here is the complete list of POP macros available, along with the types they return.</source>
          <target state="translated">以下是可用的POP宏的完整列表,以及它们返回的类型。</target>
        </trans-unit>
        <trans-unit id="41758a39c9a7b172d40507117ebc8d6513b795ee" translate="yes" xml:space="preserve">
          <source>Here is the crux of the problem. A side-effect of opening the &lt;b&gt;DB_File&lt;/b&gt; database in step 2 is that an initial block from the database will get read from disk and cached in memory.</source>
          <target state="translated">这是问题的症结所在。在第2步中打开&lt;b&gt;DB_File&lt;/b&gt;数据库的副作用是，数据库的初始块将从磁盘读取并缓存在内存中。</target>
        </trans-unit>
        <trans-unit id="c51e4961cb27feed1f60a5e6765893809aef1e36" translate="yes" xml:space="preserve">
          <source>Here is the hooking interface:</source>
          <target state="translated">这里是挂钩界面。</target>
        </trans-unit>
        <trans-unit id="a16851851d330cec48f9b8e9d6adc8c31c07b46b" translate="yes" xml:space="preserve">
          <source>Here is the list of options. Some options can be in short format (-f) or long (--from) one.</source>
          <target state="translated">下面是选项列表。有些选项可以是短格式(-f)或长格式(-from)。</target>
        </trans-unit>
        <trans-unit id="59a0c7a2e7021b69e05a0894a3173e1357ec31a3" translate="yes" xml:space="preserve">
          <source>Here is the list of things which may be &quot;broken&quot; on EMX (from EMX docs):</source>
          <target state="translated">以下是EMX上可能 &quot;坏掉 &quot;的东西清单(来自EMX文档)。</target>
        </trans-unit>
        <trans-unit id="2ff240e57cd35b4f33c424da68af14cbdadb7f0a" translate="yes" xml:space="preserve">
          <source>Here is the module.</source>
          <target state="translated">这里是模块。</target>
        </trans-unit>
        <trans-unit id="1061d133b7ebfd4153ef09e5ea8f0d70a6682093" translate="yes" xml:space="preserve">
          <source>Here is the output (split into several lines):</source>
          <target state="translated">下面是输出结果(分成几行)。</target>
        </trans-unit>
        <trans-unit id="8d77260497f2dd38213b4c5d12c82639b7bb64d8" translate="yes" xml:space="preserve">
          <source>Here is the output from the code above.</source>
          <target state="translated">下面是上面代码的输出。</target>
        </trans-unit>
        <trans-unit id="afa8a8a3c0bd9e2f5b6e60996a561b236f9c8638" translate="yes" xml:space="preserve">
          <source>Here is the output from the script:</source>
          <target state="translated">下面是脚本的输出。</target>
        </trans-unit>
        <trans-unit id="3165612e15dd81d081ad2ea3bdee303a0e8cef7a" translate="yes" xml:space="preserve">
          <source>Here is the output:</source>
          <target state="translated">这是输出。</target>
        </trans-unit>
        <trans-unit id="bc7f872b555210687127240090558fcc03c8212f" translate="yes" xml:space="preserve">
          <source>Here is the relevant quote from the dbopen man page where it defines the use of the R_CURSOR flag with seq:</source>
          <target state="translated">这里是引用dbopen手册中的相关内容,它定义了使用seq.R_CURSOR标志。</target>
        </trans-unit>
        <trans-unit id="2219210520e554129a1633cb7206210581ad4e0f" translate="yes" xml:space="preserve">
          <source>Here is the sample C file:</source>
          <target state="translated">下面是C文件的示例。</target>
        </trans-unit>
        <trans-unit id="4b7d8db184d6d571b8ca9a214519cc03ef4c5e4a" translate="yes" xml:space="preserve">
          <source>Here is the script above rewritten using the &lt;code&gt;seq&lt;/code&gt; API method.</source>
          <target state="translated">这是上面使用 &lt;code&gt;seq&lt;/code&gt; API方法重写的脚本。</target>
        </trans-unit>
        <trans-unit id="2e67d178bb0da6449165979cec1cd5461e419a26" translate="yes" xml:space="preserve">
          <source>Here is the text of</source>
          <target state="translated">以下是全文</target>
        </trans-unit>
        <trans-unit id="ff1b450e27d60fd1ad40e7bb902cfa0aa22a3e80" translate="yes" xml:space="preserve">
          <source>Here is what C has that Perl doesn't:</source>
          <target state="translated">下面是C语言有的,Perl没有的。</target>
        </trans-unit>
        <trans-unit id="16fc2b68835145e65475f1bb3c3809808bf7eb3b" translate="yes" xml:space="preserve">
          <source>Here is yet another way to print your environment:</source>
          <target state="translated">下面是另一种打印环境的方法。</target>
        </trans-unit>
        <trans-unit id="0d8ed8a023e586883874c39ef49b4107598cdc9c" translate="yes" xml:space="preserve">
          <source>Here some simple examples. For the full details of the data structure and the related glob-style pattern matching, see &lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;Rules data structure in TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">这里有一些简单的例子。有关数据结构和相关的glob样式模式匹配的完整详细信息，请参见&lt;a href=&quot;parser/scheduler#Rules-data-structure&quot;&gt;TAP :: Parser :: Scheduler中的Rules数据结构&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ac9540016a9d087f8c1a19391a980dab40c0a80" translate="yes" xml:space="preserve">
          <source>Here the first call caches the list (1,2,3,4,5,6,7). The second call does not really make sense. &lt;code&gt;Memoize&lt;/code&gt; cannot guess what behavior &lt;code&gt;iota&lt;/code&gt; should have in scalar context without actually calling it in scalar context. Normally &lt;code&gt;Memoize&lt;/code&gt;</source>
          <target state="translated">在这里，第一个调用将缓存列表（1,2,3,4,5,6,7）。第二个电话真的没有意义。 &lt;code&gt;Memoize&lt;/code&gt; 无法猜测什么样的行为 &lt;code&gt;iota&lt;/code&gt; 应该在标量上下文没有在标量上下文实际调用它。通常 &lt;code&gt;Memoize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9449cd01fe2c1ad3593def47ef2650f44e48880d" translate="yes" xml:space="preserve">
          <source>Here the first line will load &lt;code&gt;Carp&lt;/code&gt;</source>
          <target state="translated">第一行将加载 &lt;code&gt;Carp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ec7a9d65cd4bf61cf8b315b7aa4990f3fbae6e4" translate="yes" xml:space="preserve">
          <source>Here the generated XS function returns nothing on success, and will die() with a meaningful error message on error.</source>
          <target state="translated">这里生成的XS函数在成功时不返回任何内容,而在出错时将会die(),并给出有意义的错误信息。</target>
        </trans-unit>
        <trans-unit id="083a79c03137ba3c061edc8bbcb5ea85ceb9fdd1" translate="yes" xml:space="preserve">
          <source>Here the multi-argument form of pipe open() is preferred because the pattern and indeed even the filenames themselves might hold metacharacters.</source>
          <target state="translated">在这里,pipe open()的多参数形式是首选,因为模式甚至文件名本身都可能包含元字符。</target>
        </trans-unit>
        <trans-unit id="84ce6346e023cfe513980b15261a23a5e8073bce" translate="yes" xml:space="preserve">
          <source>Here the number of bytes chopped off (1) is shown next as the OFFSET. The portion of the string between the &quot;real&quot; and the &quot;fake&quot; beginnings is shown in parentheses, and the values of &lt;code&gt;SvCUR&lt;/code&gt; and &lt;code&gt;SvLEN&lt;/code&gt; reflect the fake beginning, not the real one. (The first character of the string buffer happens to have changed to &quot;\1&quot; here, not &quot;1&quot;, because the current implementation stores the offset count in the string buffer. This is subject to change.)</source>
          <target state="translated">在这里，被切掉的字节数（1）接下来显示为OFFSET。括号中显示的是&amp;ldquo;真实&amp;rdquo;和&amp;ldquo;假&amp;rdquo;开头之间的字符串部分， &lt;code&gt;SvCUR&lt;/code&gt; 和 &lt;code&gt;SvLEN&lt;/code&gt; 的值反映的是假开头，而不是真实的开头。 （由于当前实现将偏移量计数存储在字符串缓冲区中，因此字符串缓冲区的第一个字符恰好已更改为&amp;ldquo; \ 1&amp;rdquo;，而不是&amp;ldquo; 1&amp;rdquo;。这可能会发生变化。）</target>
        </trans-unit>
        <trans-unit id="02f2e253f1bb4668aac3cfa34c16cf32f5c7d557" translate="yes" xml:space="preserve">
          <source>Here translator() is a subroutine which takes</source>
          <target state="translated">这里的 translator()是一个子程序,它以</target>
        </trans-unit>
        <trans-unit id="69ad459c54b1acfe7be7330c75e06154ad271928" translate="yes" xml:space="preserve">
          <source>Here we can see a much more complex program, with various optimisations in play. At regnode 10 we see an example where a character class with only one character in it was turned into an &lt;code&gt;EXACT&lt;/code&gt; node. We can also see where an entire alternation was turned into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; node. As a consequence, some of the regnodes have been marked as optimised away. We can see that the &lt;code&gt;$&lt;/code&gt; symbol has been converted into an &lt;code&gt;EOL&lt;/code&gt; regop, a special piece of code that looks for &lt;code&gt;\n&lt;/code&gt; or the end of the string.</source>
          <target state="translated">在这里，我们可以看到一个更加复杂的程序，并且在进行各种优化。在Regnode 10，我们看到一个示例，其中仅包含一个字符的字符类被转换为 &lt;code&gt;EXACT&lt;/code&gt; 节点。我们还可以看到将整个替换项转换为 &lt;code&gt;TRIE-EXACT&lt;/code&gt; 节点的位置。结果，某些regnode已被标记为已优化。我们可以看到 &lt;code&gt;$&lt;/code&gt; 符号已转换为 &lt;code&gt;EOL&lt;/code&gt; 重做，这是一段特殊代码，用于查找 &lt;code&gt;\n&lt;/code&gt; 或字符串的结尾。</target>
        </trans-unit>
        <trans-unit id="9e88298fdbd00bad0c423ba34b385ffbc4d523ec" translate="yes" xml:space="preserve">
          <source>Here we describe the internal form your code is converted to by Perl. Start with a simple example:</source>
          <target state="translated">这里我们描述一下你的代码被Perl转换为的内部形式。从一个简单的例子开始。</target>
        </trans-unit>
        <trans-unit id="c7a54d30dda627090722af6ca7619feef7f811fd" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under AmigaOS.</source>
          <target state="translated">这里我们讨论如何在AmigaOS下构建Perl。</target>
        </trans-unit>
        <trans-unit id="5a948596d25d15dea7b9635c0bba86ef5734411f" translate="yes" xml:space="preserve">
          <source>Here we discuss how to build Perl under OS/2.</source>
          <target state="translated">这里我们讨论如何在OS/2下构建Perl。</target>
        </trans-unit>
        <trans-unit id="e0ac29b536b198edfced84637724dab1c5327400" translate="yes" xml:space="preserve">
          <source>Here we document the backslash sequences that don't fall in one of the categories above. These are:</source>
          <target state="translated">在这里,我们记录了不属于上述某一类的反斜杠序列。这些序列是:</target>
        </trans-unit>
        <trans-unit id="78599b796151b0cc81f36fe73ffc3c8ea3b46215" translate="yes" xml:space="preserve">
          <source>Here we list environment variables with are either OS/2- and DOS- and Win*-specific, or are more important under OS/2 than under other OSes.</source>
          <target state="translated">这里我们列出了环境变量,这些变量要么是OS/2和DOS以及Win*特有的,要么是在OS/2下比在其他操作系统下更重要。</target>
        </trans-unit>
        <trans-unit id="2d28d2754acd9ac1365a8c90a3604a80ec81bb16" translate="yes" xml:space="preserve">
          <source>Here we list major changes which could make you by surprise.</source>
          <target state="translated">在这里,我们列出了可能让你感到意外的重大变化。</target>
        </trans-unit>
        <trans-unit id="ffa194969d86c572c4f360d304be10a58d841a2b" translate="yes" xml:space="preserve">
          <source>Here we suppose that conversion to &lt;code&gt;MyObject&lt;/code&gt; in the INPUT: section and from MyObject when processing RETVAL will modify a global variable &lt;code&gt;global_state&lt;/code&gt; . After these conversions are performed, we restore the old value of &lt;code&gt;global_state&lt;/code&gt; (to avoid memory leaks, for example).</source>
          <target state="translated">在这里，我们假设在处理RETVAL时，在INPUT：部分中从MyObject 转换为 &lt;code&gt;MyObject&lt;/code&gt; 会修改全局变量 &lt;code&gt;global_state&lt;/code&gt; 。执行完这些转换后，我们恢复了 &lt;code&gt;global_state&lt;/code&gt; 的旧值（例如，避免内存泄漏）。</target>
        </trans-unit>
        <trans-unit id="a8ed5c8e65b6eb8ae2e55830259cac345b514bb1" translate="yes" xml:space="preserve">
          <source>Here we'll create some files that will generate a test library. These will include a C source file and a header file. We'll also create a Makefile.PL in this directory. Then we'll make sure that running make at the Mytest2 level will automatically run this Makefile.PL file and the resulting Makefile.</source>
          <target state="translated">在这里,我们将创建一些文件,生成一个测试库。这些文件将包括一个C源文件和一个头文件。我们还将在这个目录下创建一个Makefile.PL。然后我们将确保在Mytest2级别运行make会自动运行这个Makefile.PL文件和生成的Makefile。</target>
        </trans-unit>
        <trans-unit id="930cec360a8de0d300404f1ae97c04e5862e5b86" translate="yes" xml:space="preserve">
          <source>Here we're using the typeglobs to do symbol table aliasing. It's a tad subtle, though, and also won't work if you're using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables, because only globals (even in disguise as &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;s) are in the symbol table.</source>
          <target state="translated">在这里，我们使用typeglobs进行符号表别名。但是，这有点微妙，如果使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 变量，它也将不起作用，因为符号表中仅包含全局变量（甚至伪装成 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5ca4ef30e473f35ac20ca9ad8e996a139eaf86fb" translate="yes" xml:space="preserve">
          <source>Here we've created a reference to an anonymous array of three elements whose final element is itself a reference to another anonymous array of three elements. (The multidimensional syntax described later can be used to access this. For example, after the above, &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; would have the value &quot;b&quot;.)</source>
          <target state="translated">在这里，我们创建了对三个元素的匿名数组的引用，其最终元素本身就是对另一个三个元素的匿名数组的引用。（可以使用稍后描述的多维语法来访问它。例如，在上述之后， &lt;code&gt;$arrayref-&amp;gt;[2][1]&lt;/code&gt; 的值将为&amp;ldquo; b&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="977db011c41d89278867b065d331c7d420016e2c" translate="yes" xml:space="preserve">
          <source>Here you see an example of Perl's system abstraction, which we'll see later: &lt;code&gt;PerlMem_malloc&lt;/code&gt; is either your system's &lt;code&gt;malloc&lt;/code&gt; , or Perl's own &lt;code&gt;malloc&lt;/code&gt; as defined in</source>
          <target state="translated">在这里，您将看到Perl系统抽象的示例，稍后我们将看到： &lt;code&gt;PerlMem_malloc&lt;/code&gt; 是系统的 &lt;code&gt;malloc&lt;/code&gt; ，或者是Perl自己的 &lt;code&gt;malloc&lt;/code&gt; ,如</target>
        </trans-unit>
        <trans-unit id="afea48b05d5e51f5f1638375ce5b0e27610663a4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a full program showing how to make use of locale-sensitive sorting, Unicode casing, and managing print widths when some of the characters take up zero or two columns, not just one column each time. When run, the following program produces this nicely aligned output:</source>
          <target state="translated">这是一个完整的程序，显示了当某些字符占用零或两列，而不是每次仅包含一列时，如何利用对区域设置敏感的排序，Unicode大小写和管理打印宽度。运行时，以下程序将生成此对齐良好的输出：</target>
        </trans-unit>
        <trans-unit id="6a19b2363612bc52e7e1f472c3c8e257075049a6" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how to implicitly manage the translation; all encoding and decoding is done automatically, just as with streams that have a particular encoding attached to them:</source>
          <target state="translated">这是隐式管理翻译的方法；所有编码和解码都是自动完成的，就像附加了特定编码的流一样：</target>
        </trans-unit>
        <trans-unit id="e1c2be9aec08f68310e7254caae4389bbea07c40" translate="yes" xml:space="preserve">
          <source>Here's &lt;code&gt;modrm&lt;/code&gt; , a little utility to cleanly remove an installed module.</source>
          <target state="translated">这是 &lt;code&gt;modrm&lt;/code&gt; ，一个实用工具，可以干净地删除已安装的模块。</target>
        </trans-unit>
        <trans-unit id="acb297651ed81fb994c8862e1324045de85e7420" translate="yes" xml:space="preserve">
          <source>Here's a UDP program similar to the sample Internet TCP client given earlier. However, instead of checking one host at a time, the UDP version will check many of them asynchronously by simulating a multicast and then using select() to do a timed-out wait for I/O. To do something similar with TCP, you'd have to use a different socket handle for each host.</source>
          <target state="translated">这里是一个类似于前面给出的Internet TCP客户端示例的UDP程序。然而,UDP版本不是一次只检查一台主机,而是通过模拟多播来异步检查多台主机,然后使用select()来做一个定时退出的I/O等待。如果要用TCP做类似的事情,你必须为每个主机使用不同的socket句柄。</target>
        </trans-unit>
        <trans-unit id="4f4b45b7c3f776b4fbc38fc3bb7e907362d3ca50" translate="yes" xml:space="preserve">
          <source>Here's a brief lead of how to upgrade the compiler to the latest level. Of course this is subject to changes. You can only upgrade versions from ftp-available updates if the first three digit groups are the same (in where you can skip intermediate unlike the patches in the developer snapshots of Perl), or to one version up where the &quot;base&quot; is available. In other words, the AIX compiler patches are cumulative.</source>
          <target state="translated">这里简单的介绍一下如何将编译器升级到最新级别。当然这是有可能改变的。你只能从ftp-available更新的版本升级,如果前三个数字组是相同的(在其中你可以跳过中间不像Perl的开发者快照中的补丁),或者升级到一个版本向上的 &quot;基础 &quot;是可用的。换句话说,AIX编译器的补丁是累积的。</target>
        </trans-unit>
        <trans-unit id="9083bbfd93bc36a0ba2fe1e425a822a01dff192a" translate="yes" xml:space="preserve">
          <source>Here's a brief recap of the options we covered:</source>
          <target state="translated">下面简单回顾一下我们所涉及的选项。</target>
        </trans-unit>
        <trans-unit id="b70c746e9664f4a89ae78b4bc44345a9debc8745" translate="yes" xml:space="preserve">
          <source>Here's a classic non-closure function-generating function:</source>
          <target state="translated">这是一个经典的非封闭函数生成函数。</target>
        </trans-unit>
        <trans-unit id="737671b9935a9677418172be58d93041b2c042de" translate="yes" xml:space="preserve">
          <source>Here's a client that creates a TCP connection to the &quot;daytime&quot; service at port 13 of the host name &quot;localhost&quot; and prints out everything that the server there cares to provide.</source>
          <target state="translated">这里有一个客户端,它在主机名 &quot;localhost &quot;的13端口创建了一个TCP连接到 &quot;daytime &quot;服务,并打印出那里的服务器关心提供的一切。</target>
        </trans-unit>
        <trans-unit id="b9872b20edef13d184c9e33e7e54f0406f2852dd" translate="yes" xml:space="preserve">
          <source>Here's a diversion: copy &quot;runperl.bat&quot; to &quot;runperl&quot;, and type &quot;runperl&quot;. Explain the observed behavior, or lack thereof. :) Hint: .gnidnats llits er'uoy fi ,&quot;lrepnur&quot; eteled :tniH</source>
          <target state="translated">这里有一个转移:将 &quot;runperl.bat &quot;复制到 &quot;runperl &quot;中,然后输入 &quot;runperl&quot;。解释一下观察到的行为,或者没有观察到。:)提示:.gnidnats llits er'uoy fi,&quot;lrepnur&quot; eteled :tniH。</target>
        </trans-unit>
        <trans-unit id="cf12c485957b201d4ea57553686d7cb0039dde88" translate="yes" xml:space="preserve">
          <source>Here's a list of the backslash sequences that are character classes. They are discussed in more detail below. (For the backslash sequences that aren't character classes, see &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.)</source>
          <target state="translated">这是字符类的反斜杠序列的列表。它们将在下面更详细地讨论。（有关不是字符类的反斜杠序列，请参见&lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5ab128180a319c2d07a98a10caf6a07254c0f651" translate="yes" xml:space="preserve">
          <source>Here's a list of the currently unsupported API, and also the version of Perl below which it is unsupported:</source>
          <target state="translated">下面是目前不支持的API的列表,也是不支持的Perl以下版本。</target>
        </trans-unit>
        <trans-unit id="33b154fc2c3c454de669961df32cf81dfe425d93" translate="yes" xml:space="preserve">
          <source>Here's a little program that generates all permutations of all the words on each line of input. The algorithm embodied in the &lt;code&gt;permute()&lt;/code&gt; function is discussed in Volume 4 (still unpublished) of Knuth's</source>
          <target state="translated">这是一个小程序，可生成输入每一行上所有单词的所有排列。 &lt;code&gt;permute()&lt;/code&gt; 函数中包含的算法在Knuth's的第4卷（尚未出版）中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="ac1edab256d838d310d923b4a7442c76a785939d" translate="yes" xml:space="preserve">
          <source>Here's a little program that's somewhat like fmt(1):</source>
          <target state="translated">这是一个有点像fmt(1)的小程序。</target>
        </trans-unit>
        <trans-unit id="fd6a03a6db0cc55634b2b495ac28f42a4ed52934" translate="yes" xml:space="preserve">
          <source>Here's a lovely Perlish solution by Larry Rosler. It exploits properties of bitwise xor on ASCII strings.</source>
          <target state="translated">这是Larry Rosler的一个可爱的Perlish解决方案。它利用了 ASCII 字符串的 bitwise xor 属性。</target>
        </trans-unit>
        <trans-unit id="c5fae574ad1367dcbd0544744e45226bb907e0c9" translate="yes" xml:space="preserve">
          <source>Here's a mailbox appender for BSD systems.</source>
          <target state="translated">这里有一个BSD系统的邮箱应用程序。</target>
        </trans-unit>
        <trans-unit id="39554d786a12cee063a370b311126f557d404cc0" translate="yes" xml:space="preserve">
          <source>Here's a more complicated example: suppose that you wanted &lt;code&gt;struct netconfig&lt;/code&gt; to be blessed into the class &lt;code&gt;Net::Config&lt;/code&gt; . One way to do this is to use underscores (_) to separate package names, as follows:</source>
          <target state="translated">这是一个更复杂的示例：假设您希望将 &lt;code&gt;struct netconfig&lt;/code&gt; 纳入类 &lt;code&gt;Net::Config&lt;/code&gt; 。一种方法是使用下划线（_）分隔软件包名称，如下所示：</target>
        </trans-unit>
        <trans-unit id="ef76926490bf6bc7991a173108bb3e76598bbc43" translate="yes" xml:space="preserve">
          <source>Here's a more extensive illustration using vec():</source>
          <target state="translated">下面是一个使用vec()的更广泛的说明。</target>
        </trans-unit>
        <trans-unit id="9b21353c7b746d6125b0bd9ccdf2d5f6e32ae7e7" translate="yes" xml:space="preserve">
          <source>Here's a more sophisticated example of using %Config:</source>
          <target state="translated">下面是一个更复杂的使用%Config的例子。</target>
        </trans-unit>
        <trans-unit id="79fc5a3fa5bc2df2e735e49c28e40c308b498181" translate="yes" xml:space="preserve">
          <source>Here's a much better web-page hit counter:</source>
          <target state="translated">这里有一个更好的网页点击计数器。</target>
        </trans-unit>
        <trans-unit id="d392ab49a010fb0ac59f9f0078cb125cae17692b" translate="yes" xml:space="preserve">
          <source>Here's a partial table of features the different packages offer:</source>
          <target state="translated">以下是不同套餐提供的部分功能表。</target>
        </trans-unit>
        <trans-unit id="41a14f9ddca1a8bfb40a30abc5c0f1b2c1f62eef" translate="yes" xml:space="preserve">
          <source>Here's a quick mapping for the utilities/modules, and their names for the $BLACKLIST, $METHOD_FAIL and other internal functions.</source>
          <target state="translated">这里是实用程序/模块的快速映射,以及它们在$BLACKLIST、$METHOD_FAIL和其他内部函数中的名称。</target>
        </trans-unit>
        <trans-unit id="cda00e934fa6376dbf363c4a7973b5685c850503" translate="yes" xml:space="preserve">
          <source>Here's a reservoir-sampling algorithm from the Camel Book:</source>
          <target state="translated">这是《骆驼记》中的一个水库取样算法。</target>
        </trans-unit>
        <trans-unit id="9e206bb004fc82d9ef3fcc3d4b1c49d6f3d42ac3" translate="yes" xml:space="preserve">
          <source>Here's a safe backtick or pipe open for read:</source>
          <target state="translated">这里有一个安全的背板或管道打开阅读。</target>
        </trans-unit>
        <trans-unit id="a7cce3c8a9d58b666d239193afb2494a20bba3a2" translate="yes" xml:space="preserve">
          <source>Here's a sample TCP client using Internet-domain sockets:</source>
          <target state="translated">下面是一个使用Internet域套接字的TCP客户端示例。</target>
        </trans-unit>
        <trans-unit id="9c9e5f5e52c5d8da22662f4567979deb732ae0a9" translate="yes" xml:space="preserve">
          <source>Here's a sample Unix-domain client:</source>
          <target state="translated">这里有一个Unix-domain客户端的例子。</target>
        </trans-unit>
        <trans-unit id="d1aee0a8129cd8627dd813843d4743d6011f0d62" translate="yes" xml:space="preserve">
          <source>Here's a sample plugin, for your reference:</source>
          <target state="translated">下面是一个示例插件,供大家参考。</target>
        </trans-unit>
        <trans-unit id="bee38889229a5c9d4ff45e0c3ab7e676e43a251f" translate="yes" xml:space="preserve">
          <source>Here's a sample program,</source>
          <target state="translated">这是一个样本程序。</target>
        </trans-unit>
        <trans-unit id="705113e6af32ce6049ec614b7bd8ea0f06bc826f" translate="yes" xml:space="preserve">
          <source>Here's a sample showing how to create and use a record whose fields are of many different sorts:</source>
          <target state="translated">下面是一个示例,展示了如何创建和使用一个字段有多种不同类型的记录。</target>
        </trans-unit>
        <trans-unit id="16fbac9b09446fb7fa1607fa6cbcd3cd579323e7" translate="yes" xml:space="preserve">
          <source>Here's a sample:</source>
          <target state="translated">这是一个样本。</target>
        </trans-unit>
        <trans-unit id="d48d2b1ee87d318b2f88933c600ad433cc38ac05" translate="yes" xml:space="preserve">
          <source>Here's a short bibliography courtesy of J&amp;uuml;rgen Christoffel:</source>
          <target state="translated">这是J&amp;uuml;rgenChristoffel提供的简短参考书目：</target>
        </trans-unit>
        <trans-unit id="7b6db8c67bc1492d1475adb966fe40db79852b40" translate="yes" xml:space="preserve">
          <source>Here's a simple client that takes a remote host to fetch a document from, and then a list of files to get from that host. This is a more interesting client than the previous one because it first sends something to the server before fetching the server's response.</source>
          <target state="translated">这是一个简单的客户端,它从远程主机上获取一个文件,然后从该主机上获取一个文件列表。这个客户端比前一个客户端更有意思,因为它先向服务器发送一些东西,然后再获取服务器的响应。</target>
        </trans-unit>
        <trans-unit id="6d6b6f3994774d06d8f1e409ff389cf7bc440169" translate="yes" xml:space="preserve">
          <source>Here's a simple example of a switch based on pattern matching, lined up in a way to make it look more like a switch statement. We'll do a multiway conditional based on the type of reference stored in $whatchamacallit:</source>
          <target state="translated">下面是一个简单的基于模式匹配的开关的例子,排队的方式让它看起来更像一个开关语句。我们将根据$whatchamacallit中存储的引用类型做一个多向条件。</target>
        </trans-unit>
        <trans-unit id="adf661fec1c7ed224422528dd69c23adb6998e67" translate="yes" xml:space="preserve">
          <source>Here's a simple example to illustrate the difference between the two range operators:</source>
          <target state="translated">这里有一个简单的例子来说明这两个范围运算符的区别。</target>
        </trans-unit>
        <trans-unit id="24f0b23833358ef065f35cfbec9242ef09ccac71" translate="yes" xml:space="preserve">
          <source>Here's a simple program which converts between Celsius and Fahrenheit, it too has a problem:</source>
          <target state="translated">这里有一个简单的程序,可以在摄氏度和华氏度之间进行转换,它也有一个问题。</target>
        </trans-unit>
        <trans-unit id="0837b2c8d138afbded4f97677c64e44b344b5f56" translate="yes" xml:space="preserve">
          <source>Here's a simple-minded example program that rewrites its command-line parameters as integers correctly formatted in the current locale:</source>
          <target state="translated">这里有一个头脑简单的示例程序,它将命令行参数改写为在当前语言环境下正确格式化的整数。</target>
        </trans-unit>
        <trans-unit id="f4b1ca0d619e6e130110c613ca994de9ad0679d7" translate="yes" xml:space="preserve">
          <source>Here's a small example showing shared memory usage.</source>
          <target state="translated">下面是一个显示共享内存使用情况的小例子。</target>
        </trans-unit>
        <trans-unit id="ca0b16455dba662fbcb02846342b83e69dabc681" translate="yes" xml:space="preserve">
          <source>Here's a summary of the possible predicates:</source>
          <target state="translated">下面是对可能的谓语的总结。</target>
        </trans-unit>
        <trans-unit id="58dc9ec13109b06fde34d79108b2ec3645eaf897" translate="yes" xml:space="preserve">
          <source>Here's a test to make sure that the data contains nothing but &quot;word&quot; characters (alphabetics, numerics, and underscores), a hyphen, an at sign, or a dot.</source>
          <target state="translated">下面是一个测试,以确保数据只包含 &quot;字 &quot;字符(字母、数字和下划线)、连字符、&quot;at &quot;号或点。</target>
        </trans-unit>
        <trans-unit id="759693dd6cb991ad225a2379fc23020ea66b9451" translate="yes" xml:space="preserve">
          <source>Here's a trick for interpolating a subroutine call into a string:</source>
          <target state="translated">这里有一个将子程序调用内插到字符串中的技巧。</target>
        </trans-unit>
        <trans-unit id="566b3956738219763456c200fc999f82ae79bed2" translate="yes" xml:space="preserve">
          <source>Here's a truly obscure example:</source>
          <target state="translated">这是一个真正晦涩的例子。</target>
        </trans-unit>
        <trans-unit id="673e00298dcf732578c132c6f7ebc33b00f2f5a5" translate="yes" xml:space="preserve">
          <source>Here's a way to do backticks reasonably safely. Notice how the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is not called with a string that the shell could expand. This is by far the best way to call something that might be subjected to shell escapes: just never call the shell at all.</source>
          <target state="translated">这是一种合理安全地进行反引号的方法。请注意，如何不使用外壳程序可以扩展的字符串来调用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。到目前为止，这是调用可能受到外壳转义符攻击的某些东西的最佳方法：根本不要调用外壳。</target>
        </trans-unit>
        <trans-unit id="eaaae86ddf2180ef145c4679eb81721d464c8d5e" translate="yes" xml:space="preserve">
          <source>Here's an even simpler example: I wrote a simple ray tracer; the program would look in a certain direction, figure out what it was looking at, and then convert the `color' value (typically a string like `red') of that object to a red, green, and blue pixel value, like this:</source>
          <target state="translated">这里有一个更简单的例子。我写了一个简单的射线跟踪器;程序会朝某个方向看,找出它正在看的东西,然后将该物体的 &quot;颜色 &quot;值(通常是像 &quot;红色 &quot;这样的字符串)转换为红色、绿色和蓝色的像素值,像这样。</target>
        </trans-unit>
        <trans-unit id="eb7f2b2a1f46da14792dc92fada7de16651b64e3" translate="yes" xml:space="preserve">
          <source>Here's an example of a module as a blessed scalar:</source>
          <target state="translated">下面是一个模块作为祝福标量的例子。</target>
        </trans-unit>
        <trans-unit id="433e4046c8d4a59acb27a1b8715b8d822849f3f4" translate="yes" xml:space="preserve">
          <source>Here's an example of a semaphore:</source>
          <target state="translated">下面是一个信号体的例子。</target>
        </trans-unit>
        <trans-unit id="e5da5564566886484e5f1909e68561f2893fc59f" translate="yes" xml:space="preserve">
          <source>Here's an example of a simple .t file for the fictional Film module.</source>
          <target state="translated">下面是一个简单的.t文件的例子,用于虚构Film模块。</target>
        </trans-unit>
        <trans-unit id="00e3c595287e645175478199893dcfbab0d3f383" translate="yes" xml:space="preserve">
          <source>Here's an example of a somewhat interesting tied hash class: it gives you a hash representing a particular user's dot files. You index into the hash with the name of the file (minus the dot) and you get back that dot file's contents. For example:</source>
          <target state="translated">这是一个有点有趣的绑定哈希类的例子:它给了你一个哈希,代表一个特定用户的点文件。你用文件名(减去点)索引到哈希中,就能得到该点文件的内容。比如说</target>
        </trans-unit>
        <trans-unit id="44172aa24b9ebcb09c3ac7dacdd0f49ad41ffcca" translate="yes" xml:space="preserve">
          <source>Here's an example of how to copy a binary file:</source>
          <target state="translated">下面是一个如何复制二进制文件的例子。</target>
        </trans-unit>
        <trans-unit id="db4ebf9573581d82c8cc95cd18272cd15b08d992" translate="yes" xml:space="preserve">
          <source>Here's an example of how to pass in a string and a regular expression for it to match against. You construct the pattern with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">这是一个如何传递字符串和正则表达式以使其匹配的示例。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运算符构造模式：</target>
        </trans-unit>
        <trans-unit id="637519bbaa8687d335368b0791bb0e149bbe34ba" translate="yes" xml:space="preserve">
          <source>Here's an example of running that program, which we'll call</source>
          <target state="translated">下面是一个运行该程序的例子,我们称之为</target>
        </trans-unit>
        <trans-unit id="f582133574110a3518036c490af80a6f46ec43be" translate="yes" xml:space="preserve">
          <source>Here's an example of setting a filehandle named &lt;code&gt;REMOTE&lt;/code&gt; to be non-blocking at the system level. You'll have to negotiate &lt;code&gt;$|&lt;/code&gt; on your own, though.</source>
          <target state="translated">这是在系统级别将名为 &lt;code&gt;REMOTE&lt;/code&gt; 的文件句柄设置为非阻塞的示例。您必须协商 &lt;code&gt;$|&lt;/code&gt; 靠你自己。</target>
        </trans-unit>
        <trans-unit id="5747af8299e3ce8766cc1e6c9250f3bd0c64b9fc" translate="yes" xml:space="preserve">
          <source>Here's an example of using open2():</source>
          <target state="translated">下面是一个使用open2()的例子。</target>
        </trans-unit>
        <trans-unit id="52ee3997caaa83f241ead3aa88bc5b3a35f1e445" translate="yes" xml:space="preserve">
          <source>Here's an example of using the &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; variable:</source>
          <target state="translated">这是使用 &lt;code&gt;$ENV{PERLDB_OPTS}&lt;/code&gt; 变量的示例：</target>
        </trans-unit>
        <trans-unit id="244af372fc1dc3d578b9e7b6c1576ec36ffa9ff8" translate="yes" xml:space="preserve">
          <source>Here's an example of what a stack backtrace via &lt;code&gt;T&lt;/code&gt; command might look like:</source>
          <target state="translated">这是一个通过 &lt;code&gt;T&lt;/code&gt; 命令进行堆栈回溯的示例：</target>
        </trans-unit>
        <trans-unit id="e488d97af419d58ca23b439a55505523edbe2e65" translate="yes" xml:space="preserve">
          <source>Here's an example of what you need for a simple module:</source>
          <target state="translated">下面是一个简单模块所需的例子。</target>
        </trans-unit>
        <trans-unit id="daccc2549e31545d57fdedfeee9273ddd1b0ff86" translate="yes" xml:space="preserve">
          <source>Here's an example script file:</source>
          <target state="translated">这里有一个例子脚本文件。</target>
        </trans-unit>
        <trans-unit id="acda0e1d4c96684fdc356f00d807ddf1f623f6ae" translate="yes" xml:space="preserve">
          <source>Here's an example that looks up nonnumeric uids in the passwd file:</source>
          <target state="translated">下面是一个在passwd文件中查找非数字ids的例子。</target>
        </trans-unit>
        <trans-unit id="5c0f7a1e07a375e4333db5cd9cca105a10ea230a" translate="yes" xml:space="preserve">
          <source>Here's an example that makes sure that whoever runs this program knows their password:</source>
          <target state="translated">这里有一个例子,可以确保运行这个程序的人知道自己的密码。</target>
        </trans-unit>
        <trans-unit id="2ba3dad78e5e2c46821c06eb650b17001a0a2ef6" translate="yes" xml:space="preserve">
          <source>Here's an example to test whether Nagle's algorithm is enabled on a socket:</source>
          <target state="translated">下面是一个测试Nagle算法是否在socket上启用的例子。</target>
        </trans-unit>
        <trans-unit id="d274e7c0c009a3ac1b895b776347d105b0d85baa" translate="yes" xml:space="preserve">
          <source>Here's an example using a recursive regular expression. The goal is to capture all of the text within angle brackets, including the text in nested angle brackets. This sample text has two &quot;major&quot; groups: a group with one level of nesting and a group with two levels of nesting. There are five total groups in angle brackets:</source>
          <target state="translated">这是一个使用递归正则表达式的例子。目标是捕获角括号内的所有文本,包括嵌套角括号内的文本。这个示例文本有两个 &quot;主要 &quot;组:一个组有一级嵌套,一个组有两级嵌套。角括号内共有五个组。</target>
        </trans-unit>
        <trans-unit id="61f04271f847d0c8988094c50219a148be404036" translate="yes" xml:space="preserve">
          <source>Here's an example.</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="ea18952ce84912806a08117b90f220eff293cf76" translate="yes" xml:space="preserve">
          <source>Here's another example of using &lt;code&gt;..&lt;/code&gt; :</source>
          <target state="translated">这是使用 &lt;code&gt;..&lt;/code&gt; 的另一个示例：</target>
        </trans-unit>
        <trans-unit id="43b272b51e8dfc98c92e4358c6ca3238363075ae" translate="yes" xml:space="preserve">
          <source>Here's another example. Let's say you'd like to match a number at the end of a string, and you also want to keep the preceding part of the match. So you write this:</source>
          <target state="translated">这里还有一个例子。比方说,你想在一个字符串的末尾匹配一个数字,同时你也想保留匹配的前面部分。所以你写下这样的内容。</target>
        </trans-unit>
        <trans-unit id="6d394fbb45cdbc9850e3f0051e919676f4c5a2f8" translate="yes" xml:space="preserve">
          <source>Here's another interesting wanted function. It will find all symbolic links that don't resolve:</source>
          <target state="translated">这里还有一个有趣的想要的功能。它可以找到所有不解析的符号链接。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
