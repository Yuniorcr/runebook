<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="05e4ad005c5681ba47d1d566b8e0cb49ffb2ad43" translate="yes" xml:space="preserve">
          <source>Also consider this valid structure:</source>
          <target state="translated">同时考虑这个有效的结构。</target>
        </trans-unit>
        <trans-unit id="a7b339961adc2d21b9a876670a45b1f1d855a3be" translate="yes" xml:space="preserve">
          <source>Also create a file mylib.c that looks like this:</source>
          <target state="translated">同时创建一个mylib.c文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c401faba028e376c88469287989685e42d637510" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt; , &lt;code&gt;longdblsize&lt;/code&gt; ): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt; .</source>
          <target state="translated">浮点数也具有字节顺序。通常（但不总是）这与整数字节序一致。即使当今大多数平台都使用IEEE 754二进制格式，也存在差异，尤其是在涉及长双精度的情况下。你可以看到 &lt;code&gt;Config&lt;/code&gt; 变量 &lt;code&gt;doublekind&lt;/code&gt; 和 &lt;code&gt;longdblkind&lt;/code&gt; （也 &lt;code&gt;doublesize&lt;/code&gt; ， &lt;code&gt;longdblsize&lt;/code&gt; ）：在&amp;ldquo;种&amp;rdquo;的值是枚举，不像 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="379626cc299d524fecb163de196b94d66c798488" translate="yes" xml:space="preserve">
          <source>Also floating point numbers have endianness. Usually (but not always) this agrees with the integer endianness. Even though most platforms these days use the IEEE 754 binary format, there are differences, especially if the long doubles are involved. You can see the &lt;code&gt;Config&lt;/code&gt; variables &lt;code&gt;doublekind&lt;/code&gt; and &lt;code&gt;longdblkind&lt;/code&gt; (also &lt;code&gt;doublesize&lt;/code&gt;, &lt;code&gt;longdblsize&lt;/code&gt;): the &quot;kind&quot; values are enums, unlike &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">浮点数也具有字节顺序。通常（但不总是）这与整数字节序一致。即使当今大多数平台都使用IEEE 754二进制格式，也存在差异，尤其是在涉及长双精度的情况下。你可以看到 &lt;code&gt;Config&lt;/code&gt; 变量 &lt;code&gt;doublekind&lt;/code&gt; 和 &lt;code&gt;longdblkind&lt;/code&gt; （也 &lt;code&gt;doublesize&lt;/code&gt; ， &lt;code&gt;longdblsize&lt;/code&gt; ）：在&amp;ldquo;种&amp;rdquo;的值是枚举，不像 &lt;code&gt;byteorder&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6a0632d09aa67f7c933563807a5dc4e1be43b5e" translate="yes" xml:space="preserve">
          <source>Also good for one-liners:</source>
          <target state="translated">也很适合单口相声。</target>
        </trans-unit>
        <trans-unit id="801a4731c98561cdcf16aa86d636dfa32a54b0ca" translate="yes" xml:space="preserve">
          <source>Also keep around the old $(SAY) macro in case somebody's using it.</source>
          <target state="translated">另外,还可以保留旧的$(SAY)宏,以防有人在使用。</target>
        </trans-unit>
        <trans-unit id="2c84ea90ff2c682d2dfed6ff8b041df2e7877e52" translate="yes" xml:space="preserve">
          <source>Also like the &quot;strict&quot; pragma, if there is more than one instance of the &lt;code&gt;warnings&lt;/code&gt; pragma in a given scope the cumulative effect is additive.</source>
          <target state="translated">就像&amp;ldquo;严格&amp;rdquo;实用指示一样，如果在给定范围内有多个 &lt;code&gt;warnings&lt;/code&gt; 实用指示实例，则累积效果是累加的。</target>
        </trans-unit>
        <trans-unit id="8b1ee43d27cd54e3a73fd0b027a7a33d6ab24281" translate="yes" xml:space="preserve">
          <source>Also make sure that you have</source>
          <target state="translated">同时确保你有</target>
        </trans-unit>
        <trans-unit id="40bb5340e74c1ea8c0aff8ce399c268adda872b8" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&quot;BUGS AND CAVEATS&quot;&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">另外，请确保阅读以下&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;&amp;ldquo;错误和注意事项&amp;rdquo;&lt;/a&gt;以了解此端口的已知限制。</target>
        </trans-unit>
        <trans-unit id="ccf329915f222131778e86ee9fd087f89f391e81" translate="yes" xml:space="preserve">
          <source>Also make sure you read &lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;BUGS AND CAVEATS&lt;/a&gt; below for the known limitations of this port.</source>
          <target state="translated">另外，请务必仔细阅读&lt;a href=&quot;#BUGS-AND-CAVEATS&quot;&gt;错误和CAVEATS&lt;/a&gt;下面这个端口的已知限制。</target>
        </trans-unit>
        <trans-unit id="fe06cc0daccf4654b8c81c8f1faee5e0b7783c69" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">在此搜索期间，也不会注意 &lt;code&gt;\c\&lt;/code&gt; （多字符控制char语法）。因此，第二 &lt;code&gt;\&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq/\c\/&lt;/a&gt;&lt;/code&gt; 被解释为的一部分 &lt;code&gt;\/&lt;/code&gt; 和下面的 &lt;code&gt;/&lt;/code&gt; 不被识别为一个定界符。而是在引用的结构末尾使用 &lt;code&gt;\034&lt;/code&gt; 或 &lt;code&gt;\x1c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4748c09ad60564220ae82641c3695fd5eb7b587" translate="yes" xml:space="preserve">
          <source>Also no attention is paid to &lt;code&gt;\c\&lt;/code&gt; (multichar control char syntax) during this search. Thus the second &lt;code&gt;\&lt;/code&gt; in &lt;code&gt;qq/\c\/&lt;/code&gt; is interpreted as a part of &lt;code&gt;\/&lt;/code&gt;, and the following &lt;code&gt;/&lt;/code&gt; is not recognized as a delimiter. Instead, use &lt;code&gt;\034&lt;/code&gt; or &lt;code&gt;\x1c&lt;/code&gt; at the end of quoted constructs.</source>
          <target state="translated">在此搜索过程中，也不会注意 &lt;code&gt;\c\&lt;/code&gt; （多字符控制char语法）。因此，第二 &lt;code&gt;\&lt;/code&gt; 在 &lt;code&gt;qq/\c\/&lt;/code&gt; 被解释为的一部分 &lt;code&gt;\/&lt;/code&gt; 和下面的 &lt;code&gt;/&lt;/code&gt; 不被识别为一个定界符。而是在引用的结构末尾使用 &lt;code&gt;\034&lt;/code&gt; 或 &lt;code&gt;\x1c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73a9b46957654b20ec65fb83845a1d68f2c4bbed" translate="yes" xml:space="preserve">
          <source>Also note that</source>
          <target state="translated">还注意到</target>
        </trans-unit>
        <trans-unit id="674fbb1e5f8c5ba4d4b18a90ede292ece92dabf5" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">另请注意， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 将命令行参数传递给&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;，不一定将它们解释为文件名。请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;了解可能的安全隐患。</target>
        </trans-unit>
        <trans-unit id="6e76aeddde8e8e63ee64b7f772d9f3c1b3f62e2a" translate="yes" xml:space="preserve">
          <source>Also note that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; passes command line arguments to &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, which doesn't necessarily interpret them as file names. See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for possible security implications.</source>
          <target state="translated">另请注意， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 将命令行参数传递给&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc中的&amp;ldquo; open&amp;rdquo;&lt;/a&gt;，这不一定会将它们解释为文件名。请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;了解可能的安全隐患。</target>
        </trans-unit>
        <trans-unit id="93e48d832329c669ef467acfbb855710b1f11c32" translate="yes" xml:space="preserve">
          <source>Also note that in order to be compatible with the shell command, &lt;code&gt;basename()&lt;/code&gt; does not strip off a suffix if it is identical to the remaining characters in the filename.</source>
          <target state="translated">还要注意，为了与shell命令兼容，如果 &lt;code&gt;basename()&lt;/code&gt; 与文件名中的其余字符相同，则不会去除后缀。</target>
        </trans-unit>
        <trans-unit id="6d4f64c4ffda1e49198c526880412a3685e89bbb" translate="yes" xml:space="preserve">
          <source>Also note that in some platforms trying to use the infinity in arithmetic operations may result in Perl crashing because using an infinity causes SIGFPE or its moral equivalent to be sent. The way to ignore this is</source>
          <target state="translated">另外需要注意的是,在某些平台上,试图在算术运算中使用无穷大,可能会导致Perl崩溃,因为使用无穷大会导致SIGFPE或其道德等价物被发送。忽略这个问题的方法是</target>
        </trans-unit>
        <trans-unit id="e93493c0471e07df3c4c3cbce58bbf69cdead50b" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">另请注意，非STD文件句柄不受影响。使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 更改这些图层。</target>
        </trans-unit>
        <trans-unit id="65a1eea4a01332917c07c49aead459f12a5fb083" translate="yes" xml:space="preserve">
          <source>Also note that non-STD file handles remain unaffected. Use &lt;code&gt;use open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; to change the layers of those.</source>
          <target state="translated">还要注意，非STD文件句柄不受影响。使用 &lt;code&gt;use open&lt;/code&gt; 或 &lt;code&gt;binmode&lt;/code&gt; 更改这些图层。</target>
        </trans-unit>
        <trans-unit id="8343e14f16aa3f23ee42ee984961cfee3da48f48" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt; , but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">还要注意，前面介绍的 &lt;code&gt;sv_set*()&lt;/code&gt; 和 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数&lt;b&gt;不会&lt;/b&gt;在目标上调用&amp;ldquo;设置&amp;rdquo;魔术。这必须由用户通过在调用这些函数之后调用 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 宏或使用 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 或 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 函数之一来完成。同样，如果通用C代码在无法处理魔术的函数中使用从外部来源获得的SV，则必须调用 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 宏以调用任何&amp;ldquo;获取&amp;rdquo;魔术。有关这些功能的说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。例如，对 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数的调用通常需要后面跟随 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; ，但由于其实现可以处理&amp;ldquo;获取&amp;rdquo;魔术，因此它们不需要预先的 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04a13d83ef82898f68f016497d3a4a1f1464818f" translate="yes" xml:space="preserve">
          <source>Also note that the &lt;code&gt;sv_set*()&lt;/code&gt; and &lt;code&gt;sv_cat*()&lt;/code&gt; functions described earlier do &lt;b&gt;not&lt;/b&gt; invoke 'set' magic on their targets. This must be done by the user either by calling the &lt;code&gt;SvSETMAGIC()&lt;/code&gt; macro after calling these functions, or by using one of the &lt;code&gt;sv_set*_mg()&lt;/code&gt; or &lt;code&gt;sv_cat*_mg()&lt;/code&gt; functions. Similarly, generic C code must call the &lt;code&gt;SvGETMAGIC()&lt;/code&gt; macro to invoke any 'get' magic if they use an SV obtained from external sources in functions that don't handle magic. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for a description of these functions. For example, calls to the &lt;code&gt;sv_cat*()&lt;/code&gt; functions typically need to be followed by &lt;code&gt;SvSETMAGIC()&lt;/code&gt;, but they don't need a prior &lt;code&gt;SvGETMAGIC()&lt;/code&gt; since their implementation handles 'get' magic.</source>
          <target state="translated">还要注意，前面描述的 &lt;code&gt;sv_set*()&lt;/code&gt; 和 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数&lt;b&gt;不会&lt;/b&gt;在其目标上调用&amp;ldquo; set&amp;rdquo;魔术。用户必须通过在调用这些函数后调用 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; 宏，或使用 &lt;code&gt;sv_set*_mg()&lt;/code&gt; 或 &lt;code&gt;sv_cat*_mg()&lt;/code&gt; 函数之一来完成此操作。同样，如果通用C代码在无法处理魔术的函数中使用从外部来源获得的SV，则必须调用 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 宏以调用任何&amp;ldquo;获取&amp;rdquo;魔术。有关这些功能的说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。例如，对 &lt;code&gt;sv_cat*()&lt;/code&gt; 函数的调用通常需要紧随其后的是 &lt;code&gt;SvSETMAGIC()&lt;/code&gt; ，但由于它们的实现可以处理&amp;ldquo;获取&amp;rdquo;魔术，因此它们不需要预先的 &lt;code&gt;SvGETMAGIC()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7be1aad912cf4ad5fcf4064cf6ab4309ca326be" translate="yes" xml:space="preserve">
          <source>Also note that the bval option only allows you to specify a single byte as a delimiter.</source>
          <target state="translated">同时注意,bval选项只允许你指定一个字节作为定界符。</target>
        </trans-unit>
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">同时注意,没有unitchcheck-blocks的值,这是因为那些是针对每个编译单元单独运行的,因此不是全局解释器阶段。这是因为这些是为每个编译单元单独运行的,因此不是全局解释器阶段。</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">还要注意，这些说明是为将模块安装到系统的Perl模块存储库中而量身定制的，但是您可以将模块安装到所需的任何目录中。例如，在我说 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 的地方，您可以替代 &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 来将模块安装到</target>
        </trans-unit>
        <trans-unit id="981eced70a1fd7e3f9ca6ea4e94af48969947ff9" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt;, you can substitute &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">还要注意，这些说明是为将模块安装到系统的Perl模块存储库中而量身定制的，但是您可以将模块安装到所需的任何目录中。例如，在我说 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 的地方，您可以替代 &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; 来将模块安装到</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">另外要注意的是,并不是所有的配置都能使用,已知64位版本的GCC会失效。</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">另外需要注意的是,在目前的实现下,共享变量使用的内存要比普通变量多一些,速度也要慢一些。</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">另外要注意的是,在不同的编译器中,枚举是否可以隐式地变形为ints是不同的,你可能需要(int)。</target>
        </trans-unit>
        <trans-unit id="3fe91d0953fd134d385ab62185c6773cb118c04f" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt;), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt;), or for any cryptographic applications.</source>
          <target state="translated">还要注意，尽管散列元素的顺序可能是随机的，但这种&amp;ldquo;伪顺序&amp;rdquo;&lt;b&gt;不&lt;/b&gt;应该用于像随机对 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 为此，请使用List :: Util :: shuffle（），请参见&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;，自Perl 5.8.0起的标准核心模块；或CPAN模块 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ），或用于生成置换（例如使用CPAN模块 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 或 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ），或用于任何加密应用程序。</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">还要注意，尽管散列元素的顺序可能是随机的，但这种&amp;ldquo;伪顺序&amp;rdquo; &lt;b&gt;不&lt;/b&gt;应该用于随机混排列表之类的应用 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 为此，请使用List :: Util :: shuffle（），请参见&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;，自Perl 5.8.0起的标准核心模块；或CPAN模块 &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ），或用于生成置换（例如使用CPAN模块 &lt;code&gt;Algorithm::Permute&lt;/code&gt; 或 &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ），或用于任何加密应用程序。</target>
        </trans-unit>
        <trans-unit id="1cc898b24b5934f9ecf52c4f2514750c1a887e03" translate="yes" xml:space="preserve">
          <source>Also note that you should set the &lt;code&gt;Efs&lt;/code&gt; option to true if you are working with UTF8 filenames.</source>
          <target state="translated">另请注意，如果要使用UTF8文件名，则应将 &lt;code&gt;Efs&lt;/code&gt; 选项设置为true。</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">还要注意，对于本地文件系统上的超级用户， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 测试始终返回1，如果在模式下设置了执行位，则 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 返回1。因此，由超级用户运行的脚本可能需要执行stat（）以确定文件的实际模式，或将其有效uid临时设置为其他内容。</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">还要注意，对于本地文件系统上的超级用户， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 测试始终返回1，如果在模式下设置了执行位，则 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 返回1。因此，由超级用户运行的脚本可能需要执行stat（）以确定文件的实际模式，或将其有效uid临时设置为其他内容。</target>
        </trans-unit>
        <trans-unit id="4c12857d50953ae8911fef9be5deb3cb6261b630" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">还要注意，对于本地文件系统上的超级用户， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 测试始终返回1，如果在模式下设置了执行位，则 &lt;code&gt;-x&lt;/code&gt; 和 &lt;code&gt;-X&lt;/code&gt; 返回1。因此，由超级用户运行的脚本可能需要执行&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;以确定文件的实际模式，或将其有效uid临时设置为其他内容。</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">还注意到:</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">还要注意，因为所有ASCII字符都是UTF-8不变的（意味着无论是否用UTF-8编码，它们都具有完全相同的表示形式（总是一个字节））， &lt;code&gt;isASCII&lt;/code&gt; 当以任意字节中的任何字节进行调用时，isASCII将给出正确的结果是否以UTF-8编码的字符串。同样， &lt;code&gt;isASCII_utf8&lt;/code&gt; 可以在UTF-8中编码或不编码的任何字符串上正常工作。</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">同时注意到,无论你传递给perl_parse()什么参数,PERL_SYS_INIT3()都必须在C语言的main()argc、argv和env上被调用,而且只能调用一次。</target>
        </trans-unit>
        <trans-unit id="84e807ea22d37e9fcac5bf336f329420c5d937c0" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;a href=&quot;File::Basename&quot;&gt;&lt;code&gt;File::Basename&lt;/code&gt;&lt;/a&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">标准发行版中的&lt;a href=&quot;File::Basename&quot;&gt; &lt;code&gt;File::Basename&lt;/code&gt; &lt;/a&gt;也可以使用，它将路径名分为几部分（基本文件名，目录的完整路径和文件后缀）。</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">标准发行版中的 &lt;code&gt;File::Basename&lt;/code&gt; 也可以使用，它将路径名分为几部分（基本文件名，目录的完整路径和文件后缀）。</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 构造，子例程和方法调用以及匿名构造函数 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 也被解析为术语。</target>
        </trans-unit>
        <trans-unit id="76e4187069aa3cdfe5b15fb66a75e8d762b8a3c7" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;do {}&lt;/code&gt; and &lt;code&gt;eval {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;do {}&lt;/code&gt; 和 &lt;code&gt;eval {}&lt;/code&gt; 构造，子例程和方法调用以及匿名构造函数 &lt;code&gt;[]&lt;/code&gt; 和 &lt;code&gt;{}&lt;/code&gt; 也被解析为术语。</target>
        </trans-unit>
        <trans-unit id="4ab49029f03642de1877e97fc5e4ccdaa8f4d8b8" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot;&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">另请阅读上面的&lt;a href=&quot;#DESCRIPTION&quot;&gt;&amp;ldquo;说明&amp;rdquo;&lt;/a&gt;部分，以了解 &lt;code&gt;Carp&lt;/code&gt; 如何确定从何处报告错误。</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">另请阅读上面的&lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt;部分，有关 &lt;code&gt;Carp&lt;/code&gt; 如何确定从何处报告错误。</target>
        </trans-unit>
        <trans-unit id="6e8426be1042a9c74b01dabfc6cf09d489acf3c6" translate="yes" xml:space="preserve">
          <source>Also referred to as &quot;Dotted-Integer&quot;, these contains more than one decimal point and may have an optional embedded underscore, see &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt;. This is what is commonly used in most open source software as the &quot;external&quot; version (the one used as part of the tag or tarfile name). A leading 'v' character is now required and will warn if it missing.</source>
          <target state="translated">也称为&amp;ldquo;点分整数&amp;rdquo;，它们包含多个小数点，并且可能具有可选的嵌入式下划线，请参见&lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&amp;ldquo;点分十进制版本&amp;rdquo;&lt;/a&gt;。这是大多数开源软件中通常使用的&amp;ldquo;外部&amp;rdquo;版本（用作标记或tarfile名称的一部分）的版本。现在需要一个前置的&amp;ldquo; v&amp;rdquo;字符，如果缺少该字符，则会发出警告。</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">还请记住，&amp;ldquo; |&amp;rdquo; 被解释为方括号内的文字，因此，如果您编写 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; ，则实际上只匹配 &lt;code&gt;[feio|]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">还请记住，C不允许您安全地说 &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; 。它可能与您的编译器一起使用，但不适用于所有人。将这种语句分解为单独的任务：</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">还请记住， &lt;code&gt;%p&lt;/code&gt; 格式确实确实需要一个void指针：</target>
        </trans-unit>
        <trans-unit id="d484e6b6d31da17dc2ff01d2d2dda31cda9e2d99" translate="yes" xml:space="preserve">
          <source>Also remember: If the META file contains a provides field, you shouldn't be indexing anything in the first place - just use that.</source>
          <target state="translated">另外,请记住:如果META文件中包含一个provides字段,你首先就不应该索引任何东西--只需要使用它。</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;或&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f380eae13c59641be526fa28a59640fd146bd59e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">另请参见&lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc&lt;/a&gt;或&lt;a href=&quot;perlopentut&quot;&gt;perlopentut中的&lt;/a&gt;&amp;ldquo; binmode&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b821601b2c44fa646b454cc4c61309ada267db9f" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--lquote&lt;/b&gt; and &lt;b&gt;--rquote&lt;/b&gt; options, which can be used to set the left and right quotes independently. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">另请参见&lt;b&gt;--lquote&lt;/b&gt;和&lt;b&gt;--rquote&lt;/b&gt;选项，这些选项可用于分别设置左引号和右引号。如果同时设置了&lt;b&gt;--quotes&lt;/b&gt;和其他选项之一，则&lt;b&gt;--lquote&lt;/b&gt;或&lt;b&gt;--rquote&lt;/b&gt;会覆盖&lt;b&gt;--quotes&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="124ca3ad4251372cd630b0c4f1d026a6e1bb631a" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--quotes&lt;/b&gt; option, which can be used to set both quotes at once. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">另请参见&lt;b&gt;--quotes&lt;/b&gt;选项，该选项可用于同时设置两个引号。如果同时设置了&lt;b&gt;--quotes&lt;/b&gt;和其他选项之一，则&lt;b&gt;--lquote&lt;/b&gt;或&lt;b&gt;--rquote&lt;/b&gt;会覆盖&lt;b&gt;--quotes&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="14f14f1236967cfa8b858394733973952439e548" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;lquote&lt;/code&gt; and &lt;code&gt;rquote&lt;/code&gt; options, which can be used to set the left and right quotes independently. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;lquote&lt;/code&gt; 和 &lt;code&gt;rquote&lt;/code&gt; 选项，这些选项可用于分别设置左引号和右引号。如果同时设置了 &lt;code&gt;quotes&lt;/code&gt; 和其他选项之一，则 &lt;code&gt;lquote&lt;/code&gt; 或 &lt;code&gt;rquote&lt;/code&gt; 会覆盖 &lt;code&gt;quotes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43f69db8fdd0609b53e771f0c648e36f1cca6c0" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;quotes&lt;/code&gt; option, which can be used to set both quotes at once. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">另请参见 &lt;code&gt;quotes&lt;/code&gt; 选项，该选项可用于同时设置两个引号。如果同时设置了 &lt;code&gt;quotes&lt;/code&gt; 和其他选项之一，则 &lt;code&gt;lquote&lt;/code&gt; 或 &lt;code&gt;rquote&lt;/code&gt; 会覆盖 &lt;code&gt;quotes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">另见:</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">同样从v5.8.1开始，将 &lt;code&gt;DATA&lt;/code&gt; 伪文件句柄从编码转换为UTF-8。</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">还要仔细研究&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;，以避免对操作系统，文件系统，字符集等做出任何错误假设。</target>
        </trans-unit>
        <trans-unit id="2e87f20f7d97b568a4954fba96e48f292ed18abb" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;, which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;use v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">当超出&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt;的范围之外时，对非UTF-8字符串的引用也保持不变，该功能将引用Latin1范围内的所有字符。这为不使用Unicode的旧程序提供了完全的向后兼容性。（请注意， &lt;code&gt;unicode_strings&lt;/code&gt; 自动一个的范围内，使能 &lt;code&gt;use v5.12&lt;/code&gt; 或更大。）</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">当超出 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 的范围之外时，对非UTF-8字符串的引用也保持不变，该功能将引用Latin1较高范围内的所有字符。这为不使用Unicode的旧程序提供了完全的向后兼容性。（请注意， &lt;code&gt;unicode_strings&lt;/code&gt; 自动一个的范围内，使能 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或更大。）</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">当超出 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 的范围之外时，对非UTF-8字符串的引用也保持不变，该功能将引用Latin1较高范围内的所有字符。这为不使用Unicode的旧程序提供了完全的向后兼容性。（请注意， &lt;code&gt;unicode_strings&lt;/code&gt; 自动一个的范围内，使能 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或更大。）</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">也不同于 &lt;code&gt;fileparse()&lt;/code&gt; ， &lt;code&gt;dirname()&lt;/code&gt; 在其返回的路径上不包含尾部斜杠。</target>
        </trans-unit>
        <trans-unit id="26303c82ac6b3a7fa556573e39f86a09e33051c1" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt;, &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">也不同于 &lt;code&gt;fileparse()&lt;/code&gt; ， &lt;code&gt;dirname()&lt;/code&gt; 在其返回的路径上不包含尾部斜杠。</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">另外,在VMS上处理Perl程序时,如果你需要一个特定操作系统格式的语法,那么你需要检查相应的DECC$特征逻辑,或者调用一个转换例程来强制转换成该格式。</target>
        </trans-unit>
        <trans-unit id="5fc47794ba1a865aaaa0f149000e05b513e4f015" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&quot;AVs, HVs and undefined values&quot;&lt;/a&gt;).</source>
          <target state="translated">另外，将 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 用作AV或HV中的值时，也必须小心（请参阅&lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&amp;ldquo; AV，HV和未定义的值&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">另外，在AV或HV &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 用作值时，请务必小心（请参阅&lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV，HV和未定义的值&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">另外，&lt;b&gt;在Perl 5.8.x及更早版本中&lt;/b&gt;，此杂注使用伪哈希，其结果是，只要具有通过适当类型变量访问的命名字段，就可以使对象具有紧凑而又快速的数组访问。</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">同样， &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 产生 &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 代表任何</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">同样，可以通过 &lt;code&gt;/i&lt;/code&gt; 修饰符在正则表达式， &lt;code&gt;\F&lt;/code&gt; 音译转义符和 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 运算符中访问Case_Folding 。</target>
        </trans-unit>
        <trans-unit id="d028de5400e80b7bddfc22d550144658f5c96f35" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">同样，可以通过 &lt;code&gt;/i&lt;/code&gt; 修饰符在正则表达式， &lt;code&gt;\F&lt;/code&gt; 音译转义符和 &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 运算符中访问Case_Folding 。</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">另外,配置可能会以</target>
        </trans-unit>
        <trans-unit id="dbf6f9732bd6d02a3c14e683c3aa4b4c3c151f41" translate="yes" xml:space="preserve">
          <source>Also, a &lt;code&gt;&quot;r&quot;&lt;/code&gt; and/or &lt;code&gt;&quot;w&quot;&lt;/code&gt; in &lt;code&gt;$sMode&lt;/code&gt; is used to decide how the file descriptor is converted into a Perl file handle, even though this doesn't appear to make a difference. One of the following is used:</source>
          <target state="translated">此外， &lt;code&gt;&quot;r&quot;&lt;/code&gt; 和/或 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 在 &lt;code&gt;$sMode&lt;/code&gt; 用于决定文件描述符是如何转变成一个Perl文件句柄，尽管这似乎不有所作为。使用以下之一：</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">另外,反斜杠后面的两个或三个八进制数字也被认为是一个八进制数字。</target>
        </trans-unit>
        <trans-unit id="931d2aa4d5ca7dba171a5dba8982f8a76fb7815e" translate="yes" xml:space="preserve">
          <source>Also, as of Perl 5.30, delimiters which are unassigned code points but that may someday become assigned are prohibited. Otherwise, code that works today would fail to compile if the currently unassigned delimiter ends up being something that isn't a stand-alone grapheme. Because Unicode is never going to assign &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;non-character code points&lt;/a&gt;, nor &lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;code points that are above the legal Unicode maximum&lt;/a&gt;, those can be delimiters.</source>
          <target state="translated">同样，从Perl 5.30开始，禁止使用未分配的代码点但有一天可能会被分配的定界符。否则，如果当前未分配的定界符最终不是独立的字素，那么今天可以工作的代码将无法编译。因为Unicode永远不会分配&lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;非字符代码点&lt;/a&gt;，也不会分配&lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;超出合法Unicode最大值的代码点，所以&lt;/a&gt;它们可以是定界符。</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">同样，这两种方法当前都只允许命名单个字符。要命名字符序列，请使用&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;自定义翻译器&lt;/a&gt;（如下所述）。</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">同样，调用＆$ coderef（$ lh，... parameters ...）可以引发任何形式的异常（例如，如果该子级中的代码试图除以零）。但是，当您有用括号括起来的文字说要调用方法&amp;ldquo; foo&amp;rdquo;时，会发生一个非常常见的异常，但是没有这样的方法。 （例如，&amp;ldquo;您有[qua &lt;b&gt;tn&lt;/b&gt;，_1，ball]。&amp;rdquo;将在尝试调用$ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt;（$ _ [1]，'ball' 时引发异常）-您大概是指&amp;ldquo; quant&amp;rdquo;。 ） &lt;code&gt;maketext&lt;/code&gt; 捕获这些异常，但只是使错误消息更具可读性，这时它将抛出异常。</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">此外,像这样的条目</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">另外,每个使用Perl的C程序都必须在</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">另外,可以自由发挥实验功能。运行</target>
        </trans-unit>
        <trans-unit id="efa6c1b4904cf64e5362ea949feda8f167d890cd" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;Unicode Properties&quot;&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{ID_Continue}&lt;/code&gt;, &lt;code&gt;\p{XID_Start}&lt;/code&gt;, and &lt;code&gt;\p{XID_Continue}&lt;/code&gt;. See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">另外，对于在ASCII范围之外的编程语言标识符中的一组较细粒度​​的字符，您可能希望使用更自定义的&lt;a href=&quot;#Unicode-Properties&quot;&gt;&amp;ldquo; Unicode属性&amp;rdquo;&lt;/a&gt;， &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{ID_Continue}&lt;/code&gt; ， &lt;code&gt;\p{XID_Start}&lt;/code&gt; 和 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。参见&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42d6c8f0dc944343373b062a14aaa3e489bc7463" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;Unicode Properties&quot;&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{ID_Continue}&lt;/code&gt;, &lt;code&gt;\p{XID_Start}&lt;/code&gt;, and &lt;code&gt;\p{XID_Continue}&lt;/code&gt;. See &lt;a href=&quot;https://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">另外，对于在ASCII范围之外的编程语言标识符中的一组较细粒度​​的字符，您可能希望使用更自定义的&lt;a href=&quot;#Unicode-Properties&quot;&gt;&amp;ldquo; Unicode属性&amp;rdquo;&lt;/a&gt;， &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{ID_Continue}&lt;/code&gt; ， &lt;code&gt;\p{XID_Start}&lt;/code&gt; 和 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。参见&lt;a href=&quot;https://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">另外，对于超出ASCII范围的编程语言标识符中的一组较细粒度​​的字符，您可能希望使用更自定义的&lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode属性&lt;/a&gt;， &lt;code&gt;\p{ID_Start}&lt;/code&gt; ， &lt;code&gt;\p{ID_Continue}&lt;/code&gt; ， &lt;code&gt;\p{XID_Start}&lt;/code&gt; 和 &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。参见&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">另外,如果你设置了一个_AUTO词典,那么将有效值作为键就变得非常有用。_AUTO词典将在后面的章节中讨论。</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">另外，如果传递给 &lt;code&gt;mg_find&lt;/code&gt; 或 &lt;code&gt;mg_findext&lt;/code&gt; 的SV 不是SVt_PVMG类型，则Perl可能会进行核心转储。</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">同样，在二进制属性中，&amp;ldquo; Yes&amp;rdquo;，&amp;ldquo; T&amp;rdquo;和&amp;ldquo; True&amp;rdquo;都是&amp;ldquo; Y&amp;rdquo;的同义词。 &amp;ldquo;否&amp;rdquo;，&amp;ldquo; F&amp;rdquo;和&amp;ldquo;假&amp;rdquo;都是&amp;ldquo; N&amp;rdquo;的同义词。该表显示了&amp;ldquo; Y *&amp;rdquo;和&amp;ldquo; N *&amp;rdquo;来表示这一点，而没有其他可能的单独条目。请注意，并非所有具有值&amp;ldquo;是&amp;rdquo;和&amp;ldquo;否&amp;rdquo;的属性都是二进制的，并且在不使用此通配符的情况下也将其所有值拼写了出来，并且在其说明中突出显示了它们不是二进制的 &lt;code&gt;NOT&lt;/code&gt; 子句。这些还要求化合物形式与之匹配，而真正的二元性质同时具有单一形式和化合物形式。</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">同样，在&lt;b&gt;Unicode&lt;/b&gt;的上下文中，是用于特定语言或一组语言（例如希腊语，孟加拉语或Tengwar）的书写系统。</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">另外,值得注意的是,这样定义的模式可能不会有那么高的效率,因为优化器对它们的处理不是很聪明。</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">另外，不应在 &lt;code&gt;CRLF&lt;/code&gt; 中分割行（即 &lt;code&gt;\r&lt;/code&gt; 和 &lt;code&gt;\n&lt;/code&gt; 之间没有空行）。对于 &lt;code&gt;CRLF&lt;/code&gt; ，请尝试 &lt;code&gt;:crlf&lt;/code&gt; &lt;a href=&quot;perlio&quot;&gt;crlf&lt;/a&gt;层（请参见PerlIO）。</target>
        </trans-unit>
        <trans-unit id="f3992030bd7e3a922eb5df07ea510b7432d80298" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;). For &lt;code&gt;CRLF&lt;/code&gt;, try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">另外，不应在 &lt;code&gt;CRLF&lt;/code&gt; 中分割行（即 &lt;code&gt;\r&lt;/code&gt; 和 &lt;code&gt;\n&lt;/code&gt; 之间没有空行）。对于 &lt;code&gt;CRLF&lt;/code&gt; ，请尝试 &lt;code&gt;:crlf&lt;/code&gt; &lt;a href=&quot;perlio&quot;&gt;crlf&lt;/a&gt;层（请参见PerlIO）。</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">另外,负信号值在VMS下并没有什么特别的作用,只是转换为相应的正值。</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">另外,请注意,为了安全而使用文件测试从一开始就失去了意义:有一个为竞赛条件打开的窗口(谁能说测试和真实操作之间的权限不会改变?)。因此,如果你对安全问题很重视,只需尝试真正的操作,并测试其成功与否--从原子操作的角度考虑。Filetests对于文件系统管理任务更有用,当你不需要磁盘上元素的内容时。</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">另外,还要注意以下几点:</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">另外,当一个项目在其他方面完成后,你开始进行本地化,你可以把你使用的各种键都拼凑起来,然后交给翻译人员;然后如果他所呈现的是这个样子,那么翻译人员的工作会更快。</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">同样，可以将perl重新编译为在Unicode标准的早期版本上运行。有关更多信息，请 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="b542e84834d4e9866d33acb374e33e8f660c85fa" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">另外，可以重新编译perl以在Unicode标准的早期版本上运行。有关更多信息，请 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">同样，由于 &lt;code&gt;$x&lt;/code&gt; 是词法，因此外部的任何Perl代码都无法达到或修改它。</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">另外,由于您当前版本的 perl 中 opcode 的数量可能不是 8 的精确倍数,所以在 upset 的最后一个字节中可能有未使用的位。这应该不会引起任何问题(Opcode函数会忽略这些额外的位),但这意味着使用~操作符通常不会产生与invert_opset函数相同的 &quot;物理 &quot;opset &quot;字符串&quot;。</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">另外，还提供了一些常见的套接字&amp;ldquo; newline&amp;rdquo;常量：常量 &lt;code&gt;CR&lt;/code&gt; ， &lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt; 以及 &lt;code&gt;$CR&lt;/code&gt; ， &lt;code&gt;$LF&lt;/code&gt; 和 &lt;code&gt;$CRLF&lt;/code&gt; ，它们映射到 &lt;code&gt;\015&lt;/code&gt; ， &lt;code&gt;\012&lt;/code&gt; 和 &lt;code&gt;\015\012&lt;/code&gt; 。如果不想在程序中使用文字字符，请使用此处提供的常量。它们默认情况下不会导出，但是可以使用 &lt;code&gt;:crlf&lt;/code&gt; export标签单独导入：</target>
        </trans-unit>
        <trans-unit id="09c79652fdab8435dc64bf1d503eb44817957310" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt;, and &lt;code&gt;CRLF&lt;/code&gt;, as well as &lt;code&gt;$CR&lt;/code&gt;, &lt;code&gt;$LF&lt;/code&gt;, and &lt;code&gt;$CRLF&lt;/code&gt;, which map to &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, and &lt;code&gt;\015\012&lt;/code&gt;. If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">另外，还提供了一些常见的套接字&amp;ldquo; newline&amp;rdquo;常量：常量 &lt;code&gt;CR&lt;/code&gt; ， &lt;code&gt;LF&lt;/code&gt; 和 &lt;code&gt;CRLF&lt;/code&gt; 以及 &lt;code&gt;$CR&lt;/code&gt; ， &lt;code&gt;$LF&lt;/code&gt; 和 &lt;code&gt;$CRLF&lt;/code&gt; ，它们映射到 &lt;code&gt;\015&lt;/code&gt; ， &lt;code&gt;\012&lt;/code&gt; 和 &lt;code&gt;\015\012&lt;/code&gt; 。如果不想在程序中使用文字字符，请使用此处提供的常量。它们默认情况下不会导出，但可以使用 &lt;code&gt;:crlf&lt;/code&gt; export标签单独导入：</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">另外，有关在Linux上使用Sun Studio构建Perl的一些特殊说明。按照正常的 &lt;code&gt;Configure&lt;/code&gt; ，您必须运行make，如下所示：</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">同样，可以使用 &lt;code&gt;:locked&lt;/code&gt; 属性声明子例程，该属性将序列化对该子例程的访问，但允许不同的线程非同时访问。</target>
        </trans-unit>
        <trans-unit id="f700fce01f8bef830aa30a8774e7a762bfbaf65f" translate="yes" xml:space="preserve">
          <source>Also, the internal representation of Time::Piece-&amp;gt;strftime deviates from the standard POSIX implementation in that is uses the epoch (instead of separate year, month, day parts). This change was added in version 1.30. If you must have a more traditional strftime (which will normally never calculate day light saving times correctly), you can pass the date parts from Time::Piece into the strftime function provided by the POSIX module (see strftime in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; ).</source>
          <target state="translated">而且，Time :: Piece-&amp;gt; strftime的内部表示形式与标准POSIX实现有所不同，因为它使用纪元（而不是单独的年，月，日部分）。此更改是在1.30版中添加的。如果必须使用更传统的strftime（通常永远不会正确计算夏时制时间），则可以将Time :: Piece中的日期部分传递到POSIX模块提供的strftime函数中（请参阅&lt;a href=&quot;posix&quot;&gt;POSIX中的&lt;/a&gt;strftime ）。</target>
        </trans-unit>
        <trans-unit id="e7201d576462a40ab9a535c50ec57d12c94dd4c2" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the &lt;code&gt;refaddr&lt;/code&gt; the same as other handles and so can be compared to other handles with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">同样，该对象被配置为可以字符串化为临时文件的名称，因此可以直接与文件名进行比较。它对 &lt;code&gt;refaddr&lt;/code&gt; 的编号与其他句柄相同，因此可以将其与 &lt;code&gt;==&lt;/code&gt; 进行比较。</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">此外,该对象被配置为字符串化到临时文件的名称,因此可以直接与文件名进行比较。它被命名为C</target>
        </trans-unit>
        <trans-unit id="913c9e19c71d84db5eb4e7b9fa93a06fccc33227" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns and transliterations makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">此外,ASCII中的'A'-'Z'范围是一个由26个大写字母组成的不间断序列。而在EBCDIC中却不是这样。对于'a'到'z'也是如此。但是'0'-'9'在两个系统中都是一个不间断的范围。不要对其他范围做任何假设。(请注意,在正则表达式模式和译名中对范围的特殊处理,使得 Perl 代码看起来上述范围都是不间断的。)</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">此外,ASCII中的'A'-'Z'范围是一个由26个大写字母组成的不间断序列。而在EBCDIC中却不是这样。对于'a'到'z'也是如此。但是'0'-'9'在两个系统中都是一个不间断的范围。不要对其他范围做任何假设。(注意,正则表达式模式中对范围的特殊处理,使得 Perl 代码认为上述范围都是不间断的。)</target>
        </trans-unit>
        <trans-unit id="ed48bbc731848457db80d2fadad2fe9e698169b3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious, see &lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot;&lt;/a&gt; below.</source>
          <target state="translated">另外，使用Unicode可能会带来一些不太明显的安全问题，请参阅下面的&lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&amp;ldquo;&lt;/a&gt; Unicode的安全隐患&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">另外，使用Unicode可能会带来不明显的安全问题。阅读&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode安全注意事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">另外，在此修饰符下，不区分大小写的匹配适用于整套Unicode字符。所述 &lt;code&gt;KELVIN SIGN&lt;/code&gt; ，例如匹配的字母&amp;ldquo;k&amp;rdquo;和&amp;ldquo;K&amp;rdquo;; 和&amp;ldquo; &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; 匹配序列&amp;ldquo; ff&amp;rdquo;，如果您不准备使用它，则可能会使它看起来像一个十六进制常量，从而带来了另一个潜在的安全问题。有关Unicode安全问题的详细讨论，请参见&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="082c639d640961ab2741dc8437aea7d26245da44" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt;, for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">同样，在此修饰符下，不区分大小写的匹配适用于完整的Unicode字符集。所述 &lt;code&gt;KELVIN SIGN&lt;/code&gt; ，例如匹配的字母&amp;ldquo;k&amp;rdquo;和&amp;ldquo;K&amp;rdquo;; 和 &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; 匹配序列&amp;ldquo;FF&amp;rdquo;，而如果你没有准备，可能使它看起来像一个十六进制常数，呈现另一种潜在的安全问题。有关Unicode安全性问题的详细讨论，请参见&lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">并且，各种同义词像 &lt;code&gt;\p{Alpha}&lt;/code&gt; 为 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;在perluniprops中可通过\ p {}和\ P {}访问的属性中&lt;/a&gt;列出的所有属性</target>
        </trans-unit>
        <trans-unit id="185cbf92e7b7051aa2f9930ee2ca151063ceb454" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt;; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;</source>
          <target state="translated">并且，各种同义词像 &lt;code&gt;\p{Alpha}&lt;/code&gt; 为 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;在perluniprops&lt;/a&gt;中的&amp;ldquo;可通过\ p {}和\ P {}访问的属性&amp;rdquo;中列出的所有内容</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">另外,当你的</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">同样，空格，连字符和下划线通常在{花括号}之间的所有位置都被忽略，因此即使未在正则表达式上指定 &lt;code&gt;/x&lt;/code&gt; 修饰符，也可以自由添加或删除空格。但是在下表中，条目开头的&amp;ldquo; &lt;b&gt;T&lt;/b&gt; &amp;rdquo;表示该条目使用了更严格的（严格的）规则：</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">改变正则表达式行为</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">替代堆栈操作</target>
        </trans-unit>
        <trans-unit id="baff84fe31ffd586fd0cbbd5cab56329f0775d04" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the local address to &lt;code&gt;bind()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">指定 &lt;code&gt;bind()&lt;/code&gt; 到的本地地址的替代形式。这应该是 &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; 返回的形式的数组。</target>
        </trans-unit>
        <trans-unit id="0db36f7208c555076a29994a086e6ad6fe2b6c88" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the peer to &lt;code&gt;connect()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">指定 &lt;code&gt;connect()&lt;/code&gt; 要连接的对等方的另一种形式。这应该是 &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; 返回的形式的数组。</target>
        </trans-unit>
        <trans-unit id="4495ae5a9f0394b58820a885d0978ae962fd139c" translate="yes" xml:space="preserve">
          <source>Alternately I can pass an open filehandle as source and have the parser read from that rather than attempting to run a test script:</source>
          <target state="translated">或者,我可以传递一个开放的文件柄作为源文件,让解析器从该文件柄中读取,而不是尝试运行测试脚本。</target>
        </trans-unit>
        <trans-unit id="bb5fc16ac82340f31ba65517d29fc05e91506541" translate="yes" xml:space="preserve">
          <source>Alternately I can supply the names of my substitute classes to the TAP::Harness constructor:</source>
          <target state="translated">或者,我可以向TAP::Harness构造函数提供我的替代类的名称。</target>
        </trans-unit>
        <trans-unit id="9227d0ca3877e84e35d83f9ac364f43162e4ef9e" translate="yes" xml:space="preserve">
          <source>Alternately, if the language used to write my tests allows a shebang line I can use that to specify the interpreter. Here's a test written in PHP:</source>
          <target state="translated">另外,如果用于编写测试的语言允许使用shebang行,我可以用它来指定解释器。下面是一个用PHP编写的测试。</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">另外,如果你有一个SV是一个祝福的参考,你可以通过使用来找出匿迹指针。</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">或者，如果导入 &lt;code&gt;:constants&lt;/code&gt; ，则可以直接使用以下常量：</target>
        </trans-unit>
        <trans-unit id="8a245817c61d1ffafbf0a5d7c18cd6a72b400a7e" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="translated">或者，如果导入 &lt;code&gt;:constants&lt;/code&gt; ，则可以直接使用以下常量：</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">或者,如果你使用OS/2的shell,比如CMD或4os2,在你的perl脚本的开头加上以下内容。</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">或者,尝试在</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">另外,你也可以通过这种方式在现有的句柄上切换到二进制模式。</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">或者，您可以将全局变量 &lt;code&gt;$Carp::Verbose&lt;/code&gt; 为true。请参阅下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">另外,你也可以在make安装后放置 &quot;PREFIX=/destination/directory&quot;(如果你有一个脑残版的make,则在make和安装之间),来指定放置扩展文件的确切目录。如果你正在构建一个最终将被分发到多个系统的扩展,这可能非常有用。然后,你可以只将文件归档到目标目录中,然后将它们分发到你的目标系统。</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">或者，您可以尝试替换使用脚本中＃！/ usr / bin / perl语法的系统&lt;b&gt;Execute&lt;/b&gt;命令，并设置脚本的s-Bit。然后，您可以像在UNIX下使用</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">或者，您可以使用正则表达式引用运算符 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; （有关更多详细信息，请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;）。它引用并可能编译该模式，并且您可以将正则表达式标志应用于该模式。</target>
        </trans-unit>
        <trans-unit id="7d48931e8ff9955945645810ae372a2695434121" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;qr//&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">或者，您可以使用正则表达式引用运算符 &lt;code&gt;qr//&lt;/code&gt; （有关更多详细信息，请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;）。它引用并可能编译该模式，并且您可以将正则表达式标志应用于该模式。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">交替允许正则表达式在其他选择中进行选择，但其本身并不令人满意。原因是每个替代都是一个完整的正则表达式，但是有时我们只希望部分正则表达式具有替代。例如，假设我们要搜索家猫或管家。正则表达式 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 很适合帐单，但效率低下，因为我们不得不两次键入 &lt;code&gt;house&lt;/code&gt; 。最好将正则表达式的某些部分保持不变，例如 &lt;code&gt;house&lt;/code&gt; ，而另一些部分具有替代项，例如 &lt;code&gt;cat|keeper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2748d57020b2771f7481af94280b0d7745a90798" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt;, and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt;.</source>
          <target state="translated">交替允许正则表达式在其他选择中进行选择，但其本身并不令人满意。原因是每个替代都是一个完整的正则表达式，但是有时我们只希望正则表达式的一部分替代。例如，假设我们要搜索家猫或管家。正则表达式 &lt;code&gt;housecat|housekeeper&lt;/code&gt; 很适合帐单，但效率低下，因为我们不得不两次键入 &lt;code&gt;house&lt;/code&gt; 。最好将正则表达式的某些部分保持不变，例如 &lt;code&gt;house&lt;/code&gt; ，而另一些部分具有替代项，例如 &lt;code&gt;cat|keeper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">分组中的替代行为与分组中的替代行为相同：在给定的字符串位置，采用允许regexp匹配的最左侧替代。因此，在最后一个示例中，在第一个字符串位置处， &lt;code&gt;&quot;20&quot;&lt;/code&gt; 与第二个替代项匹配，但是没有剩余的内容与后两位 &lt;code&gt;\d\d&lt;/code&gt; 匹配。因此Perl转到下一个替代方案，它是null替代方案，并且可以工作，因为 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 是两位数。</target>
        </trans-unit>
        <trans-unit id="ef0bb58311a4cc103103ca6beeb54a0245223e8c" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt;. So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">分组中的替代行为与分组中的替代行为相同：在给定的字符串位置，采用允许regexp匹配的最左侧替代。因此，在最后一个示例的第一个字符串位置， &lt;code&gt;&quot;20&quot;&lt;/code&gt; 与第二个替代项匹配，但是没有剩余内容与后两位 &lt;code&gt;\d\d&lt;/code&gt; 匹配。因此Perl转到下一个替代方案，它是null替代方案，并且可以工作，因为 &lt;code&gt;&quot;20&quot;&lt;/code&gt; 是两位数。</target>
        </trans-unit>
        <trans-unit id="d45912dbd856f0ddf337c48eab0e2b6ac8ae702c" translate="yes" xml:space="preserve">
          <source>Alternative Hash Functions</source>
          <target state="translated">其他哈希函数</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">替代的捕获组编号</target>
        </trans-unit>
        <trans-unit id="ef523340b1a308a5c82202213f6749b6e6b1eda0" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math::BigInt::Calc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">替代库&lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math :: BigInt :: Calc&lt;/a&gt;，&lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt;和&lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="701e87ca0ad0ba8cd11eda21d6ba26ee826bdec9" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math::BigInt::FastCalc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">替代库&lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math :: BigInt :: FastCalc&lt;/a&gt;，&lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt;和&lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">其他数学库</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">备选方案启动器</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">Test::More::use_ok替代方案</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">模块的替代警告和死亡</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">或者，通过以下方式交互式编辑初始化文件：第三个鼠标按钮-&amp;gt;新显示-&amp;gt;编辑菜单</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">或者在这里查看：&lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http&lt;/a&gt; : //www.unix.com/man-page/FreeBSD/3/strftime/</target>
        </trans-unit>
        <trans-unit id="e35a7c6545b16241ad2de0b09b446ca8d6a30265" translate="yes" xml:space="preserve">
          <source>Alternatively one can use the</source>
          <target state="translated">或者,我们可以使用</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">另外,子字段列表也可以以标量形式提供,因此</target>
        </trans-unit>
        <trans-unit id="2d8ede1527fb5e6a736864b76d2f172c35af4997" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the</source>
          <target state="translated">或者您也可以使用</target>
        </trans-unit>
        <trans-unit id="094a83381a58e4403aca1b491639e03749297bf0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the XPUSHs() macro, which combines a &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; and &lt;code&gt;PUSHs()&lt;/code&gt;. This is less efficient if you're pushing multiple values.</source>
          <target state="translated">或者，您可以使用XPUSHs（）宏，该宏结合了 &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; 和 &lt;code&gt;PUSHs()&lt;/code&gt; 。如果您要推送多个值，则效率会降低。</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">另外,你也可以使用编译器指令our()将一个动态变量带入当前的词法范围。</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">或者你可以使用:</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">另外，您也许可以从 &lt;code&gt;CPAN&lt;/code&gt; 预先构建这些文档。</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">另外,你也可以从CPAN获得这些预建文档。</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">另外,您也可以在离您最近的CPAN档案馆里找到Berkeley DB 1版本。</target>
        </trans-unit>
        <trans-unit id="4613df2f546fec79f85cfae70e64069cb1648bc9" translate="yes" xml:space="preserve">
          <source>Alternatively, a version range &lt;b&gt;may&lt;/b&gt; use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="translated">或者，版本范围&lt;b&gt;可以&lt;/b&gt;使用运算符&amp;lt;（小于），&amp;lt;=（小于或等于），&amp;gt;（大于），&amp;gt; =（大于或等于），==（等于）和！=（不平等的）。例如，规范 &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; 表示先决条件的任何版本小于2.0均适用。</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">另外,也可以使用章节规格的数组引用。</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">或者，从版本2.24开始，可以将配置选项与 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句一起传递：</target>
        </trans-unit>
        <trans-unit id="865e46b39731975715e5505f357dc99fc1bb9e96" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;use&lt;/code&gt; statement:</source>
          <target state="translated">另外，从版本2.24开始，配置选项可以与 &lt;code&gt;use&lt;/code&gt; 语句一起传递：</target>
        </trans-unit>
        <trans-unit id="fb6383e28e6083bea50110ff705c0169c065025b" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;decode_pod&lt;/code&gt; is set, it will decode the collected pod sections according to the &lt;code&gt;=encoding&lt;/code&gt; declaration.</source>
          <target state="translated">或者，如果设置了 &lt;code&gt;decode_pod&lt;/code&gt; ，它将根据 &lt;code&gt;=encoding&lt;/code&gt; 声明对收集的pod部分进行解码。</target>
        </trans-unit>
        <trans-unit id="c0f72336ff028f49493e1034a2d5aa23e62a23ff" translate="yes" xml:space="preserve">
          <source>Alternatively, if the &lt;code&gt;string&lt;/code&gt; parameter is given, the supplied string will be parsed instead of a file.</source>
          <target state="translated">或者，如果指定了 &lt;code&gt;string&lt;/code&gt; 参数，则将解析提供的字符串而不是文件。</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">另外,如果您不需要 perlglob.exe,也不需要启用 USE_SETARGV 选项,您可以从 win32/Makefile 中删除所有提及 $(GLOBEXE)的内容,而 setargv.obj 则不需要。</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">或者，如果您有 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用它来读取压缩文件</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">或者，如果要将 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; 成员读入内存，请对 &lt;code&gt;output&lt;/code&gt; 参数使用标量引用。</target>
        </trans-unit>
        <trans-unit id="067a937688c2a4c5c986d21853b255fbc5aefe6e" translate="yes" xml:space="preserve">
          <source>Alternatively, one can round the results explicitly using one of &lt;a href=&quot;#round%28%29&quot;&gt;&quot;round()&quot;&lt;/a&gt;, &lt;a href=&quot;#bround%28%29&quot;&gt;&quot;bround()&quot;&lt;/a&gt; or &lt;a href=&quot;#bfround%28%29&quot;&gt;&quot;bfround()&quot;&lt;/a&gt; or by passing the desired accuracy to the method as an additional parameter:</source>
          <target state="translated">或者，可以使用&lt;a href=&quot;#round%28%29&quot;&gt;&amp;ldquo; round（）&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#bround%28%29&quot;&gt;&amp;ldquo; bround（）&amp;rdquo;&lt;/a&gt;或&lt;a href=&quot;#bfround%28%29&quot;&gt;&amp;ldquo; bfround（）&amp;rdquo;之一&lt;/a&gt;或通过将所需的精度作为附加参数传递给该方法来显式舍入结果：</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">或者,将此作为你脚本的第一行。</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">另外，不必显式命名要压缩的每个文件，您可以使用fileglob选择当前目录中的所有 &lt;code&gt;txt&lt;/code&gt; 文件，如下所示</target>
        </trans-unit>
        <trans-unit id="eefa7323e5eca7f13253bb419c7f371832614e4a" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this always gets it right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">另外，只需使用 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 进行比较，就可以正确进行比较。还没有一种方法来自动将数字表示为与Perl表示方式完全匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">另外，只需使用 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 进行比较，即可始终正确。还没有一种方法来自动将数字表示为与Perl表示方式完全匹配的字符串。</target>
        </trans-unit>
        <trans-unit id="055ca33d620827ab022a97400794bf3fb8a2807b" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">另外，&lt;a href=&quot;Text::ParseWords&quot;&gt;Text :: ParseWords&lt;/a&gt;模块（标准Perl发行版的一部分）使您可以说：</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">另外，&lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;模块（标准Perl发行版的一部分）允许您说：</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">另外,GNU libc中的加密库也被移植到Cygwin中。</target>
        </trans-unit>
        <trans-unit id="43ccb7ccf6de944158b57bdf33cf5e43082dfbc3" translate="yes" xml:space="preserve">
          <source>Alternatively, use the macro &lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&quot;&lt;code&gt;CopLABEL_len_flags&lt;/code&gt;&quot;&lt;/a&gt;; or if you don't need to know if the label is UTF-8 or not, the macro &lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot;&lt;code&gt;CopLABEL_len&lt;/code&gt;&quot;&lt;/a&gt;; or if you additionally dont need to know the length, &lt;a href=&quot;#CopLABEL&quot;&gt;&quot;&lt;code&gt;CopLABEL&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">或者，使用宏&lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&amp;ldquo; &lt;code&gt;CopLABEL_len_flags&lt;/code&gt; &amp;rdquo;&lt;/a&gt; ; 或者，如果您不需要知道标签是否为UTF-8，则可以使用宏&lt;a href=&quot;#CopLABEL_len&quot;&gt;&amp;ldquo; &lt;code&gt;CopLABEL_len&lt;/code&gt; &amp;rdquo;&lt;/a&gt; ; 或者，如果您另外不需要知道长度&lt;a href=&quot;#CopLABEL&quot;&gt;&amp;ldquo; &lt;code&gt;CopLABEL&lt;/code&gt; &amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">另外,首先使用定制的排版图来达到你的目的可能是比较好的。</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">或者，我们可以使用 &lt;code&gt;C&lt;/code&gt; 来解包可单独访问的字节寄存器FL，FH，AL，AH等：</target>
        </trans-unit>
        <trans-unit id="87ca4d1f50f588b444c138934de28912a7c4fa3d" translate="yes" xml:space="preserve">
          <source>Alternatively, we might be able to use a command line option such as -R</source>
          <target state="translated">或者,我们可以使用一个命令行选项,如-R</target>
        </trans-unit>
        <trans-unit id="16c917006b223001c63f85b3d40138b38f9bf9a9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can achieve a similar static effect by declaring the variable in a separate block outside the function, e.g.,</source>
          <target state="translated">另外,你也可以通过在函数外的独立块中声明变量来达到类似的静态效果,例如:。</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">或者，您可以直接摆弄堆栈： &lt;code&gt;SP&lt;/code&gt; 为您提供堆栈中第一个元素，而 &lt;code&gt;TOP*&lt;/code&gt; 为您提供顶部的SV / IV / NV / etc。在堆栈上。因此，例如，对整数进行一元求反：</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">另外,你也可以引用类名。</target>
        </trans-unit>
        <trans-unit id="3dc4c1bc0515a5f540589d100b6ce1224a32ad91" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a reference to a scalar as the destination:</source>
          <target state="translated">另外,你也可以通过添加&quot;@&quot;来指定选项可以有多个值,并传递一个标量的引用作为目标。</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">另外,你也可以通过添加&quot;@&quot;来指定选项可以有多个值,并传递一个标量引用作为目标。</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">另外，您可以使用 &lt;code&gt;plan()&lt;/code&gt; 函数。在必须计算测试次数时很有用。</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">或者,你可以使用GCC_EXEC_PREFIX环境变量来确保使用Sun的as和ld。关于-B选项和GCC_EXEC_PREFIX变量的更多信息,请查阅gcc文档。</target>
        </trans-unit>
        <trans-unit id="ee23e1f9045483d4017c29efb93306a8f81a02a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;posix#WIFEXITED&quot;&gt;&lt;code&gt;W*()&lt;/code&gt;&lt;/a&gt; calls from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">或者，您可以使用来自&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的&lt;a href=&quot;posix#WIFEXITED&quot;&gt; &lt;code&gt;W*()&lt;/code&gt; &lt;/a&gt;检查&lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">或者，您可以通过POSIX模块的 &lt;code&gt;W*()&lt;/code&gt; 调用检查 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="273eb19a8880a15607895e1cd30f571a681e7c99" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object.</source>
          <target state="translated">或者，您可以传递一个 &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="98574b24c9752f26b07d4e571e873801f591432e" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; object.</source>
          <target state="translated">另外，您可以传递一个 &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="3baaa9fdf5df5a376581f707e9bd2202f9c63495" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object.</source>
          <target state="translated">或者，您可以传递一个 &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">从左到右尝试替代方案，因此找到与整个表达式匹配的第一个替代方案。这意味着替代方案不一定是贪婪的。例如：将 &lt;code&gt;foo|foot&lt;/code&gt; 与&amp;ldquo; barefoot&amp;rdquo; 匹配时，只有&amp;ldquo; foo&amp;rdquo;部分将匹配，因为这是第一个尝试的方法，它成功匹配了目标字符串。（这似乎并不重要，但是在使用括号捕获匹配的文本时，这一点很重要。）</target>
        </trans-unit>
        <trans-unit id="c8af2aafd15c21262760094a19550be8139535e2" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt;, only the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">从左到右尝试替代方案，因此找到与整个表达式匹配的第一个替代方案。这意味着替代方案不一定是贪婪的。例如：将 &lt;code&gt;foo|foot&lt;/code&gt; 与 &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt; 匹配时，只有 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 部分会匹配，因为这是第一个尝试的方法，它成功匹配了目标字符串。（这似乎并不重要，但是在使用括号捕获匹配的文本时，这一点很重要。）</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">生的替代品</target>
        </trans-unit>
        <trans-unit id="52a09d99c8be7488acf8d5679596a3a7ebeeb466" translate="yes" xml:space="preserve">
          <source>Alternatives: &lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2::AsyncSubtest&lt;/a&gt; and &lt;a href=&quot;Test2::Workflow&quot;&gt;Test2::Workflow&lt;/a&gt; (not stable).</source>
          <target state="translated">替代方案：&lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2 :: AsyncSubtest&lt;/a&gt;和&lt;a href=&quot;Test2::Workflow&quot;&gt;Test2 :: Workflow&lt;/a&gt;（不稳定）。</target>
        </trans-unit>
        <trans-unit id="dcc6e5f9721668e6a6d8a7cd85c26663fa384cb4" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">或者，查看&lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;或其他&lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack身份验证&lt;/a&gt;选项之一。</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">或者，查看&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;或其他&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack身份验证&lt;/a&gt;选项之一。</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;无法直接执行此操作，但是有一个模块可以透明地在&lt;b&gt;DB_File&lt;/b&gt;上分层以完成此功能。</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;受Perl许可证的保护，但它使用的库（即Berkeley DB）却没有。Berkeley DB具有自己的版权和许可证。请花时间阅读它。</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">尽管&lt;b&gt;DB_File&lt;/b&gt;打算与Berkeley DB版本1一起使用，但也可以与版本2、3或4一起使用。在这种情况下，接口仅限于Berkeley DB 1.x提供的功能。无论版本2或更高版本的接口有何不同，&lt;b&gt;DB_File都会&lt;/b&gt;安排它像版本1一样工作。此功能允许将使用版本1构建的&lt;b&gt;DB_File&lt;/b&gt;脚本迁移到版本2或更高版本，而无需进行任何更改。</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">尽管 &lt;code&gt;$_&lt;/code&gt; 实际上并未显式出现在上面的示例过滤器中，但是它在许多地方都隐式使用。</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">尽管已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 在尚未使用的普通哈希中为false，但在几种非显而易见的情况下（包括迭代器，弱引用，存储名称），它变为true，甚至在 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 之后仍为 true 。这些事情使已 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 在实践中相当无用，因此现在会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="7ff687f6589d5bc55ea5b6cd3b7acf0a8989e998" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Compress::Zlib&lt;/code&gt; has a pair of functions called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;, they are</source>
          <target state="translated">尽管 &lt;code&gt;Compress::Zlib&lt;/code&gt; 具有一对称为 &lt;code&gt;compress&lt;/code&gt; 和 &lt;code&gt;uncompress&lt;/code&gt; 的函数，但它们是</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">尽管 &lt;code&gt;cmp_ok()&lt;/code&gt; 是在0.40中引入的，但0.86修复了一个重要的错误，以使其对于重载的对象而言是安全的；作为Test :: More 0.92的一部分，Perl在5.10.1中首次提供的固定版本。</target>
        </trans-unit>
        <trans-unit id="a46f1c081d434cfa72b0670296268695a927ef72" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;defined %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;undef %hash&lt;/code&gt;. These things make &lt;code&gt;defined %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">尽管已 &lt;code&gt;defined %hash&lt;/code&gt; 在尚未使用的普通哈希中为false，但在几种非显而易见的情况下仍为true，包括迭代器，弱引用，存储名称，甚至在 &lt;code&gt;undef %hash&lt;/code&gt; 之后仍为true 。这些事情使已 &lt;code&gt;defined %hash&lt;/code&gt; 在实践中相当无用，因此现在会产生致命错误。</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">尽管FileCache可以使用管道打开('-|'或'|-'),但强烈不推荐这样做。如果FileCache发现有必要关闭然后重新打开管道,那么管道末端的命令将被重新执行--在FileCache'd管道上执行IO的结果很可能不是你所期望的。在管道上使用FileCache的功能可能会在未来的版本中被移除。</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">虽然我已经仅使用的 &lt;code&gt;POP*&lt;/code&gt; 宏从Perl的子程序返回访问值，还可以绕过这些宏并使用读出栈 &lt;code&gt;ST&lt;/code&gt; 宏（见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;为的完整说明， &lt;code&gt;ST&lt;/code&gt; 宏）。</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">虽然PA-RISC二进制文件可以在Itanium系统上运行,但你不应该尝试在Itanium系统上使用PA-RISC版本的Perl。这是因为在Itanium系统上创建的共享库不能在运行PA-RISC可执行文件时被加载。</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">虽然Perl会自动为你增长字符串,但如果你需要强制Perl为你的SV分配更多的内存,你可以使用宏</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">虽然Plan 9 Perl目前只提供静态加载,但它内置了许多有用的扩展。这些扩展包括 Opcode、FileHandle、Fcntl 和 POSIX。期待未来能看到其他的扩展(还有DynaLoading!)。</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">尽管自5.6.2版以来，Test :: More一直是Perl版本的核心模块，但自那时起Test :: More已经得到了发展，并非您习惯的所有功能都会出现在Test ::的发行版中。更多。如果您正在编写模块，请不要忘记在包元数据中指出所需的最低Test :: More版本。例如，如果要使用 &lt;code&gt;done_testing()&lt;/code&gt; 但要使测试脚本在Perl 5.10.0上运行，则需要明确要求Test :: More&amp;gt; 0.88。</target>
        </trans-unit>
        <trans-unit id="4b6eb7d4608b6bb5e2737f99ed626a9c3d3fdff3" translate="yes" xml:space="preserve">
          <source>Although all mathematical operations on version objects are forbidden by default, it is possible to retrieve a number which corresponds to the version object through the use of the $obj-&amp;gt;numify method. For formatting purposes, when displaying a number which corresponds a version object, all sub versions are assumed to have three decimal places. So for example:</source>
          <target state="translated">尽管默认情况下禁止对版本对象进行所有数学运算，但是可以通过使用$ obj-&amp;gt; numify方法检索与版本对象相对应的数字。出于格式化目的，当显示与版本对象相对应的数字时，所有子版本均假定具有三个小数位。因此，例如：</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">虽然截至5.14日,也可以通过这种方式来实现。</target>
        </trans-unit>
        <trans-unit id="06dbd031cbe601d39502de2a4b463b8de205125c" translate="yes" xml:space="preserve">
          <source>Although at first sight there seems to be quite a lot going on in &lt;code&gt;Apache::GZip&lt;/code&gt;, you could sum up what the code was doing as follows -- read the contents of the file in &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt;, compress it and write the compressed data to standard output. That's all.</source>
          <target state="translated">尽管 &lt;code&gt;Apache::GZip&lt;/code&gt; 似乎有很多事情发生，但是您可以总结如下代码：-在 &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; 读取文件的内容，将其压缩并编写压缩数据到标准输出。就这样。</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">虽然如果你的经理指责你通过难以捉摸的代码来寻求工作的安全性(或快速的不安全性),那就很难辩解了。 :-)如果我是你,我会把它放在一个函数里。</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">尽管它在C中没有直接等效项，但是Perl的 &lt;code&gt;//&lt;/code&gt; 运算符与其C样式的&amp;ldquo;或&amp;rdquo;相关。实际上，它与 &lt;code&gt;||&lt;/code&gt; 完全相同，除了它测试左侧的定义而不是其真实性。因此， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 返回的值 &lt;code&gt;EXPR1&lt;/code&gt; ，如果它的定义，否则，价值 &lt;code&gt;EXPR2&lt;/code&gt; 返回。 （ &lt;code&gt;EXPR1&lt;/code&gt; 在标量上下文中评估， &lt;code&gt;EXPR2&lt;/code&gt; 在 &lt;code&gt;//&lt;/code&gt; 自身上下文中评估）。通常，这与 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; 结果（EXPR1）是相同的？ EXPR1：EXPR2（除了三元运算符形式可以用作左值，而 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 不能）。这对于提供变量的默认值非常有用。如果您实际上想测试是否已定义 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 中的至少一个，请使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fb2cc3c9a7a9c586fba874bcd544c7350b090af" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;defined($x // $y)&lt;/code&gt;.</source>
          <target state="translated">尽管它在C中没有直接等效项，但是Perl的 &lt;code&gt;//&lt;/code&gt; 运算符与其C样式的&amp;ldquo;或&amp;rdquo;相关。实际上，它与 &lt;code&gt;||&lt;/code&gt; 完全相同，除了它测试左侧的定义而不是其真实性。因此， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 返回的值 &lt;code&gt;EXPR1&lt;/code&gt; ，如果它的定义，否则，价值 &lt;code&gt;EXPR2&lt;/code&gt; 返回。 （ &lt;code&gt;EXPR1&lt;/code&gt; 在标量上下文中评估， &lt;code&gt;EXPR2&lt;/code&gt; 在 &lt;code&gt;//&lt;/code&gt; 自身上下文中评估）。通常，这与 &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; 是相同的结果吗？ EXPR1：EXPR2（除了三元运算符形式可以用作左值，而 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 不能）。这对于提供变量的默认值非常有用。如果您实际上想测试是否已定义 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 中的至少一个，请使用 &lt;code&gt;defined($x // $y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">尽管它的优先级与C中相同，但是Perl的 &lt;code&gt;?:&lt;/code&gt; 运算符会产生一个左值。这将$ x分配给$ if_true或$ if_false，这取决于$ maybe的真实性：</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">虽然它有点混乱,有些人反对这个术语,但值得一看的是,有评论说,在</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">尽管不是非法的，但在非阻塞模式下的套接字上使用 &lt;code&gt;MultiHomed&lt;/code&gt; 几乎没有用。这是因为第一个连接将不会因超时而失败，因为连接调用不会阻塞。</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">尽管可以（需要您一些努力）使用此模块来访问.zip文件，但是还有其他可用的perl模块可以为您完成所有艰苦的工作。检出 &lt;code&gt;Archive::Zip&lt;/code&gt; ， &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; ， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; Uncompress :: Unzip。</target>
        </trans-unit>
        <trans-unit id="7c711291979b77793d98593cadd4dda9f5e5ad0f" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt;, &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;.</source>
          <target state="translated">尽管可以（需要您一些努力）使用此模块访问.zip文件，但是还有其他可用的perl模块可以为您完成所有艰苦的工作。检出 &lt;code&gt;Archive::Zip&lt;/code&gt; ， &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; ， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; Uncompress :: Unzip。</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">虽然可能被认为是内部的,但类的层次结构对用户和程序员来说确实很重要。CPAN.pm处理的是上述四个类,这些类都共享一组方法。经典的单多态是有效的。一个元类对象注册了所有的各类对象,并以字符串为索引。引用对象的字符串有一个分离的命名空间(好吧,不是完全分离)。</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">虽然从上面的代码中可能不会立即显现出来,但关联数组接口可以用来写入带有重复键的值,但不能用来从数据库中读回它们。</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">尽管看起来确实很痛苦，但是在所有脚本中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;确实值得付出努力。</target>
        </trans-unit>
        <trans-unit id="566dc93bd22756361b44728a27034002b97a3383" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;use strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">尽管看起来确实很痛苦，但值得在所有脚本中 &lt;code&gt;use strict&lt;/code&gt; 才是值得的。</target>
        </trans-unit>
        <trans-unit id="1bf682b28167943a367ab8e4c8b1a462063a4d50" translate="yes" xml:space="preserve">
          <source>Although it's less convenient in some ways than the tied hash interface, you can also call methods directly to manipulate individual symbols. In some cases, this allows you finer control than using a tied hash aggregate. The following methods are supported:</source>
          <target state="translated">虽然它在某些方面不如绑定哈希接口方便,但你也可以直接调用方法来操作单个符号。在某些情况下,这可以让你比使用绑定的哈希集合进行更精细的控制。以下是支持的方法。</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">虽然较大的桶的内存开销被保存在桶内,但对于较小的桶,它被保存在单独的区域中。这个字段给出了这些区域的总大小。</target>
        </trans-unit>
        <trans-unit id="89dede28bef0b8e7f141797013c579678fb08474" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="translated">尽管当前未发出警告，但是当对既不是数字（请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&amp;ldquo;整数算术&amp;rdquo;&lt;/a&gt;）也不是&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;位字符串&lt;/a&gt;（请参阅&amp;ldquo;按位字符串运算符&amp;rdquo;）的操作数执行这些操作时，结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">尽管当前未发出警告，但是当对既不是数字（请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;）又不是&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;位字符串&lt;/a&gt;（请参见按位字符串运算符）的操作数执行这些操作时，结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">尽管不是出于胆小，Perl确实支持 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 语句。有三种形式： &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -expr，并 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -与命名。循环的LABEL实际上并不是 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 的有效目标；它只是循环的名称。</target>
        </trans-unit>
        <trans-unit id="1069922d0daa5d3be0e9150c826b5a6eaf7851b6" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;goto&lt;/code&gt; statement. There are three forms: &lt;code&gt;goto&lt;/code&gt;-LABEL, &lt;code&gt;goto&lt;/code&gt;-EXPR, and &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;goto&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">尽管不是出于胆小，Perl确实支持 &lt;code&gt;goto&lt;/code&gt; 语句。有三种形式： &lt;code&gt;goto&lt;/code&gt; -label， &lt;code&gt;goto&lt;/code&gt; -expr，并 &lt;code&gt;goto&lt;/code&gt; -与命名。循环的LABEL实际上并不是 &lt;code&gt;goto&lt;/code&gt; 的有效目标；它只是循环的名称。</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">虽然人们已经可以用上面的字面字符串regexps做很多事情,但我们只是触及了正则表达式技术的表面。在本节和后续章节中,我们将介绍 regexp 的概念(以及相关的元字符符号),这些概念将允许 regexp 不仅仅代表一个单一的字符序列,而是代表一个</target>
        </trans-unit>
        <trans-unit id="2365e59fbff407c44bacc5b415419bc0925eb6e4" translate="yes" xml:space="preserve">
          <source>Although one does not have to follow this convention, be aware that the convention for UNIX man pages for commands is for the man page title to be in all-uppercase, even if the command isn't.</source>
          <target state="translated">虽然不一定要遵循这个惯例,但要注意UNIX命令的手册页的惯例是手册页的标题要全大写,即使命令不是。</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">虽然人们期望数量$y和$z是相同的,等于100000,但它们会有所不同,而是分别为0和100000。</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">虽然预计只有一个值会从</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">虽然这些宏主要是为多线程Perl设计的,但它们也可以在非线程Perl中使用。</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">虽然相似,但Unix、Windows、Mac OS、OS/2、VMS、VOS、RISC OS以及其他操作系统之间的文件路径规范有所不同。例如,Unix是为数不多的具有单一根目录这一优雅理念的操作系统之一。</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">尽管测试失败应该足够，但是在测试运行结束时仍可以触发额外的诊断。 &lt;code&gt;onfail&lt;/code&gt; 传递了描述每个测试失败的哈希引用的数组引用。每个哈希至少包含以下字段： &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;repetition&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 。（您不应依赖于其他任何存在的字段。）如果测试具有期望值或诊断（或&amp;ldquo;注释&amp;rdquo;）字符串，则还将包括这些内容。</target>
        </trans-unit>
        <trans-unit id="cb955315f15c5e807d16b61b980d5ee47a32430b" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt;. (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">尽管测试失败应该足够，但是在测试运行结束时可以触发额外的诊断。 &lt;code&gt;onfail&lt;/code&gt; 传递了描述每个测试失败的哈希引用的数组引用。每个哈希至少包含以下字段： &lt;code&gt;package&lt;/code&gt; ， &lt;code&gt;repetition&lt;/code&gt; 和 &lt;code&gt;result&lt;/code&gt; 。 （您不应依赖其他任何存在的字段。）如果测试具有期望值或诊断（或&amp;ldquo;注释&amp;rdquo;）字符串，则还将包括这些内容。</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">尽管这种形式可能会在网络传输中遇到麻烦（由于存在8位字符）或在非ISO拉丁字符集上。但是它确实允许重写 &lt;code&gt;Is_c1&lt;/code&gt; ，因此它可以在没有 &lt;code&gt;'unicode_strings'&lt;/code&gt; （低于v5.14的版本）的Perls上运行：</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">尽管 &lt;code&gt;%&lt;/code&gt; 代码记录为返回&amp;ldquo;校验和&amp;rdquo;：请不要相信这些值！即使将其应用于少量字节，也无法保证明显的汉明距离。</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">虽然上面的内容一开始看起来有些混乱,但一般来说,在大多数情况下它都是 &quot;正确的&quot;。这种默认值的确定是基于以下典型的Unix惯例。</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">虽然上面的错误信息指的是脚本中的第二条 tie()语句,但问题的根源其实是前面的 untie()语句。</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">虽然这个标志所提供的功能看起来很简单,但只有在有充分理由的情况下才能使用。谨慎的原因是,即使你指定了G_NOARGS标志,被调用的Perl子程序仍然有可能认为你给它传递了参数。</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">虽然被忽略的参数不会进入变量中,但对调用者来说,它仍然是必须传递的。</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">尽管可以在&lt;a href=&quot;perlsec&quot;&gt;perlsec中&lt;/a&gt;找到有关Perl安全性问题的主要讨论，但是，如果没有引起您对依赖于语言环境的安全性问题的关注，对Perl的语言环境处理的讨论将是不完整的。语言环境（尤其是在允许无特权用户建立自己的语言环境的系统上）是不可信的。恶意（或仅是普通破坏）的语言环境可能会使支持语言环境的应用程序产生意外的结果。这里有一些可能性：</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">尽管最深层嵌套的数组或哈希元素不会仅仅因为已经测试过其存在而出现，但任何中间元素都可以。因此，由于上面$ key元素的存在性测试， &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 和 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 将会出现。这发生在使用箭头运算符的任何地方，甚至包括以下位置：</target>
        </trans-unit>
        <trans-unit id="d1b22581bc0b80baeffbb205fa759bdb0ff242e5" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the &lt;code&gt;$key&lt;/code&gt; element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">尽管最深嵌套的数组或哈希元素不会仅仅因为已经测试过其存在而出现，但是任何中间的数组或哈希元素都会出现。因此，由于上面 &lt;code&gt;$key&lt;/code&gt; 元素的存在性测试， &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; 和 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; 将会出现。这发生在使用箭头运算符的任何地方，甚至包括以下位置：</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">尽管optree是只读的，但是有一个覆盖工具允许您重写各种B :: * OP方法为特定op返回的值。 &lt;code&gt;$B::overlay&lt;/code&gt; 应该设置为引用两个深度的哈希值：按OP地址索引，然后按方法名称索引。每当调用op方法时，如果哈希值存在，则返回该值。B :: Deparse使用此功能来&amp;ldquo;撤消&amp;rdquo;某些优化。例如：</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">尽管存在 &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; 的主要目的是由 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; 模块使用，但它可以单独用于简单的压缩/解压缩任务。</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">尽管此处描述的技术适用于将Perl嵌入C程序中，但这不是本文档的主要目标。还必须考虑其他细节，这些细节特定于嵌入Perl。有关将Perl嵌入C的详细信息，请参考&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">虽然在任何时候都可以有任何数量的源流存在,但只有一个源流是活跃的。</target>
        </trans-unit>
        <trans-unit id="837688ce8fc062bca9030ce8b90ed396865f417d" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;&quot;Context&quot;&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;&quot;List value constructors&quot; in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">尽管这些是按家庭分组的，但它们都具有分配的优先权。这些组合的赋值运算符只能在标量上进行运算，而普通的赋值运算符只能对数组，哈希，列表甚至引用进行赋值。（请参阅&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata中的&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;&amp;ldquo;上下文&amp;rdquo;&lt;/a&gt;和&amp;ldquo;列表值构造函数&amp;rdquo;，以及perlref中的&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&amp;ldquo;分配给引用&amp;rdquo;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">尽管这些是按家庭分组的，但它们都具有分配的优先权。这些组合的赋值运算符只能对标量进行运算，而普通的赋值运算符可以赋给数组，哈希，列表甚至引用。（请参阅&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldata中的&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt;和List值构造函数，以及perlref中的&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;分配给引用&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1f0ef7687de397f14de7592d67f915d2f79f2a4c" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a &lt;code&gt;PUSHMARK&lt;/code&gt; before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;&quot;call_pv&quot;&lt;/a&gt; for example).</source>
          <target state="translated">虽然这个函数返回的Perl参数栈上的价值观，它不带任何参数从堆栈（并因此特别有没有必要做 &lt;code&gt;PUSHMARK&lt;/code&gt; 调用它之前，不像&lt;a href=&quot;#call_pv&quot;&gt;&amp;ldquo;call_pv&amp;rdquo;&lt;/a&gt;为例）。</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">尽管此函数在perl参数堆栈上返回其值，但它不从该堆栈中获取任何参数（因此，特别是，在调用它之前无需执行&lt;a href=&quot;#call_pv&quot;&gt;PUSHMARK&lt;/a&gt;，例如，与call_pv不同）。</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">虽然这个关键字是可选的,而且在某些情况下它提供了多余的信息,但它应该始终被使用。这个关键字将确保XSUB出现在所需的包中。</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">尽管此选项可与OO界面一起使用，但最常用于单发界面。例如，以下代码显示了在将文件名存储在 &lt;code&gt;$zipfile&lt;/code&gt; 之前，如何使用 &lt;code&gt;FilterName&lt;/code&gt; 从一系列文件名中删除路径组件。</target>
        </trans-unit>
        <trans-unit id="e7045e0d3148f2b5800c2c6d6d41c5d9e7c09642" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt;.</source>
          <target state="translated">尽管此选项可与OO界面一起使用，但最常用于单发界面。例如，下面的代码显示了在将文件名存储在 &lt;code&gt;$zipfile&lt;/code&gt; 之前，如何使用 &lt;code&gt;FilterName&lt;/code&gt; 从一系列文件名中删除路径组件。</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">虽然这个东西用例子解释起来比较容易,但你首先需要了解几个重要的定义。</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">尽管非常有用，但是在命令行上使用&lt;b&gt;-w&lt;/b&gt;启用警告的主要问题是它全部或全部都不存在。在编写Perl程序时采用典型情况。您将自己编写部分代码，但是很有可能会使用预先编写的Perl模块。如果在这种情况下使用&lt;b&gt;-w&lt;/b&gt;标志，则最终会在尚未编写的代码段中启用警告。</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">尽管我们确实建议您始终从源代码中构建自己的Perl，以实现最大的可配置性和安全性，但是如果您急着需要，可以&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;访问http://www.cpan.org/ports/index.html&lt;/a&gt;以获得帮助。二进制分布。</target>
        </trans-unit>
        <trans-unit id="cd023125cfeba9eec78f15bbf69240c8b819181b" translate="yes" xml:space="preserve">
          <source>Although we wish to free any temps at the same time, we have to be careful not to free any temps which are keeping return args alive; nor to free the temps we have just created while mortal copying return args. Fortunately, &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; is capable of making mortal copies of return args, shifting args down the stack, and only processing those entries on the temps stack that are safe to do so.</source>
          <target state="translated">尽管我们希望同时释放任何临时文件，但我们必须注意不要释放任何使返回参数保持活动状态的临时文件。也不释放凡人复制返回参数时我们刚刚创建的临时文件。幸运的是， &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; 能够制作返回参数的致命副本，将参数向下移动到堆栈中，并且仅能处理临时堆栈中的安全条目。</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">尽管write可以使用词法变量或包变量,但无论你使用什么变量,都必须以格式化的方式进行作用域。这很可能意味着你要本地化一些包变量。</target>
        </trans-unit>
        <trans-unit id="e5edf100e2a7db4baae600915e4757f07b6f80de" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">尽管出于历史原因，&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;发行版从此模块中获得了名称，但它现在仅是为&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供一个与&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx向后兼容的接口。如果要编写新代码，请考虑直接使用&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">尽管出于历史原因，&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;发行版从此模块中获得了名称，但它现在仅存在于为&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供一个与&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx 向下兼容的接口。如果要编写新代码，请考虑直接使用&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31fcae02d3e65b92831cdd124f189410606de910" translate="yes" xml:space="preserve">
          <source>Alvestrand, Harald Tveit. 1995.</source>
          <target state="translated">Alvestrand,Harald Tveit。1995.</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">要时刻保持文明。</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">始终检查系统调用的返回码。好的错误消息应该发送到 &lt;code&gt;STDERR&lt;/code&gt; ，包括引起问题的程序，失败的系统调用和参数是什么，并且（非常重要）应包含发生错误的标准系统错误消息。这是一个简单但足够的示例：</target>
        </trans-unit>
        <trans-unit id="c9f2011c5ea88ecfcfb89f58ad78e623f2ab76d8" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt;, include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">始终检查系统调用的返回码。良好的错误消息应该发送到 &lt;code&gt;STDERR&lt;/code&gt; ，包括引起问题的程序，失败的系统调用和参数是什么，并且（非常重要）应包含发生错误的标准系统错误消息。这是一个简单但足够的示例：</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">总是将对配置变量的更改提交到磁盘上?</target>
        </trans-unit>
        <trans-unit id="c9994fb26151727507038319136d7dd61608906c" translate="yes" xml:space="preserve">
          <source>Always comparing to a version object will help avoid surprises:</source>
          <target state="translated">总是与版本对象进行比较将有助于避免意外。</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">总是在进来的时候分解,然后在出去的时候重新分解。</target>
        </trans-unit>
        <trans-unit id="a981ab84adf96ff26a362806abc6776217d3e6df" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%X&lt;/code&gt;, the locale's appropriate time representation.</source>
          <target state="translated">始终求值为 &lt;code&gt;%X&lt;/code&gt; ，这是区域设置的适当时间表示形式。</target>
        </trans-unit>
        <trans-unit id="36ade828ef985c357a4f590a718feea06b8ef69f" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%c&lt;/code&gt;, the locale's appropriate date and time representation.</source>
          <target state="translated">始终求值为 &lt;code&gt;%c&lt;/code&gt; ，该语言环境是适当的日期和时间表示形式。</target>
        </trans-unit>
        <trans-unit id="500eaed1bf2ab70574a92f0ee3e10b9af4499072" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%x&lt;/code&gt;, the locale's appropriate date representation.</source>
          <target state="translated">始终求值为 &lt;code&gt;%x&lt;/code&gt; ，这是区域设置的适当日期表示形式。</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">总是显式地立即调用任何管道的可写端close(),除非该进程确实在向它写东西。即使不显式地调用close(),Perl仍然会在全局销毁期间关闭()所有文件柄。正如前面所讨论的,如果这些文件柄已经用Safe Pipe Open打开了,这将导致调用waitpid(),这可能会再次出现死锁。</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">始终在声明 &lt;code&gt;my_cxt_t&lt;/code&gt; 之后直接放置START_MY_CXT宏。</target>
        </trans-unit>
        <trans-unit id="2a1f78b377f3f4dbcc2f8cd296fbf35bd7322707" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt;.</source>
          <target state="translated">始终在声明 &lt;code&gt;my_cxt_t&lt;/code&gt; 之后直接放置START_MY_CXT宏。</target>
        </trans-unit>
        <trans-unit id="891f99ab9e41224456357d41b700c51457def43d" translate="yes" xml:space="preserve">
          <source>Always quote the version</source>
          <target state="translated">总是引用版本</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">总是努力保持与以前发布的版本兼容。否则,如果人们依赖旧的行为,尽量添加一个机制来恢复它。记录不兼容的变化。</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">如果包中有SIGNATURE文件并且安装了Module::Signature,总是尝试检查和验证签名(是/否)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">总是尝试用'd'和'm'命令显示上传日期(是/否)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">始终使用&lt;b&gt;-w&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f5dc9ef4a983f2881df95298081703042e4c314a" translate="yes" xml:space="preserve">
          <source>Always use a dotted-decimal with (at least) three components</source>
          <target state="translated">始终使用含有(至少)三个成分的点阵小数。</target>
        </trans-unit>
        <trans-unit id="1af0291b70c5a30fa81736f480600ed39cabe174" translate="yes" xml:space="preserve">
          <source>Always use a leading-v</source>
          <target state="translated">始终使用导语-v</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">一定要和子标签一起使用。值得注意的形式:{sgn-gb}。{sgn-gb}英国手语(BSL);{sgn-ie}。爱尔兰手语(ESL);{sgn-ni}。尼加拉瓜手语(ISN);{sgn-us}。美国手语(ASL);</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">模糊的当地时间(DST)</target>
        </trans-unit>
        <trans-unit id="60b78dd3bc38b79497387b8798a6af56908b3286" translate="yes" xml:space="preserve">
          <source>Ambiguous call resolved as CORE::%s(), qualify as such or use &amp;amp;</source>
          <target state="translated">歧义呼叫解析为CORE ::％s（），具有此类资格或使用＆</target>
        </trans-unit>
        <trans-unit id="81d6325a5322b24a8cad3df61889fcccc37da082" translate="yes" xml:space="preserve">
          <source>Ambiguous range in transliteration operator</source>
          <target state="translated">译名运算符中的模糊范围</target>
        </trans-unit>
        <trans-unit id="edda76ce0ef49493fbd99f6a03d679fce823d7ca" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c resolved as operator %c</source>
          <target state="translated">模糊使用%c的问题解决为运算符%c。</target>
        </trans-unit>
        <trans-unit id="97f919429ce49eab88ebaca27d4b763e67507277" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s[...]} resolved to %c%s[...]</source>
          <target state="translated">模糊使用%c{%s[...]}解决为%c%s[...]。</target>
        </trans-unit>
        <trans-unit id="3c963134cf7d24b861988abb82e92519a22caf5a" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s{...}} resolved to %c%s{...}</source>
          <target state="translated">模糊使用%c{%s{...}},解决为%c%s{...}。</target>
        </trans-unit>
        <trans-unit id="57d7860a6ad7ad4f88f893704243eeb8b4377d90" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s} resolved to %c%s</source>
          <target state="translated">模糊使用%c{%s},解决为%c%s。</target>
        </trans-unit>
        <trans-unit id="d67f229db4a4d1b5f2225b9846f84a14f01ccc8d" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %s resolved as %s</source>
          <target state="translated">含糊不清地使用%s,解决为%s。</target>
        </trans-unit>
        <trans-unit id="59caacddbf40a7be1f1b173255e30458a45962f9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of -%s resolved as -&amp;amp;%s()</source>
          <target state="translated">-％s的歧义使用解析为-＆％s（）</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">Amiga开发者环境</target>
        </trans-unit>
        <trans-unit id="e2b08dd8d56c6933a46584a5b28aac8a3ed2befa" translate="yes" xml:space="preserve">
          <source>Amiga Specific Modules</source>
          <target state="translated">Amiga专用模块</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="e6b810bb50ff4aa9149ad36bef5c0f4e23da0b22" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx</source>
          <target state="translated">Amiga::ARexx</target>
        </trans-unit>
        <trans-unit id="01a8977a9be8d612968643e3bf495cf6b7267806" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx - Perl extension for ARexx support</source>
          <target state="translated">Amiga::ARexx-支持ARexx的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="8adf028f8c6d2a6a1f2e1490947a8c498843d956" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx METHODS</source>
          <target state="translated">Amiga::ARexx METHODS</target>
        </trans-unit>
        <trans-unit id="b06d09541ec208da13b7be9ff5bbfee7e66e27b2" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx::Msg METHODS</source>
          <target state="translated">Amiga::ARexx::Msg METHODS</target>
        </trans-unit>
        <trans-unit id="4c7974d6ce506c1fbe8763064a655033977f865b" translate="yes" xml:space="preserve">
          <source>Amiga::Exec</source>
          <target state="translated">Amiga::Exec</target>
        </trans-unit>
        <trans-unit id="d165b945227b32b2aec4eb213a7b6887056e595f" translate="yes" xml:space="preserve">
          <source>Amiga::Exec - Perl extension for low level amiga support</source>
          <target state="translated">Amiga::Exec-用于支持低级amiga的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="6763cfad1bb35aed134ab02bf5d64d5a57ca8187" translate="yes" xml:space="preserve">
          <source>Amnesty will prevent a failed assertion from causing the overall test to fail. In other words it marks a failure as expected and allowed.</source>
          <target state="translated">赦免将防止一个失败的论断导致整体测试失败。换句话说,它将失败标记为预期和允许。</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">在IBM EBCDIC字符代码集中,有13个字符经常被映射成不同的整数值。这些字符被称为13个 &quot;变体 &quot;字符,它们是:</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">在为OS/2所做的改变中,有...</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">一个&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，根本不包含任何&amp;ldquo; = item&amp;rdquo;段落，并且仅包含一些普通/普通段落，还可能包含一些嵌套的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，&amp;ldquo; = for ...&amp;rdquo;段落和&amp;ldquo; = begin&amp;rdquo; ...&amp;ldquo; = end&amp;rdquo;区域。Pod中这种无项目的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域在含义上等同于HTML中的&amp;ldquo; &amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;&amp;rdquo;元素。</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">一个&quot;=over&quot;...&quot;=back &quot;区域只包含&quot;=item *&quot;命令,每个命令后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;...。&quot;=back &quot;区域只包含&quot;=item *&quot;命令,每个命令后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;.&quot;=back &quot;区域,&quot;=for...&quot;段,以及&quot;=begin&quot;.&quot;=end &quot;区域。&quot;=回 &quot;区域、&quot;=for.&quot;段落和&quot;=begin&quot;...&quot;=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">一个&quot;=over&quot;.&quot;=back &quot;区域,只包含&quot;=item[text]&quot;命令,每个命令(或每组命令)后面是一些普通/逐字段,其他嵌套的&quot;=over&quot;.。&quot;=back &quot;区域只包含&quot;=项[案文]&quot;命令,每个命令(或每组命令)后面都有一些普通/逐字段,其他嵌套的&quot;=over&quot;.&quot;=back &quot;区域,或&quot;=for.&quot;段落,以及&quot;=begin&quot;.&quot;=end &quot;区域。&quot;=back &quot;区域,或&quot;=for.&quot;段落,以及&quot;=begin&quot;.&quot;=end &quot;区域。</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">一个&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，仅包含 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 段落，每个段落（或其每组）后跟一些普通/普通段落，其他嵌套的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，&amp;ldquo; = for ...&amp;rdquo;段落和/或&amp;ldquo; = begin&amp;rdquo; ...&amp;ldquo; = end&amp;rdquo;代码。请注意，每个部分中的数字必须从1开始，并且必须按顺序进行且不能跳过数字。</target>
        </trans-unit>
        <trans-unit id="927c2fc26d9fdc3522cb89e03e51cb9a3f52db71" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">一个&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，仅包含 &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; 段落，每个段落（或其每组）后跟一些普通/普通段落，其他嵌套的&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;区域，&amp;ldquo; = for ...&amp;rdquo;段落和/或&amp;ldquo; = begin&amp;rdquo; ...&amp;ldquo; = end&amp;rdquo;代码。请注意，数字必须在每个部分中从1开始，并且必须按顺序进行并且不能跳过数字。</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">一个 &quot;独立 &quot;的子表达式,它与一个 &quot;独立 &quot;的子串相匹配。</target>
        </trans-unit>
        <trans-unit id="16be1ac4526418524ec7dfd0204b1847a01b249e" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a standalone</source>
          <target state="translated">一个 &quot;独立 &quot;的子表达式,它与独立的子串相匹配。</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">&amp;ldquo; perlio&amp;rdquo;的&amp;ldquo;内部&amp;rdquo;派生词，可用于为没有缓冲区或无法打扰的图层提供Unread（）函数。（基本上，该层的 &lt;code&gt;Fill()&lt;/code&gt; 将自身弹出堆栈，因此可以从下面的层继续读取。）</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">可能会更改的&amp;ldquo;内部&amp;rdquo;方法，当前会被调用以允许覆盖的类缓存信息，这些信息随后将传递给所有 &lt;code&gt;*param*&lt;/code&gt; 调用。（是的，必须阅读源代码才能理解这是一个已知的错误）。</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">一个$eol为&quot;&quot;(空字符串)是特殊的。在这种情况下,没有引入 &quot;软换行&quot;,二进制模式被有效地启用,因此原始数据中的任何&quot;\n &quot;也会被编码。</target>
        </trans-unit>
        <trans-unit id="5a6a13a346ab7340f151e0f470997f73ed378c5a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; without an argument uses the last file read. Using &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; to be examined to determine if input is available. Similarly, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; list, and if you haven't set &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt;, will read input from &lt;code&gt;STDIN&lt;/code&gt;; see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">没有参数的&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;使用最后读取的文件。将&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;与空括号一起使用是不同的。它是指由命令行上列出的文件形成并通过 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符访问的伪文件。由于未显式打开 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此就像正常的文件句柄一样，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前的&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;将导致检查&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;以确定输入是否可用。同样， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 返回文件末尾后的&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;会假定您正在处理另一个&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;列表，如果未设置&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;，则会从 &lt;code&gt;STDIN&lt;/code&gt; 读取输入; 请参阅&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop中的&amp;ldquo; I / O操作员&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1711b8c03a9928dbbe638d8c791d95aa2c85763c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">在&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;声明声明了一个包变量，这将是在其整个词法范围可见，甚至可以跨越边界包的别名。输入变量的包是在声明时确定的，而不是在使用时确定的。这意味着以下行为成立：</target>
        </trans-unit>
        <trans-unit id="b91de5a24da27e5fce41ca7887051c5441493c51" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">在&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;声明也可能有与之相关的属性列表。</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">一个&lt;b&gt;XSUB&lt;/b&gt;形成XS接口的基本单元。由&lt;b&gt;xsubpp&lt;/b&gt;编译器编译后，每个XSUB等于一个C函数定义，它将提供Perl调用约定和C调用约定之间的粘合。</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">一个&lt;b&gt;匿名&lt;/b&gt;子例程，当在运行时生成对它的引用时，即使在那些词法变量超出&lt;b&gt;范围的情况下&lt;/b&gt;，它也跟踪外部可见的&lt;b&gt;词法变量&lt;/b&gt;的标识。之所以称为&amp;ldquo;封闭&amp;rdquo;，是因为这种行为使数学家感到封闭。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">一种&lt;b&gt;参数&lt;/b&gt;传递机制，其中&lt;b&gt;形式参数&lt;/b&gt;直接引用&lt;b&gt;实际参数&lt;/b&gt;，&lt;b&gt;子例程&lt;/b&gt;可以通过更改形式参数来更改实际参数。也就是说，形式参数是实际参数的&lt;b&gt;别名&lt;/b&gt;。另请参见&lt;b&gt;按值调用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">一种&lt;b&gt;说法&lt;/b&gt; -passing机构，其中，&lt;b&gt;形式参数&lt;/b&gt;指的副本&lt;b&gt;实际参数&lt;/b&gt;和&lt;b&gt;子程序&lt;/b&gt;不能改变形式参数改变实际参数。另请参阅&lt;b&gt;按引用致电&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">在当前匹配位置左侧偷看字符串的&lt;b&gt;断言&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">在当前匹配位置右侧偷看字符串的&lt;b&gt;断言&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;声明&lt;/b&gt;某事物存在的&lt;b&gt;断言&lt;/b&gt;，也许描述了它的样子，但未对使用方式或使用地点做出任何承诺。声明就像食谱中的部分一样：&amp;ldquo;两杯面粉，一个大鸡蛋，四个或五个t&amp;hellip;&amp;hellip;&amp;rdquo;参见相反的&lt;b&gt;说法&lt;/b&gt;。请注意，某些声明也可以用作语句。如果提供了主体，则子例程声明也可以用作定义。</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">一个&lt;b&gt;属性&lt;/b&gt;的的&lt;b&gt;对象&lt;/b&gt; ; 与特定对象而不是整个类一起存储的数据。</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">该&lt;b&gt;表达式的&lt;/b&gt;计算结果可以用作&lt;b&gt;文件句柄&lt;/b&gt;：&lt;b&gt;字符串&lt;/b&gt;（文件句柄名称），&lt;b&gt;typeglob&lt;/b&gt;，typeglob &lt;b&gt;引用&lt;/b&gt;或低级&lt;b&gt;IO&lt;/b&gt;对象。</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">的&lt;b&gt;表达&lt;/b&gt;能产生一个&lt;b&gt;值&lt;/b&gt;，一个&lt;b&gt;操作者&lt;/b&gt;进行操作。另请参见&lt;b&gt;priority&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">知道如何增加ASCII字母和数字的&lt;b&gt;增量&lt;/b&gt;运算符。</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">一个&lt;b&gt;类&lt;/b&gt;的&lt;b&gt;实例&lt;/b&gt;。&amp;ldquo;知道&amp;rdquo;用户定义的类型（类）以及由于其是什么类而可以执行的操作。您的程序可以请求一个对象执行操作，但是该对象可以决定是否要执行操作。有些物体比其他物体更容易容纳。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">一个&lt;b&gt;对象&lt;/b&gt;是一个数据结构捆绑数据和子程序，其在该数据一起操作。对象的数据称为&lt;b&gt;属性&lt;/b&gt;，其子例程称为&lt;b&gt;方法&lt;/b&gt;。可以将对象视为名词（一个人，一个Web服务，一台计算机）。</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; &lt;b&gt;文字&lt;/b&gt;的&lt;b&gt;运算符&lt;/b&gt; X ，例如输出抓取运算符&amp;lt;literal moreinfo =&amp;ldquo; none&amp;rdquo; `&amp;gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运算符&lt;/b&gt;取三个&lt;b&gt;操作数&lt;/b&gt;。有时发音为&lt;b&gt;三元&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">的&lt;b&gt;操作者&lt;/b&gt;，其之间进来&lt;b&gt;的操作数&lt;/b&gt;，如在乘法 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f71291b7c0cc8bd6ef4195e1d392449e6f1d53" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt;.</source>
          <target state="translated">的&lt;b&gt;操作者&lt;/b&gt;，其之间进来&lt;b&gt;的操作数&lt;/b&gt;，如在乘法 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">使用值列表（例如 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; )执行某些&lt;b&gt;操作的运算符&lt;/b&gt;。通常用于命名的内置运算符（例如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ），这些运算符不需要在&lt;b&gt;参数&lt;/b&gt;列表中加括号。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74d9d7e2bcff5578ed582b2be81c1fd95c4fc9ac" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">用值列表做某事的&lt;b&gt;运算符&lt;/b&gt;，例如 &lt;code&gt;join&lt;/code&gt; 或 &lt;code&gt;grep&lt;/code&gt; 。通常用于命名的内置运算符（例如 &lt;code&gt;print&lt;/code&gt; ， &lt;code&gt;unlink&lt;/code&gt; 和 &lt;code&gt;system&lt;/code&gt; ），这些运算符不需要在其&lt;b&gt;参数&lt;/b&gt;列表周围加括号。</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;遵循它的&lt;b&gt;操作&lt;/b&gt;，如 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2a91b007dceec65feca65e72cf86b169ecd0ff6" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt;.</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;遵循它的&lt;b&gt;操作&lt;/b&gt;，如 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;先于它的&lt;b&gt;操作数&lt;/b&gt;，如 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25f284ffc65045a6c69870223421c5797a335e9" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt;.</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;先于它的&lt;b&gt;操作数&lt;/b&gt;，如 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运算符&lt;/b&gt;，它对一对&lt;b&gt;操作数&lt;/b&gt;说出特定的排序关系是否&lt;b&gt;成立&lt;/b&gt;。Perl同时具有数字和字符串关系运算符。请参阅&lt;b&gt;整理顺序&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">一个&lt;b&gt;操作者&lt;/b&gt;围绕其&lt;b&gt;操作数&lt;/b&gt;，如操作者的角度，或括号，或一个拥抱。</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">带有两个&lt;b&gt;操作数&lt;/b&gt;的&lt;b&gt;运算符&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;运营商&lt;/b&gt;，其分配的任务在生活中改变的价值&lt;b&gt;变量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">一个&lt;b&gt;普通款&lt;/b&gt;。如果段落的第一行既不匹配 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 也不匹配 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ，则为普通段落。</target>
        </trans-unit>
        <trans-unit id="8dd7686cbc9fa2ea98c8a7eb1004bca8a6b2e068" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt;,</source>
          <target state="translated">一个&lt;b&gt;普通款&lt;/b&gt;。如果段落的第一行既不匹配 &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; 也不匹配 &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ，则它是普通段落。</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">没有参数的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 使用最后读取的文件。将 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 与空括号一起使用是不同的。它是指由命令行上列出的文件形成并通过 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符访问的伪文件。由于未显式打开 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此就像正常的文件句柄一样，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 将导致检查 &lt;code&gt;@ARGV&lt;/code&gt; 以确定输入是否可用。同样， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 返回文件结束后的 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 会假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从 &lt;code&gt;STDIN&lt;/code&gt; 读取输入; 请参阅&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">在 &lt;code&gt;DB&lt;/code&gt; 包中定义的子例程中执行的 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 不会看到通常的周围词汇范围，而是看到了调用它的第一个非DB代码段的范围。除非您正在编写Perl调试器，否则通常不必担心这一点。</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">没有参数的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 使用最后读取的文件。将 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 与空括号一起使用是不同的。它是指由命令行上列出的文件形成并通过 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符访问的伪文件。由于未显式打开 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，因此就像正常的文件句柄一样，使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 将导致检查 &lt;code&gt;@ARGV&lt;/code&gt; 以确定输入是否可用。同样， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 返回文件结束后的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 会假定您正在处理另一个 &lt;code&gt;@ARGV&lt;/code&gt; 列表，如果未设置 &lt;code&gt;@ARGV&lt;/code&gt; ，则会从 &lt;code&gt;STDIN&lt;/code&gt; 读取输入; 请参阅&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 函数，但是，可以看到它是在被评估的范围的词法变量，只要名字被声明的内不隐藏 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 函数本身。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">在 &lt;code&gt;DB&lt;/code&gt; 包中定义的子例程中执行的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; 不会看到通常的周围词汇范围，而是看到了调用它的第一个非DB代码段的范围。除非您正在编写Perl调试器，否则通常不必担心这一点。</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明声明了一个包变量，这将是在其整个词法范围可见，甚至可以跨越边界包的别名。输入变量的包是在声明时确定的，而不是在使用时确定的。这意味着以下行为成立：</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明也可能有与之相关的属性列表。</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明声明了一个包变量，这将是在其整个词法范围可见，甚至可以跨越边界包的别名。输入变量的包是在声明时确定的，而不是在使用时确定的。这意味着以下行为成立：</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明也可能有与之相关的属性列表。</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">一个 &lt;code&gt;=item&lt;/code&gt; 或 &lt;code&gt;=back&lt;/code&gt; 命令已经发现外 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="74ddbf837617e690734ce4e331574925980ad4cf" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">一个 &lt;code&gt;=item&lt;/code&gt; 或 &lt;code&gt;=back&lt;/code&gt; 命令已经发现外 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">一个 &lt;code&gt;END&lt;/code&gt; 码块被尽可能晚地，即，是perl的已经完成运行程序和要退出的解释之前之后执行，即使它离开作为模具（）函数的结果。 （但是如果通过 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 转换为另一个程序，或者被信号吹走，则不是（您必须自己捕获（如果可以）。）文件中可能有多个 &lt;code&gt;END&lt;/code&gt; 块，它们将以相反的顺序执行；即：后进先出（LIFO）。使用 &lt;code&gt;-c&lt;/code&gt; 开关运行perl 或编译失败时，将不执行 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="e942cc0968d145d9b00a1b1c78467e33e46acc43" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;exec&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">一个 &lt;code&gt;END&lt;/code&gt; 码块被尽可能晚地，即，是perl的已经完成运行程序和要退出的解释之前之后执行，即使它离开作为模具（）函数的结果。（但是如果通过 &lt;code&gt;exec&lt;/code&gt; 转换为另一个程序，或者被信号吹掉，则不是这样（您必须自己捕获（如果可以的话）。）您可能在文件中包含多个 &lt;code&gt;END&lt;/code&gt; 块），它们将以相反的顺序执行；即：后进先出（LIFO）。使用 &lt;code&gt;-c&lt;/code&gt; 开关运行perl或编译失败时，将不执行 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="2e32fa7ec52528fa53daf789a891351a0047191f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; object.</source>
          <target state="translated">一个 &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">一个 &lt;code&gt;IO::Handle&lt;/code&gt; 目的是一个符号/ GLOB基准的基准（参见 &lt;code&gt;Symbol&lt;/code&gt; 包）。继承自 &lt;code&gt;IO::Handle&lt;/code&gt; 某些模块可能希望将与对象相关的变量保留在GLOB的哈希表部分中。为了防止模块相互踩踏，我建议任何这样的模块都应在其变量前加上用_分隔的自己的名称。例如，IO :: Socket模块将 &lt;code&gt;timeout&lt;/code&gt; 变量保留在&amp;ldquo; io_socket_timeout&amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="ddbf17a10e023000ccc30961ca5b0d4cd79dd73a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">在 &lt;code&gt;DB&lt;/code&gt; 程序包中定义的子例程中执行的 &lt;code&gt;eval ''&lt;/code&gt; 不会看到通常围绕的词汇范围，而是看到了调用它的第一个非DB代码段的范围。除非您正在编写Perl调试器，否则通常不必担心这一点。</target>
        </trans-unit>
        <trans-unit id="daf77a66a50c9398b1fd7246b531ff3583302d3a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval()&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;eval()&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;eval()&lt;/code&gt; 函数，但是，可以看到它是在被评估的范围的词法变量，只要名字被声明的内不隐藏 &lt;code&gt;eval()&lt;/code&gt; 函数本身。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4327b0847cdc34977cdbdda7e68546f97fba6ace" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;https&lt;/code&gt; connection may be made via an &lt;code&gt;http&lt;/code&gt; proxy that supports the CONNECT command (i.e. RFC 2817). You may not proxy &lt;code&gt;https&lt;/code&gt; via a proxy that itself requires &lt;code&gt;https&lt;/code&gt; to communicate.</source>
          <target state="translated">的 &lt;code&gt;https&lt;/code&gt; 连接可经由进行 &lt;code&gt;http&lt;/code&gt; 代理支持CONNECT命令（即RFC 2817）。您不能通过本身需要 &lt;code&gt;https&lt;/code&gt; 进行通信的代理来代理 &lt;code&gt;https&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb7b8e2c63742b11c42dcae1ac500eab80f3ab56" translate="yes" xml:space="preserve">
          <source>An Array Reference</source>
          <target state="translated">阵列参考</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">关于更智能、更安全的代码的补充说明</target>
        </trans-unit>
        <trans-unit id="3b01e7833f6ef8368a6a19aec43504160373e004" translate="yes" xml:space="preserve">
          <source>An E&amp;lt;...&amp;gt; surrounding strange content</source>
          <target state="translated">围绕奇怪内容的E &amp;lt;...&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e626c65821f55eedc24b3d056f760901055b33ab" translate="yes" xml:space="preserve">
          <source>An Error Handler</source>
          <target state="translated">错误处理程序</target>
        </trans-unit>
        <trans-unit id="d96ae95b9e6d2684c36b739e4e16b84332bd4be3" translate="yes" xml:space="preserve">
          <source>An Event-Driven Program</source>
          <target state="translated">一个事件驱动的计划</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">一个例子</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">一个例子--NULL终止问题。</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">一个例子:NULL终止问题。</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">应该包含一个INSTALL文件,并且应该包含简单的安装说明。当使用ExtUtils::MakeMaker时,这通常是。</target>
        </trans-unit>
        <trans-unit id="506b7c2a6739d4b086313431ab2d8807d26d26ea" translate="yes" xml:space="preserve">
          <source>An Input FileGlob string</source>
          <target state="translated">一个输入的FileGlob字符串</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">可以指定一个OFFSET以将读取的数据放置在字符串中除开头之外的其他位置。负OFFSET指定从字符串末尾开始倒数的许多字符的位置。大于SCALAR长度的正OFFSET会导致在追加读取结果之前，使用 &lt;code&gt;&quot;\0&quot;&lt;/code&gt; 字节将字符串填充为所需的大小。</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">可以指定一个OFFSET,从字符串的某些部分而不是开头写入数据。负的OFFSET指定从字符串的结尾向后数写那么多的字符,如果SCALAR长度为0,则只能使用0的OFFSET。如果SCALAR的长度为0,则只能使用0的OFFSET。</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">对象只是一个数据结构</target>
        </trans-unit>
        <trans-unit id="a75b7e5900f9f9a5e2336a6194fd54179bb27c7e" translate="yes" xml:space="preserve">
          <source>An Output FileGlob</source>
          <target state="translated">一个输出的FileGlob</target>
        </trans-unit>
        <trans-unit id="813d4e6c344e0e779c908b93f3b8922ba5b51b2f" translate="yes" xml:space="preserve">
          <source>An RDF vocabulary to describe software projects. &lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;.</source>
          <target state="translated">用于描述软件项目的RDF词汇表。&lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2be5f7e627a6ada01e5f83f900c749a12504c5b" translate="yes" xml:space="preserve">
          <source>An RPN expression can also be interpreted in another way, as a sequence of operations on a stack, one operation per token. A literal or variable token pushes a value onto the stack. A binary operator pulls two items off the stack, performs a calculation with them, and pushes the result back onto the stack. The stack starts out empty, and at the end of the expression there must be exactly one value left on the stack.</source>
          <target state="translated">RPN表达式也可以用另一种方式来解释,作为堆栈上的操作序列,每个令牌一个操作。一个文字或变量标记将一个值推到堆栈上。一个二进制操作符从栈中抽取两个项目,对它们进行计算,并将结果推回栈中。栈开始时是空的,在表达式结束时,栈上必须只剩下一个值。</target>
        </trans-unit>
        <trans-unit id="451423395ae3ecccc772428a72078e3af59aea77" translate="yes" xml:space="preserve">
          <source>An RPN expression may be any of:</source>
          <target state="translated">区域网络的表达方式可以是以下任何一种:</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">一个SV(或AV、HV等)是由两部分分配的:头部(struct sv,av,hv...)包含类型和引用计数信息,对于许多类型来说,还有一个指向主体(struct xrv,xpv,xpviv...)的指针,它包含每个类型特有的字段。有些类型在头部存储了所有需要的信息,所以没有主体。</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">可以使用一个命令创建并加载SV。可以加载五种类型的值：整数（IV），无符号整数（UV），双精度（NV），字符串（PV）和另一个标量（SV）。（&amp;ldquo; PV&amp;rdquo;代表&amp;ldquo;指针值&amp;rdquo;。您可能会误认为它是因为它被描述为仅指向字符串。但是，也可能使它指向其他东西。例如，它可以指向一个数组。但是，将其用于非字符串需要特别小心，因为许多内部结构的基本假设是PV仅用于字符串，例如，通常会自动添加尾随的 &lt;code&gt;NUL&lt;/code&gt; 。仅在本段中记录。）</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">SV可以作为第二个参数传递。如果是这样,将为其分配名称,并将其返回。否则,返回的SV将是一个新的凡人。</target>
        </trans-unit>
        <trans-unit id="7e60a0da99f77ec00184644cb08929c2fbb88e98" translate="yes" xml:space="preserve">
          <source>An URL for a bug tracker (e.g. Bugzilla or RT queue) for this project.</source>
          <target state="translated">本项目的错误跟踪器(如Bugzilla或RT队列)的URL。</target>
        </trans-unit>
        <trans-unit id="5cb53ac6b527ff22855aa21b588aeb5e456de693" translate="yes" xml:space="preserve">
          <source>An URL for an official statement of this distribution's license.</source>
          <target state="translated">本发行版许可证的官方声明的URL。</target>
        </trans-unit>
        <trans-unit id="c8d6fdbeeb22295aa04aac68ad9fd7f77cf9046a" translate="yes" xml:space="preserve">
          <source>An XS module that is locale-dependent could have been written under the assumption that it will never be called in a multi-threaded environment, and so uses other non-locale constructs that aren't multi-thread-safe. See &lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;&quot;Thread-aware system interfaces&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">依赖于语言环境的XS模块可以在不会在多线程环境中被调用的假设下编写，因此它使用了不是多线程安全的其他非语言环境构造。请参见&lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;perlxs中的&amp;ldquo;线程感知系统接口&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">一个XSUB节继续进行,直到找到另一个节开始的关键字。</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">抽象字符的整数值。与&lt;b&gt;codepoint&lt;/b&gt;相同。</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">可以重新定义访问器函数，以提供对值的附加检查，等等。在这里，我们希望 &lt;code&gt;count&lt;/code&gt; 元素始终为非负数，因此我们重新定义了 &lt;code&gt;count&lt;/code&gt; 访问器。</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">访问器让你可以围绕属性访问添加额外的代码。例如,你可以对一个没有在构造函数中设置的属性应用一个默认值,或者你可以验证一个新的属性值是可以接受的。</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">终止流程的操作将终止</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">一个实际的数据,相对于所有的变量、引用、键、索引、运算符什么的,你需要访问这个值。</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个形容词伪函数，以某种声明方式扭曲&lt;b&gt;左值&lt;/b&gt;的含义。当前有三个左值修饰符： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="147929b2af4f7b23dfdf17e155cb639bdee82ce1" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, and &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">形容词伪函数，以某种声明方式扭曲&lt;b&gt;左值&lt;/b&gt;的含义。当前有三个左值修饰符： &lt;code&gt;my&lt;/code&gt; ， &lt;code&gt;our&lt;/code&gt; 和 &lt;code&gt;local&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="450e105909f5464a91b8d711013a548cdad0ecea" translate="yes" xml:space="preserve">
          <source>An algorithm to map a character set to a byte sequence. You don't have to be able to tell which character set a given byte sequence belongs. 7-bit ISO-2022 is a CES but it cannot be a CCS. EUC is an example of being both a CCS and CES.</source>
          <target state="translated">一种将字符集映射到字节序列的算法。你不需要知道一个给定的字节序列属于哪个字符集。7位ISO-2022是一个CES,但它不能成为CCS。EUC是一个既是CCS又是CES的例子。</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">别名可以映射到正式的Unicode字符名称（而不是宽松的匹配名称）或数字代码点（常规）。后者对于将名称分配给Unicode专用区域（例如U + E800至U + F8FF）中的代码点很有用。数字代码点必须是非负整数，或者以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 开头的字符串，其余部分视为十六进制整数。文字数字常量必须是无符号的；如果前导零或包含非十进制十六进制数字，则将其解释为十六进制；否则将被解释为十进制。如果以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 开头，则将其解释为Unicode代码点；否则，将其解释为Unicode代码点。否则，它将被解释为本地的。 （只有256以下的代码点在Unicode和本机之间可以有所不同。）因此 &lt;code&gt;U+41&lt;/code&gt; 始终是拉丁字母&amp;ldquo; A&amp;rdquo;；但是 &lt;code&gt;0x41&lt;/code&gt; 在EBCDIC平台上可以是&amp;ldquo; NO-BREAK SPACE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="307b5df586934d78ce8b5dabe9ab9b8c2f875563" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">别名可以映射到正式的Unicode字符名称（而不是宽松的匹配名称）或数字代码点（常规）。后者对于将名称分配给Unicode专用区域（例如U + E800至U + F8FF）中的代码点很有用。数字代码点必须是非负整数，或者以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;0x&quot;&lt;/code&gt; 开头的字符串，其余部分视为十六进制整数。文字数字常量必须是无符号的；如果前导零或包含非十进制十六进制数字，则将其解释为十六进制；否则将被解释为十进制。如果以 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; 开头，则将其解释为Unicode代码点；否则，将其解释为Unicode代码点。否则，它将被解释为本地的。 （只有256以下的代码点在Unicode和本机之间可以有所不同。） 因此 &lt;code&gt;U+41&lt;/code&gt; 始终是拉丁字母&amp;ldquo; A&amp;rdquo;；但是 &lt;code&gt;0x41&lt;/code&gt; 在EBCDIC平台上可以是&amp;ldquo; NO-BREAK SPACE&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">全名的别称</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn()的别称。</target>
        </trans-unit>
        <trans-unit id="0f9c5134c84e70c19466ac6665667bdc11f335df" translate="yes" xml:space="preserve">
          <source>An alphanumeric name preceded by dollar sign refers to a Perl scalar variable. Only variables declared with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; are supported. If the variable's value is not a native integer, it will be converted to an integer, by Perl's usual mechanisms, at the time it is evaluated.</source>
          <target state="translated">以美元符号开头的字母数字名称是指Perl标量变量。仅支持使用 &lt;code&gt;my&lt;/code&gt; 或 &lt;code&gt;state&lt;/code&gt; 声明的变量。如果变量的值不是本机整数，则在评估时将通过Perl的常用机制将其转换为整数。</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">另一种在堆栈上推送值的方法(可能更简单)是使用宏。</target>
        </trans-unit>
        <trans-unit id="1921a2093ccc86489ce0ad3cb2bb5dbbb1b5fcf0" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;指定替代定界符。</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">可以使用&lt;b&gt;-F&lt;/b&gt;指定替代分隔符。</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">备用文件名，它指向真实&lt;b&gt;文件名&lt;/b&gt;，而真实&lt;b&gt;文件名&lt;/b&gt;又指向真实&lt;b&gt;文件&lt;/b&gt;。每当&lt;b&gt;操作系统&lt;/b&gt;尝试解析包含符号链接的&lt;b&gt;路径名时&lt;/b&gt;，它仅替换新名称并继续解析。</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Call的备用接口现在可用。有关更多详细信息，请参见&lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="309e6a9857cb37095aa6e70561b74ca78f25b7d4" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;Filter::Simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">现在可以使用Filter :: Util :: Call的备用接口。有关更多详细信息，请参见&lt;a href=&quot;Filter::Simple&quot;&gt;Filter :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1c89b199090d1d97e837c8f064d662931bf60c5" translate="yes" xml:space="preserve">
          <source>An alternate way to create a new version object is through the exported qv() sub. This is not strictly like other q? operators (like qq, qw), in that the only delimiters supported are parentheses (or spaces). It is the best way to initialize a short version without triggering the floating point interpretation. For example:</source>
          <target state="translated">另一种创建新版本对象的方法是通过导出的qv()子。这与其他q?运算符(如qq、qw)不同,严格来说,支持的定界符只有括号(或空格)。这是初始化一个短版本而不触发浮点解释的最好方法。例如</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">缓存刷新的另一种方法是使用 &lt;code&gt;HASH&lt;/code&gt; 选项（请参见上文）来请求 &lt;code&gt;Memoize&lt;/code&gt; 使用特定的哈希变量作为其缓存。然后，您可以随时以所需的任何方式检查或修改哈希。您可以使用 &lt;code&gt;%hash = ()&lt;/code&gt; 刷新缓存。</target>
        </trans-unit>
        <trans-unit id="e8b6136f62918ff1ea1ed138ea0c96c6d31fc586" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt;.</source>
          <target state="translated">缓存刷新的另一种方法是使用 &lt;code&gt;HASH&lt;/code&gt; 选项（请参见上文）来请求 &lt;code&gt;Memoize&lt;/code&gt; 使用特定的哈希变量作为其缓存。然后，您可以随时以所需的任何方式检查或修改哈希。您可以使用 &lt;code&gt;%hash = ()&lt;/code&gt; 刷新缓存。</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">另一种选择是CamelBones，该框架允许访问Foundation和AppKit类和对象，从而可以在Perl中构建完整的GUI应用程序。可以在SourceForge的&lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;上找到CamelBones 。</target>
        </trans-unit>
        <trans-unit id="5b9956d0c6aedc296243c0a951b58bd48cc08ba5" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">另一种选择是CamelBones，该框架允许访问Foundation和AppKit类和对象，以便可以在Perl中构建完整的GUI应用程序。可以在SourceForge的&lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/&lt;/a&gt;上找到CamelBones 。</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">调试正则表达式的另一种方法是将 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 语句嵌入正则表达式中。这提供了轮流回溯的交替介绍：</target>
        </trans-unit>
        <trans-unit id="d38adacc9748189f199af8dc89eab5c14ea53178" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;print&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">调试正则表达式的另一种方法是将 &lt;code&gt;print&lt;/code&gt; 语句嵌入正则表达式中。这提供了交替跟踪回溯的详尽描述：</target>
        </trans-unit>
        <trans-unit id="797f91185d7afbacb2d3c5eed6df4adbd22d2a7d" translate="yes" xml:space="preserve">
          <source>An alternative reference is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">另一种参考是Info-Zip应用笔记。可从&lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/获得&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="577bb949a7cbee63183e379cdce8743144bb2e97" translate="yes" xml:space="preserve">
          <source>An alternative to using &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将&lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt;用作左值的另一种方法是将替换字符串指定为第4个参数。这样一来，您就可以替换EXPR的各个部分，并像执行&lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt; &lt;code&gt;splice&lt;/code&gt; &lt;/a&gt;一样，返回一次之前的操作。</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">使用substr()作为l值的替代方法是指定替换字符串作为第4个参数。这允许您替换EXPR的部分内容,并在一次操作中返回之前的内容,就像您使用splice()一样。</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">用C语言编写过滤器的另一种方法是使用您选择的语言创建一个单独的可执行文件。单独的可执行文件从标准输入读取，进行必要的处理，然后将过滤后的数据写入标准输出。 &lt;code&gt;Filter::cpp&lt;/code&gt; 是作为独立可执行文件实现的源过滤器的示例-可执行文件是与C编译器捆绑在一起的C预处理程序。</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">一种比较容易写出东西的另一种方式;一种捷径。</target>
        </trans-unit>
        <trans-unit id="d69bfaa7d98ebed8954a924a638458e2ecf0b867" translate="yes" xml:space="preserve">
          <source>An alternative way to achieve this can be seen in &lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2::CodeGen&lt;/a&gt; and &lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib::CodeGen&lt;/a&gt;.</source>
          <target state="translated">实现此目标的另一种方法可以在&lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2 :: CodeGen&lt;/a&gt;和&lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib :: CodeGen中&lt;/a&gt;看到。</target>
        </trans-unit>
        <trans-unit id="3719242868ba601b24b2c4019225372b6d1ba5a6" translate="yes" xml:space="preserve">
          <source>An alternatively is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">另一种方法是Info-Zip应用笔记。可从&lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/获得&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">一个在基本的regexps中有用的锚是</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">一个匿名的备选库规格数组,用于搜索(按顺序),直到至少找到一个库。例如</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">麻烦使用 &lt;code&gt;LC_MONETARY&lt;/code&gt; 中的信息的应用程序可能会格式化借方，就好像它们是贷方，反之亦然，如果该语言环境已被颠覆。或者，它可能以美元而不是港元付款。</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">一个使用Module的应用程序可以说这样的话。</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">一种更正确的&lt;b&gt;列表上下文&lt;/b&gt;的过时表达。</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">可以通过在参数声明中省略名称的主要部分来忽略自变量，仅留下 &lt;code&gt;$&lt;/code&gt; sigil。例如，</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">一个参数行,提供插入前一个图片行的值。</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">一个数组也可以改变其长度。</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">通过指定美元符号（ &lt;code&gt;$&lt;/code&gt; ），数组名称（不带 &lt;code&gt;@&lt;/code&gt; ），方括号内的下标，可以一次访问一个标量。例如：</target>
        </trans-unit>
        <trans-unit id="540cdd79efe573437a7605791a2eb1616100de60" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt;), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt;), then the subscript inside square brackets. For example:</source>
          <target state="translated">通过指定美元符号（ &lt;code&gt;$&lt;/code&gt; ），数组名称（不带前导 &lt;code&gt;@&lt;/code&gt; ），方括号内的下标，可以一次访问一个标量数组。例如：</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">数组的数组只是一个常规的旧数组@AoA，您可以使用两个下标来获取它们，例如 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 。这是数组的声明：</target>
        </trans-unit>
        <trans-unit id="11613ff6241b5d0054882bce3b479c51b671807c" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt;. Here's a declaration of the array:</source>
          <target state="translated">数组的数组只是一个常规的旧数组@AoA，您可以使用两个下标来获取它们，例如 &lt;code&gt;$AoA[3][2]&lt;/code&gt; 。这是数组的声明：</target>
        </trans-unit>
        <trans-unit id="ae61cf59e4cd9db6ee9b5a175cc315be8ef10741" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;&quot;C_constant&quot;&lt;/a&gt;.</source>
          <target state="translated">常量名称的数组，常量可以是包含名称的标量，也可以是&lt;a href=&quot;#C_constant&quot;&gt;&amp;ldquo; C_constant&amp;rdquo;中&lt;/a&gt;详细说明的hashrefs。</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">常量名称的数组，常量可以是包含名称的标量，也可以是C_constant中详细说明的&lt;a href=&quot;#C_constant&quot;&gt;hashrefs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">被加载的共享对象的文件名数组。</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">已被引导的模块(包)名称的数组。</target>
        </trans-unit>
        <trans-unit id="e8f1da37492eab7b118aed0b3744e018cc0392dd" translate="yes" xml:space="preserve">
          <source>An array of non-negative integers that is used for comparison purposes with other version objects.</source>
          <target state="translated">一个非负整数的数组,用于与其他版本对象进行比较。</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">CPAN或本地磁盘上的修补程序阵列，可通过外部修补程序按顺序应用。 &lt;code&gt;-p&lt;/code&gt; 参数的值是 &lt;code&gt;0&lt;/code&gt; 还是 &lt;code&gt;1&lt;/code&gt; 是通过事先阅读补丁来确定的。每个补丁程序的路径要么是本地文件系统上的绝对路径，要么是相对于 &lt;code&gt;patches_dir&lt;/code&gt; 配置变量中指定的补丁程序目录的相对路径，或者是规范发行版名称的格式。有关示例，请查阅CPAN.pm发行版中的distroprefs /目录（默认情况下未安装这些示例）。</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">由bootstrap成功调用dl_load_file()后返回的句柄数组,按照加载顺序排列。可以和dl_find_symbol()一起使用,在任何一个加载的文件中寻找一个符号。</target>
        </trans-unit>
        <trans-unit id="c823d47a703f9ce8bdd6c6bd99c53c578f964658" translate="yes" xml:space="preserve">
          <source>An array reference</source>
          <target state="translated">一个数组引用</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">一个数组代表一个值的列表。</target>
        </trans-unit>
        <trans-unit id="7ce42eb4fb16bbef377321c32853b8f06079f21c" translate="yes" xml:space="preserve">
          <source>An array which exposes the contents of the capture buffers, if any, of the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="translated">一个数组,它暴露了捕获缓冲区的内容,如果有的话,最后一个成功的模式匹配,不计算已经退出的嵌套块中匹配的模式。</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">具有多个下标的数组，用于查找单个元素。Perl使用&lt;b&gt;参考来&lt;/b&gt;实现这些功能，请&lt;b&gt;参见&lt;/b&gt; Camel第9章&amp;ldquo;数据结构&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">尝试 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; 失败，即使扩展列表表明应该成功。通过进行正确的安装进行纠正。</target>
        </trans-unit>
        <trans-unit id="f00d85ec569efd3d0ba1b09d16f4a00196ee0d74" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">尝试 &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; 失败，即使扩展列表表明应该成功也是如此。通过进行正确的安装进行纠正。</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">试图分配内存失败。</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">尝试设置无法识别的属性是一个致命错误。（该错误是可捕获的，但仍会在该 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中停止编译。）将属性设置为全都是小写字母的名称，而不是内置属性（例如&amp;ldquo; foo&amp;rdquo;），将导致显示&lt;b&gt;-w&lt;/b&gt;或警告。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24018dbac9a81adda03170beee4acf228798de6" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;eval&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;use warnings 'reserved'&lt;/code&gt;.</source>
          <target state="translated">尝试设置无法识别的属性是一个致命错误。（该错误是可捕获的，但仍会在该 &lt;code&gt;eval&lt;/code&gt; 中停止编译。）将属性设置为全都是小写字母的名称，而不是内置属性（例如&amp;ldquo; foo&amp;rdquo;），将导致警告&lt;b&gt;-w&lt;/b&gt;或 &lt;code&gt;use warnings 'reserved'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 指定了一个属性处理程序，但是定义为处理的引用对象的类型不是所允许的五种之一： &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; ， &lt;code&gt;CODE&lt;/code&gt; 或 &lt;code&gt;ANY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be2ec17006c02c47726210c596c995f951690163" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, or &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; 指定了一个属性处理程序，但是定义为处理的引用对象的类型不是允许的五个值之一： &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; ， &lt;code&gt;CODE&lt;/code&gt; 或 &lt;code&gt;ANY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">属性是属于一个特定对象的一段数据。与大多数面向对象的语言不同,Perl并没有为属性的声明和操作提供特殊的语法或支持。</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">属性列表是一系列属性说明，用空格或冒号（带有可选的空格）分隔。每个属性规范都是一个简单的名称，可以选择后面跟一个带括号的参数列表。如果存在这样的参数列表，则按照 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 运算符的规则进行扫描。 （请参阅&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop中的Quote和类似Quote的运算符&lt;/a&gt;。）但是，参数列表是按发现时传递的，而不是按照 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="cc6c334100243f2c62d45354cd17461eb4374199" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;q()&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;q()&lt;/code&gt;.</source>
          <target state="translated">属性列表是一系列属性说明，用空格或冒号（带有可选的空格）分隔。每个属性规范都是一个简单的名称，可以选择后面跟一个带括号的参数列表。如果存在这样的参数列表，则将其扫描过去，以查找 &lt;code&gt;q()&lt;/code&gt; 运算符的规则。 （请参阅&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop中的&amp;ldquo;类似于Quote和Quote的运算符&amp;rdquo;&lt;/a&gt;。）但是，参数列表是按发现时传递的，而不是按照 &lt;code&gt;q()&lt;/code&gt; 传递。</target>
        </trans-unit>
        <trans-unit id="f9a21fa1e7844543aacf6b214485b949a7b1705b" translate="yes" xml:space="preserve">
          <source>An early change, in fact the change that made Test2 an idea, was a change to the indentation of the subtest note. It was decided it would be more readable to outdent the subtest note instead of having it inline with the subtest:</source>
          <target state="translated">早期的一个变化,事实上是使Test2成为一个想法的变化,是对小测试说明的缩进进行了修改。当时的决定是,将小测试说明的缩进放在外面,而不是与小测试并列,这样会更易读。</target>
        </trans-unit>
        <trans-unit id="6356b19b83a0de734fd036ef3412ad9e0499e73b" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt;. This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt;, and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">通过写 &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt; &lt;i&gt;pattern&lt;/i&gt;））\ g {-1}可以达到类似于 &lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; 的效果。它与独立的 &lt;code&gt;a+&lt;/code&gt; 匹配相同的子字符串，并且随后的 &lt;code&gt;\g{-1}&lt;/code&gt; 使用匹配的字符串；因此，它将零长度断言声明为 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 的类似物。（这两种构造之间的区别在于，第二种构造使用捕获组，因此会在正则表达式的其余部分中移动反向引用的序数。）&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">通过写 &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 可以达到类似于 &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; 的效果。它与独立的 &lt;code&gt;a+&lt;/code&gt; 匹配相同的子字符串，随后的 &lt;code&gt;\g{-1}&lt;/code&gt; 将使用匹配的字符串；因此，它将零长度断言声明为 &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; 的类似物。（这两种构造之间的区别在于，第二种构造使用捕获组，因此会在正则表达式的其余部分中移动反向引用的序数。）</target>
        </trans-unit>
        <trans-unit id="c5d792d65a737f380eae7ddca70051ed5bf418d1" translate="yes" xml:space="preserve">
          <source>An embedded perl needs to be started up while the global locale is in effect. See &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;&quot;Using embedded Perl with POSIX locales&quot; in perlembed&lt;/a&gt;.</source>
          <target state="translated">全局语言环境生效时，需要启动嵌入式perl。请参阅&lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;perlembed中的&amp;ldquo;在POSIX语言环境中使用嵌入式Perl&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65503b1bc3cc6e29b56e0751024a1c32f6babaa5" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">空的 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830fe5530bf8a388dd3b4e1cd4354d40bf489efb" translate="yes" xml:space="preserve">
          <source>An empty E&amp;lt;&amp;gt;</source>
          <target state="translated">空的E &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1de720044af3435092cdfe83370a7cafc924ed83" translate="yes" xml:space="preserve">
          <source>An empty X&amp;lt;&amp;gt;</source>
          <target state="translated">空的X &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">当EXPR的开头有一个正宽度的匹配时,会产生一个空的前导字段。例如:</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">遇到明确的 &lt;code&gt;break&lt;/code&gt; 便会清空一个列表。</target>
        </trans-unit>
        <trans-unit id="39e866d4dec47e8ffded31535bf330825a29cb83" translate="yes" xml:space="preserve">
          <source>An empty list, in list context</source>
          <target state="translated">一个空列表,在列表上下文中</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">另一方面,当EXPR的末尾有一个匹配时,就会产生一个空的尾部字段,而不管匹配的长度如何(当然,除非明确给出一个非零的LIMIT,否则这种字段会被删除,就像上一个例子一样)。因此。</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">附魔，幻觉，幻象或魔术 说到Perl神奇的&lt;b&gt;微光&lt;/b&gt;效果没有达到您的预期，而是奥秘的产物</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">在多个&lt;b&gt;进程&lt;/b&gt;之间进行网络通信的端点，其工作原理类似于电话或邮政信箱。套接字最重要的是它的&lt;b&gt;网络地址&lt;/b&gt;（如电话号码）。不同种类的套接字具有不同种类的地址-有些看起来像文件名，有些却没有。</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">整个计算机程序挤在一行文字里。</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">由数字(十进制、十六进制、八进制)指定的实体超出范围(1-255)。</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">形式为 &lt;code&gt;-La:\foo&lt;/code&gt; 的条目指定 &lt;code&gt;a:\foo&lt;/code&gt; 目录以查找后面的库。</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">形式 &lt;code&gt;-lfoo&lt;/code&gt; 的条目指定库 &lt;code&gt;foo&lt;/code&gt; ，库的拼写可能有所不同，具体取决于您使用的是哪种编译器。如果使用的是GCC，它将转换为 &lt;code&gt;libfoo.a&lt;/code&gt; ，但对于其他win32编译器，它将变为 &lt;code&gt;foo.lib&lt;/code&gt; 。如果这些转换后的名称未找到文件，则分别尝试使用 &lt;code&gt;foo.a&lt;/code&gt; 或 &lt;code&gt;libfoo.lib&lt;/code&gt; 来查找它们，具体取决于使用的是GCC还是其他Win32编译器。</target>
        </trans-unit>
        <trans-unit id="b955ec169e3cf404a025241c85cc35d91ed6e518" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt;, which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt;, but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt;. If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt;, depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">形式 &lt;code&gt;-lfoo&lt;/code&gt; 的条目指定库 &lt;code&gt;foo&lt;/code&gt; ，库的拼写可能有所不同，具体取决于您使用的是哪种编译器。如果使用的是GCC，它将转换为 &lt;code&gt;libfoo.a&lt;/code&gt; ，但对于其他win32编译器，它将变为 &lt;code&gt;foo.lib&lt;/code&gt; 。如果这些转换后的名称未找到文件，则分别尝试使用 &lt;code&gt;foo.a&lt;/code&gt; 或 &lt;code&gt;libfoo.lib&lt;/code&gt; 来查找它们，具体取决于是否使用了GCC或其他某些win32编译器。</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">匹配 &lt;code&gt;/:nodefault/i&lt;/code&gt; 的条目将禁用附加在 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 找到的默认库（应该很少使用）。</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">匹配 &lt;code&gt;/:nosearch/i&lt;/code&gt; 的条目将禁用所有在其后指定的库的搜索。 &lt;code&gt;-Lfoo&lt;/code&gt; 和 &lt;code&gt;-lfoo&lt;/code&gt; 的翻译仍然会适当地进行（取决于所使用的编译器，如 &lt;code&gt;$Config{cc}&lt;/code&gt; 所反映），但是未验证条目是否为有效的文件或目录。</target>
        </trans-unit>
        <trans-unit id="0f36c83e40eae68ee067d041dd5eaac816d400ba" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt;), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">匹配 &lt;code&gt;/:nosearch/i&lt;/code&gt; 的条目将禁用所有在其之后指定的库的搜索。 &lt;code&gt;-Lfoo&lt;/code&gt; 和 &lt;code&gt;-lfoo&lt;/code&gt; 的翻译仍会适当地进行（取决于所使用的编译器，如 &lt;code&gt;$Config{cc}&lt;/code&gt; 所反映），但是未验证条目是否为有效的文件或目录。</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">匹配 &lt;code&gt;/:search/i&lt;/code&gt; 的条目可重新搜索其后指定的库。您可以将其放在最后以启用搜索 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的默认库。</target>
        </trans-unit>
        <trans-unit id="58b3df12b9c4c1391c5d6a764ee07751d9f03ea6" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt;.</source>
          <target state="translated">匹配 &lt;code&gt;/:search/i&lt;/code&gt; 的条目可重新搜索其后指定的库。您可以将其放在最后以启用搜索 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的默认库。</target>
        </trans-unit>
        <trans-unit id="764e7bd0665e9fa3ca103f1f3c69a2b0a336ccc2" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file</source>
          <target state="translated">一个Perl类型标志的枚举。这些标志可以在文件</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perl类型的标志的枚举。这些在文件中找到&lt;b&gt;sv.h&lt;/b&gt;在 &lt;code&gt;svtype&lt;/code&gt; 枚举。使用 &lt;code&gt;SvTYPE&lt;/code&gt; 宏测试这些标志。</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">一个枚举值。用于从C中传输一个枚举组件。没有理由将一个枚举值传给C,因为它在perl中是作为IV存储的。</target>
        </trans-unit>
        <trans-unit id="22fd110d7c238cdd41592c0a602172ada41cc36a" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">使用环境变量，而不是使用并行变量本身，因为&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;需要能够自己计划各个不冲突的测试脚本，并且没有标准接口可以 &lt;code&gt;make&lt;/code&gt; 实用程序与其作业计划程序进行交互。</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">使用环境变量，而不是使用并行变量本身，因为&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;需要能够自己计划各个不冲突的测试脚本，并且没有标准接口可以 &lt;code&gt;make&lt;/code&gt; 实用程序与其作业计划程序进行交互。</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">发生错误（对于 &lt;code&gt;PerlIO_error()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3d508ac8c71c775f43142d23e442e2000fbf79e9" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt;).</source>
          <target state="translated">发生错误（对于 &lt;code&gt;PerlIO_error()&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">任何良好的开发过程的一个重要部分是适当的错误处理,并提供适当的信息,然而有一派观点认为,日志文件应该是</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">甚至更陌生的模板代码是 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c948915c37e1832c4cdb4ea5562b06199c7d0645" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt;&amp;lt;</source>
          <target state="translated">甚至更陌生的模板代码是 &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">导致&lt;b&gt;处理程序&lt;/b&gt;运行的事件。</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">类型映射的结构 &lt;code&gt;foo_t *&lt;/code&gt; 的转换函数示例可能是：</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">一个在socket上禁用Nagle算法的例子。</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">以俄语和一些使用西里尔字母的语言为例。</target>
        </trans-unit>
        <trans-unit id="62a8d925afd0ed802ddeaf7e7056d235e6263d4e" translate="yes" xml:space="preserve">
          <source>An example may make this clearer:</source>
          <target state="translated">举个例子可能会更清楚。</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">一个Perl代码可以看到的所有阶段的例子。</target>
        </trans-unit>
        <trans-unit id="b3f8fac7e809f312cdc7e6d944996bb2ded1f5bf" translate="yes" xml:space="preserve">
          <source>An example of how this is used is the &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt; formatter. For unbuffered subtests the events are rendered as they are generated. At the end of the subtest, the final subtest event is rendered, but the &lt;code&gt;subevents&lt;/code&gt; attribute is ignored. For buffered subtests the opposite occurs, the events are NOT rendered as they are generated, instead the &lt;code&gt;subevents&lt;/code&gt; attribute is used to render them all at once. This is useful when running subtests tests in parallel, since without it the output from subtests would be interleaved together.</source>
          <target state="translated">如何使用此方法的一个示例是&lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2 :: Formatter :: TAP&lt;/a&gt;格式化程序。对于无缓冲的子测试，事件在生成时呈现。在子测试的末尾，将呈现最终的子测试事件，但 &lt;code&gt;subevents&lt;/code&gt; 属性将被忽略。对于缓冲的子测试，情况恰恰相反，事件生成时不进行渲染，而是使用 &lt;code&gt;subevents&lt;/code&gt; 属性来一次渲染所有事件。当并行运行子测试测试时，这很有用，因为如果没有它，子测试的输出将被交织在一起。</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">以下是一个如何使用这种方法的例子:</target>
        </trans-unit>
        <trans-unit id="5a34b3fb3e9dbd7f514687e325a9fcbdaa8609fe" translate="yes" xml:space="preserve">
          <source>An example of this is</source>
          <target state="translated">这方面的一个例子是</target>
        </trans-unit>
        <trans-unit id="af46ea4947cfe8e14d48ae32223fb001ec7bc498" translate="yes" xml:space="preserve">
          <source>An example of using Name property wildcards is</source>
          <target state="translated">使用 Name 属性通配符的一个例子是</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">例如,输出可以是:</target>
        </trans-unit>
        <trans-unit id="d132f664732cae183fc32adf49e25fe3aca9db69" translate="yes" xml:space="preserve">
          <source>An example taken from an article posted to comp.lang.perl.misc</source>
          <target state="translated">从发布在comp.lang.perl.misc上的一篇文章中截取的一个例子。</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">一个例子的用法是这样的。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一个例子:</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">一个例外</target>
        </trans-unit>
        <trans-unit id="af317c13cfaee4d2548fba4cee59592a6612afcd" translate="yes" xml:space="preserve">
          <source>An exception event will display to STDERR, and will prevent the overall test file from passing.</source>
          <target state="translated">异常事件将显示到STDERR,并将阻止整体测试文件的通过。</target>
        </trans-unit>
        <trans-unit id="66ab19b971476be687f1585d2d4d367fb367ec27" translate="yes" xml:space="preserve">
          <source>An exception is considered to match a string if:</source>
          <target state="translated">如果出现以下情况,则认为异常与一个字符串相匹配。</target>
        </trans-unit>
        <trans-unit id="441facb85290f4d6c3e35bab01158ccc81039064" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is that &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms.</source>
          <target state="translated">上面规则的一个例外是 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 始终被解释为Unicode代码点，因此即使在EBCDIC平台上， &lt;code&gt;\N{U+0050}&lt;/code&gt; 也是 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">例外情况是您可以在列表中分配给 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。这对于丢弃函数的某些返回值很有用：</target>
        </trans-unit>
        <trans-unit id="b907b876869fb91f8d35b06170f79ee9f948ffa2" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;undef&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">例外情况是您可以在列表中分配给 &lt;code&gt;undef&lt;/code&gt; 。这对于丢掉函数的某些返回值很有用：</target>
        </trans-unit>
        <trans-unit id="6d1bf7c1ca3df304818b1a482b2ae19817ae3aee" translate="yes" xml:space="preserve">
          <source>An exception will be raised if &lt;code&gt;verify_SSL&lt;/code&gt; is true and no CA certificate file is available.</source>
          <target state="translated">如果 &lt;code&gt;verify_SSL&lt;/code&gt; 为true，并且没有CA证书文件，将引发异常。</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">在 PA-RISC 2.0 平台上编译的可执行文件不会在 PA-RISC 1.1 平台上执行,即使它们运行的是相同版本的 HP-UX。如果您在PA-RISC 2.0平台上构建Perl,并希望该Perl也能在PA-RISC 1.1平台上运行,则应使用编译器标志+DAportable和+DS32。</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">退出状态为0表示&amp;ldquo;成功&amp;rdquo;。例如，如果两个文件具有相同的内容，则&lt;b&gt;diff（1）&lt;/b&gt;的状态为0退出。</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">退出状态为1表示可能异常终止，但程序完好无损。例如，&lt;b&gt;grep（1）&lt;/b&gt;退出时状态为1</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">退出状态为2或更大意味着存在致命错误。例如，如果您在命令行上指定了非法（未知）选项，&lt;b&gt;ls（1）&lt;/b&gt;将以状态2退出。</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">一种实验性的假层,可去除最上层。使用时应注意与硝酸甘油相同。</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">有关VMS文件规范的说明，请访问&lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">显式格式参数索引，例如 &lt;code&gt;2$&lt;/code&gt; 。默认情况下，sprintf将格式化列表中下一个未使用的参数，但这使您可以使参数乱序：</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">探讨基于EBCDIC计算机的Perl程序员面临的一些问题。</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">一个表达式,当其值发生变化时,会在Perl调试器中引起一个断点。</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">扩展是从Perl调用已编译的C代码的一种方式。阅读&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;是学习更多有关扩展的好地方。</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">通过上述步骤建立的扩展可以在支持动态加载的系统上使用。在不支持动态加载的系统上,任何新创建的扩展都必须与可用资源链接在一起。MakeMaker通过在Makefile中创建相应的目标来支持链接过程,每当建立一个扩展时。您可以在Makefile中调用相应的部分,用</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XS中&lt;/b&gt;定义的外部&lt;b&gt;子例程&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">额外字段由零个或多个子字段组成。每个子字段由一个两个字节的标题和子字段数据组成。</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">一个格外导出的、迅速优秀的、明确的eXternal子程序,用现有的C或C++或一个叫(令人气愤的)XS的激动人心的扩展语言执行。</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">一个非常轻量级的&lt;b&gt;DB_File&lt;/b&gt;包装器，在绑定数据库之前简单地锁定一个锁定文件，并在解开之后丢弃该锁定。如果需要，允许一个人对多个数据库使用相同的锁定文件，以避免死锁问题。用于读取更新的数据库非常快速，并且简单的集群锁定语义就足够了。</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">标识符（不一定与文件的真实名称相关），表示打开文件的特定实例，直到您将其关闭。如果您要连续打开和关闭几个不同的文件，则可以使用相同的文件句柄打开每个文件，因此不必不必编写单独的代码来处理每个文件。</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">即时过滤器允许您指定在过滤器应用于dbm时使用的过滤器代码。在这种模式下,Filter_*_Push方法需要接收两个参数。</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">不完善的标准</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">文摘算法的一个重要特性是文摘是</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">在选项名称后用加号 &lt;code&gt;+&lt;/code&gt; 指定增量选项：</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">可以从Unicode联盟（&lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html）&lt;/a&gt;在线获得字符名称索引。带有其他资源链接的说明性材料，&lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;网址&lt;/a&gt;为http://www.unicode.org/standard/where。</target>
        </trans-unit>
        <trans-unit id="00b6943f411e2de4ec124878b41ea6334f76e3b4" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">可以从Unicode联盟（&lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html）&lt;/a&gt;在线获取字符名称索引。带有其他资源链接的说明性材料，&lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;网址&lt;/a&gt;为https://www.unicode.org/standard/where。</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">间接文件柄是指在需要文件柄的地方使用符号以外的东西。以下是获取间接文件柄的方法。</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">可为您执行的每个测试存储一个可通过 &lt;code&gt;details()&lt;/code&gt; 访问的信息性哈希。因此，内存使用量将随着每次测试运行而线性扩展。尽管对于大多数测试套件而言这不是问题，但是如果您在同一运行中进行大型（数十万至百万）组合测试，则可能会成为问题。</target>
        </trans-unit>
        <trans-unit id="701384a60361f136947eccd77eb6f91598d0f6e9" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt;, is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">可为您执行的每个测试存储一个可通过 &lt;code&gt;details()&lt;/code&gt; 访问的信息性哈希。因此，内存使用量将随着每次测试运行而线性扩展。尽管对于大多数测试套件而言这不是问题，但是如果您在同一运行中进行大型（数十万至数百万）组合测试，则可能会成为问题。</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">使用源过滤的输入文件可能不会被解析为可运行的代码，因为即使生成的代码已经是普通的Perl，也不应再次对其进行过滤，但它仍将包含源过滤模块的&lt;b&gt;use&lt;/b&gt;声明。</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">通过将Unicode数据库从&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt;下载到 &lt;code&gt;$Config{privlib}&lt;/code&gt; /，安装程序可以选择允许其中任何一个匹配</target>
        </trans-unit>
        <trans-unit id="41c8e8c55ba26c070500d10138a4327fcb1ea456" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">安装程序可以选择将任何一个匹配，方法是将Unicode数据库从&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt;下载到 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="69c0036eb0cb2d7a6d6970ded97de6c5b5c6e80b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;https://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">安装程序可以选择将任何一个匹配，方法是将Unicode数据库从&lt;a href=&quot;https://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt;下载到 &lt;code&gt;$Config{privlib}&lt;/code&gt; /</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">正在运行的程序的实例。在像Unix这样的多任务系统下，两个或多个单独的进程可以同时独立运行同一程序-实际上， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 函数旨在实现这种愉快的状态。在其他操作系统下，进程有时称为&amp;ldquo;线程&amp;rdquo;，&amp;ldquo;任务&amp;rdquo;或&amp;ldquo;作业&amp;rdquo;，其含义通常略有细微差别。</target>
        </trans-unit>
        <trans-unit id="d7bfae97a3fa7902fae2c04baaa1f1c2a7428aa8" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;fork&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">正在运行的程序的实例。在诸如Unix之类的多任务系统下，两个或多个单独的进程可以同时独立运行同一程序-实际上， &lt;code&gt;fork&lt;/code&gt; 函数旨在实现这种愉快的状态。在其他操作系统下，有时将进程称为&amp;ldquo;线程&amp;rdquo;，&amp;ldquo;任务&amp;rdquo;或&amp;ldquo;作业&amp;rdquo;，其含义通常略有细微差别。</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">对余数感兴趣而不是商数的整数除数。</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">范围从0到1（含）的整数。信息存储的最小单位。八分之一&lt;b&gt;字节&lt;/b&gt;或一美元。（&amp;ldquo;八分之一&amp;rdquo;一词的含义是能够将旧的西班牙元分成8位，每位仍然算作货币。这就是为什么今天的25美分仍然是&amp;ldquo;两位&amp;rdquo;的原因。）</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII表中的32个C0控制字符的一个有趣特性是，它们可以在Perl中&amp;ldquo;按字面意义&amp;rdquo;构造为控制字符，例如 &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; ， 等等。已将EBCDIC平台上的Perl移植到 &lt;code&gt;\c@&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;\cA&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; 等等），但是产生的字符取决于您所使用的代码页。下表使用控件的标准首字母缩写词。 POSIX-BC和1047集在此范围内完全相同，而0037集仅在一个点（十进制21个）不同。注意，行终止字符可以由产生 &lt;code&gt;\cJ&lt;/code&gt; 上ASCII平台，但通过 &lt;code&gt;\cU&lt;/code&gt; 1047或POSIX-BC平台和不能被作为生成 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037平台上的控制字符。还要注意 &lt;code&gt;\c\&lt;/code&gt; 不能是字符串或正则表达式中的最后一个元素，因为它将吸收终止符。但是 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 是一个 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 与</target>
        </trans-unit>
        <trans-unit id="5ec5858c69c508303478b5682163ba9de4ba1b6f" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt;)&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt;)&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;chr(0)&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;chr(1)&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCII表中的32个C0控制字符的一个有趣特性是，它们可以在Perl中&amp;ldquo;按字面意义&amp;rdquo;构造为控制字符，例如 &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; ， 等等。 EBCDIC平台上的Perl也已移植，可以将 &lt;code&gt;\c@&lt;/code&gt; 为 &lt;code&gt;chr(0)&lt;/code&gt; ,并将 &lt;code&gt;\cA&lt;/code&gt; 为 &lt;code&gt;chr(1)&lt;/code&gt; 等，但是所产生的字符取决于您所使用的代码页。下表使用控件的标准首字母缩写词。 POSIX-BC和1047集在整个范围内是相同的，并且与0037集仅在一个点（十进制的21个）不同。请注意，行终止符可能由 &lt;code&gt;\cJ&lt;/code&gt; 生成在ASCII平台上，但由 &lt;code&gt;\cU&lt;/code&gt; 在1047或POSIX-BC平台上，并且不能生成为 &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037平台上的控制字符。还要注意 &lt;code&gt;\c\&lt;/code&gt; 不能是字符串或正则表达式中的最后一个元素，因为它将吸收终止符。但是 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 是一个 &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 与</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">内部的&amp;ldquo; glob值&amp;rdquo; typedef，保存一个&lt;b&gt;typeglob&lt;/b&gt;。的 &lt;code&gt;GV&lt;/code&gt; 类型是子类&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">内部I / O对象。也可以表示&lt;b&gt;间接对象&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">一个内部函数,用于生成嵌入的perl代码,该代码将再生常量子程序。</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">一个内部函数,用于生成嵌入的perl代码,以重新生成常量子程序。参数与C_constant相同。</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">生成合适的 &lt;code&gt;switch&lt;/code&gt; 子句的内部方法，由 &lt;code&gt;C_constant&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">程序的内部表示，其中较低级别的&lt;b&gt;构造物&lt;/b&gt;与包围它们的较高级别的构造物无关。</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">&amp;ldquo; push-pop&amp;rdquo;代码的内部简写；也就是说，C代码实现了Perl的堆栈机。</target>
        </trans-unit>
        <trans-unit id="2be767144e56c8e338304ff9f530373044c5bc8a" translate="yes" xml:space="preserve">
          <source>An internal variable used by &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;使用的内部变量。一个字符串，分为两个部分，用 &lt;code&gt;\0&lt;/code&gt; 字节分隔，第一部分描述输入层，第二部分描述输出层。</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIO使用的内部变量。一个字符串，分为两个部分，用 &lt;code&gt;\0&lt;/code&gt; 字节分隔，第一部分描述输入层，第二部分描述输出层。</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">找到了无效的POD命令。有效的是 &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=head2&lt;/code&gt; ，= head2， &lt;code&gt;=head3&lt;/code&gt; ， &lt;code&gt;=head4&lt;/code&gt; ， &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ， &lt;code&gt;=back&lt;/code&gt; ， &lt;code&gt;=begin&lt;/code&gt; ， &lt;code&gt;=end&lt;/code&gt; ， &lt;code&gt;=for&lt;/code&gt; ， &lt;code&gt;=pod&lt;/code&gt; ， &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="680a8cfcc47d942c4c76eb14d38af7a01657dc85" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt;, &lt;code&gt;=head2&lt;/code&gt;, &lt;code&gt;=head3&lt;/code&gt;, &lt;code&gt;=head4&lt;/code&gt;, &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, &lt;code&gt;=back&lt;/code&gt;, &lt;code&gt;=begin&lt;/code&gt;, &lt;code&gt;=end&lt;/code&gt;, &lt;code&gt;=for&lt;/code&gt;, &lt;code&gt;=pod&lt;/code&gt;, &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">找到了无效的POD命令。有效的是 &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=head2&lt;/code&gt; ，= head2， &lt;code&gt;=head3&lt;/code&gt; ， &lt;code&gt;=head4&lt;/code&gt; ， &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ， &lt;code&gt;=back&lt;/code&gt; ， &lt;code&gt;=begin&lt;/code&gt; ， &lt;code&gt;=end&lt;/code&gt; ， &lt;code&gt;=for&lt;/code&gt; ， &lt;code&gt;=pod&lt;/code&gt; ， &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">遇到无效的标记命令。有效的是： &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab0cc889ac8e69a2e34e2105510c7875248e79d9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">遇到无效的标记命令。有效值为： &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">项目&amp;ldquo; _ *&amp;rdquo;被解释为表示&amp;ldquo;除$ _ [0]之外的所有@_&amp;rdquo;。即 &lt;code&gt;@_[1..$#_]&lt;/code&gt; 。请注意，在调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="c7832bda7130f94045f7bfb60ec1dccf55e7e697" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt;. Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">项目&amp;ldquo; _ *&amp;rdquo;被解释为表示&amp;ldquo;除$ _ [0]之外的所有@_&amp;rdquo;。即 &lt;code&gt;@_[1..$#_]&lt;/code&gt; 。请注意，在调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">一个项目是&quot;_&quot;。</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">一个数字，指定要返回的最大字段数。如果省略此参数（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则拆分将继续尽可能长的时间。</target>
        </trans-unit>
        <trans-unit id="da38298cadbae3dcfcb616625cc2268ee1079670" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">一个数字，指定要返回的最大字段数。如果省略此参数（或 &lt;code&gt;undef&lt;/code&gt; ），则拆分将继续尽可能长的时间。</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">一个属于语言类的对象被称为 &quot;语言句柄&quot;;它通常是一个重量级对象。</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">与POD输入文本的段落相对应的对象。它可以是普通段落，逐字段落或命令段落（请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">对应于解析后的POD文本树的对象。解析树中的每一个 &quot;节点&quot;(或称</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">与来自POD输入文本的内部序列命令相对应的对象（请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">一个对象只是一个数据结构,知道它属于哪个类。</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">一个对象方法，用于将名字和姓氏初始化为其两个参数。如果作为类方法调用，则 &lt;code&gt;init()&lt;/code&gt; 将在给定的类中创建一个对象并将其初始化。</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">第一和第三种形式创建的类的对象是基于数组的,而第二种形式创建的类的对象是基于哈希的。基于数组的形式会更快、更小;基于哈希的形式则更灵活。</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive::Tar类的对象表示一个充满文件和事物的.tar(.gz)存档。</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">一个代表POD内部序列命令的对象。它有以下方法/属性。</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">一个代表POD输入文本段落的对象。它有以下方法/属性:</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">一个对象代表一个单一的离散事物。例如,一个对象可以代表一个文件。文件对象的属性可能包括它的路径、内容和最后修改时间。如果我们创建一个对象来表示</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">重载赋值操作符的对象只在对该对象的赋值方面进行重载。换句话说,Perl从来不会调用第三个参数(&quot;swap &quot;参数)设置为TRUE的相应方法。例如,操作</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">无法将对象的成员作为变量进行访问。 &lt;code&gt;with(object) { method() }&lt;/code&gt; 最接近的Perl 是 &lt;code&gt;for&lt;/code&gt; ，它可以将 &lt;code&gt;$_&lt;/code&gt; 别名为对象：</target>
        </trans-unit>
        <trans-unit id="667eaf5552288796413270dd142cf8898197f884" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt;, which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">无法将对象的成员作为变量进行访问。 &lt;code&gt;with(object) { method() }&lt;/code&gt; 最接近的Perl是 &lt;code&gt;for&lt;/code&gt; ，它可以将 &lt;code&gt;$_&lt;/code&gt; 作为对象的别名：</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">但是，对象是对祝福数据的引用，因此，如果 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 是对象，则赋值 &lt;code&gt;$a = $b&lt;/code&gt; 仅复制引用，而 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 引用同一对象数据。因此，人们可能期望的操作 &lt;code&gt;--$a&lt;/code&gt; 递减 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$a&lt;/code&gt; 。但是，这与我们期望数学运算符的工作方式不一致。</target>
        </trans-unit>
        <trans-unit id="25fb12e7db9c947b1012ab13c08ddc21606a22cc" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt;. However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">但是，对象是对祝福数据的引用，因此，如果 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 是对象，则赋值 &lt;code&gt;$a = $b&lt;/code&gt; 仅复制引用，而 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 引用相同的对象数据。因此，人们可能期望的操作 &lt;code&gt;--$a&lt;/code&gt; 递减 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$a&lt;/code&gt; 。但是，这与我们期望数学运算符的工作方式不一致。</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">旧的风格是使用裸词作为文件柄,如</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">运算符是Perl可以执行的基本操作:所有内置的函数和运算符都是运算符,还有一系列的运算符,这些运算符处理的是解释器内部需要的概念--进入和离开一个块,结束一个语句,获取一个变量等等。</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">一个只有一个&lt;b&gt;操作数的运算符&lt;/b&gt;，例如 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。一元运算符通常是前缀运算符；也就是说，它们在其操作数之前。该 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 运营商可以是前缀或后缀。（他们的位置</target>
        </trans-unit>
        <trans-unit id="2af9fb33db84bf30fe452d6a36fe8b4e335e0649" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;chdir&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">一个只有一个&lt;b&gt;操作数的运算符&lt;/b&gt;，例如 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;chdir&lt;/code&gt; 。一元运算符通常是前缀运算符；也就是说，它们在其操作数之前。该 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 运营商可以是前缀或后缀。 （他们的位置</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname 或 optag 可以用感叹号作为前缀,例如 !mkdir。否定一个 opname 或 optag 意味着在该点上将相应的 ops 从累计的 ops 集中删除。</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">模式或替代项的选项，例如 &lt;code&gt;/i&lt;/code&gt; ,以使模式不区分大小写。</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">您在命令行上提供的一个选项可以影响程序的工作方式，通常以减号开头。这个单词也用作&lt;b&gt;switch语句&lt;/b&gt;的昵称。</target>
        </trans-unit>
        <trans-unit id="eab6379d02e7da9bfe1cac71088e9311f2348060" translate="yes" xml:space="preserve">
          <source>An optional array of other socket options to apply after the three listed above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner array relates to a single option, giving the level and option name, and an optional value. If the value element is missing, it will be given the value of a platform-sized integer 1 constant (i.e. suitable to enable most of the common boolean options).</source>
          <target state="translated">在上面列出的三个套接字选项之后,可选择应用其他套接字选项的数组。值是一个包含2个或3个元素的ARRAYref的ARRAY。每个内部数组都与一个选项有关,给出级别和选项名称,以及一个可选的值。如果缺少值元素,它将被赋予一个平台大小的整数1常数的值(即适合启用大多数常见的布尔选项)。</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN发行版提供的可选功能</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">一个可选的文件柄(或 IO::Handle ),输出将被打印到。</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">一个可选的filehandle (或IO::Handle ),输出字符串将被打印到这个文件。</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">可选参数可以像强制参数一样是无名的。例如:</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;子例程&lt;/b&gt;声明的可选部分，它告诉Perl编译器可以作为&lt;b&gt;实际参数&lt;/b&gt;传递多少个参数以及哪种形式的参数可以作为&lt;b&gt;实际参数&lt;/b&gt;传递，因此您可以编写类似于内置函数一样进行分析的子例程调用。（或者视情况而定，不进行解析。）</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">可选的第三个参数可以用来指定用于复制的缓冲区大小。这是第一个文件的字节数,在写入第二个文件之前,在任何给定的时间都会被保存在内存中。默认的缓冲区大小取决于文件,但一般是整个文件(最大2MB),或者对于不引用文件的文件句柄(例如套接字)来说是1k。</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">存储有序的&lt;b&gt;值&lt;/b&gt;序列，以便您可以轻松地使用</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">一组有序的标量值。</target>
        </trans-unit>
        <trans-unit id="5c49a2821f5a5074f3f77a39e2cb0f3e615a425e" translate="yes" xml:space="preserve">
          <source>An ordinary disk file.</source>
          <target state="translated">一个普通的磁盘文件。</target>
        </trans-unit>
        <trans-unit id="a77cc50988bf220f630f8fad5e50fc8b8f153295" translate="yes" xml:space="preserve">
          <source>An ordinary hard disk partition.</source>
          <target state="translated">一个普通的硬盘分区。</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">概述Perl解释器的源代码和一些关于Perl如何做的细节。</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl源代码树的概述。这将帮助你找到你要找的文件。</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">未捕获的&lt;b&gt;异常&lt;/b&gt;，它会在&lt;b&gt;标准错误&lt;/b&gt;流上打印消息后导致&lt;b&gt;进程&lt;/b&gt;终止。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内发生的错误不是致命的。而是，将异常消息放入 &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）变量后， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 终止。您可以尝试通过 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 运算符引发致命错误（称为引发或引发异常），但是动态封闭 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可能会捕获此错误。如果未捕获，则 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 将成为致命错误。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a5d434a9faff9684c6af59ceb8c569c1859cc2" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;eval&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;eval&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt;) variable. You can try to provoke a fatal error with the &lt;code&gt;die&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;eval&lt;/code&gt;. If not caught, the &lt;code&gt;die&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">未捕获的&lt;b&gt;异常&lt;/b&gt;，它会在&lt;b&gt;标准错误&lt;/b&gt;流上打印一条消息后导致&lt;b&gt;进程&lt;/b&gt;终止。 &lt;code&gt;eval&lt;/code&gt; 内发生的错误不是致命的。相反，在将异常消息放入 &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）变量后， &lt;code&gt;eval&lt;/code&gt; 终止。您可以尝试使用 &lt;code&gt;die&lt;/code&gt; 运算符引发致命错误（称为引发或引发异常），但是动态封闭 &lt;code&gt;eval&lt;/code&gt; 可能会捕获此错误。如果未捕获，则 &lt;code&gt;die&lt;/code&gt; 将成为致命错误。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe98c7b5bde8acca47b9d777c6042909674e86b2" translate="yes" xml:space="preserve">
          <source>An unclosed formatting code</source>
          <target state="translated">一个未封闭的格式化代码</target>
        </trans-unit>
        <trans-unit id="96b48446507c5be16337d09d4b16f13d55933f7d" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip6_address is considered a fatal error.</source>
          <target state="translated">未定义的$port参数被视为零;未定义的$ip6_address被视为致命错误。</target>
        </trans-unit>
        <trans-unit id="3f9293e352420d9fd32f5883ba4908461fd77eae" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip_address is considered a fatal error.</source>
          <target state="translated">未定义的$port参数被视为零;未定义的$ip_address被视为致命错误。</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">未定义的值不允许用作记录分隔符。不模仿Perl的特殊&amp;ldquo;段落模式&amp;rdquo;语义（la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0407455390a08706db99e80a71be456dbdff3c3e" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt;) are not emulated.</source>
          <target state="translated">未定义的值不允许用作记录分隔符。不模仿Perl的特殊&amp;ldquo;段落模式&amp;rdquo;语义（la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">临时标量值的未命名列表，可以在程序内从任何列表生成函数传递到提供&lt;b&gt;列表上下文的&lt;/b&gt;任何函数或构造。</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">&lt;b&gt;键&lt;/b&gt; / &lt;b&gt;值&lt;/b&gt;对的无序关联，存储起来使得您可以轻松地使用字符串&lt;b&gt;键&lt;/b&gt;来查找其关联的数据&lt;b&gt;值&lt;/b&gt;。该词汇表就像一个哈希，其中要定义的单词是键，而定义是值。哈希有时有时也被单独称为&amp;ldquo;关联数组&amp;rdquo;，这是将其简单地称为&amp;ldquo;哈希&amp;rdquo;的一个很好的理由。</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">未设置或为空的PERLIO等效于平台的默认层集；例如 &lt;code&gt;:unix:perlio&lt;/code&gt; 类Unix系统 &lt;code&gt;:unix:crlf&lt;/code&gt; 在Windows和其他类似DOS系统。</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">一个无符号字节。</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">一个无符号整数。</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">作为PA-RISC设计的升级版,它在许多不同的系统中出货多年。</target>
        </trans-unit>
        <trans-unit id="05468cfd5e27b4298d95a71824d624b7c4dbc8a7" translate="yes" xml:space="preserve">
          <source>An xV that is visible at the Perl level should not become unreferenced and thus be destroyed. Normally, an object will only become unreferenced when it is no longer visible, often by the same means that makes it invisible. For example, a Perl reference value (RV) owns a reference to its referent, so if the RV is overwritten that reference gets destroyed, and the no-longer-reachable referent may be destroyed as a result.</source>
          <target state="translated">在 Perl 级别上可见的 xV 不应成为不可引用的对象,从而被销毁。通常情况下,只有当一个对象不再可见时,它才会成为未引用的对象,通常是通过使它不可见的相同手段。例如,一个 Perl 引用值 (RV)拥有对其引用的引用,所以如果 RV 被覆盖,该引用就会被销毁,而不再可见的引用也会因此被销毁。</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;pTHX&lt;/code&gt; 类似，当宏是多个参数中的第一个或最后一个时，存在等效形式，其中下划线表示逗号，即 &lt;code&gt;_aMY_CXT&lt;/code&gt; ， &lt;code&gt;aMY_CXT_&lt;/code&gt; ， &lt;code&gt;_pMY_CXT&lt;/code&gt; 和 &lt;code&gt;pMY_CXT_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39d947054eb91fd720a6dfc1c92ebab2af540974" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt;, there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt;, &lt;code&gt;aMY_CXT_&lt;/code&gt;, &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;pTHX&lt;/code&gt; 类似，当宏是多个参数中的第一个或最后一个时，存在等效形式，其中下划线表示逗号，即 &lt;code&gt;_aMY_CXT&lt;/code&gt; ， &lt;code&gt;aMY_CXT_&lt;/code&gt; ， &lt;code&gt;_pMY_CXT&lt;/code&gt; 和 &lt;code&gt;pMY_CXT_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">使用fbm_instr()--Boyer-Moore算法分析字符串,以便对其进行快速搜索。</target>
        </trans-unit>
        <trans-unit id="69b405aab620184a43024659654fa4b84c6160c1" translate="yes" xml:space="preserve">
          <source>Analyzes the string in order to make fast searches on it using &lt;code&gt;fbm_instr()&lt;/code&gt; -- the Boyer-Moore algorithm.</source>
          <target state="translated">分析字符串，以便使用 &lt;code&gt;fbm_instr()&lt;/code&gt; （博耶-摩尔算法）对它进行快速搜索。</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">Anantha Kesari H Y (hyanantha@novell.com)Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xs文件的解剖</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">类型图的解剖</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="126b187e44894c18f8676c982d3d84ada9d1092e" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">而&lt;a href=&quot;Bit::Vector&quot;&gt;位:: vector的&lt;/a&gt;支持奇数位计数：</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">而&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;位:: vector的&lt;/a&gt;支持奇数位计数：</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">并打印出我们当前使用的数值。</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">并在Mytest.t中添加以下代码,同时将 &quot;11 &quot;项测试递增为 &quot;13 &quot;项。</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">并在.xs文件的末尾添加以下函数定义。</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">而偶数位可以这样确定。</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">而且请不要忘记，除 &lt;code&gt;=encoding&lt;/code&gt; 之外的所有命令都将持续到其结束</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">和其他地方。</target>
        </trans-unit>
        <trans-unit id="81cb3b2a1b531c9a6c9a5580cd54769bc7cdb329" translate="yes" xml:space="preserve">
          <source>And especially its subject 8.</source>
          <target state="translated">尤其是其主体8。</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">即使你考虑到以上所有因素,ANSI仍然让这。</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">最后创建一个Makefile.PL文件,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">最后我们来测试，我们不作Unicode字符串，如果 &lt;code&gt;U&lt;/code&gt; 是&lt;b&gt;不是&lt;/b&gt;第一个活跃格式：</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">最后,END OF CHARMAP结束本节。</target>
        </trans-unit>
        <trans-unit id="2d457e986a9ae5a62a56559cd5a194f65f8d8696" translate="yes" xml:space="preserve">
          <source>And finally, in list context, it will try to extract as many objects from the stream as it can find and return them, or the empty list otherwise. For this to work, there must be no separators (other than whitespace) between the JSON objects or arrays, instead they must be concatenated back-to-back. If an error occurs, an exception will be raised as in the scalar context case. Note that in this case, any previously-parsed JSON texts will be lost.</source>
          <target state="translated">最后,在列表上下文中,它将尝试从流中提取尽可能多的对象,并返回它们,否则就是空列表。为了达到这个目的,JSON对象或数组之间必须没有分隔符(除了空格),相反,它们必须是背对背的连接。如果发生错误,将像在标量上下文情况下一样引发一个异常。请注意,在这种情况下,任何之前被分割的JSON文本都将丢失。</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">最后， &lt;code&gt;//&lt;/code&gt; 匹配的默认定界符可以通过在前面加上 &lt;code&gt;'m'&lt;/code&gt; 来更改为任意定界符：</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">最后,标志UNICODE_WARN_ILLEGAL_INTERCHANGE选择上述所有四个WARN标志;UNICODE_DISALLOW_ILLEGAL_INTERCHANGE选择所有四个DISALLOW标志。</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">并得到正确的结果。</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">并看一下返回值。</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">而这里有一些可供选择的便携方式来编写它们。</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">下面是一个例子</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">这里有一些Perl来测试它。</target>
        </trans-unit>
        <trans-unit id="eae54ac5b1d17fae865a39da8414bc4e94611b48" translate="yes" xml:space="preserve">
          <source>And here is the function from</source>
          <target state="translated">而这里的函数是来自</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">这是修改为使用 &lt;code&gt;comment&lt;/code&gt; 方法（需要绑定对象）的先前示例：</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">而这里是作为一个子程序,仿照上面的样子。</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">这是与之配套的相应服务器。我们将地址保留为 &lt;code&gt;INADDR_ANY&lt;/code&gt; ,以便内核可以在多宿主主机上选择适当的接口。如果您想坐在一个特定的接口上（例如网关或防火墙机器的外部），请用您的真实地址填写。</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">而这里是对应的服务器。在这里你不必担心愚蠢的网络终结器,因为Unix域名套接字保证在本地主机上,因此一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">这是一个多任务的版本。它的多任务性在于,像大多数典型的服务器一样,它产生(fork()s)一个从属服务器来处理客户的请求,这样主服务器就可以快速地回去服务一个新的客户。</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">这是Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 运算符的重新实现：</target>
        </trans-unit>
        <trans-unit id="328ddc059366c7b26584066902e71a55942bcb50" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;grep&lt;/code&gt; operator:</source>
          <target state="translated">这是Perl &lt;code&gt;grep&lt;/code&gt; 运算符的重新实现：</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">而这里有一个安全的管子开着写。</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">下面是它的使用方法。</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">而在这里,如何启动一个孩子的过程,你打算从。</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">这是 &lt;code&gt;HotKey&lt;/code&gt; 模块，它隐藏了一些令人迷惑的调用来操纵POSIX termios结构。</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">如果它是一个整数</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">并且，如果您使用的协议支持让接收者知道您使用了哪种字符编码的方式，请使用该功能来帮助接收方！例如，电子邮件和HTTP支持MIME标头，因此您可以使用 &lt;code&gt;Content-Type&lt;/code&gt; 标头。他们还可以使用 &lt;code&gt;Content-Length&lt;/code&gt; 来指示</target>
        </trans-unit>
        <trans-unit id="c041e6b2053eeffc72c3a76864ceba40caffea7d" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;&quot;*&quot;&lt;/code&gt;'s in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;&quot;*&quot;&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">而且，如果您在内部组中使用 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 而不是将它们限制为0到5个匹配项，那将需要花费很长的时间，或者直到耗尽堆栈空间为止。而且，这些内部优化并不总是适用。例如，如果在外部组上放置 &lt;code&gt;{0,5}&lt;/code&gt; 而不是 &lt;code&gt;&quot;*&quot;&lt;/code&gt; ，则当前的优化不适用，并且匹配需要很长时间才能完成。</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">而且，如果您在内部组中使用 &lt;code&gt;*&lt;/code&gt; 而不是将它们限制为0到5个匹配项，那将需要花费很长的时间，或者直到耗尽堆栈空间为止。而且，这些内部优化并不总是适用。例如，如果将 &lt;code&gt;{0,5}&lt;/code&gt; 而不是 &lt;code&gt;*&lt;/code&gt; 放在外部组上，则当前的优化不适用，并且匹配需要很长时间才能完成。</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">而且，如果您想重复任何先前的命令，请使用感叹号：' &lt;b&gt;！&lt;/b&gt; '：</target>
        </trans-unit>
        <trans-unit id="e2e9c56949878c68d60537e13a0fee819e61a651" translate="yes" xml:space="preserve">
          <source>And if you want to update your remote-tracking branches for all defined remotes simultaneously you can do</source>
          <target state="translated">如果你想同时更新所有已定义的遥控器的远程跟踪分支,你可以这样做</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">如果你想再次列出第5行,输入'l 5',(注意空格)。</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">而且，如果您不是在编写格式化程序类，而是在编写一个使用Pod :: PullParser对象（而不是子类的对象）执行简单操作的程序，那么就没有理由费心子类来添加 &lt;code&gt;run&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">而在gdb做。</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">而在gdb中。</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">而在Unix值1的特殊情况下,编码是。</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">而且它是有效的;现在,这些传统标准很少被使用。大多数人都在使用Unicode。</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">而且速度也会更快,因为我们可以立即开始处理程序的stdout,而不是等待程序完成。</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">在开始循环之前，我们将 &lt;code&gt;patcopy&lt;/code&gt; 设置为 &lt;code&gt;pat&lt;/code&gt; 的开始：</target>
        </trans-unit>
        <trans-unit id="1283b8c922466a3c7b07d1feee37151a4dce3090" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt;:</source>
          <target state="translated">在开始循环之前，我们将 &lt;code&gt;patcopy&lt;/code&gt; 设置为 &lt;code&gt;pat&lt;/code&gt; 的开始：</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">而且只要使用多级哈希开始。</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">让我们一起来看看吧。</target>
        </trans-unit>
        <trans-unit id="2fcd80e8aae7192e91938fbeb5e4135bca3cc513" translate="yes" xml:space="preserve">
          <source>And likewise, the &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Languages other than Perl may not be able to accept files that contain these.</source>
          <target state="translated">同样， &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; 和 &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; 标志会影响对大于Unicode最大值0x10FFFF的代码点的处理。Perl以外的其他语言可能无法接受包含这些语言的文件。</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">而在当地几个月。</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">并确保'|1'或'|3'条目在'|0'条目之后。</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">并使 &lt;code&gt;SHELL&lt;/code&gt; 环境变量指向此</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">还有更多的杂牌功能。</target>
        </trans-unit>
        <trans-unit id="a60081f8386184766dad1be5fdc437aa5eeeb0e1" translate="yes" xml:space="preserve">
          <source>And note that unlike the first example, this will permanently set &lt;code&gt;$^W&lt;/code&gt; since it cannot both run during compile-time and be localized to a run-time block.</source>
          <target state="translated">并注意，与第一个示例不同，这将永久设置 &lt;code&gt;$^W&lt;/code&gt; 因为它既不能在编译时运行，也不能本地化为运行时块。</target>
        </trans-unit>
        <trans-unit id="804a1ae29f0ee92582bcfc8bf24a3ed82f77d6d1" translate="yes" xml:space="preserve">
          <source>And note, that some items returned by &lt;code&gt;Localeconv&lt;/code&gt; are available through &lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;&quot;Perl_langinfo&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;Localeconv&lt;/code&gt; 返回的某些项目可通过&lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;perlapi中的&amp;ldquo; Perl_langinfo&amp;rdquo;获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">而现在作为列表操作符的一些例子。</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">现在，Perl程序调用 &lt;code&gt;tzname&lt;/code&gt; ，这两个值的分配方式如下：</target>
        </trans-unit>
        <trans-unit id="f59e966510e8c065dbf5dc3f3cc9146205ad5af4" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt;, the two values will be assigned as in:</source>
          <target state="translated">现在，Perl程序调用 &lt;code&gt;tzname&lt;/code&gt; ，这两个值的分配方式如下：</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">而现在当我们运行它的时候,我们得到的仍然是&quot;\n&quot;,但至少我们知道为什么。只要让这个脚本编译,就已经暴露了'$varl'(带字母'l')变量,只要把$varl改成$var1就能解决问题。</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">而现在每当访问其中任何一个变量时,都会检索并返回其当前的系统优先级。如果这些变量被设置了,那么进程的优先级就会被改变!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">而现在只有当键本身真正相同时,你才会有重复的键。(注意:在大约1996年11月之前的db库版本中,这种重复的键被保留了下来,所以可以在比较相同的键组中恢复原始键)。</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">当然也是一个很基础的测试。</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">如果你需要在括号内的表达式中使用文字符号,你可以用&quot;~~&quot;来实现。</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">而只有在Solaris 8上你还需要。</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">而且只有最后两个符合。</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">其他分配变体类似于 &lt;code&gt;'+='&lt;/code&gt; 和 &lt;code&gt;'-='&lt;/code&gt; （并类似于上面的 &lt;code&gt;'.='&lt;/code&gt; 和 &lt;code&gt;'x='&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">也许最重要的是,保持项目的一致性:要么对所有项目使用&quot;=项目*&quot;,以产生子弹;要么使用&quot;=项目1.&quot;、&quot;=项目2.&quot;等,以产生数字列表;要么使用&quot;=项目foo&quot;、&quot;=项目bar &quot;等 ----即那些看起来完全不像子弹或数字的东西。</target>
        </trans-unit>
        <trans-unit id="ac0a1fd097b0dfd986a143395713cf6857292218" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers. (If you have a list that contains both: 1) things that don't look like bullets nor numbers, plus 2) things that do, you should preface the bullet- or number-like items with &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z&amp;lt;&amp;gt;&lt;/a&gt; below for an example.)</source>
          <target state="translated">也许最重要的是，使项目保持一致：要么对所有项目都使用&amp;ldquo; = item *&amp;rdquo;，则产生子弹；或使用&amp;ldquo; =项目1&amp;rdquo;，&amp;ldquo; =项目2&amp;rdquo;等来生成编号列表；或使用&amp;ldquo; = item foo&amp;rdquo;，&amp;ldquo; = item bar&amp;rdquo;等-即看起来像项目符号或数字的东西。（如果您的列表包含以下两者：1）看起来不像项目符号或数字的事物，加上2）看起来不相同的事物，则应在项目符号或类似数字的项目前加上 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; 作为前缀。有关示例，请参见下面的&lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z &amp;lt;&amp;gt;&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b837400890ba807a5f5e88629d11f36f624c30a2" translate="yes" xml:space="preserve">
          <source>And pull new changes from the repository, and update your local repository (must be clean first)</source>
          <target state="translated">并从版本库中提取新的变化,并更新你的本地版本库(必须先清理)</target>
        </trans-unit>
        <trans-unit id="3abab37034be7516f5a858adebbbb45b8ced8395" translate="yes" xml:space="preserve">
          <source>And push the branch to your fork:</source>
          <target state="translated">然后把树枝推到你的叉子上。</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">既然说到这个话题......</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">这些也是如此。</target>
        </trans-unit>
        <trans-unit id="d57613d3e5e04fb527cb785d3cbc34d0addd45d8" translate="yes" xml:space="preserve">
          <source>And some of the entries are marked as &quot;undocumented&quot;. This means that they aren't necessarily considered stable, and could be changed or removed in some future release without warning. It is therefore a bad idea to use them without further checking. It could be that these are considered to be for perl core use only; or it could be, though, that &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't know where to find their documentation, or that it's just an oversight that they haven't been documented. If you want to use one, and potentially have it backported, first send mail to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="translated">并且某些条目被标记为&amp;ldquo;未记录&amp;rdquo;。这意味着它们不一定被认为是稳定的，并且可以在将来的版本中更改或删除它们而不会发出警告。因此，不经进一步检查就使用它们是一个坏主意。这些可能仅被视为仅用于perl内核。或者，可能是 &lt;code&gt;Devel::PPPort&lt;/code&gt; 不知道在哪里可以找到他们的文档，或者只是疏忽大意而未记录他们。如果要使用一个，并可能将其&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;反向&lt;/a&gt;移植，请首先将邮件发送到mailto：perl5-porters@perl.org。</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">而在所有行为中,成功的值总是0。</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">那么假设你只需查找$greetings{$wanted}就可以回答客户对语言$wanted的请求。</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">假设你写了一个程序,读取该文件,然后作为守护进程运行,回答客户指定语言标签的请求,然后期待该语言的字符串,说明如何打招呼。那么一个交互的样子是这样的。</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">而这也是正确的做法。</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">而这也正是第一个怪癖罢工： &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 的模板都必须得到塞 &lt;code&gt;x&lt;/code&gt; 代码来获得这些额外的补字节。</target>
        </trans-unit>
        <trans-unit id="faa61c2d15a96573c75e47bc47738ee4332bd44e" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">而这也正是第一个怪癖罢工： &lt;code&gt;pack&lt;/code&gt; 和 &lt;code&gt;unpack&lt;/code&gt; 的模板都必须得到塞 &lt;code&gt;x&lt;/code&gt; 代码来获得这些额外的补字节。</target>
        </trans-unit>
        <trans-unit id="1c2e146487dcd6b006ca0fe732ee06c5f66c58a6" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;*&lt;/code&gt; quantifier (or its equivalent &lt;code&gt;(0,}&lt;/code&gt;) is illegal.</source>
          <target state="translated">而 &lt;code&gt;*&lt;/code&gt; 量词（或同等学历 &lt;code&gt;(0,}&lt;/code&gt; ）是非法的。</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">而除去。</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">然后至少你可以使用value(),这将是真正的参考,而不是keys(),后者不会。</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">然后硬编码,把移植作为一种练习留给你的接班人。</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">然后，将编译后的值存储在$ lh-&amp;gt; {'_ external_lex_cache'}中，而不是将编译后的值存储在词典哈希中</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">然后像以前一样打开，根据需要选择 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c1e2199a985f69bef0e671090e4f82d7d27c974b" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">然后像以前一样打开，根据需要选择 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">然后提供一个 &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; 映射项T_PTROBJ_SPECIAL，它将下划线映射到双冒号（：:)，并声明 &lt;code&gt;Net_Config&lt;/code&gt; 为该类型：</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">然后将哈希名称替换为引用。</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">然后将PERL5LIB设置为</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">然后一步步走,直到你找到你要找的东西。如果你想只在某些迭代时中断,这在循环中很好用。</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">而这些条件都成立</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">而且他们的意思都和这个一模一样。</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">而这个例子使用匿名子程序来创建单独的计数器。</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">而这是XS码。</target>
        </trans-unit>
        <trans-unit id="0991be3e57b74fce439099710428de62b394a4a0" translate="yes" xml:space="preserve">
          <source>And this is the reason that many of the C library string handling functions should not be used. They don't cope with the full generality of Perl strings. It may be that your test cases don't have embedded &lt;code&gt;NUL&lt;/code&gt;s, and so the tests pass, whereas there may well eventually arise real-world cases where they fail. A lesson here is to include &lt;code&gt;NUL&lt;/code&gt;s in your tests. Now it's fairly rare in most real world cases to get &lt;code&gt;NUL&lt;/code&gt;s, so your code may seem to work, until one day a &lt;code&gt;NUL&lt;/code&gt; comes along.</source>
          <target state="translated">这就是不应使用许多C库字符串处理函数的原因。他们不能应付Perl字符串的全部一般性。可能是因为您的测试用例没有嵌入 &lt;code&gt;NUL&lt;/code&gt; ，所以测试通过了，而最终可能会在现实情况下出现失败的案例。这里的一课是将 &lt;code&gt;NUL&lt;/code&gt; 包含在您的测试中。现在，在大多数实际情况下，获取 &lt;code&gt;NUL&lt;/code&gt; 的情况相当罕见，因此您的代码似乎可以正常工作，直到有一天出现 &lt;code&gt;NUL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">这就是上面脚本的打印效果。</target>
        </trans-unit>
        <trans-unit id="f3108d27ee1408a1d7ae19ba3de728a5ab7ca78b" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot; in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">这还不是全部。从Perl v5.12开始，未使用UTF-8编码的字符串在各种情况下也可以被视为Unicode（请参阅&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode中的&amp;ldquo; ASCII规则与Unicode规则&amp;rdquo;&lt;/a&gt;）。这仅对于序数在128到255之间的字符确实是一个问题，并且它们的行为在ASCII和Unicode规则下以代码关心的方式变化（请参阅&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的&amp;ldquo; Unicode错误&amp;rdquo;&lt;/a&gt;）。有没有发布的API来处理这个问题，因为它是可能发生变化，但你可以看看代码 &lt;code&gt;pp_lc&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">这还不是全部。从Perl v5.12开始，未使用UTF-8编码的字符串在各种情况下也可以被视为Unicode（请参阅&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicode中的ASCII规则与Unicode规则&lt;/a&gt;）。这仅对于序数在128到255之间的字符确实是一个问题，并且它们的行为在ASCII和Unicode规则下以代码关心的方式变化（请参阅&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;）。有没有发布的API来处理这个问题，因为它是可能发生变化，但你可以看看代码 &lt;code&gt;pp_lc&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">而这个是从孩子身上读出来的。</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">而这也是有道理的。</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">还有这个</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">要检查perl搜索库目录的顺序,运行</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">而代孕。</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">然后再试一次。</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">而我们最终的方案。</target>
        </trans-unit>
        <trans-unit id="fea4a67d42b69d2a6859a380b25f39bb4220097d" translate="yes" xml:space="preserve">
          <source>And whitespace may be used between the &lt;code&gt;~&lt;/code&gt; and quoted delimiters:</source>
          <target state="translated">在 &lt;code&gt;~&lt;/code&gt; 和带引号的定界符之间可以使用空格：</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">而随着 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; 的效果，这是同样的事情在UTF-8的代码：</target>
        </trans-unit>
        <trans-unit id="5057821b43bf3328e6eb98ddc5e990c468614ce5" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">而随着 &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; 的效果，这是同样的事情在UTF-8的代码：</target>
        </trans-unit>
        <trans-unit id="b354e965b809ff14ff904fafbdc0b4de89c4bc4e" translate="yes" xml:space="preserve">
          <source>And with boolean methods</source>
          <target state="translated">而对于布尔方法</target>
        </trans-unit>
        <trans-unit id="dd73bf27445a15ee33df36a7d8cf60d584177c03" translate="yes" xml:space="preserve">
          <source>And you can see the changes:</source>
          <target state="translated">而且你可以看到这些变化。</target>
        </trans-unit>
        <trans-unit id="3a140f07fc1f24b5deb3f2211fd3e22212c7dcd8" translate="yes" xml:space="preserve">
          <source>And you may also sense that you do not want to bother your translators with having to write Perl code -- you'd much rather that they spend their</source>
          <target state="translated">您也可能觉得您不想麻烦您的译员写Perl代码--您更愿意让他们把他们的</target>
        </trans-unit>
        <trans-unit id="72514ebfb8885208b2209c125f8bbac4bdc3aa69" translate="yes" xml:space="preserve">
          <source>And you write:</source>
          <target state="translated">而你写。</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">而你的呼叫器模块应该是这样的。</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">而且，从上一个示例中您已经注意到，如果您覆盖 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; ，那么 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob运算符也会被覆盖。</target>
        </trans-unit>
        <trans-unit id="09ddb5c3e778ae1b6a95dadacffb550e09674ca1" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;glob&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">而且，从上一个示例中您已经注意到，如果您覆盖 &lt;code&gt;glob&lt;/code&gt; ，那么 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob运算符也会被覆盖。</target>
        </trans-unit>
        <trans-unit id="f027b49b77d3cee2d1bd5a0ad1af1a5214bdb5ba" translate="yes" xml:space="preserve">
          <source>And, most importantly, there's all the practical details of how to actually go about deriving from Maketext so you can use it for your interfaces, and the various tools and conventions for starting out and maintaining individual language modules.</source>
          <target state="translated">而且,最重要的是,这里有所有的实用细节,包括如何真正去派生Maketext,以便你可以将它用于你的界面,以及各种工具和约定,用于启动和维护各个语言模块。</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">而且，可以通过 &lt;code&gt;\N{}&lt;/code&gt; 插值在双引号字符串和正则表达式中访问Name和Name_Aliases属性。和功能 &lt;code&gt;charnames::viacode()&lt;/code&gt; ， &lt;code&gt;charnames::vianame()&lt;/code&gt; 和 &lt;code&gt;charnames::string_vianame()&lt;/code&gt; （需要指定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3d4a9b48a0e71abc1829b589dc1a4bb4344372b" translate="yes" xml:space="preserve">
          <source>And, there is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="translated">并且，有一种技术可用于处理较早版本中长度可变的回溯，并且长度超过255个字符。在&lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html中进行了&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">而且，在Perl 5.10及更高版本中，您不必检查继承即可查看对象是否可以处理角色。为此，您可以使用来自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的 &lt;code&gt;DOES&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="df1177936aa7e7d352017983c64995f489a2f05c" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt;, which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt;:</source>
          <target state="translated">而且，在Perl 5.10及更高版本中，您不必检查继承即可查看对象是否可以处理角色。为此，您可以使用来自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的 &lt;code&gt;DOES&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="973c0aeb4f70654b3b70d2e3c1f5c993e73805e5" translate="yes" xml:space="preserve">
          <source>Andreas J. Koenig</source>
          <target state="translated">Andreas J.Koenig</target>
        </trans-unit>
        <trans-unit id="84c4d01ab2b12800c7bf2f6468b98b449d53a99b" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="translated">安德烈亚斯&amp;middot;科尼格（Andreas Koenig）&amp;lt;andk@cpan.org&amp;gt;，布拉尼斯拉夫&amp;middot;扎赫拉德尼克（Branislav Zahradnik）&amp;lt;barney@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">安德烈亚斯&amp;middot;科尼格（Andreas Koenig） &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">安德烈亚斯&amp;middot;科尼格（Andreas Koenig） &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯通&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯特朗 &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">安迪&amp;middot;阿姆斯特朗（Andy Armstrong），&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9084574cd986898323dbe20b46abf1751fbbf849" translate="yes" xml:space="preserve">
          <source>Andy Broad &amp;lt;andy@broad.ology.org.uk&amp;gt;</source>
          <target state="translated">安迪&amp;middot;布罗德（Andy Broad）&amp;lt;andy@broad.ology.org.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">安迪&amp;middot;多尔蒂 &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; ，安德烈亚斯&amp;middot;柯尼希 &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; ，蒂姆&amp;middot;邦斯 &lt;code&gt;timb@cpan.org&lt;/code&gt; 。VMS支持由Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; 提供。OS / 2支持由Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="54b2fb7511cb7a7c3493b4e0650ca3d85102f114" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt;, Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;.</source>
          <target state="translated">安迪&amp;middot;多尔蒂 &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; ，安德烈亚斯&amp;middot;柯尼希 &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; ，蒂姆&amp;middot;邦斯 &lt;code&gt;timb@cpan.org&lt;/code&gt; 。VMS支持由Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; 提供。OS / 2支持由Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="adb884ee85ba557bf7e891804c953fd2fabe3f95" translate="yes" xml:space="preserve">
          <source>Andy Glew,</source>
          <target state="translated">Andy Glew,</target>
        </trans-unit>
        <trans-unit id="9371666f1dc2fa002dd7c688c18705bc84f8f9d0" translate="yes" xml:space="preserve">
          <source>Andy Lester</source>
          <target state="translated">安迪-莱斯特</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">据传闻估计,源码到编译后的代码膨胀率增加了八倍。这意味着合理的编译形式(通常有注释、适当缩进等)的代码在内存中占用的空间将比代码在磁盘上占用的空间多八倍。</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">不写为 &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; 的尖括号可能会引起错误，因为它们可能会被误解为标记命令。仅当-warnings级别大于1时才打印。</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel(ANNO)写了xs代码,perl适当的改动Jerry Hedden(JDHEDDEN)让它更快。</target>
        </trans-unit>
        <trans-unit id="602afe4dcabe1b2fe81bdeaea0130200ac9160dc" translate="yes" xml:space="preserve">
          <source>AnnoCPAN: Annotated CPAN documentation</source>
          <target state="translated">AnnoCPAN:附加说明的CPAN文件。</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">带注释的POD &lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads</target>
        </trans-unit>
        <trans-unit id="7858242352e2796cb227df6cabe7747dcc9c11c4" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">带注释的POD&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;：&lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https&lt;/a&gt; : //web.archive.org/web/20171028020148/http : //annocpan.org/?mode = search&amp;amp;field = Module&amp;amp;name = threads</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">带&lt;a href=&quot;threads/shared&quot;&gt;螺纹的&lt;/a&gt;注释POD :: shared：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads%3A% 3Ashared</target>
        </trans-unit>
        <trans-unit id="7ff3b3d306ae85d31c9461b66532ebdda6c7e205" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">带注释的POD &lt;a href=&quot;threads::shared&quot;&gt;:: shared&lt;/a&gt;：&lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https &lt;/a&gt;://web.archive.org/web/20171028020148/http : //annocpan.org/?mode= search&amp;amp;field = Module&amp;amp;name= threads% 3A%3Ashared</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">附加说明的人物名单</target>
        </trans-unit>
        <trans-unit id="c10f845c88bdb301cd3ade696bdf99cccd4ed1f0" translate="yes" xml:space="preserve">
          <source>Annotated tags in the canonical perl.git repository will never be deleted or modified. Think long and hard about whether you want to push a local tag to perl.git before doing so. (Pushing simple tags is not allowed.)</source>
          <target state="translated">规范的 perl.git 仓库中的注释标签永远不会被删除或修改。在这样做之前,请仔细考虑是否要将本地标签推送到 perl.git。推送简单的标签是不允许的)。</target>
        </trans-unit>
        <trans-unit id="d5154e030234862764507248749c6a7c751b8bc6" translate="yes" xml:space="preserve">
          <source>Anonymous Subroutines</source>
          <target state="translated">匿名子程序</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">像这样的匿名哈希和数组合成器可以自由混合,产生你想要的复杂结构。下面描述的多维语法也适用于这些结构。上面的值是字面值,但变量和表达式也同样适用,因为Perl中的赋值运算符(甚至在local()或my()中)是可执行的语句,而不是编译时的声明。</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">匿名子程序相对于my()变量,也就是当前作用域内词法可见的变量,起到了闭包的作用。闭包是Lisp世界中的一个概念,它说如果你在一个特定的词法上下文中定义了一个匿名函数,那么即使在上下文外调用它,它也会假装在这个上下文中运行。</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名子程序得到每次执行时捕获 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 运营商，因为它们是动态创建。如果习惯于在其他编程语言中将嵌套子例程与它们自己的私有变量一起使用，则必须在Perl中进行一些处理。由于上述原因，这种类型的事物的直观编码会引发关于&amp;ldquo;将不会保持共享&amp;rdquo;的神秘警告。例如，这将不起作用：</target>
        </trans-unit>
        <trans-unit id="484e8735a38d0b2c3316b6b4767502150b9246c0" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;sub&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名子程序得到每次执行时捕获 &lt;code&gt;sub&lt;/code&gt; 运营商，因为它们是动态创建。如果习惯于在其他编程语言中将嵌套子例程与它们自己的私有变量一起使用，则必须在Perl中进行一些处理。由于上述原因，这种类型的事物的直观编码会引发关于&amp;ldquo;将不会保持共享&amp;rdquo;的神秘警告。例如，这将不起作用：</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">另一个例子</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">另一个例子 --Key是一个C int。</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">另一个例子。钥匙是一个Cint。</target>
        </trans-unit>
        <trans-unit id="c610761bff33dc8f8934a509a66662b8c1def3f8" translate="yes" xml:space="preserve">
          <source>Another P5P contributor recommended installation and use of Devel::PatchPerl for this situation, first to determine the version of perl at the commit in question, then to patch the source code at that point to facilitate a build.</source>
          <target state="translated">另一位P5P贡献者推荐安装并使用Devel::PatchPerl来处理这种情况,首先确定提交时的perl版本,然后在该点对源代码打补丁,以方便构建。</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">另一种便携式二进制编码</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">另一个简短的调试器,稍微有用一点,可以只用行创建。</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">另一个常见的错误是,当你应该使用方括号或大括号时,却使用普通括号来构建列表引用,例如,如果你说</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">这个构造的另一个常见用途是当你需要在没有shell干扰的情况下执行一些东西。使用system(),这很直接,但你不能安全地使用管道打开或回标。这是因为没有办法阻止shell对你的参数动手脚。相反,使用低级控制直接调用exec()。</target>
        </trans-unit>
        <trans-unit id="948bec86ec25e1c793c75848e3f095908f00b9e7" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&quot;Unicode and Localisation Support&quot;&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. This is another instance where the parsing needs to be restarted, and it can and is done immediately. The function returns failure, and sets the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; (encapsulated by using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt;). This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;.</source>
          <target state="translated">另一个复杂之处在于，如果程序需要存储Unicode，则表示该程序所使用的表示形式会有所不同，但是，直到解析过程中，始终无法确定它是否会存储。该程序的Unicode表示形式较大，无法有效匹配。 （有关原因的更多详细信息，请参见下面的&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&amp;ldquo; Unicode和本地化支持&amp;rdquo;&lt;/a&gt;。）如果该模式包含文字Unicode，则很明显该程序需要存储Unicode。否则，解析器乐观地假定可以使用更有效的表示形式，并在此基础上开始调整大小。但是，如果它遇到了模式中必须存储为Unicode的内容，例如 &lt;code&gt;\x{...}&lt;/code&gt; 转义序列表示字符文字，那么这意味着需要使用适合Unicode表示的值来重做所有先前计算的大小。这是另一个需要重新开始分析的实例，它可以并且可以立即完成。该函数返回失败，并设置标志 &lt;code&gt;RESTART_UTF8&lt;/code&gt; （使用宏 &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; 封装）。此重新启动请求以类似的方式在调用链中传播，直到被&amp;ldquo;捕获&amp;rdquo;在 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 中，该标志将模式标记为包含Unicode，然后重新启动大小调整过程。运行时代码块中的构造也可能需要Unicode表示，这由 &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; 发出信号。返回false到 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">另一个复杂之处是，如果程序需要存储Unicode，则表示该程序所用的表示形式会有所不同，但是，直到解析过程中途，始终无法确定它是否会存储。该程序的Unicode表示形式较大，无法有效匹配。 （有关原因的更多详细信息，请参见下面的&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode和本地化支持&lt;/a&gt;。）如果模式包含文字Unicode，则很明显程序需要存储Unicode。否则，解析器乐观地假定可以使用更有效的表示形式，并在此基础上开始调整大小。但是，如果它随后遇到模式中必须存储为Unicode的某些内容，例如 &lt;code&gt;\x{...}&lt;/code&gt; 转义序列表示一个字符文字，那么这意味着需要使用适合Unicode表示的值来重做所有先前计算的大小。当前，所有可触发此操作的正则表达式构造都通过 &lt;code&gt;regatom()&lt;/code&gt; 中的代码进行解析。</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">这两个属性的另一个困惑是,定义并不是说代码点已被</target>
        </trans-unit>
        <trans-unit id="8de6445149b9f420296053261c9997adf2340600" translate="yes" xml:space="preserve">
          <source>Another consequence of using &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt;, the I/O subsystem will regard it as the end of the file, unless you use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;（在某些系统上）的另一个结果是，特殊的文件结束标记将被视为数据流的一部分。对于Microsoft系列系统，这意味着，如果您的二进制数据包含 &lt;code&gt;\cZ&lt;/code&gt; ，则I / O子系统会将其视为文件的末尾，除非您使用&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">（在某些系统上）使用binmode（）的另一个结果是，特殊的文件结束标记将被视为数据流的一部分。对于Microsoft系列的系统，这意味着，如果您的二进制数据包含 &lt;code&gt;\cZ&lt;/code&gt; ，则I / O子系统会将其视为文件的末尾，除非您使用binmode（）。</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">另一个需要警惕的构造是在正则表达式中不适当地使用十六进制（除非使用 &lt;code&gt;\N{U+...}&lt;/code&gt; ）或八进制常量。考虑以下子集：</target>
        </trans-unit>
        <trans-unit id="4bdabce8c57375ff87d8b683a0b4feedd678dfa2" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt;) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">另一个需要警惕的构造是在正则表达式中不适当地使用十六进制（除非使用 &lt;code&gt;\N{U+...}&lt;/code&gt; ）或八进制常量。考虑以下子集：</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">另一种描述是从 &quot;更好&quot;/&quot;更差 &quot;的概念开始的。所有可能被给定正则表达式匹配的子串都可以从 &quot;最佳 &quot;匹配到 &quot;最差 &quot;匹配进行排序,选择的是 &quot;最佳 &quot;匹配。这就把 &quot;选择什么 &quot;的问题改为 &quot;哪些匹配更好,哪些更差 &quot;的问题。</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">另一个缺点是只对5.6.0之前的Perl版本有效。这个缺点是,seek和tell函数(包括内置版本和POSIX模块版本)将无法正确执行。</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">另一个虚拟层。按下该按钮时，它会自行弹出并在（现在又是现在）堆栈顶部的层上设置 &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">又是一个数据段的例子。</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">另一个例子将它发现的第一个 &quot;latin1 &quot;编码切换为pod文件中的 &quot;utf8&quot;。</target>
        </trans-unit>
        <trans-unit id="50f1426af11ad7a924141e38d176e901ed8b9c69" translate="yes" xml:space="preserve">
          <source>Another example that shows that within &lt;code&gt;\p{...}&lt;/code&gt;, &lt;code&gt;/x&lt;/code&gt; isn't needed to have spaces:</source>
          <target state="translated">另一个示例显示 &lt;code&gt;\p{...}&lt;/code&gt; 中的 &lt;code&gt;/x&lt;/code&gt; 不需要空格：</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">另一个例子:</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">代码表达式的另一种形式是</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">可能发生的另一种优化形式是解析后的&amp;ldquo;窥孔&amp;rdquo;优化，其中将无效的构造替换为更有效的构造。在解析过程中用来标记分支结束和组结束的 &lt;code&gt;TAIL&lt;/code&gt; regops就是这样的示例。这些regops用作施工期间占位和&amp;ldquo;总是一致&amp;rdquo;，使他们能够&amp;ldquo;优化掉&amp;rdquo;通过使东西点到 &lt;code&gt;TAIL&lt;/code&gt; 点的东西， &lt;code&gt;TAIL&lt;/code&gt; 点，因此&amp;ldquo;退出&amp;rdquo;的节点。</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">除了可读性和可维护性之外,下面的例子还说明了使用相对回溯引用的另一个很好的理由,其中使用了一个简单的模式来匹配奇特的字符串。</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC的另一种有趣的方法是使您的单个程序进行多进程处理，并在自己之间甚至之间进行通信。open（）函数将接受文件参数 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 来做一件非常有趣的事情：它派生一个与您打开的文件句柄连接的孩子。子进程与父进程运行相同的程序。例如，这对于在假定的UID或GID下运行时安全地打开文件很有用。如果您打开管道</target>
        </trans-unit>
        <trans-unit id="4522d51a25407d48caa1899497ae3f892458c192" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The two-argument form of the open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPC的另一种有趣的方法是使您的单个程序进行多进程处理，并在彼此之间甚至之间进行通信。open（）函数的两个参数形式将接受文件参数 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;|-&quot;&lt;/code&gt; 来做一件非常有趣的事情：它派生一个与您打开的文件句柄连接的孩子。子级运行与父级运行相同的程序。例如，这对于在假定的UID或GID下运行时安全地打开文件很有用。如果您打开管道</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">另一个有趣的信号是零号信号。这实际上并不影响子进程,而是检查子进程是否还活着或者是否改变了UID。</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">用于查询与语言环境相关的信息的另一个接口是 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 函数，至少在类似Unix的系统和VMS中可用。</target>
        </trans-unit>
        <trans-unit id="b2c6ea999a64bd42bd0c393eb0d4d13d68bfe00e" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function.</source>
          <target state="translated">用于查询与语言环境相关的信息的另一个接口是 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="7e0169360cab902c54c29d1ed679e73f96ea0a5a" translate="yes" xml:space="preserve">
          <source>Another is</source>
          <target state="translated">另一个是</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">另一种客户端-服务器的设置是不使用连接,而是使用消息。UDP通信涉及到的开销要低得多,但也提供了较低的可靠性,因为没有承诺消息会完全到达,更不用说按顺序和不纠缠了。不过,UDP还是比TCP有一些优势,包括可以一次向一大堆目标主机(通常是在你的本地子网)&quot;广播 &quot;或 &quot;多播&quot;。如果你发现自己过分关注可靠性,并开始在你的消息系统中建立检查,那么你可能应该一开始就只使用TCP。</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">另一个需要检查的内存限制项目是'SYS1.PARMLIB(BPXPRMxx)'数据集中的MAXASSIZE参数(也请注意,从V2R8开始,地址空间限制可以在RACF配置文件的USS段中根据每个用户ID来设置)。有人报告说,Perl的MAXASSIZE参数小到503316480,就可以成功地构建Perl(也可以用比MAXASSIZE更小的MAXASSIZE构建Perl)。</target>
        </trans-unit>
        <trans-unit id="7f12c23dd22baed9e55a21bc829f2cdbb2990e89" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (without swearing) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">此修饰符的另一个助记符是&amp;ldquo; Depends&amp;rdquo;，因为实际使用的规则取决于各种因素，因此您可能会得到意想不到的结果。请参见&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的&amp;ldquo;&amp;ldquo; Unicode错误&amp;rdquo;&amp;rdquo;&lt;/a&gt;。Unicode Bug已经声名狼藉，导致该修饰符&amp;ldquo; Dodgy&amp;rdquo;的另一个名称（不发誓）。</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">此修饰符的另一个助记符是&amp;ldquo; Depends&amp;rdquo;，因为实际使用的规则取决于各种因素，因此您可能会得到意外的结果。请参见&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicode中的Unicode错误&lt;/a&gt;。 Unicode错误已经声名狼藉，导致该修饰符&amp;ldquo; Dodgy&amp;rdquo;的另一个（可打印的）名称。</target>
        </trans-unit>
        <trans-unit id="df7cbfe3fb975c17e692f6a855e0332ef03824f0" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension to the JSON syntax, enabled with the &lt;code&gt;allow_tags&lt;/code&gt; setting, are tagged values. In this implementation, the</source>
          <target state="translated">使用 &lt;code&gt;allow_tags&lt;/code&gt; 设置启用的另一个JSON语法的非标准扩展是标记值。在此实施中，</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">模板字母中的另一个奇数符号是 &lt;code&gt;u&lt;/code&gt; ，其中包含&amp;ldquo; uuencoded字符串&amp;rdquo;。 （&amp;ldquo; uu&amp;rdquo;是Unix到Unix的缩写。）您可能永远不需要这种编码技术，该编码技术是为了克服不支持简单ASCII数据之外的老式传输介质的缺点而发明的。基本配方很简单：占用三个字节或24位。将它们分成4个六包装，每个包装加一个（0x20）空间。重复直到所有数据混合在一起。将4个字节的组折叠成不超过60行，并在其前面加上原始字节数（增加0x20），并在末尾加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。 - 当您在菜单上选择包装代码 &lt;code&gt;u&lt;/code&gt; 时， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 厨师将为您准备点菜：</target>
        </trans-unit>
        <trans-unit id="0815afa133e3357f3c224c29010f1fab6f9eb77d" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt;, which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;pack&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">模板字母中的另一个奇数符号是 &lt;code&gt;u&lt;/code&gt; ，它包装了一个&amp;ldquo; uuencoded字符串&amp;rdquo;。 （&amp;ldquo; uu&amp;rdquo;是Unix到Unix的缩写。）您可能永远不需要这种编码技术，该编码技术是为了克服不支持简单ASCII数据以外的老式传输介质的缺点而发明的。基本配方很简单：占用3个字节或24位。将它们分成4个六包装，每个包装增加一个空格（0x20）。重复直到所有数据混合在一起。将4个字节的组折叠成不超过60行，并在其前面加上原始字节数（增加0x20），并在末尾加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。 -当您在菜单上选择包装代码 &lt;code&gt;u&lt;/code&gt; 时，厨师 &lt;code&gt;pack&lt;/code&gt; 将为您准备，大约一分钟：</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">另一个具有令人惊讶的优先级的运算符是幂运算。它甚至比一元负号更紧密地结合，从而使 &lt;code&gt;-2**2&lt;/code&gt; 产生负4而不是正1。它也是右关联的，这意味着 &lt;code&gt;2**3**2&lt;/code&gt; 是2升到9的幂，而不是8的平方。</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">可能发生的另一种优化是&amp;ldquo; &lt;code&gt;EXACT&lt;/code&gt; 合并&amp;rdquo;的优化，其中两个连续的 &lt;code&gt;EXACT&lt;/code&gt; 节点被合并到一个单独的regop中。甚至更积极的形式是，可以将 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; 形式的分支序列转换为 &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop。</target>
        </trans-unit>
        <trans-unit id="bd2c2ceaa1b82e7064a95fc5a1daa0bbc069a63f" translate="yes" xml:space="preserve">
          <source>Another option for Perls starting with 5.16, if you only care about ASCII matches, is to add the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex. This will exclude all these non-obvious matches, thus getting rid of this message. You can also say</source>
          <target state="translated">如果您只关心ASCII匹配，那么从5.16开始的Perls的另一种选择是将 &lt;code&gt;/aa&lt;/code&gt; 修饰符添加到正则表达式中。这将排除所有这些非显而易见的匹配，从而摆脱此消息。你也可以说</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">另一种选择是使用 &lt;code&gt;iter&lt;/code&gt; 类方法来遍历tarball中的文件，而无需一次读取它们在内存中的所有内容。</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">另一个选择是使用Perl编写的make,可从CPAN获得。</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist 的另一个特点是,我们可以成功地从最后一个文件中获取的站点会自动获得一个偏好标记,并作为下一次请求的第一个站点进行尝试。因此,如果你在运行时添加了一个新的站点,可能会发生之前的首选站点会在下一次被尝试的情况。这意味着,如果你想在下一次传输中不允许使用某个站点,必须明确地从urllist中删除它。</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">还有一点值得注意的是,在第一个系列的例子中,我只使用了 &quot;我的&quot;。</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; 另一个流行用途是在您的perl破坏二进制兼容性时充当抢救工具。如果CPAN使用的模块之一又取决于二进制兼容性（因此您不能运行CPAN命令），则应尝试使用CPAN :: Nox模块进行恢复。</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">另一种可能是你忘记了一个反斜杠。Perl不够聪明,无法理解你真正的意思。</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">出现问题的另一个可能原因是，在Perl看到这样的包存在之前，您已经在类名上使用了间接对象语法（例如， &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）。最明智的做法是在开始使用它们之前确保所有软件包都已定义，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ，将会很注意。如果不是，请确保使用箭头符号（例如 &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ）。对象表示法在&lt;a href=&quot;perlobj&quot;&gt;perlobj中进行了&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="fb10e4ab85598fb1febe5de364db832f8ae6b33d" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt;) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;use&lt;/code&gt; statement instead of &lt;code&gt;require&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt;) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">出现问题的另一个可能原因是，在Perl看到这样的包存在之前，您已经在类名上使用了间接对象语法（例如， &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）。最明智的做法是在开始使用它们之前确保所有软件包都已定义，如果您使用 &lt;code&gt;use&lt;/code&gt; 语句而不是 &lt;code&gt;require&lt;/code&gt; ，将可以解决这些问题。如果不是，请确保使用箭头符号（例如 &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ）。对象表示法在&lt;a href=&quot;perlobj&quot;&gt;perlobj中进行了&lt;/a&gt;说明。</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">由内而外的类发生的另一个问题是序列化。由于对象数据不在通常的位置，因此诸如 &lt;code&gt;Storable::freeze()&lt;/code&gt; ， &lt;code&gt;Storable::thaw()&lt;/code&gt; 和 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 类的标准例程无法自行处理。这两个 &lt;code&gt;Data::Dumper&lt;/code&gt; 和 &lt;code&gt;Storable&lt;/code&gt; 提供必要的钩子把事情的工作，而是由钩使用的函数或方法必须由每个内而外的类来提供。</target>
        </trans-unit>
        <trans-unit id="0ea375285a64fb396aba7ed50ea3def9a1613d41" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt;, &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">由内而外的类发生的另一个问题是序列化。由于对象数据不在通常的位置，因此诸如 &lt;code&gt;Storable::freeze()&lt;/code&gt; ， &lt;code&gt;Storable::thaw()&lt;/code&gt; 和 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; 类的标准例程无法自行处理。这两个 &lt;code&gt;Data::Dumper&lt;/code&gt; 和 &lt;code&gt;Storable&lt;/code&gt; 提供必要的钩子把事情的工作，而是由钩使用的函数或方法必须由每个内而外的类来提供。</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">这种方法的另一个问题是,越过单字节/多字节边界的操作没有很好的定义,所以是不允许的。(这个边界是在255/256的代码点之间。)例如,小写字母LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178)应该返回LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF)。但是在希腊语中,比如说,0xFF处没有字符,Perl也无法知道0xFF处的字符到底应该代表什么。因此,它不允许该操作。在这种模式下,U+0178的小写就是自己。</target>
        </trans-unit>
        <trans-unit id="e3482e337a3d87721af4bdffd6d9b7cb27fdfc8f" translate="yes" xml:space="preserve">
          <source>Another reason it isn't completely a drop-in replacement is that it is declared to return &lt;code&gt;const char *&lt;/code&gt;, whereas the system setlocale omits the &lt;code&gt;const&lt;/code&gt; (presumably because its API was specified long ago, and can't be updated; it is illegal to change the information &lt;code&gt;setlocale&lt;/code&gt; returns; doing so leads to segfaults.)</source>
          <target state="translated">它不是完全替代的另一个原因是声明它返回 &lt;code&gt;const char *&lt;/code&gt; ，而系统setlocale省略了 &lt;code&gt;const&lt;/code&gt; （大概是因为它的API是在很早之前指定的，并且无法更新；这是非法的）。更改 &lt;code&gt;setlocale&lt;/code&gt; 返回的信息；这样做会导致段错误。）</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">大家有时会认为他们希望一个变量包含一个变量的名称,另一个原因是他们不知道如何使用哈希值建立正确的数据结构。例如,假设他们想在程序中使用两个哈希值。%fred和%barney 他们想用另一个标量变量来指代这两个变量的名字。</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">使用 &lt;code&gt;HASH&lt;/code&gt; 的另一个原因是提供您自己的哈希变量。然后，您可以检查或修改哈希的内容，以更好地控制缓存管理。</target>
        </trans-unit>
        <trans-unit id="1d033aa9337856f2221026f5c7e24c794df0edbb" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">另一个示例模块&lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt;在CPAN上的单独发行版中可用。它实现了一个策略，允许您指定始终要重新查找某些函数值。有关详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">另一个示例模块&lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Saves&lt;/a&gt;在CPAN上的单独发行版中可用。它实现了一个策略，允许您指定始终要重新查找某些函数值。有关详细信息，请参见文档。</target>
        </trans-unit>
        <trans-unit id="5d1b15340e7ecbdf1f65260c165ba0bcb3105f71" translate="yes" xml:space="preserve">
          <source>Another subtle error that can occur in resolving prerequisites comes from the way that modules in prerequisites are indexed to distribution files on CPAN. When a module is deleted from a distribution, prerequisites calling for that module could indicate an older distribution should be installed, potentially overwriting files from a newer distribution.</source>
          <target state="translated">在解析先决条件时可能出现的另一个微妙的错误来自于先决条件中的模块与CPAN上的发行版文件的索引方式。当一个模块从发行版中被删除时,调用该模块的先决条件可能表明应该安装一个较旧的发行版,从而有可能覆盖较新发行版的文件。</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">另一个可以尝试的方法是了解你的Perl是用系统的malloc还是用Perl内置的malloc编译的。不管是哪一种,都可以尝试使用另一种,看看是否会有不同。关于 malloc 的信息可以在</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">另外需要注意的是,当你在私人区域安装时,UNINST参数可能会很危险,因为你可能会不小心删除其他人依赖的、没有使用私人区域的模块。</target>
        </trans-unit>
        <trans-unit id="254082198376f41ade29efc6ce1df2a3ebdfd235" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">对于运行时与编译时陷阱的另一种彻底的补救方法是使用&lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt;，它是Exporter的包装，允许在use语句中的单个gulp中使用所有样板代码。</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">对于运行时与编译时陷阱的另一种彻底的补救方法是使用&lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt;，它是Exporter的包装，允许在use语句中的单个gulp中使用所有样板代码。</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">重新分配的另一种典型用法是在 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法中。如果这样的方法确定它无法处理特定的调用，则它可能会选择重新分派该调用，以希望其他一些 &lt;code&gt;AUTOLOAD&lt;/code&gt; （在其上方或左侧）可以做得更好。</target>
        </trans-unit>
        <trans-unit id="c4228b8c62bb634355292e1e3ac8e4544658301e" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt;'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">redispatch的另一种典型用法是在 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法中。如果这样的方法确定它无法处理特定的调用，则它可能会选择重新分派该调用，以希望其他一些 &lt;code&gt;AUTOLOAD&lt;/code&gt; （在其上方或左侧）可以做得更好。</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">另一个非官方数据来源。目前,它没有被用来获取数据,但注释和解释材料对于理解来源之间的差异非常有用。</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 的另一种用途是当您希望两种返回值都存储在同一磁盘文件中时；这使您不必处理两个磁盘文件，而不必处理一个。您可以使用规范化函数将两组返回值保持分开。例如：</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">闭包的另一个用途是将一个可变的</target>
        </trans-unit>
        <trans-unit id="5cec4425942c518509d1fda3df7b77a63ebbfefa" translate="yes" xml:space="preserve">
          <source>Another use for escape sequences is to specify characters that cannot (or which you prefer not to) be written literally. These are described in detail in &lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;&quot;Character Escapes&quot; in perlrebackslash&lt;/a&gt;, but the next three paragraphs briefly describe some of them.</source>
          <target state="translated">转义序列的另一种用途是指定不能（或您不希望）按字面写的字符。这些内容&lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;在perlrebackslash的&amp;ldquo;字符转义&amp;rdquo;中&lt;/a&gt;进行了详细描述，但接下来的三段简要介绍了其中的一些内容。</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">正常化器的另一个用途是当函数依赖于其参数以外的数据时。假设你有一个函数,它的返回值取决于一天中的当前小时。</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT:部分的另一个用途是在调用C函数之前检查前提条件。</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">typeglobs 的另一个用途是将文件柄传递到一个函数中或创建新的文件柄。如果你需要使用 typeglob 来保存一个文件柄,可以这样做。</target>
        </trans-unit>
        <trans-unit id="bd85fb00e79bd02a66b771e2ae402c322124bc55" translate="yes" xml:space="preserve">
          <source>Another use is to indicate that</source>
          <target state="translated">另一种用法是表示</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">符号表的另一个用途是用于制作 &quot;常数 &quot;标量。</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">通用对象的另一个用途是作为模板。它是一个方便的地方,可以存储各种字段的类特定默认值,以便在实际对象初始化中使用。</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">另一种有用的快捷方式是，如果使用一个文字数组或哈希作为参数 &lt;code&gt;given&lt;/code&gt; ，它变成一个参考。因此，例如， &lt;code&gt;given(@foo)&lt;/code&gt; 与Given &lt;code&gt;given(\@foo)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="cc6a78b5df54e2e6affa44db83d9141a9a6580a8" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt;, it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt;, for example.</source>
          <target state="translated">另一种有用的快捷方式是，如果使用一个文字数组或哈希作为参数 &lt;code&gt;given&lt;/code&gt; ，它变成一个参考。因此，例如， &lt;code&gt;given(@foo)&lt;/code&gt; 与Given &lt;code&gt;given(\@foo)&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">主题的另一种变化。这次我们将修改 &lt;code&gt;Subst&lt;/code&gt; 过滤器，以允许指定开始和停止模式以及</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">另一个版本在列表上下文中使用全局匹配,然后将结果分配给一个标量,产生一个匹配数的计数。</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">另一种方法是赋值给字符串末尾的substr()。</target>
        </trans-unit>
        <trans-unit id="d77d43e614a814160a75653eb86a2b6f1db8267e" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">另一种方法是使用&lt;a href=&quot;Tie::File&quot;&gt;Tie :: File&lt;/a&gt;模块，该模块将整个文件视为一个数组。只需访问随机数组元素。</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">另一种方法是使用&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块，该模块将整个文件视为一个数组。只需访问随机数组元素。</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">另一种方法是在左侧使用undef作为元素。</target>
        </trans-unit>
        <trans-unit id="b6dde2905ab30997325ea52458484ff80b17847e" translate="yes" xml:space="preserve">
          <source>Another way of describing the operation is this: If &lt;code&gt;/c&lt;/code&gt; is specified, the</source>
          <target state="translated">描述该操作的另一种方式是：如果指定了 &lt;code&gt;/c&lt;/code&gt; ，则</target>
        </trans-unit>
        <trans-unit id="8b74b30f842e3a2fe422587280e297e6a0fb34e2" translate="yes" xml:space="preserve">
          <source>Another way of thinking about this function is finding a needle in a haystack. &lt;code&gt;big&lt;/code&gt; points to the first byte in the haystack. &lt;code&gt;big_end&lt;/code&gt; points to one byte beyond the final byte in the haystack. &lt;code&gt;little&lt;/code&gt; points to the first byte in the needle. &lt;code&gt;little_end&lt;/code&gt; points to one byte beyond the final byte in the needle. All the parameters must be non-&lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">考虑此功能的另一种方法是在大海捞针中寻找针头。 &lt;code&gt;big&lt;/code&gt; 点指向大海捞针中的第一个字节。 &lt;code&gt;big_end&lt;/code&gt; 指向干草堆中最后一个字节之后的一个字节。 &lt;code&gt;little&lt;/code&gt; 点指向针头的第一个字节。 &lt;code&gt;little_end&lt;/code&gt; 指向指针最后一个字节之外的一个字节。所有参数都必须为非 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">创建匿名文件句柄的另一种方法是使用Symbol模块或IO :: Handle模块及其类似项。这些模块的优点是不会在local（）期间隐藏相同名称的不同类型。有关示例，请参见&lt;a href=&quot;functions/open&quot;&gt;打开&lt;/a&gt;底部。</target>
        </trans-unit>
        <trans-unit id="6660859ea71d8fc8ba79b6222c7cabca290a534d" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for an example.</source>
          <target state="translated">创建匿名文件句柄的另一种方法是使用Symbol模块或IO :: Handle模块及其类似组件。这些模块的优点是不会在local（）期间隐藏相同名称的不同类型。有关示例，请参见&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc&lt;/a&gt;中&amp;ldquo;打开&amp;rdquo;的底部。</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">调试编译时代码的另一种方法是启动调试器,将断点设置在</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">声明 &lt;code&gt;host&lt;/code&gt; 另一种方法是在CODE：部分中使用C块：</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">在本地禁用安全信号行为的另一种方法是使用CPAN 的 &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; 模块，该模块会影响所有信号。</target>
        </trans-unit>
        <trans-unit id="11569e74dec6446efa52dec2c7a4e093532b6648" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">检查树的另一种方法是使用编译器后端模块，例如&lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">检查树的另一种方法是使用编译器后端模块，例如&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">另一种对底层对象的引用下手的方式是使用tied()函数,所以他们可能会交替使用设置clobber。</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">另一种方式是通过比特来看。</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">无需修改程序即可修改 &lt;code&gt;@INC&lt;/code&gt; 的另一种方法是使用 &lt;code&gt;lib&lt;/code&gt; pragma，例如：</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">另一种查看PM程序输出的方法是将其运行为</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">跳过UTF-8字符串中字符的另一种方法是使用 &lt;code&gt;utf8_hop&lt;/code&gt; ，它需要一个字符串和许多字符来跳过。但是，您只需要进行边界检查，因此请不要轻易使用它。</target>
        </trans-unit>
        <trans-unit id="bdbeba721ab6028c2b3830fe28f0b278956ef2ae" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt;, which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">跳过UTF-8字符串中字符的另一种方法是使用 &lt;code&gt;utf8_hop&lt;/code&gt; ，它需要一个字符串和许多字符来跳过。但是，您需要自己进行边界检查，因此请不要轻易使用它。</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">另一种用一个参数指定许多INSTALL目录的方法是LIB。</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">编写 &lt;code&gt;Is_latin_1()&lt;/code&gt; 的另一种方法是显式使用范围内的字符：</target>
        </trans-unit>
        <trans-unit id="7b86cf4ed2b3d4be5d67a5a0ca22b08970c9b1b4" translate="yes" xml:space="preserve">
          <source>Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</source>
          <target state="translated">安斯加&amp;middot;伯查德（Ansgar Burchardt）&amp;lt;ansgar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fcb531954bffd941479549648f2841c2d77a7164" translate="yes" xml:space="preserve">
          <source>Anton Tagunov doubts its usefulness.</source>
          <target state="translated">安东-塔古诺夫怀疑它的作用。</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">例子中使用的$(FOO)都是make变量,不是Perl。</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">使用的任何&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;用户定义属性&lt;/a&gt;必须在编译正则表达式时已经定义（但请注意，可以使用此构造代替此类属性）。</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">组成，初始化，祝福并返回&lt;b&gt;object的&lt;/b&gt;任何&lt;b&gt;类方法&lt;/b&gt;，&lt;b&gt;实例&lt;/b&gt;或&lt;b&gt;子例程&lt;/b&gt;。有时我们用宽松的术语来指&lt;b&gt;作曲家&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">任何 &lt;code&gt;\&lt;/code&gt; （反斜杠）都将转换为 &lt;code&gt;/&lt;/code&gt; （正斜杠），然后在结果上调用File :: Spec :: Unix canonpath（）。</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">任何 &lt;code&gt;make&lt;/code&gt; 或 &lt;code&gt;test&lt;/code&gt; 都是无条件运行的。一个</target>
        </trans-unit>
        <trans-unit id="bf7362a2fe12e03fc4b84c1c886bc1d5ed325938" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;use utf8&lt;/code&gt; or &lt;code&gt;no utf8&lt;/code&gt; declarations within the string have no effect, and source filters are forbidden. (&lt;code&gt;unicode_strings&lt;/code&gt;, however, can appear within the string.) See also the &lt;a href=&quot;#evalbytes-EXPR&quot;&gt;&lt;code&gt;evalbytes&lt;/code&gt;&lt;/a&gt; operator, which works properly with source filters.</source>
          <target state="translated">字符串中的任何 &lt;code&gt;use utf8&lt;/code&gt; 声明或 &lt;code&gt;no utf8&lt;/code&gt; 使用utf8声明均无效，并且禁止使用源过滤器。（但是， &lt;code&gt;unicode_strings&lt;/code&gt; 可以出现在字符串中。）另请参见&lt;a href=&quot;#evalbytes-EXPR&quot;&gt; &lt;code&gt;evalbytes&lt;/code&gt; &lt;/a&gt;运算符，该运算符可与源过滤器一起正常使用。</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">任何SV可能都是神奇的，也就是说，它具有普通SV没有的特殊功能。这些功能存储在SV结构中的 &lt;code&gt;struct magic&lt;/code&gt; （已定义为 &lt;code&gt;MAGIC&lt;/code&gt; )的链接列表中。</target>
        </trans-unit>
        <trans-unit id="33b69c22f5834c109ce23cffa5c65513da0e84fe" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt;'s, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt;.</source>
          <target state="translated">任何SV可能都是神奇的，也就是说，它具有普通SV没有的特殊功能。这些功能存储在SV结构中的 &lt;code&gt;struct magic&lt;/code&gt; （定义为 &lt;code&gt;MAGIC&lt;/code&gt; )的链接列表中。</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">任何附加参数都应该是要生成代码的模块名称。</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">在&lt;b&gt;-&lt;/b&gt;标记之前找到的所有其他参数都应该是为其生成代码的模块的名称。</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">任何你想传递给链接器的附加标志。</target>
        </trans-unit>
        <trans-unit id="76af9e90cc2fb275b94658ee19c44c077d496116" translate="yes" xml:space="preserve">
          <source>Any argument provided is passed as CHECK to underlying Encode::decode() call. Pass the value &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; to have the decoding croak if not all the command line arguments can be decoded. See &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot; in Encode&lt;/a&gt; for details on other options for CHECK.</source>
          <target state="translated">提供的任何参数都作为CHECK传递给基础的Encode :: decode（）调用。如果不是所有的命令行参数都可以被解码，则传递值 &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; 以使解码嘶哑。有关CHECK的其他选项的详细信息，请参见&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;编码中的&amp;ldquo;处理格式错误的数据&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">任何看起来像信号名称的参数（即 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）都表明&lt;b&gt;sigtrap&lt;/b&gt;应该为该名称安装一个处理程序。</target>
        </trans-unit>
        <trans-unit id="f26e937185e1c5cd97a379a8dabb810b138157bc" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt;) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">任何看起来像信号名称的参数（即 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）都表明&lt;b&gt;sigtrap&lt;/b&gt;应该为该名称安装一个处理程序。</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">第二个'--'标记后的任何参数都是附加的链接器参数,它们将被检查是否有潜在的冲突。如果没有冲突,附加参数将成为输出的一部分。</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">传入的所有参数都显示在数组 &lt;code&gt;@_&lt;/code&gt; 中。（它们也可能显示在签名引入的词法变量中；请参阅下面的&lt;a href=&quot;#Signatures&quot;&gt;签名&lt;/a&gt;。）因此，如果您调用带有两个参数的函数，则这些参数将存储在 &lt;code&gt;$_[0]&lt;/code&gt; 和 &lt;code&gt;$_[1]&lt;/code&gt; 中。数组 &lt;code&gt;@_&lt;/code&gt; 是本地数组，但是其元素是实际标量参数的别名。特别是如果元素 &lt;code&gt;$_[0]&lt;/code&gt; 更新，相应的参数也将更新（如果不可更新，则会发生错误）。如果参数是在调用函数时不存在的数组或哈希元素，则仅在（如果有）对其进行修改或对其进行引用时才创建该元素。 （一些早期版本的Perl不管是否分配了元素都创建了该元素。）分配给整个数组 &lt;code&gt;@_&lt;/code&gt; 会删除该别名，并且不会更新任何参数。</target>
        </trans-unit>
        <trans-unit id="f35f240798e3c5e460d473d423be038d4c72e7d0" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt;. (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt;. The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">传入的所有参数都显示在数组 &lt;code&gt;@_&lt;/code&gt; 中。 （它们也可能显示在签名引入的词法变量中；请参见下面的&lt;a href=&quot;#Signatures&quot;&gt;&amp;ldquo;签名&amp;rdquo;&lt;/a&gt;。）因此，如果您调用带有两个参数的函数，则这些参数将存储在 &lt;code&gt;$_[0]&lt;/code&gt; 和 &lt;code&gt;$_[1]&lt;/code&gt; 中。数组 &lt;code&gt;@_&lt;/code&gt; 是本地数组，但是其元素是实际标量参数的别名。特别是，如果元素 &lt;code&gt;$_[0]&lt;/code&gt; 进行更新，相应的参数也将更新（如果不可更新，则会发生错误）。如果参数是在调用函数时不存在的数组或哈希元素，则仅在（如果有）对其进行修改或对其进行引用时才创建该元素。 （一些早期版本的Perl不管是否分配了元素都创建了该元素。）分配给整个数组 &lt;code&gt;@_&lt;/code&gt; 将删除该别名，并且不更新任何参数。</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">STRING中的代码如果试图使用一个不被隔层允许的操作符,就会引起一个错误(在主程序运行时,但STRING中的代码在编译时)。错误的形式是&quot;'%s'被操作掩码所困...&quot;。</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">任何反斜杠原型字符都代表一个实际参数，该参数必须以该字符开头（可选地以 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 开头）， &lt;code&gt;$&lt;/code&gt; 除外，它将接受任何标量左值表达式，例如 &lt;code&gt;$foo = 7&lt;/code&gt; 或 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 。作为 &lt;code&gt;@_&lt;/code&gt; 的一部分传递的值将是对子例程调用中给定的实际参数的引用，该子参数是通过将 &lt;code&gt;\&lt;/code&gt; 应用于该参数而获得的。</target>
        </trans-unit>
        <trans-unit id="ffa3112ef74eec5708dbce1d67d94690c63f3116" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt;, which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt;. The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">任何反斜杠原型字符都代表一个实际参数，该参数必须以该字符开头（可选地以 &lt;code&gt;my&lt;/code&gt; ， &lt;code&gt;our&lt;/code&gt; 或 &lt;code&gt;local&lt;/code&gt; 开头）， &lt;code&gt;$&lt;/code&gt; 除外，它将接受任何标量左值表达式，例如 &lt;code&gt;$foo = 7&lt;/code&gt; 或 &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; 。作为 &lt;code&gt;@_&lt;/code&gt; 的一部分传递的值将是对子例程调用中给定的实际参数的引用，该子参数通过将 &lt;code&gt;\&lt;/code&gt; 应用于该参数而获得。</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">任何包对自己的调用都是安全的。</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">任何来自 Perl 内部模块的调用都是安全的。(没有什么能阻止用户模块将自己标记为Perl的内部模块,但这种做法是不鼓励的。)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">调用Perl的警告系统（例如Carp本身）都是安全的。（此规则使它无法在您称为 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的位置报告错误。）</target>
        </trans-unit>
        <trans-unit id="3b252f8b26d454c8056df1a78fc7a97e6d22f01f" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;.)</source>
          <target state="translated">调用Perl的警告系统（例如Carp本身）都是安全的。（此规则使它无法在您称为 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的位置报告错误。）</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;\d&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\D&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="a92f497a3debf42be69af7cf310d253bf9089f09" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;\d&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\D&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">与 &lt;code&gt;\s&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\S&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="6f9b47e6ac747d8625677192454745261e50c9f3" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;\s&lt;/code&gt; 不匹配的任何字符都由 &lt;code&gt;\S&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">任何字符不匹配 &lt;code&gt;\w&lt;/code&gt; 由匹配 &lt;code&gt;\W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca92dc8b5b50382eccc8de66976a91add27a47ad" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="translated">任何字符不匹配 &lt;code&gt;\w&lt;/code&gt; 由匹配 &lt;code&gt;\W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">任何不属于65个字符的base64子集的字符都会被忽略。'='填充字符之后的字符永远不会被解码。</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">任何角色,都是</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">具有组合标记常规类别（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）的任何字符，可以是空格或非空格。有些甚至是看不见的。组合字符的跟随字形基字符的序列一起组成称为单用户可见的字符&lt;b&gt;字形&lt;/b&gt;。大多数但并非全部变音符号都结合了字符，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f7f37ee9ffee4805d8681593ea741f6cb413f361" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt;), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">具有组合标记常规类别（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）的任何字符，可以是空格或非空格。有些甚至是看不见的。组合字符的跟随字形基字符的序列一起组成称为单用户可见的字符&lt;b&gt;字形&lt;/b&gt;。大多数但并非全部变音符号都结合了字符，反之亦然。</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">任何从重载类派生出来的类也是重载的,并继承其操作符实现。如果同一个操作符在一个以上的祖先中被重载,那么其实现是由通常的继承规则决定的。</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">任何这个函数返回true的类都是 &quot;通用 &quot;的,即所有的类都有可能继承它的方法。</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">任何类都可以定义钩子,这些钩子将在序列化和反序列化过程中对作为该类实例的对象进行调用。这些钩子可以重新定义序列化的执行方式(因此,对称的反序列化应该如何进行)。</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">调试器无法识别的任何命令都将作为当前包中的Perl代码直接执行（ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd）。（调试器使用数据库包来保留其自身的状态信息。）</target>
        </trans-unit>
        <trans-unit id="78f7d4f4e5eb056442905f4be332daa2d7078212" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;eval&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">调试器无法识别的任何命令都将作为当前包中的Perl代码直接执行（ &lt;code&gt;eval&lt;/code&gt; 'd）。（调试器使用DB包来保留其自己的状态信息。）</target>
        </trans-unit>
        <trans-unit id="e1fcc44228bcb7043c7f8789e115cc416dabfd31" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch by first adding an entry to the relevant voting file in the maint-votes branch announcing the commit as a candidate for back-porting, and then waiting for at least two other committers to add their votes in support of this (i.e. a total of at least three votes is required before a commit may be back-ported).</source>
          <target state="translated">任何提交者都可以从 blead 分支中挑出任何一个提交到 maint 分支,首先在 maint-votes 分支的相关投票文件中添加一个条目,宣布该提交为回溯移植的候选,然后等待至少两个其他提交者添加他们的投票支持(也就是说,至少需要三个投票才可以回溯移植)。</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">任何提交者都可以从 blead 分支中挑选任何一个提交到主分支,只要他们向 perl5-porters 发出邮件,宣布他们想挑选一个特定的提交,并说明这样做的理由,并且至少有两个其他提交者回复名单表示同意。(这个政策适用于现在的、以前的、以及其他提交者。)</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">任何包含的POSIX字符类，包括 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\D&lt;/code&gt; 类的东西都遵循 &lt;code&gt;/a&lt;/code&gt; （和 &lt;code&gt;/aa&lt;/code&gt; ）修饰符。</target>
        </trans-unit>
        <trans-unit id="ed912b6d995f34c695ed9e38e5b4d742feccc889" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt;) modifiers.</source>
          <target state="translated">任何包含的POSIX字符类，包括 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\D&lt;/code&gt; 类的东西，都遵循 &lt;code&gt;/a&lt;/code&gt; （和 &lt;code&gt;/aa&lt;/code&gt; ）修饰符。</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;thread :: shared&lt;/a&gt;支持的任何数据类型都可以通过队列传递：</target>
        </trans-unit>
        <trans-unit id="4e0656683c3bae7fc0640dbcbac9a2b39fa2d301" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;thread :: shared&lt;/a&gt;支持的任何数据类型都可以通过队列传递：</target>
        </trans-unit>
        <trans-unit id="e796dc658263f7829a0c740b0d175dbd881579ef" translate="yes" xml:space="preserve">
          <source>Any diagnostics that were output for the test. This only includes diagnostics output &lt;b&gt;after&lt;/b&gt; the test result is declared.</source>
          <target state="translated">测试输出的所有诊断信息。仅包括&lt;b&gt;在&lt;/b&gt;声明测试结果&lt;b&gt;之后&lt;/b&gt;的诊断输出。</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">如果有的话,提取路径前缀的任何目录。</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">任何现有的</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">对Perl的任何扩展，包括那些包含XSUB的扩展，都应该有一个Perl模块作为引导程序，将扩展引入Perl。此模块将扩展的功能和变量导出到Perl程序，并使扩展的XSUB链接到Perl。以下模块将用于本文档中的大多数示例，并且应通过Perl与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 命令一起使用，如先前所示。Perl模块将在本文档的后面部分更详细地说明。</target>
        </trans-unit>
        <trans-unit id="4138f336ca25f7058dac8592c9829407df50fe3e" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;use&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">对Perl的任何扩展，包括那些包含XSUB的扩展，都应该有一个Perl模块作为引导程序，将扩展引入Perl。此模块将扩展的功能和变量导出到Perl程序，并使扩展的XSUB链接到Perl。以下模块将用于本文档中的大多数示例，并且应从Perl中 &lt;code&gt;use&lt;/code&gt; 命令（如先前所示）使用。Perl模块将在本文档的后面部分更详细地说明。</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">此方法应删除不应传递给 &lt;code&gt;plan()&lt;/code&gt; 的所有其他参数。</target>
        </trans-unit>
        <trans-unit id="479572afcef4faf54a80923b02d6ecab023cba50" translate="yes" xml:space="preserve">
          <source>Any extra arguments you want passed into the subtest code.</source>
          <target state="translated">任何你想传递到子测试代码的额外参数。</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">任何在fork()时打开的文件句柄都会被dup()-ed。因此,文件可以在父文件和子文件中独立关闭,但要注意 dup()-ed 句柄仍然会共享同一个 seek 指针。改变父文件中的寻求位置会改变子文件中的寻求位置,反之亦然。可以通过在子程序中分别打开需要不同的寻求指针的文件来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">下面列表中的任何函数都可以在其参数周围使用或不使用括号。(语法描述省略了括号)。(语法描述省略了括号。)如果你使用括号,简单但有时令人惊讶的规则是这样的。它</target>
        </trans-unit>
        <trans-unit id="9f6c837fd47f5e061c1ecbb824c94df3994dcde5" translate="yes" xml:space="preserve">
          <source>Any good book on software engineering</source>
          <target state="translated">有什么好的软件工程书籍吗?</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">值为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的所有键都将被忽略。</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">值为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 的所有键都将被忽略。</target>
        </trans-unit>
        <trans-unit id="b98397e3061065c914af3247fdcc89fdfd6a02c2" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;undef&lt;/code&gt; will be ignored.</source>
          <target state="translated">值为 &lt;code&gt;undef&lt;/code&gt; 的所有键都将被忽略。</target>
        </trans-unit>
        <trans-unit id="568e69d3500c9fb9cde3152f15ae5ed8fcf84af4" translate="yes" xml:space="preserve">
          <source>Any keys not described in this specification document (whether top-level or within compound data structures described herein) are considered</source>
          <target state="translated">本规范文件中没有描述的任何键(无论是顶层还是在本文描述的复合数据结构中)都被认为是</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">任何一个大型的IRC网络(Dalnet、EFnet)也都可能有一个#perl频道,活跃度不一。</target>
        </trans-unit>
        <trans-unit id="9ec17e0cbd0b3e2eebd6b6cf6a596cebb4cfc33d" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;:&quot;&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;&quot;?&quot;&lt;/code&gt; 之间的任何字母 和 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 与 &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt; 一样用作标志修饰符。例如，</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">之间有字母 &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 与 &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; 一样用作标志修饰符。例如，</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 创建的对象上的任何方法调用都将作为常规对象分派到程序包。</target>
        </trans-unit>
        <trans-unit id="26b68c72e2b484267b2f658de2349d6444e86420" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;qr//&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">使用 &lt;code&gt;qr//&lt;/code&gt; 创建的对象上的任何方法调用都将作为常规对象分派到程序包。</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">任何标记的方法</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">这里没有列出的任何方法都是从Math::BigFloat(或Math::BigInt)派生出来的,所以请务必查看这两个模块以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">任何混合都是可能的。例如,最常用的选项可以存储在变量中,而所有其他选项则存储在哈希中。</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">任何不是标签的名称都将 &lt;code&gt;@EXPORT&lt;/code&gt; 添加到@EXPORT或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; ,但会触发警告（带有 &lt;code&gt;-w&lt;/code&gt; ），以避免将拼写错误的标签名称默默添加到 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。将来的版本可能会导致此致命错误。</target>
        </trans-unit>
        <trans-unit id="f1edfb250e37d4b9a7863e1b2498e2a280885f23" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt;) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Future versions may make this a fatal error.</source>
          <target state="translated">任何不是标签的名称都将 &lt;code&gt;@EXPORT&lt;/code&gt; 添加到@EXPORT或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; ,但会触发警告（带有 &lt;code&gt;-w&lt;/code&gt; ），以避免将拼写错误的标签名称默默添加到 &lt;code&gt;@EXPORT&lt;/code&gt; 或 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 。将来的版本可能会导致此致命错误。</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">$perl_code中的任何换行符都将被转义。前导和尾部的换行符将被删除。这让这个成语变得更加简单。</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">任何非空格分隔符都可以替换斜杠。使用标识符允许的字符时，在 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 后添加空格。如果使用单引号，则不会对替换字符串进行任何解释（但是 &lt;code&gt;/e&lt;/code&gt; 修饰符会覆盖此内容）。请注意，Perl将反引号视为常规定界符；替换文本不作为命令求值。如果</target>
        </trans-unit>
        <trans-unit id="48ec8f1e8af52f4ed4957bdfee1ffd49c84a8c6f" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;s&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">任何非空格分隔符都可以替换斜杠。使用标识符中允许的字符时，在 &lt;code&gt;s&lt;/code&gt; 后添加空格。如果使用单引号，则不会对替换字符串进行任何解释（但是 &lt;code&gt;/e&lt;/code&gt; 修饰符会覆盖此内容）。请注意，Perl将反引号视为普通的定界符；替换文本不作为命令求值。如果</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">模式中可以使用任意数量的 &lt;code&gt;(*PRUNE)&lt;/code&gt; 断言。</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">在数组之前的列表中可以出现任何数量的参数,但输入和输出数组必须是列表中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">任何数量的tildes和周围的whitespace将被折叠成一个空间。</target>
        </trans-unit>
        <trans-unit id="6743acd9891044d5d8bdbb4fb2163336b42729f9" translate="yes" xml:space="preserve">
          <source>Any numerical value returned which is less than SVt_PVAV will be a scalar of some form.</source>
          <target state="translated">任何小于SVt_PVAV的数值都将是某种形式的标量。</target>
        </trans-unit>
        <trans-unit id="c027e1a6e6b64e23c560209fac7288c23f0070f0" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;&quot;CONSTRUCTOR ARGUMENTS&quot; in IO::Socket&lt;/a&gt; may be passed to the constructor, but if any arguments are provided, then one of them must be the &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument. The &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument can, by default, be either &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_UNIX&lt;/code&gt;. Other domains can be used if a proper subclass for the domain family is registered. All other arguments will be passed to the &lt;code&gt;configuration&lt;/code&gt; method of the package for that domain.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;IO :: Socket中的&lt;/a&gt;任何&amp;ldquo; CONSTRUCTOR ARGUMENTS&amp;rdquo;都可以传递给构造函数，但是如果提供了任何参数，则其中之一必须是&lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt;参数中的&amp;ldquo; Domain&amp;rdquo;。&lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt;参数中的&amp;ldquo;域&amp;rdquo;默认情况下可以为 &lt;code&gt;AF_INET&lt;/code&gt; 或 &lt;code&gt;AF_UNIX&lt;/code&gt; 。如果为域系列注册了适当的子类，则可以使用其他域。所有其他参数将传递给该域的程序包的 &lt;code&gt;configuration&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="d9c5d3662ce5a04f9a5a84a78523f9d65e2d1542" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the &lt;code&gt;$timeleft&lt;/code&gt;. If not, they always return &lt;code&gt;$timeleft&lt;/code&gt; equal to the supplied &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="translated">任何位掩码也可以是&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。超时（如果指定）以秒为单位，可以是分数。注意：并非所有实现都能返回 &lt;code&gt;$timeleft&lt;/code&gt; 。如果不是，则它们始终返回等于提供的 &lt;code&gt;$timeout&lt;/code&gt; &lt;code&gt;$timeleft&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">任何一个位掩码也可以是undef。如果指定了超时,则以秒为单位,可以是小数。注意:并非所有的实现都能返回$timeleft。如果不能,它们总是返回$timeleft等于提供的$timeout。</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">可以将这些修饰符中的任何一个设置为全局应用于在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; 范围内编译的所有正则表达式。请参见&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;re中的&amp;ldquo; / flags&amp;rdquo;模式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="511eb3ecca55bf6890b46608108a95afce5c385f" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;use re&lt;/code&gt;. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt;.</source>
          <target state="translated">可以将这些修饰符中的任何一个设置为全局应用于在 &lt;code&gt;use re&lt;/code&gt; 范围内编译的所有正则表达式。请参阅&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;re中的&amp;ldquo; / flags模式&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">这些语句中的任何一个都可以很好地替代 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 用相同的编译时的效果。基本区别是 &lt;code&gt;base&lt;/code&gt; 代码与声明的 &lt;code&gt;fields&lt;/code&gt; 进行交互，而 &lt;code&gt;parent&lt;/code&gt; 是旧版本 &lt;code&gt;base&lt;/code&gt; 代码的简化版本，仅用于建立IS-A关系。</target>
        </trans-unit>
        <trans-unit id="a58afbeb2eaab93b0832f3d91597b76dd426bf94" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">这些语句中的任何一个都可以很好地替代 &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 用相同的编译时的效果。基本区别在于， &lt;code&gt;base&lt;/code&gt; 代码与声明的 &lt;code&gt;fields&lt;/code&gt; 进行交互，而 &lt;code&gt;parent&lt;/code&gt; 是旧版本 &lt;code&gt;base&lt;/code&gt; 代码的简化版本，仅用于建立IS-A关系。</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">任何省略或空的正则表达式将默认为&quot;.*&quot;。请注意,每个给定的正则表达式都会在开头和结尾处添加&quot;^&quot;和&quot;$&quot;,从而隐式锚定。此外,如果给定的正则表达式以&quot;!&quot;字符开头,那么表达式就是</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">任何其他的角色,它从字面上看。</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">与该方法有关的任何其他参数</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">任何其他返回代码意味着未找到刷新点。如果有更多数据可用， &lt;code&gt;inflateSync&lt;/code&gt; 可以使用更多压缩数据重复调用inflateSync，直到找到刷新点为止。</target>
        </trans-unit>
        <trans-unit id="f1dc9b8d3bdcecba91d97097df903ce52027fe14" translate="yes" xml:space="preserve">
          <source>Any other string</source>
          <target state="translated">任何其他字符串</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">任何要压入堆栈的参数都应在 &lt;code&gt;PUSHMARK&lt;/code&gt; 和 &lt;code&gt;PUTBACK&lt;/code&gt; 宏后面加上括号。在这种情况下，这两个宏的目的是计算您自动推送的参数数量。然后，每当Perl为子例程创建 &lt;code&gt;@_&lt;/code&gt; 数组时，它就会知道要创建多大的数组。</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">包含允许参数的特殊回溯动词的任何模式都具有特殊的行为，即在执行时会设置当前包的 &lt;code&gt;$REGERROR&lt;/code&gt; 和 &lt;code&gt;$REGMARK&lt;/code&gt; 变量。这样做时，以下规则适用：</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">与传入的引用之一相同的任何引用将被命名为 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 中的任何正则表达式特殊字符仍然是特殊字符，该模式仍然必须有效，否则Perl会抱怨。例如，在此模式中，存在不成对的括号。</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">任何不等于0或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 标量值。</target>
        </trans-unit>
        <trans-unit id="bc814185c98806f976443ba7f707c9de190e5102" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">任何不等于0或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 标量值。</target>
        </trans-unit>
        <trans-unit id="1aef8e8c0d886239b79a86d40fbcb9638ca8176a" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">任何标量变量都可以带有 &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; 魔术，该魔术包含该变量的标量数据，但是会转换为可以使用常规内存比较来根据语言环境设置比较数据的格式。</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">任何标量变量都可以携带PERL_MAGIC_collxfrm魔法,该魔法包含变量的标量数据,但转换为这样一种格式,即可以根据locale设置使用正常的内存比较来比较数据。</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">任何简单的语句后面都可以选择加一个</target>
        </trans-unit>
        <trans-unit id="6edad6532b87dcd9565ed8ca948fd8e9febfc827" translate="yes" xml:space="preserve">
          <source>Any single character in a pattern matches that same character in the target string, unless the character is a</source>
          <target state="translated">模式中的任何一个字符都与目标字符串中的相同字符相匹配,除非该字符是一个。</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">任何单个字符都与自己匹配,除非它是一个。</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">可能需要将任何特殊标志传递给ld，以创建适合于动态加载的共享库。使用它取决于makefile。（请参阅&lt;a href=&quot;../config#lddlflags&quot;&gt;Config中的lddlflags&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="bea6827ac537eb7924457a4cf759d617d88c98bb" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;config#lddlflags&quot;&gt;&quot;lddlflags&quot; in Config&lt;/a&gt;)</source>
          <target state="translated">可能需要将任何特殊标志传递给ld，以创建适合于动态加载的共享库。使用makefile取决于makefile。（请参阅&lt;a href=&quot;config#lddlflags&quot;&gt;Config中的&amp;ldquo; lddlflags&amp;rdquo;&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">循环体内任何可以使循环过早停止循环或跳过&lt;b&gt;迭代的&lt;/b&gt;语句。通常，您不应该在过山车上尝试此操作。</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">任何被在隔间中执行的代码所执行的字符串eval,或者被在隔间中执行的代码所调用的代码,都会在隔间的命名空间中被eval。这是个潜在的严重问题。</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 环境变量中的所有开关都将在命令行参数之前使用。</target>
        </trans-unit>
        <trans-unit id="7c3b8e236160fc72cba179bfa08e7e8fcf86e97c" translate="yes" xml:space="preserve">
          <source>Any test which does not match a rule will be run in sequence at the end of the run.</source>
          <target state="translated">任何不符合规则的测试都将在运行结束时按顺序运行。</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perl开始运行主程序后的任何时间。另请参见&lt;b&gt;编译阶段&lt;/b&gt;。运行阶段主要是花费在&lt;b&gt;运行&lt;/b&gt;，但也可以在花费&lt;b&gt;编译时间&lt;/b&gt;的时候 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c3d3bd0813c99a89a071ee04615c19b004d52d" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">Perl开始运行主程序后的任何时间。另请参见&lt;b&gt;编译阶段&lt;/b&gt;。运行阶段主要是花费在&lt;b&gt;运行&lt;/b&gt;，但也可以在花费&lt;b&gt;编译时间&lt;/b&gt;的时候 &lt;code&gt;require&lt;/code&gt; ， &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl开始运行主程序之前的任何时间。另请参见&lt;b&gt;运行阶段&lt;/b&gt;。编译阶段主要花费在&lt;b&gt;编译时&lt;/b&gt;，但是也可能花费在&lt;b&gt;运行&lt;/b&gt;时，当 &lt;code&gt;BEGIN&lt;/code&gt; 块， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 使用声明，或评估常量子表达式时。任何 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明的启动和导入代码也在编译阶段运行。</target>
        </trans-unit>
        <trans-unit id="89bbb32771fb02c8c9a2b7c9c816ca4c3b49cddb" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;use&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perl开始运行主程序之前的任何时间。另请参见&lt;b&gt;运行阶段&lt;/b&gt;。编译阶段主要用在&lt;b&gt;编译时&lt;/b&gt;，但也可能用在&lt;b&gt;运行&lt;/b&gt;时，例如 &lt;code&gt;BEGIN&lt;/code&gt; 块， &lt;code&gt;use&lt;/code&gt; 或 &lt;code&gt;no&lt;/code&gt; 使用声明，或正在评估常量子表达式时。任何 &lt;code&gt;use&lt;/code&gt; 声明的启动和导入代码也在编译阶段运行。</target>
        </trans-unit>
        <trans-unit id="08963a941982a994fe2895ea2c775da89cda3e41" translate="yes" xml:space="preserve">
          <source>Any time you're doing a &quot;this equals that&quot; sort of test, use &lt;code&gt;is()&lt;/code&gt;. It even works on arrays. The test is always in scalar context, so you can test how many elements are in an array this way. [5]</source>
          <target state="translated">每当您进行&amp;ldquo;等于&amp;rdquo;测试时，请使用 &lt;code&gt;is()&lt;/code&gt; 。它甚至适用于数组。该测试始终在标量环境中进行，因此您可以通过这种方式测试数组中有多少个元素。[5]</target>
        </trans-unit>
        <trans-unit id="aa83fb5c769020023303529abde854eefeaa0d66" translate="yes" xml:space="preserve">
          <source>Any version between 1.00 and 1.82 inclusive would be acceptable, except for 1.75.</source>
          <target state="translated">1.00至1.82(含)之间的任何版本都可以接受,但1.75除外。</target>
        </trans-unit>
        <trans-unit id="c34097998161c40da19bcb944501b160cf796dc7" translate="yes" xml:space="preserve">
          <source>Any version from version 1.2 onward, except version 1.5, that also precedes version 2.0.</source>
          <target state="translated">从1.2版本开始的任何版本,除了1.5版本,也就是2.0版本之前的版本。</target>
        </trans-unit>
        <trans-unit id="db5515dadcc88944ac0dd16b3a430dc89d34c3d0" translate="yes" xml:space="preserve">
          <source>Any version which &quot;looks like a number&quot;, see &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;. This also includes versions with a single decimal point and a single embedded underscore, see &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;, even though these must be quoted to preserve the underscore formatting.</source>
          <target state="translated">任何&amp;ldquo;看起来像数字&amp;rdquo;的&lt;a href=&quot;#Decimal-Versions&quot;&gt;版本&lt;/a&gt;，请参见&amp;ldquo;十进制版本&amp;rdquo;。这也包括带有单个小数点和单个嵌入式下划线的&lt;a href=&quot;#Alpha-Versions&quot;&gt;版本&lt;/a&gt;，请参阅&amp;ldquo; Alpha版本&amp;rdquo;，即使必须使用引号将其保留下划线格式也是如此。</target>
        </trans-unit>
        <trans-unit id="7bc6b65d5c451906eff3dea5dd5120214b2325bd" translate="yes" xml:space="preserve">
          <source>Any/all fields and accessors are autovivified into existence. There is no way to know what metadata may be added, so any is allowed.</source>
          <target state="translated">任何/所有的字段和存取器都会自动存活。没有办法知道可以添加什么元数据,所以允许添加任何元数据。</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-为多个DBM提供框架。</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">任何对复活这个文件感兴趣的人都应该从MakeMaker CVS仓库中提取旧版本,并联系makemaker@perl.org。</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">此行之后的所有内容都是XSUB函数的描述。&lt;b&gt;xsubpp&lt;/b&gt;将这些描述转换为C代码，该代码使用Perl调用约定来实现这些功能，并使这些功能在Perl解释器中可见。</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">这行之前的所有内容都是纯C代码，它描述了要包含的标头，并定义了一些便利功能。此部分不执行任何翻译，除了跳过嵌入式POD文档（请参阅&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;）之外，它直接进入生成的输出C文件。</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">空格和 &lt;code&gt;MANIFEST&lt;/code&gt; 文件中的行尾之间的任何内容均视为注释。以＃开头的任何行也是注释。从ExtUtils :: Manifest 1.52开始，如果文件名用单引号引起来，则文件名可能包含空格字符；该文件名中的单引号或反斜杠必须使用反斜杠转义。</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">其他的都是Perl专用的方便缩写。如果你想用脚本专用的短名来指定一个或多个脚本的名字。</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">EXPR中任何与PATTERN匹配的内容都会被视为分隔符,将EXPR分隔成子串(称为 &quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">凡是标记为BE的都是Big Endian(或网络字节序),LE是Little Endian(又称VAX字节序)。对于没有标记为BE或LE的任何东西,一个称为字节顺序标记(BOM)的字符将被预置到字符串中,以表示恩典性。</target>
        </trans-unit>
        <trans-unit id="09e186b65803161a334d1142c77aae1e01d4460e" translate="yes" xml:space="preserve">
          <source>Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="translated">这里没有列出的任何东西都不是公共API的一部分,扩展编写者根本不应该使用。基于这些原因,在编写扩展时要避免盲目使用proto.h中列出的函数。</target>
        </trans-unit>
        <trans-unit id="43c6485292ca5760fa287d9f9ae8c3f36373f766" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to &lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY::postamble()&lt;/a&gt; if you have one.</source>
          <target state="translated">如果您有任何东西，这里放的任何东西都将传递给&lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY :: postamble（）&lt;/a&gt;。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
