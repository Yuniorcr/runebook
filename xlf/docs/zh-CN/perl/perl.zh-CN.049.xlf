<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">选择新的盐时，创建一个随机的两个字符串，其字符来自集合 &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; （例如 &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。这组字符只是一个建议；盐中允许的字符仅取决于系统的crypt库，Perl不能限制 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; 接受的盐。</target>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">与变量声明结合使用时，仅第一次执行对 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 变量的简单标量分配（如 &lt;code&gt;state $x = 42&lt;/code&gt; ）。以后评估此类语句时，将忽略该分配。此类分配给非标量变量的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">比较 &lt;code&gt;$]&lt;/code&gt; 时，&lt;b&gt;强烈建议使用&lt;/b&gt;字符串比较运算符。二进制浮点表示法的固有局限性有时会导致在某些体系结构上对某些数字进行不正确的比较。</target>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">当在Tru64中编译Perl时,你可能会看到两个警告,比如说</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">当编译Perl时,你必须使用ANSI C编译器。AIX默认不提供符合ANSI标准的C编译器,但AIX的gcc二进制编译器可以广泛使用。AIX工具箱中也包含了gcc的版本,它是随AIX一起提供的。</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">当编译Perl时,你必须使用ANSI C编译器。AIX默认不提供符合ANSI标准的C编译器,但AIX的gcc二进制编译器可以广泛使用。</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">编译Perl时，必须使用ANSI C编译器。所有HP-UX系统随附的C编译器是K＆R编译器，仅应用于构建新内核。</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">当在PASE中编译时,没有 &quot;oslevel &quot;命令,因此,你可能需要创建一个名为 &quot;oslevel &quot;的脚本来呼应你的PASE运行时版本所支持的AIX级别。因此,你可能需要创建一个名为 &quot;oslevel &quot;的脚本,以呼应你的PASE运行时版本所支持的AIX级别。如果你不确定,请查阅你的文档或使用 &quot;4.3.3.0&quot;。</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">当对字符串进行补码时，如果所有字符的序数值都小于256，则它们的补码也将变为。但是，如果不这样做，则所有字符都将使用32位或64位补码，具体取决于您的体系结构。因此，例如，在32位计算机上， &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; 是 &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; ，在64位计算机上是 &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">当配置为捆绑时,单字符选项会区分大小写,而长选项则不区分大小写。要让单字符选项也不区分大小写,请使用:</target>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">当为Symbian或Series 60或Series 80或Series 90创建和扩展应用程序编程接口(API)时,建议不要在API名称中使用商标、注册商标或商品名称。相反,开发者应该考虑以现有的(C++,或者Java)公共组件和API命名为基础,并根据新的API所使用的编程语言的规则进行适当修改。</target>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">处理C结构时，应为XS类型选择&lt;b&gt;T_PTROBJ&lt;/b&gt;或&lt;b&gt;T_PTRREF&lt;/b&gt;。两种类型都旨在处理指向复杂对象的指针。T_PTRREF类型将使Perl对象不受祝福，而T_PTROBJ类型要求使对象受祝福。通过使用T_PTROBJ，可以实现一种类型检查，因为XSUB会尝试验证Perl对象是否为预期的类型。</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">处理二进制文件（或二进制模式的文本文件）时，请确保在使用 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; 之前将$ /显式设置为文件格式的适当值。</target>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">处理参考文献时，请务必谨慎处理。该 &lt;code&gt;INIT:&lt;/code&gt; 块首先调用SvGETMAGIC（路径），如果路径是并列的变量。然后，它检查 &lt;code&gt;SvROK&lt;/code&gt; 是否返回true，这表示路径是有效的引用。 （仅检查 &lt;code&gt;SvROK&lt;/code&gt; 不会触发绑定变量上的FETCH。）然后使用 &lt;code&gt;SvRV&lt;/code&gt; 取消引用路径，并使用 &lt;code&gt;SvTYPE&lt;/code&gt; 来发现路径引用的对象是否是数组。作为附加测试，它使用 &lt;code&gt;av_top_index&lt;/code&gt; 检查路径引用的数组是否为非空函数（如果数组为空，则返回-1）。XSRETURN_UNDEF宏用于中止XSUB并在不满足所有这三个条件的情况下返回未定义的值。</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">当处理包含无法使用八位字符集表示的字符的字符串时，perl使用内部表示形式，它是Unicode的UTF-8编码的允许版本[2]。它使用单个字节来表示ASCII字符集中的字符，并使用两个或多个字节的序列来表示所有其他字符。（有关UTF-8和perl编码utf8之间关系的更多信息，请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;。区别对于本讨论而言并不重要。）</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">调试使用＃！的脚本时 因此通常在$ PATH中找到-S选项使perl在$ PATH中搜索它，因此您不必键入路径或 &lt;code&gt;which $scriptname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">当定义多个常量时,您不能使用在同一声明中定义的其他常量的值。这是因为在调用包时,直到</target>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">在Perl和C库之间设计接口时，从C到XS的直接转换（例如由 &lt;code&gt;h2xs -x&lt;/code&gt; 创建）通常就足够了。但是，有时接口看起来会非常像C，有时甚至是非直觉的，特别是当C函数修改其参数之一或带内返回失败时（如&amp;ldquo;负返回值意味着失败&amp;rdquo;）。在程序员希望创建更像Perl的界面的情况下，以下策略可能有助于识别界面中更关键的部分。</target>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">在开发交互式和/或潜在的长期运行的应用程序时,维护一个持久解释器而不是多次分配和构造一个新的解释器是个好主意。主要的原因是速度:因为Perl只会被载入一次内存。</target>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">当进行XS/Symbian C++编程时,首先包括Symbian头文件,然后是任何标准的C/POSIX头文件,然后是Perl头文件,最后是任何应用程序头文件。</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">从CPAN下载时，请使用 &lt;code&gt;.tgz&lt;/code&gt; 扩展名而不是 &lt;code&gt;.tar.gz&lt;/code&gt; 保存文件。文件名中的所有其他句点都应替换为下划线。例如，应将 &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; 下载为 &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">当Perl调用每个过滤器时， &lt;code&gt;$_&lt;/code&gt; 的本地副本将包含要过滤的键或值。通过修改 &lt;code&gt;$_&lt;/code&gt; 的内容来实现过滤。过滤器的返回码将被忽略。</target>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">当嵌入式代码被量化时,成功匹配的代码将对量化器的每一次匹配迭代调用一次。例如:</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">在评估时，typeglob产生一个标量值，代表该名称的所有对象，包括任何文件句柄，格式或子例程。分配给它时，它使提到的名称引用分配给它的任何 &lt;code&gt;*&lt;/code&gt; 值。例：</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">当在伪进程内部调用exec()时,那么在外部进程返回后,仍然会调用DESTROY方法和END块。</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">当程序执行到达子例程调用时，将调用 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">当程序执行使用 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 输入非XS子例程，并且 &lt;code&gt;$^P&lt;/code&gt; 的0x80位置1时，将调用 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; ，其中 &lt;code&gt;$DB::sub&lt;/code&gt; 保留要输入的子例程的名称。</target>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">当exitcode为非零时,会出现一个消息框,否则控制台就会关闭,所以你可能要在程序中抓到一个状态为0的退出才能看到任何输出。</target>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">使用字段哈希时，基本结构保持不变。每个词法哈希将成为字段哈希。可以从访问器方法中省略对 &lt;code&gt;refaddr&lt;/code&gt; 的调用。不需要DESTROY和CLONE方法。</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">找到要运行的程序时，Perl首先要求操作系统在 &lt;code&gt;PATH&lt;/code&gt; 上查找可执行文件（OS / 2添加了扩展名</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">完成后， &lt;code&gt;$input&lt;/code&gt; 将被完全处理（假设没有错误）。如果放气成功，则将放气的数据写入 &lt;code&gt;$output&lt;/code&gt; 并返回状态值 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">当后跟一个BLOCK时， &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 实际上是一个流控制语句而不是一个函数。如果有一个 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 连接到一个BLOCK（通常为BLOCK &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;foreach&lt;/code&gt; ），前条件即将被再次评价，就像的第三部分它总是只执行 &lt;code&gt;for&lt;/code&gt; 在C.循环因此它可以是用于增加循环变量，即使通过 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句（类似于C的 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 语句）继续执行了循环也是如此。</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">当后跟一个BLOCK时， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 实际上是一个流控制语句而不是一个函数。如果有一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 连接到一个BLOCK（通常为BLOCK &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;foreach&lt;/code&gt; ），前条件即将被再次评价，就像的第三部分它总是只执行 &lt;code&gt;for&lt;/code&gt; 在C.循环因此它可以是用于增加循环变量，即使通过 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句（类似于C的 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 语句）继续执行了循环也是如此。</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">当XS源文件中的函数必须被分离成包时,应该使用PACKAGE关键字。这个关键字与MODULE关键字一起使用,使用时必须紧跟在它后面。</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">当给定一个不明确的本地时间时,函数timelocal()应该总是返回该时间的纪元。</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">当使用PPCODE部分处理输出参数时，请确保正确处理&amp;ldquo; set&amp;rdquo;魔术。有关&amp;ldquo;设置&amp;rdquo;魔术的详细信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">如有疑问，请加上括号。至少它将使&lt;b&gt;vi中&lt;/b&gt;的％键有些糟糕的弹跳弹起。</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">如有疑问，请通过&lt;b&gt;a2p&lt;/b&gt;运行&lt;b&gt;awk&lt;/b&gt;构造，并查看其提供的功能。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">当有疑问时,您可以使用</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">当作为 &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; 调用时，将识别以下选项：</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">当作为 &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; 调用时，将识别以下选项：</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">当使用单个字符串调用时，&lt;b&gt;parseopts&lt;/b&gt;将字符串视为parse-option的名称，如果存在则返回其对应的值（如果不存在则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">当使用多个参数调用时，&lt;b&gt;parseopts&lt;/b&gt;将它们视为键/值对，并且将指定的parse-option名称设置为给定值。任何未指定的解析选项均不受影响。</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">当不带其他参数调用时，&lt;b&gt;parseopts&lt;/b&gt;返回所有当前解析选项的哈希表。</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">当调用时,可以接受和选择以下参数。</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">什么时候布尔不是布尔?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">当它单独出现时，会导致序列 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 和Posix字符类仅在ASCII范围内匹配。因此，它们恢复为5.6之前的版本，Unicode之前的含义。在 &lt;code&gt;/a&lt;/code&gt; 下， &lt;code&gt;\d&lt;/code&gt; 始终精确地表示数字 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 至 &lt;code&gt;&quot;9&quot;&lt;/code&gt; ； &lt;code&gt;\s&lt;/code&gt; 表示五个字符 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; ，从Perl v5.18（垂直标签）开始； &lt;code&gt;\w&lt;/code&gt; 表示63个字符 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ；同样，所有Posix类（例如 &lt;code&gt;[[:print:]]&lt;/code&gt; )仅匹配适当的ASCII范围字符。</target>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">当涉及到时空权衡时,Perl几乎总是倾向于把内存扔给一个问题。Perl中的标量比C语言中的字符串占用更多的内存,数组占用更多的内存,哈希占用更多的内存。虽然还有很多工作要做,但最近的版本已经在解决这些问题。例如,从 5.004 开始,重复的哈希键会在所有使用它们的哈希中共享,因此不需要重新分配。</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">对于在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 下会触发警告的未定义变量，您可以将警告升级为错误。</target>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">当它收敛时,你得到了一个功能变体的</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">当它启动时,调试器读取你的rc文件(</target>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">当项目碰撞到给定的哈希桶中时，它们在链中的存储顺序在Perl 5.18中不再可预测。目的是使观察到碰撞更加困难。可以通过使用PERL_PERTURB_KEYS环境变量来覆盖此行为，请参见&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;perlrun中的PERL_PERTURB_KEYS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">加载&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared时&lt;/a&gt;，必须先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 然后再 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。（如果相反， &lt;code&gt;threads&lt;/code&gt; 将发出警告。）</target>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">当寻找相对于搜索路径的 &lt;code&gt;DBD::Oracle&lt;/code&gt; ，我们应该找到</target>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">在给模块命名时,请考虑以下几点。</target>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">如果没有为选项指定目的地，则GetOptions会将结果值存储在名为 &lt;code&gt;opt_&lt;/code&gt; 的全局变量中</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">如果为非 &lt;code&gt;NULL&lt;/code&gt; ，则每次以相应的OP作为参数释放OP时，都会调用此变量指向的函数。这允许扩展释放它们在本地附加到OP的任何其他属性。还可以确保先为父级OP点火，然后为其子级点火。</target>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">当这个选项不为零时,将使bzip2使用一种使用较少内存的解压算法,但代价是增加解压的时间。</target>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">当为open（）提供了一个明确的层列表（使用三参数语法）时，它们将覆盖使用此编译指示声明的列表。还可以为open（）的层名称指定单个冒号（:)，以覆盖此杂注并使用默认值（在Unix上为 &lt;code&gt;:raw&lt;/code&gt; ，在Windows 上为 &lt;code&gt;:crlf&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">当打开写入时,文件的空部分将有NULL(0x00)字节写入其中。</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">打开文件时，如果请求失败，最好不要继续，因此 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 通常与 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一起使用。即使 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 不会做您想要的事情（例如，在CGI脚本中，您要在其中格式化适当的错误消息的格式（但是有一些模块可以帮助解决该问题））也始终检查打开文件的返回值。</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">打开文件时，如果请求失败，最好不要继续，因此 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 通常与 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一起使用。即使 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 不会做您想要的事情（例如，在CGI脚本中，您要在其中格式化适当的错误消息的格式（但是有一些模块可以帮助解决该问题））也始终检查打开文件的返回值。</target>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">当传递单个哈希引用时，&lt;b&gt;parseopts&lt;/b&gt;使用该哈希值完全重置现有的parse-options，所有先前的parse-option值都会丢失。</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">当perl开始解析任何提供词法范围的块构造时（例如eval主体，所需文件，子例程主体，循环主体或条件块），将保存 &lt;code&gt;$^H&lt;/code&gt; 的现有值，但其值保持不变。块的编译完成后，它将重新获得保存的值。在保存和恢复其值的点之间，在BEGIN块中执行的代码可以自由更改 &lt;code&gt;$^H&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">当perl执行诸如 &lt;code&gt;addop&lt;/code&gt; 之类的操作时，如何将其结果传递给下一个op？答案是通过使用堆栈。Perl有许多堆栈来存储当前正在处理的内容，我们将在这里介绍三个最重要的堆栈。</target>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">当perl执行 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 表达式时，它将转换C运行时库中的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 调用，然后将其转换为操作系统内核。perl设置 &lt;code&gt;$!&lt;/code&gt; 如果这些调用之一失败，则返回C库的 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">当perl编译时支持内存占用调试(默认使用Perl的malloc()),Devel::Peek提供了对这个API的访问。</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">将perl配置为使用ithreads时，它将优先使用非可重入版本的可重入库调用。FreeBSD 在4.5及更早版本中的 &lt;code&gt;readdir_r&lt;/code&gt; 函数中存在一个错误，在读取大目录时可能导致SEGV。提供了FreeBSD libc补丁（请参见&lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt;），该补丁已集成到FreeBSD 4.6中。</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">如果存在此选项，则将从输入文件/缓冲区读取的压缩字节数限制为 &lt;code&gt;$size&lt;/code&gt; 。在压缩数据流之后直接有有用数据并且您事先知道压缩数据流的确切长度的情况下，可以使用此选项。</target>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">当出现可能具有几种不同解释的内容时，Perl使用&lt;b&gt;DWIM&lt;/b&gt;（即&amp;ldquo;按我的意思做&amp;rdquo;）原则来选择最可能的解释。这种策略是如此成功，以至于Perl程序员通常不会怀疑自己编写的内容的模棱两可。但是，Perl的概念有时会与作者的真实含义大相径庭。</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">当打印时,一个复杂的数字通常显示在它的卡提斯样式下</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">提示时,选择一个主题,总结你的变化。</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">将项目放入 &lt;code&gt;%^H&lt;/code&gt; ，为了避免与哈希的其他用户冲突，存在关于使用哪些键的约定。模块只能使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 键。</target>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">从文件或文件句柄读取时， &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 在读取前设置binmode。</target>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">从套接字读取时，请记住默认输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; 为 &lt;code&gt;\n&lt;/code&gt; ，但是可靠的套接字代码将识别为 &lt;code&gt;\012&lt;/code&gt; 或 &lt;code&gt;\015\012&lt;/code&gt; 作为行尾：</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: AnyInflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: AnyUncompress将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Bunzip2将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Gunzip将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: Inflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress :: RawInflate将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取数据。</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">读取压缩的输入数据时，IO :: Uncompress ::: Unzip将以 &lt;code&gt;$num&lt;/code&gt; 字节的块读取它。</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">当引用时， &lt;code&gt;$!&lt;/code&gt; 检索C &lt;code&gt;errno&lt;/code&gt; 整数变量的当前值。如果 &lt;code&gt;$!&lt;/code&gt; 被分配一个数值，该数值存储在 &lt;code&gt;errno&lt;/code&gt; 中。当引用为字符串时， &lt;code&gt;$!&lt;/code&gt; 产生对应于 &lt;code&gt;errno&lt;/code&gt; 的系统错误字符串。</target>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">当使用E &amp;lt;n&amp;gt;数字代码引用字符时，范围在32-126之间的数字是指所有Pod格式化程序必须忠实呈现的那些众所周知的US-ASCII字符（也由Unicode定义，具有相同的含义）。 。除换行符的文字字节序列（ASCII 13，ASCII 13）外，不应使用其E &amp;lt;&amp;gt;数字在0-31和127-159范围内的字符（既不作为文字，也不作为E &amp;lt;number&amp;gt;代码）。 10，或ASCII 10）和制表符（ASCII 9）。</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">当注册新的警告类别时,你可以像这样向 warnings::register 提供更多的名称。</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">在删除目录树时,如果你想检查每一个文件,以决定是否删除它(可能会留下大片空白)。</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">当将Pod渲染成允许注释的格式时(即,几乎可以渲染成除纯文本以外的任何格式),Pod格式化器必须插入注释文本,以确定其名称和版本号,以及可能用于处理Pod的任何模块的名称和版本号。最低限度的例子。</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">当将Pod渲染成有两种连字符(-)的格式时,一种是非断裂连字符,另一种是可断裂连字符(如 &quot;面向对象&quot;,可跨行分割为 &quot;object-&quot;、newline、&quot;oriented&quot;),鼓励格式员一般将&quot;-&quot;翻译为非断裂连字符,但可以应用启发式方法将其中的一些连字符转换为断裂连字符。</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">当报告一个错误时,请运行这个检查表。</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">当报告错误/问题时,请尽可能多地包含信息。我可能很难重现这个问题,因为几乎每个设置都是不同的。</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">当解析对全局DLL的请求时,已经加载的特定DLL的表会被(有效地)忽略;此外,特定的DLL会被称为</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">当将C数组返回给Perl时，XS &lt;code&gt;size_$var&lt;/code&gt; 必须提供一个名为size_ $ var的整数变量，其中包含数组中元素的数量。这用于确定应将多少个元素压入返回参数堆栈。输入不是必需的，因为Perl知道在调用例程时堆栈中有多少个参数。通常，此变量称为 &lt;code&gt;size_RETVAL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">当返回一个非空结果时,返回的类型是相关的。如果它是一个AV,那么AV的元素就是指向这个项目的弱引用RV。如果是其他类型,那么这个项目本身就是弱引用。</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">当对一个数字进行四舍五入时,可以采用不同的 &quot;风格 &quot;或 &quot;种类&quot;。(请注意,Math::Round中的随机四舍五入没有实现。)</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">当运行时,它产生以下输出</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">当运行时,脚本会产生这个错误信息。</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 时，环境变量 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; 设置为正在执行的 &lt;code&gt;Makefile.PL&lt;/code&gt; 的完整路径。这样可以防止使用更高版本的Module :: Install导致进程失控。</target>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">在运行taint检查时，由于程序正在运行setuid或setgid，或者已指定&lt;b&gt;-T&lt;/b&gt;或&lt;b&gt;-t&lt;/b&gt;开关，因此未查询PERL5LIB或PERLLIB。该程序应改为：</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">运行此程序时，请重定向 &lt;code&gt;STDOUT&lt;/code&gt; ,以便可以从以下测试运行中检查输出是否正确，并使用系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 实用程序检查总体运行时间。</target>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">当在Eunice下运行时,这个变量包含一个命令,它将把shell脚本转换为适当形式的文本文件,以便shell能够执行。在其他系统中,它是一个无操作的变量。</target>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">当安全信号生效时（默认行为- 有关更多详细信息，请参阅&lt;a href=&quot;#Unsafe-signals&quot;&gt;不安全信号&lt;/a&gt;），则各个线程可以发送信号并对其采取行动。</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">对结果满意后，请重新运行 &lt;code&gt;installcmd&lt;/code&gt; 目标。现在，您可以将 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; 复制到 &lt;code&gt;perl.exe&lt;/code&gt; ，并安装其他OMF生成的可执行文件： &lt;code&gt;perl__.exe&lt;/code&gt; 等。它们已准备就绪，可以使用。</target>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">当保存源时,包括不产生子程序的evals。</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">保存源码时,包括没有编译的源码。</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">搜索单字符定界符时，将跳过转义的定界符和 &lt;code&gt;\\&lt;/code&gt; 。例如，在搜索终止符 &lt;code&gt;/&lt;/code&gt; 时，将跳过 &lt;code&gt;\\&lt;/code&gt; 和 &lt;code&gt;\/&lt;/code&gt; 组合。如果定界符放在括号内，则也将跳过嵌套对。例如，在搜索与开始 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;]&lt;/code&gt; 配对的 &lt;code&gt;\\&lt;/code&gt; ，\\， &lt;code&gt;\]&lt;/code&gt; 和 &lt;code&gt;\[&lt;/code&gt; 都被跳过，嵌套的 &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; 也被跳过。但是，将反斜杠用作分隔符时（例如 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ），则不会跳过任何内容。在搜索末尾期间，会删除转义定界符的反斜杠或其他反斜杠（确切地说，它们不会复制到安全位置）。</target>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">当设置为 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 遍历键将被随机化。每次将哈希插入密钥顺序时，都会以随机方式更改。即使已指定PERL_HASH_SEED，该顺序在以后的程序运行中也可能无法重复。这是perl的默认模式。</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">当设置为 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 将键插入到哈希中将导致键顺序发生更改，但是这种方式在程序运行到程序运行之间是可重复的。</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">设置为true值时，将导致 &lt;code&gt;remove_tree&lt;/code&gt; 跳过进程缺少删除文件所需的必需特权（例如VMS上的删除特权）的文件。换句话说，该代码不会尝试更改文件权限。因此，如果该过程被中断，则没有文件系统对象将处于更宽松的模式。</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">当设置为true时,将导致除最初指定的目录外的所有文件和子目录被删除。这在清理应用程序的scratch目录时很方便。</target>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">设置后，Data :: Dumper将发出单个非自我引用的值作为原子/项，而不是语句。这意味着 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">设置时,控制网络超时(以秒为单位)。</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">设置后，启用双引号表示字符串值。除空格以外的空白将表示为 &lt;code&gt;[\n\t\r]&lt;/code&gt; ，&amp;ldquo; unsafe&amp;rdquo;字符将被反斜杠，并且不可打印字符将被输出为带引号的八进制整数。默认值为0。</target>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">什么时候应该解码或编码?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">什么时候不应该用Perl编程?</target>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">当其他内容中包含某些内容时，尤其是在令人惊讶的情况下：&amp;ldquo;我在编辑器中嵌入了完整的Perl解释器！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">在谈到regexes时,我们需要区分它们的源代码形式和内部形式。在本文档中,当我们谈到它们的文本、源代码形式时,我们将使用术语 &quot;模式&quot;,而当我们谈到它们的内部表示时,将使用术语 &quot;程序&quot;。这些术语对应的是</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">当在模块的</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">直接启动脚本时，Perl使用与&lt;b&gt;-S&lt;/b&gt;命令行选项给出的脚本搜索完全相同的算法：它将在当前目录中查找，然后使用以下扩展名顺序查找 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 组件：没有扩展名，</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">当按网络顺序存储双数时,它们的值被存储为文本。然而,你也不应该期望非数字浮点值,如无穷大和 &quot;不是一个数字&quot;,能够成功地通过nstore()/retrieve()对。</target>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">在测试应用程序时，通常会发现自己需要在测试环境中提供通常由外部模块提供的功能。该模块为您提供了一种非常简单的方式来将模块标记为已加载和/或卸载，而不是手动修改 &lt;code&gt;%INC&lt;/code&gt; 来将这些外部模块标记为已加载，因此不会尝试由perl加载它们。</target>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">当这个字符串从括号符号编译成一个真正的Perl子时,基本上就变成了。</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">当在%o转换中给出#标志和一个精度时,如果需要前导 &quot;0&quot;,精度会递增。</target>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">当 &lt;code&gt;all&lt;/code&gt; 参数省略或为false时，绑定的哈希元素将是最左侧定义的缓冲区的内容，并带有关联的哈希键的名称。换句话说，绑定哈希将表现为 &lt;code&gt;%+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">当提供 &lt;code&gt;all&lt;/code&gt; 参数时，绑定的哈希元素将是数组引用，列出每个捕获缓冲区的内容，这些缓冲区的名称与关联的哈希键相同。如果匹配中没有这些缓冲区，则该数组ref的内容将是与具有该名称的捕获缓冲区一样多的 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值。换句话说，绑定哈希将表现为 &lt;code&gt;%-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">如果存在 &lt;code&gt;exUnix2&lt;/code&gt; 选项，它将触发在本地zip标头中创建Unix2额外字段（ID为&amp;ldquo; Ux&amp;rdquo;）。这将填充 &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。在中央zip标头中还将创建一个空的Unix2额外字段。</target>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">如果存在 &lt;code&gt;exUnixN&lt;/code&gt; 选项，它将在本地和中央zip标头中触发创建UnixN额外字段（ID为&amp;ldquo; ux&amp;rdquo;）。这将填充 &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。UID和GID存储为32位整数。</target>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">当 &lt;code&gt;frame&lt;/code&gt; 选项设置时，调试器将打印输入的（和可选地退出）子程序在不同的风格。有关这些示例的冗长示例，请参见&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">首次使用CPAN模块时，配置对话框会尝试确定几个特定于站点的选项。对话框的结果存储在文件CPAN / Config.pm 中的哈希引用 &lt;code&gt; $CPAN::Config &lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">当CPAN shell通过look命令进入子shell时,会将环境CPAN_SHELL_LEVEL设置为1,如果已经设置,则将该变量递增。</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">当CPAN shell启动时,它通常会显示一个问候信息,其中包含运行的版本和读线支持的状态。</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">读取或写入SV时，将以 &lt;code&gt;uf_index&lt;/code&gt; 作为第一个arg并以指向SV的指针作为第二个调用 &lt;code&gt;uf_val&lt;/code&gt; 或 &lt;code&gt;uf_set&lt;/code&gt; 函数。下面显示了如何添加 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术的简单示例。请注意，ufuncs结构是由sv_magic复制的，因此您可以安全地在堆栈上分配它。</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">当Storable引擎找不到任何 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 钩子例程时，它将尝试通过动态要求软件包（使用受祝福的软件包名称）来加载类，然后重新尝试查找。如果那时无法找到挂钩，则发动机发出嘶哑声。请注意，如果您在同一文件中定义多个类，则此机制将失败，但是&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;警告您。</target>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">当子级的实际VMS终止状态为错误时，在内部 &lt;code&gt;$!&lt;/code&gt; 值将设置为与该错误最接近的Unix errno值，以便测试错误消息的Perl脚本将看到预期的Unix样式错误消息，而不是VMS消息。</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">当参数通过系统外壳执行时，结果受其怪癖和能力的影响。有关详细信息，请参见&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">当参数通过系统外壳执行时，结果受其怪癖和能力的影响。有关详细信息，请参见&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;perlop中的&amp;ldquo; STRING&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">如果该类要在 &lt;code&gt;/i&lt;/code&gt; 匹配规则下进行不区分大小写的匹配，并且在类内部明确提到的字符在Unicode规则下不区分大小写地匹配一个多字符序列，则该类也将匹配该序列。例如，Unicode表示字母 &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 应该与 &lt;code&gt;/i&lt;/code&gt; 规则下的序列 &lt;code&gt;ss&lt;/code&gt; 相匹配。从而，</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">当代码只在两三个操作系统上运行时,你可能只需要考虑这些特定系统的差异。重要的是要决定代码将在哪里运行,并且在决定时要慎重。</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">当配置变量ftp_aspsive被设置时,所有的下载将在环境变量FTP_PASSIVE被设置为该值时运行。一般来说,这是一个好主意,因为它同时影响Net::FTP和基于LWP的连接。同样的效果也可以通过启动cpan shell时设置这个环境变量来实现。单纯对于Net::FTP来说,也可以通过运行libnetcfg随时设置被动模式。</target>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">当数据库仅包含UTF-8时，包装函数或方法是替换所有 &lt;code&gt;fetchrow_array&lt;/code&gt; 和 &lt;code&gt;fetchrow_hashref&lt;/code&gt; 调用的便捷方法。包装函数还将使您更容易适应数据库驱动程序中将来的增强。请注意，在撰写本文时（2012年1月），DBI还没有标准化的方式来处理UTF-8数据。请检查&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI文档&lt;/a&gt;以验证是否仍然正确。</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">当程序的执行到达可以保存断点的点时，如果任何变量 &lt;code&gt;$DB::trace&lt;/code&gt; ， &lt;code&gt;$DB::single&lt;/code&gt; 或 &lt;code&gt;$DB::signal&lt;/code&gt; 为true ，则调用 &lt;code&gt;DB::DB()&lt;/code&gt; 子例程。。这些变量不可 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。在 &lt;code&gt;DB::DB()&lt;/code&gt; 内部执行时，禁用此功能，包括从其调用的函数，除非 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; 为true。</target>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">当文件</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">当你要处理的文件很小的时候,你用哪种方式处理并不太重要,但是当文件开始变大的时候,就会有很大的不同。</target>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">当内子程序被调用时,它将看到外子程序的词性子程序的值,就像在*次调用外子程序之前和期间一样;在这种情况下,在第一次调用外子程序完成后,内子程序和外子程序将不再共享词性子程序的共同值。换句话说,它将不再被共享。如果词法子程序访问在其周围作用域中声明的词法变量,这一点尤其会有所区别。</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">当内子程序被调用时,它将看到外子程序的变量值,就像在*次调用外子程序之前和期间一样;在这种情况下,在第一次调用外子程序完成后,内子程序和外子程序将不再共享变量的共同值。换句话说,该变量将不再被共享。</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">当一个对象的最后一个引用消失时,这个对象就会被销毁。如果你对一个存储在词法标量中的对象只有一个引用,那么当这个标量超出范围时,这个对象就会被销毁。如果你将对象存储在包全局中,该对象可能不会离开范围,直到程序退出。</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">当将图层作为 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 调用的一部分推送时，将调用 &lt;code&gt;PUSHED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">推入该层时，将保存 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; 的当前值，并在调用Encode方法encode（）和encode（）时用作CHECK参数。</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">首次加载lib模块时，它将@INC的当前值记录在数组 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; 。要将@INC恢复为该值，您可以说</target>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">当匹配运行时，正则表达式的第一部分（ &lt;code&gt;\b(foo)&lt;/code&gt; ）在字符串的开头找到一个可能的匹配，并用&amp;ldquo; Foo&amp;rdquo;加载$ 1。但是，只要匹配引擎发现保存在$ 1中的&amp;ldquo; Foo&amp;rdquo;后面没有空格，它就会意识到自己的错误，并在尝试性匹配之后重新开始一个字符。这次一直进行到下一次出现&amp;ldquo; foo&amp;rdquo;为止。这次完整的正则表达式匹配，您将获得&amp;ldquo; table following foo&amp;rdquo;的预期输出。</target>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">当对象超出范围时,会调用destructor。这个析构器将尝试解开文件的链接(使用 L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">满足优化条件后，将调用 &lt;code&gt;reg_try()&lt;/code&gt; 进行匹配。</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">当输出是文件名时,它将在写入任何压缩数据之前截断文件的内容。如果输出是一个文件柄,它的位置将不会被改变。如果输出是一个缓冲区,它将在输出任何压缩数据之前被擦除。</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">当输出是文件名时,它将在写入任何未压缩的数据之前截断文件的内容。如果输出是一个文件柄,它的位置将不会被改变。如果输出是一个缓冲区,它将在输出任何未压缩数据之前被擦除。</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">当程序终止后,可以使用任何标准的文本过滤工具对输出进行检查和排序。类似下面的工具就足够了。</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">当脚本结束后,你想改变生成的</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">当脚本终止时，探查器将创建一个包含探查器信息的数据库，您可以使用探查器的工具将其转换为报告。有关详细信息，请参见&amp;lt;perlperf&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">当字符串包含以Unicode命名的代码点 &lt;code&gt;\N{...}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">当字符串中包含一个Unicode-only码点时。</target>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">当字符串来自标记为Unicode的外部来源时。</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">当异味模式（ &lt;code&gt;-T&lt;/code&gt; ）生效时，&amp;ldquo;。&amp;rdquo;从 &lt;code&gt;@INC&lt;/code&gt; 删除目录，Perl忽略环境变量 &lt;code&gt;PERL5LIB&lt;/code&gt; 和 &lt;code&gt;PERLLIB&lt;/code&gt; 。您仍然可以使用 &lt;code&gt;-I&lt;/code&gt; 命令行选项从程序外部调整 &lt;code&gt;@INC&lt;/code&gt; ，如&lt;a href=&quot;perlrun&quot;&gt;perlrun中所述&lt;/a&gt;。这两个环境变量会被忽略，因为它们被模糊了，并且运行程序的用户可能不知道已设置它们，而 &lt;code&gt;-I&lt;/code&gt; 选项清晰可见，因此可以使用。</target>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">当测试文件完成后,输出总结,一起。</target>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">当没有BLOCK时， &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 是一个会落在当前 &lt;code&gt;when&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 块中的函数，而不是迭代动态封闭的 &lt;code&gt;foreach&lt;/code&gt; 或退出 &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; 的词汇封闭的函数。在Perl 5.14和更早版本中，仅当启用 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能时，这种 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 形式才可用。有关更多信息，请参见&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;perlsyn中的&lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;和开关语句。</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">当没有BLOCK时， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 是一个函数，该函数会落在当前 &lt;code&gt;when&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 块中，而不是迭代动态封闭的 &lt;code&gt;foreach&lt;/code&gt; 或退出 &lt;code&gt;given&lt;/code&gt; 的词法封闭。在Perl 5.14和更早版本中，仅当启用 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能时，这种 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 形式才可用。有关更多信息，请参见&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的&lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;和开关语句。</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">当没有方法时,它将方法名作为编码的名称,并将实例编码为</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">当这些图案被嵌入到另一个图案中时,它们所匹配的内容不会改变,无论该图案中的括号或修饰符是否有效。</target>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">当这段代码执行时,没有任何输出。这就是原因。</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">运行此代码时，只有 &lt;code&gt;Derived&lt;/code&gt; 对象 &lt;code&gt;$b&lt;/code&gt; 会生成警告。</target>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">当此代码与&lt;b&gt;-w&lt;/b&gt;标志一起运行时，将对 &lt;code&gt;$a&lt;/code&gt; 行产生警告： &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">使用这种形式的编译指示时，Perl仅使用语言环境的非字符部分，例如 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 。Perl假定您已将要操作的所有字符都转换为Unicode（实际上是平台的本机字符集（ASCII或EBCDIC）加上Unicode）。对于文件中的数据，也可以通过指定</target>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">当此函数被调用时,由</target>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">设置为 &lt;code&gt;1&lt;/code&gt; 时，将自动从 &lt;code&gt;O_FILES&lt;/code&gt; 派生 &lt;code&gt;OBJECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">当该值为真时,CPAN 将把 PERL_MM_USE_DEFAULT 设置为真值。这将导致 ExtUtils::MakeMaker (和兼容的)提示使用默认值,而不是停止提示您回答问题。它还将 NONINTERACTIVE_TESTING 设置为真值,以更普遍地表明发行版不应该尝试与您交互。</target>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">什么时候仍然使用local()</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">何时使用OO</target>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">当为真时,该参数将把gzip头中的FLG.FHCRC位设置为1,并将CRC16头字段设置为除CRC16字段本身以外的完整gzip头的CRC。</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">当为 &quot;true &quot;时,在'make distdir'时,通过'cpansign -s'在distdir中生成并添加SIGNATURE文件的MANIFEST。</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">为true时，禁止将安装追加到 &lt;code&gt;perllocal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">当为 &quot;true &quot;时,在 &quot;make distdir &quot;时,抑制META.yml和META.json模块元数据文件的生成和添加到MANIFEST中。</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">当为真时,在'perl Makefile.PL'时抑制生成MYMETA.yml和MYMETA.json模块元数据文件。</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">为true时，禁止写入要安装的 &lt;code&gt;packlist&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">当试图解释堆栈时,大多数计算机科学教科书都会喃喃自语,说是食堂盘子的弹簧柱:你推到堆栈上的最后一件事,就是你弹出的第一件事。对于我们的目的来说,这就足够了:你的C程序将把一些参数推到 &quot;Perl堆栈 &quot;上,在一些神奇的事情发生时闭上眼睛,然后把结果--Perl子程序的返回值--从堆栈上弹出。</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">系上手柄时，要 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的第一个参数应以星号开头。因此，如果要捆绑STDOUT，请使用 &lt;code&gt;*STDOUT&lt;/code&gt; 。如果已将其分配给标量变量，例如 &lt;code&gt;$handle&lt;/code&gt; ，请使用 &lt;code&gt;*$handle&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; 标量变量 &lt;code&gt;$handle&lt;/code&gt; ，而不是其内部的句柄。</target>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">当用作类方法（ &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; ，有时称为静态方法）时， &lt;code&gt;isa&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">当作为过滤器使用时,我们要这样调用它。</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">当用作实例或类方法（ &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ）时， &lt;code&gt;isa&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">像这样使用时，选项及其可能的值将从 &lt;code&gt;@myopts&lt;/code&gt; 中删除，根本不会触摸全局 &lt;code&gt;@ARGV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">当使用这样的。</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">在哈希元素上使用时，它告诉您是否定义了值，而不是键是否存在于哈希中。使用&lt;a href=&quot;#exists&quot;&gt;存在&lt;/a&gt;后者的目的。</target>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">在哈希元素上使用时，它告诉您是否定义了值，而不是键是否存在于哈希中。使用&lt;a href=&quot;exists&quot;&gt;存在&lt;/a&gt;后者的目的。</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">当用于数组或哈希的元素时， &lt;code&gt;is_shared&lt;/code&gt; 检查指定的元素是否属于共享数组或哈希。（它不检查该元素的内容。）</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">当用于将Perl列表传递给C时，XS编写器必须提供一个函数（以数组类型命名，但用'Ptr'代替'*'）来分配保存列表所需的内存。应该返回一个指针。由XS编写器决定在函数退出时释放内存。变量 &lt;code&gt;ix_$var&lt;/code&gt; 设置为新数组中的元素数。</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">与一起使用时 &lt;code&gt;.&lt;/code&gt; ，重复计数确定计算值偏移量的起始位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">与 &lt;code&gt;@&lt;/code&gt; 一起使用时，重复计数表示从最里面 &lt;code&gt;()&lt;/code&gt; 组的开始的偏移量。</target>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">当与 &lt;code&gt;Z&lt;/code&gt; 一起使用时，保证使用 &lt;code&gt;*&lt;/code&gt; 作为重复计数来添加尾随的空字节，因此，所得字符串始终比项目本身的字节长一个字节。</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">与类方法一起使用时，问题甚至更加严重。由于Perl允许将子例程名称写为裸词，因此Perl必须猜测方法后的裸词是类名称还是子例程名称。换句话说，Perl可以将语法解析为 &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;或&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">当使用命令行选项时。</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">当userelocatableinc为true时,这个变量保存了make install应该将perl二进制文件复制到的位置,所有运行时的可重定位路径都是在安装时据此计算出来的。当使用时,它被初始化为binexp的原始值,然后将binexp设置为</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 组上使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 时，这会影响该组内所有接受字节顺序修饰符的类型，包括所有子组。对于所有其他类型，它将被静默忽略。不允许覆盖已经有字节顺序修饰符后缀的组中的字节顺序。</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">当将 &lt;code&gt;Exporter&lt;/code&gt; 与标准 &lt;code&gt;strict&lt;/code&gt; 和 &lt;code&gt;warnings&lt;/code&gt; 编译指示一起使用时，需要 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 关键字来声明包变量@ &lt;code&gt;@EXPORT_OK&lt;/code&gt; ，@ &lt;code&gt;@EXPORT&lt;/code&gt; ，@ &lt;code&gt;@ISA&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Open3&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 时，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则假定它已被适当地转义。您可以使用 &lt;code&gt;QUOTE&lt;/code&gt; 常量用作可移植的引号字符（请参见上文）。但是，如果提供数组引用，则适用特殊规则：</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">当使用 &lt;code&gt;IPC::Run&lt;/code&gt; ，如果您提供一个字符串作为 &lt;code&gt;command&lt;/code&gt; 参数，则该字符串将在空白处分割以确定命令的各个元素。尽管这通常只会执行您的意思，但是如果其中包含空格的文件或命令可能会中断。</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">当将 &lt;code&gt;autodie&lt;/code&gt; 或 &lt;code&gt;Fatal&lt;/code&gt; 与用户子例程一起使用时，这些子例程的声明必须出现在首次使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 之前，或者已经从模块中导出。尝试在其他用户子例程上使用 &lt;code&gt;Fatal&lt;/code&gt; 或 &lt;code&gt;autodie&lt;/code&gt; 会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;fd_retrieve&lt;/code&gt; 时，将按顺序检索对象，每个关联的 &lt;code&gt;store_fd&lt;/code&gt; 检索一个对象（即一棵递归树）。</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">使用GCC时，该条目指定MakeMaker应该首先在 &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定的所有位置中寻找 &lt;code&gt;libgl.a&lt;/code&gt; （后跟 &lt;code&gt;gl.a&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">当使用Module::Build时,这通常会是。</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">当使用PUSHCOLOR、POPCOLOR和LOCALCOLOR时,特别重要的是不要在常量之间加逗号。</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">当使用Term::ReadLine时,你可以打开饰品,使你的输入与CPAN.pm的输出形成鲜明对比。</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">当使用Unix或MSDOS语法时，它会模拟 &lt;code&gt;dirname(1)&lt;/code&gt; shell函数，该函数与 &lt;code&gt;fileparse()&lt;/code&gt; 的工作方式稍有不同。即使最后一级显然是目录，它也会返回文件路径的最后一级以外的所有内容。实际上，它不是返回目录部分，而只是返回上一级的路径，类似于文件路径的 &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">当使用GCC以外的编译器时，以上条目将搜索 &lt;code&gt;gl.lib&lt;/code&gt; （紧随其后的是 &lt;code&gt;libgl.lib&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">当使用不支持内联修饰符的 &lt;code&gt;(?:)&lt;/code&gt; 构造的自定义引擎时，最好将 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 字符串化为所提供的模式，请注意，在以下情况下，这将创建不需要的模式：</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">使用签名时，除了签名的词法变量之外，特殊数组变量 &lt;code&gt;@_&lt;/code&gt; 中的参数仍然可用。两种访问参数的方式有所不同： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">当使用这些例程中的任何一个（ &lt;code&gt;call_argv&lt;/code&gt; 除外）时，程序员必须操纵Perl堆栈。这些包括以下宏和函数：</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">当使用前瞻断言和否定时,这一切可能会变得更加棘手。想象一下,你想找到一个不以 &quot;123 &quot;开头的非数字序列。你可以试着写成</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">当在OS/390上使用perl时,请记住EBCDIC和ASCII字符集是不同的。有关此类字符集问题的更多信息,请参见 perlebcdic.pod。perlport.pod文档中也提到了在EBCDIC下可能表现不同的Perl内置函数。</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">在 &lt;code&gt;-m&lt;/code&gt; 模式（显示模块源代码）下使用perldoc时， &lt;code&gt;perldoc&lt;/code&gt; 将尝试使用 &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 中设置的寻呼机。该命令的一个有用设置是您喜欢的编辑器，如 &lt;code&gt;/usr/bin/nano&lt;/code&gt; 。（不要判断我）</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">当使用 &quot;syn &quot;协议时,使用这个方法来确定远程主机的可到达性。这个方法的调用次数与调用ping()的次数一样多。每次调用都会返回带有TCP ACK的主机(如传递给ping()的那样)。返回主机的顺序不一定与使用ping()方法进行SYN排队的顺序相同。如果在收到TCP ACK之前就达到了超时,或者远程主机没有在尝试的端口上监听,那么TCP连接将无法建立,ack()将返回undef。在列表上下文中,将返回主机、ack时间和点号ip字符串,而不是只返回主机。如果指定了可选的$host参数,返回值将只与该主机有关。如果你使用的是除syn以外的其他协议,这个调用根本没有任何作用。</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">使用 &lt;code&gt;+&lt;/code&gt; 原型时，您的函数必须检查参数是否为可接受的类型。</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">使用Borland编译器时，第二项以 &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; ，MakeMaker负责将 &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; 移动到链接器命令行中的正确位置。</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">当使用GUI版本的SAM时,点击内核配置图标,然后点击可配置参数图标。向下滚动并选择maxdsiz行。从Actions菜单中,选择Modify Configurable Parameter项目。在Formula/Value框中插入新的公式。然后按照说明重建内核并重启系统。</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">使用Visual C编译器时，第二项作为 &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">使用常量时，如果不想记住在每个打印行的末尾添加 &lt;code&gt;, RESET&lt;/code&gt; ，则可以将$ Term :: ANSIColor :: AUTORESET设置为真实值。然后，如果常量后面没有逗号，则显示模式将自动重置。换句话说，设置该变量：</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">当使用这个编译器来编译Perl时,你应该确保在config.sh文件中的cpprun和cppstdin变量中加入了标志-Aa(参见下面关于64位perl的章节)。如果你使用的是最新版本的 Perl 发行版,这些标志会自动设置。</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">验证现有摘要字符串时，应将摘要用作盐（例如 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。用于创建摘要的SALT作为摘要的一部分可见。这样可以确保crypt（）使用与摘要相同的盐值来哈希新字符串。这使您的代码可以与标准&lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt;以及更多奇异的实现一起使用。换句话说，对于返回的字符串本身或SALT多少字节可能无关紧要。</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">当我们祝福某件事时,我们不是祝福包含对该事物的引用的变量,也不是祝福变量所存储的引用;我们是祝福变量所引用的事物(有时也被称为该事物的</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">当我们对变量调用 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 时，实际上是在祝福该变量所引用的基础数据结构。我们没有祝福引用本身，也没有祝福包含该引用的变量。这就是第二次对 &lt;code&gt;blessed( $bar )&lt;/code&gt; 调用返回false的原因。那时， &lt;code&gt;$bar&lt;/code&gt; 不再存储对对象的引用。</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">当我们把一个方法调用，Perl的安排方法的&lt;b&gt;调用者&lt;/b&gt;，以作为第一个参数传递。&lt;b&gt;Invocant&lt;/b&gt;是箭头左侧的东西的奇特名称。发起人可以是类名或对象。我们还可以将其他参数传递给该方法：</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">下面我们说的 &quot;Mac OS &quot;是指Mac OS 7、8、9和</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">当我们要将返回给调用者的值放置在栈上时,我们使用一系列以 &quot;XPUSH &quot;开头的宏。有五个不同的版本,用于将整数、无符号整数、双数、字符串和Perl标量放在栈上。在我们的例子中,我们将Perl标量放置在堆栈上。(事实上,这是唯一一个可以用来返回多个值的宏。)</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">当遇到长度超过 &lt;code&gt;$columns&lt;/code&gt; 单词时，它们将被分解。 &lt;code&gt;wrap()&lt;/code&gt; 在 &lt;code&gt;$columns&lt;/code&gt; 添加 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 。可以通过将 &lt;code&gt;$huge&lt;/code&gt; 设置为 'die'或'overflow' 来覆盖此行为。当设置为'die'时，较大的单词将导致 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 被调用。设置为&amp;ldquo;溢出&amp;rdquo;时，大字将保持不变。</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">当编写一个DBM过滤器时,它是</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">当编写一个用于一般消费的Perl扩展时,我们应该预料到该扩展将与你机器上的Perl版本不同。由于你正在阅读这篇文档,你的机器上的Perl版本可能是5.005或更高版本,但你的扩展的用户可能有更古老的版本。</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">将字符UV写入UTF-8字符串时，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; ，除非使用 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s = uv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">当写一个gzip文件时,这个接口将</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">写入文件或文件句柄时，在写入文件之前设置 &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">当你</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">当您对嫌疑人名单感到满意时,您现在可以进行以下操作</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">当你完成后,XS-module安装过程会在你的 &quot;perllocal &quot;信息中添加信息,告诉你perl二进制文件已经被替换,以及安装了什么模块。你可以在任何时候使用命令来查看这些信息。</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">当您要使用GNU C编译器（gcc）且还没有gcc时，您可以从源代码自己构建它（例如，可以从&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html获得&lt;/a&gt;）。或从&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt;的HP移植中心获取预构建的二进制文件，或者从&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://www.hp.com/go/DSPP&lt;/a&gt;（您需要成为成员）：？//h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801 CIID = 2a08725cc2f02110725cc2f02110275d6e10RCRD＆jumpid = reg_r1002_usen_c-001_title_r0001（浏览列表，因为经常有同一个包的多个版本）。</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">当您手动创建UCM文件时,您应该复制ascii.ucm或与您的编码相近的现有编码,而不是从头开始编写自己的编码。</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">当你对测试结果满意后,安装扩展的构建C库。</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">当你确信只有几个子目录导致故障，您可能要添加 &lt;code&gt;-j4&lt;/code&gt; 选项 &lt;code&gt;make&lt;/code&gt; 加快与已经完成构建跳过子目录。</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">当您使用&amp;ldquo;流&amp;rdquo;协议时，此调用会预先打开tcp套接字。仅当您要在创建连接时提供不同的超时时间时才需要执行此操作，或者从第一次ping中消除建立连接的开销。如果不调用 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; ，则在第一次调用 &lt;code&gt;ping()&lt;/code&gt; 时会自动打开连接。如果您使用流以外的任何协议，则此调用完全不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">当你构建模块时,告诉Perl安装模块的位置。</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">当您使用参数调用 &lt;code&gt;bar&lt;/code&gt; 时，您会看到 &lt;code&gt;foo&lt;/code&gt; 拥有相同的 &lt;code&gt;@_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">调用方法时，箭头左侧的内容将作为第一个参数传递给该方法。这意味着当我们调用 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; 时， &lt;code&gt;new()&lt;/code&gt; 方法将接收字符串 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; 作为其第一个参数。当我们调用 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; ，会将 &lt;code&gt;$fred&lt;/code&gt; 变量作为第一个参数传递给talk &lt;code&gt;speak()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">当您更改要复制的&lt;b&gt;值时&lt;/b&gt;。[摘自法语&amp;ldquo;通过&amp;rdquo;，如国际象棋中充满异国情调的典当捕获动作。]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">当你砍()一个数学对象时,它会被提升为一个字符串,并且它的数学属性会丢失。同样的情况也会发生在其他操作上。</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">当您将遗留数据和Unicode结合起来时,需要将遗留数据升级为Unicode。通常,遗留数据被假定为ISO 8859-1(或EBCDIC,如果适用)。</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">创建地图时，应确保地图往返安全。也就是说， &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; 表示标记为 &lt;code&gt;|0&lt;/code&gt; 所有字符。这是如何确保：</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">当使用上述方法声明诸如 &lt;code&gt;PI&lt;/code&gt; 之类的常量时，运行脚本的每台计算机都可以使用尽可能多的精度。同样，您的程序将更易于阅读，更易于维护（并正确维护），并且不太可能向错误的行星发送空间探测器，因为没有人注意到您编写 &lt;code&gt;3.14195&lt;/code&gt; 的公式。</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">当你解码(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">解码时，会为格式错误的字符插入 &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;对象上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您可能会得到此类的对象。</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">在&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;上执行$ parser-&amp;gt; get_token时，您应该获得Pod :: Simple :: PullParserToken子类的对象。</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">当你进行open()并指定额外的PerlIO层进行部署时,你指定的层会被 &quot;推送 &quot;到已有的默认栈之上。有一种说法是 &quot;操作系统在左边&quot;,&quot;Perl在右边&quot;。</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">这样做时，除非您的环境是EBCDIC，否则请确保至少&lt;b&gt;保留U0000&lt;/b&gt;到&lt;b&gt;U0020&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">执行此操作时，可以通过创建类型为您自己的PP函数的 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 和 &lt;code&gt;op_ppaddr&lt;/code&gt; 的操作，用自定义操作替换普通的Perl操作。这应该在XS代码中定义，并且应该看起来像 &lt;code&gt;pp_*.c&lt;/code&gt; 的PP ops 。您有责任确保您的op从堆栈中获取适当数量的值，并且有责任在必要时添加堆栈标记。</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">当你进行编码时,它只是将UTF-8字符串与</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">当你执行这个脚本时,Perl会为文件创建一个源流。在解析器处理文件中的任何一行之前,源流看起来是这样的。</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">当您厌倦了为数据结构编写自定义打印时，可以查看标准的&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;或&lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt;模块。前者是Perl调试器使用的东西，而后者则生成可分析的Perl代码。例如：</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">当您安装了 Module::Build,并且一个模块同时带有 Makefile.PL 和 Build.PL 时,哪个应该优先?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">当你安装了Term::ANSIColor后,你可以开启彩色化输出,让正常的CPAN.pm输出、警告、调试输出和正在安装的模块输出有一些视觉上的区别。在对Term::ANSIColor模块进行一些实验后,可以设置自己喜欢的颜色。</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">当您有一个 &lt;code&gt;$normalized&lt;/code&gt; 字符串和紧随其后的 &lt;code&gt;$unnormalized&lt;/code&gt; 字符串时，简单的串联是错误的：</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">当您有重复的条目时,用&quot;|1 &quot;或&quot;|3 &quot;标记其中一个。</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">当您在.xs文件中列出XSUB的参数时，将告诉&lt;b&gt;xsubpp&lt;/b&gt;哪个参数对应于哪个参数堆栈（即，列出的第一个参数是第一个参数，依此类推）。如果您未按函数预期的顺序列出灾难，则会引发灾难。</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">当使脚本可执行时，为了使其可用作命令，系统将从脚本的＃！将开关传递给perl！线。 Perl检查提供给setuid（或setgid）脚本的任何命令行开关是否确实与＃！上设置的那些匹配！线。某些Unix和类似Unix的环境对＃！施加一键限制。行，因此在这种系统下，可能需要使用 &lt;code&gt;-wU&lt;/code&gt; 之类的东西，而不是 &lt;code&gt;-w -U&lt;/code&gt; 之类的东西。 （仅在支持＃！以及setuid或setgid脚本的Unix或类似Unix的环境中才会出现此问题。）</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">覆盖内置时，替换项应与内置本机语法保持一致（如果可能）。您可以通过使用合适的原型来实现。要获取可覆盖的内置 &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; ，请使用带有参数 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 的prototype函数（请参见&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">当你更换这个变量时,它被认为是一个很好的做法,存储可能以前安装的钩子,你在你自己的内部调用它。</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">当你运行Makefile.PL时,它就会生成一个Makefile。这就是MakeMaker的全部意义。Makefile.PL是一个简单的程序,它加载ExtUtils::MakeMaker,并运行WriteMakefile()函数来生成一个Makefile。</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">当你运行一个Perl脚本时,有其他东西在为你运行这个脚本,而这个其他东西可能会输出错误信息。脚本可能会发出自己的警告和错误信息。大多数时候,你无法判断谁说了什么。</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">当你运行这个程序时,你应该得到类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">当你说 &quot;make test &quot;时,Perl使用的是</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=gb2312&lt;/code&gt; 时，它们实际上是 &lt;code&gt;euc-cn&lt;/code&gt; 编码。为了解决这个问题， &lt;code&gt;gb2312&lt;/code&gt; 被别名为 &lt;code&gt;euc-cn&lt;/code&gt; 。真正使用时，请使用 &lt;code&gt;gb2312-raw&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">当您在邮件和网页上看到 &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; 时，它们实际上是&amp;ldquo; cp949&amp;rdquo;编码。为了解决这个问题，设置了以下别名；</target>
        </trans-unit>
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">当您说一种语言而计算机认为您在说另一种语言时。例如，当您发送UTF-8时，您会看到奇怪的翻译，但是计算机认为您发送了Latin-1，而是显示了各种奇怪的字符。该术语用日语写成&amp;ldquo;文字化け&amp;rdquo;，意思是&amp;ldquo;字符腐烂&amp;rdquo;，是一种恰当的描述。在标准&lt;b&gt;IPA&lt;/b&gt;语音中发音为[ &lt;code&gt;modʑibake&lt;/code&gt; ] ，或近似为&amp;ldquo; moh-jee-bah-keh&amp;rdquo;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">当你在.xs文件中为例程指定参数时,你实际上是为列出的每个参数传递了三条信息。第一条是该参数相对于其他参数的顺序(第一、第二等)。第二条是参数的类型,由参数的类型声明组成(例如,int、char*等)。第三块是该参数在调用库函数时的调用约定。</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">当你提供一个单独的显示名称时,就可以多次运行一个测试;显示名称实际上是测试在线束中的别名。当每次调用使用不同的名称时,线束不会在意是否会多次运行同一个测试。</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 锁定文件时， &lt;code&gt;Tie::File&lt;/code&gt; 假定读取缓存不再受信任，因为自上次读取文件以来，另一个进程可能已经修改了该文件。因此，对 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 的成功调用将丢弃读取缓存和内部记录偏移表的内容。</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">当你从C语言中使用Perl时,你的C语言程序通常会分配、&quot;运行 &quot;和重新分配一个</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">当您使用&lt;b&gt;-n&lt;/b&gt;和&lt;b&gt;-p&lt;/b&gt;切换到Perl时， &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;END&lt;/code&gt; 就像在&lt;b&gt;awk&lt;/b&gt;中一样工作，这是简并的情况。无论 &lt;code&gt;BEGIN&lt;/code&gt; 和 &lt;code&gt;CHECK&lt;/code&gt; 当您使用块运行&lt;b&gt;-c&lt;/b&gt;开关仅编译语法检查，虽然你的主要代码是没有。</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">当您使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或Perl的&lt;b&gt;-w&lt;/b&gt;命令行选项时，您可能会看到有关在&amp;ldquo;无效上下文&amp;rdquo;中无用的常量或函数使用的警告。无效上下文仅表示该值已被丢弃，例如仅包含 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; 的语句；或 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; 。对于关心是否在列表上下文中调用它们的函数，它仍视为标量上下文。</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">然而,当你想对邮件和网页进行Unicode编码时,不要使用UTF-7,除非你确信你的收件人和读者可以处理它。现在很少有MUA和WWW浏览器支持(似乎只有Mozilla支持)。在一般情况下,使用UTF-8作为邮件主体,MIME-Header作为邮件头。</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">当你想写到一个文件时,你首先要决定如何处理该文件的任何现有内容。在这里,你有两个基本选择:保存或删除。</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">完成文件句柄后，应将它们 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; （尽管老实说，如果您忘记了，Perl将在您清理之后）：</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">当您使用RETVAL返回 &lt;code&gt;SV *&lt;/code&gt; 时，幕后发生了一些不可思议的事情。例如，当您使用ST（x）宏操作参数堆栈时，通常必须特别注意引用计数。（有关参考计数的更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。）为了使您的生活更轻松，当返回 &lt;code&gt;SV *&lt;/code&gt; 时，typemap文件会自动使 &lt;code&gt;RETVAL&lt;/code&gt; 成为凡人。因此，以下两个XSUB或多或少是等效的：</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">当你发现你要做的事情没有可用的模块,而你又不得不自己写代码的时候,可以考虑把解决方案打包成一个模块,然后上传到CPAN上,这样其他人就可以受益了。</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">当你整理好你的名字,确定你的模块是想要的,而且目前还没有,就可以开始编码了。</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">当您的孩子完成测试后，您必须致电 &lt;code&gt;finalize&lt;/code&gt; 进行清理，并告诉父母您的通过/失败状态。</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">当你的模块遇到一个错误时,它应该做一个或多个。</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">当， &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 启用，使用是否从存档文件的权限此设置不控制，如果他们删除任何SETID位和运用当前的umask过滤的修改。</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">每当Berkeley DB函数通过其参数之一返回数据时，等效的&lt;b&gt;DB_File&lt;/b&gt;方法就会执行完全相同的操作。</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">每当一个Perl子程序被调用时,使用其中一个</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">每当一个引用被用作字段哈希键时,都会检查对象登记册,必要时还会新建一个条目。然后,该字段哈希将被添加到该参考资料使用过的字段列表中。</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">每当控制权从</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">在可能的情况下,新功能应该在CPAN模块中进行原型设计,然后再考虑将其纳入核心。</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">每当将其应用于不完全满足模式要求的字符串（例如 &lt;code&gt;&quot;abc &quot;&lt;/code&gt; 或 &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; ，正则表达式引擎都会回退，对于字符串中的每个字符大约回溯一次。但是我们知道没有办法</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">每当您在Perl中对文件进行I / O时，都需要通过Perl中称为&lt;b&gt;filehandle的方式来进行&lt;/b&gt;。文件句柄是外部文件的内部名称。在内部名称和外部名称之间建立关联是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 函数的工作，而打破该关联是 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数的工作。</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">当你有多个子进程时,你必须注意每个子进程都要关闭为进程间通信而创建的任何一半管道。这是因为任何从管道中读取并期望得到 EOF 的子进程将永远不会收到 EOF,因此永远不会退出。单个进程关闭管道还不足以关闭它;最后一个打开管道的进程必须关闭管道才能读取EOF。</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">每当你和你的 perl 进程外部的任何东西进行文本交流时,比如数据库、文本文件、套接字或其他程序。即使你要与之通信的东西也是用Perl写的。</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">每当将编码的二进制字符串与文本字符串一起使用时，Perl都会假定您的二进制字符串是使用ISO-8859-1（也称为latin-1）编码的。如果不是latin-1，那么您的数据将被令人讨厌地转换。例如，如果它是UTF-8，则将多字节字符的各个字节视为单独的字符，然后再次转换为UTF-8。可以将这种双重编码与双重HTML编码（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）或双重URI编码（ &lt;code&gt;%253E&lt;/code&gt; ）进行比较。</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">每当你的程序访问可以被其他线程访问的数据或资源时,你必须采取措施协调访问,否则就会有数据不一致和竞赛条件的风险。请注意,Perl会保护其内部免受你的竞赛条件的影响,但它不会保护你。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">其中1是字符串中第一个字符的位置。请注意,位置可以是0,也可以大于图案的实际长度,同样,长度也可以是0。</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">其中 &lt;code&gt;$id1&lt;/code&gt; ， &lt;code&gt;$id2&lt;/code&gt; 是两个字节的子字段ID。除非已禁用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 选项，否则ID的第二个字节不能为0 。</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">凡 &lt;code&gt;$r1&lt;/code&gt; 可以是任何类型的数据结构，你想一个参考。它将被深深地复制。因为 &lt;code&gt;dclone&lt;/code&gt; 接受并返回引用，所以如果要复制的数组的哈希值很大，则必须添加额外的标点符号。</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">当一个&lt;b&gt;编译器&lt;/b&gt;记住符号。像Perl这样的程序必须以某种方式记住您使用过的所有&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;文件句柄&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;的所有名称。它通过将名称放在符号表中来实现，该符号表在Perl中使用&lt;b&gt;哈希表实现&lt;/b&gt;。每个&lt;b&gt;包&lt;/b&gt;都有一个单独的符号表，以为每个&lt;b&gt;包&lt;/b&gt;提供自己的&lt;b&gt;名称空间&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">模块安装在哪里?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">我在哪里可以买到商业版的Perl?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">我在哪里可以得到 vi 的 Perl 宏?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">我在哪里可以获得Perl的信息?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">我在哪里可以得到 perl-mode 或 cperl-mode for emacs?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">我在哪里可以学习CGI或Perl中的Web编程?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">我在哪里可以学习C语言与Perl的链接?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">哪里可以学习面向对象的Perl编程?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">我在哪里可以发布问题?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">我在哪里可以得到做ioctl()或syscall()的包含文件?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">我在哪里发送错误报告?</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">落实在哪里?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">人们遇到麻烦的地方就在这里。</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">在涉及前提条件的情况下，如果使用META_MERGE，则前提条件将与其对应的 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数合并（PREREQ_PM并入{prereqs} {runtime} {requires}，BUILD_REQUIRES并入 &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; ，CONFIGURE_REQUIRES并入 &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; ，然后将TEST_REQUIRES放入 &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; 中。当使用META_ADD指定先决条件时，添加到文件的唯一先决条件来自元数据，而不是 &lt;code&gt;WriteMakefile()&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">其中$way是一个从0($theta0,$phi0)到1($theta1,$phi1)的值。请注意,反极点(其距离为</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">其中'DSLIP'字符具有以下含义。</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">如果只有一个操作数(或只有一个操作数有重载),则跳过对上述其他操作数的检查。</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">这些步骤在perl程序的实际执行中发生的位置由模式是否涉及对任何字符串变量进行插值来确定。如果发生插值，则编译将在运行时发生。如果不是，则在编译时执行编译。（ &lt;code&gt;/o&lt;/code&gt; 修饰符在一定程度上改变了它， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 也是如此。）引擎实际上并不那么在乎。</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">哪里可以找到社区</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">在哪里可以找到perlfaq</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">您在哪里寻找其他地方的信息指针。（请参阅&lt;b&gt;间接&lt;/b&gt;引用。）引用有两种形式：&lt;b&gt;符号引用&lt;/b&gt;和&lt;b&gt;硬引用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">渔获物在哪里？在第一个字段 &lt;code&gt;count&lt;/code&gt; 之前，在此字段和下一个字段 &lt;code&gt;glyph&lt;/code&gt; 之间都不需要填充，因此为什么我们不能像这样简单地打包：</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">而一个同时适用于ASCII和EBCDIC平台的QP解码器则有点像下面的样子。</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">而下面是一个Perl程序员对这个成语比较熟悉的做法。</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">而如果你把我说的那两行字注释出来,你可能会希望,那么它反而会这样显示给你。</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">只要能给出一个运算符列表,就可以使用一个或多个OPSET。请参阅下面的操纵操作集。</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">在可能的情况下,可共享的图像优于对象库,对象库优于普通对象文件。按照VMS的命名惯例,ext()会查找名为</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePV是否是UTF8格式。目前,这个值总是为真。</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT（在这种情况下启用了 &lt;code&gt;require_order&lt;/code&gt; ），否则默认设置为禁用。</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">是否允许命令行参数与选项混合。除非已设置环境变量POSIXLY_CORRECT，否则将启用默认值，在这种情况下，禁用 &lt;code&gt;permute&lt;/code&gt; 。请注意， &lt;code&gt;permute&lt;/code&gt; 与 &lt;code&gt;require_order&lt;/code&gt; 相反。</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">是否已经通过窥视孔优化器对操作进行了优化。</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">测试是否应该输出数字。也就是说,这个如果为真。</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">是否对它正在做的事情进行详细说明--它将默认为$Module::Load::Conditional::VERBOSE。</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">这个条目是否属于外垫。这种情况的条目通常被称为 &quot;假的&quot;。</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;状态 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">这是否是一个 &quot;我们的 &quot;变量。</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">如果调试器信号标志被激发,是否要中止打印。</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">是否在每页顶部增加一个目录(为了传统,称为索引)。</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">是否锚定每个定义 &lt;code&gt;=item&lt;/code&gt; 指令。如果您希望能够链接到特定的 &lt;code&gt;=item&lt;/code&gt; 指令（以 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 元素输出），则需要启用此功能。默认禁用。</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">是否将这些扩展的字词群称为 &quot;字符&quot;,取决于你的观点。如果你是一个程序员,你可能会倾向于把序列中的每个元素看作一个单元,或者说 &quot;字符&quot;。然而从用户的角度来看,整个序列可以被看作是一个 &quot;字符&quot;,因为在用户语言的上下文中,这可能就是它的样子。在本文档中,我们从程序员的角度出发:一个 &quot;字符 &quot;就是一个Unicode码点。</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">是否打印二进制或 &quot;按原样 &quot;设置的高位字符。</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">是否打印globs的内容。</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">是否尝试查找给定引用的子程序名。</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">是否将每个=head1指令都变成指向页面顶部的链接(特别是开头的body标签)。</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">是否编写非过载形式的字符串化过载对象。</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">Perl不能控制各种库调用是否是线程安全的。经常受线程安全影响的调用包括： &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; ，获取用户，组和网络信息的函数（例如 &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; 等等）， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 。通常，调用取决于某些全局外部状态。</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">你是否使用NIS并不重要。令人惊奇的是,同样的bug也会影响到Solaris。</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">无论您使用 &lt;code&gt;perlbug&lt;/code&gt; 还是手动发送电子邮件，请使您的主题行内容丰富。 &amp;ldquo;错误&amp;rdquo;不提供信息。 &amp;ldquo; perl崩溃&amp;rdquo;也不是&amp;ldquo;帮助！&amp;rdquo;。这些无济于事。简要描述出什么问题是可以的。</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">呼! 剩下的角色和角色类就这些了。</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">正在Perl级别上在 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; 上执行哪个&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;操作：</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">我应该看哪些Perl博客?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">你更喜欢哪种YAML实现?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">哪个架构依赖目录?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">哪个字符集修改器是有效的?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">首先检查哪种方法， &lt;code&gt;nomethod&lt;/code&gt; 或 &lt;code&gt;fallback&lt;/code&gt; ？如果一个运算符的两个操作数是不同类型的并且都使该运算符超载，则使用哪种实现？以下是优先规则：</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">这实际上只是。</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">这可能是我们所期望的，该匹配项在字符串中找到了唯一的 &lt;code&gt;cat&lt;/code&gt; 并将其锁定。但是，请考虑以下正则表达式：</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">哪些杂志有Perl内容?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">这样一来,$richard和$dick就成了同一个变量,但@richard和@dick就成了单独的数组。棘手吧,嗯?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">该op使用哪种 &lt;code&gt;*OP&lt;/code&gt; 结构。这应该是 &lt;code&gt;OA_*&lt;/code&gt; 常量之一</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">这些修饰符中的哪一个在正则表达式的任何给定点有效，取决于一组相当复杂的交互作用。这些功能的设计使您通常不必担心，但是本节提供了详细的信息。如以下&lt;a href=&quot;#Extended-Patterns&quot;&gt;扩展模式中所述&lt;/a&gt;，可以显式指定仅适用于正则表达式部分的修饰符。最里面的总是优先于任何外部的，而应用于整个表达式的优先于本节其余部分描述的任何默认设置。</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">你选哪一个,要看这些表达方式中哪一个更能体现上面的注释规范。</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">这或许是意外的收获。</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">根据&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符生效&lt;/a&gt;来确定适用哪些规则？在。</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">先检查哪个子串。</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用哪种文本格式化程序。默认值为&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;，或者对于非常旧的Perl版本&lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt;。另一种选择是例如&lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">我应该使用哪个版本的Perl?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">我应该使用哪个版本的perl?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">我应该使用哪个网络框架?</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">这将打印</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">这将试图在调试器初始化后立即在第4行和第6行设置断点。请注意,@DB::typeahead不是一个支持的接口,在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">这将产生一个类似于这样的格式。</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">其中,在只使用普通数组的退化情况下,可以得到像C语言一样的多维数组。</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">无论使用哪种版本，实际方法都将通过 &lt;code&gt;EVERY&lt;/code&gt; 在与原始调用相同的上下文中（列表，标量或void）调用，并返回：</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">虽然$FORMAT_TOP_NAME包含了当前页眉格式的名称,但没有相应的机制来自动为页脚做同样的事情。在评估之前,不知道一个格式会有多大,这是主要问题之一。这已经在TODO列表中了。</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">尽管 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 提供仅整数运算，但没有类似的机制可提供自动舍入或舍入到一定数量的小数位。对于四舍五入到一定数量的数字， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 通常是最简单的方法。参见&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">尽管 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 和 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 对于每个实例都是独立的类很有用，但该机制很难（或不兼容）与作为公共流程级或系统级资源存在的对象（例如单例对象，数据库池，缓存或已记录对象）一起使用（或不兼容） 。</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">虽然 B::Deparse 会花一些力气去弄清楚你的原始程序在做什么,但语言的某些部分还是会让它绊倒;甚至在 Perl 自己的测试套件的某些部分也会失败。如果你遇到了下面 BUGS 部分所描述的最常见的故障以外的故障,你可以通过提交一个小例子的 bug 报告来帮助 B::Deparse 的持续发展。</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">虽然BigInt对inf和NaN有广泛的处理,但仍然存在某些怪癖。</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">虽然C语言保证了结构定义中指定的排序,但不同平台之间的定义可能有所不同</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">虽然Dan Kogai作为维护者保留了版权,但所有参与的人都应该得到荣誉。请参阅AUTHORS以了解提交项目代码的人员名单。</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">当Perl试图保持vaxc$errno的值为当前值时,如果errno不是EVMSERR,它可能不是来自当前的操作。</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perl通过引用向函数传递参数,而C语言则通过值传递参数;要实现一个修改其中一个 &quot;参数 &quot;数据的C函数,这个C函数的实际参数将是一个指向数据的指针。因此,两个C函数的声明是</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">尽管System V IPC并未像套接字那样被广泛使用，但它仍有一些有趣的用途。但是，您不能使用SysV IPC或Berkeley mmap（）在多个进程之间共享变量。那是因为Perl会在您不想要的时候重新分配您的字符串。您可以考虑使用 &lt;code&gt;IPC::Shareable&lt;/code&gt; 或 &lt;code&gt;threads::shared&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">虽然是个不错的扩展,但它并不便携。Perl 代码确实会在可用的情况下使用它们来获得一些额外的速度(本质上是一种时髦的内联形式),但你不应该这样做。</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">在搜索过程中，进度对象的 &lt;code&gt;reach&lt;/code&gt; 和 &lt;code&gt;done&lt;/code&gt; 方法按如下方式调用：</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">虽然显然是一个全新的程序。</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">在构建Perl时，您的Cygwin设置可能需要进行一些更改，以便Perl能够干净地构建。这些变化&lt;b&gt;并不&lt;/b&gt;需要正常的Perl使用。</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">在检查时，此模块收集文档属性，例如，超链接（ &lt;code&gt;=headX&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; ）和索引条目（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）的节点。POD转换程序可以使用此功能进行语法检查并在实际开始转换之前的第一遍中获取节点。就执行时间而言，这是昂贵的，但是允许非常可靠的转换。</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">尽管专家可能会争论这些习惯用法，但是Perl胆量的新手可能更喜欢一种Perl胆量特定的方式，这意味着自动转换和自动调用生成，就像&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;从XSUBs中脱颖而出&lt;/a&gt;。这种方法的另一个好处是可以保护XSUB编写器免受将来对Perl API的更改。</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">虽然原则上可以通过CRTL &lt;code&gt;vfork()&lt;/code&gt; 例程（并具有与之相同的相当严格的限制）来实现 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 运算符，并且尽管已有一些内部支持来实现此目的，但该实现尚未完成，使得 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 目前不可用。期望在VMS的未来版本中使用真正的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 内核，并且在VMS的Perl的未来版本中可以使用基于解释器线程的伪叉（请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;）。同时，使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ，反引号或管道文件句柄创建子进程。</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">在这种模式下,Perl会采取特殊的预防措施,称为</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">虽然可以 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; FileCache托管文件，但是如果您从导入的包之外的包或另一个覆盖 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 的模块中调用 &lt;code&gt;FileCache::cacheout&lt;/code&gt; ，则不要这样做。如果必须，请使用 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">虽然对于文档变更、新的测试或琐碎的补丁来说没有必要,但通常值得解释一下你的变更是如何工作的。即使你今天很清楚,但下个月或明年的搬运工可能就不清楚了。</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">虽然可以在类外直接引用这些哈希键,但最好的做法是将所有对属性的访问都用访问器方法包起来。</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">虽然Perl的正则表达式确实确实类似于egrep（1）程序的DFA（确定性有限自动机），但实际上它们已实现为NFA（非确定性有限自动机）以允许回溯和反向引用。而且它们也不是POSIX风格的，因为它们保证了所有情况下的最坏情况。 （似乎有些人更喜欢一致性的保证，即使保证的是缓慢性。）请参阅Jeffrey Friedl的书&amp;ldquo; Mastering Regular Expressions&amp;rdquo;（来自O'Reilly），以获取您希望在这些问题上知道的所有详细信息（完整的引文出现在&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2中&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">虽然这个文档确实有些子虚乌有,但如果你使用一个名为</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">虽然字面列表和命名数组通常是可以互换的,但哈希的情况并非如此。仅仅因为你可以像普通数组一样下标一个列表值,并不意味着你可以将一个列表值下标为哈希。同样,作为其他列表(包括参数列表和函数的返回列表)的一部分的哈希值总是扁平化为键/值对。这就是为什么有时使用引用是好的。</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">虽然这个文件中最重要的值</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">虽然内置的数据类型都没有任意的大小限制(除了内存大小),但还是有一些任意的限制:一个给定的变量名不能超过251个字符。诊断程序显示的行号在内部存储为短整数,所以它们的最大限制是65535(更高的数字通常会受到环绕的影响)。</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">虽然并不完全局限于Unix衍生的操作系统(例如,PC上的WinSock提供了套接字支持,一些VMS库也提供了支持),但你的系统上可能没有套接字,在这种情况下,本节可能对你没有什么好处。有了套接字,你既可以做像TCP流这样的虚拟电路,也可以做像UDP包这样的数据报。根据你的系统,你可能可以做得更多。</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">在运行Configure和构建时,你很可能会收到不少这样的警告。</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">虽然像 &lt;code&gt;$gotit&lt;/code&gt; 这样的短标识符可能没问题，但请使用下划线将较长标识符中的单词分开。通常， &lt;code&gt;$var_names_like_this&lt;/code&gt; 比 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; 更容易阅读，尤其是对于非英语母语的人。这也是一条与 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; 一致的简单规则。</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">尽管有些开发人员发现致命警告某些警告是一种有用的防御性编程技术，但使用 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 来致命警告所有可能的警告类别（包括自定义警告）特别危险。因此，使用的 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; 被&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;气馁&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">当仍在该目录中时,输入:</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">虽然GNU项目在其发行版中包含了Perl,但并不存在 &quot;GNU Perl &quot;这样的东西。Perl 不是由自由软件基金会制作或维护的。Perl的许可条款也比GNU软件更开放。</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">虽然Unicode标准定义了两种附加的大小写折叠形式，一种用于突厥语，另一种从未将一个字符映射成多个字符，但Perl内核没有提供这些形式。但是，CPAN模块 &lt;code&gt;Unicode::Casing&lt;/code&gt; 可用于提供实现。</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">虽然键必须是字符串值(因为这是Perl对哈希键的基本限制),但目前词库中的值可以有几种类型:定义的标量、标量ref或coderef。这些的使用在上面的 &quot;maketext &quot;方法 &quot;一节中进行了说明,下一节将讨论字符串的括号符号。</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">虽然参数列表对于一个、两个甚至三个参数来说可能很好用,但任何更多的参数对于模块用户来说都会变得很难记住,对于模块作者来说也很难管理。如果你想添加一个新的参数,为了向后兼容,你必须把它添加到列表的最后,这可能会使你的列表顺序变得不直观。另外,如果很多元素可能是未定义的,你可能会看到以下不好看的方法调用。</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">虽然 &quot;infin &quot;到字符&quot;\x{221E}&quot;的映射(希望)已经被Pod解析器处理过了,但这个文件中出现的字符意味着它足够重要,可以被包含在一个表格中,从著名的Unicode字符映射到渲染它们所需的代码。因此,对于Unicode-to-*roff映射,例如,这将是值得的条目。</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">尽管这两个类在许多方面可能有所不同，但是当涉及到 &lt;code&gt;print_content()&lt;/code&gt; 方法时，它们是相同的。这意味着我们可以尝试在任一类的对象上调用 &lt;code&gt;print_content()&lt;/code&gt; 方法，而&lt;b&gt;不必知道该对象属于哪个类！&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">虽然目前还没有与perl一起发布的特定架构的扩展或模块,但以下目录可以用来存放这些文件(用适当的版本号替换字符串VERSION)。</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">尽管这些操作不是生死攸关的问题，但许多有用的脚本需要它们。这迫使 &lt;code&gt;a.out&lt;/code&gt; 风格的编译</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">虽然这其实是可以做到的,但比你想象的要难得多。例如,这个单行本</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">虽然这允许一些(显著的?)性能优势,但这给开发人员的生活带来了很大的困难,因为上述方案使得DLL不可能与</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">虽然这个类目前是用Class::Struct模块来实现的,以建立一个类似结构体的类,但你不应该依赖这个。</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">虽然这个编译和运行得很愉快,但它可能不会做预期的事情,即它根本不会打印 &quot;Hello World\n&quot;;另一方面,它将完全按照它被告知的那样去做,因为计算机有点倾向于这样。也就是说,它会打印出一个换行符,而你会得到一个看起来像空行的东西。它看起来像有两个变量,而(因为打错了)实际上有三个。</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">虽然目前所有三个实现中都有这个功能,但perl本身并没有使用它。</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">虽然本文件旨在对所有模块作者有用,但它特别针对那些希望在CPAN上发布模块的作者。</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">虽然这是合法的做法,但它肯定是可疑的,至少在一个平台上是致命的:例如VMS cc认为这是一个致命的错误。人们经常犯这种错误的一个原因是,一个 &quot;裸体char &quot;以及因此而派生的 &quot;裸体char指针 &quot;具有未定义的签名性:结果是有签名还是无签名取决于编译器和底层平台的标志。出于同样的原因,使用 &quot;char &quot;作为数组索引是不好的。</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">虽然表面上看是这样,但一次只处理一行或一条记录的文件效率要高得多,因为这样你就不必一次把整个文件读到内存中。它还能让你更精细地控制整个过程,如果你愿意,可以让你提前杀掉子进程。</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">虽然在基于事件的Pod解析器中实现这一点可能会过于繁琐,但对于返回解析树的解析器来说,它是直接的。</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">尽管这可能是偶然地在某些平台（IV恰好是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ）上工作的，但通常不能。IV可能更大。更糟糕的情况是使用更特定的类型（由Perl的配置步骤定义）</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">虽然这对于单向通信来说效果还算不错,但双向通信呢?最显而易见的方法是行不通的。</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">虽然线程带来了一系列新的有用工具,但它们也带来了一些陷阱。其中一个陷阱就是竞赛条件。</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">当试图从他的来电显示框中读取内容时，臭名昭著的Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 咬牙切齿地与 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; ，POSIX的 &lt;code&gt;tcgetattr&lt;/code&gt; 业务以及各种其他功能在晚上碰到了一样，终于想到了这个：</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">当使用标准的</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">当版本对象超载字符串化时，为了将 &lt;code&gt;$^V&lt;/code&gt; 转换为字符串表示形式，请使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 转换，该转换对v字符串或版本对象均适用：</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">虽然比5.8.1更早的版本有线程,但它们包含的bug太多,无法支持。</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">虽然我们通常认为模式用 &lt;code&gt;/&lt;/code&gt; 字符分隔，但几乎可以用任何字符分隔它们。&lt;a href=&quot;perlre&quot;&gt;perlre对此进行了&lt;/a&gt;描述。例如，上面的 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 使用花括号作为定界符。选择另一个定界符可以避免在模式中引用定界符：</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">尽管我们强烈建议您不要从头开始构建对象，但是您应该知道术语&lt;b&gt;bless&lt;/b&gt;。受&lt;b&gt;祝福的&lt;/b&gt;数据结构（也称为&amp;ldquo;对象&amp;rdquo;）是一个对象。有时我们说一个对象已经&amp;ldquo;被祝福到一个类中&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">虽然我们通常将引号视为文字值，但在Perl中它们充当运算符，提供各种插值和模式匹配功能。Perl为这些行为提供了惯用的引号字符，但还为您提供了一种为其中任何一种选择引号字符的方法。在下表中， &lt;code&gt;{}&lt;/code&gt; 代表您选择的任何一对定界符。</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">当我们在这里时，请仔细看一下' &lt;b&gt;x&lt;/b&gt; '命令，它确实很有用，并且会愉快地转储嵌套引用，完整对象，部分对象-几乎与您抛出的内容一样：</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">虽然可以将双冒号与单引号引起来，但引号必须在冒号后： &lt;code&gt;$::::'foo&lt;/code&gt; 和 &lt;code&gt;$foo::'bar&lt;/code&gt; 是合法的，但是 &lt;code&gt;$::'::foo&lt;/code&gt; 和 &lt;code&gt;$foo'::bar&lt;/code&gt; 不是。</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">虽然你可以为词库键使用任意的唯一ID(如&quot;_min_larger_max_error&quot;),但它通常对一个条目的键本身是一个有效的值很有用,就像这个错误信息的例子。</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">当你这样做的时候,要确保你没有错过一个类似于你要写的模块。</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">当控件在库中时,发生了一个错误条件。你之前已经设置了一个Perl回调来处理这种情况,所以它将被执行。一旦回调完成,控制将再次回到Perl中。下面是在这种情况下的控制流程。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">空格不对文件组进行定界。</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">文件名中的空白在大多数系统中是可以被容忍的,但并非所有系统都可以,即使在可以容忍的系统中,一些实用程序也会被这种空白所迷惑。</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">忽略空白处。</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">空格是无关紧要的。</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">谁需要复杂的数据结构?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">谁支持Perl?谁在开发它?为什么它是免费的?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">谁写的 (如果是多人写的,就用AUTHORS)。最好包括你当前的电子邮件地址(或一些应该发送错误报告的电子邮件地址)或其他一些联系信息,这样用户就有办法与你联系。记住,程序文档在野外漫游的时间往往比你预想的要长得多,要选择一种可能持续的联系方法。</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">哎呀！您只需在该文件名中放入一个标签和一个换页符即可！请记住，在双引号字符串（&amp;ldquo; like \ this&amp;rdquo;）中，反斜杠是转义字符。这些的完整列表&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;在perlop&lt;/a&gt;中的Quote和类似Quote的运算符中。毫不奇怪，您的旧DOS文件系统上没有名为&amp;ldquo; c：（tab）emp（formfeed）oo&amp;rdquo;或&amp;ldquo; c：（tab）emp（formfeed）oo.exe&amp;rdquo;的文件。</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">呜呜,你应该用这个。你应该用这个,如果文件不存在,就会失败。</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">为什么我得到的是长小数(例如,19.9499999999999),而不是我应该得到的数字(例如,19.95)?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">为什么我的随机数不是随机的?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">为什么我不能用system()获取命令的输出?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">为什么我不能只打开（FH，&amp;ldquo;&amp;gt; file.lock&amp;rdquo;）？</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">为什么我在DOS路径中不能使用 &quot;C:tempfoo&quot;?为什么 &quot;C:\tempfoo.exe &quot;不能使用?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">为什么在这个同样的文件中找不到一个方法?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">为什么我的脚本在给了EOF(Unix上是^D,MS-DOS上是^Z)之后不能从STDIN读取?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">为什么要建立奇美拉?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">为什么MakeMaker要重新发明构建配置轮?为什么不直接使用autoconf或automake或ppm或Ant或 ...</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">为什么每次启动shell都会问我同样的问题?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">为什么我在打印一个数组行时得到奇怪的空格?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">为什么在使用&amp;lt;*&amp;gt;时有时会出现&amp;ldquo;参数列表过长&amp;rdquo;的情况？</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">为什么我有时会收到 &quot;Argument list too long&quot;(参数列表太长),当我使用?</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">为什么Perl运算符与C运算符的优先级不同?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">为什么regex字符类有时只在ASCII范围内匹配?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">为什么setuid perl脚本会抱怨内核问题?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">为什么有些字不能正确地大写或小写?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">你为什么要这样做?)</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么 Perl 让我删除只读文件?为什么 -i 会破坏受保护的文件?这难道不是 Perl 的一个错误吗?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">为什么Perl让我删除只读文件？为什么 &lt;code&gt;-i&lt;/code&gt; 破坏器保护文件？这不是Perl中的错误吗？</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">为什么 defined()在空数组和哈希上返回 true?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">为什么在哈希中传递一个未定义元素的子程序会创建它?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">为什么使用$＆，$`或$'会使我的程序变慢？</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">为什么不显示&amp;ldquo; my（$ foo）= &amp;lt;$ fh&amp;gt;;&amp;rdquo; 工作吧？</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">为什么 &quot;my($foo)=;&quot;不能正常工作?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">为什么不按我想要的方式工作？</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">为什么 glob(&quot;*.*&quot;)不能得到所有的文件?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">为什么我的套接字程序在System V (Solaris)下不能工作?协议不支持 &quot;的错误信息是什么意思?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">为什么管道打开失败时,open()不返回错误?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">为什么Perl单行本在我的DOS/Mac/VMS系统上无法使用?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">为什么我的&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">为什么我的&amp;lt;&amp;lt; HERE文档不起作用？</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">为什么我的绑定哈希不做定义/存在的区分?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">为什么用 &lt;code&gt;\b&lt;/code&gt; 进行单词边界搜索对我不起作用？</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">為什麼我不能用字界搜索?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">为什么要做动态链接?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">为什么int()会坏掉?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">为什么我的数据库里有Perl源码?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">为什么我的八进制数据解释不正确?</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">为什么会有奇怪的名字?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">到底为什么Encode API不一样?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">为什么使用pport.h?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">为什么你会想要一个列表的哈希?让我们举个简单的例子。你有一个城市和国家名称的文件,像这样。</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">您可能会问，为什么需要一块包含一些二进制表示值的内存？一个很好的理由是输入和输出访问某些文件，设备或网络连接，这样，这种二进制表示形式要么强加于您，要么将给您带来一些处理上的好处。另一个原因是将数据传递给Perl函数无法使用的某些系统调用： &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 要求您提供以C程序中发生的方式存储的参数。通过明智地使用这两个功能，甚至可以简化文本处理（如下一节所示）。</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">为什么？由于 &lt;code&gt;can&lt;/code&gt; 回报CODEREF表示&amp;ldquo;是的，它可以（和方法是这样的......）&amp;rdquo;，然后 &lt;code&gt;ok&lt;/code&gt; 看到了CODEREF并且认为你传递一个函数，你想它来调用，并考虑结果的真相的！即，就像：</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">为什么？因为 &lt;code&gt;nasty_break()&lt;/code&gt; 修改 &lt;code&gt;$\&lt;/code&gt; 而不先对其进行本地化。返回时，您在 &lt;code&gt;nasty_break()&lt;/code&gt; 中设置的值仍然存在。解决方法是添加 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; ,以便该值不会从 &lt;code&gt;nasty_break()&lt;/code&gt; 中泄漏出来：</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">通配符扩展</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">我的旧脚本会不会坏掉?</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">会将文件添加到内存存档中，名称 &lt;code&gt;$filename&lt;/code&gt; ，内容 &lt;code&gt;$data&lt;/code&gt; 。可以使用 &lt;code&gt;$opthashref&lt;/code&gt; 设置特定属性。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。（在MacOS上，文件的路径和修改时间将转换为Unix等效文件。）</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时将被调用。（请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">将按需加载,由BigInt自动调用。</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">将被预置到每个安装路径中。</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">将用于修改应用于字符串的padding,如上所述。</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">都将原样保留该句子。通常，当接受来自用户的文字字符串输入时，必须使用quotemeta（）或 &lt;code&gt;\Q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">将导致 &lt;code&gt;$sentence&lt;/code&gt; 成为 &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">如果出现错误,会呱呱叫()。</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">如果在r-magic上调用,会死()。</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">会以人类可读的格式转储任何参考资料的内容。很方便,比如...</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">将以人类可读的格式转储任何引用的内容。通常，您要将其传递给 &lt;code&gt;note&lt;/code&gt; 或 &lt;code&gt;diag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">将强制使用较早的 &lt;code&gt;Test&lt;/code&gt; 模块生成测试代码。</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">会错误地打印</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">将确保= head1将变为&amp;lt;h3&amp;gt;并且= head2将变为&amp;lt;h4&amp;gt;等等...</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">不会导致 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 重新读取目录流。在 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 调用之前已读取的条目将仅从缓存缓冲区中再次返回。（Win32的）</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">在不支持C测试的平台上将无法使用粘性位。</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">将输出2，而不是1。如果要使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 运算符编译定义，然后以另一种模式内插它们，则这尤其重要。</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">将防止自动使用INSTALL.SKIP作为安装跳过文件。</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">将打印 &lt;code&gt;2&lt;/code&gt; ，因为 &lt;code&gt;$string&lt;/code&gt; 已升级为UTF-8。不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; ，它将改为打印 &lt;code&gt;4&lt;/code&gt; ，因为当解释为Latin-1时 &lt;code&gt;$string&lt;/code&gt; 是三个八位字节。</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">会产生这样的东西。</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">将使用&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;作为线束类，并将TAP保存到 &lt;code&gt;file.tgz&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 CORE函数存根</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">Win32执行</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Win32对Sys::Syslog的支持。</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32用户应该使用真正的斜线。如果你真的想使用反斜线,可以考虑使用 Sarathy 的 File::DosGlob,它是标准的 Perl 发行版。</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95和Win98以及WinME是Win9x和Win32的统称。</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">如果我们将最大长度设置为nmake的最大2K,Win98会对Encode这样的东西产生窒息。所以我们选择一个比较保守的值1K。</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9x无法 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; 打开的文件（尽管WinNT可以）。</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9x不能正确报告 &lt;code&gt;EOF&lt;/code&gt; ，并且在封闭的管道上进行非阻塞读取。您将看到以下消息：</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">5.6中增加了对Win9x的支持(Benjamin Stuhl)。</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Server支持Intel Itanium架构上的LLP64数据模型。</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windows事件日志，&lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">Windows是Win32。</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows是Windows telnet,Cygwin SSH是Windows NT上Cygwin下的OpenSSH实现,Mac Terminal是Mac OS X中的终端应用程序。当条目不是yes或no时,仿真器会将给定的属性显示为其他内容。请注意,在 aixterm 上,清除并不能重置颜色;你必须明确地将颜色设置为你想要的颜色。欢迎在此表中添加更多条目。</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用 &lt;code&gt;nmake&lt;/code&gt; 的 Windows用户应注意，由于 &lt;code&gt;nmake&lt;/code&gt; 中的错误，在指定 &lt;code&gt;TEST_FILES&lt;/code&gt; 时，必须使用反斜杠而不是正斜杠。</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windows专用测试。</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">在$k慎重选择的情况下,而且很可能是1或2这样的小数。理论上斗阵越大,碰撞的几率越小。</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">使用5005线程，您还可以 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 一个子线程，以便从另一个线程对该子线程的任何调用都将阻塞，直到释放锁定为止。</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">使用 &lt;code&gt;/a&lt;/code&gt; ，您可以放心地写 &lt;code&gt;\d&lt;/code&gt; 仅匹配ASCII字符，并且如果需要匹配ASCII以外的字符，则可以改用 &lt;code&gt;\p{Digit}&lt;/code&gt; （对于 &lt;code&gt;\w&lt;/code&gt; 使用 &lt;code&gt;\p{Word}&lt;/code&gt; ）。有类似的 &lt;code&gt;\p{...}&lt;/code&gt; 构造可以匹配ASCII以外的&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白&lt;/a&gt;（请参见perlrecharclass中的Whitespace）和Posix类（请参见&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的POSIX字符类&lt;/a&gt;）。因此，此修饰符并不意味着您不能使用Unicode，它意味着要获得Unicode匹配，您必须显式使用发出Unicode信号的结构（ &lt;code&gt;\p{}&lt;/code&gt; ， &lt;code&gt;\P{}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ，您可以使用一个块和一个放置文件句柄的表达式来解决此问题：</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; ，除非 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 命令将它们重定向，否则STDOUT和STDERR都将与脚本的STDOUT和STDERR放在同一位置。反引号和 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; &lt;b&gt;仅&lt;/b&gt;读取命令的STDOUT。</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">使用 &lt;code&gt;Class::Tiny&lt;/code&gt; ，所有访问器都是可读写的。它为您以及您定义的访问器生成一个构造函数。</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">使用 &lt;code&gt;ignore_case&lt;/code&gt; 时，仅大小写不同的选项的选项规范（例如 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; ）将被标记为重复项。</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">使用 &lt;code&gt;pass_through&lt;/code&gt; 时,任何未知，模棱两可或带有无效选项的内容都不会被标记为错误。相反，未知选项将传递给catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在），否则传递给 &lt;code&gt;@ARGV&lt;/code&gt; 。这样就可以编写仅处理部分用户提供的命令行参数的包装器脚本，并将其余选项传递给其他程序。</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">通过EXPR,它返回一些额外的信息,调试器用来打印堆栈跟踪。EXPR的值表示在当前帧之前要返回多少个调用帧。</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">在Mac OS X 10.4 &quot;Tiger &quot;及更新版本中,非预绑定库几乎没有性能上的损失。较早的版本会比静态库或苹果的预绑定动态库的加载时间更长。</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">如果使用NTFS(而且没有CYGWIN=nontsec),即使perl是建立在FAT上的,也应该没有问题。</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">通过OO风格,你可以任意的打破消息。这意味着我们不再局限于在内存中拥有整个消息的空间,即我们可以处理任何大小的消息。</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">在Perl 5.004中,你也可以使用TIEHANDLE接口来访问压缩文件,就像访问普通文件一样。</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">在Perl 5.10及以后的版本中,智能匹配运算符可以用最少的工作量给你答案。</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">有一个</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;， &lt;code&gt;charscript()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">使用&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; 返回</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">只要做一点额外的工作,你可以得到所有在角括号中的组,即使它们也在其他角括号中。每当你得到一个平衡的匹配,去掉它的外定界符(就是你刚刚匹配的那个,所以不要再匹配它了),然后把它添加到字符串队列中去处理。一直这样做,直到你没有得到匹配。</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">使用非 &lt;code&gt;DEBUGGING&lt;/code&gt; Perl，从 &lt;code&gt;128&lt;/code&gt; 开始的存储桶会有4字节的开销，因此8192长的存储桶可能需要多达8188字节的分配。</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">在签名中使用一个模糊参数,对传递参数的数量没有上限。稀疏数组参数可以是无名的,就像位置参数一样,在这种情况下,它的唯一作用是关闭原本适用的参数限制。</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">通过一种叫做copy-on-write的技术,可以将过载复制的成本降到最低,甚至完全避免。COW的测试实现确实显示出对重载数学的性能提升,但由于对其他所有操作的持续开销,引入了性能损失。所以Math::BigInt目前没有COW。</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">使用todo块，内部测试将失败。Test :: More将正常运行测试，但是会打印出特殊标志，表明它们是&amp;ldquo;待办事项&amp;rdquo;。&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;会将故障解释为正常。如果成功，它将报告为意外成功。然后，您知道必须做的事情已经完成，可以删除TODO标志。</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">对于以上所有的regex,如果regex与字符串中的任何地方相匹配,则认为是匹配的。要指定</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">对于上面所有的regexps,如果regexp在字符串中的任何地方匹配,就被认为是匹配的。然而,有时候,我们希望指定的是</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时，您应该特别小心记住以下情况：</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">使用其中任何一种,你都可以在调用前改变文件描述符。</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">在任何版本的Perl 5中,你都可以使用基本的OO接口。</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">通过捆绑，可以一次设置多个单字符选项。例如，如果 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 均为有效选项，</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">对于早期版本的Perl,你必须做更多的工作。如果你要对任意字符串值进行多次查询,最快的方法可能是对原始数组进行反转,并维护一个哈希,其键是第一个数组的值。</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">摘自Perl,以及Ronald J.Kimball、Dave Mitchell、Dominic Dunlop、Mark Jason Dominus、Stephen McCamant和David Landgren的贡献和建议。</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">有了hooks,就有了回溯到Storable引擎的能力。事实上,hooks是常规的Perl代码,而Storable在序列化和反序列化的时候很方便,为什么不用它来处理序列化字符串呢?</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">在Dean Roehrich、Malcolm Beattie、Andreas Koenig、Paul Hudson、Ilya Zakharevich、Paul Marquess、Neil Bowers、Matthew Green、Tim Bunce、Spider Boardman、Ulrich Pfeifer、Stephen McCamant和Gurusamy Sarathy的帮助和建议下。</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">使用方法2和3，Perl从头开始解析输入文件，除非您指定了&lt;b&gt;-x&lt;/b&gt;开关，在这种情况下，它将扫描以 &lt;code&gt;#!&lt;/code&gt; 开头的第一行！并包含&amp;ldquo; perl&amp;rdquo;一词，然后从此处开始。这对于运行嵌入较大消息中的程序很有用。 （在这种情况下，您将使用 &lt;code&gt;__END__&lt;/code&gt; 令牌指示程序的结束。）</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">通过使用mod_perl和Apache :: Registry模块（随mod_perl分发），httpd将与嵌入式Perl解释器一起运行，该解释器预编译您的脚本，然后在相同的地址空间内执行它而不会分叉。Apache扩展还使Perl可以访问内部服务器API，因此用Perl编写的模块几乎可以执行用C编写的模块可以执行的任何操作。有关mod_perl的更多信息，请参见&lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">在共享图书馆方面得到了Marc Sabatella的大力协助。</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">在负偏移的情况下,当目标字符串被修改时,它会记住它从字符串末端开始的位置。</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">在没有MASK参数的情况下,它返回当前隔层的操作者掩码。</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">没有参数，访问器将返回对元素整个数组的引用（无论元素是否指定为 &lt;code&gt;'@'&lt;/code&gt; 或 &lt;code&gt;'*@'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">不带任何参数的访问器将返回对元素整个哈希的引用（无论元素是否指定为 &lt;code&gt;'%'&lt;/code&gt; 或 &lt;code&gt;'*%'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">不带参数（或使用 &lt;code&gt;threads::all&lt;/code&gt; ），并在列表上下文中，返回所有未连接，未分离的列表</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">对于旧版本的Perl，&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;模块提供了类似的功能。</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">有一个或两个自变量，第一个自变量是指定哈希值一个元素的键；第二个参数（如果存在）被分配给hash元素。如果元素类型为 &lt;code&gt;'%'&lt;/code&gt; ，则访问器返回哈希元素值。如果元素类型为 &lt;code&gt;'*%'&lt;/code&gt; ，则返回对哈希元素的引用。</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">有一个或两个参数，第一个参数是指定数组一个元素的索引；第二个参数（如果存在）将分配给数组元素。如果元素类型为 &lt;code&gt;'@'&lt;/code&gt; ，则访问器返回数组元素值。如果元素类型为 &lt;code&gt;'*@'&lt;/code&gt; ，则返回对数组元素的引用。</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">使用选项-exec,按执行顺序走树,否则按基本顺序走。</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">在超载的数学情况下,只有前两种变体会导致BigFloat。</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">关于字符匹配,还有几点你需要知道。首先,并不是所有的字符都可以在匹配中 &quot;原样 &quot;使用。有些字符,被称为</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">对于文件，将其设置为正确的权限位以使您可以访问文件。关于计算机程序，一个编写得很好的程序使某人有机会弄清楚它要做什么。</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">关于加载 &lt;code&gt;Exporter&lt;/code&gt; 和继承，还有一些使用模块的替代方法，例如 &lt;code&gt;base&lt;/code&gt; 和 &lt;code&gt;parent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">对于某些防火墙，活动模式不起作用，因为服务器无法连接到您的计算机（因为您位于防火墙后面），并且防火墙不会重新编写命令。在这种情况下，您应该将 &lt;code&gt;ftp_ext_passive&lt;/code&gt; 设置为</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">通过源码过滤器,你可以将脚本的文本压缩存储,然后使用源码过滤器为Perl的解析器解压。</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">在支持 &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; 的情况下，可以避免这种情况-除非从以下一个DLL启动</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">通过这个技巧,MakeMaker将只读取第一行,从而读取下划线,而perl解释器将评估$VERSION,并将字符串转换成一个数字。之后的操作如果把$VERSION当作数字来处理,就不会引起关于$VERSION不是数字的警告。</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">对于 &quot;tcp &quot;协议,ping()方法会尝试建立与远程主机回音端口的连接。如果连接成功建立,则认为远程主机是可到达的。实际上没有数据被呼应。这个协议不需要任何特殊的权限,但比 &quot;udp &quot;和 &quot;icmp &quot;协议的开销大。</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，您可以使用 &lt;code&gt;:locale&lt;/code&gt; 层</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 运算符，匹配的变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等可立即用于替换表达式中。使用global修饰符， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 将搜索并替换字符串中所有出现的正则表达式：</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 编译指示，您可以控制内置 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 函数的行为。</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">使用 &lt;code&gt;IN&lt;/code&gt; 子编译，可以声明输入流的默认层，而使用 &lt;code&gt;OUT&lt;/code&gt; 子编译，可以声明输出流的默认层。使用 &lt;code&gt;IO&lt;/code&gt; 子实用程序，您可以同时控制输入和输出流。</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">将 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 逻辑名称定义为&amp;ldquo; ENABLE&amp;rdquo;，设置 &lt;code&gt;$?&lt;/code&gt; 将导致将新值编码为 &lt;code&gt;$^E&lt;/code&gt; 以便预期_POSIX_EXIT行为的C程序可以自动恢复原始的父出口或子出口状态值0至255。如果父出口值和子出口值都不为零，则将假定这实际上是要传递的VMS本机状态值。特殊值0xFFFF几乎是NOOP，因为它将导致C库中的当前本机VMS状态变为当前本机Perl VMS状态，并以这种方式进行处理，因为它不是有效的本机VMS状态值。建议仅使用正常Unix父或子状态编号范围内的值（0到255）。</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">如果用C式运算符,本来是这样写的。</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">使用FCGI模块（来自CPAN）和mod_fastcgi模块（可从&lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/获得&lt;/a&gt;），每个Perl程序都将成为永久的CGI守护进程。</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">在MASK参数存在的情况下,它为隔间设置操作者掩码(相当于调用deny_only方法)。</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">在设置了_POSIX_EXIT宏后,Unix的退出值为0,表示为VMS的本机状态为1,从2到255的Unix值用公式编码。</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">通过check_sigs参数,你可以开启和关闭签名检查。目前默认的是关闭,因为整个工具链的功能还没有被一些人认为是成熟的。CPAN.pm的作者建议在大多数情况下将其设置为true,只有当它变得很烦人时才将其关闭。</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">完成示例4后，我们现在有了一种简单的方法来模拟一些现实世界的库，这些库的接口可能不是世界上最干净的。现在，我们将继续讨论传递给&lt;b&gt;xsubpp&lt;/b&gt;编译器的参数。</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">随着 &lt;code&gt;IO::Compress&lt;/code&gt; 和 &lt;code&gt;IO::Uncompress&lt;/code&gt; 模块的创建，没有为 &lt;code&gt;Compress::Zlib&lt;/code&gt; 计划新功能-新模块完成了 &lt;code&gt;Compress::Zlib&lt;/code&gt; 工作，然后执行了一些工作。在 &lt;code&gt;Compress::Zlib&lt;/code&gt; 进行的开发将仅限于错误修复。</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">默认设置下,大小限制为128MB。而-1则会取消这个限制。如果 &quot;make test &quot;失败,请如上所述修改你的/etc/security/limits。</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">在上面的示例中，您知道要查找 &lt;code&gt;Perl_pp_add&lt;/code&gt; ，但是如果到处都多次调用它，或者您不知道要查找的操作是什么呢？</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在32位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项可以得到一个在64位模式下通过所有make测试的Perl版本。</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以通过64位模式下的所有make测试。</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">使用下面的选项,你可以得到一个线程化的Perl版本,它可以在线程化的32位模式下通过所有的make测试,这是AIX的Perl构建的默认配置。</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">随着词性警告的引入,强制警告现在变成了。</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">引入了</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">随着锁的释放,进程 &quot;B &quot;现在可以继续。它还更新了数据库,不幸的是它也修改了最初缓冲区中的数据。一旦这些数据被刷新到磁盘上,它将覆盖进程 &quot;A &quot;对数据库所做的一些/全部修改。</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">随着5.003_01版本的发布,当编译不同版本的Perl时,动态加载的库应该被重建。特别是,DLLs(包括</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">在存在此关键字的情况下，&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;将&lt;/a&gt;创建RETVAL变量，并在对该子例程的生成的调用中将其分配给该变量，但是该变量的值将不会在自动生成的代码中使用。</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">使用这个选项,每条语句(从nextstate OP开始)的渲染将在生成它的第1行源代码之前。例如</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">使用这种语法，&amp;ldquo; C &amp;lt;&amp;lt;&amp;lt;&amp;rdquo;之后和&amp;ldquo; &amp;gt;&amp;gt;&amp;gt;&amp;rdquo;（或任何字母）之前的空格字符是</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">有了这个,就需要 &quot;somepackage&quot;,然后检查储藏室,每个功能都会呈现。</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">这样，如果 &lt;code&gt;charinrange()&lt;/code&gt; 的输入代码点映射到 &lt;code&gt;$default&lt;/code&gt; 它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。您可以通过省略 &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 一条语句并在循环后添加一行以处理反转映射的最后一个元素来避免这种情况。</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">对于线程,人们必须小心翼翼地确保它们都有机会运行完成,假设这是你想要的。</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">使用待办事项测试，最好让测试实际运行。这样，您就会知道它们何时开始通过。有时这是不可能的。测试失败通常会导致整个程序死机或挂起，即使在使用并使用 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 中也是如此。在这些极端情况下，您别无选择，只能完全跳过损坏的测试。</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">在 &lt;code&gt;(?[ ])&lt;/code&gt; ，不允许文字字符，除非它们在一对方括号内，例如</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">在Perl中,你可以直接使用这个。</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">在 USS 中,你的 /etc/profile 或 $HOME/.profile 可能会限制你的 ulimit 设置。检查以下命令是否返回合理的值。</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">在Pod块中，有&lt;b&gt;Pod段落&lt;/b&gt;。Pod段落由非空白文本行组成，并由一个或多个空白行分隔。</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">在一个角色类内。</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">在一个模式中,你可以用括号指定子模式供以后参考,你也可以回溯至</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在子例程中，数组 &lt;code&gt;@_&lt;/code&gt; 包含传递给该子例程的参数。在子例程中，@ &lt;code&gt;@_&lt;/code&gt; 是数组运算符 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 的默认数组。</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">在搜索模式（也进行双引号替换）中，存在一个模糊的歧义： &lt;code&gt;/$foo[bar]/&lt;/code&gt; 被解释为 &lt;code&gt;/${foo}[bar]/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是正则表达式）还是 &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （其中 &lt;code&gt;[bar]&lt;/code&gt; 是数组@foo的下标）？如果@foo不存在，则显然是字符类。如果@foo存在，Perl会对 &lt;code&gt;[bar]&lt;/code&gt; 做出很好的猜测，并且几乎总是正确的。如果确实猜错了，或者只是个偏执狂，则可以如上所述使用花括号强行进行正确的解释。</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">在要在固定长度的文本字段中显示的字符串中，每个控制字符都用空格代替。（但是，请记住使用 &lt;code&gt;\r&lt;/code&gt; 填充模式时\ r的特殊含义。）这样做是为了避免某些输出媒体上的控制字符&amp;ldquo;消失&amp;rdquo;时出现未对齐的情况。</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">在该基本表格中,添加需要插入、更改或删除行的部分。</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">在该模块中，创建一个 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程中，调用 &lt;code&gt;filter_add&lt;/code&gt; ，将其传递给子例程引用。</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">在备选编号组内,每个备选方案的组号从同一位置开始。在该组之后,以高于所有替代品所达到的最大值的一个数字继续编号。</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">在传递给 &lt;code&gt;FILTER&lt;/code&gt; 的匿名子例程或块中，处理$ _的内容以所需的方式更改源代码。</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">在使用范围内的&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;功能'unicode_strings'&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">在&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;使用区域设置'not_characters'&lt;/a&gt;或&lt;a href=&quot;perllocale&quot;&gt;使用区域设置&lt;/a&gt;的范围内，当前区域设置为UTF-8区域设置。</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 的&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;范围内</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内，无论字符串是否编码为UTF-8，都引用所有非ASCII Latin1代码点。如上所述，语言环境不会影响ASCII范围字符的引用。这可以防止出现诸如 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 字符的语言环境。被认为是文字字符。</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">在子例程引用中， &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用模块的源文件中的源代码数据，调用 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 来对$ _进行&amp;ldquo; prime&amp;rdquo; 。检查返回的状态值以查看是否实际读入任何源代码。</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">在while循环中，我们调用accept（）并检查其是否返回假值。这通常表示需要报告系统错误。但是，在Perl 5.8.0中引入了安全信号（请参阅上面的&lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;延迟信号（安全信号）&lt;/a&gt;），这意味着当进程接收到信号时，accept（）也可能会中断。这通常在派生子流程之一退出并用CHLD信号通知父流程时发生。</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">如果没有Readline支持,当使用方向键和/或退格键时,你可能会看到符号&quot;^[[A&quot;,&quot;^[[C&quot;,&quot;^[[B&quot;,&quot;^[[D&quot;&quot;,&quot;^H&quot;,...。</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">在没有额外配置的情况下,GetOptions()将忽略选项名称的大小写,并允许选项被缩写为唯一性。</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，一旦确定了列表类型，就检索一个用于简化单个项目字符串的正则表达式。使用方法：例如转换为HTML时，人们可能会作为剥离以有序列表中的前导号码 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; 已打印号码本身。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-rx&lt;/b&gt;或使用标量参数调用&lt;b&gt;rx（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关列表标记的信息，该标记可以是任何标量。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-tag&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;tag（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索有关持有此列表的父级的信息，以任意标量表示。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-parent&lt;/b&gt;或使用标量参数调用&lt;b&gt;parent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">在没有参数的情况下,检索列表中的项目数组。项目可以用任何标量表示。如果有参数,则推送到项目列表中。</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表所在的文件名。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-file&lt;/b&gt;或使用标量参数调用&lt;b&gt;file（）&lt;/b&gt;方法来设置此名称。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索 &lt;code&gt;=over n&lt;/code&gt; 中指定的列表的缩进级别。必须在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-indent&lt;/b&gt;或通过使用标量参数调用&lt;b&gt;indent（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表开始的行号。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-start&lt;/b&gt;或使用标量参数调用&lt;b&gt;start（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">不带参数的情况下，检索列表类型，当考虑HTML方式时，它可以是任意值，例如 &lt;code&gt;OL&lt;/code&gt; ， &lt;code&gt;UL&lt;/code&gt; ，...。必须通过在&lt;b&gt;new（）&lt;/b&gt;方法中指定&lt;b&gt;-type&lt;/b&gt;或使用标量参数调用&lt;b&gt;type（）&lt;/b&gt;方法来进行设置。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">在没有参数的情况下,libnetcfg会显示当前配置。</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">没有autodie（并且假设BAREWORD是打开的文件句柄/目录句柄），这是对chdir的有效调用。但是在autodie下， &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 的行为将类似于原型&amp;ldquo;; $&amp;rdquo;，因此BAREWORD将是语法错误（在&amp;ldquo; use strict&amp;rdquo;下。如果没有strict，它将被解释为文件名）。</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">在没有binmode的情况下,这种情况会发生,但如果没有binmode,print()会失败,而不是write()。</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">如果不编译一个特殊的Perl,就无法得到Perl 5.18.0之前的任何版本的完全相同的行为。最接近的方法是将PERL_PERTURB_KEYS设置为0,并将PERL_HASH_SEED设置为一个已知值。出于上述安全考虑,我们不建议在生产中使用这些设置。</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">如果不按地址发信,不看另一端是否有人接听,你就不能完全回答部分</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">如果没有原作者提供的测试,那么将来修改 perl 的人怎么能确定他们没有无意中破坏了补丁所实现的行为?而没有测试,补丁的作者又怎么能确信他/她在补丁中的辛勤工作不会被未来的人不小心丢弃呢?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">如果没有&quot;=head1 &quot;前的那行空行,很多译者就不会把&quot;=head1 &quot;识别为Pod块的起始。</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">如果没有 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 声明，这个代码将不会下编译&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;编译。</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">如果没有#前的\\,我们就会有一个Makefile注释的开头,宏的定义就会不正确。</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">如果没有所有至关重要的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明，那么将UTF-8放在文字和标识符中将无法正常工作。如果您使用上面刚刚给出的标准前导，则已经发生了。如果这样做，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">如果没有括号，Perl会寻找一个$ whospeak，一个 &lt;code&gt;$who::0&lt;/code&gt; 和一个 &lt;code&gt;$who's&lt;/code&gt; 变量。最后两个是（可能是）不存在的软件包 &lt;code&gt;who&lt;/code&gt; 中的$ 0和$ s变量。</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">如果没有文件句柄,就无法直接从C回调映射到Perl子程序。</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">如果没有引号,Perl会在编译时将大数转换为浮点常数,然后将结果交给BigInt,结果是一个截断的结果或NaN。</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">如果没有这个参数,如果按字节语义操作的字符串和带有Unicode字符数据的字符串被连接起来,新的字符串将通过解码字节字符串来创建。</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">字符</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">工作团队</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">多次绕过DCL的255个字符限制,并在一些情况下使用VMS风格的命令行引号。</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">为泵金工作,为Perl程序员工作,为模块作者工作,...Perl应该是很简单的。</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">工作代码总是比天马行空的想法更受欢迎。一个添加功能的补丁比一个随机的功能请求有更大的机会被加入到语言中,不管这个请求有多么激烈的争论。这与 &quot;它是否有用?&quot;有关,因为有人花时间打补丁的事实表明了对该功能的强烈渴望。</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">与AVs一起工作</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">与HVs一起工作</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">使用Net::FTP</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">与SVs一起工作</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">目前只适用于整数。</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">与 &lt;code&gt;like()&lt;/code&gt; 完全一样，仅检查$ got &lt;b&gt;是否&lt;/b&gt;与给定模式&lt;b&gt;不&lt;/b&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">就像&lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt;一样工作，但是返回的值被本地化为标准格林威治时区。</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">就像&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;的 &lt;code&gt;cmp_ok()&lt;/code&gt; 一样工作。</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">和index()的工作原理一样,只不过它返回的是index()的位置。</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_catpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvf&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。不处理&amp;ldquo;定型&amp;rdquo;魔法。参见 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">像 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 一样工作，但是将文本复制到SV中，而不是附加文本。</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">万维网、HTML、HTTP、CGI、MIME。</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">更糟糕的是,如果你的语言,比如中文或日文,有几百个或几千个字符,那么你真的无法将它们装进仅仅256个字符中,所以他们不得不完全忘掉ASCII,建立自己的系统,用数字对来指代一个字符。</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">将打印&amp;ldquo; 1&amp;rdquo;，因为 &lt;code&gt;$foo&lt;/code&gt; 持有对</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">会像这样运行bin/foobar.PL。</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">围绕CPAN.pm的封装器,无需使用任何XS模块。</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">围绕配置.pm的封装器</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">用于在作用域结束时调用子类的封装类。</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">在处理程序例程中包装所有die调用对于查看&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;如何以及从何处被调用有更多信息，这很有用：</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">包装用括号允许输入文件水珠的通配符部分由第二个参数被引用 &lt;code&gt;globmap&lt;/code&gt; ， &lt;code&gt;#1.tgz&lt;/code&gt; ，所述</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">通过用在CODE引用上调用&lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt;的结果替换每个参数，包装在参数中找到的所有CODE引用。递归检查参数中的所有ARRAY或HASH引用。</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">用一些其他操作包装操作树，以便在运行时创建动态范围。原始操作在新的动态范围内运行，然后，只要它们正常退出，该范围将被取消。用于创建和展开动态范围的其他操作通常将是一个 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; 对，但是如果操作足够简单以至于不需要完整的动态范围结构，则可以使用 &lt;code&gt;scope&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">将 &lt;code&gt;BUFFER&lt;/code&gt; 中的 &lt;code&gt;SIZE&lt;/code&gt; 字节数据写入服务器，同时还要执行任何&amp;lt;CRLF&amp;gt;转换。 &lt;code&gt;TIMEOUT&lt;/code&gt; 是可选的，如果未指定，将使用命令连接中的超时值。</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">将 &lt;code&gt;SIZE&lt;/code&gt; 字节写入 &lt;code&gt;POS&lt;/code&gt; 的共享内存段。如果成功，则返回true；如果有错误，则返回false。参见&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">将MYMETA信息写入MYMETA.json和MYMETA.yml中。</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">编写RFC 1950文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">编写RFC 1951文件/缓冲器</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">编写RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">编写YAML语言数据</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">写一个formatter作为Pod::Simple子类。</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">通过git写访问</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">写入一个条目,其名称相当于提供给磁盘的文件名。可选择使用第二个参数,即条目将被写入的完整本地路径(包括文件名)。</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">写入bzip2文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">用POD编写文档</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">将名称等同于 &lt;code&gt;@filenames&lt;/code&gt; 中任何名称的文件写入磁盘，并根据需要创建子目录。在VMS下这可能无法很好地工作。在MacPerl下，文件的修改时间将转换为MacOS的零时间，并将对路径进行适当的转换。但是，不检查路径的每个元素的长度以查看其是否比MacOS当前允许的长度（32个字符）长。</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">为动态扩展写链接器选项文件</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">编写 perlmain.c 的 C 代码。</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">将内存中的档案写入磁盘。第一个参数可以是文件名,也可以是一个已经打开的文件柄的引用(GLOB引用)。</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">将状态写入文件。</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">写入文件。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">写到modules@perl.org,说明你做了什么来联系当前的维护者。PAUSE管理员也会尝试联系维护者。</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">写压缩文件/缓冲区</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">对文件中的数据进行只写访问。</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()现在会对其参数进行一些基本的理智检查,以防止错别字和格式化错误的值。这意味着一些过去可以正常工作的东西现在会发出警告,并可能产生内部错误。</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [，...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">将STRING中的SIZE字节写入从位置POS开始的ADDR的内存段。如果STRING太长,只使用SIZE字节;如果STRING太短,则写入空值来填充SIZE字节。如果成功则返回true,如果出现错误则返回false。</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">写入C代码文件和XS代码文件，分别在模块的XS代码的C和XS部分中分别 &lt;code&gt;INCLUDE&lt;/code&gt; &lt;code&gt;#include&lt;/code&gt; 和INCLUDE。您可能希望在 &lt;code&gt;Makefile.PL&lt;/code&gt; 中执行此操作，以便可以轻松编辑常量列表，而无需触摸模块的其余部分。支持的属性是</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">使用与该文件关联的格式，将格式化的记录（可能是多行）写入指定的FILEHANDLE。默认情况下，文件格式是与文件句柄名称相同的格式，但是可以通过将格式名称分配给 &lt;code&gt;$~&lt;/code&gt; 变量来显式设置当前输出通道的格式（请参见 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">将当前目录下的所有文件写到你的</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">写一个空的FORCE:目标。</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">允许写,即以 &quot;w &quot;或 &quot;r+&quot;或 &quot;a &quot;等方式打开。</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">将 &lt;code&gt;$buffer&lt;/code&gt; 的内容写入压缩文件。返回实际写入的字节数，如果出错则返回0。</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">将模块的META.yml(YAML编码的元数据)和META.json(JSON编码的元数据)文件写入distdir中。其格式尽可能的遵循Module::Build的格式。</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">用 &quot;cpansign -s &quot;写入文件SIGNATURE。</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">写入</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">书写配件</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">编写结构体</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">实际上，在EBCDIC平台上写Perl与在&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;上写Perl并没有什么不同，但是具有不同的基础数字，我们将很快看到。您将必须了解有关这些&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;平台的一些信息，因为该文档有偏见，并且会经常使用不适用于EBCDIC的示例编号。也很少有为EBCDIC编写的CPAN模块，它们不能在ASCII上工作；取而代之的是，绝大多数CPAN模块都是为ASCII编写的，有些可能恰好在EBCDIC上工作，而有些则被设计为可在这两种模块上移植。</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">编写插件</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">编写自己的调试器</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">编写过滤器</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">用MakeMaker编写一个模块</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">将源过滤器编写为单独的可执行文件可以很好地工作，但是会导致性能下降。例如，如果您执行上面的小示例，将创建一个单独的子进程来运行Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 命令。过滤器的每次使用都需要其自己的子过程。如果在您的系统上创建子流程非常昂贵，则可能要考虑使用其他选项之一来创建源过滤器。</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">在你的程序中写上反标,会向你的代码读者发出一个明确的信息,即你想收集命令的输出。为什么要发送一个不真实的明确信息呢?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">编写好的测试脚本</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">编写子程序</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">编写子程序很容易。</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">编写补丁</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">建议先写短选项,因为它更容易阅读。反正长选项足够长,可以吸引眼球,否则短选项可能会在视觉噪音中消失。</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">编写类型图条目</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">错误：可存储引擎为您创建了一个空引擎。如果您知道Eiffel，则可以将 &lt;code&gt;STORABLE_thaw&lt;/code&gt; 作为备用创建例程。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPG的可操作性往往意味着存在着一个 &quot;XPG&quot;。</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH args AND set RETVAL AND assign return value to array(将返回值分配给数组)。</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XS版本</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Bacon添加的XS代码&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XS代码通常可以在任何平台上工作,但依赖的库、头文件等可能不是现成的或可移植的,或者XS代码本身可能是平台特定的,就像Perl代码一样。如果库和头文件是可移植的,那么确保XS代码也是可移植的通常是合理的。</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnisch编写的用于从 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; 借用的使用本机C函数的XS代码，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS代码可以完全访问系统调用,包括C库函数。因此,它有能力干扰Perl核心或其他模块所设置的东西,如信号处理程序或文件句柄。它可能会扰乱内存,或者任何有害的东西。不要。</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XS代码如果期望FILE *参数,可能最好使用 &quot;tyemap&quot;。标准的typemap将被调整以理解这方面的任何变化。</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XS代码对模块的版本号非常敏感,如果你的Perl模块的版本号不匹配,XS代码就会抱怨。如果你改变了你的模块版本号而没有重新运行Makefile.PL,旧的版本号将保留在Makefile中,导致XS代码被编译成错误的版本号。</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XS是一种接口描述文件格式,用于在Perl和C代码(或C库)之间创建一个扩展接口,以便与Perl一起使用。XS接口与库相结合,创建一个新的库,然后可以动态加载或静态链接到perl中。XS接口描述是用XS语言编写的,是Perl扩展接口的核心组件。</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 以外的所有类别的XS模块都获得基础语言环境，因此，它们调用的任何C库函数都将使用该基础语言环境。有关更多讨论，请参见&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxs中的CAVEATS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS类型的模块确实需要重新链接perl二进制文件,因为XS模块的一部分是用 &quot;C &quot;写的,必须和要执行的perl二进制文件链接在一起。之所以需要这样做,是因为DJGPP下的perl是以 &quot;静态链接 &quot;选项构建的,因为DJGPP环境中缺乏 &quot;动态链接&quot;。</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-动态加载C库到Perl代码中。</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUBs和参数栈</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">还允许XSUB避免将Perl函数参数自动转换为C函数参数。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。甚至在自动转换可以进行的情况下，有些人还是喜欢通过检查 &lt;code&gt;ST(i)&lt;/code&gt; 来进行手动转换，因为这使XSUB调用的逻辑更加清晰。与&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;将脂肪从&lt;/a&gt; XSUB中移除相比，XBOX的&amp;ldquo; Perl胶&amp;rdquo;和&amp;ldquo;主力&amp;rdquo;部分的完全分离具有类似的权衡。</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">还允许XSUB返回列表，而不仅仅是标量。这必须通过以微妙的不同方式操纵堆栈值ST（0），ST（1）等来完成。有关详细信息，请参见&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">通过在参数列表中指定省略号 &lt;code&gt;(...)&lt;/code&gt; ，XSUB可以具有可变长度的参数列表。省略号的这种用法类似于ANSI C中的用法。程序员可以通过检查&lt;b&gt;xsubpp&lt;/b&gt;编译器为所有&lt;b&gt;XSUB&lt;/b&gt;提供的 &lt;code&gt;items&lt;/code&gt; 变量来确定传递给XSUB的参数数量。通过使用这种机制，可以创建一个XSUB，它接受未知长度的参数列表。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUB没有CvPADLIST。dXSTARG从PL_curpad中获取值，但这实际上是调用者板（每个entersub都分配了其插槽）。如果CV是XSUB（由 &lt;code&gt;CvISXSUB()&lt;/code&gt; 确定），则不要获取或设置CvPADLIST ，CvPADLIST插槽在XSUB中被用于其他内部用途。</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUB使用宏&lt;b&gt;ST（x）&lt;/b&gt;引用其堆栈参数，其中</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D行用于在编译时设置xs版本。</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:.xs文件中的版本。默认值为$(VERSION)</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:哪个宏代表XS版本。</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPM如果把arg做成PADOFFSET会更有意义 void SAVEPADSV(PADOFFSET po)</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX:需要更多的文件。</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAML结果标记。</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">年值解释</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">大于999的年份被解释为实际年份,而不是从1900年开始的偏移。因此,1964年是马丁-路德-金获得诺贝尔奖的年份,而不是3864年。</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0..99范围内的年份被解释为滚动的 &quot;本世纪 &quot;中的年份的简写,定义为当年两边的50年。因此,今天,在1999年,0指的是2000年,45指的是2045年,但55指的是1955年。20年后,55反而会指2055年。这很混乱,但符合目前人们对两位数日期的思考方式。只要有可能,就用绝对的四位数年份来代替。</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">在100...999范围内的年份被解释为从1900年开始的偏移,因此,112表示2012年。这一规则也适用于小于零的年份(但见下文关于日期范围的说明)。</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">是的，请参阅先前的答案。由于 &lt;code&gt;Compress::Zlib&lt;/code&gt; 以及 &lt;code&gt;IO::Zlib&lt;/code&gt; 不支持在其文件句柄上进行 &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ，因此别无选择，只能将存档读入内存。如果要对归档执行内存中操作，则可以。</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">是的。它是纯Perl，所以它比 &lt;code&gt;/bin/tar&lt;/code&gt; 慢得多。但是，它非常易于移植。如果速度是一个问题，请考虑改用 &lt;code&gt;/bin/tar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">是的,它是</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">是的,这是一个很大的扩展。</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">是的，有很多:-)但是，更准确地说，在UNIX系统中，有一个名为 &lt;code&gt;file&lt;/code&gt; 的实用程序，该实用程序根据其内容（通常是前几个字节）识别数据文件。为此，某个文件称为</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">是的，您可以通过使用 &lt;code&gt;-T&lt;/code&gt; 选项或以 &lt;code&gt;perlthanks&lt;/code&gt; 的身份调用程序来执行此操作。谢谢你的笔记很好。它使人微笑。</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">是的你可以！如果您的源是UTF-8编码的，则可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma进行指示。</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">是的，您可能可以使用$ token-&amp;gt; isa（'Pod :: Simple :: PullParserEndToken'）之类的代码执行相同的操作，但这并不像仅使用$ token-&amp;gt; type甚至以下快捷方式那样漂亮：</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">是的,如果你正在建立一个具有任何交互性的网站(表单/用户/数据库),你会希望使用一个框架来使处理请求和响应更容易。</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">是的,Perl 的垃圾收集系统会处理好这个问题,所以一切都很正常。Perl的垃圾收集系统会处理这些问题,所以一切都很正常。</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">是。阅读&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;以获取更多信息。以下是一些示例。（这些假设标准的Unix Shell引用规则。）</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">又一个编译器编译器。一个解析器生成器,如果没有它,Perl可能就不存在了。参见文件</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">然而,另一种捕捉组号的技术(也是Perl 5.10中的技术)处理的是在一组备选方案中引用组的问题。考虑一个用于匹配一天中的时间、民用或军用风格的模式。</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">然而,另一个编写测试脚本的框架</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pm提供的另一个伪类是 &lt;code&gt;EVERY&lt;/code&gt; 。它的行为比 &lt;code&gt;NEXT&lt;/code&gt; 系列的行为简单得多。致电至：</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">另一种方法是分配给 &lt;code&gt;foreach&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">然而另一种方法是使用Devel::Peek模块。</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">您&lt;b&gt;不&lt;/b&gt;调用 &lt;code&gt;setlogsock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">如果您&lt;b&gt;必须&lt;/b&gt;匹配UTF-8和非UTF-8字符，则&lt;b&gt;必须&lt;/b&gt;使用上述功能将字符转换为UV。在这种情况下，您不能跳过UTF-8字符。如果这样做，将失去匹配高位非UTF-8字符的能力；例如，如果您的UTF-8字符串包含 &lt;code&gt;v196.172&lt;/code&gt; ，而您跳过了该字符，则您永远无法在非UTF-8字符串中匹配 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; 。所以不要那样做！</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">您&lt;b&gt;必须&lt;/b&gt;安装BFD（-lbfd）库，否则 &lt;code&gt;perl&lt;/code&gt; 将无法链接。BFD通常作为GNU binutils的一部分分发。</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">你可以说</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">您已经了解到，&lt;b&gt;方法&lt;/b&gt;是对对象进行操作的子例程。您可以将方法视为对象可以做的事情</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您还不能使用&lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt;或 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 中描述的任何循环控制运算符退出排序块或子例程。</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您还不能使用&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;或 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; 中描述的任何循环控制运算符退出排序块或子例程。</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">你也不必使用push()。如果你知道你想把它放在哪里,你可以直接进行赋值。</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">你也要注意上下文。你可以将一个数组赋值给一个标量来获取数组中的元素数量。不过这只对数组有效。</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">您还需要dmake。有关如何获取的信息，请参见上面的&amp;ldquo; &lt;a href=&quot;#Make&quot;&gt;制作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">允许您在数字之间的数字文字中使用下划线（下划线）以提高可读性（但不能连续使用多个下划线： &lt;code&gt;23__500&lt;/code&gt; 无效； &lt;code&gt;23_500&lt;/code&gt; 合法）。例如，您可以将二进制数字按三位（对于Unix样式的模式自变量，例如0b110_100_100）或四位（代表零字节，如0b1010_0110）或其他组。</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">除非指定了 &lt;code&gt;no_chdir&lt;/code&gt; ，否则在调用函数时，您将chdir（）设置为 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。请注意，更改目录实际上是根目录（</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">你使用的zlib副本比1.2.0版本更老,或者你希望你的应用程序代码能够在尽可能多的不同版本的zlib中运行。</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">我们鼓励您参与讨论,并为您的补丁进行宣传。有时你的补丁可能会被淹没在洗牌中。如果一个月内没有任何行动,给 p5p 发送一封提醒邮件是合适的。请记住,Perl 5 的开发者都是志愿者,要有礼貌。</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">鼓励您在可能的情况下在 &lt;code&gt;ok()&lt;/code&gt; 上使用 &lt;code&gt;is()&lt;/code&gt; 和 &lt;code&gt;isnt()&lt;/code&gt; ，但是不要试图使用它们来确定真假！</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">您可以保证 &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; 将表示与原始$ path相同的位置。</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">你不应该在数组被迭代的时候修改它们。出于速度和效率的原因,Perl 内部并不对迭代项进行完全的引用计算,因此在迭代过程中删除这样的项会导致 Perl 看到一个释放的值。</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">建议您更改您的代码集 &lt;code&gt;$/&lt;/code&gt; 以 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 明确，如果你想发出声音文件。在将来的Perl版本中，分配对的引用将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">如果您打算将其半永久性地存储在任何地方，则应对返回值上的 &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; 负责（否则，下一次缓存无效时，它可能会从您的下方删除）。</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">强烈鼓励你实现下面的方法,至少是encode()或decode()。</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">强烈建议您尽快将任何现有的线程代码迁移到新模型（即，使用 &lt;code&gt;threads&lt;/code&gt; 和 &lt;code&gt;threads::shared&lt;/code&gt; 模块）。</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">当然,你不允许以这种方式修改常量。如果一个参数实际上是字面意思,而你又想修改它,你会出现一个(可能是致命的)异常。例如,这样做是行不通的。</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">你已经可以 &quot;制作安装 &quot;了,但你应该先测试一下。</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">您可以（并且应该）阅读有关&lt;a href=&quot;perlref&quot;&gt;perlref中的&lt;/a&gt;引用的更多信息。简而言之，引用就像是知道它们所指向的指针。（对象也是一种参考，但是我们将不再需要它们（如果有的话）。）这意味着当您拥有某种看起来像是访问二维数组或二维数组的对象时， /或哈希，实际上发生的是，基本类型只是一维实体，其中包含对下一级的引用。只是你可以</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">您可以仅 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 集合中的一个元素。通常这是在动力学上完成的：</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">你可以用substr()访问一个字符串的第一个字符。例如,要获取第一个字符,从位置0开始,然后抓取长度为1的字符串。</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">实际上,你可以咬住任何一个l值,包括一个赋值。</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">实际上,你可以砍掉任何一个l值,包括一个赋值。</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">实际上,你可以在列表中的任何地方放置一个数组或哈希,但是列表中的第一个数组会吸收所有的值,而它之后的任何值都会变成未定义的。这在my()或local()中可能很有用。</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">您可以将自定义别名添加到标准（ &lt;code&gt;:full&lt;/code&gt; ）Unicode命名约定中。别名会覆盖所有标准定义，因此，如果您扭曲得不够充分，可以将 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">您可以通过分配给 &lt;code&gt;$.&lt;/code&gt; 来调整计数器。，但这实际上不会移动搜索指针。</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">您还可以通过更改 &lt;code&gt;Carp&lt;/code&gt; 名称空间中的某些全局变量来更改 &lt;code&gt;Carp&lt;/code&gt; 的输出和逻辑的工作方式。请参阅下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">您也可以使用引用参数调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，并且如果该引用陷阱包含在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中，则 &lt;code&gt;$@&lt;/code&gt; 包含该引用。这允许使用维护有关异常的任意状态的对象进行更精细的异常处理。这种方案有时比将 &lt;code&gt;$@&lt;/code&gt; 特定字符串值与正则表达式匹配更可取。因为 &lt;code&gt;$@&lt;/code&gt; 是全局变量，并且 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可以在对象实现中使用，所以要小心，分析错误对象不会替换全局变量中的引用。在进行任何操作之前，最简单的方法是创建引用的本地副本。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">您也可以使用引用参数调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，并且如果该引用陷阱包含在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中，则 &lt;code&gt;$@&lt;/code&gt; 包含该引用。这允许使用维护有关异常的任意状态的对象进行更精细的异常处理。这种方案有时比将 &lt;code&gt;$@&lt;/code&gt; 特定字符串值与正则表达式匹配更可取。因为 &lt;code&gt;$@&lt;/code&gt; 是全局变量，并且 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 可以在对象实现中使用，所以要小心，分析错误对象不会替换全局变量中的引用。在进行任何操作之前，最简单的方法是创建引用的本地副本。这是一个例子：</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">您还可以调用parse_lines（）来解析行数组，或者调用parse_string_document（）来解析内存中已经存在的文档。与parse_file（）一样，除非使用output_fh（）方法进行更改，否则parse_lines（）和parse_string_document（）默认将其输出发送到 &lt;code&gt;STDOUT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">你也可以这样连锁调用,这样可以先做一个副本,然后再乘以2。</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">您也可以通过 &lt;code&gt;set_suspects&lt;/code&gt; 方法更改内部可疑列表。</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">你也可以选择使用rsync来获取 bleadperl分支和所有维护分支的当前源代码树的副本。</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">你也可以在运行时使用内置例程vmsish::husthed()来控制'hushed'标志。在没有参数的情况下,它将返回 &quot;hushed &quot;状态。因为vmsish::hashed是内置的,所以你不需要 &quot;使用vmsish &quot;来调用它。</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">您还可以控制字符编码和实体。例如，如果您确定POD正确编码（使用 &lt;code&gt;=encoding&lt;/code&gt; 命令），则可以防止在分析之前将高位字符编码为HTML实体，并将输出字符集声明为UTF-8，如下所示：</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">您还可以通过PERL5SHELL控制perl用于运行system（）和backtick命令的shell。参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">你也可以用单个变量创建一个循环引用。</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">你也可以做</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">您还可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;模块执行相同的操作：</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">你也可以通过rad2rad()、deg2deg()和grad2grad()明确地进行封装。</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">您也可以使用 &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 序列直接在match运算符中执行此操作。该 &lt;code&gt;\Q&lt;/code&gt; 告诉Perl从哪里开始转义特殊字符，以及 &lt;code&gt;\E&lt;/code&gt; 告诉它在哪里停止（见&lt;a href=&quot;perlop&quot;&gt;perlop中&lt;/a&gt;有详细介绍）。</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">您也可以使用CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;模块对大多数系统执行此操作，该模块更易于使用，理论上更易于移植。</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">你也可以很容易的说除了一个类别外,其他类别都要用,比如说,通过任一。</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">你也可以直接在字符串中嵌入换行符,也就是说,换行符可以在与开头不同的行结束。这很好,但是如果你忘记了尾部的引号,在Perl找到包含引号字符的另一行之前是不会报告错误的,而这一行可能在脚本的更远处。字符串中的变量替换仅限于标量变量、数组、数组或哈希片。换句话说,以$或@开头的名称,后面跟着一个可选的括号内的表达式作为下标)。下面的代码段打印出 &quot;价格是100元&quot;。</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">你也可以显式地指定一个处理程序用于所有类型的引用,就像这样。</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">您还可以使用 &lt;code&gt;*2$v&lt;/code&gt; 类的方式显式指定用于连接字符串的参数编号；例如：</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">你也可以通过预先扩展一个即将变大的数组来获得一些微不足道的效率。你也可以通过赋值给一个数组末端的元素来扩展数组。你可以通过将空列表()赋值给一个数组,将其截断为零。以下是等价的。</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">你也可以通过宏来获取存储在SV中的字符串末端的指针。</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">您还可以通过减法来获得差异，该减法将返回&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;对象：</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">您还可以在Perl中的那几个实际上关心字符串和数字之间差异的操作上遇到一些细微问题，例如神奇的 &lt;code&gt;++&lt;/code&gt; 自动增量运算符或syscall（）函数。</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">您还可以使用 &lt;code&gt;.*&lt;/code&gt; 从下一个参数获取精度：</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">您还可以浏览每个元素，并跳过之前看到的元素。使用哈希来跟踪。循环第一次看到元素时，该元素在 &lt;code&gt;%Seen&lt;/code&gt; 中没有键。在 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 语句创建关键并立即使用它的价值，这是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此该循环不断的 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ，并增加该键的值。下次循环看到相同的元素时，其键存在于哈希中</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">您还可以从 &lt;code&gt;Fcntl&lt;/code&gt; 模块导入符号 &lt;code&gt;S_I*&lt;/code&gt; 常量：</target>
        </trans-unit>
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">您还可以通过将Perl代码直接放入 &lt;code&gt;@INC&lt;/code&gt; 来将挂钩插入文件包含系统。这些挂钩可以是子例程引用，数组引用或受祝福的对象。有关详细信息，请参见&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">您也可以通过将Perl代码直接放入@INC数组中,将钩子插入到导入设施中。钩子有三种形式:子程序引用、数组引用和祝福对象。</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">您还可以通过以下方式快速 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一个未定义的值：</target>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">你也可以在以下地方查找资料:</target>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">您也可以在自己的类中直接重写 &lt;code&gt;DOES&lt;/code&gt; 。如果重写此方法，则永远不要抛出异常。</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">您还可以通过 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 显式编码来即时更改它。这不完全是&amp;ldquo;二进制&amp;rdquo;模式，但是我们仍然使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">您还可以传递子例程引用，以便根据给定的测试脚本确定并返回要运行的正确程序。子例程引用应该将TAP :: Harness对象本身作为第一个参数，并将文件名作为第二个参数。它应该返回一个数组引用，其中包含要运行的命令并包括测试文件名。它也可以简单地返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在这种情况下，TAP :: Harness将退回到在Perl中执行测试脚本的位置：</target>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">你也可以在你的C程序中从文件中读取和执行Perl语句,通过将文件名放在</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">您也可以使用负数来相对地引用捕获组，以便 &lt;code&gt;\g-1&lt;/code&gt; 和 &lt;code&gt;\g{-1}&lt;/code&gt; 都引用紧接的捕获组，而 &lt;code&gt;\g-2&lt;/code&gt; 和 &lt;code&gt;\g{-2}&lt;/code&gt; 都引用请参考之前的小组。例如：</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">您还可以通过指定字符名称&lt;a href=&quot;charnames&quot;&gt;杂&lt;/a&gt;注来将名称限制为某个字母：</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">您还可以在该示例中看到，我们使用 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 来获取字符的值。逆函数 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 可用于将UV放入UTF-8：</target>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">你也可以向Github仓库发送拉取请求。</target>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">您也可以使用十六进制表示法指定分隔符：&lt;b&gt;-0x &lt;i&gt;HHH ...&lt;/i&gt;&lt;/b&gt;，其中 &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; 是有效的十六进制数字。与八进制格式不同，此格式可用于指定任何Unicode字符，甚至包括0xFF之后的字符。所以如果你</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">你也可以指定不使用某些东西。</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">您还可以按网络顺序存储数据，以便在多个平台之间轻松共享，或者在存储在已知可以远程连接的套接字上时轻松共享数据。调用的例程的初始前缀为 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">你也可以对一个列表进行下标,以从中获取单个元素。</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">你也可以测试一个类,以确保它有正确的祖先。</target>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">您也可以尝试默认情况下导出的 &lt;code&gt;guess_encoding&lt;/code&gt; 函数。它需要$ data进行检查，还可以通过选项获取可疑列表。可选的可疑列表是</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">你也可以试着把这个模块包含在一个单行本里,看看perl是否能找到它。</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">您还可以尝试使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，如&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中所述&lt;/a&gt;（尽管许多模块将为您做同样的事情）。</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">您也可以使用</target>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">您也可以将&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt;用于 &lt;code&gt;Moose&lt;/code&gt; 的语法。</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt;，它是Perl的交互式外壳，通常称为REPL-读取，评估，打印，循环。它提供了各种方便的功能。</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt;使用标量，该标量始终具有圆形数组的下一个元素：</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;来完成许多相同的事情。使用&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;的设置安装模块，然后在程序中使用该模块：</target>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">您还可以使用Perl附带的&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;，并提供一个返回对象的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">您也可以使用 &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; 访问给定文件句柄的行计数器，而不必担心上次访问哪个句柄。</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">您还可以使用 &lt;code&gt;cpan&lt;/code&gt; 的 &lt;code&gt;-a&lt;/code&gt; 开关来创建 &lt;code&gt;CPAN.pm&lt;/code&gt; 可以理解的自动捆绑文件，并可以用来重新安装每个模块：</target>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">您还可以使用 &lt;code&gt;while&lt;/code&gt; 在一个后置条件：</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">你也可以使用 Perl 的单行本来修改文件。下面将文件中的 'Fred' 改为 'Barney' 。</target>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">您也可以使用商业调试器,如Affrus(Mac OS X)、Activestate的Komodo(Windows和Mac OS X)或EPIC(大多数平台)。</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">您也可以使用双叉。您可以立即 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 第一个孩子，并且init守护进程将在退出后为您的孙子 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">你也可以使用列表切片只选择你需要的元素。</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">您还可以使用本地化 &lt;code&gt;@ARGV&lt;/code&gt; 消除 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">你也可以使用子程序引用作为方法。</target>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">你也可以有条件地使用某些库,比如Config,但如果没有,一定要优雅地跳过测试。</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">您也可以使用dmake来使用Visual C++进行构建;不过前提是,在您的环境中把OSRELEASE设置为 &quot;microsft&quot;(或者任何Visual C dmake配置所在的目录名),并编辑win32/config.vc,把 &quot;make=nmake &quot;改为 &quot;make=dmake&quot;。只有当你想使用dmake作为你使用MakeMaker构建扩展的默认make时,后一步才是必不可少的。</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">您也可以使用文件描述符重定向使STDERR成为STDOUT的副本。</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">您还可以在第一个花括号和属性名称之间插入一个插入符号（ &lt;code&gt;^&lt;/code&gt; ），从而在 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 使用否定符： &lt;code&gt;\p{^Tamil}&lt;/code&gt; 等于 &lt;code&gt;\P{Tamil}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">你也可以使用substr()作为l值。</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">你也可以使用 -Duse64bitint 标志来配置。虽然用这个标志编译Perl和用-Duse64bitall标志编译Perl有一些细微的差别,但从Perl用户的角度来看,这些差别应该是不明显的。当在 pa-risc 架构上使用 64bit gcc 配置 -Duse64bitint 时,-Duse64bitint 会被默默地提升为 -Duse64bitall。</target>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">您还可以通过其 &lt;code&gt;Today_and_Now&lt;/code&gt; 函数使用&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您也可以使用&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块，该模块使您可以通过绑定数组访问行。您可以使用常规数组操作来修改文件，包括设置最后一个索引和使用 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">您还可以使用 &lt;code&gt;**&lt;/code&gt; 运算符，请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">您也可以在标量上下文中使用 &lt;code&gt;\G&lt;/code&gt; 锚。您仍然需要 &lt;code&gt;g&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3中&lt;/a&gt;的 &lt;code&gt;open3()&lt;/code&gt; 函数。本杰明&amp;middot;戈德堡（Benjamin Goldberg）提供了一些示例代码：</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">你也可以使用 Unix 命令 mknod(1),或者在某些系统中使用 mkfifo(1)。不过这些命令可能不在你的正常路径中。</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">你也可以用\b的补语,\B,来指定不应该有一个词的边界。</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">您也可以使用以下功能从Storable图像中提取文件头信息。</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">你也可以把它写成一个单独的替换,虽然事实证明组合语句比单独的语句慢。不过这对你来说可能并不重要。</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">你也可以。</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">你可以改变全局变量$ PARAMS ::检查:: NO_DUPLICATES控制是否 &lt;code&gt;store&lt;/code&gt; &amp;ldquo;d键仍然会出现在你的结果集。请参阅下面的&amp;ldquo; &lt;a href=&quot;#Global-Variables&quot;&gt;全局变量&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">您可以随时通过打印八进制符号来检查您正在使用的值,以确保它与您认为应该的值相匹配。以八进制和十进制格式打印。</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">您始终可以使用大括号将数组引用替换为数组名称。例如， &lt;code&gt;@{$aref}&lt;/code&gt; 而不是 &lt;code&gt;@array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">您可以安排要运行的回调之前 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 做它的行为，通过设置 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩。关联的处理程序将使用错误文本进行调用，并且如果认为合适，可以通过再次调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 来更改错误消息。有关设置 &lt;code&gt;%SIG&lt;/code&gt; 条目的详细信息，请参见&lt;a href=&quot;../perlvar#%25SIG&quot;&gt;perlvar&lt;/a&gt;中的％SIG；有关某些示例，请参见&lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt;。尽管此功能仅在程序退出前立即运行，但当前并非如此： &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩子即使在eval（）ed的块/字符串中也被调用！如果在这种情况下希望钩子什么都不做，请放</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">您可以安排要运行的回调之前 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 做它的行为，通过设置 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩。关联的处理程序将使用错误文本进行调用，并且如果认为合适，可以通过再次调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 来更改错误消息。有关设置 &lt;code&gt;%SIG&lt;/code&gt; 条目的详细信息，请参见&lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvar&lt;/a&gt;中的％SIG；有关某些示例，请参见&lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt;。尽管此功能仅在程序退出前立即运行，但当前并非如此： &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩子即使在eval（）ed的块/字符串中也被调用！如果在这种情况下希望钩子什么都不做，请放</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">您可以要求 &lt;code&gt;prove&lt;/code&gt; 者记住先前测试运行的状态，并根据保存的状态选择和/或订购要运行的测试。</target>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">您可以通过创建&amp;ldquo;弱引用&amp;rdquo;来中断循环引用。弱引用不会增加变量的引用计数，这意味着对象可能超出范围并被破坏。您可以使用&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块导出的 &lt;code&gt;weaken&lt;/code&gt; 功能来弱化引用。</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">如果给定参数，则可以用 &lt;code&gt;constant&lt;/code&gt; 以外的方式调用perl visible子例程。</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">您可以使用以下方法获取其数字和字符串内容。</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">你可以通过3个标准对这些CES进行分类:每个字符的大小,endianness和Byte Order Mark。</target>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">你可以改变一个数组元素,但你不能改变一个列表元素。</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setgid()&lt;/code&gt; （仅使用一个数字参数）同时更改有效gid和实际gid 。更改 &lt;code&gt;$)&lt;/code&gt; 需要检查 &lt;code&gt;$!&lt;/code&gt; 在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改有效uid和实际uid 。对 &lt;code&gt;$&amp;gt;&lt;/code&gt; 的更改要求对$进行检查 &lt;code&gt;$!&lt;/code&gt; 在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setgid()&lt;/code&gt; 同时更改实际gid和有效gid 。更改 &lt;code&gt;$(&lt;/code&gt; 要求对 &lt;code&gt;$!&lt;/code&gt; 进行检查，以在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">您可以从</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">你可以通过使用以下方法来改变进行低级数学运算的底层模块。</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">你可以通过使用来改变这个后台库。</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">您可以通过以下方式改变这一点:</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">你可以在你的系统上用以下方法检查这些变量的值</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">您可以选择是否要总是安装(是)、从不安装(否)或总是被询问。在后一种情况下,您可以将问题的默认答案设置为是(问/是)或否(问/否)。</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">你可以将上面的$s1和$s2与</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">您可以编译Perl的特殊调试版本，该版本允许您使用Perl 的 &lt;code&gt;-D&lt;/code&gt; 选项来了解有关Perl在做什么的更多信息。但是有时除了与调试器一起使用之外，别无选择，要么查看核心转储的堆栈跟踪（在错误报告中非常有用），要么尝试找出发生核心转储之前出了什么问题，或者怎么做。我们最终会得到错误或意外的结果。</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">你可以将 perl 编译成通用二进制文件(同时为 ppc 和 intel 构建)。在 Mac OS X 10.4 &quot;Tiger &quot;中,你必须导出'u'版本的 SDK。</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">您可以通过导入great_circle_distance（）函数来计算称为&lt;b&gt;大圆距的&lt;/b&gt;球面距离：</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">您可以将 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置为也自动使用此选项：</target>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">你可以通过在调用dbmopen()之前加载该库来控制你使用的DBM库。</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">如果你通过freeze()序列化的东西(例如)指向我们在钩子中试图序列化的对象,你可以创建无限循环。</target>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">您可以为所有领带类型定义一个将在untie（）处调用的UNTIE方法。请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">您可以通过定义名称以 &lt;code&gt;&quot;In&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;Is&quot;&lt;/code&gt; 开头的子例程来定义自己的二进制字符属性。 （&lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;perlre中&lt;/a&gt;的实验功能（？[]）提供了一种替代方法，它允许更复杂的定义。）子例程可以在任何程序包中定义。用户定义的属性可以在正则表达式 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造中使用；如果您使用的不是来自其他软件包的用户定义属性，则必须在 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 构造中指定其软件包。</target>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">您可以定义自己的字符属性，并在带有 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 结构的正则表达式中使用它们。有关更多详细信息，请参见&lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;用户定义的字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">你可以使用 &quot;isainfo -v &quot;来检测操作系统的模式,如</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">你可以通过这个咒语来判断你的系统恩典度。</target>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">您可以使用 &lt;code&gt;c&lt;/code&gt; 标志禁用失败的 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 重置，该标志记录在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlreref&quot;&gt;perlreref中&lt;/a&gt;。随后的匹配从最后一次成功的匹配结束（ &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 的值）开始，即使在同一时间对同一字符串的匹配失败了。在这种情况下， &lt;code&gt;while()&lt;/code&gt; 循环之后的匹配从 &lt;code&gt;a&lt;/code&gt; （最后一个匹配停止的位置）开始，并且由于它不使用任何锚点，因此可以跳过 &lt;code&gt;a&lt;/code&gt; 来查找 &lt;code&gt;44&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">您可以完全省去数字，然后创建命名的捕获组。表示是 &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; ，表示是 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 。（为了与净正则表达式兼容， &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 也可以被写为 &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">您可以使用保存脚本名称的 &lt;code&gt;$0&lt;/code&gt; 值执行类似的操作。那可能拥有相对路径，但是 &lt;code&gt;rel2abs&lt;/code&gt; 可以将其变成绝对路径。一旦有了</target>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">你可以自己做。</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">你可以通过设置一个定制的</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">如果你不介意最后整个文件都在内存中,你可以用c标志和\G锚对foreach和匹配做同样的事情。</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">您可以通过根据您的条件过滤 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象的列表来完成此操作。例如，要仅提取标题中带有字符串 &lt;code&gt;foo&lt;/code&gt; 的文件，可以使用：</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">你可以在</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">你可以对列表做各种有用的事情。</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">您可以从&lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;下载NDK 。</target>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">您也可以轻松地自己完成此操作，方法是在移至下一级别之前检查哈希的每个级别。实际上，这就是&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;为您完成的工作：</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">这样可以实现250毫秒的睡眠。</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">你可以从Ninemoons获得最新的perl-for-amiga源码,然后用它解压。</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">您可以将Pod文档嵌入到Perl模块和脚本中。以空行开始文档，在开头以&amp;ldquo; = head1&amp;rdquo;命令开头，以&amp;ldquo; = cut&amp;rdquo;命令和空行结束。在&lt;b&gt;Perl的&lt;/b&gt;可执行文件会忽略波德文本。您可以将Pod语句放在&lt;b&gt;perl&lt;/b&gt;期望新语句开始的位置，但不能放在语句内，因为那样会导致错误。有关示例，请参见任何提供的库模块。</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">您可以使用 &lt;code&gt;-C&lt;/code&gt; 命令行开关或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量来启用标准文件句柄，默认的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，有关 &lt;code&gt;-C&lt;/code&gt; 开关的文档，请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">您可以通过将包变量 &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; 设置为真值来在整个程序范围内启用该程序。有关详细信息，请参见下面的&amp;ldquo; &lt;code&gt;Global Variables&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">你甚至可以在文件的开头添加一行,因为当前的行打印在循环的最后。</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">你甚至可以像往常一样连锁操作。</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">您甚至可以将它们设置为管道命令。例如，这会通过&lt;b&gt;gzip&lt;/b&gt;自动过滤压缩的参数：</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">你可以在 perl 程序中检查 @INC 变量,查看 Perl 搜索这些目录的顺序。</target>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">您可以在</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">你可以通过解压一个以原生格式打包的数据结构来探索你的平台的endianness,比如。</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">您可以使用 &lt;code&gt;Unicode::UCD&lt;/code&gt; 模块从Unicode数据文件中探索各种信息。</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">您可以扩展数据转换快捷菜单,例如,您可以一键显示一个SV的IV值,而不需要做任何输入。要做到这一点,只需编辑~/.ddd/init文件,并在后面添加。</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">您可以使用超出范围的词汇变量来伪造静态变量。在此示例中，您定义了子例程 &lt;code&gt;counter&lt;/code&gt; ，它使用词法变量 &lt;code&gt;$count&lt;/code&gt; 。由于将其包装在BEGIN块中，因此 &lt;code&gt;$count&lt;/code&gt; 是在编译时定义的，但在BEGIN块的末尾也超出了范围。BEGIN块还确保在编译时定义了子例程及其使用的值，以便该子例程可以像其他任何子例程一样使用，并且可以将此代码与程序文本中的其他子例程放在同一位置（即通常在代码末尾）。子程序 &lt;code&gt;counter&lt;/code&gt; 仍然具有对数据的引用，并且是访问该值的唯一方法（并且每次访问时，都需要增加该值）。 &lt;code&gt;$count&lt;/code&gt; 定义的内存块中的数据是 &lt;code&gt;counter&lt;/code&gt; 专用的。</target>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">你可以用perldoc命令找到这个模块的文档。</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">您可以在配置的命令行开关中找到更多信息。</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;找出Perl是否将&amp;ldquo; long double&amp;rdquo;视为要在您的平台上使用的默认浮点大小：</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;找出Perl是否将&amp;ldquo; long double&amp;rdquo;视为要在您的平台上使用的默认浮点大小：</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持Quads ：</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持Quads ：</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">你可以用下面的方法找到组成UTF-8序列的字节。</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">您可以在这里列出的任何一个镜像中找到完整的 DJGPP 发行版。</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">例如,你可以通过以下方式找到它们</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">您可以使用带数字的格式来说明该格式应影响多少个字符： &lt;code&gt;A12&lt;/code&gt; 表示&amp;ldquo;采用12个字符&amp;rdquo;； &lt;code&gt;x6&lt;/code&gt; 表示&amp;ldquo;跳过6个字节&amp;rdquo;或&amp;ldquo;字符0，6次&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">你可以像我们之前看到的那样,通过在裸词上添加&quot;::&quot;来强制Perl将其解释为类名。</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">您可以通过两种方式强制Perl使用第一种解释（即，作为对名为&amp;ldquo; Class&amp;rdquo;的类的方法调用）。首先，你可以追加 &lt;code&gt;::&lt;/code&gt; 类名：</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">您可以始终使用 &lt;code&gt;\g{...}&lt;/code&gt; 格式强制执行反向引用解释。您可以始终使用 &lt;code&gt;\o{...}&lt;/code&gt; 格式来强制执行八进制解释，也可以强制使用\ 077（= 63十进制）表示数字，并使用以&amp;ldquo; 0&amp;rdquo;开头的三位数。</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">您可以通过调用 &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; 或SvPV_force_nolen（sv）来强制SV复制其字符串缓冲区。</target>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">您可以从&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;或&lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;获得gcc的预编译版本。确保为您的Solaris发行版选择软件包。</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">你可以通过这个命令了解所有文件的概况。</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">您可以通过以下宏来获取和设置存储在SV中的字符串的当前长度。</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">您可以根据我们的情况以几种方式解决此问题。首先，如果您不希望字符串中的任何字符是特殊字符，则可以在使用字符串之前使用 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 对其进行转义。</target>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">您可以很容易地从C获得这些数量中的任何一个。只需将 &lt;code&gt;Sv&lt;/code&gt; 添加到代码段中显示的字段名称中，您将获得一个返回值的宏： &lt;code&gt;SvCUR(sv)&lt;/code&gt; 返回字符串的当前长度， &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; 返回引用计数 &lt;code&gt;SvPV(sv, len)&lt;/code&gt; 返回字符串本身及其长度，依此类推。在&lt;a href=&quot;perlguts&quot;&gt;perlguts中&lt;/a&gt;可以找到更多操纵这些属性的宏。</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; 获得键和值的列表。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
