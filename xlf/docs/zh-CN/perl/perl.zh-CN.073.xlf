<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="254f31569eb5ae2200e952d6645d10bd474402c9" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt; . Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">您还可以通过将Perl代码直接放入 &lt;code&gt;@INC&lt;/code&gt; 来将挂钩插入文件包含系统。这些挂钩可以是子例程引用，数组引用或受祝福的对象。有关详细信息，请参见&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d00ca1cf68d3a16d0f398e68938a43a44653a67" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the file inclusion system by putting Perl code directly into &lt;code&gt;@INC&lt;/code&gt;. Those hooks may be subroutine references, array references or blessed objects. See &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3bd593043bf11a275706b2d003ae9bc2607ea6" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae3dcb264a37bf433b3f44d57e7b80c09701bead" translate="yes" xml:space="preserve">
          <source>You can also insert hooks into the import facility by putting Perl code directly into the @INC array. There are three forms of hooks: subroutine references, array references, and blessed objects.</source>
          <target state="translated">您也可以通过将Perl代码直接放入@INC数组中,将钩子插入到导入设施中。钩子有三种形式:子程序引用、数组引用和祝福对象。</target>
        </trans-unit>
        <trans-unit id="05e59c02014a1d5de9eba1297e8dbc08a175322a" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; on an undefined value this way:</source>
          <target state="translated">您还可以通过以下方式快速 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 一个未定义的值：</target>
        </trans-unit>
        <trans-unit id="d08d52cd53b0788f14ad13e65f62fc4176471f69" translate="yes" xml:space="preserve">
          <source>You can also just quickly &lt;code&gt;die&lt;/code&gt; on an undefined value this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af0b3086e446e033f6737e913de95b977971d84" translate="yes" xml:space="preserve">
          <source>You can also look for information at:</source>
          <target state="translated">你也可以在以下地方查找资料:</target>
        </trans-unit>
        <trans-unit id="87644608210f2aa31bbb03fc62e8e9aeb59cfbac" translate="yes" xml:space="preserve">
          <source>You can also make the warnings fatal by importing this module as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c87e0f17edfeca7f9eb08d5d17c96c80da6a5f2" translate="yes" xml:space="preserve">
          <source>You can also organize your tests within subdirectories in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f3afa40db22b85e32dd734c2f80ac43010fee7" translate="yes" xml:space="preserve">
          <source>You can also override &lt;code&gt;DOES&lt;/code&gt; directly in your own classes. If you override this method, it should never throw an exception.</source>
          <target state="translated">您也可以在自己的类中直接重写 &lt;code&gt;DOES&lt;/code&gt; 。如果重写此方法，则永远不要抛出异常。</target>
        </trans-unit>
        <trans-unit id="95cd0a4f9ce9a6a1469a2469c1efc68cdb5fae5b" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to do it:</source>
          <target state="translated">您还可以通过 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 显式编码来即时更改它。这不完全是&amp;ldquo;二进制&amp;rdquo;模式，但是我们仍然使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="0073e68ffe2cd9f7e4c5d59bc4ac83d3762723b7" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;binmode&lt;/code&gt; an explicit encoding to change it on the fly. This isn't exactly &quot;binary&quot; mode, but we still use &lt;code&gt;binmode&lt;/code&gt; to do it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90ccf1fd48c6dc4de43f56b2888c9c3134e2996" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="translated">您还可以传递子例程引用，以便根据给定的测试脚本确定并返回要运行的正确程序。子例程引用应该将TAP :: Harness对象本身作为第一个参数，并将文件名作为第二个参数。它应该返回一个数组引用，其中包含要运行的命令并包括测试文件名。它也可以简单地返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在这种情况下，TAP :: Harness将退回到在Perl中执行测试脚本的位置：</target>
        </trans-unit>
        <trans-unit id="962bddff5bcc07f7f4968830992a0a3b3b51ad71" translate="yes" xml:space="preserve">
          <source>You can also pass a subroutine reference in order to determine and return the proper program to run based on a given test script. The subroutine reference should expect the TAP::Harness object itself as the first argument, and the file name as the second argument. It should return an array reference containing the command to be run and including the test file name. It can also simply return &lt;code&gt;undef&lt;/code&gt;, in which case TAP::Harness will fall back on executing the test script in Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f73ef4e3f69ff87027791a2bee2e957755bc2ee3" translate="yes" xml:space="preserve">
          <source>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in</source>
          <target state="translated">你也可以在你的C程序中从文件中读取和执行Perl语句,通过将文件名放在</target>
        </trans-unit>
        <trans-unit id="e9bed781c4a6044ffb67b23fe5c127e03e4dd1a1" translate="yes" xml:space="preserve">
          <source>You can also refer to capture groups relatively, by using a negative number, so that &lt;code&gt;\g-1&lt;/code&gt; and &lt;code&gt;\g{-1}&lt;/code&gt; both refer to the immediately preceding capture group, and &lt;code&gt;\g-2&lt;/code&gt; and &lt;code&gt;\g{-2}&lt;/code&gt; both refer to the group before it. For example:</source>
          <target state="translated">您也可以使用负数来相对地引用捕获组，以便 &lt;code&gt;\g-1&lt;/code&gt; 和 &lt;code&gt;\g{-1}&lt;/code&gt; 都引用紧接的捕获组，而 &lt;code&gt;\g-2&lt;/code&gt; 和 &lt;code&gt;\g{-2}&lt;/code&gt; 都引用请参考之前的小组。例如：</target>
        </trans-unit>
        <trans-unit id="108a751b15dd5a65748cd5542a9f662a512fab15" translate="yes" xml:space="preserve">
          <source>You can also restrict names to a certain alphabet by specifying the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; pragma:</source>
          <target state="translated">您还可以通过指定字符名称&lt;a href=&quot;charnames&quot;&gt;杂&lt;/a&gt;注来将名称限制为某个字母：</target>
        </trans-unit>
        <trans-unit id="0b5023bd40fe3a7df91e6504812de04a002532fe" translate="yes" xml:space="preserve">
          <source>You can also see in that example that we use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get the value of the character; the inverse function &lt;code&gt;uvchr_to_utf8&lt;/code&gt; is available for putting a UV into UTF-8:</source>
          <target state="translated">您还可以在该示例中看到，我们使用 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 来获取字符的值。逆函数 &lt;code&gt;uvchr_to_utf8&lt;/code&gt; 可用于将UV放入UTF-8：</target>
        </trans-unit>
        <trans-unit id="2fae27cd653314395e221d45c5f75ed85eb09446" translate="yes" xml:space="preserve">
          <source>You can also send patch files to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt; directly if the patch is not ready to be applied, but intended for discussion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a3be218b57aec1fe1552cf95cde772b459e8c4a" translate="yes" xml:space="preserve">
          <source>You can also send pull requests to the Github repository:</source>
          <target state="translated">你也可以向Github仓库发送拉取请求。</target>
        </trans-unit>
        <trans-unit id="36456f92328715ac88fc0c97cb1b9c2205f52562" translate="yes" xml:space="preserve">
          <source>You can also set up your user name and e-mail address. Most people do this once globally in their</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a4162cf16b37e0bb4e40d233ea23d3b932f7f0d" translate="yes" xml:space="preserve">
          <source>You can also specify the separator character using hexadecimal notation: &lt;b&gt;-0x&lt;i&gt;HHH...&lt;/i&gt;&lt;/b&gt;, where the &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; are valid hexadecimal digits. Unlike the octal form, this one may be used to specify any Unicode character, even those beyond 0xFF. So if you</source>
          <target state="translated">您也可以使用十六进制表示法指定分隔符：&lt;b&gt;-0x &lt;i&gt;HHH ...&lt;/i&gt;&lt;/b&gt;，其中 &lt;code&gt;&lt;i&gt;H&lt;/i&gt;&lt;/code&gt; 是有效的十六进制数字。与八进制格式不同，此格式可用于指定任何Unicode字符，甚至包括0xFF之后的字符。所以如果你</target>
        </trans-unit>
        <trans-unit id="5708c7cba5f95ced05791bc1f781cc7e3ab698d2" translate="yes" xml:space="preserve">
          <source>You can also specify to NOT use something:</source>
          <target state="translated">你也可以指定不使用某些东西。</target>
        </trans-unit>
        <trans-unit id="d0e21d8042eb943e53a763ac42b81475843fd69a" translate="yes" xml:space="preserve">
          <source>You can also store data in network order to allow easy sharing across multiple platforms, or when storing on a socket known to be remotely connected. The routines to call have an initial &lt;code&gt;n&lt;/code&gt; prefix for</source>
          <target state="translated">您还可以按网络顺序存储数据，以便在多个平台之间轻松共享，或者在存储在已知可以远程连接的套接字上时轻松共享数据。调用的例程的初始前缀为 &lt;code&gt;n&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32a000612a53a9f73b8165e9ffd35ee663d455aa" translate="yes" xml:space="preserve">
          <source>You can also subscript a list to get a single element from it:</source>
          <target state="translated">你也可以对一个列表进行下标,以从中获取单个元素。</target>
        </trans-unit>
        <trans-unit id="e308900a9f85413017177815b933ee92128f909d" translate="yes" xml:space="preserve">
          <source>You can also test a class, to make sure that it has the right ancestor:</source>
          <target state="translated">你也可以测试一个类,以确保它有正确的祖先。</target>
        </trans-unit>
        <trans-unit id="45cf05db45090a770c4e7c7739f97f42fdaa1b72" translate="yes" xml:space="preserve">
          <source>You can also test whether a version object is an alpha version, for example to prevent the use of some feature not present in the main release:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e940484c0812f3991ca3b5162180666fbbc774e9" translate="yes" xml:space="preserve">
          <source>You can also try &lt;code&gt;guess_encoding&lt;/code&gt; function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is</source>
          <target state="translated">您也可以尝试默认情况下导出的 &lt;code&gt;guess_encoding&lt;/code&gt; 函数。它需要$ data进行检查，还可以通过选项获取可疑列表。可选的可疑列表是</target>
        </trans-unit>
        <trans-unit id="c6c2bb7263fcb86f56120bac5220dbcae10e778f" translate="yes" xml:space="preserve">
          <source>You can also try to include the module in a one-liner to see if perl finds it:</source>
          <target state="translated">你也可以试着把这个模块包含在一个单行本里,看看perl是否能找到它。</target>
        </trans-unit>
        <trans-unit id="b15c66e70792efbd27fd6c112e317c6eb54c5b69" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="translated">您还可以尝试使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，如&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中所述&lt;/a&gt;（尽管许多模块将为您做同样的事情）。</target>
        </trans-unit>
        <trans-unit id="74be7ad2f05258d57aeb18d3aea7623947196e74" translate="yes" xml:space="preserve">
          <source>You can also try using &lt;code&gt;fork&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; (although this is the same thing that many of the modules will do for you).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">您也可以使用</target>
        </trans-unit>
        <trans-unit id="e0b40e46358631fd782ce6cd1e20ef0687b61198" translate="yes" xml:space="preserve">
          <source>You can also use 0x8e and 0x8f to indicate that the following sequence of characters belongs to yet another character set. To each following byte is added the value 0x80.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202f7bfbf8f49e8ba6c221c617da66be05b837aa" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt;-like syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da89dff1ecf2505f23c0fe06386fc84d5b6555f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05db0e88a7c897c6cc9fa696a780cde648824d4d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb4cba1a89412d983ef34b9565f67b33c11cb2b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;localtime&lt;/code&gt; that returns an object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0304b03ea61e4912a40d9a36c7c0d47306360a9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class::Tiny::Antlers&lt;/a&gt; for &lt;code&gt;Moose&lt;/code&gt; -like syntax.</source>
          <target state="translated">您也可以将&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny::Antlers&quot;&gt;Class :: Tiny :: Antlers&lt;/a&gt;用于 &lt;code&gt;Moose&lt;/code&gt; 的语法。</target>
        </trans-unit>
        <trans-unit id="37de0be164e83020017ecbe8445d1b73a8f2a1b8" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel::REPL&lt;/a&gt; which is an interactive shell for Perl, commonly known as a REPL - Read, Evaluate, Print, Loop. It provides various handy features.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::REPL&quot;&gt;Devel :: REPL&lt;/a&gt;，它是Perl的交互式外壳，通常称为REPL-读取，评估，打印，循环。它提供了各种方便的功能。</target>
        </trans-unit>
        <trans-unit id="9013c35ad3298535ad5c8c74739a6a896be46939" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie::Cycle&lt;/a&gt; to use a scalar that always has the next element of the circular array:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::Cycle&quot;&gt;Tie :: Cycle&lt;/a&gt;使用标量，该标量始终具有圆形数组的下一个元素：</target>
        </trans-unit>
        <trans-unit id="ed9079885add1db23c7b692dc26264a6c8112995" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;来完成许多相同的事情。使用&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: lib&lt;/a&gt;的设置安装模块，然后在程序中使用该模块：</target>
        </trans-unit>
        <trans-unit id="cee36dc459570b6060c3229ade20676c1103dac6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt; to do much of the same thing. Install modules using &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;'s settings then use the module in your program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38efc50c4c6a8567a3f07d734113580b8054b830" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt;, which comes with Perl and provides a &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object:</source>
          <target state="translated">您还可以使用Perl附带的&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;，并提供一个返回对象的 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fe8ff91507ad3e201158ab00126828440dda9b62" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; to access the line counter for a given filehandle without having to worry about which handle you last accessed.</source>
          <target state="translated">您也可以使用 &lt;code&gt;HANDLE-&amp;gt;input_line_number(EXPR)&lt;/code&gt; 访问给定文件句柄的行计数器，而不必担心上次访问哪个句柄。</target>
        </trans-unit>
        <trans-unit id="cfc194c704de65f5fa2e2dc7cdfca08cd861cafc" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt; 's &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="translated">您还可以使用 &lt;code&gt;cpan&lt;/code&gt; 的 &lt;code&gt;-a&lt;/code&gt; 开关来创建 &lt;code&gt;CPAN.pm&lt;/code&gt; 可以理解的自动捆绑文件，并可以用来重新安装每个模块：</target>
        </trans-unit>
        <trans-unit id="c32a4a11aa3d97ad829511eee7c584cbf65b7424" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;cpan&lt;/code&gt;'s &lt;code&gt;-a&lt;/code&gt; switch to create an autobundle file that &lt;code&gt;CPAN.pm&lt;/code&gt; understands and can use to re-install every module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed04ee9d470ae5bb5ded41953f6884557aab9f4" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;while&lt;/code&gt; in a post-condition:</source>
          <target state="translated">您还可以使用 &lt;code&gt;while&lt;/code&gt; 在一个后置条件：</target>
        </trans-unit>
        <trans-unit id="d2490129a2ade6b9a949f50bed0b1d18208e8c0a" translate="yes" xml:space="preserve">
          <source>You can also use Perl one-liners to modify a file in-place. The following changes all 'Fred' to 'Barney' in</source>
          <target state="translated">你也可以使用 Perl 的单行本来修改文件。下面将文件中的 'Fred' 改为 'Barney' 。</target>
        </trans-unit>
        <trans-unit id="7bdc3a001959e967af8fbe560047483c608a1a86" translate="yes" xml:space="preserve">
          <source>You can also use PerlIO to convert larger amounts of data you don't want to bring into memory. For example, to convert between ISO-8859-1 (Latin 1) and UTF-8 (or UTF-EBCDIC in EBCDIC machines):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae806fe9a09487e09415c88d84054f11b5bab926" translate="yes" xml:space="preserve">
          <source>You can also use a commercial debugger such as Affrus (Mac OS X), Komodo from Activestate (Windows and Mac OS X), or EPIC (most platforms).</source>
          <target state="translated">您也可以使用商业调试器,如Affrus(Mac OS X)、Activestate的Komodo(Windows和Mac OS X)或EPIC(大多数平台)。</target>
        </trans-unit>
        <trans-unit id="79babd18e608e40e4da78366242734a20c79cee2" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="translated">您也可以使用双叉。您可以立即 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 第一个孩子，并且init守护进程将在退出后为您的孙子 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d69e7ee5e4d94793bbffd2e90393fe6a378a73cd" translate="yes" xml:space="preserve">
          <source>You can also use a double fork. You immediately &lt;code&gt;wait()&lt;/code&gt; for your first child, and the init daemon will &lt;code&gt;wait()&lt;/code&gt; for your grandchild once it exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef85cce54fb95ce8f948edcebadc50c579e68d3" translate="yes" xml:space="preserve">
          <source>You can also use a list slice to select only the elements that you need:</source>
          <target state="translated">你也可以使用列表切片只选择你需要的元素。</target>
        </trans-unit>
        <trans-unit id="d760c6f0200ce645ec4271e39ed0780a635d6be2" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">您还可以使用本地化 &lt;code&gt;@ARGV&lt;/code&gt; 消除 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="52b5c5f91438f8f97a41eab3ee2f38fefeb189a7" translate="yes" xml:space="preserve">
          <source>You can also use a localized &lt;code&gt;@ARGV&lt;/code&gt; to eliminate the &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4613c51eb74aabc580ab960ede735ed7c5a84c03" translate="yes" xml:space="preserve">
          <source>You can also use a subroutine reference as a method:</source>
          <target state="translated">你也可以使用子程序引用作为方法。</target>
        </trans-unit>
        <trans-unit id="55b643d1caec2f7008ddc9ff139f97c1c50f1aef" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a8095c707393fa806f56c74d791b44c5bdbd35" translate="yes" xml:space="preserve">
          <source>You can also use certain libraries like Config conditionally, but be sure to skip the test gracefully if it's not there.</source>
          <target state="translated">你也可以有条件地使用某些库,比如Config,但如果没有,一定要优雅地跳过测试。</target>
        </trans-unit>
        <trans-unit id="aee62fec81f8fc5af73b94cc4b6a4396ba0e2b3e" translate="yes" xml:space="preserve">
          <source>You can also use dmake to build using Visual C++; provided, however, you set OSRELEASE to &quot;microsft&quot; (or whatever the directory name under which the Visual C dmake configuration lives) in your environment and edit win32/config.vc to change &quot;make=nmake&quot; into &quot;make=dmake&quot;. The latter step is only essential if you want to use dmake as your default make for building extensions using MakeMaker.</source>
          <target state="translated">您也可以使用dmake来使用Visual C++进行构建;不过前提是,在您的环境中把OSRELEASE设置为 &quot;microsft&quot;(或者任何Visual C dmake配置所在的目录名),并编辑win32/config.vc,把 &quot;make=nmake &quot;改为 &quot;make=dmake&quot;。只有当你想使用dmake作为你使用MakeMaker构建扩展的默认make时,后一步才是必不可少的。</target>
        </trans-unit>
        <trans-unit id="4fabe958607319aed5413ce7d91aa1937c4486e1" translate="yes" xml:space="preserve">
          <source>You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:</source>
          <target state="translated">您也可以使用文件描述符重定向使STDERR成为STDOUT的副本。</target>
        </trans-unit>
        <trans-unit id="bb1f48473296bb1c89d7c3f43ff784b475814cae" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt; .</source>
          <target state="translated">您还可以在第一个花括号和属性名称之间插入一个插入符号（ &lt;code&gt;^&lt;/code&gt; ），从而在 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 使用否定符： &lt;code&gt;\p{^Tamil}&lt;/code&gt; 等于 &lt;code&gt;\P{Tamil}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54d20874570939ffd2d092114e0b4e19463ff0b5" translate="yes" xml:space="preserve">
          <source>You can also use negation in both &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; by introducing a caret (&lt;code&gt;^&lt;/code&gt;) between the first brace and the property name: &lt;code&gt;\p{^Tamil}&lt;/code&gt; is equal to &lt;code&gt;\P{Tamil}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a71e5490894554dcf75a2f44b77577d1780db" translate="yes" xml:space="preserve">
          <source>You can also use substr() as an lvalue.</source>
          <target state="translated">你也可以使用substr()作为l值。</target>
        </trans-unit>
        <trans-unit id="c8a027b09bbb1035f68edd31b3dac9da865767c1" translate="yes" xml:space="preserve">
          <source>You can also use the -Duse64bitint flag to Configure. Although there are some minor differences between compiling Perl with this flag versus the -Duse64bitall flag, they should not be noticeable from a Perl user's perspective. When configuring -Duse64bitint using a 64bit gcc on a pa-risc architecture, -Duse64bitint is silently promoted to -Duse64bitall.</source>
          <target state="translated">你也可以使用 -Duse64bitint 标志来配置。虽然用这个标志编译Perl和用-Duse64bitall标志编译Perl有一些细微的差别,但从Perl用户的角度来看,这些差别应该是不明显的。当在 pa-risc 架构上使用 64bit gcc 配置 -Duse64bitint 时,-Duse64bitint 会被默默地提升为 -Duse64bitall。</target>
        </trans-unit>
        <trans-unit id="b2a60dda9b88e0346f381f0e7d0f8c46c74bcfba" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a700e3ed5372f353d27ba3249155ac84ffdf5ae" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f985bfd65126ce04f3352a8f1c24d2647a415c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module using its &lt;code&gt;Today_and_Now&lt;/code&gt; function.</source>
          <target state="translated">您还可以通过其 &lt;code&gt;Today_and_Now&lt;/code&gt; 函数使用&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="5948ec91fdfb792b5884ccadb56a91fc59d16359" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您也可以使用&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块，该模块使您可以通过绑定数组访问行。您可以使用常规数组操作来修改文件，包括设置最后一个索引和使用 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea4cf5784aecf948d1c03056df0b1645df434de" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;**&lt;/code&gt; operator, see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">您还可以使用 &lt;code&gt;**&lt;/code&gt; 运算符，请参阅&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aca7a853e98fdbbaafd79c6bf0b9e3d107072aaf" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; flag.</source>
          <target state="translated">您也可以在标量上下文中使用 &lt;code&gt;\G&lt;/code&gt; 锚。您仍然需要 &lt;code&gt;g&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="dd0679d81994a6f99aa92d35f6d6b0e5281b7e9d" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;\G&lt;/code&gt; anchor in scalar context. You still need the &lt;code&gt;g&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6b2b4f9f728f0a8f747fc021c92ba0dae0be15" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d5ff0652d0a9cfb0d9a8028ed64cb97f87e026" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;open3()&lt;/code&gt; function from &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;. Benjamin Goldberg provides some sample code:</source>
          <target state="translated">您也可以使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3中&lt;/a&gt;的 &lt;code&gt;open3()&lt;/code&gt; 函数。本杰明&amp;middot;戈德堡（Benjamin Goldberg）提供了一些示例代码：</target>
        </trans-unit>
        <trans-unit id="54c10825a7a9a0e79c4bc9a8acb25f8c895c8d2f" translate="yes" xml:space="preserve">
          <source>You can also use the Unix command mknod(1), or on some systems, mkfifo(1). These may not be in your normal path, though.</source>
          <target state="translated">你也可以使用 Unix 命令 mknod(1),或者在某些系统中使用 mkfifo(1)。不过这些命令可能不在你的正常路径中。</target>
        </trans-unit>
        <trans-unit id="d558c8753e7739908d901edc4316bd26afe6b26c" translate="yes" xml:space="preserve">
          <source>You can also use the complement of \b, \B, to specify that there should not be a word boundary.</source>
          <target state="translated">你也可以用\b的补语,\B,来指定不应该有一个词的边界。</target>
        </trans-unit>
        <trans-unit id="94817cf57f637575defe9d34927c35a3c77682d8" translate="yes" xml:space="preserve">
          <source>You can also use the following functions to extract the file header information from Storable images:</source>
          <target state="translated">您也可以使用以下功能从Storable图像中提取文件头信息。</target>
        </trans-unit>
        <trans-unit id="621c9d7b846400426f6a8d8885a28fc12414361e" translate="yes" xml:space="preserve">
          <source>You can also write that as a single substitution, although it turns out the combined statement is slower than the separate ones. That might not matter to you, though:</source>
          <target state="translated">你也可以把它写成一个单独的替换,虽然事实证明组合语句比单独的语句慢。不过这对你来说可能并不重要。</target>
        </trans-unit>
        <trans-unit id="6e736747d1920ca322bb92742d39b47addfde6fe" translate="yes" xml:space="preserve">
          <source>You can also:</source>
          <target state="translated">你也可以。</target>
        </trans-unit>
        <trans-unit id="9a39342cae5acfdbd6b63da64d2d504d73f599e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt; 'd key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section below.</source>
          <target state="translated">你可以改变全局变量$ PARAMS ::检查:: NO_DUPLICATES控制是否 &lt;code&gt;store&lt;/code&gt; &amp;ldquo;d键仍然会出现在你的结果集。请参阅下面的&amp;ldquo; &lt;a href=&quot;#Global-Variables&quot;&gt;全局变量&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="6da0fead206bedaefe0c555de0dec9128299e2e3" translate="yes" xml:space="preserve">
          <source>You can alter the global variable $Params::Check::NO_DUPLICATES to control whether the &lt;code&gt;store&lt;/code&gt;'d key will still be present in your result set. See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330192003f1fea8edf49c86f71523fd9c154de87" translate="yes" xml:space="preserve">
          <source>You can always check the value you're using by printing it in octal notation to ensure it matches what you think it should be. Print it in octal and decimal format:</source>
          <target state="translated">您可以随时通过打印八进制符号来检查您正在使用的值,以确保它与您认为应该的值相匹配。以八进制和十进制格式打印。</target>
        </trans-unit>
        <trans-unit id="ef6c5c0a821b62556c215147b73e29172a7eabfd" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">您始终可以使用大括号将数组引用替换为数组名称。例如， &lt;code&gt;@{$aref}&lt;/code&gt; 而不是 &lt;code&gt;@array&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="150541d09f643b30e2058d1e0bade9c15ba89324" translate="yes" xml:space="preserve">
          <source>You can always use an array reference, in curly braces, in place of the name of an array. For example, &lt;code&gt;@{$aref}&lt;/code&gt; instead of &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7165a3ffe3314c6d01e5a6307c924382d3b64487" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; does its deed, by setting the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; hook. The associated handler is called with the exception as an argument, and can change the exception, if it sees fit, by calling &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; for details on setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;%SIG&lt;/code&gt;&lt;/a&gt; entries, and &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; hook is currently called even inside &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4754996a46b2974a193b45735bde04e1ddad5927" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;../perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">您可以安排要运行的回调之前 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 做它的行为，通过设置 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩。关联的处理程序将使用错误文本进行调用，并且如果认为合适，可以通过再次调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 来更改错误消息。有关设置 &lt;code&gt;%SIG&lt;/code&gt; 条目的详细信息，请参见&lt;a href=&quot;../perlvar#%25SIG&quot;&gt;perlvar&lt;/a&gt;中的％SIG；有关某些示例，请参见&lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt;。尽管此功能仅在程序退出前立即运行，但当前并非如此： &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩子即使在eval（）ed的块/字符串中也被调用！如果在这种情况下希望钩子什么都不做，请放</target>
        </trans-unit>
        <trans-unit id="6d6ebe42604b8b630167882d7abe0a8f91ccbdb6" translate="yes" xml:space="preserve">
          <source>You can arrange for a callback to be run just before the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; does its deed, by setting the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook. The associated handler is called with the error text and can change the error message, if it sees fit, by calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again. See &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; for details on setting &lt;code&gt;%SIG&lt;/code&gt; entries, and &lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt; for some examples. Although this feature was to be run only right before your program was to exit, this is not currently so: the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is currently called even inside eval()ed blocks/strings! If one wants the hook to do nothing in such situations, put</source>
          <target state="translated">您可以安排要运行的回调之前 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 做它的行为，通过设置 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩。关联的处理程序将使用错误文本进行调用，并且如果认为合适，可以通过再次调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 来更改错误消息。有关设置 &lt;code&gt;%SIG&lt;/code&gt; 条目的详细信息，请参见&lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvar&lt;/a&gt;中的％SIG；有关某些示例，请参见&lt;a href=&quot;#eval-BLOCK&quot;&gt;eval BLOCK&lt;/a&gt;。尽管此功能仅在程序退出前立即运行，但当前并非如此： &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩子即使在eval（）ed的块/字符串中也被调用！如果在这种情况下希望钩子什么都不做，请放</target>
        </trans-unit>
        <trans-unit id="b111cf2dc7e21ab63d8886219ae9103dbe8e5745" translate="yes" xml:space="preserve">
          <source>You can ask &lt;code&gt;prove&lt;/code&gt; to remember the state of previous test runs and select and/or order the tests to be run based on that saved state.</source>
          <target state="translated">您可以要求 &lt;code&gt;prove&lt;/code&gt; 者记住先前测试运行的状态，并根据保存的状态选择和/或订购要运行的测试。</target>
        </trans-unit>
        <trans-unit id="691310b760f2429354c31b938255b9b2f1fdb135" translate="yes" xml:space="preserve">
          <source>You can avoid this by using a bracketed character class in the lookbehind assertion, like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291f7b02019a89ab9c5bae1789127ea82bbc5201" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be6ec0673c2462bb7fe8ce793fcded60eef0f18" translate="yes" xml:space="preserve">
          <source>You can break circular references by creating a &quot;weak reference&quot;. A weak reference does not increment the reference count for a variable, which means that the object can go out of scope and be destroyed. You can weaken a reference with the &lt;code&gt;weaken&lt;/code&gt; function exported by the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module.</source>
          <target state="translated">您可以通过创建&amp;ldquo;弱引用&amp;rdquo;来中断循环引用。弱引用不会增加变量的引用计数，这意味着对象可能超出范围并被破坏。您可以使用&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;模块导出的 &lt;code&gt;weaken&lt;/code&gt; 功能来弱化引用。</target>
        </trans-unit>
        <trans-unit id="7b50c9286c4042666f0e26f5a3f4bc1fff06eaf5" translate="yes" xml:space="preserve">
          <source>You can call the perl visible subroutine something other than &lt;code&gt;constant&lt;/code&gt; if you give the parameter</source>
          <target state="translated">如果给定参数，则可以用 &lt;code&gt;constant&lt;/code&gt; 以外的方式调用perl visible子例程。</target>
        </trans-unit>
        <trans-unit id="03c6b44929e8d300ef044fa7166e3c54539d868d" translate="yes" xml:space="preserve">
          <source>You can capture its numeric and string content using:</source>
          <target state="translated">您可以使用以下方法获取其数字和字符串内容。</target>
        </trans-unit>
        <trans-unit id="596d44f0dc27aeca16b120bcaf752ef2dfa99248" translate="yes" xml:space="preserve">
          <source>You can categorize these CES by 3 criteria: size of each character, endianness, and Byte Order Mark.</source>
          <target state="translated">你可以通过3个标准对这些CES进行分类:每个字符的大小,endianness和Byte Order Mark。</target>
        </trans-unit>
        <trans-unit id="4b8f84adbeec6314eab49fb83df65b6443839d6c" translate="yes" xml:space="preserve">
          <source>You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, just like the pattern's delimiter must be escaped if it also occurs within the pattern. Thus, &lt;code&gt;&quot;\.&quot;&lt;/code&gt; matches just a literal dot, &lt;code&gt;&quot;.&quot;&lt;/code&gt; instead of its normal meaning. This means that the backslash is also a metacharacter, so &lt;code&gt;&quot;\\&quot;&lt;/code&gt; matches a single &lt;code&gt;&quot;\&quot;&lt;/code&gt;. And a sequence that contains an escaped metacharacter matches the same sequence (but without the escape) in the target string. So, the pattern &lt;code&gt;/blur\\fl/&lt;/code&gt; would match any target string that contains the sequence &lt;code&gt;&quot;blur\fl&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b889973d01196115807ed3e24800abe92e6ed58" translate="yes" xml:space="preserve">
          <source>You can change an array element, but you can't change a list element:</source>
          <target state="translated">你可以改变一个数组元素,但你不能改变一个列表元素。</target>
        </trans-unit>
        <trans-unit id="d178a91245c223a6b3d558a26825e4086182ea75" translate="yes" xml:space="preserve">
          <source>You can change both the effective gid and the real gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; (use only a single numeric argument). Changes to &lt;code&gt;$)&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setgid()&lt;/code&gt; （仅使用一个数字参数）同时更改有效gid和实际gid 。更改 &lt;code&gt;$)&lt;/code&gt; 需要检查 &lt;code&gt;$!&lt;/code&gt; 在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="59d9719ad7d1133b142fc0ce7a1557db385a25a2" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setuid()&lt;/code&gt; 同时更改有效uid和实际uid 。对 &lt;code&gt;$&amp;gt;&lt;/code&gt; 的更改要求对$进行检查 &lt;code&gt;$!&lt;/code&gt; 在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="5c077fd437c354bc24be98de6cf2487d02c8a685" translate="yes" xml:space="preserve">
          <source>You can change both the effective uid and the real uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Changes to &lt;code&gt;$&amp;gt;&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57121de58d74f1a64c5b126aeda69842259d90c4" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt; . Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setgid()&lt;/code&gt; 同时更改实际gid和有效gid 。更改 &lt;code&gt;$(&lt;/code&gt; 要求对 &lt;code&gt;$!&lt;/code&gt; 进行检查，以在尝试更改后检测任何可能的错误。</target>
        </trans-unit>
        <trans-unit id="11e8003bdfd58a10a9ce8d2ff75b8afc3ab5c059" translate="yes" xml:space="preserve">
          <source>You can change both the real gid and the effective gid at the same time by using &lt;code&gt;POSIX::setgid()&lt;/code&gt;. Changes to &lt;code&gt;$(&lt;/code&gt; require a check to &lt;code&gt;$!&lt;/code&gt; to detect any possible errors after an attempted change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09c5405e2b602271ef0ef2f3017aa480c6d1079" translate="yes" xml:space="preserve">
          <source>You can change options from</source>
          <target state="translated">您可以从</target>
        </trans-unit>
        <trans-unit id="d6315b4e978f53eeff4964ee1909c618fbc90cfa" translate="yes" xml:space="preserve">
          <source>You can change the underlying module that does the low-level math operations by using:</source>
          <target state="translated">你可以通过使用以下方法来改变进行低级数学运算的底层模块。</target>
        </trans-unit>
        <trans-unit id="ac0967b2c568b641678650e45e2b539ad81b2c7d" translate="yes" xml:space="preserve">
          <source>You can change this backend library by using:</source>
          <target state="translated">你可以通过使用来改变这个后台库。</target>
        </trans-unit>
        <trans-unit id="e271d7bee0eb9af50859c996a87b147d97ca08b1" translate="yes" xml:space="preserve">
          <source>You can change this by using:</source>
          <target state="translated">您可以通过以下方式改变这一点:</target>
        </trans-unit>
        <trans-unit id="a8c0aadd56b5a3424b47f02ac266fd1fef206d7e" translate="yes" xml:space="preserve">
          <source>You can check the values of these variables on your system with</source>
          <target state="translated">你可以在你的系统上用以下方法检查这些变量的值</target>
        </trans-unit>
        <trans-unit id="19186d4d2aa107ae87a9009974a30d3e15b94cd1" translate="yes" xml:space="preserve">
          <source>You can choose if you want to always install (yes), never install (no) or be always asked. In the latter case you can set the default answer for the question to yes (ask/yes) or no (ask/no).</source>
          <target state="translated">您可以选择是否要总是安装(是)、从不安装(否)或总是被询问。在后一种情况下,您可以将问题的默认答案设置为是(问/是)或否(问/否)。</target>
        </trans-unit>
        <trans-unit id="432283768bc5fcc2cbc19482faa7326a0cb0200d" translate="yes" xml:space="preserve">
          <source>You can compare $s1 and $s2 above with</source>
          <target state="translated">你可以将上面的$s1和$s2与</target>
        </trans-unit>
        <trans-unit id="5cd28c9babbe3b0c5cce52c7e8b6bd3de247f8a7" translate="yes" xml:space="preserve">
          <source>You can compile a special debugging version of Perl, which allows you to use the &lt;code&gt;-D&lt;/code&gt; option of Perl to tell more about what Perl is doing. But sometimes there is no alternative than to dive in with a debugger, either to see the stack trace of a core dump (very useful in a bug report), or trying to figure out what went wrong before the core dump happened, or how did we end up having wrong or unexpected results.</source>
          <target state="translated">您可以编译Perl的特殊调试版本，该版本允许您使用Perl 的 &lt;code&gt;-D&lt;/code&gt; 选项来了解有关Perl在做什么的更多信息。但是有时除了与调试器一起使用之外，别无选择，要么查看核心转储的堆栈跟踪（在错误报告中非常有用），要么尝试找出发生核心转储之前出了什么问题，或者怎么做。我们最终会得到错误或意外的结果。</target>
        </trans-unit>
        <trans-unit id="87041007fca4b20217db14f0fb86e591cf75c1a4" translate="yes" xml:space="preserve">
          <source>You can compile perl as a universal binary (built for both ppc and intel). In Mac OS X 10.4 &quot;Tiger&quot;, you must export the 'u' variant of the SDK:</source>
          <target state="translated">你可以将 perl 编译成通用二进制文件(同时为 ppc 和 intel 构建)。在 Mac OS X 10.4 &quot;Tiger &quot;中,你必须导出'u'版本的 SDK。</target>
        </trans-unit>
        <trans-unit id="fa58ab427e59cc304b800becf278713e2a473dc4" translate="yes" xml:space="preserve">
          <source>You can compute spherical distances, called &lt;b&gt;great circle distances&lt;/b&gt;, by importing the great_circle_distance() function:</source>
          <target state="translated">您可以通过导入great_circle_distance（）函数来计算称为&lt;b&gt;大圆距的&lt;/b&gt;球面距离：</target>
        </trans-unit>
        <trans-unit id="e0e56eaab18c95d9fc59dbbcb6020dceb739e042" translate="yes" xml:space="preserve">
          <source>You can configure &lt;code&gt;CPAN.pm&lt;/code&gt; to automatically use this option too:</source>
          <target state="translated">您可以将 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置为也自动使用此选项：</target>
        </trans-unit>
        <trans-unit id="0a61232f0a79e5aed1425905026fb34cb9f7fecb" translate="yes" xml:space="preserve">
          <source>You can consult &lt;a href=&quot;http://dev.perl.org/perl5&quot;&gt;releases&lt;/a&gt; to determine the current stable release of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1c9e7ff6eff00a8559dcb5573a19d0be7a958f" translate="yes" xml:space="preserve">
          <source>You can control the maximum array and hash recursion depths by modifying &lt;code&gt;$Storable::recursion_limit&lt;/code&gt; and &lt;code&gt;$Storable::recursion_limit_hash&lt;/code&gt; respectively. Either can be set to &lt;code&gt;-1&lt;/code&gt; to prevent any depth checks, though this isn't recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f34654d1547e79b58fc6ed76c2c867b2e4c13c5" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call &lt;a href=&quot;#dbmopen-HASH%2CDBNAME%2CMASK&quot;&gt;&lt;code&gt;dbmopen&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d461022ba384996bf77747145dbd16f78eb1d3d" translate="yes" xml:space="preserve">
          <source>You can control which DBM library you use by loading that library before you call dbmopen():</source>
          <target state="translated">你可以通过在调用dbmopen()之前加载该库来控制你使用的DBM库。</target>
        </trans-unit>
        <trans-unit id="b63a08beb712c643691cdd9c1e77329f30769a82" translate="yes" xml:space="preserve">
          <source>You can create endless loops if the things you serialize via freeze() (for instance) point back to the object we're trying to serialize in the hook.</source>
          <target state="translated">如果你通过freeze()序列化的东西(例如)指向我们在钩子中试图序列化的对象,你可以创建无限循环。</target>
        </trans-unit>
        <trans-unit id="adf4a1b481a315cc2b37fc68aeedf4fc3bec4612" translate="yes" xml:space="preserve">
          <source>You can create your own names for characters, and override official ones when using &lt;code&gt;\N{...}&lt;/code&gt;. See &lt;a href=&quot;charnames#CUSTOM-ALIASES&quot;&gt;&quot;CUSTOM ALIASES&quot; in charnames&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146fea6b6c62fcc84c6add6c6816ffff9347ea9e" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc300aa058401f33bcdc1d74e140c0960d7fa90" translate="yes" xml:space="preserve">
          <source>You can define for all tie types an UNTIE method that will be called at untie(). See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">您可以为所有领带类型定义一个将在untie（）处调用的UNTIE方法。请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd22b39009d785c43f4f9453185f24b021494e27" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt; . (The experimental feature &lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;(?[ ]) in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="translated">您可以通过定义名称以 &lt;code&gt;&quot;In&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;Is&quot;&lt;/code&gt; 开头的子例程来定义自己的二进制字符属性。 （&lt;a href=&quot;perlre#(%3f%5b-%5d)&quot;&gt;perlre中&lt;/a&gt;的实验功能（？[]）提供了一种替代方法，它允许更复杂的定义。）子例程可以在任何程序包中定义。用户定义的属性可以在正则表达式 &lt;code&gt;\p{}&lt;/code&gt; 和 &lt;code&gt;\P{}&lt;/code&gt; 构造中使用；如果您使用的不是来自其他软件包的用户定义属性，则必须在 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 构造中指定其软件包。</target>
        </trans-unit>
        <trans-unit id="581b021633b88b8ca77368d47883217c97fc358f" translate="yes" xml:space="preserve">
          <source>You can define your own binary character properties by defining subroutines whose names begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt; or &lt;code&gt;&quot;Is&quot;&lt;/code&gt;. (The experimental feature &lt;a href=&quot;perlre#%28%3F%5B-%5D%29&quot;&gt;&quot;(?[ ])&quot; in perlre&lt;/a&gt; provides an alternative which allows more complex definitions.) The subroutines can be defined in any package. They override any Unicode properties expressed as the same names. The user-defined properties can be used in the regular expression &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs; if you are using a user-defined property from a package other than the one you are in, you must specify its package in the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea972cce46eda2a3f1a7af312987a64fafa63f8" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107745b2e3d0c30dbe6a28beb79e3db6db75115c" translate="yes" xml:space="preserve">
          <source>You can define your own character properties and use them in the regular expression with the &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; construct. See &lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties&lt;/a&gt; for more details.</source>
          <target state="translated">您可以定义自己的字符属性，并在带有 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 结构的正则表达式中使用它们。有关更多详细信息，请参见&lt;a href=&quot;#User-Defined-Character-Properties&quot;&gt;用户定义的字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d07e5c5285c0856948c6976c6c8552f314a8bd96" translate="yes" xml:space="preserve">
          <source>You can define your own custom character classes, by putting into your pattern in the appropriate place(s), a list of all the characters you want in the set. You do this by enclosing the list within &lt;code&gt;[]&lt;/code&gt; bracket characters. These are called &quot;bracketed character classes&quot; when we are being precise, but often the word &quot;bracketed&quot; is dropped. (Dropping it usually doesn't cause confusion.) This means that the &lt;code&gt;&quot;[&quot;&lt;/code&gt; character is another metacharacter. It doesn't match anything just by itself; it is used only to tell Perl that what follows it is a bracketed character class. If you want to match a literal left square bracket, you must escape it, like &lt;code&gt;&quot;\[&quot;&lt;/code&gt;. The matching &lt;code&gt;&quot;]&quot;&lt;/code&gt; is also a metacharacter; again it doesn't match anything by itself, but just marks the end of your custom class to Perl. It is an example of a &quot;sometimes metacharacter&quot;. It isn't a metacharacter if there is no corresponding &lt;code&gt;&quot;[&quot;&lt;/code&gt;, and matches its literal self:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9472dcd36f94375050dea75545931297e23f500b" translate="yes" xml:space="preserve">
          <source>You can detect the OS mode using &quot;isainfo -v&quot;, e.g.</source>
          <target state="translated">你可以使用 &quot;isainfo -v &quot;来检测操作系统的模式,如</target>
        </trans-unit>
        <trans-unit id="ac56709f3e046a38d3f4f58f4d03fe93d1a1a7f4" translate="yes" xml:space="preserve">
          <source>You can determine your system endianness with this incantation:</source>
          <target state="translated">你可以通过这个咒语来判断你的系统恩典度。</target>
        </trans-unit>
        <trans-unit id="d720ebfa9c94db62cff235f1fc566ea523fe6220" translate="yes" xml:space="preserve">
          <source>You can directly disable thread support with one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e10ee4faf1824e9c84d1fdce76b93c2ae5f9fd0" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; flag, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">您可以使用 &lt;code&gt;c&lt;/code&gt; 标志禁用失败的 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 重置，该标志记录在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlreref&quot;&gt;perlreref中&lt;/a&gt;。随后的匹配从最后一次成功的匹配结束（ &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 的值）开始，即使在同一时间对同一字符串的匹配失败了。在这种情况下， &lt;code&gt;while()&lt;/code&gt; 循环之后的匹配从 &lt;code&gt;a&lt;/code&gt; （最后一个匹配停止的位置）开始，并且由于它不使用任何锚点，因此可以跳过 &lt;code&gt;a&lt;/code&gt; 来查找 &lt;code&gt;44&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="762ba82b0f7c5bd42e2bb3f028578d05bfa6f570" translate="yes" xml:space="preserve">
          <source>You can disable &lt;code&gt;pos()&lt;/code&gt; resets on fail with the &lt;code&gt;c&lt;/code&gt; modifier, documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;. Subsequent matches start where the last successful match ended (the value of &lt;code&gt;pos()&lt;/code&gt;) even if a match on the same string has failed in the meantime. In this case, the match after the &lt;code&gt;while()&lt;/code&gt; loop starts at the &lt;code&gt;a&lt;/code&gt; (where the last match stopped), and since it does not use any anchor it can skip over the &lt;code&gt;a&lt;/code&gt; to find &lt;code&gt;44&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458912b1d0d0c5a77d13c3e7ffc4ddad22f59daf" translate="yes" xml:space="preserve">
          <source>You can dispense with numbers altogether and create named capture groups. The notation is &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; to declare and &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; to reference. (To be compatible with .Net regular expressions, &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; may also be written as &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt;.)</source>
          <target state="translated">您可以完全省去数字，然后创建命名的捕获组。表示是 &lt;code&gt;(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;...)&lt;/code&gt; ，表示是 &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 。（为了与净正则表达式兼容， &lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 也可以被写为 &lt;code&gt;\k{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; ， &lt;code&gt;\k&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;\k'&lt;i&gt;name&lt;/i&gt;'&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b18d3c8d444331784ad87d0c9066604ce83188e2" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt; , which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="translated">您可以使用保存脚本名称的 &lt;code&gt;$0&lt;/code&gt; 值执行类似的操作。那可能拥有相对路径，但是 &lt;code&gt;rel2abs&lt;/code&gt; 可以将其变成绝对路径。一旦有了</target>
        </trans-unit>
        <trans-unit id="708b113fd606c824d990b531e5ec634fa7999b38" translate="yes" xml:space="preserve">
          <source>You can do a similar thing with the value of &lt;code&gt;$0&lt;/code&gt;, which holds the script name. That might hold a relative path, but &lt;code&gt;rel2abs&lt;/code&gt; can turn it into an absolute path. Once you have the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb0b5304ad3a2505b033f6205316fe91cd8667f" translate="yes" xml:space="preserve">
          <source>You can do it yourself:</source>
          <target state="translated">你可以自己做。</target>
        </trans-unit>
        <trans-unit id="3df3594ac830b3b367e2449531bc9481e6c2c743" translate="yes" xml:space="preserve">
          <source>You can do some customization by setting up a</source>
          <target state="translated">你可以通过设置一个定制的</target>
        </trans-unit>
        <trans-unit id="e36b0a11441d7f370d1c8f3b9a2c5df0ed14fec0" translate="yes" xml:space="preserve">
          <source>You can do the same thing with foreach and a match using the c flag and the \G anchor, if you do not mind your entire file being in memory at the end.</source>
          <target state="translated">如果你不介意最后整个文件都在内存中,你可以用c标志和\G锚对foreach和匹配做同样的事情。</target>
        </trans-unit>
        <trans-unit id="94475bd1aa00e25358f732725451e1c48c0023a3" translate="yes" xml:space="preserve">
          <source>You can do this by filtering a list of &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects based on your criteria. For example, to extract only files that have the string &lt;code&gt;foo&lt;/code&gt; in their title, you would use:</source>
          <target state="translated">您可以通过根据您的条件过滤 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象的列表来完成此操作。例如，要仅提取标题中带有字符串 &lt;code&gt;foo&lt;/code&gt; 的文件，可以使用：</target>
        </trans-unit>
        <trans-unit id="e3b58ea141bf0b2ab8308eba04e2fe1187709b38" translate="yes" xml:space="preserve">
          <source>You can do this in</source>
          <target state="translated">你可以在</target>
        </trans-unit>
        <trans-unit id="0e82d2d4c5fee3c3455ee13c93472ac8305c2886" translate="yes" xml:space="preserve">
          <source>You can do various useful things to lists:</source>
          <target state="translated">你可以对列表做各种有用的事情。</target>
        </trans-unit>
        <trans-unit id="2293c83d7e9f41c388c0c9ef674c18441a39f91a" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;.</source>
          <target state="translated">您可以从&lt;a href=&quot;http://developer.blackberry.com/native/downloads/&quot;&gt;http://developer.blackberry.com/native/downloads/&lt;/a&gt;下载NDK 。</target>
        </trans-unit>
        <trans-unit id="ccab4c9ebd3c859889355271883dcf42caad69df" translate="yes" xml:space="preserve">
          <source>You can download the NDK from &lt;a href=&quot;https://developer.android.com/tools/sdk/ndk/index.html&quot;&gt;https://developer.android.com/tools/sdk/ndk/index.html&lt;/a&gt;. You'll want the normal, non-legacy version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34382fbd280654c58cbfc9d0110d2c77f2d872d7" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2add1e5f384d4e366c7f0bda81dca221784f796a" translate="yes" xml:space="preserve">
          <source>You can easily do this yourself too by checking each level of the hash before you move onto the next level. This is essentially what &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; does for you:</source>
          <target state="translated">您也可以轻松地自己完成此操作，方法是在移至下一级别之前检查哈希的每个级别。实际上，这就是&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt;为您完成的工作：</target>
        </trans-unit>
        <trans-unit id="aca937c9b8249ef74f6bdd2a2c24ef2b2c942c33" translate="yes" xml:space="preserve">
          <source>You can effect a sleep of 250 milliseconds this way:</source>
          <target state="translated">这样可以实现250毫秒的睡眠。</target>
        </trans-unit>
        <trans-unit id="2cf03e7d8c028c108e1f07b9fdfd93ec5a0911cb" translate="yes" xml:space="preserve">
          <source>You can either get the latest perl-for-amiga source from Ninemoons and extract it with:</source>
          <target state="translated">你可以从Ninemoons获得最新的perl-for-amiga源码,然后用它解压。</target>
        </trans-unit>
        <trans-unit id="dc1b686bd86f9825c512e3b19e24ca27d9b0e88c" translate="yes" xml:space="preserve">
          <source>You can embed Pod documentation in your Perl modules and scripts. Start your documentation with an empty line, a &quot;=head1&quot; command at the beginning, and end it with a &quot;=cut&quot; command and an empty line. The &lt;b&gt;perl&lt;/b&gt; executable will ignore the Pod text. You can place a Pod statement where &lt;b&gt;perl&lt;/b&gt; expects the beginning of a new statement, but not within a statement, as that would result in an error. See any of the supplied library modules for examples.</source>
          <target state="translated">您可以将Pod文档嵌入到Perl模块和脚本中。以空行开始文档，在开头以&amp;ldquo; = head1&amp;rdquo;命令开头，以&amp;ldquo; = cut&amp;rdquo;命令和空行结束。在&lt;b&gt;Perl的&lt;/b&gt;可执行文件会忽略波德文本。您可以将Pod语句放在&lt;b&gt;perl&lt;/b&gt;期望新语句开始的位置，但不能放在语句内，因为那样会导致错误。有关示例，请参见任何提供的库模块。</target>
        </trans-unit>
        <trans-unit id="4e8901a24d5203f278555dd6630e84e6495d5c32" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="translated">您可以使用 &lt;code&gt;-C&lt;/code&gt; 命令行开关或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量来启用标准文件句柄，默认的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 层和 &lt;code&gt;@ARGV&lt;/code&gt; 的自动UTF-8化，有关 &lt;code&gt;-C&lt;/code&gt; 开关的文档，请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82c6bb69edc2a1dcc5ef223d908dad512d68780d" translate="yes" xml:space="preserve">
          <source>You can enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; by using either the &lt;code&gt;-C&lt;/code&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable, see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt; for the documentation of the &lt;code&gt;-C&lt;/code&gt; switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7d65e57af61c849fd344c325e8ff8558b6ea76" translate="yes" xml:space="preserve">
          <source>You can enable this program wide by setting the package variable &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; to a true value. For details, see the section on &lt;code&gt;Global Variables&lt;/code&gt; below.</source>
          <target state="translated">您可以通过将包变量 &lt;code&gt;$Params::Check::VERBOSE&lt;/code&gt; 设置为真值来在整个程序范围内启用该程序。有关详细信息，请参见下面的&amp;ldquo; &lt;code&gt;Global Variables&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="bd9f5fdd175da39fdf1b2aee95117b6f24089729" translate="yes" xml:space="preserve">
          <source>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</source>
          <target state="translated">你甚至可以在文件的开头添加一行,因为当前的行打印在循环的最后。</target>
        </trans-unit>
        <trans-unit id="469cbe63338eb0799dde10314ea7997fd8799ab7" translate="yes" xml:space="preserve">
          <source>You can even chain the operations together as usual:</source>
          <target state="translated">你甚至可以像往常一样连锁操作。</target>
        </trans-unit>
        <trans-unit id="2aadc431d196d9bef8923dcadb3a5f0c2d7f67b9" translate="yes" xml:space="preserve">
          <source>You can even set them to pipe commands. For example, this automatically filters compressed arguments through &lt;b&gt;gzip&lt;/b&gt;:</source>
          <target state="translated">您甚至可以将它们设置为管道命令。例如，这会通过&lt;b&gt;gzip&lt;/b&gt;自动过滤压缩的参数：</target>
        </trans-unit>
        <trans-unit id="5959df3dd95aca5e6820f2cd7c4389121f214d69" translate="yes" xml:space="preserve">
          <source>You can examine the @INC variable from within a perl program to see the order in which Perl searches these directories.</source>
          <target state="translated">你可以在 perl 程序中检查 @INC 变量,查看 Perl 搜索这些目录的顺序。</target>
        </trans-unit>
        <trans-unit id="b4227d7f6f90687ed1f952d3300efda038a669dd" translate="yes" xml:space="preserve">
          <source>You can examine your last commit with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b698e2e22416ac9eb31f0b1d16a0dd9b5e075ed0" translate="yes" xml:space="preserve">
          <source>You can expand the macros in a</source>
          <target state="translated">您可以在</target>
        </trans-unit>
        <trans-unit id="c6984ea0cc547a7d94d70f8b198039214ca8c15f" translate="yes" xml:space="preserve">
          <source>You can explore the endianness of your platform by unpacking a data structure packed in native format such as:</source>
          <target state="translated">你可以通过解压一个以原生格式打包的数据结构来探索你的平台的endianness,比如。</target>
        </trans-unit>
        <trans-unit id="25084ad020c81115ae6c13e15f94c38c747b7c70" translate="yes" xml:space="preserve">
          <source>You can explore various information from the Unicode data files using the &lt;code&gt;Unicode::UCD&lt;/code&gt; module.</source>
          <target state="translated">您可以使用 &lt;code&gt;Unicode::UCD&lt;/code&gt; 模块从Unicode数据文件中探索各种信息。</target>
        </trans-unit>
        <trans-unit id="214226a1ed44146fabbcdf1d7ff955aea72e1c83" translate="yes" xml:space="preserve">
          <source>You can extend the data conversion shortcuts menu, so for example you can display an SV's IV value with one click, without doing any typing. To do that simply edit ~/.ddd/init file and add after:</source>
          <target state="translated">您可以扩展数据转换快捷菜单,例如,您可以一键显示一个SV的IV值,而不需要做任何输入。要做到这一点,只需编辑~/.ddd/init文件,并在后面添加。</target>
        </trans-unit>
        <trans-unit id="9f3b19dace5e1ee6e80db897c83810c886662b0c" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt; , and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt; . Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt; .</source>
          <target state="translated">您可以使用超出范围的词汇变量来伪造静态变量。在此示例中，您定义了子例程 &lt;code&gt;counter&lt;/code&gt; ，它使用词法变量 &lt;code&gt;$count&lt;/code&gt; 。由于将其包装在BEGIN块中，因此 &lt;code&gt;$count&lt;/code&gt; 是在编译时定义的，但在BEGIN块的末尾也超出了范围。BEGIN块还确保在编译时定义了子例程及其使用的值，以便该子例程可以像其他任何子例程一样使用，并且可以将此代码与程序文本中的其他子例程放在同一位置（即通常在代码末尾）。子程序 &lt;code&gt;counter&lt;/code&gt; 仍然具有对数据的引用，并且是访问该值的唯一方法（并且每次访问时，都需要增加该值）。 &lt;code&gt;$count&lt;/code&gt; 定义的内存块中的数据是 &lt;code&gt;counter&lt;/code&gt; 专用的。</target>
        </trans-unit>
        <trans-unit id="d87a4ece96c240d1ec10cdcea1f450090af5432d" translate="yes" xml:space="preserve">
          <source>You can fake a static variable by using a lexical variable which goes out of scope. In this example, you define the subroutine &lt;code&gt;counter&lt;/code&gt;, and it uses the lexical variable &lt;code&gt;$count&lt;/code&gt;. Since you wrap this in a BEGIN block, &lt;code&gt;$count&lt;/code&gt; is defined at compile-time, but also goes out of scope at the end of the BEGIN block. The BEGIN block also ensures that the subroutine and the value it uses is defined at compile-time so the subroutine is ready to use just like any other subroutine, and you can put this code in the same place as other subroutines in the program text (i.e. at the end of the code, typically). The subroutine &lt;code&gt;counter&lt;/code&gt; still has a reference to the data, and is the only way you can access the value (and each time you do, you increment the value). The data in chunk of memory defined by &lt;code&gt;$count&lt;/code&gt; is private to &lt;code&gt;counter&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bfa69a23c16121bcf7918a14cd66f9c3c6d27f" translate="yes" xml:space="preserve">
          <source>You can find documentation for this module with the perldoc command.</source>
          <target state="translated">你可以用perldoc命令找到这个模块的文档。</target>
        </trans-unit>
        <trans-unit id="2ec893daacd3a612f16b5ff8e3b0ca737de8a9f5" translate="yes" xml:space="preserve">
          <source>You can find more info about Configure's command line switches in the</source>
          <target state="translated">您可以在配置的命令行开关中找到更多信息。</target>
        </trans-unit>
        <trans-unit id="60d30b2a5683150ee021b2d2efe823e684b28b49" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;找出Perl是否将&amp;ldquo; long double&amp;rdquo;视为要在您的平台上使用的默认浮点大小：</target>
        </trans-unit>
        <trans-unit id="0a14665644553d1c1ca40b3a369c0cfc1687919b" translate="yes" xml:space="preserve">
          <source>You can find out whether Perl considers &quot;long double&quot; to be the default floating-point size to use on your platform via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;找出Perl是否将&amp;ldquo; long double&amp;rdquo;视为要在您的平台上使用的默认浮点大小：</target>
        </trans-unit>
        <trans-unit id="a8c0376796b23fff5ec186fab67f5500801dd3ed" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持Quads ：</target>
        </trans-unit>
        <trans-unit id="977c50ef8718482d8b17abe375d1697e8f9a2d66" translate="yes" xml:space="preserve">
          <source>You can find out whether your Perl supports quads via &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;:</source>
          <target state="translated">您可以通过&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;来确定Perl是否支持Quads ：</target>
        </trans-unit>
        <trans-unit id="58566ff87e227e47e0a6175cb880b0492ff07d0d" translate="yes" xml:space="preserve">
          <source>You can find the bytes that make up a UTF-8 sequence with</source>
          <target state="translated">你可以用下面的方法找到组成UTF-8序列的字节。</target>
        </trans-unit>
        <trans-unit id="d66bda1e5630ce31a16d647268de04ca99f2d093" translate="yes" xml:space="preserve">
          <source>You can find the full DJGPP distribution on any of the mirrors listed here:</source>
          <target state="translated">您可以在这里列出的任何一个镜像中找到完整的 DJGPP 发行版。</target>
        </trans-unit>
        <trans-unit id="53a7bd12f9a84d4d155f8bc43066fe15624ba305" translate="yes" xml:space="preserve">
          <source>You can find them for example by</source>
          <target state="translated">例如,你可以通过以下方式找到它们</target>
        </trans-unit>
        <trans-unit id="abd3b038a5876faa8d912c01ba340b1b8ceaabfa" translate="yes" xml:space="preserve">
          <source>You can follow the formats with numbers to say how many characters should be affected by that format: &lt;code&gt;A12&lt;/code&gt; means &quot;take 12 characters&quot;; &lt;code&gt;x6&lt;/code&gt; means &quot;skip 6 bytes&quot; or &quot;character 0, 6 times&quot;.</source>
          <target state="translated">您可以使用带数字的格式来说明该格式应影响多少个字符： &lt;code&gt;A12&lt;/code&gt; 表示&amp;ldquo;采用12个字符&amp;rdquo;； &lt;code&gt;x6&lt;/code&gt; 表示&amp;ldquo;跳过6个字节&amp;rdquo;或&amp;ldquo;字符0，6次&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e5ffde15ed2080164a5592bd7bb881aeab7fa67" translate="yes" xml:space="preserve">
          <source>You can force Perl to interpret the bareword as a class name by appending &quot;::&quot; to it, like we saw earlier:</source>
          <target state="translated">你可以像我们之前看到的那样,通过在裸词上添加&quot;::&quot;来强制Perl将其解释为类名。</target>
        </trans-unit>
        <trans-unit id="6a0f7fd6c71d8ef00acad73e562310bfdc7188b5" translate="yes" xml:space="preserve">
          <source>You can force Perl to use the first interpretation (i.e. as a method call on the class named &quot;Class&quot;) in two ways. First, you can append a &lt;code&gt;::&lt;/code&gt; to the class name:</source>
          <target state="translated">您可以通过两种方式强制Perl使用第一种解释（即，作为对名为&amp;ldquo; Class&amp;rdquo;的类的方法调用）。首先，你可以追加 &lt;code&gt;::&lt;/code&gt; 类名：</target>
        </trans-unit>
        <trans-unit id="3683b364293548110b32df191aa4769c6b0d7861" translate="yes" xml:space="preserve">
          <source>You can force a backreference interpretation always by using the &lt;code&gt;\g{...}&lt;/code&gt; form. You can the force an octal interpretation always by using the &lt;code&gt;\o{...}&lt;/code&gt; form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</source>
          <target state="translated">您可以始终使用 &lt;code&gt;\g{...}&lt;/code&gt; 格式强制执行反向引用解释。您可以始终使用 &lt;code&gt;\o{...}&lt;/code&gt; 格式来强制执行八进制解释，也可以强制使用\ 077（= 63十进制）表示数字，并使用以&amp;ldquo; 0&amp;rdquo;开头的三位数。</target>
        </trans-unit>
        <trans-unit id="b877192684c9091db1ed512a1471d2f292aa330b" translate="yes" xml:space="preserve">
          <source>You can force an SV to make its own copy of its string buffer by calling &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; or SvPV_force_nolen(sv).</source>
          <target state="translated">您可以通过调用 &lt;code&gt;sv_force_normal(sv)&lt;/code&gt; 或SvPV_force_nolen（sv）来强制SV复制其字符串缓冲区。</target>
        </trans-unit>
        <trans-unit id="17a663e3d7a25b5bda8c7ec8fa9aff0d95066f73" translate="yes" xml:space="preserve">
          <source>You can force the thread-safe locale operations to always be used (if available) by recompiling perl with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e323a2944066f4acfe2875190557e817154e971" translate="yes" xml:space="preserve">
          <source>You can force the type to be a JSON number by numifying it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a383c28a991c1f9ed0ee28b1f5306a152b1497" translate="yes" xml:space="preserve">
          <source>You can force the type to be a JSON string by stringifying it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bd5097130055276750c2a4628acf949f4c2e6b" translate="yes" xml:space="preserve">
          <source>You can get a precompiled version of gcc from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt; or &lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;. Make sure you pick up the package for your Solaris release.</source>
          <target state="translated">您可以从&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;或&lt;a href=&quot;http://www.blastwave.org/&quot;&gt;http://www.blastwave.org/&lt;/a&gt;获得gcc的预编译版本。确保为您的Solaris发行版选择软件包。</target>
        </trans-unit>
        <trans-unit id="6c43b7d416e3df44e0ee3889ce9e7a7e5b755245" translate="yes" xml:space="preserve">
          <source>You can get an overview of all the files with this command:</source>
          <target state="translated">你可以通过这个命令了解所有文件的概况。</target>
        </trans-unit>
        <trans-unit id="a325b2e4941194b844aaba1d34803d7f10c46f65" translate="yes" xml:space="preserve">
          <source>You can get and set the current length of the string stored in an SV with the following macros:</source>
          <target state="translated">您可以通过以下宏来获取和设置存储在SV中的字符串的当前长度。</target>
        </trans-unit>
        <trans-unit id="498e28fc3884e7bafa55f40835a491ab14376104" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; before you use the string.</source>
          <target state="translated">您可以根据我们的情况以几种方式解决此问题。首先，如果您不希望字符串中的任何字符是特殊字符，则可以在使用字符串之前使用 &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; 对其进行转义。</target>
        </trans-unit>
        <trans-unit id="907671da7c158c5e53cf7c4009f169bdae8b7e54" translate="yes" xml:space="preserve">
          <source>You can get around this in several ways depending on our situation. First, if you don't want any of the characters in the string to be special, you can escape them with &lt;code&gt;quotemeta&lt;/code&gt; before you use the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2880274dc7c0ec586da21bf05619e960d62718ce" translate="yes" xml:space="preserve">
          <source>You can get at any of these quantities from C very easily; just add &lt;code&gt;Sv&lt;/code&gt; to the name of the field shown in the snippet, and you've got a macro which will return the value: &lt;code&gt;SvCUR(sv)&lt;/code&gt; returns the current length of the string, &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; returns the reference count, &lt;code&gt;SvPV(sv, len)&lt;/code&gt; returns the string itself with its length, and so on. More macros to manipulate these properties can be found in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">您可以很容易地从C获得这些数量中的任何一个。只需将 &lt;code&gt;Sv&lt;/code&gt; 添加到代码段中显示的字段名称中，您将获得一个返回值的宏： &lt;code&gt;SvCUR(sv)&lt;/code&gt; 返回字符串的当前长度， &lt;code&gt;SvREFCOUNT(sv)&lt;/code&gt; 返回引用计数 &lt;code&gt;SvPV(sv, len)&lt;/code&gt; 返回字符串本身及其长度，依此类推。在&lt;a href=&quot;perlguts&quot;&gt;perlguts中&lt;/a&gt;可以找到更多操纵这些属性的宏。</target>
        </trans-unit>
        <trans-unit id="98610d953793b8d3a809dccac32eb0df790fe7b6" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values()&lt;/a&gt;&lt;/code&gt; 获得键和值的列表。</target>
        </trans-unit>
        <trans-unit id="bfa837955bc2111631d4644a0aa1c41fcffdf11c" translate="yes" xml:space="preserve">
          <source>You can get at lists of keys and values with &lt;code&gt;keys()&lt;/code&gt; and &lt;code&gt;values()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a77b36211d3d02a45104bff8d76788cd986acc" translate="yes" xml:space="preserve">
          <source>You can get commercial support of Perl if you wish, although for most users the informal support will more than suffice. See the answer to &quot;Where can I buy a commercial version of Perl?&quot; for more information.</source>
          <target state="translated">如果你愿意,你可以得到 Perl 的商业支持,不过对于大多数用户来说,非正式的支持已经足够了。更多信息请参见 &quot;哪里可以买到商业版的Perl?&quot;的回答。</target>
        </trans-unit>
        <trans-unit id="83877e131c38375e988c7edf4defa59ad28286ba" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;</source>
          <target state="translated">您可以从&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;获取gzip。</target>
        </trans-unit>
        <trans-unit id="5cc7caff36ea8191fb948cb25382a0802d8b70e3" translate="yes" xml:space="preserve">
          <source>You can get gzip from &lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt;</source>
          <target state="translated">您可以从&lt;a href=&quot;http://www.s390.ibm.com/products/oe/bpxqp1.html&quot;&gt;http://www.s390.ibm.com/products/oe/bpxqp1.html&lt;/a&gt;获取gzip 。</target>
        </trans-unit>
        <trans-unit id="ceb45063df183ed03ff063ebe2021495fbb9baff" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; .</source>
          <target state="translated">如果您在自动引述裸词的上下文中使用常量，就会遇到麻烦（对于任何子例程调用都是如此）。例如，您不能说 &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; 因为 &lt;code&gt;CONSTANT&lt;/code&gt; 将被解释为字符串。使用 &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; 或 &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; 可以防止引入裸字引用机制。类似地，由于 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符在其左侧立即引用了一个裸字，因此必须说 &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; （或简单地用逗号代替大箭头）而不是 &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da2f7597146611c6fbedf52c5830c6aad8de3611" translate="yes" xml:space="preserve">
          <source>You can get into trouble if you use constants in a context which automatically quotes barewords (as is true for any subroutine call). For example, you can't say &lt;code&gt;$hash{CONSTANT}&lt;/code&gt; because &lt;code&gt;CONSTANT&lt;/code&gt; will be interpreted as a string. Use &lt;code&gt;$hash{CONSTANT()}&lt;/code&gt; or &lt;code&gt;$hash{+CONSTANT}&lt;/code&gt; to prevent the bareword quoting mechanism from kicking in. Similarly, since the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator quotes a bareword immediately to its left, you have to say &lt;code&gt;CONSTANT() =&amp;gt; 'value'&lt;/code&gt; (or simply use a comma in place of the big arrow) instead of &lt;code&gt;CONSTANT =&amp;gt; 'value'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6872803f70582536909b7aa8df4da94cd4d37a4" translate="yes" xml:space="preserve">
          <source>You can have an environment variable PERL_INSTALL_ROOT set which will be prepended as a directory to each installed file (and directory).</source>
          <target state="translated">你可以设置一个环境变量PERL_INSTALL_ROOT,它将作为一个目录预置到每个安装的文件(和目录)中。</target>
        </trans-unit>
        <trans-unit id="fa58ede728fa900b2be53c5925b3b4ff8069c044" translate="yes" xml:space="preserve">
          <source>You can ignore [pad]THXx when browsing the Perl headers/sources. Those are strictly for use within the core. Extensions and embedders need only be aware of [pad]THX.</source>
          <target state="translated">你可以在浏览Perl头文件/资源时忽略[pad]THXx。这些都是严格用于核心内部的。扩展程序和嵌入程序只需要注意 [pad]THX。</target>
        </trans-unit>
        <trans-unit id="f0a479cb9681a1cb4f6cbb2bcf71ac6471f5092e" translate="yes" xml:space="preserve">
          <source>You can imagine how bad things would be if, for example, the SYS$MANAGER or SYS$SYSTEM logical names were deleted.</source>
          <target state="translated">你可以想象一下,如果,例如,SYS$MANAGER或SYS$SYSTEM逻辑名被删除,事情会有多糟糕。</target>
        </trans-unit>
        <trans-unit id="2157dc8c06b7685edcc449748ab0e77243e5a157" translate="yes" xml:space="preserve">
          <source>You can immediately see a slightly different focus to the subroutine profiling modules, and we start to see exactly which line of code is taking the most time. That regex line is looking a bit suspicious, for example. Remember that these tools are supposed to be used together, there is no single best way to profile your code, you need to use the best tools for the job.</source>
          <target state="translated">你可以立即看到子程序剖析模块的侧重点略有不同,我们开始看到到底是哪一行代码花费了最多的时间。比如说,那行regex看起来就有点可疑。请记住,这些工具应该是一起使用的,没有一种最好的方法来剖析你的代码,你需要使用最好的工具来完成这项工作。</target>
        </trans-unit>
        <trans-unit id="01ccbef4b59df5e513c51a0c19924a7a01e4981e" translate="yes" xml:space="preserve">
          <source>You can import &lt;code&gt;:pushpop&lt;/code&gt; and maintain a stack of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR. PUSHCOLOR takes the attribute string that starts its argument and pushes it onto a stack of attributes. POPCOLOR removes the top of the stack and restores the previous attributes set by the argument of a prior PUSHCOLOR. LOCALCOLOR surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.</source>
          <target state="translated">您可以导入 &lt;code&gt;:pushpop&lt;/code&gt; 并使用PUSHCOLOR，POPCOLOR和LOCALCOLOR维护一堆颜色。PUSHCOLOR采用开始其参数的属性字符串，并将其推入属性堆栈。POPCOLOR删除堆栈的顶部，并恢复由先前PUSHCOLOR的参数设置的先前属性。LOCALCOLOR将其参数包含在PUSHCOLOR和POPCOLOR中，以便随后重新设置颜色。</target>
        </trans-unit>
        <trans-unit id="7225c37bbdccefc8a70c019da87c9b8dea7a6b29" translate="yes" xml:space="preserve">
          <source>You can import all the great circle formulas by</source>
          <target state="translated">您可以通过以下方式导入所有的大圆公式。</target>
        </trans-unit>
        <trans-unit id="6ccdd2eb8d7e6ad6ca52482a2893e8ad5920726c" translate="yes" xml:space="preserve">
          <source>You can import radial coordinate conversion functions by using the &lt;code&gt;:radial&lt;/code&gt; tag:</source>
          <target state="translated">您可以使用 &lt;code&gt;:radial&lt;/code&gt; 标签导入径向坐标转换函数：</target>
        </trans-unit>
        <trans-unit id="a747eb56defc25ea65ac8c773f590bb69f4cf6d4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt; ) and functions (&lt;code&gt;S_IS*&lt;/code&gt; ) from the Fcntl module:</source>
          <target state="translated">您可以从Fcntl模块导入符号模式常量（ &lt;code&gt;S_IF*&lt;/code&gt; ）和函数（ &lt;code&gt;S_IS*&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="daf6e79cd146ad6c1ff8be35e0c5dd03545d96b4" translate="yes" xml:space="preserve">
          <source>You can import symbolic mode constants (&lt;code&gt;S_IF*&lt;/code&gt;) and functions (&lt;code&gt;S_IS*&lt;/code&gt;) from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c8f6c731717afeb2f914b548c9389d16df04b0" translate="yes" xml:space="preserve">
          <source>You can include one underscore between any two digits.</source>
          <target state="translated">您可以在任何两个数字之间加入一个下划线。</target>
        </trans-unit>
        <trans-unit id="06780cff3747acdd27c6cb36674311a1b2286d47" translate="yes" xml:space="preserve">
          <source>You can instead write</source>
          <target state="translated">你可以改写为</target>
        </trans-unit>
        <trans-unit id="c4bd7d42db9b74a8aac6c0368becb036004d4652" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; matches with &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="translated">您可以将 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; 匹配项与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\G.../g&lt;/a&gt;&lt;/code&gt; 混合在一起，其中 &lt;code&gt;\G&lt;/code&gt; 是零宽度的断言，它与上一个 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; （如果有）不存在的确切位置匹配。如果没有 &lt;code&gt;/g&lt;/code&gt; 修饰符， &lt;code&gt;\G&lt;/code&gt; 断言仍会像操作开始时一样锚定在 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 上（请参阅&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;），但是匹配当然只尝试了一次。在先前未应用过 &lt;code&gt;/g&lt;/code&gt; 匹配的目标字符串上使用 &lt;code&gt;\G&lt;/code&gt; 而不使用 &lt;code&gt;/g&lt;/code&gt; ，与使用 &lt;code&gt;\A&lt;/code&gt; 断言匹配字符串的开头相同。另请注意，当前 &lt;code&gt;\G&lt;/code&gt; 仅当锚定在图案的开始时才得到适当的支持。</target>
        </trans-unit>
        <trans-unit id="a2f99acf8ebf785cd6fcc65bebd6795b26da26f1" translate="yes" xml:space="preserve">
          <source>You can intermix &lt;code&gt;m//g&lt;/code&gt; matches with &lt;code&gt;m/\G.../g&lt;/code&gt;, where &lt;code&gt;\G&lt;/code&gt; is a zero-width assertion that matches the exact position where the previous &lt;code&gt;m//g&lt;/code&gt;, if any, left off. Without the &lt;code&gt;/g&lt;/code&gt; modifier, the &lt;code&gt;\G&lt;/code&gt; assertion still anchors at &lt;code&gt;pos()&lt;/code&gt; as it was at the start of the operation (see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;), but the match is of course only attempted once. Using &lt;code&gt;\G&lt;/code&gt; without &lt;code&gt;/g&lt;/code&gt; on a target string that has not previously had a &lt;code&gt;/g&lt;/code&gt; match applied to it is the same as using the &lt;code&gt;\A&lt;/code&gt; assertion to match the beginning of the string. Note also that, currently, &lt;code&gt;\G&lt;/code&gt; is only properly supported when anchored at the very beginning of the pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b86b2d839c827310b20f3c55919cf18f3acb03" translate="yes" xml:space="preserve">
          <source>You can inversely compute the destination if you know the starting point, direction, and distance:</source>
          <target state="translated">如果知道起点、方向和距离,就可以反过来计算目的地。</target>
        </trans-unit>
        <trans-unit id="c770c9c675ab604224950a0310e7e3cbf6f8631c" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;&quot;Predefined Opcode Tags&quot; in Opcode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dfc74f0d7463fa46580b22cd874ca59538b399a" translate="yes" xml:space="preserve">
          <source>You can list opcodes by names, or use a tag name; see &lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;Predefined Opcode Tags in Opcode&lt;/a&gt;.</source>
          <target state="translated">您可以按名称列出操作码，也可以使用标签名称。请参见&lt;a href=&quot;opcode#Predefined-Opcode-Tags&quot;&gt;操作码中的预定义操作码标签&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f4c7db1d02ea8c4d5d73863315380fa405b9daa" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001468774175cba071073df8732faf49990cd65b" translate="yes" xml:space="preserve">
          <source>You can load a custom &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP::Parser::Formatter&lt;/a&gt;:</source>
          <target state="translated">您可以加载自定义的&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Parser::Formatter&quot;&gt;TAP :: Parser :: Formatter&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="922b68ea0df3880a69d6f0bb73214de0179f5c3f" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cc72d3ba21acacd11a8df6beb891397824853a" translate="yes" xml:space="preserve">
          <source>You can load custom &lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s, to change the way the parser interprets particular</source>
          <target state="translated">您可以加载自定义&lt;a href=&quot;tap/parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;，以更改解析器解释特定内容的方式。</target>
        </trans-unit>
        <trans-unit id="864c8cc598c8e4c08f636d6accb98e4216dd8dc6" translate="yes" xml:space="preserve">
          <source>You can log in to the bug tracking system and comment on existing bug reports. If you have additional information regarding an existing bug, please add it. This will help the porters fix the bug.</source>
          <target state="translated">您可以登录到错误跟踪系统,并对现有的错误报告进行评论。如果您有关于现有错误的额外信息,请添加它。这将有助于移植者修复错误。</target>
        </trans-unit>
        <trans-unit id="70b967da2737530b2ccb33fdb14ce4b355858a95" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;In Memory Databases in DB_File&lt;/a&gt;. The &lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="translated">您可以研究使用 &lt;code&gt;DB_File&lt;/code&gt; 模块，并使用 &lt;code&gt;$DB_BTREE&lt;/code&gt; 哈希绑定来 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie()&lt;/a&gt;&lt;/code&gt; ，如&lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;DB_File中的&amp;ldquo;内存数据库&amp;rdquo;中所述&lt;/a&gt;。CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt;模块也可能具有启发性。尽管这确实使哈希保持排序，但您可能不喜欢受tie接口影响的速度降低。您确定需要这样做吗？:)</target>
        </trans-unit>
        <trans-unit id="7b312039abf365be7292ef1e18c22e425bf6aa57" translate="yes" xml:space="preserve">
          <source>You can look into using the &lt;code&gt;DB_File&lt;/code&gt; module and &lt;code&gt;tie()&lt;/code&gt; using the &lt;code&gt;$DB_BTREE&lt;/code&gt; hash bindings as documented in &lt;a href=&quot;db_file#In-Memory-Databases&quot;&gt;&quot;In Memory Databases&quot; in DB_File&lt;/a&gt;. The &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt; module from CPAN might also be instructive. Although this does keep your hash sorted, you might not like the slowdown you suffer from the tie interface. Are you sure you need to do this? :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9625d3e38b4c49498359b9273455de8f35f225d" translate="yes" xml:space="preserve">
          <source>You can make a read-only clone of the repository by running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03c6c46e2fd91fc95b867e10fbdca9429550351" translate="yes" xml:space="preserve">
          <source>You can make references to anything, including scalars, functions, and other references.</source>
          <target state="translated">你可以对任何东西进行引用,包括标量、函数和其他引用。</target>
        </trans-unit>
        <trans-unit id="f238aab29e64ee5c9b032d4d04c0ab30c79c6501" translate="yes" xml:space="preserve">
          <source>You can make the while loop a lot shorter with this suggestion from Benjamin Goldberg:</source>
          <target state="translated">你可以用Benjamin Goldberg的这个建议使while循环缩短很多。</target>
        </trans-unit>
        <trans-unit id="0ec5f2b2db5f7957e7b186e607473a4a56ae2fd0" translate="yes" xml:space="preserve">
          <source>You can make your configuration changes permanent by calling the command &lt;code&gt;o conf commit&lt;/code&gt; . Alternatively set the &lt;code&gt;auto_commit&lt;/code&gt; variable to true by running &lt;code&gt;o conf init auto_commit&lt;/code&gt; and answering the following question with yes.</source>
          <target state="translated">您可以通过调用命令 &lt;code&gt;o conf commit&lt;/code&gt; 永久更改配置。或者，通过运行 &lt;code&gt;o conf init auto_commit&lt;/code&gt; 并使用yes回答以下问题，将 &lt;code&gt;auto_commit&lt;/code&gt; 变量设置为true 。</target>
        </trans-unit>
        <trans-unit id="2011dcb658fe55c431da3ed5067e6f4bf4528970" translate="yes" xml:space="preserve">
          <source>You can mimic class subtraction using lookahead. For example, what UTS#18 might write as</source>
          <target state="translated">你可以用lookahead模仿类减法。例如,UTS#18可能写成的是</target>
        </trans-unit>
        <trans-unit id="3461cd371c3715543776c435145f8478a0ac6ec8" translate="yes" xml:space="preserve">
          <source>You can mock TTY input to debugger by adding arbitrary commands to @DB::typeahead. For example, your</source>
          <target state="translated">你可以通过向@DB::typeahead添加任意命令来模拟TTY输入到调试器。例如,你的</target>
        </trans-unit>
        <trans-unit id="cf9cef6663d4cd69a19179eacb290a6dcc1e8352" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt; ) continue as though the input were one big happy file. See the example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="translated">您可以在第一个 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 之前修改 &lt;code&gt;@ARGV&lt;/code&gt; ，只要该数组最终包含所需的文件名列表即可。行号（ &lt;code&gt;$.&lt;/code&gt; ）继续，好像输入是一个很大的快乐文件。有关如何重置每个文件上的行号，请参阅&lt;a href=&quot;functions/eof&quot;&gt;eof中&lt;/a&gt;的示例。</target>
        </trans-unit>
        <trans-unit id="fef203404e7c4e26b3201a37c63c3bf76f7a448a" translate="yes" xml:space="preserve">
          <source>You can modify &lt;code&gt;@ARGV&lt;/code&gt; before the first &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; as long as the array ends up containing the list of filenames you really want. Line numbers (&lt;code&gt;$.&lt;/code&gt;) continue as though the input were one big happy file. See the example in &lt;a href=&quot;perlfunc#eof&quot;&gt;&quot;eof&quot; in perlfunc&lt;/a&gt; for how to reset line numbers on each file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8a419c4027fffc2a00680692cdd50042e9d07e" translate="yes" xml:space="preserve">
          <source>You can modify the 'commands' for example to hardwire an absolute path by e.g.</source>
          <target state="translated">你可以修改 &quot;命令&quot;,例如,通过以下方法硬连接一个绝对路径</target>
        </trans-unit>
        <trans-unit id="b4169d013aca1666238580a9fd59a4dae77a7deb" translate="yes" xml:space="preserve">
          <source>You can not currently force the type in other, less obscure, ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5494206985a4f40e7d6f949c9e6a6ea96245c15" translate="yes" xml:space="preserve">
          <source>You can now &lt;code&gt;use my::autodie&lt;/code&gt;, which will work just like the standard &lt;code&gt;autodie&lt;/code&gt;, but is now aware of any hints that you've set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de41be22b6a5efcacf396fbce08b0572f97fd60" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; , &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; , and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; . They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="translated">您只能为 &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;HASH&quot;&lt;/code&gt; 类型声明自动处理。它们是Perl可以绑定的唯一东西（除了typeglob之外，这是无法声明的）。</target>
        </trans-unit>
        <trans-unit id="d8980e8dd984a6627df441ec747331d50a1b07d8" translate="yes" xml:space="preserve">
          <source>You can only declare autoties for types &lt;code&gt;&quot;SCALAR&quot;&lt;/code&gt;, &lt;code&gt;&quot;ARRAY&quot;&lt;/code&gt;, and &lt;code&gt;&quot;HASH&quot;&lt;/code&gt;. They're the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d6492d8d5c8ebf50c4b6f0278c97639e62301c" translate="yes" xml:space="preserve">
          <source>You can only obtain this using an alias, and Getopt::Long of at least version 2.13.</source>
          <target state="translated">你只能使用别名,以及至少2.13版本的Getopt::Long来获得。</target>
        </trans-unit>
        <trans-unit id="d146ace3315d8b55185b8781aa6332aa44a31223" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. Syntactically, &quot;&lt;code&gt;...;&lt;/code&gt;&quot; is a complete statement, but, as with other kinds of semicolon-terminated statement, the semicolon may be omitted if &quot;&lt;code&gt;...&lt;/code&gt;&quot; appears immediately before a closing brace. These examples show how the ellipsis works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce5924582aac2aa9ee7cd1ad99c9e8ff1e6ecea" translate="yes" xml:space="preserve">
          <source>You can only use the elliptical statement to stand in for a complete statement. These examples of how the ellipsis works:</source>
          <target state="translated">你只能用省略号语句来代替完整的语句。这些例子说明了省略号的作用。</target>
        </trans-unit>
        <trans-unit id="9cae8654bfe063f888826b48470927a2c30f96cd" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 函数打开文件进行输入或输出。它在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;和&lt;a href=&quot;perlopentut&quot;&gt;perlopentut中有&lt;/a&gt;详尽的记录，但是总之：</target>
        </trans-unit>
        <trans-unit id="318c92a1d982aec365969dbe006cbe697f2326c8" translate="yes" xml:space="preserve">
          <source>You can open a file for input or output using the &lt;code&gt;open()&lt;/code&gt; function. It's documented in extravagant detail in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;, but in short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ba77a9bf1f3b31a9c843fd61b1d22b18753582" translate="yes" xml:space="preserve">
          <source>You can open filehandles directly to Perl scalars instead of a file or other resource external to the program. To do so, provide a reference to that scalar as the third argument to &lt;code&gt;open&lt;/code&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce96504bc4965bb9a6b5d98ed74131b7aef0ff79" translate="yes" xml:space="preserve">
          <source>You can override predefined aliases by simply applying define_alias(). The new alias is always evaluated first, and when necessary, define_alias() flushes the internal cache to make the new definition available.</source>
          <target state="translated">您可以通过简单地应用define_alias()来覆盖预定义的别名。新的别名总是先被评估,当需要时,define_alias()会刷新内部缓存以使新的定义可用。</target>
        </trans-unit>
        <trans-unit id="ef785435f6086fb9fd6b00d9def6f92017001719" translate="yes" xml:space="preserve">
          <source>You can override the default and build a shared libperl if you wish (Configure ... -Duseshrplib).</source>
          <target state="translated">如果你愿意的话,你可以覆盖默认值并构建一个共享的 libperl (Configure ...-Duseshrplib)。</target>
        </trans-unit>
        <trans-unit id="97ed2e27db33bd8f090672fcd70380db3caec730" translate="yes" xml:space="preserve">
          <source>You can override this by giving extra arguments; see below.</source>
          <target state="translated">你可以通过提供额外的参数来覆盖它,见下文。</target>
        </trans-unit>
        <trans-unit id="73f74d7cb907a2b7504c7060b4ad0ec87a6506fe" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt; :</source>
          <target state="translated">您可以通过将所需的舍入模式作为参数传递给 &lt;code&gt;as_number()&lt;/code&gt; 来覆盖它：</target>
        </trans-unit>
        <trans-unit id="82587933cae4e9f30d2fe8c8c0c7863b53e2375e" translate="yes" xml:space="preserve">
          <source>You can override this by passing the desired rounding mode as parameter to &lt;code&gt;as_number()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7321ebb0b4eea0262a3b635a8b77554cb51e976a" translate="yes" xml:space="preserve">
          <source>You can override this default using the &lt;code&gt;T2_FORMATTER&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b4dbfc185a430ad159257351a9ef1b4f3e946a" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; . You can pass multiple arguments using commas:</source>
          <target state="translated">您可以通过在插件名称后添加 &lt;code&gt;=&lt;/code&gt; 来将参数传递给插件，例如 &lt;code&gt;-PMyPlugin=foo&lt;/code&gt; 。您可以使用逗号传递多个参数：</target>
        </trans-unit>
        <trans-unit id="2736e3b985373c7bf800fbac7652d16fb607a369" translate="yes" xml:space="preserve">
          <source>You can pass an argument to your plugin by appending an &lt;code&gt;=&lt;/code&gt; after the plugin name, eg &lt;code&gt;-PMyPlugin=foo&lt;/code&gt;. You can pass multiple arguments using commas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577ba47f8467272240629f611eeec9e04fdaf1e6" translate="yes" xml:space="preserve">
          <source>You can pass arguments to your plugin by appending &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; to the plugin name:</source>
          <target state="translated">您可以通过在插件名称后附加 &lt;code&gt;=arg1,arg2,etc&lt;/code&gt; 来将参数传递给插件：</target>
        </trans-unit>
        <trans-unit id="386308dc979139b37676d9287d489e82d9329ea5" translate="yes" xml:space="preserve">
          <source>You can pass in &lt;code&gt;&quot;?&quot;&lt;/code&gt; for &lt;code&gt;$svAccess&lt;/code&gt; to have an error message displayed summarizing its possible values. This is very handy when doing on-the-fly programming using the Perl debugger:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2015c5b11227b45450c075073adbe76ec83f58eb" translate="yes" xml:space="preserve">
          <source>You can peek into the bisecting process with &lt;code&gt;git bisect log&lt;/code&gt; and &lt;code&gt;git bisect visualize&lt;/code&gt;. &lt;code&gt;git bisect reset&lt;/code&gt; will get you out of bisect mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b26d7e57483cd1ed4bf2659755481a3ca93653" translate="yes" xml:space="preserve">
          <source>You can pick up prebuilt binaries for Solaris from &lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;, &lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt;, ActiveState &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;, and &lt;a href=&quot;http://www.perl.com/&quot;&gt;http://www.perl.com/&lt;/a&gt; under the Binaries list at the top of the page. There are probably other sources as well. Please note that these sites are under the control of their respective owners, not the perl developers.</source>
          <target state="translated">您可以拿起的Solaris预编译的二进制&lt;a href=&quot;http://www.sunfreeware.com/&quot;&gt;http://www.sunfreeware.com/&lt;/a&gt;，&lt;a href=&quot;http://www.blastwave.org&quot;&gt;http://www.blastwave.org&lt;/a&gt;，ActiveState的&lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;，和&lt;a href=&quot;http://www.perl.com/&quot;&gt;HTTP：//www.perl .com /&lt;/a&gt;在页面顶部的&amp;ldquo;二进制文件&amp;rdquo;列表下。可能还有其他来源。请注意，这些站点受其各自所有者的控制，而不是perl开发人员的控制。</target>
        </trans-unit>
        <trans-unit id="afad181efc494d271a3d1339fc4bea9100125dd3" translate="yes" xml:space="preserve">
          <source>You can preallocate space for a hash by assigning to the keys() function. This rounds up the allocated buckets to the next power of two:</source>
          <target state="translated">你可以通过分配给 keys()函数来预分配哈希的空间。这将分配的桶四舍五入到二的下一位幂。</target>
        </trans-unit>
        <trans-unit id="627b7e3f88900bea51795d1c0d405285e2cec7cd" translate="yes" xml:space="preserve">
          <source>You can prevent regeneration by adding the setting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ece78405c91977c16dd3a742419b856c5fd5394" translate="yes" xml:space="preserve">
          <source>You can probably expect your users to be able to guess that they can request less CPU or memory or just &quot;less&quot; overall.</source>
          <target state="translated">你大概可以期待你的用户能够猜到他们可以请求更少的CPU或内存,或者只是总体上 &quot;更少&quot;。</target>
        </trans-unit>
        <trans-unit id="02d6761deb2c7c6b18b97139af69b3430e2b5002" translate="yes" xml:space="preserve">
          <source>You can provide an argument, which will be available in the var &lt;code&gt;$REGMARK&lt;/code&gt; after the match completes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb56a3e59af78b8d5da4daff16effef12d060e2" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing the file:</source>
          <target state="translated">您可以在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 文件时提供此层：</target>
        </trans-unit>
        <trans-unit id="add06e5808df8acbd3f7d2e5d056882c7fd1db80" translate="yes" xml:space="preserve">
          <source>You can provide this layer when &lt;code&gt;open&lt;/code&gt;ing the file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d0d59bd2621cca1e6ec0d854420947ec5a4ec5" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">您可以在 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 前面放置一个 &lt;code&gt;+&lt;/code&gt; ，以表示您希望同时具有对该文件的读写访问权；因此， &lt;code&gt;+&amp;lt;&lt;/code&gt; /几乎总是首选用于读/写更新- &lt;code&gt;+&amp;gt;&lt;/code&gt; 模式将首先破坏文件。通常，您不能使用任何一种读写模式来更新文本文件，因为它们具有可变长度的记录。有关更好的方法，请参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun中&lt;/a&gt;的&lt;b&gt;-i&lt;/b&gt;开关。创建的文件的权限为 &lt;code&gt;0666&lt;/code&gt; ，该权限由进程的 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 值修改。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a5c78cfaaebb70f40ad0f93e0301fba4283c243b" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">您可以在 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; 前面放置一个 &lt;code&gt;+&lt;/code&gt; ，以表示您希望同时具有对该文件的读写访问权；因此， &lt;code&gt;+&amp;lt;&lt;/code&gt; /几乎总是首选用于读/写更新- &lt;code&gt;+&amp;gt;&lt;/code&gt; 模式将首先破坏文件。通常，您不能使用任何一种读写模式来更新文本文件，因为它们具有可变长度的记录。有关更好的方法，请参见&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;的&lt;b&gt;-i&lt;/b&gt;开关。创建的文件的权限为 &lt;code&gt;0666&lt;/code&gt; ，该权限由进程的 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 值修改。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="764b0ecb923d2a9a161c6836b490b2d71dbd0c6c" translate="yes" xml:space="preserve">
          <source>You can put a &lt;code&gt;+&lt;/code&gt; in front of the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; to indicate that you want both read and write access to the file; thus &lt;code&gt;+&amp;lt;&lt;/code&gt; is almost always preferred for read/write updates--the &lt;code&gt;+&amp;gt;&lt;/code&gt; mode would clobber the file first. You can't usually use either read-write mode for updating textfiles, since they have variable-length records. See the &lt;b&gt;-i&lt;/b&gt; switch in &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; for a better approach. The file is created with permissions of &lt;code&gt;0666&lt;/code&gt; modified by the process's &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8c4f9eec7c5f71cbfe88cf0f5ec847885d12d2" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt; ) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="translated">您可以将任何反斜杠序列字符类（ &lt;code&gt;\N&lt;/code&gt; 和 &lt;code&gt;\R&lt;/code&gt; 除外）放在带括号的字符类中，其作用就像将所有与反斜杠序列匹配的字符都放在字符类中一样。例如， &lt;code&gt;[a-f\d]&lt;/code&gt; 匹配任何十进制数字，或者匹配'a'和'f'之间的任何小写字母。</target>
        </trans-unit>
        <trans-unit id="3f74a5262161afb2e7d36af12d2c0a5e7f5326b6" translate="yes" xml:space="preserve">
          <source>You can put any backslash sequence character class (with the exception of &lt;code&gt;\N&lt;/code&gt; and &lt;code&gt;\R&lt;/code&gt;) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, &lt;code&gt;[a-f\d]&lt;/code&gt; matches any decimal digit, or any of the lowercase letters between 'a' and 'f' inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88a6953f485e8c5fc3aeb601fd219de754900f0" translate="yes" xml:space="preserve">
          <source>You can read from an open filehandle using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. In scalar context it reads a single line from the filehandle, and in list context it reads the whole file in, assigning each line to an element of the list:</source>
          <target state="translated">您可以使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符从打开的文件句柄读取。在标量上下文中，它从文件句柄读取一行，在列表上下文中，它读取整个文件，并将每一行分配给列表的元素：</target>
        </trans-unit>
        <trans-unit id="91ab2ef6e453973e41443b71f9d3e34175e99630" translate="yes" xml:space="preserve">
          <source>You can read more about profiling in</source>
          <target state="translated">你可以在</target>
        </trans-unit>
        <trans-unit id="00f2324bbf3536a80f241b597db331417bcbe8c1" translate="yes" xml:space="preserve">
          <source>You can redistribute and/or modify this document under the same terms as Perl itself.</source>
          <target state="translated">您可以在与Perl本身相同的条款下重新发布和/或修改本文档。</target>
        </trans-unit>
        <trans-unit id="d7dc0e1fc9ad5b87e77bf63d3f4081648cdf49ca" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; . See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">您可以要求羊群（）常数（LOCK_SH，LOCK_EX，LOCK_NB和LOCK_UN）通过使用标签来提供 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 。见&lt;a href=&quot;exporter&quot;&gt;出口商&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd402063fc23c838fdd082ec0039119a677f8477" translate="yes" xml:space="preserve">
          <source>You can request that the flock() constants (LOCK_SH, LOCK_EX, LOCK_NB and LOCK_UN) be provided by using the tag &lt;code&gt;:flock&lt;/code&gt;. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f4701466ab8780e7a2b0e9f2a17e8d0b7017d5" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt; . For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="translated">出于兼容性原因，您可以使用标签 &lt;code&gt;:Fcompat&lt;/code&gt; 要求提供旧常量（FAPPEND，FASYNC，FCREAT，FDEFER，FEXCL，FNDELAY，FNONBLOCK，FSYNC，FTRUNC）。对于新应用，建议使用这些常量的较新版本（O_APPEND，O_ASYNC，O_CREAT，O_DEFER，O_EXCL，O_NDELAY，O_NONBLOCK，O_SYNC，O_TRUNC）。</target>
        </trans-unit>
        <trans-unit id="2443b5b8d3d70bb42e56fa3047f34fa5b05587ad" translate="yes" xml:space="preserve">
          <source>You can request that the old constants (FAPPEND, FASYNC, FCREAT, FDEFER, FEXCL, FNDELAY, FNONBLOCK, FSYNC, FTRUNC) be provided for compatibility reasons by using the tag &lt;code&gt;:Fcompat&lt;/code&gt;. For new applications the newer versions of these constants are suggested (O_APPEND, O_ASYNC, O_CREAT, O_DEFER, O_EXCL, O_NDELAY, O_NONBLOCK, O_SYNC, O_TRUNC).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caaaaed5194349d7e53889bf69ba7c88d167c7d9" translate="yes" xml:space="preserve">
          <source>You can reset this cache by assigning an empty hashref to it, or individually remove keys.</source>
          <target state="translated">你可以通过给它分配一个空的哈希夫来重置这个缓存,或者单独删除键。</target>
        </trans-unit>
        <trans-unit id="c4fc671bd928d082df8dcbc4d77c81ac14538200" translate="yes" xml:space="preserve">
          <source>You can retrieve the result via -&amp;gt;data but usually you don't have to because the stringify operator (&quot;&quot;) is overridden to do exactly that.</source>
          <target state="translated">您可以通过-&amp;gt; data检索结果，但是通常不必这样做，因为stringify运算符（&amp;ldquo;&amp;rdquo;）被重写以实现此目的。</target>
        </trans-unit>
        <trans-unit id="1bc6861c31e761832a97f33e3f90e04d306eb3ee" translate="yes" xml:space="preserve">
          <source>You can return the</source>
          <target state="translated">您可以返回</target>
        </trans-unit>
        <trans-unit id="c5203f3ceab8b6b9bc7b6ca2deddcda6d494d3e9" translate="yes" xml:space="preserve">
          <source>You can run a command in the background with:</source>
          <target state="translated">你可以在后台运行一个命令。</target>
        </trans-unit>
        <trans-unit id="c92356e98ca4379f9b92a2bcc41db6e953218853" translate="yes" xml:space="preserve">
          <source>You can run all the tests with the following commands:</source>
          <target state="translated">您可以使用以下命令运行所有测试。</target>
        </trans-unit>
        <trans-unit id="dab3a450deb8a8c4cd405b2e23f88d23efbbf2ec" translate="yes" xml:space="preserve">
          <source>You can run an individual test by a command similar to</source>
          <target state="translated">您可以通过类似于以下的命令来运行单个测试</target>
        </trans-unit>
        <trans-unit id="7019e534322025bbdc3a56a0ada6decc0fac6688" translate="yes" xml:space="preserve">
          <source>You can run into similar problems when you store &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; or &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; into AVs or HVs. Trying to modify such elements will give you the following error:</source>
          <target state="translated">将 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 或 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 存储到AV或HV中时，可能会遇到类似的问题。尝试修改此类元素会给您以下错误：</target>
        </trans-unit>
        <trans-unit id="48a3f2e45a171b8580b9277e027aa9cbf304aecf" translate="yes" xml:space="preserve">
          <source>You can run part of the test suite by hand by using one of the following commands from the</source>
          <target state="translated">您可以通过使用以下命令之一,手动运行部分测试套件。</target>
        </trans-unit>
        <trans-unit id="8428671802bcea1f2c15f381a5fa2ece33821ca0" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3A-Keyword&quot;&gt;&quot;The PROTOTYPES: Keyword&quot; in perlxs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9677002a55994cfb79edd644465223dc6f275627" translate="yes" xml:space="preserve">
          <source>You can safely ignore the line about &quot;prototyping behavior&quot; - it is explained in &lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;The PROTOTYPES: Keyword in perlxs&lt;/a&gt;.</source>
          <target state="translated">您可以放心地忽略关于&amp;ldquo;原型设计行为&amp;rdquo;的这一行-这在&lt;a href=&quot;perlxs#The-PROTOTYPES%3a-Keyword&quot;&gt;《原型：perlxs中的关键字》中进行了解释&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="00bbb0e9f9b7d267fed175221358a00b2882f0e8" translate="yes" xml:space="preserve">
          <source>You can safely replace &lt;code&gt;isa&lt;/code&gt; with &lt;code&gt;DOES&lt;/code&gt; (although the converse is not true).</source>
          <target state="translated">您可以用 &lt;code&gt;DOES&lt;/code&gt; 安全地替换 &lt;code&gt;isa&lt;/code&gt; （尽管事实并非如此）。</target>
        </trans-unit>
        <trans-unit id="f3c22b7008ae62adff98ca02982c07c25fd7ebcc" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; and &lt;code&gt;*foo{NAME}&lt;/code&gt; to find out what name and package the *foo symbol table entry comes from. This may be useful in a subroutine that gets passed typeglobs as arguments:</source>
          <target state="translated">您可以说 &lt;code&gt;*foo{PACKAGE}&lt;/code&gt; 和 &lt;code&gt;*foo{NAME}&lt;/code&gt; 来找出* foo符号表条目来自何名称和包。这在将typeglob作为参数传递的子例程中可能很有用：</target>
        </trans-unit>
        <trans-unit id="1966e0b952d6a25db96c9f73b3f341a3e54cf712" translate="yes" xml:space="preserve">
          <source>You can say &lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; to see how the specifications are being processed and what is actually being imported into modules.</source>
          <target state="translated">您可以说 &lt;code&gt;BEGIN { $Exporter::Verbose=1 }&lt;/code&gt; 以查看规范的处理方式以及实际导入模块的内容。</target>
        </trans-unit>
        <trans-unit id="0ffa8d04bb2be838b7be17e141561b51ef27dbcb" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt;上搜索CPAN 。</target>
        </trans-unit>
        <trans-unit id="60a987a3bb2545fd9e1606745f4c8b7aa743cafc" translate="yes" xml:space="preserve">
          <source>You can search CPAN on &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="decda746759f350cc820cd1383e913824bf2e767" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="translated">您可以在&lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/中&lt;/a&gt;搜索与&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;相关的错误报告。如果需要，将任何新的错误，问题，补丁等提交至：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;http&lt;/a&gt; : //rt.cpan.org/Public/Dist/Display.html?Name=threads</target>
        </trans-unit>
        <trans-unit id="e97ec90c5b6d0afa6264e332a770f1df3b2195d9" translate="yes" xml:space="preserve">
          <source>You can search for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; related bug reports at &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt;. If needed submit any new bugs, problems, patches, etc. to: &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=threads&quot;&gt;https://rt.cpan.org/Public/Dist/Display.html?Name=threads&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="802f6c1f9273b694e1c0cdbd6edb66de5f11d6b4" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.</source>
          <target state="translated">从上面可以看到，在多个Perl版本中 &lt;code&gt;unicode_strings&lt;/code&gt; 的效果有所提高。（并且Perl对Unicode的支持在不断提高；最好使用最新的可用发行版，以便尽可能获得最完整和准确的结果。）请注意，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 5.012或更高版本， &lt;code&gt;unicode_strings&lt;/code&gt; 自动选择unicode_strings。</target>
        </trans-unit>
        <trans-unit id="46b2856a8d70679ee475ab545d871ca0c4c93809" translate="yes" xml:space="preserve">
          <source>You can see from the above that the effect of &lt;code&gt;unicode_strings&lt;/code&gt; increased over several Perl releases. (And Perl's support for Unicode continues to improve; it's best to use the latest available release in order to get the most complete and accurate results possible.) Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically chosen if you &lt;code&gt;use 5.012&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd3b0475986391ff28ff08c186138fbea404f4a4" translate="yes" xml:space="preserve">
          <source>You can see recent commits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169f5a8ded36f882f89340ed4481186781ecd0dd" translate="yes" xml:space="preserve">
          <source>You can see this with the following:</source>
          <target state="translated">你可以用下面的方法来看。</target>
        </trans-unit>
        <trans-unit id="f79ce90f40044bb7e9b04185de2c778bbed128b2" translate="yes" xml:space="preserve">
          <source>You can see what files are changed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30453af312489e18bd58825504c04b5c3c816c5" translate="yes" xml:space="preserve">
          <source>You can see whether your Perl was built with PerlIO by running &lt;code&gt;perl -V&lt;/code&gt; and looking for the &lt;code&gt;useperlio=&lt;/code&gt; line. If &lt;code&gt;useperlio&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , you have PerlIO; otherwise you don't.</source>
          <target state="translated">通过运行 &lt;code&gt;perl -V&lt;/code&gt; 并查找 &lt;code&gt;useperlio=&lt;/code&gt; 行，可以查看Perl是否是用PerlIO构建的。如果 &lt;code&gt;useperlio&lt;/code&gt; 是 &lt;code&gt;define&lt;/code&gt; ，则您有PerlIO; 否则你不会。</target>
        </trans-unit>
        <trans-unit id="1d64238a1676682fd78cc68f5aa21599974d313a" translate="yes" xml:space="preserve">
          <source>You can see which (or neither) threading flavour you have by running &lt;code&gt;perl -V&lt;/code&gt; and looking at the &lt;code&gt;Platform&lt;/code&gt; section. If you have &lt;code&gt;useithreads=define&lt;/code&gt; you have ithreads, if you have &lt;code&gt;use5005threads=define&lt;/code&gt; you have 5.005 threads. If you have neither, you don't have any thread support built in. If you have both, you are in trouble.</source>
          <target state="translated">您可以通过运行 &lt;code&gt;perl -V&lt;/code&gt; 并查看&amp;ldquo; &lt;code&gt;Platform&lt;/code&gt; 部分来查看所具有的线程风味（或都不具有）。如果具有 &lt;code&gt;useithreads=define&lt;/code&gt; ，则具有ithread；如果具有 &lt;code&gt;use5005threads=define&lt;/code&gt; ，则具有5.005线程。如果两者都没有，则您没有内置任何线程支持。如果两者都没有，那么您将遇到麻烦。</target>
        </trans-unit>
        <trans-unit id="8dc1d6869249a32d7f829c0b3a5e051d9383488b" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt; . For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; .</source>
          <target state="translated">您会看到箭头为何如此重要。没有它们，我们将不得不写 &lt;code&gt;${$a[1]}[2]&lt;/code&gt; 而不是 &lt;code&gt;$a[1][2]&lt;/code&gt; 。对于三维数组，他们让我们写 &lt;code&gt;$x[2][3][5]&lt;/code&gt; 代替不可读的 &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="317655eca25364352776afb5bed80ace1fea4f49" translate="yes" xml:space="preserve">
          <source>You can see why the arrows are important. Without them, we would have had to write &lt;code&gt;${$a[1]}[2]&lt;/code&gt; instead of &lt;code&gt;$a[1][2]&lt;/code&gt;. For three-dimensional arrays, they let us write &lt;code&gt;$x[2][3][5]&lt;/code&gt; instead of the unreadable &lt;code&gt;${${$x[2]}[3]}[5]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46ad3852d414e337d72bbed36bfa27c57b29adc" translate="yes" xml:space="preserve">
          <source>You can set and query each of these options interactively in the cpan shell with the &lt;code&gt;o conf&lt;/code&gt; or the &lt;code&gt;o conf init&lt;/code&gt; command as specified below.</source>
          <target state="translated">您可以使用下面指定的 &lt;code&gt;o conf&lt;/code&gt; 或 &lt;code&gt;o conf init&lt;/code&gt; 命令在cpan shell中交互设置和查询每个选项。</target>
        </trans-unit>
        <trans-unit id="16508b3f102bc9307eda4b040c0235215ac4aad7" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; on the elements, and use &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; , the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="translated">您可以设置 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 元素设置POSIX实时信号处理，使用 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 的元素，并使用 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; 找出多少POSIX实时信号有可用的 &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt; ， &lt;code&gt;SIGRTMAX&lt;/code&gt; 是有效的POSIX实时信号）。</target>
        </trans-unit>
        <trans-unit id="79ff7651cbb8cbdef1e9fddeb8df40c39df09e89" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; elements to set the POSIX realtime signal handlers, use &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;exists&lt;/code&gt; on the elements, and use &lt;code&gt;scalar&lt;/code&gt; on the &lt;code&gt;%POSIX::SIGRT&lt;/code&gt; to find out how many POSIX realtime signals there are available &lt;code&gt;(SIGRTMAX - SIGRTMIN + 1&lt;/code&gt;, the &lt;code&gt;SIGRTMAX&lt;/code&gt; is a valid POSIX realtime signal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f6da332e187deef2beadbe770ab6beeaee593c3" translate="yes" xml:space="preserve">
          <source>You can set the values of the &lt;code&gt;%SIG&lt;/code&gt; hash to be the functions you want to handle the signal. After perl catches the signal, it looks in &lt;code&gt;%SIG&lt;/code&gt; for a key with the same name as the signal, then calls the subroutine value for that key.</source>
          <target state="translated">您可以将 &lt;code&gt;%SIG&lt;/code&gt; 哈希值设置为要处理信号的函数。perl捕获到信号后，它将在 &lt;code&gt;%SIG&lt;/code&gt; 中查找与该信号同名的键，然后调用该键的子例程值。</target>
        </trans-unit>
        <trans-unit id="4b3c0110aa09f64da5c5df5eac7d33e443e6104d" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0 if you are sure the filesystem you are scanning reflects the number of subdirectories in the parent directory's &lt;code&gt;nlink&lt;/code&gt; count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee1469992dc1b9c8f0b603349904e7ab865deb8" translate="yes" xml:space="preserve">
          <source>You can set the variable &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, if you want to force File::Find to always stat directories. This was used for file systems that do not have an &lt;code&gt;nlink&lt;/code&gt; count matching the number of sub-directories. Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file system) and a couple of others.</source>
          <target state="translated">如果要强制File :: Find始终统计目录，可以将变量 &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 为1。这用于没有 &lt;code&gt;nlink&lt;/code&gt; 计数与子目录数量匹配的文件系统。示例包括ISO-9660（CD-ROM），AFS，HPFS（OS / 2文件系统），FAT（DOS文件系统）以及其他几个。</target>
        </trans-unit>
        <trans-unit id="5472b025e4a5169aacbf87f4ca700aef907769b9" translate="yes" xml:space="preserve">
          <source>You can set these attributes on the parser object before you call &lt;code&gt;parse_file&lt;/code&gt; (or a similar method) on it:</source>
          <target state="translated">您可以在解析器对象上设置这些属性，然后再对其调用 &lt;code&gt;parse_file&lt;/code&gt; （或类似方法）：</target>
        </trans-unit>
        <trans-unit id="d11091c76638b6f543204cac0351812864021173" translate="yes" xml:space="preserve">
          <source>You can set these with cereg.exe, a (remote) registry editor or via the PerlIDE.</source>
          <target state="translated">你可以使用cereg.exe、(远程)注册表编辑器或通过PerlIDE来设置这些。</target>
        </trans-unit>
        <trans-unit id="a45d7d92f838159f25ad37c4eba92cfbf985fe7f" translate="yes" xml:space="preserve">
          <source>You can set this in your &lt;code&gt;CPAN.pm&lt;/code&gt; configuration so modules automatically install in your private library directory when you use the CPAN.pm shell:</source>
          <target state="translated">您可以在 &lt;code&gt;CPAN.pm&lt;/code&gt; 配置中进行设置，以便在使用CPAN.pm shell时模块自动安装在私有库目录中：</target>
        </trans-unit>
        <trans-unit id="30390221c1f07dd9de6ff3b92b3e83f72d1fc24c" translate="yes" xml:space="preserve">
          <source>You can sometimes</source>
          <target state="translated">你有时可以</target>
        </trans-unit>
        <trans-unit id="7db7fa33c434550059625aa8e8d2392ae86f8c71" translate="yes" xml:space="preserve">
          <source>You can specify a character class, by enclosing a list of characters in &lt;code&gt;[]&lt;/code&gt; , which will match any character from the list. If the first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not in the list. Within a list, the &quot;-&quot; character specifies a range, so that &lt;code&gt;a-z&lt;/code&gt; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive. If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a class, put it at the start of the list (possibly after a &quot;^&quot;), or escape it with a backslash. &quot;-&quot; is also taken literally when it is at the end of the list, just before the closing &quot;]&quot;. (The following all specify the same class of three characters: &lt;code&gt;[-az]&lt;/code&gt; , &lt;code&gt;[az-]&lt;/code&gt; , and &lt;code&gt;[a\-z]&lt;/code&gt; . All are different from &lt;code&gt;[a-z]&lt;/code&gt; , which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.) Also, if you try to use the character classes &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , or &lt;code&gt;\D&lt;/code&gt; as endpoints of a range, the &quot;-&quot; is understood literally.</source>
          <target state="translated">您可以通过在 &lt;code&gt;[]&lt;/code&gt; 中包含一个字符列表来指定字符类，该字符列表将匹配列表中的任何字符。如果&amp;ldquo; [&amp;rdquo;之后的第一个字符是&amp;ldquo; ^&amp;rdquo;，则该类匹配列表中未包含的任何字符。在列表中，&amp;ldquo;-&amp;rdquo;字符指定范围，因此 &lt;code&gt;a-z&lt;/code&gt; 表示&amp;ldquo; a&amp;rdquo;和&amp;ldquo; z&amp;rdquo;之间（包括两端）的所有字符。如果您希望&amp;ldquo;-&amp;rdquo;或&amp;ldquo;]&amp;rdquo;本身成为类的成员，请将其放在列表的开头（可能在&amp;ldquo; ^&amp;rdquo;之后），或使用反斜杠对其进行转义。当它位于列表的末尾，紧接在&amp;ldquo;]&amp;rdquo;之前时，也照字面使用&amp;ldquo;-&amp;rdquo;。 （以下各项均指定了三个字符的同一类： &lt;code&gt;[-az]&lt;/code&gt; ， &lt;code&gt;[az-]&lt;/code&gt; ，和 &lt;code&gt;[a\-z]&lt;/code&gt; 。都与 &lt;code&gt;[a-z]&lt;/code&gt; 不同，即使在基于EBCDIC的字符集上，该类也指定包含26个字符的类。）此外，如果尝试使用字符类 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\d&lt;/code&gt; 或 &lt;code&gt;\D&lt;/code&gt; 作为端点在范围内，&amp;ldquo;-&amp;rdquo;在字面上被理解。</target>
        </trans-unit>
        <trans-unit id="26fab1522afd0e2727fdb333919185675d766a45" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt; , this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="translated">您可以通过指定来指定精度（用于数字转换）或最大宽度（用于字符串转换） &lt;code&gt;.&lt;/code&gt; 跟一个数字。对于 &lt;code&gt;g&lt;/code&gt; 和 &lt;code&gt;G&lt;/code&gt; 以外的浮点格式，它指定要显示的小数点右边的位数（默认为6）。例如：</target>
        </trans-unit>
        <trans-unit id="eb60daa97062d5b450232fe33f31d785b7b34956" translate="yes" xml:space="preserve">
          <source>You can specify a precision (for numeric conversions) or a maximum width (for string conversions) by specifying a &lt;code&gt;.&lt;/code&gt; followed by a number. For floating-point formats except &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, this specifies how many places right of the decimal point to show (the default being 6). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7117f36d5a9b63e0e2af83d4187313124e5bec9" translate="yes" xml:space="preserve">
          <source>You can specify a series of alternatives for a pattern using &quot;|&quot; to separate them, so that &lt;code&gt;fee|fie|foe&lt;/code&gt; will match any of &quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the target string (as would &lt;code&gt;f(e|i|o)e&lt;/code&gt;). The first alternative includes everything from the last pattern delimiter (&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and the last alternative contains everything from the last &quot;|&quot; to the next closing pattern delimiter. That's why it's common practice to include alternatives in parentheses: to minimize confusion about where they start and end.</source>
          <target state="translated">您可以使用&amp;ldquo; |&amp;rdquo;为模式指定一系列替代方案 分隔它们，以便 &lt;code&gt;fee|fie|foe&lt;/code&gt; 与目标字符串中的&amp;ldquo;费用&amp;rdquo;，&amp;ldquo;费用&amp;rdquo;或&amp;ldquo;费用&amp;rdquo;中的任何一个匹配（与 &lt;code&gt;f(e|i|o)e&lt;/code&gt; ）。第一个备选方案包括从最后一个模式定界符（&amp;ldquo;（&amp;rdquo;，&amp;ldquo;（?:&amp;rdquo;等，或模式的开头）到第一个&amp;ldquo; |&amp;rdquo;&amp;rdquo;到第一个&amp;ldquo; |&amp;rdquo;的所有内容，最后一个备选方案包含从最后一个&amp;ldquo; |&amp;rdquo;起的所有内容这就是为什么通常的做法是在圆括号中包含替代项：最大程度地减少对替代项在何处开始和结束的困惑。</target>
        </trans-unit>
        <trans-unit id="2c0acf2a3cfcada005163c068fb15aa1f1ca963b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; .</source>
          <target state="translated">您可以使用 &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt; 逗号或分号来指定几个类来尝试。</target>
        </trans-unit>
        <trans-unit id="641b8e676fa0d8d749c4f8fe7240158e55ec8e1b" translate="yes" xml:space="preserve">
          <source>You can specify several classes to try by joining them with commas or semicolons, as in &lt;code&gt;-MTk::SuperPod;Tk::Pod&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590cfec6710042ae4b201c340cadca79997b8f8" translate="yes" xml:space="preserve">
          <source>You can stop using AutoLoader by simply</source>
          <target state="translated">您可以通过以下方式停止使用AutoLoader</target>
        </trans-unit>
        <trans-unit id="2a07cd3fd8cff327607dbfc5239cb17fe58be132" translate="yes" xml:space="preserve">
          <source>You can subclass an existing HashBase class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb2363990bc861a2294e72254c60f889449d2d6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;; see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 在已经打开的流上切换编码；参见&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="408bf98559257c5c2b42f635092e2cb73454caf6" translate="yes" xml:space="preserve">
          <source>You can switch encodings on an already opened stream by using &lt;code&gt;binmode()&lt;/code&gt;; see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4a77a592ef4f50bebb75551ecc777ec47349e4" translate="yes" xml:space="preserve">
          <source>You can switch locales as often as you wish at run time with the &lt;code&gt;POSIX::setlocale()&lt;/code&gt; function:</source>
          <target state="translated">您可以使用 &lt;code&gt;POSIX::setlocale()&lt;/code&gt; 函数在运行时随意切换语言环境：</target>
        </trans-unit>
        <trans-unit id="4591a0f85fb87cbd2147c9e7634ca2d54faf481c" translate="yes" xml:space="preserve">
          <source>You can tell if using locales is safe on your system by looking at the read-only boolean variable &lt;code&gt;${^SAFE_LOCALES}&lt;/code&gt;. The value is 1 if the perl is not threaded, or if it is using thread-safe locale operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35fb0ec3f2c6e87bec34d10cff3e1fa0aa39f99" translate="yes" xml:space="preserve">
          <source>You can test for these with Perl's &lt;b&gt;-S&lt;/b&gt; file test:</source>
          <target state="translated">您可以使用Perl的&lt;b&gt;-S&lt;/b&gt;文件测试来测试它们：</target>
        </trans-unit>
        <trans-unit id="33cabbc3e6b78a04641195c801755295c5b1770a" translate="yes" xml:space="preserve">
          <source>You can test out changing these variables temporarily, and if the new settings seem to help, put those settings into your shell startup files. Consult your local documentation for the exact details. For Bourne-like shells (&lt;b&gt;sh&lt;/b&gt;, &lt;b&gt;ksh&lt;/b&gt;, &lt;b&gt;bash&lt;/b&gt;, &lt;b&gt;zsh&lt;/b&gt;):</source>
          <target state="translated">您可以临时测试更改这些变量，如果新设置似乎有帮助，请将这些设置放入您的Shell启动文件中。有关详细信息，请查阅您当地的文档。对于类Bourne的壳（&lt;b&gt;sh&lt;/b&gt;，&lt;b&gt;ksh&lt;/b&gt;，&lt;b&gt;bash&lt;/b&gt;，&lt;b&gt;zsh&lt;/b&gt;）：</target>
        </trans-unit>
        <trans-unit id="9aef87ade0298c8e39a512c631e34755f8d99a1d" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; .</source>
          <target state="translated">您可以测试SV是否通过 &lt;code&gt;SvIsCOW(sv)&lt;/code&gt; 使用写时复制。</target>
        </trans-unit>
        <trans-unit id="397833f042c8b1f602c31dae872891a03b284f7c" translate="yes" xml:space="preserve">
          <source>You can test whether an SV is using copy-on-write with &lt;code&gt;SvIsCOW(sv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7b765496cd5db87bb4e9bf905826761c1ac026" translate="yes" xml:space="preserve">
          <source>You can therefore save time by reusing this object as follows;</source>
          <target state="translated">因此,你可以通过重复使用这个对象来节省时间,如下所示。</target>
        </trans-unit>
        <trans-unit id="9025bea13f42c28d6d27d405ef555cfdfb67e0c5" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">您可以将 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 视为 &lt;code&gt;typeof&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="cf104869dd9c15f6376b764dcf7d585d45ca8039" translate="yes" xml:space="preserve">
          <source>You can think of &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; as a &lt;code&gt;typeof&lt;/code&gt; operator.</source>
          <target state="translated">您可以将 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 视为 &lt;code&gt;typeof&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="728882433c08d9f5799a415b920db42fb16d9b1c" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/&lt;/a&gt; .</source>
          <target state="translated">您可以将模块视为可重复使用的Perl代码的基本单位；有关详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。每当有人创建对自己的世界有用的大量Perl代码时，他们都会在&lt;a href=&quot;http://www.cpan.org/modules/04pause.html&quot;&gt;http://www.cpan.org/modules/04pause.html上&lt;/a&gt;注册为Perl开发人员，以便随后将其代码上传到CPAN。CPAN是综合Perl存档网络，可以从&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;进行访问，也可以在&lt;a href=&quot;http://search.cpan.org/&quot;&gt;http://search.cpan.org/进行&lt;/a&gt;搜索。</target>
        </trans-unit>
        <trans-unit id="f66f02858677c3e7654c4ad6291c3ba16be82841" translate="yes" xml:space="preserve">
          <source>You can think of a module as the fundamental unit of reusable Perl code; see &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details. Whenever anyone creates a chunk of Perl code that they think will be useful to the world, they register as a Perl developer at &lt;a href=&quot;https://www.cpan.org/modules/04pause.html&quot;&gt;https://www.cpan.org/modules/04pause.html&lt;/a&gt; so that they can then upload their code to the CPAN. The CPAN is the Comprehensive Perl Archive Network and can be accessed at &lt;a href=&quot;https://www.cpan.org/&quot;&gt;https://www.cpan.org/&lt;/a&gt; , and searched at &lt;a href=&quot;https://metacpan.org/&quot;&gt;https://metacpan.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f96d8ec4df0c71d177e6b1625408e665ae979" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , and &lt;code&gt;EXISTS&lt;/code&gt; . For example,</source>
          <target state="translated">您可以将缓存表绑定到任何想要的绑定哈希，只要它支持 &lt;code&gt;TIEHASH&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; ， &lt;code&gt;STORE&lt;/code&gt; 和 &lt;code&gt;EXISTS&lt;/code&gt; 即可。例如，</target>
        </trans-unit>
        <trans-unit id="067fb5762580d2bd9d11414d9eb17e488c70c98d" translate="yes" xml:space="preserve">
          <source>You can tie the cache tables to any sort of tied hash that you want to, as long as it supports &lt;code&gt;TIEHASH&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt;, &lt;code&gt;STORE&lt;/code&gt;, and &lt;code&gt;EXISTS&lt;/code&gt;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dff5882ff33a85a3a95fb0e709084606bfc8485" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Filter::* from CPAN, or Filter::Util::Call and Filter::Simple since Perl 5.8). But crackers might be able to decrypt it. You can try using the byte code compiler and interpreter described below, but crackers might be able to de-compile it. You can try using the native-code compiler described below, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (this is true of every language, not just Perl).</source>
          <target state="translated">你可以尝试通过源码过滤器(CPAN中的Filter::*,或Perl 5.8以来的Filter::Util::Call和Filter::Simple)使用加密。但破解者可能会解密它。你可以尝试使用下面描述的字节码编译器和解释器,但破解者可能会对它进行反编译。你可以尝试使用下面描述的本机代码编译器,但是破解者可能会对它进行反汇编。这些对想要获取你的代码的人构成了不同程度的困难,但都不能明确地隐藏它(这对每一种语言都是如此,不仅仅是Perl)。</target>
        </trans-unit>
        <trans-unit id="bd149095683892a2c8050e33a089a96e4ba58ba3" translate="yes" xml:space="preserve">
          <source>You can try using encryption via source filters (Starting from Perl 5.8 the Filter::Simple and Filter::Util::Call modules are included in the standard distribution), but any decent programmer will be able to decrypt it. You can try using the byte code compiler and interpreter described later in &lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3&lt;/a&gt;, but the curious might still be able to de-compile it. You can try using the native-code compiler described later, but crackers might be able to disassemble it. These pose varying degrees of difficulty to people wanting to get at your code, but none can definitively conceal it (true of every language, not just Perl).</source>
          <target state="translated">您可以尝试通过源过滤器使用加密（从Perl 5.8开始，标准分发中包括Filter :: Simple和Filter :: Util :: Call模块），但是任何体面的程序员都可以对其进行解密。您可以尝试使用稍后在&lt;a href=&quot;perlfaq3&quot;&gt;perlfaq3中&lt;/a&gt;描述的字节码编译器和解释器，但好奇的人仍然可以对其进行反编译。您可以尝试使用稍后描述的本机代码编译器，但破解者可能会对其进行反汇编。这些给想要使用您的代码的人们带来了不同程度的困难，但是没有人能够明确地隐藏它（每种语言都适用，而不仅仅是Perl）。</target>
        </trans-unit>
        <trans-unit id="2b09b812e89e288611a3620bc913b5b1b0fe4650" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt; . For example:</source>
          <target state="translated">您可以通过使用关键字 &lt;code&gt;RAWDATA&lt;/code&gt; 声明属性处理程序来关闭急切的帮助。例如：</target>
        </trans-unit>
        <trans-unit id="411d0a05d6b5a0d470da1b804c20182fb7f3b7be" translate="yes" xml:space="preserve">
          <source>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword &lt;code&gt;RAWDATA&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49d0ea6561f21345168a93b25795d827d9b3e56" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#%28%3F%23text%29&quot;&gt;&quot;(?#text)&quot;&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5701868a13c5d43cf7a782ca599e3f4284f18bb" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#(%3f%23text)&quot;&gt;(?#text)&lt;/a&gt; to create a comment that ends earlier than the end of the current line, but &lt;code&gt;text&lt;/code&gt; also can't contain the closing delimiter unless escaped with a backslash.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#(%3f%23text)&quot;&gt;（？#text）&lt;/a&gt;创建一个比当前行的结尾更早结束的注释，但是 &lt;code&gt;text&lt;/code&gt; 也不能包含结束定界符，除非使用反斜杠进行转义。</target>
        </trans-unit>
        <trans-unit id="46e1962292f1a1a38164468a62659371a7ced694" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d944fb3215d0dd16d4105b924d26c8f26a00944" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; to find out if a given property is one which has a restricted set of values, and if so, what those values are. But usually each value actually has several synonyms. For example, in Unicode binary properties,</source>
          <target state="translated">您可以使用&lt;a href=&quot;#prop_values()&quot;&gt;prop_values（）&lt;/a&gt;来查找给定的属性是否具有一组受限制的值，如果是，则这些值是什么。但是通常每个值实际上都有几个同义词。例如，在Unicode二进制属性中，</target>
        </trans-unit>
        <trans-unit id="53b328e86a1c8561fad7e05704d7dac310eecbe7" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c9a75863cb6d9c190a426b8b3063cbac50315b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;URI::Find&quot;&gt;URI::Find&lt;/a&gt; or &lt;a href=&quot;URL::Search&quot;&gt;URL::Search&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53d0563bc5da053955b9d3b7d437fbd188f8795" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt; to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt;分隔数字中的位置。它为那些想插入句点（实际上是他们想要使用的其他任何东西）的人处理语言环境信息。</target>
        </trans-unit>
        <trans-unit id="49f5dd665c5e9d2b71ecb4caa05c28940c8fc3d9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI::Find&lt;/a&gt; to extract URLs from an arbitrary text document.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/URI::Find&quot;&gt;URI :: Find&lt;/a&gt;从任意文本文档中提取URL。</target>
        </trans-unit>
        <trans-unit id="7fe2956ea1b7c9e1e517ba013b7204dc28c702c8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt; ) to explicitly disable all the above Unicode features.</source>
          <target state="translated">您可以使用&lt;b&gt;-C0&lt;/b&gt;（或对于 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 为 &lt;code&gt;&quot;0&quot;&lt;/code&gt; ）来显式禁用所有上述Unicode功能。</target>
        </trans-unit>
        <trans-unit id="463dcf8fc0cca782c4e0e34c3ad93d1f8a2e69a8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;-C0&lt;/b&gt; (or &lt;code&gt;&quot;0&quot;&lt;/code&gt; for &lt;code&gt;PERL_UNICODE&lt;/code&gt;) to explicitly disable all the above Unicode features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8820cb36e9b0a2ef9812096c3ae47e4337e70f22" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt; .</source>
          <target state="translated">您可以使用 &lt;code&gt;-w optionname&lt;/code&gt; （无值）作为 &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt; 简写：&lt;i&gt;TRUE&lt;/i&gt;。在开/关功能（例如 &lt;code&gt;-w page_numbering&lt;/code&gt; )的情况下，这大概很有用。</target>
        </trans-unit>
        <trans-unit id="d92d50a80d7de3bbc1a703e905f54b306c769ca9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;-w optionname&lt;/code&gt; (without a value) as shorthand for &lt;code&gt;-w optionname:&lt;i&gt;TRUE&lt;/i&gt;&lt;/code&gt;. This is presumably useful in cases of on/off features like: &lt;code&gt;-w page_numbering&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34722383d4a6c958172dfe61f02074274ede7a9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;).</source>
          <target state="translated">您可以使用不带括号的 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 来定位每个输入文件的末尾，以防您想要追加到每个文件，或者重置行号（请参阅&lt;a href=&quot;functions/eof&quot;&gt;eof中的&lt;/a&gt;示例）。</target>
        </trans-unit>
        <trans-unit id="7509178f0cc142ffa6970d993aa78a311665535a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="translated">如果列之间用空格或其他分隔符分隔，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; ，只要空格或分隔符不能作为数据的一部分出现即可。</target>
        </trans-unit>
        <trans-unit id="6118fe862d5ba72dadefc97ab80da97946efe653" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;eof&lt;/code&gt; without parentheses to locate the end of each input file, in case you want to append to each file, or reset line numbering (see example in &lt;a href=&quot;perlfunc#eof&quot;&gt;&quot;eof&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9d607e237fddf53d59f7e552edb64a49ae50a5" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;no Test2::IPC;&lt;/code&gt; to disable IPC for good. You can also use the T2_NO_IPC env var.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8daea58cf28c3fae97111d40d3f6273a0428003e" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;split&lt;/code&gt; if the columns are separated by whitespace or some other delimiter, as long as whitespace or the delimiter cannot appear as part of the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207bd81996c41f563d70786505a61f566bf7c9d1" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="translated">您可以使用Andreas Koenig的CPAN模块（&lt;a href=&quot;http://www.cpan.org/modules/by-module/CPAN&quot;&gt;http://www.cpan.org/modules/by-module/CPAN&lt;/a&gt;）自动执行以下步骤，从DECOMPRESS到INSTALL。</target>
        </trans-unit>
        <trans-unit id="e7b5250e276d656c30117b7ccc528681aa0fdc2f" translate="yes" xml:space="preserve">
          <source>You can use Andreas Koenig's CPAN module ( &lt;a href=&quot;https://metacpan.org/release/CPAN&quot;&gt;https://metacpan.org/release/CPAN&lt;/a&gt; ) to automate the following steps, from DECOMPRESS through INSTALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a4fa2e9a279c718478efb15dbd58f3963c395b2" translate="yes" xml:space="preserve">
          <source>You can use Perl's somewhat exotic &lt;code&gt;..&lt;/code&gt; operator (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;):</source>
          <target state="translated">您可以使用Perl的 &lt;code&gt;..&lt;/code&gt; 运算符（在&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;中记录）：</target>
        </trans-unit>
        <trans-unit id="0352c7c82515615be31fde318d8a078c0a2c1a97" translate="yes" xml:space="preserve">
          <source>You can use a leading underscore to indicate that a variable or function should not be used outside the package that defined it.</source>
          <target state="translated">你可以使用前导下划线来表示一个变量或函数不应该在定义它的包之外使用。</target>
        </trans-unit>
        <trans-unit id="388231cbd33477282c1e5dc7ff7aa725ad26b114" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt; . This is called a</source>
          <target state="translated">您可以像参考一样使用字符串。如果使用字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 作为数组引用，则将其视为对 &lt;code&gt;@foo&lt;/code&gt; 数组的引用。这叫做</target>
        </trans-unit>
        <trans-unit id="f196929f5477404a496f1eb939b7d7fae56076c9" translate="yes" xml:space="preserve">
          <source>You can use a string as if it were a reference. If you use the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; as an array reference, it's taken to be a reference to the array &lt;code&gt;@foo&lt;/code&gt;. This is called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc3bc3485dafe6de0835e8cb890731728d4f233" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt; . This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="translated">您可以使用&amp;ldquo; =&amp;rdquo;代替&amp;ldquo;：&amp;rdquo;，如： &lt;code&gt;-w textsize=15&lt;/code&gt; 。根据您使用的外壳，这可能更（或​​更少）方便。</target>
        </trans-unit>
        <trans-unit id="574332bc08377fe482a2062d389f5bfcb77e4baa" translate="yes" xml:space="preserve">
          <source>You can use an &quot;=&quot; instead of the &quot;:&quot;, as in: &lt;code&gt;-w textsize=15&lt;/code&gt;. This might be more (or less) convenient, depending on what shell you use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72421369c1a6f65beaf183288338ba69c655cf15" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;&quot;MATH LIBRARY&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659b448e1309e418ec405468f01e562189ac5581" translate="yes" xml:space="preserve">
          <source>You can use an alternative library to drive Math::BigInt. See the section &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;MATH LIBRARY&lt;/a&gt; for more information.</source>
          <target state="translated">您可以使用替代库来驱动Math :: BigInt。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;#MATH-LIBRARY&quot;&gt;数学库&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="f7c7a81f2a96d58e5477ffb42832551e4a65a1ae" translate="yes" xml:space="preserve">
          <source>You can use and redistribute this document under the same terms as Perl itself.</source>
          <target state="translated">您可以在与Perl本身相同的条款下使用和重新发布本文档。</target>
        </trans-unit>
        <trans-unit id="02346143e059d2c6966f5b1da988acae6f664ce7" translate="yes" xml:space="preserve">
          <source>You can use another collation element table if desired.</source>
          <target state="translated">如果需要的话,你可以使用另一个整理元素表。</target>
        </trans-unit>
        <trans-unit id="80ffd7e86ab2f265c3b1b5af5301c88022dfacbd" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods from none to all four.</source>
          <target state="translated">您可以使用从无到所有四种方法的任意组合。</target>
        </trans-unit>
        <trans-unit id="727cc3b9105721ca57e170521deb86b9cfbaaa16" translate="yes" xml:space="preserve">
          <source>You can use any combination of the methods, from none, to all four.</source>
          <target state="translated">您可以使用任何方法的组合,从无到所有四个方法。</target>
        </trans-unit>
        <trans-unit id="d63724145019d1ea36fba22c0caf955250b6107a" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;filter()&lt;/code&gt; or &lt;code&gt;pre_filter()&lt;/code&gt;, depending on your needs. Both have identical syntax, so only &lt;code&gt;filter()&lt;/code&gt; is shown here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf084acc213926a976c0b6e7b2d7ff58c8a1c98" translate="yes" xml:space="preserve">
          <source>You can use formatting codes in ordinary paragraphs, for &lt;b&gt;bold&lt;/b&gt;,</source>
          <target state="translated">您可以在普通段落中使用格式代码，例如&lt;b&gt;粗体&lt;/b&gt;，</target>
        </trans-unit>
        <trans-unit id="7b0f4d35c03dc40ee00f05e56f139894c4c251ca" translate="yes" xml:space="preserve">
          <source>You can use it as follows:</source>
          <target state="translated">您可以按以下方式使用它。</target>
        </trans-unit>
        <trans-unit id="cfbc7862683635b53050e53b7defa0eddc13b749" translate="yes" xml:space="preserve">
          <source>You can use more than one source filter on a single file. Similarly, you can reuse the same filter in as many files as you like.</source>
          <target state="translated">你可以在一个文件上使用一个以上的源过滤器。同样,你也可以在你喜欢的多个文件中重复使用同一个过滤器。</target>
        </trans-unit>
        <trans-unit id="cb2c65d2dbc0740833a918a76d1bf6977975706a" translate="yes" xml:space="preserve">
          <source>You can use parentheses for functions' arguments or omit them according to your personal taste. They are only required occasionally to clarify issues of precedence.</source>
          <target state="translated">你可以根据你的个人喜好为函数的参数使用括号或省略括号。它们只是偶尔需要用来澄清优先级问题。</target>
        </trans-unit>
        <trans-unit id="78045ec633e87e0c82678bcb8abea9b50b38e139" translate="yes" xml:space="preserve">
          <source>You can use that same structure to count the entries any way that you like. If you want the count of the keys with vowels in them, you just test for that instead:</source>
          <target state="translated">你可以用同样的结构来计算你喜欢的任何方式的条目。如果你想知道带有元音的键的数量,你只需要测试一下就可以了。</target>
        </trans-unit>
        <trans-unit id="1690d1523426f507501d7105b1df0c66115ba59a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f3236da7ba1e40bfd7a845e9acaf4bc53886e9" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2ff1d721e6d422eb2eb3595a270ae28f16f631d" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6328463814d0d727ad78cc1185df620969d34550" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd3c53d8040ec103bb8a5c0b0a769aa081bccb4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264d904732b18badb8f8af0ee614fe938cb62fd3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File::Random&lt;/a&gt; module which provides a function for that algorithm:</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/File::Random&quot;&gt;File :: Random&lt;/a&gt;模块，该模块为该算法提供功能：</target>
        </trans-unit>
        <trans-unit id="12dc43addaceb3325735b42235a5db7b043fe8e8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term::ANSIScreen&lt;/a&gt; module to get the special sequence. Import the &lt;code&gt;cls&lt;/code&gt; function (or the &lt;code&gt;:screen&lt;/code&gt; tag):</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ANSIScreen&quot;&gt;Term :: ANSIScreen&lt;/a&gt;模块获取特殊序列。导入 &lt;code&gt;cls&lt;/code&gt; 函数（或 &lt;code&gt;:screen&lt;/code&gt; 标签）：</target>
        </trans-unit>
        <trans-unit id="5e45dc25f4fd438a13c8ce07a9424e43bd367039" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;Time::JulianDay&lt;/a&gt; module available on CPAN. Ensure that you really want to find a Julian day, though, as many people have different ideas about Julian days (see &lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt; for instance):</source>
          <target state="translated">您可以使用CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/Time::JulianDay&quot;&gt;Time :: JulianDay&lt;/a&gt;模块。不过，请确保您确实想找到儒略日，因为许多人对儒略日有不同的想法（例如，请参见&lt;a href=&quot;http://www.hermetic.ch/cal_stud/jdn.htm&quot;&gt;http://www.hermetic.ch/cal_stud/jdn.htm&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ba1788ef1bedfa0514aebf9080742800f7823493" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, part of the Standard Library, which can convert a date/time to a Julian Day:</source>
          <target state="translated">您可以使用标准库中的&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;模块，该模块可以将日期/时间转换为儒略日：</target>
        </trans-unit>
        <trans-unit id="19bff3f43fe0160ae5712a54b49b7225e08cf437" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; variable to detect if you are currently in the global destruction phase:</source>
          <target state="translated">您可以使用 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 变量来检测您当前是否处于全局销毁阶段：</target>
        </trans-unit>
        <trans-unit id="c3b01f73c25a67d7de0988508e3d6a08d549191f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keyword to fall through from one case to the next:</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 关键字从一种情况转到另一种情况：</target>
        </trans-unit>
        <trans-unit id="0512ec103381f142d5cd53ad55c41fe8a57f36b8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $array[$idx]&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $hash{key}&lt;/code&gt; 构造来删除当前块的复合类型条目，并在结束时恢复它。它们在本地化之前返回数组/哈希值，这意味着它们分别等效于</target>
        </trans-unit>
        <trans-unit id="e75c67446fa3d94c780e921da6acd4affb168a6f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="translated">您可以在标量上下文中使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; 内置函数来找出哈希表中有很多条目：</target>
        </trans-unit>
        <trans-unit id="32a43fdc7d4ed02e813e0075b65927b5536f01d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; functions to reset &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="translated">您可以使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 功能来重设 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 键。要简单地重置 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器使用的迭代器而不做其他任何事情，请在void上下文中使用其中一个：</target>
        </trans-unit>
        <trans-unit id="91d95a3ba11b677c44eabfc4c39139686174c03a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt; . Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">您可以使用 &lt;code&gt;END&lt;/code&gt; 块来模拟 &lt;code&gt;atexit()&lt;/code&gt; 。程序或线程结束时，将调用每个程序包的 &lt;code&gt;END&lt;/code&gt; 块。有关 &lt;code&gt;END&lt;/code&gt; 块的更多详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;联机帮助页。</target>
        </trans-unit>
        <trans-unit id="4356379b81876248477b6f357e68e2915cc3c4a7" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;END&lt;/code&gt; block to simulate &lt;code&gt;atexit()&lt;/code&gt;. Each package's &lt;code&gt;END&lt;/code&gt; block is called when the program or thread ends. See the &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; manpage for more details about &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf833c1822dba958c8327441530b019e90d9f3c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23320d34367d7c8e19c4f3b2648a39107aaceafc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Text::Soundex&lt;/code&gt; module. If you want to do fuzzy or close matching, you might also try the &lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String::Approx&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text::Metaphone&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text::DoubleMetaphone&lt;/a&gt; modules.</source>
          <target state="translated">您可以使用 &lt;code&gt;Text::Soundex&lt;/code&gt; 模块。如果要进行模糊匹配或紧密匹配，也可以尝试使用&lt;a href=&quot;http://search.cpan.org/perldoc/String::Approx&quot;&gt;String :: Approx&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Metaphone&quot;&gt;Text :: Metaphone&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Text::DoubleMetaphone&quot;&gt;Text :: DoubleMetaphone&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="488d88c32abab4c7103bc8a9f7d995aca32467c4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;UNIVERSAL&lt;/code&gt; class (see &lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;). However, please be very careful to consider the consequences of doing this: adding methods to every object is very likely to have unintended consequences. If possible, it would be better to have all your object inherit from some common base class, or to use an object system like Moose that supports roles.</source>
          <target state="translated">您可以使用 &lt;code&gt;UNIVERSAL&lt;/code&gt; 类（请参阅&lt;a href=&quot;universal&quot;&gt;UNIVERSAL&lt;/a&gt;）。但是，请非常谨慎地考虑这样做的后果：向每个对象添加方法很可能会产生意想不到的后果。如果可能的话，最好让所有对象都从某个通用基类继承，或者使用支持角色的Moose这样的对象系统。</target>
        </trans-unit>
        <trans-unit id="9e82c1f5d6a6827f8e16779cc47df9c04d7d8adc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;\[]&lt;/code&gt; backslash group notation to specify more than one allowed argument type. For example:</source>
          <target state="translated">您可以使用 &lt;code&gt;\[]&lt;/code&gt; 反斜杠组表示法指定多个允许的参数类型。例如：</target>
        </trans-unit>
        <trans-unit id="29a5b3337e458ba95bc1ff4b8a89d182c9528c72" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt; .</source>
          <target state="translated">您可以使用 &lt;code&gt;break&lt;/code&gt; 关键字突破封闭的 &lt;code&gt;given&lt;/code&gt; 块。每个 &lt;code&gt;when&lt;/code&gt; 块都以 &lt;code&gt;break&lt;/code&gt; 隐式结束。</target>
        </trans-unit>
        <trans-unit id="bba1699dbcdd0690079aefe9fd9ab593286631dc" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;break&lt;/code&gt; keyword to break out of the enclosing &lt;code&gt;given&lt;/code&gt; block. Every &lt;code&gt;when&lt;/code&gt; block is implicitly ended with a &lt;code&gt;break&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949c9a5e3f3716d2943d21cb6815e4a1eba07109" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;continue&lt;/code&gt; keyword to fall through from one case to the next immediate &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5ebdd2538225dc5126d819377dd6fa733157f0" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;delete local $array[$idx]&lt;/code&gt; and &lt;code&gt;delete local $hash{key}&lt;/code&gt; constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="424781ac9f1048ec292a7a68c49b74676d773d63" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;keys()&lt;/code&gt; built-in function in scalar context to find out have many entries you have in a hash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6ffcfb4d7d7a8b446a2b5b6c864d29b7abf92a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;keys&lt;/code&gt; or &lt;code&gt;values&lt;/code&gt; functions to reset &lt;code&gt;each&lt;/code&gt;. To simply reset the iterator used by &lt;code&gt;each&lt;/code&gt; without doing anything else, use one of them in void context:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6268ce8a22314d30cc236ac406a7320d8f9ec" translate="yes" xml:space="preserve">
          <source>You can use the Configure script in non-interactive mode too. When I built my</source>
          <target state="translated">你也可以在非交互模式下使用配置脚本。当我建立我的</target>
        </trans-unit>
        <trans-unit id="a88ac92f15e86bfef2bc330f6e37cbdfaa5d2949" translate="yes" xml:space="preserve">
          <source>You can use the POSIX character class syntax &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; documented in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;perlre&quot;&gt;perlre中&lt;/a&gt;记录的POSIX字符类语法 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; :::: ]] /。</target>
        </trans-unit>
        <trans-unit id="e278d58c9ab507fbb7f9453e431896c65ad5fd6f" translate="yes" xml:space="preserve">
          <source>You can use the SDK by exporting some additions to Perl's 'ccflags' and '..flags' config variables:</source>
          <target state="translated">你可以使用SDK向Perl的'ccflags'和'.flags'配置变量导出一些附加功能。</target>
        </trans-unit>
        <trans-unit id="2cbe3a7e5b8b2c8d5af954d0911633deaa0d280d" translate="yes" xml:space="preserve">
          <source>You can use the WILDCARD option to enable the debugging output of this subpattern matching. Careful! This can lead to voluminous outputs, and it may not make much sense to you what and why Perl is doing what it is. But it may be helpful to you to see why things aren't going the way you expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcba1d434e18427e8484e54d9e14e5566e79c6d1" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;.</source>
          <target state="translated">您可以对大多数文件句柄使用内置的 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc()&lt;/a&gt;&lt;/code&gt; 函数，但在终端设备上无法（轻松）使用。对于STDIN，请使用CPAN的Term :: ReadKey模块或使用&lt;a href=&quot;functions/getc&quot;&gt;getc中&lt;/a&gt;的示例代码。</target>
        </trans-unit>
        <trans-unit id="576855da70920d778b0c9c1adac6f51a7f5843b4" translate="yes" xml:space="preserve">
          <source>You can use the builtin &lt;code&gt;getc()&lt;/code&gt; function for most filehandles, but it won't (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad23301638fa59a074f7b5a830adc451b7882aec" translate="yes" xml:space="preserve">
          <source>You can use the debugger's &lt;code&gt;x&lt;/code&gt; command to dump out complex data structures. For example, given the assignment to $AoA above, here's the debugger output:</source>
          <target state="translated">您可以使用调试器的 &lt;code&gt;x&lt;/code&gt; 命令转储复杂的数据结构。例如，给定上面$ AoA的分配，这是调试器的输出：</target>
        </trans-unit>
        <trans-unit id="26aa247b07d1815cd4598322a5a4fc92732d8a40" translate="yes" xml:space="preserve">
          <source>You can use the file handle returned by &lt;code&gt;vmsopen&lt;/code&gt; just as you would any other Perl file handle. The class VMS::Stdio ISA IO::File, so you can call IO::File methods using the handle returned by &lt;code&gt;vmsopen&lt;/code&gt;. However, &lt;code&gt;use&lt;/code&gt;ing VMS::Stdio does not automatically &lt;code&gt;use&lt;/code&gt; IO::File; you must do so explicitly in your program if you want to call IO::File methods. This is done to avoid the overhead of initializing the IO::File package in programs which intend to use the handle returned by &lt;code&gt;vmsopen&lt;/code&gt; as a normal Perl file handle only. When the scalar containing a VMS::Stdio file handle is overwritten, &lt;code&gt;undef&lt;/code&gt;d, or goes out of scope, the associated file is closed automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c95e7176a4cdb8eb19d859ce523240b91e0d516f" translate="yes" xml:space="preserve">
          <source>You can use the following types of values for allow:</source>
          <target state="translated">您可以为允许使用以下类型的值。</target>
        </trans-unit>
        <trans-unit id="3ce0a691bebd0b371247224bb7f78a55fdff48f0" translate="yes" xml:space="preserve">
          <source>You can use the four-argument form of sysread to continually add to a buffer. After you add to the buffer, you check if you have a complete line (using your regular expression).</source>
          <target state="translated">你可以使用sysread的四参数形式来不断地添加到缓冲区。在你添加到缓冲区后,你检查是否有完整的行(使用你的正则表达式)。</target>
        </trans-unit>
        <trans-unit id="68293f8666171fe0ed45f0e78671e51ac55dfe3d" translate="yes" xml:space="preserve">
          <source>You can use the open source 7-zip ( &lt;a href=&quot;https://www.7-zip.org/&quot;&gt;https://www.7-zip.org/&lt;/a&gt; ) or the shareware Winzip ( &lt;a href=&quot;https://www.winzip.com&quot;&gt;https://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da343e9c661b7d9b54a6aef1473ed8a755544823" translate="yes" xml:space="preserve">
          <source>You can use the shareware Winzip ( &lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt; ) to decompress and unpack modules.</source>
          <target state="translated">您可以使用共享软件Winzip（&lt;a href=&quot;http://www.winzip.com&quot;&gt;http://www.winzip.com&lt;/a&gt;）解压缩和解压缩模块。</target>
        </trans-unit>
        <trans-unit id="29131242da6a21b6f2efd67a20aaa973ec754794" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">您可以使用替换运算符查找字符对（或字符序列）并将其替换为单个实例。在此替换中，我们在 &lt;code&gt;(.)&lt;/code&gt; 找到一个字符。内存括号将匹配的字符存储在后向引用 &lt;code&gt;\g1&lt;/code&gt; ，我们使用它来要求相同的字符紧随其后。我们用 &lt;code&gt;$1&lt;/code&gt; 的字符替换字符串的该部分。</target>
        </trans-unit>
        <trans-unit id="7f3665d3fee5fef1523abafbe5cde6dfe44f5710" translate="yes" xml:space="preserve">
          <source>You can use the substitution operator to find pairs of characters (or runs of characters) and replace them with a single instance. In this substitution, we find a character in &lt;code&gt;(.)&lt;/code&gt;. The memory parentheses store the matched character in the back-reference &lt;code&gt;\g1&lt;/code&gt; and we use that to require that the same thing immediately follow it. We replace that part of the string with the character in &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56ec6ea26f22e6bec1d13c6dc597e46c1853d2d" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可以将substr（）函数用作左值，在这种情况下，EXPR本身必须是左值。如果分配的长度短于LENGTH，则字符串将缩小；如果分配的长度大于LENGTH，则字符串将增长以容纳它。为了使字符串长度相同，您可能需要使用 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 填充或截断值。</target>
        </trans-unit>
        <trans-unit id="5696279d1bd6b651a532c13cf176bc61670cde27" translate="yes" xml:space="preserve">
          <source>You can use the substr() function as an lvalue, in which case EXPR must itself be an lvalue. If you assign something shorter than LENGTH, the string will shrink, and if you assign something longer than LENGTH, the string will grow to accommodate it. To keep the string the same length, you may need to pad or chop your value using &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可以将substr（）函数用作左值，在这种情况下，EXPR本身必须是左值。如果分配的长度短于LENGTH，则字符串将缩小；如果分配的长度大于LENGTH，则字符串将增长以容纳它。为了使字符串长度相同，您可能需要使用 &lt;code&gt;&lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 填充或截断值。</target>
        </trans-unit>
        <trans-unit id="370c9e4d882e8e3555298091312bb16cb7ba0b14" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;&quot;Laundering and Detecting Tainted Data&quot; in perlsec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfeed36c7e84bfafbf0ea57f25867379b77f770c" translate="yes" xml:space="preserve">
          <source>You can use the tainted() function of the Scalar::Util module, available from CPAN (or included with Perl since release 5.8.0). See also &lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;Laundering and Detecting Tainted Data in perlsec&lt;/a&gt;.</source>
          <target state="translated">您可以使用CPAN提供的Scalar :: Util模块的tainted（）函数（或从5.8.0版开始包含在Perl中）。另请参见&lt;a href=&quot;perlsec#Laundering-and-Detecting-Tainted-Data&quot;&gt;perlsec中的清洗和检测污染数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67ef5a8d9d775587994b1c8525522dac443d6c25" translate="yes" xml:space="preserve">
          <source>You can use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the new filehandle. These affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09d2af0acba58841da7d114d861e093a90573f8a" translate="yes" xml:space="preserve">
          <source>You can use these macros if you call code that may croak, but you need to do some cleanup before giving control back to Perl. For example:</source>
          <target state="translated">如果你调用的代码可能会崩溃,但你需要在把控制权还给Perl之前做一些清理工作,你可以使用这些宏。例如</target>
        </trans-unit>
        <trans-unit id="8d60246dfc629fa2c767c2383b114af7d8fad4bc" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">您可以使用它作为快捷方式来确定在将压缩存档传递给 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法之前， &lt;code&gt;Archive::Tar&lt;/code&gt; 是否会按照您的想法进行操作。</target>
        </trans-unit>
        <trans-unit id="dbd42e35c7b3f7dd461bd372dbf9f5578060d86f" translate="yes" xml:space="preserve">
          <source>You can use this as a shortcut to determine whether &lt;code&gt;Archive::Tar&lt;/code&gt; will do what you think before passing compressed archives to its &lt;code&gt;read&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2583bc76f12f41a833e44f457c707f446ecc90f" translate="yes" xml:space="preserve">
          <source>You can use this class as the base class for a Pod formatter/processor.</source>
          <target state="translated">你可以使用这个类作为Pod格式化/处理器的基础类。</target>
        </trans-unit>
        <trans-unit id="ddc269b809151a32259fd4bfb2f0eaf592a60142" translate="yes" xml:space="preserve">
          <source>You can use this subroutine to get and set the traversal mask for a specific hash. Setting the mask ensures that a given hash will produce the same key order. &lt;b&gt;Note&lt;/b&gt; that this does &lt;b&gt;not&lt;/b&gt; guarantee that &lt;b&gt;two&lt;/b&gt; hashes will produce the same key order for the same hash seed and traversal mask, items that collide into one bucket may have different orders regardless of this setting.</source>
          <target state="translated">您可以使用此子例程获取并设置特定哈希的遍历掩码。设置掩码可确保给定的哈希将产生相同的键顺序。&lt;b&gt;请注意&lt;/b&gt;，这&lt;b&gt;不能&lt;/b&gt;保证&lt;b&gt;两个&lt;/b&gt;散列将为相同的哈希种子和遍历掩码产生相同的键顺序，无论此设置如何，碰撞到一个存储桶中的项可能具有不同的顺序。</target>
        </trans-unit>
        <trans-unit id="3cb82727ce61d8edf5281f6c0ba4e6a9919853bd" translate="yes" xml:space="preserve">
          <source>You can use this to concatenate two scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e57a6a3e1ac0e576a34f1deb9cbe35e8438d88f" translate="yes" xml:space="preserve">
          <source>You can use this to find out whether two handles refer to the same underlying descriptor:</source>
          <target state="translated">你可以用它来找出两个句柄是否指向同一个底层描述符。</target>
        </trans-unit>
        <trans-unit id="e2f6df83e5ac1b378170dbde8b31e8b10cee41f6" translate="yes" xml:space="preserve">
          <source>You can use this to print out all the variables in a package, for instance. The standard but antiquated</source>
          <target state="translated">例如,你可以用它来打印出一个包中的所有变量。标准但陈旧的</target>
        </trans-unit>
        <trans-unit id="2c064b95103461f4732f35fcd238f5be71635622" translate="yes" xml:space="preserve">
          <source>You can use this to record all events AFTER they have been sent to the formatter. No changes made here will be meaningful, except possibly to other listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973b86bb17e6d843653e8421a775f98d4d43a73b" translate="yes" xml:space="preserve">
          <source>You can use this to remove a listen callback. You must pass in the coderef returned by the &lt;code&gt;listen()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fe2602c37d36cd939b3f2966e9882c1457b54a" translate="yes" xml:space="preserve">
          <source>You can use whitespace and the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator to lay them out more nicely:</source>
          <target state="translated">您可以使用空格和 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符来更好地布局它们：</target>
        </trans-unit>
        <trans-unit id="2a2d95bc6981ab5724b117c21adf2c42ff1324ac" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re
'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="translated">您可以观看Perl的正则表达式引擎在工作，以验证Perl是否正在重新编译正则表达式。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 编译（自带的Perl 5.005或更高版本）显示的细节。使用5.6之前的Perls，您应该看到 &lt;code&gt;re&lt;/code&gt; 报告其在每次迭代时都编译正则表达式。在Perl 5.6或更高版本中，您应该只看到在第一次迭代中 &lt;code&gt;re&lt;/code&gt; 报告该报告。</target>
        </trans-unit>
        <trans-unit id="be5157e72fec47ccda29a3884d0d6aa69a038c22" translate="yes" xml:space="preserve">
          <source>You can watch Perl's regular expression engine at work to verify for yourself if Perl is recompiling a regular expression. The &lt;code&gt;use re 'debug'&lt;/code&gt; pragma (comes with Perl 5.005 and later) shows the details. With Perls before 5.6, you should see &lt;code&gt;re&lt;/code&gt; reporting that its compiling the regular expression on each iteration. With Perl 5.6 or later, you should only see &lt;code&gt;re&lt;/code&gt; report that for the first iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95a7534126966a35fdb290a82cc3eb90110d990" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt; ) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="translated">您可以通过在需要局部值的地方使用全限定名（ &lt;code&gt;$Package::FOO&lt;/code&gt; ）来解决第一种情况，也可以通过在脚本中说 &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; 来覆盖它。</target>
        </trans-unit>
        <trans-unit id="5d9ed6d1d4bf51c3f2d48b808ade1c9eb6d3e68f" translate="yes" xml:space="preserve">
          <source>You can work around the first case by using the fully qualified name (&lt;code&gt;$Package::FOO&lt;/code&gt;) where you need a local value, or by overriding it by saying &lt;code&gt;*FOO = *Package::FOO&lt;/code&gt; in your script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74896a00006c71879750ed85d659cbff45ee1a05" translate="yes" xml:space="preserve">
          <source>You can write this by hand or generate it with 'make manifest'.</source>
          <target state="translated">你可以用手写,也可以用'make manifest'生成。</target>
        </trans-unit>
        <trans-unit id="b1c2fce28dbd805f8d7a870a949b6c5834632bf2" translate="yes" xml:space="preserve">
          <source>You can write this more briefly using a grep, which does the same thing.</source>
          <target state="translated">你可以用grep写得更简单一些,它的作用是一样的。</target>
        </trans-unit>
        <trans-unit id="abb98a8eca7d1aa69e5a0eb195e9e9713bd18c72" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt; , and don't use octal notation at all.</source>
          <target state="translated">您可以像编写ASCII平台上的人一样编写正则表达式。但是请记住，使用八进制或十六进制表示法来指定特定的代码点将为您提供EBCDIC代码页本机映射到它的字符。（对于所有双引号字符串也是如此。）如果您想进行可移植的编写，则只需在可能使用 &lt;code&gt;\x{...}&lt;/code&gt; 地方使用 &lt;code&gt;\N{U+...}&lt;/code&gt; 表示法，不要完全使用八进制表示法。</target>
        </trans-unit>
        <trans-unit id="7d266b91c488913460baf4dd560ddccb0fd29aed" translate="yes" xml:space="preserve">
          <source>You can write your regular expressions just like someone on an ASCII platform would do. But keep in mind that using octal or hex notation to specify a particular code point will give you the character that the EBCDIC code page natively maps to it. (This is also true of all double-quoted strings.) If you want to write portably, just use the &lt;code&gt;\N{U+...}&lt;/code&gt; notation everywhere where you would have used &lt;code&gt;\x{...}&lt;/code&gt;, and don't use octal notation at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c77e05c4dac877ccb1d3bc62136f650220cc0e0" translate="yes" xml:space="preserve">
          <source>You can't (directly) write a recursive lexical subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94e5e7086b787cf553633de7398d82024090d60" translate="yes" xml:space="preserve">
          <source>You can't (easily) have any space in front of the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62834a834066a3093a80c93ec315493101e7f82e" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt; , whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="translated">您不能说 &lt;code&gt;\{1}000&lt;/code&gt; 来消除歧义，而可以用 &lt;code&gt;${1}000&lt;/code&gt; 来解决。插值操作不应与匹配后向引用的操作混淆。当然，它们的意思是两个不同的东西</target>
        </trans-unit>
        <trans-unit id="446ed284a8405938957f84b57096d4442d17377f" translate="yes" xml:space="preserve">
          <source>You can't disambiguate that by saying &lt;code&gt;\{1}000&lt;/code&gt;, whereas you can fix it with &lt;code&gt;${1}000&lt;/code&gt;. The operation of interpolation should not be confused with the operation of matching a backreference. Certainly they mean two different things on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020ca4e878548eed17ca845dc3179b69179a2006" translate="yes" xml:space="preserve">
          <source>You can't do this with the &lt;code&gt;if&lt;/code&gt; pragma; however, you can achieve exactly this effect, at compile time, with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="026d053774b9559119bfc24f712c71285ffb2ad2" translate="yes" xml:space="preserve">
          <source>You can't have =items (as at line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18683b4b76072abbee71a6881cdb8bc575df90f" translate="yes" xml:space="preserve">
          <source>You can't have a hash whose values are arrays; hash values can only be scalars. We're stuck with that. But a single reference can refer to an entire array, and references are scalars, so you can have a hash of references to arrays, and it'll act a lot like a hash of arrays, and it'll be just as useful as a hash of arrays.</source>
          <target state="translated">你不能有一个值是数组的哈希,哈希值只能是标量。我们就只能这样了。但是一个单一的引用可以引用整个数组,而引用是标量,所以你可以有一个数组的引用的哈希,它的作用会很像数组的哈希,而且会和数组的哈希一样有用。</target>
        </trans-unit>
        <trans-unit id="d10d9e535268b6be7a5edad8c961bf0a3eba1a2f" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="translated">您不能阻止人们向您的脚本发送错误的数据。即使您添加了一些客户端检查，人们也可能禁用它们或完全绕开它们。例如，某人可能使用诸如&lt;a href=&quot;http://search.cpan.org/perldoc/LWP&quot;&gt;LWP之类&lt;/a&gt;的模块来提交到您的网站。如果要防止尝试使用SQL注入或其他类型攻击的数据（并且应该这样做），则不必信任进入程序的任何数据。</target>
        </trans-unit>
        <trans-unit id="6424e72f031416bce90e6701fa0fc1986967103a" translate="yes" xml:space="preserve">
          <source>You can't prevent people from sending your script bad data. Even if you add some client-side checks, people may disable them or bypass them completely. For instance, someone might use a module such as &lt;a href=&quot;lwp&quot;&gt;LWP&lt;/a&gt; to submit to your web site. If you want to prevent data that try to use SQL injection or other sorts of attacks (and you should want to), you have to not trust any data that enter your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8673b45bcf51a92e5bbd4f8ac4117b4afa807acf" translate="yes" xml:space="preserve">
          <source>You can't produce a tied constant by giving a tied scalar as the value. References to tied variables, however, can be used as constants without any problems.</source>
          <target state="translated">你不能通过给出一个绑定的标量作为值来产生一个绑定的常量。然而,对绑定变量的引用可以毫无问题地用作常量。</target>
        </trans-unit>
        <trans-unit id="37d171546c154312737dfd62e998eea96bcef04d" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, REGEXP, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="translated">你不能存储GLOB、FORMLINE、REGEXP等......。如果你能为这些操作定义语义,请随意增强Storable,使它能处理这些操作。</target>
        </trans-unit>
        <trans-unit id="67bd9de8b466ae8269d533b74dcf8f4858db7b40" translate="yes" xml:space="preserve">
          <source>You can't store GLOB, FORMLINE, etc.... If you can define semantics for those operations, feel free to enhance Storable so that it can deal with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c681bde3f10285d1065419cbcfdfe8d15a0638" translate="yes" xml:space="preserve">
          <source>You can't take the address of anything, although a similar operator in Perl is the backslash, which creates a reference.</source>
          <target state="translated">你不能取任何东西的地址,尽管在Perl中类似的操作符是反斜杠,它会创建一个引用。</target>
        </trans-unit>
        <trans-unit id="3d03f47a54efdf6a567386eabfcea4dcbcebbcab" translate="yes" xml:space="preserve">
          <source>You can't use a reference to an array or hash in quite the same way that you would a real array or hash. For C or C++ programmers unused to distinguishing between arrays and pointers to the same, this can be confusing. If so, just think of it as the difference between a structure and a pointer to a structure.</source>
          <target state="translated">你不能像使用真实数组或哈希那样使用对数组或哈希的引用。对于不习惯区分数组和指针的C或C++程序员来说,这可能会让他们感到困惑。如果是这样,就把它看作是结构体和指向结构体的指针之间的区别。</target>
        </trans-unit>
        <trans-unit id="f88b12efd9288b17ac8ba038151b3170bc987f73" translate="yes" xml:space="preserve">
          <source>You can't. Some use the UTF8 flag for this, but that's misuse, and makes well behaved modules like Data::Dumper look bad. The flag is useless for this purpose, because it's off when an 8 bit encoding (by default ISO-8859-1) is used to store the string.</source>
          <target state="translated">你不能这样做。有些人使用UTF8标志来实现这个目的,但这是误用,并使Data::Dumper这样的行为良好的模块看起来很糟糕。这个标志对于这个目的来说是无用的,因为当使用8位编码(默认为ISO-8859-1)来存储字符串时,这个标志是关闭的。</target>
        </trans-unit>
        <trans-unit id="2fd8f1486a5edc4ee6dd1a50f986e5205ada1304" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt; . Unfortunately, the non-Unicode string &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="translated">你不能 这是因为UTF-8数据就像非UTF-8数据一样以字节存储。带有重音符号的Unicode字符200（对于十六进制类型为 &lt;code&gt;0xC8&lt;/code&gt; ）大写E由两个字节 &lt;code&gt;v196.172&lt;/code&gt; 表示。不幸的是，非Unicode字符串 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(196).chr(172)&lt;/a&gt;&lt;/code&gt; 也具有该字节序列。因此，您不能仅凭外观就能分辨出来-这就是使Unicode输入成为一个有趣的问题的原因。</target>
        </trans-unit>
        <trans-unit id="7f972addc76fd0cd985b7d4af8bf74af7b31dec1" translate="yes" xml:space="preserve">
          <source>You can't. This is because UTF-8 data is stored in bytes just like non-UTF-8 data. The Unicode character 200, (&lt;code&gt;0xC8&lt;/code&gt; for you hex types) capital E with a grave accent, is represented by the two bytes &lt;code&gt;v196.172&lt;/code&gt;. Unfortunately, the non-Unicode string &lt;code&gt;chr(196).chr(172)&lt;/code&gt; has that byte sequence as well. So you can't tell just by looking -- this is what makes Unicode input an interesting problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a4ed4ed782a30731e5ac82f99a95d222b188b0" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="translated">你不能 您需要模仿 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 调用（有关示例代码，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;），然后为INT信号提供一个信号处理程序，该信号处理程序将信号传递给子进程。或者您可以检查一下：</target>
        </trans-unit>
        <trans-unit id="6e29577f40cc4b8214af8a5686eca5058c2c6b00" translate="yes" xml:space="preserve">
          <source>You can't. You need to imitate the &lt;code&gt;system()&lt;/code&gt; call (see &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for sample code) and then have a signal handler for the INT signal that passes the signal on to the subprocess. Or you can check for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969f4cfd26924af3983dcc03e66552409285562e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="translated">你可以，当然，声明不同的处理器，这些类型以及（但你需要指定 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; warnings 'redefine'&lt;/code&gt; 悄悄地做到这一点）：</target>
        </trans-unit>
        <trans-unit id="9b9ddea33f9624effb8458a53428961e73756f4e" translate="yes" xml:space="preserve">
          <source>You can, of course, declare separate handlers for these types as well (but you'll need to specify &lt;code&gt;no warnings 'redefine'&lt;/code&gt; to do it quietly):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74374dec5e50007a2bb85f4a7c8771f4686fdade" translate="yes" xml:space="preserve">
          <source>You cannot Configure Perl to use long doubles unless you have at least Tru64 V5.0, the long double support simply wasn't functional enough before that. Perl's Configure will override attempts to use the long doubles (you can notice this by Configure finding out that the modfl() function does not work as it should).</source>
          <target state="translated">除非你至少有 Tru64 V5.0,否则你不能 Configure Perl 使用长双倍函数,在那之前长双倍函数的支持功能根本不够。Perl的Configure会覆盖使用长双数的尝试(你可以通过Configure发现modfl()函数不能正常工作来注意到这一点)。</target>
        </trans-unit>
        <trans-unit id="9d01ce1702f639775b361fb520a4a77dd3873994" translate="yes" xml:space="preserve">
          <source>You cannot add a regular filter to a hub if the hub was created in another process or thread. You can always add a pre_filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d8ae48400ed6e2886a4d5be754a09a9e2677eb" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8bdeec288ef204b43d051952afe1296036c485c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_formfeed()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">您不能仅通过静态方法在句柄上调用 &lt;code&gt;format_formfeed()&lt;/code&gt; 。参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="886d6e7860352adfbf36238a2c3195543ecc4842" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206c72a8b7cef7a32a6db021ff310a9ca6c22c22" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;format_line_break_characters()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">您不能仅通过静态方法在句柄上调用 &lt;code&gt;format_line_break_characters()&lt;/code&gt; 。参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e0ebaf2ed18c8c28bbb77a954b42ef5fea55a1b9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be794aed40b9701358348d087034d06f390762c7" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;input_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">您不能仅通过静态方法在句柄上调用 &lt;code&gt;input_record_separator()&lt;/code&gt; 。参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3fbf7abc01d969743407ff802897565a9f2a54c" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9632f1b73e717ca255777fe1c2f39799e45e4a" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_field_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">您不能仅通过静态方法在句柄上调用 &lt;code&gt;output_field_separator()&lt;/code&gt; 。参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c8b5595acc49990fca235aed04153d4258b087b" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3ec65172d98e67d60dc40971034bddc7747e9" translate="yes" xml:space="preserve">
          <source>You cannot call &lt;code&gt;output_record_separator()&lt;/code&gt; on a handle, only as a static method. See &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">您不能仅通过静态方法在句柄上调用 &lt;code&gt;output_record_separator()&lt;/code&gt; 。参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9134fa5f451fb01a8e6eeae9f39b7f5a89fc7ce" translate="yes" xml:space="preserve">
          <source>You cannot change the ordering once the database has been created. Thus you must use the same compare function every time you access the database.</source>
          <target state="translated">一旦数据库被创建,你就不能改变排序。因此,每次访问数据库时必须使用相同的比较功能。</target>
        </trans-unit>
        <trans-unit id="9e33a69a0160e97c284c6f83bf69b3911fb50910" translate="yes" xml:space="preserve">
          <source>You cannot currently get the precision from a specified number, but it is intended that this will be possible in the future, for example using &lt;code&gt;.*2$&lt;/code&gt;:</source>
          <target state="translated">您目前无法从指定的数字中获得精度，但是希望将来可以使用，例如 &lt;code&gt;.*2$&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9a19723c24ab74fcf1cad038cc364f2eed15903b" translate="yes" xml:space="preserve">
          <source>You cannot discern from mere inspection which builtins are unary operators (like chop() and chdir()) and which are list operators (like print() and unlink()). (Unless prototyped, user-defined subroutines can &lt;b&gt;only&lt;/b&gt; be list operators, never unary ones.) See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">仅凭检查无法分辨出哪些内建函数是一元运算符（如chop（）和chdir（）），以及哪些是列表运算符（如print（）和unlink（））。（除非有原型，用户定义的子例程&lt;b&gt;只能&lt;/b&gt;是列表运算符，而不能是一元运算符。）请参见&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab137c3fb7d6e07844b33eb499911ea797677bd5" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One experimental module that does partially attempt to address this need is the MLDBM module. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code to MLDBM.</source>
          <target state="translated">您无法轻松地将多级数据结构（例如哈希散列）绑定到dbm文件。第一个问题是除GDBM和Berkeley DB之外的所有数据库都有大小限制，但是除此之外，在磁盘上如何表示引用也存在问题。 MLDBM模块是部分尝试满足这一需求的实验模块。按照&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib中&lt;/a&gt;所述检查离您最近的CPAN站点，以获取 MLDBM的源代码。</target>
        </trans-unit>
        <trans-unit id="38213a95a75072574eb5ab9364f983653ee56ffc" translate="yes" xml:space="preserve">
          <source>You cannot easily tie a multilevel data structure (such as a hash of hashes) to a dbm file. The first problem is that all but GDBM and Berkeley DB have size limitations, but beyond that, you also have problems with how references are to be represented on disk. One module that does attempt to address this need is DBM::Deep. Check your nearest CPAN site as described in &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for source code. Note that despite its name, DBM::Deep does not use dbm. Another earlier attempt at solving the problem is MLDBM, which is also available on the CPAN, but which has some fairly serious limitations.</source>
          <target state="translated">您无法轻松地将多级数据结构（例如哈希散列）绑定到dbm文件。第一个问题是除GDBM和Berkeley DB之外的所有数据库都有大小限制，但是除此之外，在磁盘上如何表示引用也存在问题。可以满足这一需求的模块之一就是DBM :: Deep。按照&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib中的说明&lt;/a&gt;检查离您最近的CPAN站点以获取源代码。请注意，尽管其名称为DBM :: Deep也不使用dbm。解决该问题的另一种较早的尝试是MLDBM，它也可以在CPAN上使用，但是有一些相当严重的局限性。</target>
        </trans-unit>
        <trans-unit id="54808a204fe862b1dfa25e752a892b2a04ab63bf" translate="yes" xml:space="preserve">
          <source>You cannot get stack frame information or in any fashion debug functions that were not compiled by Perl, such as those from C or C++ extensions.</source>
          <target state="translated">你不能获取堆栈框架信息,也不能以任何方式调试那些不是由Perl编译的函数,比如那些来自C或C++扩展的函数。</target>
        </trans-unit>
        <trans-unit id="b370a3f9299c4f8abb35adc5b9b2b86568a00bc8" translate="yes" xml:space="preserve">
          <source>You cannot lock the individual elements of a container variable:</source>
          <target state="translated">你不能锁定容器变量的各个元素。</target>
        </trans-unit>
        <trans-unit id="f2b8b7a26c050e538a292ea22f61da0581625210" translate="yes" xml:space="preserve">
          <source>You cannot portably &quot;stack&quot; cpp directives. For example in the above you need two separate BURGLE() #defines, one for each #ifdef branch.</source>
          <target state="translated">你不能移植 &quot;堆栈 &quot;cpp指令。例如在上面的例子中,你需要两个独立的 BURGLE()#定义,每个 #ifdef 分支都需要一个。</target>
        </trans-unit>
        <trans-unit id="b918f134e01ab04a493d865bacd0ad2555d6eed0" translate="yes" xml:space="preserve">
          <source>You cannot set $RS to a pattern, only a string.</source>
          <target state="translated">您不能将$RS设置为一个模式,只能是一个字符串。</target>
        </trans-unit>
        <trans-unit id="891970fccef081510b98291902ea82121168e7ae" translate="yes" xml:space="preserve">
          <source>You cannot tie this routine directly to an option, e.g.:</source>
          <target state="translated">你不能将这个例程直接绑定到一个选项上,例如。</target>
        </trans-unit>
        <trans-unit id="2d9b5eae243979aa930fce2644c85c94e98e03e5" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;b&gt;-i&lt;/b&gt; to create directories or to strip extensions from files.</source>
          <target state="translated">您不能使用&lt;b&gt;-i&lt;/b&gt;创建目录或从文件中删除扩展名。</target>
        </trans-unit>
        <trans-unit id="3d40633e0023663f60f6c6868c36efce9e85c50a" translate="yes" xml:space="preserve">
          <source>You compare the sort keys using a binary comparison and get the result of the comparison of the strings using UCA.</source>
          <target state="translated">你用二进制比较来比较排序键,用UCA得到字符串的比较结果。</target>
        </trans-unit>
        <trans-unit id="794fe9a7963db4b15645c3e75175ca30a42e7c02" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt; , if you don't need it, by</source>
          <target state="translated">您也可以排除 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ，如果不需要的话</target>
        </trans-unit>
        <trans-unit id="7f8b90476595b6a38493d09d09f4d09a3ee84510" translate="yes" xml:space="preserve">
          <source>You could also exclude &lt;code&gt;LC_NUMERIC&lt;/code&gt;, if you don't need it, by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63946de92748533808fd29d4342bd54a0ec7a953" translate="yes" xml:space="preserve">
          <source>You could also have used the existing block property names:</source>
          <target state="translated">你也可以使用现有的块属性名称。</target>
        </trans-unit>
        <trans-unit id="eaa54d59d0ed5e55dbc530f16d131415959a1711" translate="yes" xml:space="preserve">
          <source>You could also investigate the can() method in the UNIVERSAL class (part of the standard perl distribution).</source>
          <target state="translated">你也可以研究一下UNIVERSAL类中的can()方法(标准perl发行版的一部分)。</target>
        </trans-unit>
        <trans-unit id="802dff37470d190b2a864a13c708bc5907b98d91" translate="yes" xml:space="preserve">
          <source>You could also just know all the perl errors, and although there are some people who may know all of them, you probably don't. However, they all should be in the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; manpage. If you don't find the error in there, it probably isn't a perl error.</source>
          <target state="translated">您也可能只知道所有perl错误，尽管有些人可能知道所有这些错误，但您可能不知道。但是，它们都应该在&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;联机帮助页中。如果您没有在其中找到错误，则可能不是perl错误。</target>
        </trans-unit>
        <trans-unit id="80d2dd3ba7c4c2069cf58261b6aaeb6dcd467d24" translate="yes" xml:space="preserve">
          <source>You could also write a single get/set method using an optional argument:</source>
          <target state="translated">你也可以使用一个可选的参数写一个单一的get/set方法。</target>
        </trans-unit>
        <trans-unit id="8444b9fc7a3ed8d2fa7659ffde996510ee7f1f46" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;) is a better option.</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;和自己的代码来构建网站，但是对于非常基本的网站以外的其他任何情况，使用Web框架（使用&lt;a href=&quot;http://search.cpan.org/perldoc/Plack&quot;&gt;Plack&lt;/a&gt;）则是更好的选择。</target>
        </trans-unit>
        <trans-unit id="5c2c9c77f0aed52ec579ee2ac823c3d0735f4eb0" translate="yes" xml:space="preserve">
          <source>You could build a web site using &lt;a href=&quot;plack&quot;&gt;Plack&lt;/a&gt; and your own code, but for anything other than a very basic web site, using a web framework (that uses &lt;a href=&quot;https://plackperl.org&quot;&gt;https://plackperl.org&lt;/a&gt;) is a better option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2158ae7a8b9ea3f34a07fb0e90c3b98892665dc8" translate="yes" xml:space="preserve">
          <source>You could conceivably do both.</source>
          <target state="translated">可以想象,你可以两者兼得。</target>
        </trans-unit>
        <trans-unit id="49073618f97078f446e251732bebc1a46a9b86b9" translate="yes" xml:space="preserve">
          <source>You could do the memoization yourself, by rewriting the function, like this:</source>
          <target state="translated">你可以自己做备忘,重写函数,像这样。</target>
        </trans-unit>
        <trans-unit id="958608f6d5208c278d0f2a3422ee32f9617b3a57" translate="yes" xml:space="preserve">
          <source>You could do this through opening an ordinary filehandle into each of those files, gradually building up an in-memory array of all the file contents you load this way, and finally sorting and filtering that array when you've run out of files to load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bc28868b949ea5a73ffcd10a5a6d7af5c6ab02" translate="yes" xml:space="preserve">
          <source>You could do this:</source>
          <target state="translated">你可以这样做。</target>
        </trans-unit>
        <trans-unit id="9e128ecfca5b0e265baad327ad431d782e5e7ffc" translate="yes" xml:space="preserve">
          <source>You could edit that header yourself to remove that last '/', or you might note that Language Environment (LE) APAR PQ39997 describes the problem and PTF's UQ46272 and UQ46271 are the (R8 at least) fixes and apply them. If left unattended that syntax error will turn up as an inability for Perl to build its &quot;Socket&quot; extension.</source>
          <target state="translated">你可以自己编辑那个头来删除最后的 '/',或者你可以注意语言环境 (LE)APAR PQ39997 描述了这个问题,而 PTF 的 UQ46272 和 UQ46271 则是 (至少是 R8)修复方法并应用它们。如果不加以注意,该语法错误将变成Perl无法构建其 &quot;Socket &quot;扩展。</target>
        </trans-unit>
        <trans-unit id="3e7ad6be7d9fb2b01433fa3be5444bc3be8a1d7d" translate="yes" xml:space="preserve">
          <source>You could instead do lookups on $wanted with:</source>
          <target state="translated">你可以用以下方法对$wanted进行查找。</target>
        </trans-unit>
        <trans-unit id="457f8e624ad1da28bfb9cf34b1f79dc6623d16da" translate="yes" xml:space="preserve">
          <source>You could just store all your dates as a number and then subtract. Life isn't always that simple though.</source>
          <target state="translated">你可以把所有的日期都存成一个数字,然后再减去。不过生活并不总是那么简单。</target>
        </trans-unit>
        <trans-unit id="c19f6ab6291cf9eaf2e211ed563b35ea9ac437b5" translate="yes" xml:space="preserve">
          <source>You could open the document in a web browser, and change the character set or character encoding until you can visually confirm that all characters look the way they should.</source>
          <target state="translated">你可以在网络浏览器中打开文档,然后改变字符集或字符编码,直到你能直观地确认所有字符看起来都是这样。</target>
        </trans-unit>
        <trans-unit id="6bbc1dc32472d30736fd70aa0522d187dae0801f" translate="yes" xml:space="preserve">
          <source>You could tell make to run tests in both of those directories with the following directives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a20c232c667e613d02f2b4874878f40bc6c28f2" translate="yes" xml:space="preserve">
          <source>You could write the last two using the &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-d&lt;/code&gt; operators. Commonly available &lt;code&gt;S_IF*&lt;/code&gt; constants are:</source>
          <target state="translated">您可以使用 &lt;code&gt;-u&lt;/code&gt; 和 &lt;code&gt;-d&lt;/code&gt; 运算符编写最后两个。常用的 &lt;code&gt;S_IF*&lt;/code&gt; 常量为：</target>
        </trans-unit>
        <trans-unit id="2516f9cbf3f3333565923611bf8e4c6225451c64" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; . Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt; , and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt; . A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="translated">您使用 &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt; 创建队列。然后，您可以使用 &lt;code&gt;enqueue()&lt;/code&gt; 将标量列表添加到末尾，并使用 &lt;code&gt;dequeue()&lt;/code&gt; 将标量列表弹出其最前面。队列没有固定的大小，并且可以根据需要增长以容纳推送到它的所有内容。</target>
        </trans-unit>
        <trans-unit id="c19ccf2bc39b48b6ea782f37420e2fd0ec94934e" translate="yes" xml:space="preserve">
          <source>You create the queue with &lt;code&gt;Thread::Queue-&amp;gt;new()&lt;/code&gt;. Then you can add lists of scalars onto the end with &lt;code&gt;enqueue()&lt;/code&gt;, and pop scalars off the front of it with &lt;code&gt;dequeue()&lt;/code&gt;. A queue has no fixed size, and can grow as needed to hold everything pushed on to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dede4110b8ccb447bd7101130015f76cda530da1" translate="yes" xml:space="preserve">
          <source>You currently don't need to instantiate a factory in order to use it.</source>
          <target state="translated">目前你不需要实例化工厂就可以使用它。</target>
        </trans-unit>
        <trans-unit id="94aa24e74566493da77121fdf1cf79a43455f271" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt; . See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您没有运行 &lt;code&gt;omflibs&lt;/code&gt; 。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="520c8e979cd55500908dc61d154b50983c533336" translate="yes" xml:space="preserve">
          <source>You did not run &lt;code&gt;omflibs&lt;/code&gt;. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="351e72fc696e530c4b98b81dced35a153aee9b73" translate="yes" xml:space="preserve">
          <source>You did try the &lt;b&gt;-w&lt;/b&gt; switch, didn't you?</source>
          <target state="translated">您确实尝试了&lt;b&gt;-w&lt;/b&gt;开关，不是吗？</target>
        </trans-unit>
        <trans-unit id="4eedca5e5af0ab78e40eb2863f783568ef2a973d" translate="yes" xml:space="preserve">
          <source>You do have &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; enabled, don't you?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ae653a2469feaccaacebc0c4775e33fd1da464" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt; . The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="translated">您确实需要注意代表进程永久文件的逻辑名，例如 &lt;code&gt;SYS$INPUT&lt;/code&gt; 和 &lt;code&gt;SYS$OUTPUT&lt;/code&gt; 。这些逻辑名的转换之前带有两个字节的二进制值（0x1B 0x00），如果要使用它，则需要将其删除。（在以前的Perl版本中，无法获得这些逻辑名的值，因为空字节充当字符串结尾标记）</target>
        </trans-unit>
        <trans-unit id="50985c33eacad99671dfcb8dd8006db36d362e65" translate="yes" xml:space="preserve">
          <source>You do need to be careful with the logical names representing process-permanent files, such as &lt;code&gt;SYS$INPUT&lt;/code&gt; and &lt;code&gt;SYS$OUTPUT&lt;/code&gt;. The translations for these logical names are prepended with a two-byte binary value (0x1B 0x00) that needs to be stripped off if you want to use it. (In previous versions of Perl it wasn't possible to get the values of these logical names, as the null byte acted as an end-of-string marker)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="058b0924bf8d4ec16b563bbf0577363645a7bf62" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">您不调用 &lt;code&gt;setlogsock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66b3b57985e95259e75aa2f231d8ac7e67d53cd1" translate="yes" xml:space="preserve">
          <source>You do not call &lt;code&gt;setlogsock&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0688f744612cb917b09a1848a221dbc87e7927a1" translate="yes" xml:space="preserve">
          <source>You do not have MT-safe</source>
          <target state="translated">你没有MT-safe</target>
        </trans-unit>
        <trans-unit id="2e1ca2f68a9ba2ef298384c1d65396bc3e584c1e" translate="yes" xml:space="preserve">
          <source>You do not have to override methods shown below unless you have to.</source>
          <target state="translated">你不必覆盖下面显示的方法,除非你必须这样做。</target>
        </trans-unit>
        <trans-unit id="fb758f283ea1827a0e24eaa44c4a0b710b292031" translate="yes" xml:space="preserve">
          <source>You do not need to use this directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d463f5c40ea27790902d715d5582fd331f2a8862" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt; s. If you need to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="translated">通过使用这样做&lt;a href=&quot;carp&quot;&gt;鲤鱼&lt;/a&gt;和更换你的 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 与S &lt;code&gt;carp&lt;/code&gt; 秒。如果您需要 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，请说&amp;ldquo; &lt;code&gt;croak&lt;/code&gt; 。但是，请 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 在地方的完整性检查-它真的是你的过错模块。</target>
        </trans-unit>
        <trans-unit id="113f89135b9f076e711872b293b64852cb136b98" translate="yes" xml:space="preserve">
          <source>You do this by using &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and replacing your &lt;code&gt;warn&lt;/code&gt;s with &lt;code&gt;carp&lt;/code&gt;s. If you need to &lt;code&gt;die&lt;/code&gt;, say &lt;code&gt;croak&lt;/code&gt; instead. However, keep &lt;code&gt;warn&lt;/code&gt; and &lt;code&gt;die&lt;/code&gt; in place for your sanity checks - where it really is your module at fault.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005e9bdc4a22cadca7bbf603665f85ba87cfef2b" translate="yes" xml:space="preserve">
          <source>You don't actually</source>
          <target state="translated">你其实并没有</target>
        </trans-unit>
        <trans-unit id="5d5d63d2e431a9c6b982f4e636021ca69ef4faa3" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27b09323fd0303316a1e04f47208b954d9880846" translate="yes" xml:space="preserve">
          <source>You don't actually &quot;trap&quot; a control character. Instead, that character generates a signal which is sent to your terminal's currently foregrounded process group, which you then trap in your process. Signals are documented in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt; and the section on &quot;Signals&quot; in the Camel.</source>
          <target state="translated">您实际上并没有&amp;ldquo;捕获&amp;rdquo;控制字符。而是，该角色生成一个信号，该信号被发送到终端的当前前台进程组，然后您将其捕获在进程中。信号记录在&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipc的Signals&lt;/a&gt;和Camel的&amp;ldquo; Signals&amp;rdquo;部分中。</target>
        </trans-unit>
        <trans-unit id="43005f5be66bea21174dcb83ad3e5e91f2ebadaa" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; on the return from &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;. Like &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt;&lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; on improper numeric conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1e2e036145d009e379c1e58f4e8404e4bb7c5f" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">您不必检查 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。像 &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 一样，它将Perl中从系统调用返回的 &lt;code&gt;0&lt;/code&gt; 映射为 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。该字符串在布尔上下文中为true，在数字上下文中为 &lt;code&gt;0&lt;/code&gt; 。对于不正确的数字转换，它也不受常规的&lt;b&gt;-w&lt;/b&gt;警告的影响。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="91e28b8dde4eef2778828dc13bbb504ddd8429b3" translate="yes" xml:space="preserve">
          <source>You don't have to check for &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; on the return from &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;. Like &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, it maps a &lt;code&gt;0&lt;/code&gt; return from the system call into &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in Perl. This string is true in boolean context and &lt;code&gt;0&lt;/code&gt; in numeric context. It is also exempt from the normal &lt;b&gt;-w&lt;/b&gt; warnings on improper numeric conversions.</source>
          <target state="translated">您不必检查 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。像 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 一样，它将Perl中从系统调用返回的 &lt;code&gt;0&lt;/code&gt; 映射为 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 。该字符串在布尔上下文中为true，在数字上下文中为 &lt;code&gt;0&lt;/code&gt; 。对于不正确的数字转换，它也不受常规的&lt;b&gt;-w&lt;/b&gt;警告的影响。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b28935e71a19f281a841ddb06e95aa9113f5e9af" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; on it, because &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;.) However, an explicit &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on an input file resets the line counter (&lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;), while the implicit close done by &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3317a455934bcb4f5310b2ce1e13684a7b6884c6" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">如果您要立即对其进行另一个 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ，则不必关闭FILEHANDLE ，因为 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 会为您关闭它。（请参见&lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;。）但是，输入文件上的显式 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 重置行计数器（ &lt;code&gt;$.&lt;/code&gt; ），而 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 所进行的隐式关闭则不会。</target>
        </trans-unit>
        <trans-unit id="d144697260e1beed6903444902a55fc7aceb423c" translate="yes" xml:space="preserve">
          <source>You don't have to close FILEHANDLE if you are immediately going to do another &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; on it, because &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; closes it for you. (See &lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;.) However, an explicit &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on an input file resets the line counter (&lt;code&gt;$.&lt;/code&gt; ), while the implicit close done by &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; does not.</source>
          <target state="translated">如果您要立即对其进行另一个 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ，则不必关闭FILEHANDLE ，因为 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 会为您关闭它。（请参见&lt;a href=&quot;#open-FILEHANDLE&quot;&gt;open&lt;/a&gt;。）但是，输入文件上的显式 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 重置行计数器（ &lt;code&gt;$.&lt;/code&gt; ），而 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 所进行的隐式关闭则不会。</target>
        </trans-unit>
        <trans-unit id="ada37b6245f195e4fcd7aa6724d9b314782b9989" translate="yes" xml:space="preserve">
          <source>You don't have to do anything new in your extension to get this; since the Perl library provides Perl_get_context(), it will all just work.</source>
          <target state="translated">你不需要在你的扩展中做任何新的事情来获得这个功能;因为Perl库提供了Perl_get_context(),所以这一切都能正常工作。</target>
        </trans-unit>
        <trans-unit id="0afa6281a85d9c8f0451db68d3408cd7d6bba6a9" translate="yes" xml:space="preserve">
          <source>You don't have to do this all on the command line, though, there are a few GUI options out there. The nice thing about these is you can wave a mouse over a variable and a dump of its data will appear in an appropriate window, or in a popup balloon, no more tiresome typing of 'x $varname' :-)</source>
          <target state="translated">你不必在命令行上完成这些工作,不过,有一些GUI选项。这些选项的好处是,你可以在一个变量上挥动鼠标,它的数据转储就会出现在一个适当的窗口中,或者在一个弹出的气球中,再也不用烦人地输入 &quot;x $varname &quot;了 :-)</target>
        </trans-unit>
        <trans-unit id="bc3f5455b30ee7863f96aa530c94393c0cafca20" translate="yes" xml:space="preserve">
          <source>You don't have to enclose POSIX class names inside double brackets, hence both of the following work:</source>
          <target state="translated">你不必把POSIX类名放在双括号内,因此下面两个都可以。</target>
        </trans-unit>
        <trans-unit id="229ae092ed53a2ce77c4892afb43389969fbd9bc" translate="yes" xml:space="preserve">
          <source>You don't have to use \b to match words though. You can look for non-word characters surrounded by word characters. These strings match the pattern /\b'\b/.</source>
          <target state="translated">不过你不一定非要用\b来匹配单词。你可以寻找被单词字符包围的非单词字符。这些字符串符合/\b'\b/的模式。</target>
        </trans-unit>
        <trans-unit id="21cad750fa1f143b35b4124baa7518d27d8319c9" translate="yes" xml:space="preserve">
          <source>You don't have to worry about finding or paying for Perl; it's freely available and several popular operating systems come with Perl. Community support in places such as Perlmonks ( &lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt; ) and the various Perl mailing lists ( &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; ) means that you can usually get quick answers to your problems.</source>
          <target state="translated">您不必担心寻找Perl或为它付费。它是免费提供的，Perl随附了几种流行的操作系统。在Perlmonks（&lt;a href=&quot;http://www.perlmonks.com&quot;&gt;http://www.perlmonks.com&lt;/a&gt;）和各种Perl邮件列表（&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;）之类的地方，社区支持意味着您通常可以快速找到问题的答案。</target>
        </trans-unit>
        <trans-unit id="8365eeff3d04c895cb1076cf6e1217da1d00d04f" translate="yes" xml:space="preserve">
          <source>You don't just have to match on fixed strings. In fact, you can match on just about anything you could dream of by using more complex regular expressions. These are documented at great length in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the meantime, here's a quick cheat sheet:</source>
          <target state="translated">您不仅需要匹配固定的字符串。实际上，通过使用更复杂的正则表达式，您几乎可以匹配任何您梦dream以求的东西。这些文件在&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;中有大量记录，但与此同时，这是一个快速备忘单：</target>
        </trans-unit>
        <trans-unit id="6fa3f4f65b9497a1fe4774a26aaf551f58ec3c5f" translate="yes" xml:space="preserve">
          <source>You don't need to have /usr/ucb/ in your PATH to build perl. If you want /usr/ucb/ in your PATH anyway, make sure that /usr/ucb/ is NOT in your PATH before the directory containing the right C compiler.</source>
          <target state="translated">你不需要在你的PATH里有/usr/ucb/来编译perl。如果你想让/usr/ucb/在你的PATH中,确保/usr/ucb/不在你的PATH中,而在包含正确的C编译器的目录前。</target>
        </trans-unit>
        <trans-unit id="fb446a8ceff857b0d30326b022d90618c379b51d" translate="yes" xml:space="preserve">
          <source>You don't need to specify wildcards if you only want to test within specific subdirectories. The following example will only run tests in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40dd09143f7def3dc81d2ff9344d2600d1d1ae7" translate="yes" xml:space="preserve">
          <source>You don't really have to count them yourself, though, since Perl already does that with the &lt;code&gt;$.&lt;/code&gt; variable, which is the current line number from the last filehandle read:</source>
          <target state="translated">不过，由于Perl已经使用 &lt;code&gt;$.&lt;/code&gt; 做到了这一点，因此您实际上不必自己计算它们。变量，它是最近读取的文件句柄中的当前行号：</target>
        </trans-unit>
        <trans-unit id="b24e0508e2da733e0f794e663fee88bb39a1e25a" translate="yes" xml:space="preserve">
          <source>You don't skip tests which are failing because there's a bug in your program, or for which you don't yet have code written. For that you use TODO. Read on.</source>
          <target state="translated">你不会跳过那些因为你的程序有bug而失败的测试,或者你还没有写好代码的测试。为此,你使用TODO。请继续阅读。</target>
        </trans-unit>
        <trans-unit id="eebc556ad68a7f00f0136b389c1fbe429ec9a58f" translate="yes" xml:space="preserve">
          <source>You first enter in bisect mode with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdc25fa644377770199aae18193b3eaaa7f502c" translate="yes" xml:space="preserve">
          <source>You forgot a '=back' before '=head</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93562b7ff5c979fa6f4e89c93b44f448f3599aca" translate="yes" xml:space="preserve">
          <source>You forgot a '=back' before '=head3'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710a0707d7d6991623d26d4226d9c4d860f3f7d5" translate="yes" xml:space="preserve">
          <source>You forgot to check &lt;code&gt;$?&lt;/code&gt; to see whether the program even ran correctly. Even if you wrote</source>
          <target state="translated">您忘了检查 &lt;code&gt;$?&lt;/code&gt; 查看程序是否正确运行。即使你写了</target>
        </trans-unit>
        <trans-unit id="fc90d9f18467dae7f984c44b04f6fed62e49d3b4" translate="yes" xml:space="preserve">
          <source>You get two references to the same array. If you modify &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; and then look at &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; you'll see the change.</source>
          <target state="translated">您将获得对同一数组的两个引用。如果修改 &lt;code&gt;$aref1-&amp;gt;[23]&lt;/code&gt; ，然后查看 &lt;code&gt;$aref2-&amp;gt;[23]&lt;/code&gt; 您将看到更改。</target>
        </trans-unit>
        <trans-unit id="bc28177c520a27689ee52401d7752fede6fec23d" translate="yes" xml:space="preserve">
          <source>You have '=item x' instead of the expected '=item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e5e5638bed24bad2d4ab312bfe1360cb8707ce" translate="yes" xml:space="preserve">
          <source>You have a data file that expresses greetings in different languages. Its format is &quot;[language tag]=[how to say 'Hello']&quot;, like:</source>
          <target state="translated">你有一个用不同语言表达问候语的数据文件。它的格式是&quot;[语言标签]=[如何说'你好']&quot;,比如。</target>
        </trans-unit>
        <trans-unit id="afbb6b8d64f8b4b3f378ab57026bdb8753122fdc" translate="yes" xml:space="preserve">
          <source>You have a piece of data on which many different operations are applied.</source>
          <target state="translated">你有一个数据,在这个数据上应用了许多不同的操作。</target>
        </trans-unit>
        <trans-unit id="63d97bb84f94237f7e4b056d5ae5d88b12cd254c" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8eed8b91591afe605349a4edd81010c1b4133d5" translate="yes" xml:space="preserve">
          <source>You have a very old pdksh. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您有一个非常老的pdksh。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0763fc81d3cd7a4189100a79a22596558a167896" translate="yes" xml:space="preserve">
          <source>You have an older version of</source>
          <target state="translated">你有一个旧版本的</target>
        </trans-unit>
        <trans-unit id="e430c6e7f2999710866cf3f6291d3dd58341a4a4" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;&quot;Selecting What to Export&quot;&lt;/a&gt; to not export:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b9024251b30a14c45724d6bbd90abab3f232a3" translate="yes" xml:space="preserve">
          <source>You have been warned already in &lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;Selecting What to Export&lt;/a&gt; to not export:</source>
          <target state="translated">您已经在&lt;a href=&quot;#Selecting-What-to-Export&quot;&gt;选择要导出的内容&lt;/a&gt;中不发出警告：</target>
        </trans-unit>
        <trans-unit id="43dfe62727996603d47468da8d91c958abc24b74" translate="yes" xml:space="preserve">
          <source>You have created an XSUB interface to an application's C API.</source>
          <target state="translated">你已经创建了一个XSUB接口到应用程序的C API。</target>
        </trans-unit>
        <trans-unit id="c236e9b8bd9523c45d8e12fd36ee9331405ecbff" translate="yes" xml:space="preserve">
          <source>You have defined an END handler for an attribute that is being applied to a lexical variable. Since the variable may not be available during END this won't happen.</source>
          <target state="translated">你为一个应用于词法变量的属性定义了一个END处理程序。由于变量在END期间可能无法使用,所以不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="717f15e5bfd4a04630296d7e18d1dc4a8563c670" translate="yes" xml:space="preserve">
          <source>You have set the &lt;code&gt;WindowBits&lt;/code&gt; parameter to &lt;code&gt;-MAX_WBITS&lt;/code&gt; in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</source>
          <target state="translated">您已设置 &lt;code&gt;WindowBits&lt;/code&gt; 参数 &lt;code&gt;-MAX_WBITS&lt;/code&gt; 在构造该对象，即你解压缩原始瘪数据流（RFC 1951）。</target>
        </trans-unit>
        <trans-unit id="522d08a79de6280adc20232939d047a4cc891b57" translate="yes" xml:space="preserve">
          <source>You have the choice to set the config variable &lt;code&gt;scan_cache&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt; . Then you must clean it up yourself. The other possible values, &lt;code&gt;atstart&lt;/code&gt; and &lt;code&gt;atexit&lt;/code&gt; clean up the build directory when you start (or more precisely, after the first extraction into the build directory) or exit the CPAN shell, respectively. If you never start up the CPAN shell, you probably also have to clean up the build directory yourself.</source>
          <target state="translated">您可以选择将配置变量 &lt;code&gt;scan_cache&lt;/code&gt; 设置为 &lt;code&gt;never&lt;/code&gt; 。然后，您必须自己清理它。其他可能的值，分别是 &lt;code&gt;atstart&lt;/code&gt; 和 &lt;code&gt;atexit&lt;/code&gt; ，它们分别在您启动时（或更确切地说，在第一次提取到构建目录中之后）或退出CPAN Shell时清除构建目录。如果您从不启动CPAN Shell，则可能还必须自己清理build目录。</target>
        </trans-unit>
        <trans-unit id="d43912cc9e84a61faff2f02f26a4d03134058ada" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;Time::Local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2deb6a8cd98a82f2aaaef2ec6bec5741ef832ea" translate="yes" xml:space="preserve">
          <source>You have the same problem with &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt;, which will give the wrong answer for those same special cases:</source>
          <target state="translated">您在&lt;a href=&quot;time/local&quot;&gt;Time :: Local上遇到&lt;/a&gt;了相同的问题，对于相同的特殊情况，这将给出错误的答案：</target>
        </trans-unit>
        <trans-unit id="d93e439cde6acc82e52bf85fad48553b810a706b" translate="yes" xml:space="preserve">
          <source>You have to be prepared to &quot;reap&quot; the child process when it finishes.</source>
          <target state="translated">你要做好准备,当孩子的过程结束后,你要 &quot;收获&quot;。</target>
        </trans-unit>
        <trans-unit id="7bc9963f1adfa43aa2eba732c53b836ac12c4562" translate="yes" xml:space="preserve">
          <source>You have to decide whether you want to use string or numeric comparisons.</source>
          <target state="translated">你必须决定你是要使用字符串还是数字比较。</target>
        </trans-unit>
        <trans-unit id="4cf51b08c425e59c5631231a092f6037897d07c7" translate="yes" xml:space="preserve">
          <source>You have to decide whether your array has numeric or string indices.</source>
          <target state="translated">你必须决定你的数组是有数字还是字符串索引。</target>
        </trans-unit>
        <trans-unit id="a73461591d1d0c0412d08a5e1e1cc7e69b28c7fe" translate="yes" xml:space="preserve">
          <source>You have to have Pod::Simple::RTF installed (from the Pod::Simple dist), or this module won't work.</source>
          <target state="translated">你必须安装Pod::Simple::RTF(来自Pod::Simple dist),否则这个模块将无法工作。</target>
        </trans-unit>
        <trans-unit id="58b51a173ef28ef95718c75aa4bacf0fb0ef7258" translate="yes" xml:space="preserve">
          <source>You have to have installed Pod::Simple::XMLOutStream (from the Pod::Simple dist), or this class won't work.</source>
          <target state="translated">你必须安装了Pod::Simple::XMLOutStream(来自Pod::Simple dist),否则这个类将无法工作。</target>
        </trans-unit>
        <trans-unit id="f9f9dbede53dcc87c8a6c2c35d9ae17a92119e03" translate="yes" xml:space="preserve">
          <source>You have to have installed Tk::Pod first, or this class won't load.</source>
          <target state="translated">你必须先安装Tk::Pod,否则这个类不会加载。</target>
        </trans-unit>
        <trans-unit id="95bfc19d25cce1034c6f167e8df494025bec3f1c" translate="yes" xml:space="preserve">
          <source>You have to have two hex digits after a braceless &lt;code&gt;\x&lt;/code&gt; (use a leading zero to make two). These restrictions are to lower the incidence of typos causing the class to not match what you thought it would.</source>
          <target state="translated">无括号的 &lt;code&gt;\x&lt;/code&gt; 后面必须有两个十六进制数字（使用前导零表示两个）。这些限制是为了减少导致班级与您认为的不符的错别字的发生。</target>
        </trans-unit>
        <trans-unit id="c268b51167b66309dd9d49ba2a2c249b1b287fa0" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; , case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="translated">您必须自己跟踪N。例如，假设您要不区分大小写地将第五次出现的 &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt; 。这些都假定$ _包含要更改的字符串。</target>
        </trans-unit>
        <trans-unit id="8f497ff3dd0b8c02bb7f0cfe45277ba739785588" translate="yes" xml:space="preserve">
          <source>You have to keep track of N yourself. For example, let's say you want to change the fifth occurrence of &lt;code&gt;&quot;whoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomever&quot;&lt;/code&gt; into &lt;code&gt;&quot;whosoever&quot;&lt;/code&gt; or &lt;code&gt;&quot;whomsoever&quot;&lt;/code&gt;, case insensitively. These all assume that $_ contains the string to be altered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac02203046e578344330c6d8542449742080d451" translate="yes" xml:space="preserve">
          <source>You have to run this program by hand; it's not run as part of the Perl installation.</source>
          <target state="translated">你必须手动运行这个程序;它不会作为Perl安装的一部分运行。</target>
        </trans-unit>
        <trans-unit id="64c3798560849a7dba79bf1106dd1dedfd652114" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;
filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="translated">您尝试使用 &lt;code&gt;-rwxRWX&lt;/code&gt; filetest中的一项，并且 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; 。 &lt;code&gt;File::stat&lt;/code&gt; 将忽略编译指示，仅照常使用 &lt;code&gt;mode&lt;/code&gt; 成员中的信息。</target>
        </trans-unit>
        <trans-unit id="619430200c4656ad3bc2866c9b899c95858a7c7b" translate="yes" xml:space="preserve">
          <source>You have tried to use one of the &lt;code&gt;-rwxRWX&lt;/code&gt; filetests with &lt;code&gt;use filetest 'access'&lt;/code&gt; in effect. &lt;code&gt;File::stat&lt;/code&gt; will ignore the pragma, and just use the information in the &lt;code&gt;mode&lt;/code&gt; member as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f298d6edd85361a4fe69a118c738c5c6d1ac6519" translate="yes" xml:space="preserve">
          <source>You just can't, okay? Instead, put all the specifications together with commas between them in a single &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">你不能，好吗？取而代之的是，将所有规范以及它们之间的逗号放在一个 &lt;code&gt;ATTR(&lt;i&gt;specification&lt;/i&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2ae4f730c89fd94f9c70ee5552ee3019cb5e33a" translate="yes" xml:space="preserve">
          <source>You like this port? See &lt;a href=&quot;http://www.broad.ology.org.uk/amiga/&quot;&gt;http://www.broad.ology.org.uk/amiga/&lt;/a&gt; for how you can help.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbf451f9422303960f49b456d9bb760406138be" translate="yes" xml:space="preserve">
          <source>You likely need to figure out how this multi-byte character got mixed up with your single-byte locale (or perhaps you thought you had a UTF-8 locale, but Perl disagrees).</source>
          <target state="translated">你很可能需要弄清楚这个多字节字符是如何与你的单字节区位混在一起的 (或者你以为你有一个 UTF-8 区位,但 Perl 不同意)。</target>
        </trans-unit>
        <trans-unit id="b36efc02e455a878d40bce54d0800047ed5ce051" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">您可能（通常应该）使用open的三参数形式来指定I / O层（有时称为&amp;ldquo;学科&amp;rdquo;）以应用于影响输入和输出处理方式的句柄（请参见&lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;和&lt;a href=&quot;../perlio&quot;&gt;PerlIO&lt;/a&gt;以获取相关信息）。更多细节）。例如：</target>
        </trans-unit>
        <trans-unit id="f4242caecdd2a41134c434e48293066c09a61129" translate="yes" xml:space="preserve">
          <source>You may (and usually should) use the three-argument form of open to specify I/O layers (sometimes referred to as &quot;disciplines&quot;) to apply to the handle that affect how the input and output are processed (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; for more details). For example:</source>
          <target state="translated">您可能（通常应该）使用open的三参数形式来指定I / O层（有时称为&amp;ldquo;学科&amp;rdquo;）以应用于影响输入和输出处理方式的句柄（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;和&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;以获取相关信息）。更多细节）。例如：</target>
        </trans-unit>
        <trans-unit id="9e56389d96587e792278e4c558eb5807976007cf" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to RSS feeds for the changes, search for particular commits and more. You may access it at &lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git&lt;/a&gt;. A mirror of the repository is found at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="translated">您可以通过Web访问存储库。这使您可以浏览树，查看最近的提交，订阅RSS feed进行更改，搜索特定的提交等等。您可以在&lt;a href=&quot;http://perl5.git.perl.org/perl.git&quot;&gt;http://perl5.git.perl.org/perl.git上&lt;/a&gt;访问它。可以在&lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;找到存储库的镜像。</target>
        </trans-unit>
        <trans-unit id="880fe17e1513224bf25aeb9d0faccae93b9cb553" translate="yes" xml:space="preserve">
          <source>You may access the repository over the web. This allows you to browse the tree, see recent commits, subscribe to repository notifications, search for particular commits and more. You may access it at &lt;a href=&quot;https://github.com/Perl/perl5&quot;&gt;https://github.com/Perl/perl5&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d839e720ae2e7bff2fab5b0520b346cd44ca6b4d" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="translated">您可以通过Perl或XS代码将其他方法添加到UNIVERSAL类中。您不需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; UNIVERSAL&lt;/code&gt; 使这些方法可用于您的程序（并且您不应这样做）。</target>
        </trans-unit>
        <trans-unit id="224f5909daef0b34d22040e764c9911e7daddf8b" translate="yes" xml:space="preserve">
          <source>You may add other methods to the UNIVERSAL class via Perl or XS code. You do not need to &lt;code&gt;use UNIVERSAL&lt;/code&gt; to make these methods available to your program (and you should not do so).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100a6f059c39fc4530e46957891e388f20cf1052" translate="yes" xml:space="preserve">
          <source>You may also choose to assign the strings &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; or &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; as the handler, in which case Perl will try to discard the signal or do the default thing.</source>
          <target state="translated">您也可以选择将字符串 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 为处理程序，在这种情况下，Perl将尝试丢弃信号或执行默认操作。</target>
        </trans-unit>
        <trans-unit id="daa282ce292ff54483ba2ce846a92dc96f9168dc" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt; :</source>
          <target state="translated">您还可以检查输出操作对象上的&amp;ldquo;安全&amp;rdquo;标志，该标志在作为 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 的第三个参数给出时被填充：</target>
        </trans-unit>
        <trans-unit id="423918885baf5f3a8b58d2fd022436e7d14efbab" translate="yes" xml:space="preserve">
          <source>You may also examine the &quot;safe&quot; flag on the output action object which is filled in when given as the third parameter to &lt;code&gt;POSIX::sigaction()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6858c6ae6b5f95e06bfedeb3afc148cdf748f135" translate="yes" xml:space="preserve">
          <source>You may also have found out by now why 7bit ISO-2022 cannot comprise a CCS. If you look at a byte sequence \x21\x21, you can't tell if it is two !'s or IDEOGRAPHIC SPACE. EUC maps the latter to \xA1\xA1 so you have no trouble differentiating between &quot;!!&quot;. and &quot; &quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01c5b9373dd2d19d42f55fdae95d97ea20dd07a1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt; . Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;gr_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; 对应于$ gr_gid。数组引用可作为常规数组变量使用，因此 &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; 就是@gr_members。</target>
        </trans-unit>
        <trans-unit id="caae676e8fb92488f8f5b8dcd2e680cb050048ef" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;gr_&lt;/code&gt;. Thus, &lt;code&gt;$group_obj-&amp;gt;gid()&lt;/code&gt; corresponds to $gr_gid if you import the fields. Array references are available as regular array variables, so &lt;code&gt;@{ $group_obj-&amp;gt;members() }&lt;/code&gt; would be simply @gr_members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4935199f235ba2f0cd0a1d49e3ac1a3bbd011f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt; . Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;h_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; 对应于$ h_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@h_aliases。</target>
        </trans-unit>
        <trans-unit id="da401673f6af44a50993b3561d0579f99e07eee9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;h_&lt;/code&gt;. Thus, &lt;code&gt;$host_obj-&amp;gt;name()&lt;/code&gt; corresponds to $h_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $host_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @h_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ec160f76fcfc38cc73d96c90a7ce874d6384c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt; . Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;n_&lt;/code&gt; 命名的变量进行访问。因此，如果您导入字段，则 &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; 对应于$ n_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@n_aliases。</target>
        </trans-unit>
        <trans-unit id="19db00abebd3ac2639c39bd38da2d23c013b0474" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;n_&lt;/code&gt;. Thus, &lt;code&gt;$net_obj-&amp;gt;name()&lt;/code&gt; corresponds to $n_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $net_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @n_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8189e5c613aac0e23d3c0670ed3ce2f5ae13db" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt; . Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases()
}&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;p_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; 对应于$ p_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; 就是@p_aliases。</target>
        </trans-unit>
        <trans-unit id="59c78f0961227d9eef360c4cd0d66deb00f372b4" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;p_&lt;/code&gt;. Thus, &lt;code&gt;$proto_obj-&amp;gt;name()&lt;/code&gt; corresponds to $p_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $proto_obj-&amp;gt;aliases() }&lt;/code&gt; would be simply @p_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25ca76eb17a2cf86a0c57fdc15c696e88b6cf4c9" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;pw_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; corresponds to $pw_shell if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为变量使用方法名称前的 &lt;code&gt;pw_&lt;/code&gt; 命名。因此，如果导入字段，则 &lt;code&gt;$passwd_obj-&amp;gt;shell&lt;/code&gt; 对应于$ pw_shell。</target>
        </trans-unit>
        <trans-unit id="274d859e81c068db4c48efa8f50c77493ca5cdbd" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt; . Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。 （请注意，这仍然会覆盖您的核心功能。）将这些字段作为以前面的 &lt;code&gt;s_&lt;/code&gt; 命名的变量进行访问。因此，如果导入字段，则 &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; 对应于$ s_name。数组引用可以作为常规数组变量使用，因此例如 &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; 就是@s_aliases。</target>
        </trans-unit>
        <trans-unit id="18fe09aa2549872796afb74f39ab43e75ad25ff1" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;s_&lt;/code&gt;. Thus, &lt;code&gt;$serv_obj-&amp;gt;name()&lt;/code&gt; corresponds to $s_name if you import the fields. Array references are available as regular array variables, so for example &lt;code&gt;@{ $serv_obj-&amp;gt;aliases()}&lt;/code&gt; would be simply @s_aliases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447198c5b98b7b54155b70c415358589d509c62e" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your core functions.) Access these fields as variables named with a preceding &lt;code&gt;tm_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; corresponds to $tm_mday if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的核心功能。）将这些字段作为变量使用方法名称 &lt;code&gt;tm_&lt;/code&gt; 变量tm_命名。因此，如果导入字段，则 &lt;code&gt;$tm_obj-&amp;gt;mday()&lt;/code&gt; 对应于$ tm_mday。</target>
        </trans-unit>
        <trans-unit id="5c856054dbb9356054cca7ccfef163a998ceb55f" translate="yes" xml:space="preserve">
          <source>You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag. (Note that this still overrides your stat() and lstat() functions.) Access these fields as variables named with a preceding &lt;code&gt;st_&lt;/code&gt; in front their method names. Thus, &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; corresponds to $st_dev if you import the fields.</source>
          <target state="translated">您也可以使用：FIELDS import标记将所有结构字段作为常规变量直接导入到您的命名空间中。（请注意，这仍然会覆盖您的stat（）和lstat（）函数。）以变量名的形式访问这些字段， &lt;code&gt;st_&lt;/code&gt; 在其方法名称前加一个前置st_。因此，如果您导入字段，则 &lt;code&gt;$stat_obj-&amp;gt;dev()&lt;/code&gt; 对应于$ st_dev。</target>
        </trans-unit>
        <trans-unit id="a6b6b26fcc9879eca82e69c4a67570540fca4ae9" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt; , so it makes sense looking for these strings.</source>
          <target state="translated">您可能还需要应用perl二进制发行版随附的补丁。在perl5-porters邮件列表中查找与OS / 2相关的最新补丁也很有意义（请参阅&lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;）。这样的补丁通常包含字符串 &lt;code&gt;/os2/&lt;/code&gt; 和 &lt;code&gt;patch&lt;/code&gt; ，因此查找这些字符串很有意义。</target>
        </trans-unit>
        <trans-unit id="8e4529b370379079adb0c3991b105507c8bdaf29" translate="yes" xml:space="preserve">
          <source>You may also need to apply the patches supplied with the binary distribution of perl. It also makes sense to look on the perl5-porters mailing list for the latest OS/2-related patches (see &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/&lt;/a&gt;). Such patches usually contain strings &lt;code&gt;/os2/&lt;/code&gt; and &lt;code&gt;patch&lt;/code&gt;, so it makes sense looking for these strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa8495c9efa1eb6aea78e6cd751529d33d7b29e" translate="yes" xml:space="preserve">
          <source>You may also need to comment out the &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; line in the Makefile if you're using VC++ 6.0 without the latest service pack and the linker reports an internal error.</source>
          <target state="translated">如果您使用的是不带最新Service Pack的VC ++ 6.0，并且链接器报告内部错误，则可能还需要注释掉Makefile中的 &lt;code&gt;DELAYLOAD = ...&lt;/code&gt; 行。</target>
        </trans-unit>
        <trans-unit id="069c796ed1b4791a2efc8028daa2cfe58429ceb7" translate="yes" xml:space="preserve">
          <source>You may also refer to a distribution in the form A/AU/AUTHORID/TARBALL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c64c3fbfbcaace5918da128791239c43cdf19d2" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">您也可以使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 检查子程序 &lt;code&gt;&amp;amp;func&lt;/code&gt; 是否已定义。返回值不受 &lt;code&gt;&amp;amp;func&lt;/code&gt; 的任何前向声明的影响。未定义的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次被调用时就存在。参见&lt;a href=&quot;../perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172f346295165efa4fd86444269a98fd3b778c01" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; to check whether subroutine &lt;code&gt;&amp;amp;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;&amp;amp;func&lt;/code&gt; . A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">您也可以使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(&amp;amp;func)&lt;/a&gt;&lt;/code&gt; 检查子程序 &lt;code&gt;&amp;amp;func&lt;/code&gt; 是否已定义。返回值不受 &lt;code&gt;&amp;amp;func&lt;/code&gt; 的任何前向声明的影响。未定义的子例程可能仍然可以调用：其程序包可能具有 &lt;code&gt;AUTOLOAD&lt;/code&gt; 方法，该方法使它在第一次被调用时就存在。参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b8d15f86aa40a5b71c22fd3f0132310f48b5d79" translate="yes" xml:space="preserve">
          <source>You may also use &lt;code&gt;defined(&amp;amp;func)&lt;/code&gt; to check whether subroutine &lt;code&gt;func&lt;/code&gt; has ever been defined. The return value is unaffected by any forward declarations of &lt;code&gt;func&lt;/code&gt;. A subroutine that is not defined may still be callable: its package may have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method that makes it spring into existence the first time that it is called; see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b5f7479dd4b17df91be39e0264b553fbc922288" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="translated">您也可以使用反引号来调用DCL子进程，该子进程的输出用作表达式的返回值。反引号之间的字符串的处理方式就像是 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 运算符的参数一样（请参见下文）。在这种情况下，Perl将等待子进程完成后再继续。</target>
        </trans-unit>
        <trans-unit id="4106bc4cad7712056a35b119b25c2a2d70a97ddc" translate="yes" xml:space="preserve">
          <source>You may also use backticks to invoke a DCL subprocess, whose output is used as the return value of the expression. The string between the backticks is handled as if it were the argument to the &lt;code&gt;system&lt;/code&gt; operator (see below). In this case, Perl will wait for the subprocess to complete before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbaa1ecf2a2a16f0a8eda0bda48b0855b6af1d1c" translate="yes" xml:space="preserve">
          <source>You may also use dmake or gmake. See &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;&lt;/a&gt; above on how to get it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5448f65c98891197c6cecbe08ead986b82724f17" translate="yes" xml:space="preserve">
          <source>You may also use dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">您也可以使用dmake。有关如何获取的信息，请参见上面的&amp;ldquo; &lt;a href=&quot;#Make&quot;&gt;制作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a9260264524823855ded5315edf6f0c9bddfa48" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3196fa8d2ff4d6ac1033b15a7916441466060e42" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module (part of the standard perl distribution), but be warned that it has a different order of arguments from &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; (see &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">您也可以使用&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;模块（标准perl发行版的一部分），但要注意其模块的参数顺序与&lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2的&lt;/a&gt;顺序不同（请参阅&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="71182d3aa143564846d6bda380e37d7713401c83" translate="yes" xml:space="preserve">
          <source>You may also use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ef88e606ea55cb21f76eea0e0de1fb7b9db2f" translate="yes" xml:space="preserve">
          <source>You may also want to look at one other option for building a perl that will work on Windows: the README.cygwin file, which give a different set of rules to build a perl for Windows. This method will probably enable you to build a more Unix-compatible perl, but you will also need to download and use various other build-time and run-time support software described in that file.</source>
          <target state="translated">你可能还想看看另外一个可以在Windows上运行的perl的选项:README.cygwin文件,它给出了一套不同的规则来构建Windows下的perl。这种方法可能会让你构建一个更兼容Unix的perl,但你还需要下载并使用该文件中描述的其他各种构建时和运行时支持软件。</target>
        </trans-unit>
        <trans-unit id="47d8e5afa5f51ce60391c15623a30d357b47dac4" translate="yes" xml:space="preserve">
          <source>You may also want to override the &lt;b&gt;begin_input()&lt;/b&gt; and &lt;b&gt;end_input()&lt;/b&gt; methods for your subclass (to perform any needed per-file and/or per-document initialization or cleanup).</source>
          <target state="translated">您可能还想为您的子类覆盖&lt;b&gt;begin_input（）&lt;/b&gt;和&lt;b&gt;end_input（）&lt;/b&gt;方法（以执行任何需要的按文件和/或按文档的初始化或清除操作）。</target>
        </trans-unit>
        <trans-unit id="fad70035f3a1b89b3667a331878011a9d50cf74f" translate="yes" xml:space="preserve">
          <source>You may also want to read over the source for &lt;code&gt;File::Findgrep&lt;/code&gt; and its constituent modules -- they are a complete (if small) example application that uses Maketext.</source>
          <target state="translated">您可能还想阅读 &lt;code&gt;File::Findgrep&lt;/code&gt; 及其组成模块的源代码-它们是使用Maketext的完整（如果很小）的示例应用程序。</target>
        </trans-unit>
        <trans-unit id="32c591edfbc105cf26f618c0c72cc57761fceff2" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt; 's treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="translated">您可能还希望与翻译人员讨论如何关联同一个语言标签的不同子形式的问题，考虑它如何与 &lt;code&gt;get_handle&lt;/code&gt; 对这些形式的反应。例如，如果用户接受&amp;ldquo; en，fr&amp;rdquo;中的接口，而您拥有&amp;ldquo; en-US&amp;rdquo;和&amp;ldquo; fr&amp;rdquo;中的可用接口，那么他们应该得到什么？您可能希望通过使&amp;ldquo; en&amp;rdquo;和&amp;ldquo; en-US&amp;rdquo;有效同义来解决这一问题，方法是让一个类从另一个派生为零。</target>
        </trans-unit>
        <trans-unit id="91e1b897633821a7c3b5243be65043e6b7b07517" translate="yes" xml:space="preserve">
          <source>You may also wish to discuss with the translators the question of how to relate different subforms of the same language tag, considering how this reacts with &lt;code&gt;get_handle&lt;/code&gt;'s treatment of these. For example, if a user accepts interfaces in &quot;en, fr&quot;, and you have interfaces available in &quot;en-US&quot; and &quot;fr&quot;, what should they get? You may wish to resolve this by establishing that &quot;en&quot; and &quot;en-US&quot; are effectively synonymous, by having one class zero-derive from the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05003e2911012bca46d826b18714273b702cbb78" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as &lt;code&gt;dup(2)&lt;/code&gt; ) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; , and &lt;code&gt;+&amp;lt;&lt;/code&gt; . The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="translated">您还可以按照Bourne shell传统，以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头指定EXPR ，在这种情况下，字符串的其余部分将解释为要复制的文件句柄（或文件描述符，如果是数字）的名称（如 &lt;code&gt;dup(2)&lt;/code&gt; ）并打开。您可以在 &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;+&amp;gt;&lt;/code&gt; ， &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;+&amp;lt;&lt;/code&gt; 之后使用＆。您指定的模式应与原始文件句柄的模式匹配。 （对文件句柄进行复制不会考虑IO缓冲区的任何现有内容。）如果使用三参数形式，则可以传递数字，文件句柄的名称或常规的&amp;ldquo;对glob的引用&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="36b7c7ac25178c324a91d61c24d7fde286a14a90" translate="yes" xml:space="preserve">
          <source>You may also, in the Bourne shell tradition, specify an EXPR beginning with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, in which case the rest of the string is interpreted as the name of a filehandle (or file descriptor, if numeric) to be duped (as in &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt;) and opened. You may use &lt;code&gt;&amp;amp;&lt;/code&gt; after &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&lt;/code&gt;, &lt;code&gt;+&amp;gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;+&amp;lt;&lt;/code&gt;. The mode you specify should match the mode of the original filehandle. (Duping a filehandle does not take into account any existing contents of IO buffers.) If you use the three-argument form, then you can pass either a number, the name of a filehandle, or the normal &quot;reference to a glob&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5fc563eb0d1fd26ae839cfa02427332324573f" translate="yes" xml:space="preserve">
          <source>You may ask whether one of these was implemented on the system Perl was built on by asking the importable &lt;code&gt;pw_has&lt;/code&gt; function about them. This function returns true if all parameters are supported fields on the build platform, false if one or more were not, and raises an exception if you asked about a field that Perl never knows how to provide. Parameters may be in a space-separated string, or as separate arguments. If you pass no parameters, the function returns the list of &lt;code&gt;struct pwd&lt;/code&gt; fields supported by your build platform's C library, as a list in list context, or a space-separated string in scalar context. Note that just because your C library had a field doesn't necessarily mean that it's fully implemented on that system.</source>
          <target state="translated">您可以通过询问可导入的 &lt;code&gt;pw_has&lt;/code&gt; 函数来询问是否在Perl的系统上实现了其中之一。如果在构建平台上支持所有参数，则此函数返回true；如果不支持一个或多个，则返回false；如果询问有关Perl不知道如何提供的字段，则该函数将引发异常。参数可以用空格分隔，也可以作为单独的参数。如果不传递任何参数，则该函数将返回构建平台的C库支持的 &lt;code&gt;struct pwd&lt;/code&gt; 字段的列表，列表上下文中的列表或标量上下文中以空格分隔的字符串。请注意，仅仅因为您的C库包含一个字段，并不一定意味着它已在该系统上完全实现。</target>
        </trans-unit>
        <trans-unit id="56003b76083072e5d28f4c38591744948d360c03" translate="yes" xml:space="preserve">
          <source>You may at this point want to consider whether your base class (Projname::L10N), from which all lexicons inherit from (Projname::L10N::en, Projname::L10N::es, etc.), should be an _AUTO lexicon. It may be true that in theory, all needed messages will be in each language class; but in the presumably unlikely or &quot;impossible&quot; case of lookup failure, you should consider whether your program should throw an exception, emit text in English (or whatever your project's first language is), or some more complex solution as described in the section &quot;Controlling Lookup Failure&quot;, above.</source>
          <target state="translated">这时你可能要考虑你的基类(Projname::L10N)是否应该是一个_AUTO词典,所有的词典都是从这个基类继承而来的(Projname::L10N::en、Projname::L10N::es等)。理论上,所有需要的消息都会在每个语言类中,这可能是真的;但在大概不太可能或 &quot;不可能 &quot;出现查找失败的情况下,你应该考虑你的程序是否应该抛出一个异常,发出英语(或不管你的项目的第一语言是什么)的文本,或者像上面 &quot;控制查找失败 &quot;一节中描述的一些更复杂的解决方案。</target>
        </trans-unit>
        <trans-unit id="00dd50349ec2812a0e8ba87a508b17b844d30458" translate="yes" xml:space="preserve">
          <source>You may be able to figure out what's going wrong using the Perl debugger. For information about how to use the debugger &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;.</source>
          <target state="translated">使用Perl调试器，您可能可以找出问题所在。有关如何使用调试器&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldebug&quot;&gt;perldebug的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14e829b9ba39410c7fdd62b2c0459a78db997545" translate="yes" xml:space="preserve">
          <source>You may be able to get the CCTools app, which is free. Keep in mind that you want a full toolchain; some apps tend to default to installing only a barebones version without some important utilities, like ar or nm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538c1768e7dd08c154327dd9d81d8469210ac3b8" translate="yes" xml:space="preserve">
          <source>You may be mixing the Tru64 cc/ar/ld with the GNU gcc/ar/ld. That may work, but sometimes it doesn't (your gcc or GNU utils may have been compiled for an incompatible OS release).</source>
          <target state="translated">您可能将 Tru64 cc/ar/ld 与 GNU gcc/ar/ld 混合使用。这可能会有效,但有时不会(您的 gcc 或 GNU utils 可能是为不兼容的操作系统版本编译的)。</target>
        </trans-unit>
        <trans-unit id="569474da0977b8a6d57c606d4bf816045d439deb" translate="yes" xml:space="preserve">
          <source>You may be more comfortable with the Perl version of that:</source>
          <target state="translated">你可能更喜欢Perl版本的。</target>
        </trans-unit>
        <trans-unit id="55841621afe9413e5a4d96acdf404652aff0ba71" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially handle it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c2934cf1eab265e83a97c11bed16b38a8b5801" translate="yes" xml:space="preserve">
          <source>You may be presented with strings in any of these equivalent forms. There is currently nothing in Perl 5 that ignores the differences. So you'll have to specially hanlde it. The usual advice is to convert your inputs to &lt;code&gt;NFD&lt;/code&gt; before processing further.</source>
          <target state="translated">可能会以任何这些等效形式为您提供字符串。目前，Perl 5中没有什么可以忽略这些差异。因此，您必须专门处理它。通常的建议是在进一步处理之前将输入转换为 &lt;code&gt;NFD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58f64d73709bb7f46995ccc9ddf584cf761fc186" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;can&lt;/code&gt; as a class (static) method or an object method.</source>
          <target state="translated">您可以将 &lt;code&gt;can&lt;/code&gt; 称为类（静态）方法或对象方法。</target>
        </trans-unit>
        <trans-unit id="8cf034da6832021586a2104fbbd0c08a1605f5bc" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt; , so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="translated">您可以在迭代器当前指向的哈希条目上调用 &lt;code&gt;hv_delete&lt;/code&gt; 或 &lt;code&gt;hv_delete_ent&lt;/code&gt; ，而不会失去位置或使迭代器无效。请注意，在这种情况下，当前条目将从哈希中删除，而您的迭代器将保留对它的最后一个引用。您的迭代器被标记为在下次调用 &lt;code&gt;hv_iternext&lt;/code&gt; 时释放该条目，因此您不得立即丢弃该迭代器，否则该条目将泄漏-调用 &lt;code&gt;hv_iternext&lt;/code&gt; 触发资源释放。</target>
        </trans-unit>
        <trans-unit id="224612e001a662c3d4076adbf22c1ddb33c4fc09" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;hv_delete&lt;/code&gt; or &lt;code&gt;hv_delete_ent&lt;/code&gt; on the hash entry that the iterator currently points to, without losing your place or invalidating your iterator. Note that in this case the current entry is deleted from the hash with your iterator holding the last reference to it. Your iterator is flagged to free the entry on the next call to &lt;code&gt;hv_iternext&lt;/code&gt;, so you must not discard your iterator immediately else the entry will leak - call &lt;code&gt;hv_iternext&lt;/code&gt; to trigger the resource deallocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be40ceb1a7306a76b520e9584d2eca0a12452f8" translate="yes" xml:space="preserve">
          <source>You may change the pager which is used via &lt;code&gt;o pager=...&lt;/code&gt; command.</source>
          <target state="translated">您可以更改通过 &lt;code&gt;o pager=...&lt;/code&gt; 命令使用的寻呼机。</target>
        </trans-unit>
        <trans-unit id="8d0d219cb50b9b95de99bdba2a6790e3027b1988" translate="yes" xml:space="preserve">
          <source>You may choose one of six different protocols to use for the ping. The &quot;tcp&quot; protocol is the default. Note that a live remote host may still fail to be pingable by one or more of these protocols. For example, www.microsoft.com is generally alive but not &quot;icmp&quot; pingable.</source>
          <target state="translated">你可以从六种不同的协议中选择一种来进行ping。tcp &quot;协议是默认的。请注意,一个正常运行的远程主机可能仍然无法被其中一个或多个协议ping。例如,www.microsoft.com 通常是活着的,但不能被 &quot;icmp &quot;ping。</target>
        </trans-unit>
        <trans-unit id="5b9386b09cdd1212e7410c2ab62737e2149c7f2b" translate="yes" xml:space="preserve">
          <source>You may create a shared library that refers to another library, which may be either an archive library or a shared library. If this second library is a shared library, this is called a &quot;dependent library&quot;. The dependent library's name is recorded in the main shared library, but it is not linked into the shared library. Instead, it is loaded when the main shared library is loaded. This can cause problems if you build an extension on one system and move it to another system where the libraries may not be located in the same place as on the first system.</source>
          <target state="translated">您可以创建一个指向另一个库的共享库,这个库可以是归档库,也可以是共享库。如果第二个库是共享库,则称为 &quot;依赖库&quot;。从属库的名称记录在主共享库中,但它不链接到共享库中。相反,当主共享库被加载时,它会被加载。如果你在一个系统上建立了一个扩展,并将其移动到另一个系统上,而在另一个系统上,库的位置可能与第一个系统上的不一样,那么这就会造成问题。</target>
        </trans-unit>
        <trans-unit id="9c69978ae72909c6a0d4c9ce7bda602f4029ade9" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="translated">You may declare &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</target>
        </trans-unit>
        <trans-unit id="876f17265dbc24f5deeea94b0b905e8da6c53d61" translate="yes" xml:space="preserve">
          <source>You may declare &lt;code&gt;my&lt;/code&gt; variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C's static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c485e566982c516f185802a5bb8005684c87aaf" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; , and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="translated">您可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads qw(yield)&lt;/code&gt; ，然后在代码中使用 &lt;code&gt;yield()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4966f6d04fe64b0eb4295da47dec6c27a2bd019" translate="yes" xml:space="preserve">
          <source>You may do &lt;code&gt;use threads qw(yield)&lt;/code&gt;, and then just use &lt;code&gt;yield()&lt;/code&gt; in your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6dafa2436cf995ba75a2bba335e0ce68071a9ad" translate="yes" xml:space="preserve">
          <source>You may downgrade strings with &lt;code&gt;Encode::encode&lt;/code&gt; and &lt;code&gt;utf8::encode&lt;/code&gt;. See &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad59ee540ee6c5334c4114152f24df062a49e4a1" translate="yes" xml:space="preserve">
          <source>You may encounter the following warning message at Perl startup:</source>
          <target state="translated">你可能会在Perl启动时遇到以下警告信息。</target>
        </trans-unit>
        <trans-unit id="294037a277c0cf3bb9e6ace3733986ce5d32b057" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Even then,</source>
          <target state="translated">您可能会发现有一个&amp;ldquo;宏字典&amp;rdquo;会很有帮助，您可以通过说出 &lt;code&gt;cpp -dM perl.c | &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 来生成它。排序。即使这样，</target>
        </trans-unit>
        <trans-unit id="299fa4ce881470b697321e68c7758eae9bf1d1cf" translate="yes" xml:space="preserve">
          <source>You may find it helpful to have a &quot;macro dictionary&quot;, which you can produce by saying &lt;code&gt;cpp -dM perl.c | sort&lt;/code&gt;. Even then,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972b606b3734fb1680ed24e777ce569b72a6f320" translate="yes" xml:space="preserve">
          <source>You may find it helpful to use letter case to indicate the scope or nature of a variable. For example:</source>
          <target state="translated">您可能会发现使用字母大小写来表示变量的范围或性质很有帮助。例如:</target>
        </trans-unit>
        <trans-unit id="c25f48a1ca763d34150d8bac8dc30aeefcd980b5" translate="yes" xml:space="preserve">
          <source>You may get a bus error core dump from the op/pwent or op/grent tests. If compiled with -g you will see a stack trace much like the following:</source>
          <target state="translated">你可能会从op/pwent或op/grent测试中得到一个总线错误核心转储。如果用-g编译,你会看到一个类似下面的堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="108b6e50ab8abc6a709ca1e727e6115ff077c1f8" translate="yes" xml:space="preserve">
          <source>You may get a warning when doing a threaded build:</source>
          <target state="translated">在进行线程构建时,你可能会得到一个警告。</target>
        </trans-unit>
        <trans-unit id="22f1e826336ce72e185bd16ea03c1b6430323fa0" translate="yes" xml:space="preserve">
          <source>You may have an optional comma before the closing parenthesis of a list literal, so that you can say:</source>
          <target state="translated">你可以在列表文字的结尾括号前有一个可选的逗号,这样你就可以说。</target>
        </trans-unit>
        <trans-unit id="94ced856f582ad7ad5a45cb74870b4f4ae27ed8b" translate="yes" xml:space="preserve">
          <source>You may have to add extra libraries as well. Which ones? Perhaps those printed by</source>
          <target state="translated">你可能还需要添加额外的库。哪些库?也许是那些由</target>
        </trans-unit>
        <trans-unit id="adc5eceb43ab39f0721310d8a087b92c4cf96e19" translate="yes" xml:space="preserve">
          <source>You may have to re-read this entire section a few times...</source>
          <target state="translated">你可能要重新读几遍这一整节......</target>
        </trans-unit>
        <trans-unit id="9e568be51255384d52fb1c41217e7d274f15f0ca" translate="yes" xml:space="preserve">
          <source>You may ignore the error message for the first element of the archive (this doesn't look like a tar archive / skipping to next file...), it's only the directory which will be created automatically anyway.</source>
          <target state="translated">你可以忽略归档的第一个元素的错误信息(这看起来不像一个tar归档/跳到下一个文件......),它只是自动创建的目录。</target>
        </trans-unit>
        <trans-unit id="927c6b1abd9425ad341215fb99d87b72f734b089" translate="yes" xml:space="preserve">
          <source>You may intersperse documentation and Perl code within the .pm file. In fact, if you want to use method autoloading, you must do this, as the comment inside the .pm file explains.</source>
          <target state="translated">你可以在.pm文件中穿插文档和Perl代码。事实上,如果你想使用方法自动加载,你必须这样做,正如.pm文件中的注释所解释的那样。</target>
        </trans-unit>
        <trans-unit id="b911c24edf96323dfee0b5a16ac2655f93ba03e8" translate="yes" xml:space="preserve">
          <source>You may lock arrays and hashes as well as scalars. Locking an array, though, will not block subsequent locks on array elements, just lock attempts on the array itself.</source>
          <target state="translated">你可以锁定数组、哈希以及标量。不过锁定一个数组不会阻止后续对数组元素的锁定,只是对数组本身的锁定尝试。</target>
        </trans-unit>
        <trans-unit id="00344360ec287bdb5274fbd2e88953a8065f329a" translate="yes" xml:space="preserve">
          <source>You may look into the file</source>
          <target state="translated">你可以查一下文件</target>
        </trans-unit>
        <trans-unit id="9516dc740ae77942efcf6e8fd80e5504a8b1fd26" translate="yes" xml:space="preserve">
          <source>You may mail your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt; ) to perlbug@perl.org . If you've succeeded in compiling perl, the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; script in the</source>
          <target state="translated">您可以将错误报告（请确保将完整的配置信息作为myconfig程序在perl源树中或 &lt;code&gt;perl -V&lt;/code&gt; 中输出的信息）邮寄到perlbug@perl.org。如果您成功编译了perl，&lt;a href=&quot;perlbug&quot;&gt;请&lt;/a&gt;在</target>
        </trans-unit>
        <trans-unit id="9b598b6ebd49a9a2c8435acfea60cd639dc39cf9" translate="yes" xml:space="preserve">
          <source>You may need the following GNU programs in order to install perl:</source>
          <target state="translated">你可能需要以下GNU程序来安装perl。</target>
        </trans-unit>
        <trans-unit id="65000230f7491853635f8932fbc750e90e8f3c2d" translate="yes" xml:space="preserve">
          <source>You may need to be</source>
          <target state="translated">你可能需要</target>
        </trans-unit>
        <trans-unit id="64a7e3cbbe6d605d5c662e6d4594cef6c6e25ffe" translate="yes" xml:space="preserve">
          <source>You may need to carry out some system configuration tasks before running the Configure script for Perl.</source>
          <target state="translated">在运行Perl的Configure脚本之前,你可能需要执行一些系统配置任务。</target>
        </trans-unit>
        <trans-unit id="b5c6282830e01b5eeb55fdff2a78b2efbd4e43e4" translate="yes" xml:space="preserve">
          <source>You may need to examine the test results in a more flexible way, for example, the diagnostic output may be quite long or complex or it may involve something that you cannot predict in advance like a timestamp. In this case you can get direct access to the test results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10056deec90cd668c3f12e0f304b01dde73621d" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, no files with the names passed to &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt; , then &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="translated">您可能需要对为Unix系统编写的脚本进行此更改，这些脚本期望在调用 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 之后，不存在名称传递给 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 的文件。 （注意：这可以在编译时更改；如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 并且 &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; 是 &lt;code&gt;define&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 将在第一次调用时删除文件的所有版本。）</target>
        </trans-unit>
        <trans-unit id="1ff29c0121a8a089447657f7329f05cee5d1935c" translate="yes" xml:space="preserve">
          <source>You may need to make this change to scripts written for a Unix system which expect that after a call to &lt;code&gt;unlink&lt;/code&gt;, no files with the names passed to &lt;code&gt;unlink&lt;/code&gt; will exist. (Note: This can be changed at compile time; if you &lt;code&gt;use Config&lt;/code&gt; and &lt;code&gt;$Config{'d_unlink_all_versions'}&lt;/code&gt; is &lt;code&gt;define&lt;/code&gt;, then &lt;code&gt;unlink&lt;/code&gt; will delete all versions of a file on the first call.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec14405f03df7cdb78bb123848d4a14d07a8d45" translate="yes" xml:space="preserve">
          <source>You may not (usefully) use a reference as the key to a hash. It will be converted into a string:</source>
          <target state="translated">你不可以(有用的)使用引用作为哈希的密钥。它将被转换为一个字符串。</target>
        </trans-unit>
        <trans-unit id="d8a434e0ce88a99bf8a5488e4b0fad4981c52cd7" translate="yes" xml:space="preserve">
          <source>You may not even need to write the module. Check whether it's already been done in Perl, and avoid re-inventing the wheel unless you have a good reason.</source>
          <target state="translated">你可能甚至不需要写模块。检查一下是否已经在Perl中做过了,除非你有充分的理由,否则要避免重新发明轮子。</target>
        </trans-unit>
        <trans-unit id="936986b9e470ced1f7fdf65dd9ad838a32d13386" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt;, the variable of &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt;, the messages returned by &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="translated">您可能不会使用从程序外部获取的数据来影响程序外部的其他内容-至少并非偶然。所有命令行参数，环境变量，本地信息（参见&lt;a href=&quot;perllocale&quot;&gt;perllocale手册&lt;/a&gt;），某些系统调用（结果 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink()&lt;/a&gt;&lt;/code&gt; ，可变 &lt;code&gt;&lt;a href=&quot;functions/shmread&quot;&gt;shmread()&lt;/a&gt;&lt;/code&gt; ，通过返回的消息 &lt;code&gt;&lt;a href=&quot;functions/msgrcv&quot;&gt;msgrcv()&lt;/a&gt;&lt;/code&gt; ,密码，GCOS和外壳由 &lt;code&gt;getpwxxx()&lt;/code&gt; 调用返回的字段）和所有文件输入都标记为&amp;ldquo;污染&amp;rdquo;。&lt;b&gt;除以下情况外&lt;/b&gt;，不得在调用子外壳程序的任何命令中或在修改文件，目录或进程的任何命令中直接或间接使用污染数据：</target>
        </trans-unit>
        <trans-unit id="dd3902074b205dce05c67740cc2649d8a39ee898" translate="yes" xml:space="preserve">
          <source>You may not use data derived from outside your program to affect something else outside your program--at least, not by accident. All command line arguments, environment variables, locale information (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), results of certain system calls (&lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;readlink()&lt;/code&gt;, the variable of &lt;code&gt;shmread()&lt;/code&gt;, the messages returned by &lt;code&gt;msgrcv()&lt;/code&gt;, the password, gcos and shell fields returned by the &lt;code&gt;getpwxxx()&lt;/code&gt; calls), and all file input are marked as &quot;tainted&quot;. Tainted data may not be used directly or indirectly in any command that invokes a sub-shell, nor in any command that modifies files, directories, or processes, &lt;b&gt;with the following exceptions&lt;/b&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591a9362d10f62521cdde4ccfa89567d331e2d8b" translate="yes" xml:space="preserve">
          <source>You may notice that &lt;code&gt;PL_FILES&lt;/code&gt; is not specified above, since the default of mapping each .PL file to its basename works well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656cab64db0943d80c2c347bdd21c8a07c645dc2" translate="yes" xml:space="preserve">
          <source>You may once in a while try a &quot;make microperl&quot; to see whether we can still compile Perl with just the bare minimum of interfaces. (See README.micro.)</source>
          <target state="translated">你可以偶尔尝试一下 &quot;make microperl&quot;,看看我们是否还能用最低限度的接口来编译Perl。(参见 README.micro.)</target>
        </trans-unit>
        <trans-unit id="67acb9777380059ff280be22d8c3f8940dae8cc7" translate="yes" xml:space="preserve">
          <source>You may or may not choose to follow this usage. But never write &quot;PERL&quot;, because perl is not an acronym.</source>
          <target state="translated">你可以选择也可以不选择遵循这种用法。但千万不要写 &quot;PERL&quot;,因为perl不是一个缩写。</target>
        </trans-unit>
        <trans-unit id="613fbbe8af8f9b1517992c7dc5a2a0283f5a8c13" translate="yes" xml:space="preserve">
          <source>You may override this as you like; Maketext doesn't use it for anything.</source>
          <target state="translated">你可以随意覆盖它,Maketext不会用它来做任何事情。</target>
        </trans-unit>
        <trans-unit id="402c7a6c9e9b95e1569244e1df01e166ced2b5b5" translate="yes" xml:space="preserve">
          <source>You may redistribute this under the same terms as Perl itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c300617b79443af38e0fcd704c86c317dd858ef3" translate="yes" xml:space="preserve">
          <source>You may report corrections, additions, and suggestions on the CPAN Request Tracker at</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="471b54cb9da3fd2429477493f77011df7439603d" translate="yes" xml:space="preserve">
          <source>You may run into memory limits, in which case you should use the -Xmx option:</source>
          <target state="translated">你可能会遇到内存限制,在这种情况下,你应该使用-Xmx选项。</target>
        </trans-unit>
        <trans-unit id="2b87668ec2b109de55eff18c1a93548bfc928cdb" translate="yes" xml:space="preserve">
          <source>You may see a message about errors while extracting</source>
          <target state="translated">您可能会在解压时看到一条关于错误的信息</target>
        </trans-unit>
        <trans-unit id="567b2cee3d4edcc53c5dd10d0ae801a480e80721" translate="yes" xml:space="preserve">
          <source>You may see some messages during Configure that seem suspicious.</source>
          <target state="translated">在配置过程中,你可能会看到一些看似可疑的信息。</target>
        </trans-unit>
        <trans-unit id="6272ef61085d34f4e76b635ae7f550e4bd67beb6" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;&quot;The 13 variant characters&quot;&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d40b88fd93e71db6719630cc623bcd6de5e08cd" translate="yes" xml:space="preserve">
          <source>You may see the term &quot;invariant&quot; character or code point. This simply means that the character has the same numeric value and representation when encoded in UTF-8 (or UTF-EBCDIC) as when not. (Note that this is a very different concept from &lt;a href=&quot;#The-13-variant-characters&quot;&gt;The 13 variant characters&lt;/a&gt; mentioned above. Careful prose will use the term &quot;UTF-8 invariant&quot; instead of just &quot;invariant&quot;, but most often you'll see just &quot;invariant&quot;.) For example, the ordinal value of &quot;A&quot; is 193 in most EBCDIC code pages, and also is 193 when encoded in UTF-EBCDIC. All UTF-8 (or UTF-EBCDIC) variant code points occupy at least two bytes when encoded in UTF-8 (or UTF-EBCDIC); by definition, the UTF-8 (or UTF-EBCDIC) invariant code points are exactly one byte whether encoded in UTF-8 (or UTF-EBCDIC), or not. (By now you see why people typically just say &quot;UTF-8&quot; when they also mean &quot;UTF-EBCDIC&quot;. For the rest of this document, we'll mostly be casual about it too.) In ASCII UTF-8, the code points corresponding to the lowest 128 ordinal numbers (0 - 127: the ASCII characters) are invariant. In UTF-EBCDIC, there are 160 invariant characters. (If you care, the EBCDIC invariants are those characters which have ASCII equivalents, plus those that correspond to the C1 controls (128 - 159 on ASCII platforms).)</source>
          <target state="translated">您可能会看到术语&amp;ldquo;不变&amp;rdquo;字符或代码点。这仅表示在使用UTF-8（或UTF-EBCDIC）进行编码时，该字符具有与未使用相同的数字值和表示。 （请注意，这与&lt;a href=&quot;#The-13-variant-characters&quot;&gt;13个变体字符&lt;/a&gt;截然不同上文提到的。细心的散文将使用术语&amp;ldquo; UTF-8不变式&amp;rdquo;，而不仅仅是&amp;ldquo;不变式&amp;rdquo;，但是大多数情况下，您只会看到&amp;ldquo;不变式&amp;rdquo;。）例如，在大多数EBCDIC代码页中，&amp;ldquo; A&amp;rdquo;的序数值为193，以UTF-EBCDIC编码时也为193。当以UTF-8（或UTF-EBCDIC）进行编码时，所有UTF-8（或UTF-EBCDIC）变体代码点至少占据两个字节；根据定义，无论是否以UTF-8（或UTF-EBCDIC）进行编码，UTF-8（或UTF-EBCDIC）不变代码点都是一个字节。 （到现在为止，您就会明白为什么人们在通常也表示&amp;ldquo; UTF-EBCDIC&amp;rdquo;的情况下通常只说&amp;ldquo; UTF-8&amp;rdquo;。对于本文档的其余部分，我们也会大为随意。）在ASCII UTF-8中，与最低的128个序数（0-127：ASCII字符）相对应的代码点是不变的。在UTF-EBCDIC中，有160个不变字符。 （如果需要，EBCDIC不变量是指具有ASCII等价字符的字符，以及与C1控件相对应的字符（在ASCII平台上为128-159）。）</target>
        </trans-unit>
        <trans-unit id="79733aabc84104a70d6cbcc3a880d8aa4897ea07" translate="yes" xml:space="preserve">
          <source>You may sense that a lexicon (to use a non-committal catch-all term for a collection of things you know how to say, regardless of whether they're phrases or words) consisting of functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa093d809cde8bd253ba564171319f316c1ecb65" translate="yes" xml:space="preserve">
          <source>You may set the &lt;code&gt;dw_size&lt;/code&gt; option to limit the amount of data that can be saved in the deferred write buffer. This limit may not exceed the total memory limit. For example, if you set &lt;code&gt;dw_size&lt;/code&gt; to 1000 and &lt;code&gt;memory&lt;/code&gt; to 2500, that means that no more than 1000 bytes of deferred writes will be saved up. The space available for the read cache will vary, but it will always be at least 1500 bytes (if the deferred write buffer is full) and it could grow as large as 2500 bytes (if the deferred write buffer is empty.)</source>
          <target state="translated">您可以设置 &lt;code&gt;dw_size&lt;/code&gt; 选项以限制可以保存在延迟写入缓冲区中的数据量。此限制不能超过总内存限制。例如，如果将 &lt;code&gt;dw_size&lt;/code&gt; 设置为1000，将 &lt;code&gt;memory&lt;/code&gt; 为2500，则意味着最多可以保存1000个字节的延迟写入。读缓存的可用空间会有所不同，但始终至少为1500字节（如果延迟的写缓冲区已满），并且可能会增长到2500字节（如果延迟的写缓冲区为空）。</target>
        </trans-unit>
        <trans-unit id="e3ef89e73cb3013d59d9c9121bbae022ae6a75e6" translate="yes" xml:space="preserve">
          <source>You may submit your bug reports (be sure to include full configuration information as output by the myconfig program in the perl source tree, or by &lt;code&gt;perl -V&lt;/code&gt;) to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe802847d2e9437afa3772a7f3ed12ac0cb75f5" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see &lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt&lt;/a&gt; for more information. Note: quotations in this topic from same.).</source>
          <target state="translated">您可以在RFC3461定义的匿名数组引用中使用这三个值'SUCCESS'，'FAILURE'，'DELAY'的任意组合（有关更多信息，请参见&lt;a href=&quot;http://www.ietf.org/rfc/rfc3461.txt&quot;&gt;http://www.ietf.org/rfc/rfc3461.txt）&lt;/a&gt;。注意：本主题中的引号相同。）。</target>
        </trans-unit>
        <trans-unit id="36629e1d8b3fb0403dc71736a38b10adc1877865" translate="yes" xml:space="preserve">
          <source>You may use any combination of these three values 'SUCCESS','FAILURE','DELAY' in the anonymous array reference as defined by RFC3461 (see http://www.ietf.org/rfc/rfc3461.txt for more information. Note: quotations in this topic from same.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3726ab64bc777be024735266d80e288f34e7bd83" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt; .</source>
          <target state="translated">可以将 &lt;code&gt;mv&lt;/code&gt; 别名用于此功能，就像将 &lt;code&gt;cp&lt;/code&gt; 别名用于 &lt;code&gt;copy&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="fb0e3799f2ec470ffb4ae33dcfe538e7d9e90c15" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;mv&lt;/code&gt; alias for this function in the same way that you may use the &lt;code&gt;cp&lt;/code&gt; alias for &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9368b724095114d596f9a9bbd047855f785492a1" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="translated">您可以使用语法 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; File::Copy &quot;cp&quot;&lt;/code&gt; 来获取此函数的 &lt;code&gt;cp&lt;/code&gt; 别名。语法是</target>
        </trans-unit>
        <trans-unit id="2cddc64528e49f0c1ae7766ec48b73a37ff2e0c8" translate="yes" xml:space="preserve">
          <source>You may use the syntax &lt;code&gt;use File::Copy &quot;cp&quot;&lt;/code&gt; to get at the &lt;code&gt;cp&lt;/code&gt; alias for this function. The syntax is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354ed25e81c6f68b0172423d879862310feed1c5" translate="yes" xml:space="preserve">
          <source>You may very well want to see how your subpattern gets compiled, but it is likely of less use to you to see how Perl matches that against all the legal possibilities, as that is under control of Perl, not you. Therefore, the debugging information of the compilation portion is as specified by the other options, but the debugging output of the matching portion is normally suppressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ef4fe61a399da32f9cc97283defa049459439a2" translate="yes" xml:space="preserve">
          <source>You may want to configure something like</source>
          <target state="translated">你可能想配置一些像</target>
        </trans-unit>
        <trans-unit id="a188842328fc3a53256335dbb97698cdb0d7e65f" translate="yes" xml:space="preserve">
          <source>You may want to create the destination directory and give it the right permissions before installing, thus eliminating the need to build Perl as a super user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274166c866cd17a4a70da3e9dd16359e3df50e0e" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Digits&quot;&gt;/\d/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="3d3a0b34238678a39ac71745f1262bf0f4700e24" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;/\s/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="30ce0fc76dee65d768e8b8edbb86d17b3ec69cef" translate="yes" xml:space="preserve">
          <source>You may want to use the &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; construct instead.</source>
          <target state="translated">您可能要改用 &lt;code&gt;&lt;a href=&quot;perlrecharclass#Word-characters&quot;&gt;/\w/&lt;/a&gt;&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="599db7e90374e2462ae43e1deb74b5ede6e00ac9" translate="yes" xml:space="preserve">
          <source>You may wish to put your version of perl in the PATH of all users by changing the link</source>
          <target state="translated">您可能希望将您的perl版本放在所有用户的PATH中,方法是更改以下链接</target>
        </trans-unit>
        <trans-unit id="a667970ef9d2de2018d0cc9d89b6040168c92e68" translate="yes" xml:space="preserve">
          <source>You might also be interested in using the &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; to measure and compare code snippets.</source>
          <target state="translated">您可能还对使用&lt;a href=&quot;benchmark&quot;&gt;基准&lt;/a&gt;来测量和比较代码段感兴趣。</target>
        </trans-unit>
        <trans-unit id="e19209d2418cb6070db23de3b3f291f912738061" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2fb8d4423459616a83c78e11c0c6368281abff5" translate="yes" xml:space="preserve">
          <source>You might also find it more fun to use the standard &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, or the &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt; module's &lt;code&gt;$DB_RECNO&lt;/code&gt; bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</source>
          <target state="translated">您可能还会发现使用标准的&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;模块或&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;模块的 &lt;code&gt;$DB_RECNO&lt;/code&gt; 绑定会更有趣，该绑定使您可以将数组绑定到文件，以便访问数组的元素实际上可以访问数组中的相应行。文件。</target>
        </trans-unit>
        <trans-unit id="e08469744ffe89846f236eef2581143171c3fbcd" translate="yes" xml:space="preserve">
          <source>You might also have loaded that from a function:</source>
          <target state="translated">你也可能是从一个函数中加载的。</target>
        </trans-unit>
        <trans-unit id="95a16ffa9a148d97aba69dab68818a05442a9c0f" translate="yes" xml:space="preserve">
          <source>You might also see the terms &lt;b&gt;getter&lt;/b&gt; and &lt;b&gt;setter&lt;/b&gt;. These are two types of accessors. A getter gets the attribute's value, while a setter sets it. Another term for a setter is &lt;b&gt;mutator&lt;/b&gt;</source>
          <target state="translated">您可能还会看到术语&lt;b&gt;getter&lt;/b&gt;和&lt;b&gt;setter&lt;/b&gt;。这是两种类型的访问器。获取器获取属性的值，而设置器设置属性的值。setter的另一个术语是&lt;b&gt;mutator&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a6f4008d05ac5a7684642f452fcea99bbe63649d" translate="yes" xml:space="preserve">
          <source>You might also think of closure as a way to write a subroutine template without using eval(). Here's a small example of how closures work:</source>
          <target state="translated">你也可以把闭包看作是一种不使用eval()而编写子程序模板的方法。下面是一个关于闭包如何工作的小例子。</target>
        </trans-unit>
        <trans-unit id="adab95dd47c51cc1af72771a0152072872dcbaaf" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2Flibrary-directory%3F&quot;&gt;&quot;How do I keep my own module/library directory?&quot; in perlfaq8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b07a183cbfa7c2c5ada23e1358bb836c0036ff82" translate="yes" xml:space="preserve">
          <source>You might also want to check out &lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;How do I keep my own module/library directory? in perlfaq8&lt;/a&gt;.</source>
          <target state="translated">您可能还想查看&lt;a href=&quot;perlfaq8#How-do-I-keep-my-own-module%2flibrary-directory%3f&quot;&gt;如何保留自己的模块/库目录？在perlfaq8中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9d50c5088a6a6db1dd16f71b5a0b7ad311259d2" translate="yes" xml:space="preserve">
          <source>You might also want to employ anonymous functions for simple signal handlers:</source>
          <target state="translated">你可能还想为简单的信号处理程序采用匿名函数。</target>
        </trans-unit>
        <trans-unit id="c4f0a4c3456aabab2b8397ba18c3d239195efdd9" translate="yes" xml:space="preserve">
          <source>You might also want to have GNU groff for OS/390 installed before running the &quot;make install&quot; step for Perl.</source>
          <target state="translated">在运行 Perl 的 &quot;make install &quot;步骤之前,你可能还需要安装 GNU groff for OS/390。</target>
        </trans-unit>
        <trans-unit id="2fa0f7304d269ada4e265c5dcd91a35489923597" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block around the whole thing.</source>
          <target state="translated">您可能还想通过将 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 块包裹在整个对象上来捕获任何错误。</target>
        </trans-unit>
        <trans-unit id="f194f9c87c4be6e7a8b64a94f082480b14ad7510" translate="yes" xml:space="preserve">
          <source>You might also want to trap any errors by wrapping an &lt;code&gt;eval&lt;/code&gt; block around the whole thing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae14caefeb104abfd32e1ac4b08ddaa6c43442c2" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt; , but it isn't, so don't.</source>
          <target state="translated">您可能会倾向于认为延迟写入就像是事务，将 &lt;code&gt;flush&lt;/code&gt; 作为 &lt;code&gt;commit&lt;/code&gt; ， &lt;code&gt;discard&lt;/code&gt; 作为 &lt;code&gt;rollback&lt;/code&gt; ，但是事实并非如此，所以不要这样做。</target>
        </trans-unit>
        <trans-unit id="1c6b7aa981d94fea5d2afafa18044a92955cf0dc" translate="yes" xml:space="preserve">
          <source>You might be tempted to think that deferred writing is like transactions, with &lt;code&gt;flush&lt;/code&gt; as &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; as &lt;code&gt;rollback&lt;/code&gt;, but it isn't, so don't.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadb7f27713b1af6126dec14d8fa3f25be31b545" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;$#array + 1&lt;/code&gt; to tell you how many items there are in an array. Don't bother. As it happens, using &lt;code&gt;@array&lt;/code&gt; where Perl expects to find a scalar value (&quot;in scalar context&quot;) will give you the number of elements in the array:</source>
          <target state="translated">您可能会想使用 &lt;code&gt;$#array + 1&lt;/code&gt; 来告诉您数组中有多少个项目。不要打扰 碰巧的是，在Perl期望找到标量值的地方使用&amp;ldquo; &lt;code&gt;@array&lt;/code&gt; &amp;rdquo;（&amp;ldquo;在标量上下文中&amp;rdquo;）将为您提供数组中元素的数量：</target>
        </trans-unit>
        <trans-unit id="cdd5e43c44200a95eaa3aa45d374b3ef4d1b96c7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="translated">您可能会考虑只使用Math :: BigInt或Math :: BigFloat，因为它们使您可以更好地控制在哪个模块/空间中完成的工作。例如，简单的循环计数器将是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bignum;&lt;/code&gt; Math :: BigInts ；这比将它们保持为Perl标量要慢：</target>
        </trans-unit>
        <trans-unit id="30c848bd997fa1fb77285aa03d0d04fc4d8a21e7" translate="yes" xml:space="preserve">
          <source>You might consider using just Math::BigInt or Math::BigFloat, since they allow you finer control over what get's done in which module/space. For instance, simple loop counters will be Math::BigInts under &lt;code&gt;use bignum;&lt;/code&gt; and this is slower than keeping them as Perl scalars:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602086881bebd3c9c81540dfd1686b9dc1e9a7c1" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt; ) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt; ) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="translated">您可能希望它输出&amp;ldquo; 12&amp;rdquo;。实际上，它会打印&amp;ldquo; &amp;lt;&amp;rdquo;：处理&amp;ldquo; |&amp;rdquo;的ASCII结果 作为按位的字符串运算符-即，将操作数视为字符串&amp;ldquo; 4&amp;rdquo;和&amp;ldquo; 8&amp;rdquo;而不是数字的结果。实现numify（ &lt;code&gt;0+&lt;/code&gt; ）而实现stringify（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）并没有什么不同，因为后者只是从前者自动生成的。</target>
        </trans-unit>
        <trans-unit id="aba6c51d79ac08de8cd8c4628728aebfc81fc52e" translate="yes" xml:space="preserve">
          <source>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&amp;lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (&lt;code&gt;0+&lt;/code&gt;) is implemented but stringify (&lt;code&gt;&quot;&quot;&lt;/code&gt;) isn't makes no difference since the latter is simply autogenerated from the former.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2b6e72cccd9ea401a92e1c584d3ce729f0ed23" translate="yes" xml:space="preserve">
          <source>You might find these links useful:</source>
          <target state="translated">你可能会发现这些链接很有用。</target>
        </trans-unit>
        <trans-unit id="7041884103fb3be2206f9857bdd3e655cde0bf34" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of $x, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="translated">您可能希望测试3失败，因为它似乎是测试1的通用版本。它们之间的重要区别在于，测试3包含量词（ &lt;code&gt;\D*&lt;/code&gt; ），因此可以使用回溯，而测试1则不会。发生的事情是，您问&amp;ldquo;在$ x的开头，跟随0或多个非数字，您的值不是123吗？&amp;rdquo; 如果模式匹配器将 &lt;code&gt;\D*&lt;/code&gt; 扩展为&amp;ldquo; ABC&amp;rdquo;，则将导致整个模式失败。</target>
        </trans-unit>
        <trans-unit id="8d27aa5c6286c0d9603c5055be14cd21bce623ba" translate="yes" xml:space="preserve">
          <source>You might have expected test 3 to fail because it seems to a more general purpose version of test 1. The important difference between them is that test 3 contains a quantifier (&lt;code&gt;\D*&lt;/code&gt;) and so can use backtracking, whereas test 1 will not. What's happening is that you've asked &quot;Is it true that at the start of &lt;code&gt;$x&lt;/code&gt;, following 0 or more non-digits, you have something that's not 123?&quot; If the pattern matcher had let &lt;code&gt;\D*&lt;/code&gt; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bd0f9bdd3b3f8f6c3d7920cb7c553cce6d6284" translate="yes" xml:space="preserve">
          <source>You might like to read Mark Jason Dominus's &quot;Suffering From Buffering&quot; at &lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt; .</source>
          <target state="translated">您可能想在&lt;a href=&quot;http://perl.plover.com/FAQs/Buffering.html&quot;&gt;http://perl.plover.com/FAQs/Buffering.html&lt;/a&gt;上阅读Mark Jason Dominus的&amp;ldquo;遭受缓冲&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="46f43a5be926bef744cfabc91aaec25e6a108f46" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e0af742e5a24576127c7192de3da3f64667af3" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">您可能想使用 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 读取程序配置文件。可以通过以下方式进行手动错误检查：</target>
        </trans-unit>
        <trans-unit id="ea3e43e35b42104c2dfdbbb81763643be691010c" translate="yes" xml:space="preserve">
          <source>You might like to use &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; to read in a program configuration file. Manual error checking can be done this way:</source>
          <target state="translated">您可能想使用 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 读取程序配置文件。可以通过以下方式进行手动错误检查：</target>
        </trans-unit>
        <trans-unit id="2bd0dacd69a7ed36257e893211378330acac2cba" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider asking the &lt;code&gt;module-authors@perl.org&lt;/code&gt; mailing list (send an email to &lt;code&gt;module-authors-subscribe@perl.org&lt;/code&gt; to subscribe; see &lt;a href=&quot;https://lists.perl.org/list/module-authors.html&quot;&gt;https://lists.perl.org/list/module-authors.html&lt;/a&gt; for more information and a link to the archives).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052100b20ac103ab19054e70ed9a9d17e374ebf5" translate="yes" xml:space="preserve">
          <source>You might love it. You might feel that everyone else needs it. But there might not actually be any real demand for it out there. If you're unsure about the demand your module will have, consider sending out feelers on the &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; newsgroup, or as a last resort, ask the modules list at &lt;code&gt;modules@perl.org&lt;/code&gt; . Remember that this is a closed list with a very long turn-around time - be prepared to wait a good while for a response from them.</source>
          <target state="translated">您可能会喜欢。您可能会觉得其他所有人都需要它。但是实际上可能没有任何实际需求。如果您不确定模块的需求，请考虑在 &lt;code&gt;comp.lang.perl.modules&lt;/code&gt; 新闻组中发送探针，或者作为最后的选择，在 &lt;code&gt;modules@perl.org&lt;/code&gt; 上询问模块列表。请记住，这是一个关闭列表，周转时间很长-请准备好等待一段时间，以便得到他们的答复。</target>
        </trans-unit>
        <trans-unit id="635f4d083c94bfb096f7bc0bc442f402e843c1a1" translate="yes" xml:space="preserve">
          <source>You might mistakenly think that &lt;code&gt;len&lt;/code&gt; is the number of bytes to add to the existing size, but instead it is the total size &lt;code&gt;sv&lt;/code&gt; should be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169bde04d58834aed9e29a6302664c4d13ccbcd6" translate="yes" xml:space="preserve">
          <source>You might not need all the power of XS. The Inline::C module lets you put C code directly in your Perl source. It handles all the magic to make it work. You still have to learn at least some of the perl API but you won't have to deal with the complexity of the XS support files.</source>
          <target state="translated">你可能不需要XS的所有功能。Inline::C模块可以让你直接在Perl源代码中加入C代码。它处理了所有的魔法,使其工作。你仍然需要学习至少一些perl API,但你不必处理复杂的XS支持文件。</target>
        </trans-unit>
        <trans-unit id="3b031c43f33840adc70b02de47a8fd1daefabaa6" translate="yes" xml:space="preserve">
          <source>You might notice several familiar Perl concepts in this collection of ACM columns from Jon Bentley. The similarity to the title of the major Perl book (which came later) is not completely accidental:</source>
          <target state="translated">你可能会注意到,在Jon Bentley的这本ACM专栏集中,有几个熟悉的Perl概念。与主要的Perl书籍(后来才有的)的标题相似并非完全偶然。</target>
        </trans-unit>
        <trans-unit id="66fdf1bb9d02362c3ab6fa3feaa38bdbfcec77f8" translate="yes" xml:space="preserve">
          <source>You might notice that you could use backticks for much the same effect as opening a pipe for reading:</source>
          <target state="translated">你可能会注意到,你可以用背杆来达到和开管阅读差不多的效果。</target>
        </trans-unit>
        <trans-unit id="42704287df9412e9063781246ba069342cd72b32" translate="yes" xml:space="preserve">
          <source>You might notice this when each of the elements of &lt;code&gt;@array&lt;/code&gt; end with a newline. You expect to print one element per line, but notice that every line after the first is indented:</source>
          <target state="translated">当 &lt;code&gt;@array&lt;/code&gt; 的每个元素以换行符结尾时，您可能会注意到这一点。您希望每行打印一个元素，但是请注意，第一行之后的每一行都是缩进的：</target>
        </trans-unit>
        <trans-unit id="e3ccde21cef99ed04d4c1fb15da658aad8223bd5" translate="yes" xml:space="preserve">
          <source>You might prefer to go on to &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt; instead of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;; it discusses lists of lists and multidimensional arrays in detail. After that, you should move on to &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;; it's a Data Structure Cookbook that shows recipes for using and printing out arrays of hashes, hashes of arrays, and other kinds of data.</source>
          <target state="translated">您可能更喜欢&lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;而不是&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;；它详细讨论了列表列表和多维数组。之后，您应该继续进行&lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;；这是一本数据结构手册，其中显示了使用和打印哈希数组，数组哈希以及其他类型数据的方法。</target>
        </trans-unit>
        <trans-unit id="a6310ecb45c68b753610be852acb876a80aa3c10" translate="yes" xml:space="preserve">
          <source>You might relate this to a fictional 'Translate' module:</source>
          <target state="translated">你可以把它和一个虚构的 &quot;翻译 &quot;模块联系起来。</target>
        </trans-unit>
        <trans-unit id="13ab2e65d93fb0059f6f55ed6a75f22913178d96" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or
&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; .</source>
          <target state="translated">您可能还记得 &lt;code&gt;ok() or diag()&lt;/code&gt; 以及助记符 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;() or &lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88eec674517534aa08403d748f3a5041ffce6d87" translate="yes" xml:space="preserve">
          <source>You might remember &lt;code&gt;ok() or diag()&lt;/code&gt; with the mnemonic &lt;code&gt;open() or die()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c266ee238a4776706bced7eb857615f2dea1e3c" translate="yes" xml:space="preserve">
          <source>You might sometimes find that the original author has edited the branch's history. There are lots of good reasons for this. Sometimes, an author might simply be rebasing the branch onto a newer source point. Sometimes, an author might have found an error in an early commit which they wanted to fix before merging the branch to blead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d4864369383102be2440cd5c5cb4b7987e528b" translate="yes" xml:space="preserve">
          <source>You might sometimes see reference to Rule 1 and Rule 2. Larry's power as Supreme Court is expressed in The Rules:</source>
          <target state="translated">你有时可能会看到对规则1和规则2的参考。拉里作为最高法院的权力在《规则》中得到了体现。</target>
        </trans-unit>
        <trans-unit id="8dd311a23537c2ad8611321313121285ae51f8bb" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;Encode::Guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5b7d1197bc89948add2ed3f352d319d84d2e28b" translate="yes" xml:space="preserve">
          <source>You might try &lt;a href=&quot;encode/guess&quot;&gt;Encode::Guess&lt;/a&gt;, but it has a number of limitations.</source>
          <target state="translated">您可以尝试&lt;a href=&quot;encode/guess&quot;&gt;Encode :: Guess&lt;/a&gt;，但是它有很多限制。</target>
        </trans-unit>
        <trans-unit id="193b85d5b4fe0e90a0d9c66d7d0b78036e923063" translate="yes" xml:space="preserve">
          <source>You might want to do the same thing for expressing key bindings or the like (since hardwiring &quot;q&quot; as the binding for the function that quits a screen/menu/program is useful only if your language happens to associate &quot;q&quot; with &quot;quit&quot;!)</source>
          <target state="translated">你可能想对表达键绑定或类似的东西做同样的事情(因为只有当你的语言恰好将 &quot;q &quot;与 &quot;quit &quot;联系在一起时,将 &quot;q &quot;作为退出屏幕/菜单/程序的函数绑定才会有用!)。</target>
        </trans-unit>
        <trans-unit id="b5d495d915ce638287be04e211dc9e03d5ac46bf" translate="yes" xml:space="preserve">
          <source>You might want to keep these desktop references close by your keyboard:</source>
          <target state="translated">你可能想把这些桌面参考资料放在键盘旁。</target>
        </trans-unit>
        <trans-unit id="d8a5e7dd7b9870679e3daf8f99524f8e40f1a078" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1eb54f95a4e04b463b84dfe6de9e8067695824" translate="yes" xml:space="preserve">
          <source>You might wonder why &lt;code&gt;'.'&lt;/code&gt; matches everything but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; - why not every character? The reason is that often one is matching against lines and would like to ignore the newline characters. For instance, while the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; represents one line, we would like to think of it as empty. Then</source>
          <target state="translated">您可能想知道为什么 &lt;code&gt;'.'&lt;/code&gt; 匹配除 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 所有字符-为什么不匹配每个字符？原因是经常有人将其与行匹配并且想忽略换行符。例如，虽然字符串 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 代表一行，但我们希望将其视为空。然后</target>
        </trans-unit>
        <trans-unit id="e851d081cca3db1538b95133dfa4e2591e66b038" translate="yes" xml:space="preserve">
          <source>You must Configure perl with</source>
          <target state="translated">你必须在配置perl时使用</target>
        </trans-unit>
        <trans-unit id="2b0e2052701354699753b2ee60dea4ed06963928" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;system()&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18657846c86f19718177ea80036f400e403ff68" translate="yes" xml:space="preserve">
          <source>You must be triply conscious of cross-platform concerns. This usually boils down to using &lt;a href=&quot;file/spec&quot;&gt;File::Spec&lt;/a&gt;, avoiding things like &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; unless absolutely necessary, and not assuming that a given character has a particular ordinal value (code point) or that its UTF-8 representation is composed of particular bytes.</source>
          <target state="translated">您必须三重意识到跨平台问题。这通常归结为使用&lt;a href=&quot;file/spec&quot;&gt;File :: Spec&lt;/a&gt;，除非绝对必要，否则避免使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 之类的东西，并且不假定给定字符具有特定的序数值（代码点）或它的UTF-8表示形式构成的特定字节。</target>
        </trans-unit>
        <trans-unit id="8daf2a31e4062052794994fb1a77c6bf915b4376" translate="yes" xml:space="preserve">
          <source>You must call &lt;code&gt;plan(...)&lt;/code&gt; once and only once. You should call it in a &lt;code&gt;BEGIN {...}&lt;/code&gt; block, like so:</source>
          <target state="translated">您只能调用一次 &lt;code&gt;plan(...)&lt;/code&gt; 。您应该在 &lt;code&gt;BEGIN {...}&lt;/code&gt; 块中调用它，如下所示：</target>
        </trans-unit>
        <trans-unit id="ec48be76fb2e44c8427a737bacd675c106899a43" translate="yes" xml:space="preserve">
          <source>You must convert your non-ASCII, non-UTF-8 Perl scripts to be UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9b102a51e636379025c1716da72ec7158d144f" translate="yes" xml:space="preserve">
          <source>You must have a plan.</source>
          <target state="translated">你必须有一个计划。</target>
        </trans-unit>
        <trans-unit id="f323bd128da70502b49397ad0f7c4f483197be9e" translate="yes" xml:space="preserve">
          <source>You must have a project base class, which you load, and which you then use as the first argument in the call to YourProjClass-&amp;gt;get_handle(...). It should derive (whether directly or indirectly) from Locale::Maketext. It &lt;b&gt;doesn't matter&lt;/b&gt; how you name this class, although assuming this is the localization component of your Super Mega Program, good names for your project class might be SuperMegaProgram::Localization, SuperMegaProgram::L10N, SuperMegaProgram::I18N, SuperMegaProgram::International, or even SuperMegaProgram::Languages or SuperMegaProgram::Messages.</source>
          <target state="translated">您必须具有一个项目基类，该基类必须加载，然后用作调用YourProjClass-&amp;gt; get_handle（...）的第一个参数。它应该（无论是直接还是间接）从Locale :: Maketext派生。这&lt;b&gt;不要紧，&lt;/b&gt;你如何命名这个类，但假设这是你的超大型项目的本地化部件，为您的项目类的好名字可能是SuperMegaProgram ::本地化，SuperMegaProgram ::本地化，SuperMegaProgram ::国际化，SuperMegaProgram ::国际，甚至SuperMegaProgram :: Languages或SuperMegaProgram :: Messages。</target>
        </trans-unit>
        <trans-unit id="739cc975a787be41633b91aa5de71e36b127ddec" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;eexpect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">您必须安装 &lt;code&gt;Expect&lt;/code&gt; 模块才能使用 &lt;code&gt;eexpect&lt;/code&gt; 。CPAN.pm不会为您安装它。</target>
        </trans-unit>
        <trans-unit id="72fde4fbc93c4a749f9096aea6d3bd9a70e80b1d" translate="yes" xml:space="preserve">
          <source>You must install the &lt;code&gt;Expect&lt;/code&gt; module to use &lt;code&gt;expect&lt;/code&gt; . CPAN.pm does not install it for you.</source>
          <target state="translated">您必须安装 &lt;code&gt;Expect&lt;/code&gt; 到使用模块 &lt;code&gt;expect&lt;/code&gt; 。CPAN.pm不会为您安装它。</target>
        </trans-unit>
        <trans-unit id="4490a879ca5d596cdf1f67e2681afb5d54f17c52" translate="yes" xml:space="preserve">
          <source>You must make sure that any paths and path components are properly surrounded with double-quotes if they contain spaces. For example, &lt;code&gt;$potential_libs&lt;/code&gt; could be (literally):</source>
          <target state="translated">如果路径和路径组件包含空格，则必须确保用双引号将其正确包围。例如， &lt;code&gt;$potential_libs&lt;/code&gt; 可以是（字面上）：</target>
        </trans-unit>
        <trans-unit id="30c4fd5a99a25cad991844e3c5c4f7509fd399a0" translate="yes" xml:space="preserve">
          <source>You must open your files before you print to them.</source>
          <target state="translated">您必须在打印之前打开文件。</target>
        </trans-unit>
        <trans-unit id="45897939488bd63d927112e2ca64e2fec16238a0" translate="yes" xml:space="preserve">
          <source>You must override the abstract methods as noted above.</source>
          <target state="translated">你必须覆盖上面提到的抽象方法。</target>
        </trans-unit>
        <trans-unit id="2aa81922480ed45c435c4cf0c99c4c4aba3634fc" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt; .</source>
          <target state="translated">您必须使用 &lt;code&gt;elsif&lt;/code&gt; 而不是 &lt;code&gt;else if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5226624761673c1e1cddc0c742247733ee03083" translate="yes" xml:space="preserve">
          <source>You must use &lt;code&gt;elsif&lt;/code&gt; rather than &lt;code&gt;else if&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c7a78d87a43f543e7180d2370d441ee16c546b" translate="yes" xml:space="preserve">
          <source>You must use an ANSI C compiler to build perl. Perl can be compiled with either Sun's add-on C compiler or with gcc. The C compiler that shipped with SunOS4 will not do.</source>
          <target state="translated">你必须使用ANSI C编译器来编译perl。Perl 可以用 Sun 的附加 C 编译器或 gcc 编译。SunOS4附带的C编译器是不行的。</target>
        </trans-unit>
        <trans-unit id="ac16e240bd822406d6dbb8a20f6f3e5d780cc6b4" translate="yes" xml:space="preserve">
          <source>You must use the cmd.exe, the Cygwin shell will not work. The PATH must include the SDK tools, including a Perl, which should be the case under cmd.exe. If you do not have that, see the end of symbian\sdk.pl for notes of how your environment should be set up for Symbian compiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c168b8ed4e8b351eba14fd33d598861cf2969e22" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt; es while packing. There is no way for pack() and unpack() to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="translated">您必须自己进行任何对齐或填充操作，例如在包装时插入足够的 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 。pack（）和unpack（）无法知道字符的去向或来源，因此它们将输出和输入作为字符的平面序列来处理。</target>
        </trans-unit>
        <trans-unit id="da2b6f4499c28ef8f95dd1270da02ad4217bd0a5" translate="yes" xml:space="preserve">
          <source>You must yourself do any alignment or padding by inserting, for example, enough &lt;code&gt;&quot;x&quot;&lt;/code&gt;es while packing. There is no way for &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; to know where characters are going to or coming from, so they handle their output and input as flat sequences of characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495ba80801ecf71f6944f8f06ac3f6b0ec33f568" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, nmake will work. Builds using the gcc need dmake.</source>
          <target state="translated">你需要一个 &quot;make &quot;程序来构建源代码。如果你使用Visual C++或Windows SDK工具,nmake就可以。使用gcc编译则需要dmake。</target>
        </trans-unit>
        <trans-unit id="6e03410c2453434206af384ed70ad4bb1fdfc03a" translate="yes" xml:space="preserve">
          <source>You need a &quot;make&quot; program to build the sources. If you are using Visual C++ or the Windows SDK tools, you can use nmake supplied with Visual C++ or Windows SDK. You may also use, for Visual C++ or Windows SDK, dmake or gmake instead of nmake. dmake is open source software, but is not included with Visual C++ or Windows SDK. Builds using gcc need dmake or gmake. nmake is not supported for gcc builds. Parallel building is only supported with dmake and gmake, not nmake. When using dmake it is recommended to use dmake 4.13 or newer for parallel building. Older dmakes, in parallel mode, have very high CPU usage and pound the disk/filing system with duplicate I/O calls in an aggressive polling loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="384c0cf5619a59f9ce19e0cd720b3f9bfb700b5a" translate="yes" xml:space="preserve">
          <source>You need a separate perl executable</source>
          <target state="translated">你需要一个单独的perl可执行文件</target>
        </trans-unit>
        <trans-unit id="aa34c474feea2ebcd51fe52bc61e21c7aa534d7c" translate="yes" xml:space="preserve">
          <source>You need an installed and working gccsdk cross compiler &lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt; and REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</source>
          <target state="translated">您需要一个已安装且正在运行的gccsdk交叉编译器&lt;a href=&quot;http://gccsdk.riscos.info/&quot;&gt;http://gccsdk.riscos.info/&lt;/a&gt;和REXEN &lt;a href=&quot;http://www.cp15.org/programming/&quot;&gt;http://www.cp15.org/programming/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4caefc1d4e2631b1200ec354d43fce32735ee7c7" translate="yes" xml:space="preserve">
          <source>You need at the very least AmigaOS version 2.0. Recommended is version 3.1.</source>
          <target state="translated">你至少需要AmigaOS 2.0版本。推荐的是3.1版本。</target>
        </trans-unit>
        <trans-unit id="5333f88ac5bf8fd24e224f0d8051b5fec4dfc6b5" translate="yes" xml:space="preserve">
          <source>You need the Unix emulation for AmigaOS, whose most important part is &lt;b&gt;ixemul.library&lt;/b&gt;. For a minimum setup, get the latest versions of the following packages from the Aminet archives ( &lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt; ):</source>
          <target state="translated">您需要用于AmigaOS的Unix仿真，其最重要的部分是&lt;b&gt;ixemul.library&lt;/b&gt;。对于最低设置，请从Aminet存档（&lt;a href=&quot;http://www.aminet.net/~aminet/&quot;&gt;http://www.aminet.net/~aminet/&lt;/a&gt;）中获取以下软件包的最新版本：</target>
        </trans-unit>
        <trans-unit id="46e89c73cbc6b5dd39fd756e0f6110a1446e5be5" translate="yes" xml:space="preserve">
          <source>You need the following files to build perl (or add new modules):</source>
          <target state="translated">你需要以下文件来构建perl(或添加新模块)。</target>
        </trans-unit>
        <trans-unit id="9f9c012bcf4380f633cf4f7379c24b96c60ecb4b" translate="yes" xml:space="preserve">
          <source>You need to add either braces or blanks to disambiguate.</source>
          <target state="translated">你需要加括号或空白来消除歧义。</target>
        </trans-unit>
        <trans-unit id="cd33ddce78ff1c7340f83b621a3b3b7072ee0d07" translate="yes" xml:space="preserve">
          <source>You need to apply the patches in</source>
          <target state="translated">你需要以</target>
        </trans-unit>
        <trans-unit id="1e3349f1cb25ac13b86ae16e145a0b5decd29f3c" translate="yes" xml:space="preserve">
          <source>You need to correct all the entries which look like file paths (they currently start with &lt;code&gt;f:/&lt;/code&gt;).</source>
          <target state="translated">您需要更正所有看起来像文件路径的条目（它们当前以 &lt;code&gt;f:/&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="ac623d9d2638d8e7b4db69f0dfe7d1ff10e6b5e8" translate="yes" xml:space="preserve">
          <source>You need to create a local file or directory handle or a local function.</source>
          <target state="translated">你需要创建一个本地文件或目录句柄或一个本地函数。</target>
        </trans-unit>
        <trans-unit id="f1f5eb114f0c20a6807ea82566cc5f87d3a50a5b" translate="yes" xml:space="preserve">
          <source>You need to fetch the latest perl source (including developers releases). With some probability it is located in</source>
          <target state="translated">你需要获取最新的perl源代码(包括开发者发布的版本)。它很有可能位于</target>
        </trans-unit>
        <trans-unit id="965f03aeeab996c747b3c012ec9e65e74625b61a" translate="yes" xml:space="preserve">
          <source>You need to give a global variable a temporary value, especially $_.</source>
          <target state="translated">你需要给全局变量一个临时值,尤其是$_。</target>
        </trans-unit>
        <trans-unit id="4566431899ec1f0737bac24e93a9db0aa49d528e" translate="yes" xml:space="preserve">
          <source>You need to have the latest &lt;b&gt;ixemul&lt;/b&gt; (Unix emulation for Amiga) from Aminet.</source>
          <target state="translated">您需要具有&lt;b&gt;Aminet&lt;/b&gt;的最新&lt;b&gt;ixemul&lt;/b&gt;（Amiga的Unix仿真）。</target>
        </trans-unit>
        <trans-unit id="a7ac6e008f84ae7c7059b678b8182fe611763a32" translate="yes" xml:space="preserve">
          <source>You need to have the latest EMX development environment, the full GNU tool suite (gawk renamed to awk, and GNU</source>
          <target state="translated">你需要有最新的EMX开发环境,完整的GNU工具套件(gawk改名为awk,以及GNU</target>
        </trans-unit>
        <trans-unit id="f0226c50fdff6c76ac2211b429b8387e73ade57a" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; , &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; .</source>
          <target state="translated">如果要将 &lt;code&gt;-Merge&lt;/code&gt; 选项与 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ， &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 和 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 结合使用，则需要zlib 1.2.1或更高版本。</target>
        </trans-unit>
        <trans-unit id="873959dbb9bde44be24f12aa34b3eef434338c60" translate="yes" xml:space="preserve">
          <source>You need to have zlib 1.2.1 or better if you want to use the &lt;code&gt;-Merge&lt;/code&gt; option with &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; and &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe783f272c0192721f39d883cea6a7e6d87c384" translate="yes" xml:space="preserve">
          <source>You need to indent a strictly positive number of spaces, not 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d2bb828dde58ca4350b2c6d38a82848f926212" translate="yes" xml:space="preserve">
          <source>You need to make sure your script is executable, is accessible by the user CGI is running the script under (which is probably not the user account you tested it under), does not rely on any environment variables (like PATH) from the user it isn't running under, and isn't in a location where the CGI server can't find it, basically, more or less. Please see the following for more information:</source>
          <target state="translated">你需要确保你的脚本是可执行的,是CGI运行脚本的用户可以访问的(这可能不是你测试的用户账户),不依赖任何环境变量(比如PATH),不在CGI服务器找不到的位置,基本上,或多或少。详情请看下面的内容。</target>
        </trans-unit>
        <trans-unit id="5378dd6faea905708bfdb72023c895700d44361d" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dffbeaeb79cbefc3a6182c3945facf9e0c58d9" translate="yes" xml:space="preserve">
          <source>You need to pass references to these objects. See &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for this particular question, and &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for information on references.</source>
          <target state="translated">您需要将引用传递给这些对象。有关特定问题，请参见&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub中的按引用传递；有关参考的信息，&lt;/a&gt;请参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3725b76142cf0ba93578fc0f4b37b143a50c105" translate="yes" xml:space="preserve">
          <source>You need to perform the same general operations on related types of data, but with slight variations depending on the specific type of data the operations are applied to.</source>
          <target state="translated">你需要对相关类型的数据进行相同的一般操作,但根据操作所应用的具体数据类型,略有变化。</target>
        </trans-unit>
        <trans-unit id="97ad81b34d40212b78af8fc083ac0854544a24a5" translate="yes" xml:space="preserve">
          <source>You need to quote &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="520b001573d6d14aabe35562ee4099fd076b8bd4" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs and also to add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca7b2277d21c0c8eb2a5172b673ea24b48da4eb" translate="yes" xml:space="preserve">
          <source>You need to use &lt;code&gt;sv_magicext&lt;/code&gt; to add magic to SvREADONLY SVs and also to add more than one instance of the same 'how'.</source>
          <target state="translated">您需要使用 &lt;code&gt;sv_magicext&lt;/code&gt; 将魔术添加到SvREADONLY SV中，并且还需要添加多个相同的&amp;ldquo; how&amp;rdquo;实例。</target>
        </trans-unit>
        <trans-unit id="87282945868227dd2bfe22d624f87b781030217d" translate="yes" xml:space="preserve">
          <source>You never know what tools you call from within your own tool will need a context. Obtaining the context early ensures that nested tools can find the context you want them to find.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3262ccbefb20acd592d55306e17827a38c688" translate="yes" xml:space="preserve">
          <source>You now have better understanding of what a source filter is, and you might even have a possible use for them. If you feel like playing with source filters but need a bit of inspiration, here are some extra features you could add to the Debug filter.</source>
          <target state="translated">你现在对源码过滤器有了更好的理解,你甚至可能对它们有了可能的用途。如果你觉得想玩源码过滤器,但需要一点灵感,这里有一些你可以添加到Debug过滤器的额外功能。</target>
        </trans-unit>
        <trans-unit id="73cbac231eb90b456375cc000b5becdd4bf8f684" translate="yes" xml:space="preserve">
          <source>You probably cannot fix the thing that runs perl, but you can change how perl outputs its warnings by defining a custom warning and die functions.</source>
          <target state="translated">你可能无法修复运行perl的东西,但是你可以通过定义一个自定义的警告和死机函数来改变perl输出警告的方式。</target>
        </trans-unit>
        <trans-unit id="c7c0603ac9ce1e85817396d548da858cc92fd4cc" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; is often implemented using &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c42726aad22724c022f0c559e39f4d6e8477c11a" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能无法将 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫混合使用，因为 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 通常是使用 &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实现的。</target>
        </trans-unit>
        <trans-unit id="15661abf22e3cef9f933847127ca80cfb4161e88" translate="yes" xml:space="preserve">
          <source>You probably cannot mix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; is often implemented using &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能无法将 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 呼叫混合使用，因为 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 通常是使用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 实现的。</target>
        </trans-unit>
        <trans-unit id="c6ea02ffa42491538c740d65bba124e60d5ff937" translate="yes" xml:space="preserve">
          <source>You probably expect this code to print the equivalent of</source>
          <target state="translated">你可能希望这段代码能打印出相当于以下的代码</target>
        </trans-unit>
        <trans-unit id="d62ac8cab5911278724664b4481b34fb6ef41dfa" translate="yes" xml:space="preserve">
          <source>You probably meant to use &lt;code&gt;$]&lt;/code&gt; instead. &lt;code&gt;$[&lt;/code&gt; is the base for indexing arrays. &lt;code&gt;$]&lt;/code&gt; is the Perl version number in decimal.</source>
          <target state="translated">您可能打算使用 &lt;code&gt;$]&lt;/code&gt; 来代替。 &lt;code&gt;$[&lt;/code&gt; 是索引数组的基础。 &lt;code&gt;$]&lt;/code&gt; 是十进制的Perl版本号。</target>
        </trans-unit>
        <trans-unit id="fd777891ad8556771da5ce520e6dfb0017006c11" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="translated">您可能不应该永远依赖 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; 。在这方面，并非所有的pod转换器都表现良好，也许编译器会变得更挑剔。</target>
        </trans-unit>
        <trans-unit id="fdea4fb0b549076471da0ef11cc5591c5ad20b5e" translate="yes" xml:space="preserve">
          <source>You probably shouldn't rely upon the &lt;code&gt;warn()&lt;/code&gt; being podded out forever. Not all pod translators are well-behaved in this regard, and perhaps the compiler will become pickier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e43d034a25f1af2139047ca7966917ab4cd1dd" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt; , &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; , &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; .</source>
          <target state="translated">您可能要使用各种包装器之一，例如 &lt;code&gt;SvSetSV&lt;/code&gt; ， &lt;code&gt;SvSetSV_nosteal&lt;/code&gt; ， &lt;code&gt;SvSetMagicSV&lt;/code&gt; 和 &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26d6df5a722c4587c10d1e33caf64417a111e3b7" translate="yes" xml:space="preserve">
          <source>You probably want to use one of the assortment of wrappers, such as &lt;code&gt;SvSetSV&lt;/code&gt;, &lt;code&gt;SvSetSV_nosteal&lt;/code&gt;, &lt;code&gt;SvSetMagicSV&lt;/code&gt; and &lt;code&gt;SvSetMagicSV_nosteal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ef8cdce7f3fb77e02bca3307aceacf65c4aa9" translate="yes" xml:space="preserve">
          <source>You probably wrote something like this:</source>
          <target state="translated">你可能写了这样的东西。</target>
        </trans-unit>
        <trans-unit id="39ad4b4dd2e75230f3579c0483b312257f0274c5" translate="yes" xml:space="preserve">
          <source>You really need GNU make to compile this. GNU make ships by default with QNX 4.23, but you can get it from quics for earlier versions.</source>
          <target state="translated">您确实需要使用 GNU make 来编译。QNX 4.23 中默认有 GNU make,但您可以从 quics 中获取早期版本。</target>
        </trans-unit>
        <trans-unit id="f29c66ebc5c2830e25ec34ca0ddd3f809b29ffce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; instead, because &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91eff73482d2359765ffe5506e4ead5d70a7574" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">您可能真的想使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ，因为大多数人都不认为 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo; local&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsub中通过my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab88c992626b72f6894fc343016d386fe947c5ce" translate="yes" xml:space="preserve">
          <source>You really probably want to be using &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; instead, because &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; isn't what most people think of as &quot;local&quot;. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">您可能真的想使用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ，因为大多数人都不认为 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是&amp;ldquo; local&amp;rdquo;。有关详细信息，请参见&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsub中通过my（）的私有变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d15f62d6aa63d728245cd3284fc083f9f68cff93" translate="yes" xml:space="preserve">
          <source>You see, if you call pstruct by its other incybernation, c2ph, you have a code generator that translates C code into perl code! Well, structure and union declarations at least, but that's quite a bit.</source>
          <target state="translated">你看,如果你用它的另一个incybernation,c2ph来调用pstruct,你就有了一个代码生成器,它可以把C代码翻译成perl代码!至少,结构化和联合声明,但也有不少。好吧,至少是结构和联合声明,但那是相当多的。</target>
        </trans-unit>
        <trans-unit id="e40f965e1563da6a69b2b3cefacc4ba6dd9ef204" translate="yes" xml:space="preserve">
          <source>You should &lt;code&gt;use Test2::IPC;&lt;/code&gt; as early as possible in your test file. If you import this module after API initialization it will attempt to retrofit IPC onto the existing hubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95f74aa64cd2ea580871d2847f70b2776302bedc" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt; , Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt; , and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt; . A trivial example might look like:</source>
          <target state="translated">您还应该在Perl解释器中&amp;ldquo;注册&amp;rdquo;您的操作，以便它可以产生明智的错误和警告消息。由于在一个&amp;ldquo;逻辑&amp;rdquo;操作类型 &lt;code&gt;OP_CUSTOM&lt;/code&gt; 中可能有多个自定义操作，因此Perl使用 &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; 的值来确定它正在处理哪个自定义操作。您应该创建一个 &lt;code&gt;XOP&lt;/code&gt; 为每个使用ppaddr结构，设置与自定义运算的性能 &lt;code&gt;XopENTRY_set&lt;/code&gt; ，并注册反对使用ppaddr结构 &lt;code&gt;Perl_custom_op_register&lt;/code&gt; 。一个简单的示例可能看起来像：</target>
        </trans-unit>
        <trans-unit id="a859b2e7cc53302cdc693e11c15d6ffe18891b34" translate="yes" xml:space="preserve">
          <source>You should also &quot;register&quot; your op with the Perl interpreter so that it can produce sensible error and warning messages. Since it is possible to have multiple custom ops within the one &quot;logical&quot; op type &lt;code&gt;OP_CUSTOM&lt;/code&gt;, Perl uses the value of &lt;code&gt;o-&amp;gt;op_ppaddr&lt;/code&gt; to determine which custom op it is dealing with. You should create an &lt;code&gt;XOP&lt;/code&gt; structure for each ppaddr you use, set the properties of the custom op with &lt;code&gt;XopENTRY_set&lt;/code&gt;, and register the structure against the ppaddr using &lt;code&gt;Perl_custom_op_register&lt;/code&gt;. A trivial example might look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd501f21ed6c5e9d05fc6e18329636984dc10c8" translate="yes" xml:space="preserve">
          <source>You should also check out the Frequently Asked Questions list in comp.unix.* for things like this: the answer is essentially the same. It's very system-dependent. Here's one solution that works on BSD systems:</source>
          <target state="translated">你还应该查看comp.unix.*中的常见问题列表,了解类似这样的事情:答案基本上是一样的。这是非常依赖于系统的。这里有一个适用于BSD系统的解决方案。</target>
        </trans-unit>
        <trans-unit id="f04dff0eea092cd0ec8988c859db7bf95d5caa53" translate="yes" xml:space="preserve">
          <source>You should also check your modules, and upgrade them if necessary. For example, HTML::Entities requires version &amp;gt;= 1.32 to function correctly, even though the changelog is silent about this.</source>
          <target state="translated">您还应该检查模块，并在必要时进行升级。例如，HTML :: Entities要求版本&amp;gt; = 1.32才能正常运行，即使更改日​​志对此未作任何说明。</target>
        </trans-unit>
        <trans-unit id="216e237825c211374fe3090940c41c56504f6ae4" translate="yes" xml:space="preserve">
          <source>You should also have received a copy of the GNU General Public License along with this program in the file named &quot;Copying&quot;. If not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA or visit their web page on the internet at &lt;a href=&quot;http://www.gnu.org/copyleft/gpl.html&quot;&gt;http://www.gnu.org/copyleft/gpl.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf271b2d5721f863cabe314c6f3ea53dab9ccef" translate="yes" xml:space="preserve">
          <source>You should also look at &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;.</source>
          <target state="translated">您还应该查看&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2a8e7bc27f2427aec43e373a1d93fb28c7dab24" translate="yes" xml:space="preserve">
          <source>You should also take a look at &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt; for best practices in making a module.</source>
          <target state="translated">您还应该查看&lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt;以获取制作模块的最佳实践。</target>
        </trans-unit>
        <trans-unit id="50caca8ed03bfd57a516ccc3b6dfa215ef520713" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="translated">您还应该尝试从已经熟悉该模块的应用程序域和CPAN命名系统的人员那里获得反馈。类似模块或具有相似名称的模块的作者可能是一个不错的起点，就像&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;这样的社区网站一样。</target>
        </trans-unit>
        <trans-unit id="95145fec9529b3152d5a5f6f32c276f625174f2b" translate="yes" xml:space="preserve">
          <source>You should also try to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like &lt;a href=&quot;https://www.perlmonks.org&quot;&gt;Perl Monks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6748d5917300372787fdc7a9ff0a6b3a57b1d0d9" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt; .</source>
          <target state="translated">您应该始终支持 &lt;code&gt;TIEHASH&lt;/code&gt; 的 &lt;code&gt;HASH&lt;/code&gt; 参数，该参数绑定了基础缓存，以便用户可以指定缓存也是持久性的或具有其他有趣的语义。上面的示例演示了如何执行此操作， &lt;code&gt;Memoize::Expire&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1e2e0b2bc7e86a2fa76d37f5310a663f4f81bdc" translate="yes" xml:space="preserve">
          <source>You should always support a &lt;code&gt;HASH&lt;/code&gt; argument to &lt;code&gt;TIEHASH&lt;/code&gt; that ties the underlying cache so that the user can specify that the cache is also persistent or that it has some other interesting semantics. The example above demonstrates how to do this, as does &lt;code&gt;Memoize::Expire&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be69763ec9a168e71d6a325f5feb839520bece8" translate="yes" xml:space="preserve">
          <source>You should attempt older code to fully use</source>
          <target state="translated">你应该尝试用旧的代码来完全使用</target>
        </trans-unit>
        <trans-unit id="035ccc9a9d5711f4af1f69c6423f5fd457c6beb5" translate="yes" xml:space="preserve">
          <source>You should attempt to get older code to fully use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa5702baea4b6cbbf8baf7ed5e04e20725d5137" translate="yes" xml:space="preserve">
          <source>You should be aware that it is unsupported, and is not claimed to be fit for any purpose. If your system allows installation of arbitrary locales, you may find the definitions useful as they are, or as a basis for the development of your own locales.</source>
          <target state="translated">你应该意识到,它是不被支持的,也没有声称适合任何目的。如果你的系统允许安装任意的locales,你可能会发现这些定义是有用的,或者作为开发你自己的locales的基础。</target>
        </trans-unit>
        <trans-unit id="e3162405a76386caaa175c4a5b3c2a85402c9c86" translate="yes" xml:space="preserve">
          <source>You should be careful about creating mortal variables. Strange things can happen if you make the same value mortal within multiple contexts, or if you make a variable mortal multiple times. Thinking of &quot;Mortalization&quot; as deferred &lt;code&gt;SvREFCNT_dec&lt;/code&gt; should help to minimize such problems. For example if you are passing an SV which you</source>
          <target state="translated">您应谨慎创建致命变量。如果您在多个上下文中使同一个值成为凡人，或者多次使一个变量凡人，则可能会发生奇怪的事情。将&amp;ldquo;道德化&amp;rdquo;视为延迟 &lt;code&gt;SvREFCNT_dec&lt;/code&gt; 应该有助于最大程度地减少此类问题。例如，如果您传递的是SV</target>
        </trans-unit>
        <trans-unit id="9ad5df3f66f5b17aedb15ffe31f22d342f4b8c8e" translate="yes" xml:space="preserve">
          <source>You should be especially careful to remember what's being looked at when:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2612532f10e360a543e4698a0462860c195cea00" translate="yes" xml:space="preserve">
          <source>You should be using two different symbols instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75000df91bba9bce6bbc0dce623bb898fe50b2f" translate="yes" xml:space="preserve">
          <source>You should be very careful when modifying the default values of most special variables described in this document. In most cases you want to localize these variables before changing them, since if you don't, the change may affect other modules which rely on the default values of the special variables that you have changed. This is one of the correct ways to read the whole file at once:</source>
          <target state="translated">在修改本文档中描述的大多数特殊变量的默认值时,您应该非常小心。在大多数情况下,您希望在修改这些变量之前先将它们本地化,因为如果您不这样做,您的修改可能会影响到其他依赖您所修改的特殊变量的默认值的模块。这是一次读取整个文件的正确方法之一。</target>
        </trans-unit>
        <trans-unit id="949c1f70059f0d92507bf8500b354d7dab533cd7" translate="yes" xml:space="preserve">
          <source>You should by now have had a look at &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, which tells you about Perl's internal variable types: SVs, HVs, AVs and the rest. If not, do that now.</source>
          <target state="translated">现在，您应该已经了解了&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;，它向您介绍了Perl的内部变量类型：SV，HV，AV和其他变量。如果没有，请立即执行。</target>
        </trans-unit>
        <trans-unit id="8dc43c8dd65f9ea8dbe3744e02b3f2e2bf6fd033" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the Artistic License with this Kit, in the file named &quot;Artistic&quot;. If not, I'll be glad to provide one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de8c82aa4b462c346cc4f7308a916f25f4fef57" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt; . If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="translated">您应该已经与该库程序一起收到了GNU通用公共许可证的副本；它应该在 &lt;code&gt;COPYING&lt;/code&gt; 文件中。如果没有，请写信给美国自由软件基金会有限公司（Free Software Foundation，Inc.），美国马萨诸塞州波士顿市5楼富兰克林街02110-1301</target>
        </trans-unit>
        <trans-unit id="89d4940a32ed3ab90e1b7165c58f90ef387f0c29" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the GNU General Public License along with this library program; it should be in the file &lt;code&gt;COPYING&lt;/code&gt;. If not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e47e81623eb986394886e54e85f1183c3a98df4e" translate="yes" xml:space="preserve">
          <source>You should in general be leery of using functions that could potentially return lists in scalar context without explicitly stating such. This would be clearer to the casual reader:</source>
          <target state="translated">一般来说,你应该谨慎使用可能在标量上下文中返回列表的函数,而不明确说明。这对普通读者来说会更清楚。</target>
        </trans-unit>
        <trans-unit id="f07911b4c8d126039388d13cb35130da1027b105" translate="yes" xml:space="preserve">
          <source>You should make a module out of any code that you think is going to be useful to others. Anything that's likely to fill a hole in the communal library and which someone else can slot directly into their program. Any part of your code which you can isolate and extract and plug into something else is a likely candidate.</source>
          <target state="translated">你应该把任何你认为对别人有用的代码做成一个模块。任何可能填补公共库中的漏洞,并且别人可以直接插入他们的程序中的代码。你的代码的任何部分,只要你能分离、提取并插入到其他程序中,都是一个可能的候选。</target>
        </trans-unit>
        <trans-unit id="040633d0da585780031086722446751b04946152" translate="yes" xml:space="preserve">
          <source>You should neither care about nor depend on the internal representation; it might change without notice. Use &lt;b&gt;ONLY&lt;/b&gt; method calls like &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; instead relying on the internal representation.</source>
          <target state="translated">您既不应该在乎也不依赖于内部代表；它可能会更改，恕不另行通知。&lt;b&gt;仅&lt;/b&gt;使用方法调用，例如 &lt;code&gt;$x-&amp;gt;sign();&lt;/code&gt; 而是依靠内部表示。</target>
        </trans-unit>
        <trans-unit id="8e48507edb3519e34f20c7e3d955b48a4ed82ad2" translate="yes" xml:space="preserve">
          <source>You should normally only add directories to @INC. If you need to delete directories from @INC take care to only delete those which you added yourself or which you are certain are not needed by other modules in your script. Other modules may have added directories which they need for correct operation.</source>
          <target state="translated">通常情况下,您应该只向 @INC 中添加目录,如果您需要从 @INC 中删除目录,请注意只删除那些您自己添加的或您确定不需要的模块。如果您需要从@INC中删除目录,请注意只删除那些您自己添加的或者您确定脚本中其他模块不需要的目录。其他模块可能已经添加了它们需要的目录,以保证正确的操作。</target>
        </trans-unit>
        <trans-unit id="693cc772a08fe2cee68cbfc24c2a6625d73c01c6" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a bright idea since there is no guaranty that the object in question has such a hashkey, nor is a hash underneath at all.</source>
          <target state="translated">您不应该依赖内部格式，所有访问都必须通过访问器方法进行。例如，查看$ x-&amp;gt; {sign}并不是一个好主意，因为没有保证所讨论的对象具有这样的哈希键，也根本没有下面的哈希。</target>
        </trans-unit>
        <trans-unit id="d13d5397797f2275509831750bfac02171b7d4f3" translate="yes" xml:space="preserve">
          <source>You should not depend on the internal format, all accesses must go through accessor methods. E.g. looking at $x-&amp;gt;{sign} is not a good idea since there is no guaranty that the object in question has such a hash key, nor is a hash underneath at all.</source>
          <target state="translated">您不应该依赖内部格式，所有访问都必须通过访问器方法进行。例如，查看$ x-&amp;gt; {sign}并不是一个好主意，因为没有保证所讨论的对象具有这样的哈希键，也根本没有哈希。</target>
        </trans-unit>
        <trans-unit id="6e8d21cc64f2bc1e9d1ef661a62db1a121e53da8" translate="yes" xml:space="preserve">
          <source>You should not even &lt;b&gt;want&lt;/b&gt; to use</source>
          <target state="translated">你甚至都不&lt;b&gt;想要&lt;/b&gt;使用</target>
        </trans-unit>
        <trans-unit id="675338533405ed3338eef5ef4ee169f82f2ec7e6" translate="yes" xml:space="preserve">
          <source>You should not use perl's malloc if you are building with gcc. There are reports of core dumps, especially in the PDL module. The problem appears to go away under -DDEBUGGING, so it has been difficult to track down. Sun's compiler appears to be okay with or without perl's malloc. [XXX further investigation is needed here.]</source>
          <target state="translated">如果你是用gcc构建的话,你不应该使用perl的malloc。有关于核心转储的报告,特别是在PDL模块中。这个问题似乎在-DDEBUGGING下消失了,所以很难追查。Sun的编译器似乎不管有没有perl的malloc都没问题。[这里需要XXX进一步调查。]</target>
        </trans-unit>
        <trans-unit id="13af3135f590e4077444d490629ef8daddd658bc" translate="yes" xml:space="preserve">
          <source>You should note that, if it is necessary to store the SV (&lt;code&gt;name&lt;/code&gt; in the example above) which corresponds to the Perl subroutine so that it can be used later in the program, it not enough just to store a copy of the pointer to the SV. Say the code above had been like this:</source>
          <target state="translated">您应注意，如果有必要存储与Perl子例程相对应的SV（上例中的 &lt;code&gt;name&lt;/code&gt; ），以便以后在程序中使用它，仅存储指向该指针的指针的副本是不够的。 SV。说上面的代码是这样的：</target>
        </trans-unit>
        <trans-unit id="be707fb5b1867bc329a5a5a540fc202148f2df94" translate="yes" xml:space="preserve">
          <source>You should now build perl and test your (merged) changes one last time (ideally run the whole test suite, but failing that at least run the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b47aa7e3c4b13e3ddb21243f2aa9c3c7a0d993" translate="yes" xml:space="preserve">
          <source>You should now submit a Pull Request (PR) on GitHub from the new branch to blead. For more information, see the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&quot;&gt;https://help.github.com/en/articles/creating-a-pull-request-from-a-fork&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d554ccba9c0cacff167113e9e842dbb2b577730c" translate="yes" xml:space="preserve">
          <source>You should only need to use this option if you want the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d7be701b66af4a13ce23ca4f4637ef46685c93" translate="yes" xml:space="preserve">
          <source>You should probably be using lexical variables anyway, although the issue is the same here:</source>
          <target state="translated">你可能无论如何都应该使用词法变量,尽管这里的问题是一样的。</target>
        </trans-unit>
        <trans-unit id="8df19768141a29740332079971ccdd9d5ccbe578" translate="yes" xml:space="preserve">
          <source>You should really look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. This package is some very basic essential tools implemented using &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. This exists only so that &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; and other tools required by &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; can be tested. This is the package &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt; uses to test itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54112594f7721aec0b526a825c8c553a794597d2" translate="yes" xml:space="preserve">
          <source>You should say</source>
          <target state="translated">你应该说</target>
        </trans-unit>
        <trans-unit id="669aa98258ce9656dc2f7e8465e9a97f44e937fd" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; for more on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae04df28b1ca8233ad4f14017b75003d4a4c0fc" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">如果曾经使用 &lt;code&gt;0644&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的参数，则几乎不应该使用它，因为这样可以避免用户选择具有更大许可的umask。最好省略它。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目。</target>
        </trans-unit>
        <trans-unit id="a5da0398cef906098b3aedb900161f9013fc9dbe" translate="yes" xml:space="preserve">
          <source>You should seldom if ever use &lt;code&gt;0644&lt;/code&gt; as argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, because that takes away the user's option to have a more permissive umask. Better to omit it. See the perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; for more on this.</source>
          <target state="translated">如果曾经使用 &lt;code&gt;0644&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 的参数，则几乎不应该使用它，因为这样可以避免用户选择具有更大许可的umask。最好省略它。有关更多信息，请参见 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 上的perlfunc（1）条目。</target>
        </trans-unit>
        <trans-unit id="93291955e6753d9b28d9290f1f843ab314e860d1" translate="yes" xml:space="preserve">
          <source>You should take great pains to try to pass the function the type of variable it wants, when possible. It will save you a lot of trouble in the long run.</source>
          <target state="translated">在可能的情况下,你应该不厌其烦地尽量给函数传递它想要的变量类型。从长远来看,这将为你省去很多麻烦。</target>
        </trans-unit>
        <trans-unit id="12e9cbf7ef859529e7aa6ad559377e6f6b1073a2" translate="yes" xml:space="preserve">
          <source>You should think long and hard about why you need everything loaded at once. It's just not a scalable solution.</source>
          <target state="translated">你应该好好想想为什么要一次装完所有的东西。这不是一个可扩展的解决方案。</target>
        </trans-unit>
        <trans-unit id="60692fdbea6181558282af5a09ad1a91226b0568" translate="yes" xml:space="preserve">
          <source>You should use</source>
          <target state="translated">你应该使用</target>
        </trans-unit>
        <trans-unit id="6151ee9c13ae718ea297cb2924721c23869b50eb" translate="yes" xml:space="preserve">
          <source>You should use the &lt;b&gt;-T&lt;/b&gt; flag to enable taint checking (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) even if we aren't running setuid or setgid. This is always a good idea for servers or any program run on behalf of someone else (like CGI scripts), because it lessens the chances that people from the outside will be able to compromise your system.</source>
          <target state="translated">即使我们没有运行setuid或setgid，也应使用&lt;b&gt;-T&lt;/b&gt;标志启用污点检查（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。对于服务器或代表其他人运行的任何程序（例如CGI脚本）来说，这始终是一个好主意，因为它减少了外部人员入侵您系统的机会。</target>
        </trans-unit>
        <trans-unit id="c6b52a2caf001c41f2fbe0900c81a2862fac3a04" translate="yes" xml:space="preserve">
          <source>You should use this</source>
          <target state="translated">你应该用这个</target>
        </trans-unit>
        <trans-unit id="f980030e1ddd6415377ab007be132a7835310a08" translate="yes" xml:space="preserve">
          <source>You should use this option if you are using UTF-16 and others which linefeed is not $/.</source>
          <target state="translated">如果你使用UTF-16和其他非$/的行进,你应该使用这个选项。</target>
        </trans-unit>
        <trans-unit id="db384f65b44d08a41642068cf25462a07360e950" translate="yes" xml:space="preserve">
          <source>You should usually be able to ignore this and just use the module without thinking about deferring. However, special applications may require fine control over which writes are deferred, or may require that all writes be immediate. To disable the autodeferment feature, use</source>
          <target state="translated">通常您应该可以忽略这一点,只需使用该模块,而无需考虑推迟。然而,特殊的应用程序可能需要精细地控制哪些写入是延迟的,或者可能要求所有的写入都是立即的。要禁用自动延迟功能,请使用</target>
        </trans-unit>
        <trans-unit id="962a252e8053766a043aa7e45b2c62a450a0683c" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen in perlunicode&lt;/a&gt;.)</source>
          <target state="translated">您不必关心。但是，如果您的Perl在5.14.0之前，或者您未指定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; （或更高版本），则可能会出现这种情况，因为否则，代码点在128到255之间的规则会有所不同，具体取决于字符串是否它们是否包含在Unicode中。（请参阅&lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;何时在perlunicode中不发生Unicode&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9aa9430e0cc51b74e3ef5d34b9f38ebd3c03a610" translate="yes" xml:space="preserve">
          <source>You shouldn't have to care. But you may if your Perl is before 5.14.0 or you haven't specified &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; or &lt;code&gt;use 5.012&lt;/code&gt; (or higher) because otherwise the rules for the code points in the range 128 to 255 are different depending on whether the string they are contained within is in Unicode or not. (See &lt;a href=&quot;perlunicode#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot; in perlunicode&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8856a657ecb3d97a5c46abba56a556f46cc66ed" translate="yes" xml:space="preserve">
          <source>You shouldn't need to set this variable, since File::Find should now detect such file systems on-the-fly and switch itself to using stat. This works even for parts of your file system, like a mounted CD-ROM.</source>
          <target state="translated">你不需要设置这个变量,因为 File::Find 现在应该可以即时检测到这样的文件系统,并将自己切换到使用 stat。这甚至适用于文件系统的一部分,比如挂载的 CD-ROM。</target>
        </trans-unit>
        <trans-unit id="07632dfd399f0ee08d2dcc1bc356caea0fb1fc3a" translate="yes" xml:space="preserve">
          <source>You shouldn't worry about what this format is, because conversion is automatically done when you decode or encode.</source>
          <target state="translated">你不应该担心这个格式是什么,因为在你解码或编码的时候会自动进行转换。</target>
        </trans-unit>
        <trans-unit id="1bf2aae490ef3108185dddeac7ace7d36d9b8359" translate="yes" xml:space="preserve">
          <source>You specified a character that has the given plainer way of writing it, and which is also portable to platforms running with different character sets.</source>
          <target state="translated">你指定的字符具有给定的更简单的书写方式,而且还可以移植到运行不同字符集的平台上。</target>
        </trans-unit>
        <trans-unit id="ba1446898cf703a433f10e50053c48b7c4bd65ea" translate="yes" xml:space="preserve">
          <source>You specify the parameters that will be passed into the XSUB on the line(s) after you declare the function's return value and name. Each input parameter line starts with optional whitespace, and may have an optional terminating semicolon.</source>
          <target state="translated">你可以在声明函数的返回值和名称之后的行中指定传入XSUB的参数。每个输入参数行以可选的空格开始,并且可以有一个可选的分号结束。</target>
        </trans-unit>
        <trans-unit id="5e23d741eb164f1a1d95de07ecc25c6899dd796b" translate="yes" xml:space="preserve">
          <source>You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.</source>
          <target state="translated">你在专用硬件上花了很多很多钱,但这必然会让你被人议论。</target>
        </trans-unit>
        <trans-unit id="e47578a3d656799aa6fd209dfd66ed644e50edb2" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="translated">然后，您可以从测试套件中运行调用&lt;a href=&quot;../builder&quot;&gt;Test :: Builder的测试&lt;/a&gt;。此时，&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;的输出将由&lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt;安全地捕获，而不是被解释为真实的测试输出。</target>
        </trans-unit>
        <trans-unit id="27cca9133f1312a001d7fe1a85c24e4f576073c8" translate="yes" xml:space="preserve">
          <source>You then can run the test(s) from your test suite that call &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;. At this point the output of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; is safely captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; rather than being interpreted as real test output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677380f0fc96290216b3b386e909881a38477756" translate="yes" xml:space="preserve">
          <source>You think about that, and realize that it doesn't even work right for English, as it can produce this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f392c3f60b78b930a2c99b682f5745b402f97b" translate="yes" xml:space="preserve">
          <source>You tried to use a negative time argument.</source>
          <target state="translated">你想用否定时间的说法。</target>
        </trans-unit>
        <trans-unit id="d0e63499831fb2a66fb9056cf426d7e6b0b72f22" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;&quot;Prerequisites&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="215da501a4d763185822fdec5710086fea4dd9c5" translate="yes" xml:space="preserve">
          <source>You use an old version of GNU make. See &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">您使用的是旧版本的GNU make。请参阅&lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="220275358a49875c3abbea24e2340553d9cb4444" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; flag. It uses the value of &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">您可以使用 &lt;code&gt;\G&lt;/code&gt; 锚点在同一字符串上开始下一个匹配，而最后一个匹配将从该字符串开始。正则表达式引擎无法跳过任何字符来查找与此锚点匹配的下一个匹配项，因此 &lt;code&gt;\G&lt;/code&gt; 类似于字符串锚点 &lt;code&gt;^&lt;/code&gt; 的开头。所述 &lt;code&gt;\G&lt;/code&gt; 锚通常用于与 &lt;code&gt;g&lt;/code&gt; 标志。它使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 的值作为开始下一个匹配的位置。当match运算符进行连续的匹配时，它将使用上一个匹配项（或下一个匹配项的第一个字符）之后的下一个字符的位置来更新 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ，具体取决于您的喜好。每个字符串都有其自己的 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="1e5946dcfcf3479db4ae2e5695fe6c76f97743a7" translate="yes" xml:space="preserve">
          <source>You use the &lt;code&gt;\G&lt;/code&gt; anchor to start the next match on the same string where the last match left off. The regular expression engine cannot skip over any characters to find the next match with this anchor, so &lt;code&gt;\G&lt;/code&gt; is similar to the beginning of string anchor, &lt;code&gt;^&lt;/code&gt;. The &lt;code&gt;\G&lt;/code&gt; anchor is typically used with the &lt;code&gt;g&lt;/code&gt; modifier. It uses the value of &lt;code&gt;pos()&lt;/code&gt; as the position to start the next match. As the match operator makes successive matches, it updates &lt;code&gt;pos()&lt;/code&gt; with the position of the next character past the last match (or the first character of the next match, depending on how you like to look at it). Each string has its own &lt;code&gt;pos()&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc28690a1164ffed63384fc9d48573f0201b1c8c" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;functions/utime&quot;&gt;utime&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="translated">您可以使用中记录了UTIME（）函数&lt;a href=&quot;functions/utime&quot;&gt;UTIME&lt;/a&gt;。举例来说，这是一个小程序，它将读写时间从其第一个参数复制到所有其他参数。</target>
        </trans-unit>
        <trans-unit id="9d5d257c0d5834299b68e1d80c48e829b8bcc94a" translate="yes" xml:space="preserve">
          <source>You use the utime() function documented in &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt;. By way of example, here's a little program that copies the read and write times from its first argument to all the rest of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6636b861a3b2aa1c111b3f0b60ae946532727186" translate="yes" xml:space="preserve">
          <source>You usually can use the value of &lt;code&gt;$^X&lt;/code&gt; to re-invoke an independent copy of the same perl that is currently running, e.g.,</source>
          <target state="translated">通常，您可以使用 &lt;code&gt;$^X&lt;/code&gt; 的值重新调用当前正在运行的同一Perl的独立副本，例如，</target>
        </trans-unit>
        <trans-unit id="aa6e6cfea08fbea7a5de694a45b0570deb9eda14" translate="yes" xml:space="preserve">
          <source>You usually can't. Memory allocated to lexicals (i.e. my() variables) cannot be reclaimed or reused even if they go out of scope. It is reserved in case the variables come back into scope. Memory allocated to global variables can be reused (within your program) by using undef() and/or delete().</source>
          <target state="translated">通常不能。分配给词法(即my()变量)的内存即使超出了作用域,也不能被回收或重新使用。它被保留在变量重新进入作用域的情况下。分配给全局变量的内存可以通过使用undef()和/或delete()重新使用(在你的程序中)。</target>
        </trans-unit>
        <trans-unit id="654d5925759821a41f7b319f6f5acce1580b7e6a" translate="yes" xml:space="preserve">
          <source>You want to temporarily change just one element of an array or hash.</source>
          <target state="translated">你想临时改变一个数组或哈希中的一个元素。</target>
        </trans-unit>
        <trans-unit id="d06ad7bf53cef6bd6922e06d9d929dd05f8dbea0" translate="yes" xml:space="preserve">
          <source>You will almost certainly be better off using the &lt;code&gt;PL_FILES&lt;/code&gt; system, instead. See above, or the &lt;a href=&quot;ExtUtils::MakeMaker::FAQ&quot;&gt;ExtUtils::MakeMaker::FAQ&lt;/a&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba6881210a4041e425c0b40054f89e605a3c752" translate="yes" xml:space="preserve">
          <source>You will also need to be able to connect over the Internet to the public key servers, like pgp.mit.edu, and their port 11731 (the HKP protocol).</source>
          <target state="translated">你还需要能够通过互联网连接到公钥服务器,比如pgp.mit.edu,以及他们的11731端口(HKP协议)。</target>
        </trans-unit>
        <trans-unit id="c62030728cb5bac5bc525932491c14ac0a7adf6d" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Platform SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for header files, libraries and rc.exe, and &quot;.NET Framework SDK&quot; for more libraries and nmake.exe. Note that the latter (which also includes the free compiler and linker) requires the &quot;.NET Framework Redistributable&quot; to be installed first. This can be downloaded and installed separately, but is included in the &quot;Visual C++ Toolkit 2003&quot; anyway.</source>
          <target state="translated">你还需要下载 &quot;Platform SDK&quot;(需要 &quot;Core SDK &quot;和 &quot;MDAC SDK &quot;组件)以获取头文件、库和rc.exe,以及&quot;.NET Framework SDK &quot;以获取更多库和nmake.exe。注意,后者(还包括免费的编译器和链接器)需要先安装&quot;.NET Framework Redistributable&quot;。这可以单独下载和安装,但无论如何都包含在 &quot;Visual C++Toolkit 2003 &quot;中。</target>
        </trans-unit>
        <trans-unit id="356f5d0daa70748f28cbf7166d4f341295254619" translate="yes" xml:space="preserve">
          <source>You will also need to download the &quot;Windows SDK&quot; (the &quot;Core SDK&quot; and &quot;MDAC SDK&quot; components are required) for more header files and libraries.</source>
          <target state="translated">您还需要下载 &quot;Windows SDK&quot;(需要 &quot;Core SDK &quot;和 &quot;MDAC SDK &quot;组件)以获得更多的头文件和库。</target>
        </trans-unit>
        <trans-unit id="a1a5cfadaa899360662110efdf3739aae4dbc6c1" translate="yes" xml:space="preserve">
          <source>You will encounter this particular error message when you have the &lt;code&gt;strict 'subs'&lt;/code&gt; pragma (or the full strict pragma) in your script. Consider this script:</source>
          <target state="translated">当脚本中包含 &lt;code&gt;strict 'subs'&lt;/code&gt; 编译指示（或完整的严格编译指示）时，将遇到此特定的错误消息。考虑以下脚本：</target>
        </trans-unit>
        <trans-unit id="23e29e8947be99b87040c3c4a0668f86aaf880a4" translate="yes" xml:space="preserve">
          <source>You will find brief info on &lt;code&gt;EUC-CN&lt;/code&gt;, &lt;code&gt;GBK&lt;/code&gt; and mostly on &lt;code&gt;GB 18030&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d527eca4336857f6af5af5d0a105cad653a71a0" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt;&lt;/a&gt; handlers (which don't suppress the error text, but can instead call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; again to change it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef82421bf1d6104efddfdc8565b14c0ddc86aec" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">您会发现此行为与 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序的行为略有不同（该处理程序不会隐藏错误文本，但可以再次调用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 进行更改）。</target>
        </trans-unit>
        <trans-unit id="7d85e118af6c81732006143a60990cead4fa03d5" translate="yes" xml:space="preserve">
          <source>You will find this behavior is slightly different from that of &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handlers (which don't suppress the error text, but can instead call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; again to change it).</source>
          <target state="translated">您会发现此行为与 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理程序的行为略有不同（该处理程序不会隐藏错误文本，但可以再次调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 进行更改）。</target>
        </trans-unit>
        <trans-unit id="c01bddfdbad27a7674a351ac148e02cb61a266a6" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用中的参数之一错误时，您将收到此错误消息。不幸的是，有很多参数会出错，因此很难弄清楚它是哪一个。</target>
        </trans-unit>
        <trans-unit id="6f39ce5468b191fe767e35548ddecfe66b13656d" translate="yes" xml:space="preserve">
          <source>You will get this error message when one of the parameters in the &lt;code&gt;tie&lt;/code&gt; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b306755ccc7dd24d9d304eb11d95322f9c7d1c36" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler.</source>
          <target state="translated">你必须确保CCTYPE设置正确,并且CCHOME指向你安装编译器的地方。</target>
        </trans-unit>
        <trans-unit id="5a37a6f06ca5d5f038a38f2ddd94e62c35c0fb8e" translate="yes" xml:space="preserve">
          <source>You will have to make sure that CCTYPE is set correctly and that CCHOME points to wherever you installed your compiler. For GCC this should be the directory that contains the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d67b6a7548006b180c9c0aa7f1777391e8e3f6" translate="yes" xml:space="preserve">
          <source>You will need a copy of Git for your computer. You can fetch a copy of the repository using the git protocol:</source>
          <target state="translated">你需要在你的电脑上安装一个Git的副本,你可以使用git协议来获取仓库的副本。你可以使用 git 协议获取仓库的副本。</target>
        </trans-unit>
        <trans-unit id="7a0e1442c7d674a64133a4ac5cbad0b8f84016fe" translate="yes" xml:space="preserve">
          <source>You will need perl version 5.005_03 or newer.</source>
          <target state="translated">你需要perl 5.005_03或更新的版本。</target>
        </trans-unit>
        <trans-unit id="c20642cf215c3811e3976c0a074a0bc8e167607f" translate="yes" xml:space="preserve">
          <source>You will need the packages mentioned in</source>
          <target state="translated">你将需要在</target>
        </trans-unit>
        <trans-unit id="125a7a338622da6411e41d9bf9ce7dc1495ae8ff" translate="yes" xml:space="preserve">
          <source>You will need to have Module::Signature installed, which in turn requires that you have at least one of Crypt::OpenPGP module or the command-line</source>
          <target state="translated">你需要安装Module::Signature,而这又要求你至少有一个Crypt::OpenPGP模块或命令行的</target>
        </trans-unit>
        <trans-unit id="26225667638a5ef1fac02d60146f2f3c0e15d299" translate="yes" xml:space="preserve">
          <source>You will need to open every other filehandle on your own. Although there are many variants, the most common way to call Perl's open() function is with three arguments and one return value:</source>
          <target state="translated">你需要自己打开其他每一个文件柄。虽然有很多变体,但调用Perl的open()函数最常见的方式是使用三个参数和一个返回值。</target>
        </trans-unit>
        <trans-unit id="e7fe6fd13dad565a05157034d79dc2c0ed04e368" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;&quot;Packing and Unpacking C Structures&quot;&lt;/a&gt; for more on that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ced186b3bff5ac2b886750a50b53e155abe57dbc" translate="yes" xml:space="preserve">
          <source>You will probably find these modifiers even more useful if you have to deal with big- or little-endian C structures. Be sure to read &lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;Packing and Unpacking C Structures&lt;/a&gt; for more on that.</source>
          <target state="translated">如果必须处理大尾数的C结构，则这些修饰符可能会更加有用。请务必阅读&lt;a href=&quot;#Packing-and-Unpacking-C-Structures&quot;&gt;打包C结构&lt;/a&gt;的更多信息。</target>
        </trans-unit>
        <trans-unit id="299bf5b3f1c12a5c613500fd1bf200a8e448ae9f" translate="yes" xml:space="preserve">
          <source>You will see a message about errors while extracting</source>
          <target state="translated">在解压时,你会看到一条关于错误的信息。</target>
        </trans-unit>
        <trans-unit id="5094570ece83ba87b116e497a48639d59ad16c42" translate="yes" xml:space="preserve">
          <source>You will see your commits being re-applied, and you will then be able to push safely. More information about rebasing can be found in the documentation for the git-rebase(1) command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ae5109d0174e4b426288bcd1b8e77508718bce" translate="yes" xml:space="preserve">
          <source>You will sometimes see older books or documentation mention &quot;blessing a reference&quot; or describe an object as a &quot;blessed reference&quot;, but this is incorrect. It isn't the reference that is blessed as an object; it's the thing the reference refers to (i.e. the referent).</source>
          <target state="translated">您有时会看到较老的书籍或文档中提到 &quot;祝福一个参照物 &quot;或将一个对象描述为 &quot;祝福参照物&quot;,但这是不正确的。被祝福为对象的不是参考文献,而是参考文献所指的东西(即参照物)。</target>
        </trans-unit>
        <trans-unit id="b76bd931ca4d3ee61d00134eaf02261405743feb" translate="yes" xml:space="preserve">
          <source>You will usually get this message if you are working with UTF-8 data and want to read/write it from/to a Berkeley DB database file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffa4e5392f74c061811f37be769a0d8e66a909" translate="yes" xml:space="preserve">
          <source>You wonder how you'll get gettext to handle this; to accommodate the ways Arabic, Chinese, and Italian deal with numbers in just these few very simple phrases, you need to write code that will ask gettext for different queries depending on whether the numerical values in question are 1, 2, more than 2, or in some cases 0, and you still haven't figured out the problem with the different word order in Chinese.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e797714a16ef1ab3d51adb0398a2351cdb2d4869" translate="yes" xml:space="preserve">
          <source>You would do</source>
          <target state="translated">你会做</target>
        </trans-unit>
        <trans-unit id="6a39b437275322e4ded1326f66b7e094ff120686" translate="yes" xml:space="preserve">
          <source>You would do well to understand that the TIEARRAY and TIEHASH interfaces are mere sugar to invoke some perl method calls while using the uniform hash and array syntax. The use of this sugar imposes some overhead (typically about two to four extra opcodes per FETCH/STORE operation, in addition to the creation of all the mortal variables required to invoke the methods). This overhead will be comparatively small if the TIE methods are themselves substantial, but if they are only a few statements long, the overhead will not be insignificant.</source>
          <target state="translated">你最好明白,TIEARRAY和TIEHASH接口只是一个糖,用来调用一些perl方法,同时使用统一的哈希和数组语法。这种糖的使用会带来一些开销(通常每个FETCH/STORE操作会有两到四个额外的操作码,此外还要创建调用方法所需的所有凡人变量)。如果TIE方法本身就很可观,那么这个开销就会相对较小,但如果这些方法只有几条语句长,那么这个开销就不小了。</target>
        </trans-unit>
        <trans-unit id="d4ff63e38580a86bc4e960e615187745a0cf46e6" translate="yes" xml:space="preserve">
          <source>You would tell &lt;code&gt;Memoize&lt;/code&gt; to use this normalizer this way:</source>
          <target state="translated">您将告诉 &lt;code&gt;Memoize&lt;/code&gt; 以这种方式使用此规范化器：</target>
        </trans-unit>
        <trans-unit id="26052a9c2b555b8c00fe517ca714ea40b56ea28f" translate="yes" xml:space="preserve">
          <source>You would think passing files to an XS is difficult, with all the typeglobs and stuff. Well, it isn't.</source>
          <target state="translated">你会觉得把文件传到XS上很困难,因为有很多打字夹之类的东西。其实不然。</target>
        </trans-unit>
        <trans-unit id="0f48ec8747685a1be6881def5b864ffbb8151d2b" translate="yes" xml:space="preserve">
          <source>You would use the following &lt;code&gt;test&lt;/code&gt; directive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ae49780570ada5605ad7b4d5f17a41e10f03f26" translate="yes" xml:space="preserve">
          <source>You wrote something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97f37569bdb5c4ba52eeb6c3306265613993e5ff" translate="yes" xml:space="preserve">
          <source>You'll also find that &lt;code&gt;foreach&lt;/code&gt; loop used to create a topicalizer and a switch:</source>
          <target state="translated">您还将发现用于创建主题分析器和开关的 &lt;code&gt;foreach&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="5e9bf36ecbd53fc8e26acf6fb90205c1b5356d3c" translate="yes" xml:space="preserve">
          <source>You'll also have to choose the appropriate library directory (</source>
          <target state="translated">你还得选择合适的库目录(</target>
        </trans-unit>
        <trans-unit id="d14f9a4e84e4a65a6fcadc471d3775e2d2026c66" translate="yes" xml:space="preserve">
          <source>You'll also need to add the following code to the top of the .xs file, just after the include of &quot;XSUB.h&quot;:</source>
          <target state="translated">你还需要将以下代码添加到.xs文件的顶部,就在 &quot;XSUB.h &quot;的包含之后。</target>
        </trans-unit>
        <trans-unit id="067d0f39aaa002449de130921826b00edd6e52d4" translate="yes" xml:space="preserve">
          <source>You'll also see code that does this without a temporary variable, as in</source>
          <target state="translated">你也会看到一些代码在没有临时变量的情况下这样做,如</target>
        </trans-unit>
        <trans-unit id="e76c883ffb7e9e13e48b98bafcbb6fa1aa675b80" translate="yes" xml:space="preserve">
          <source>You'll be in trouble. Those should (in 99.8% of the cases) be the simpler and more direct:</source>
          <target state="translated">你会有麻烦的。这些应该(在99.8%的情况下)是比较简单直接的。</target>
        </trans-unit>
        <trans-unit id="f885bd4b3bb53aff3bed3dec0b066248d1576a12" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您必须捕获SIGCHLD信号，并且可能还捕获SIGPIPE。后台进程完成时发送SIGCHLD。当您写入其子进程已关闭的文件句柄时，将发送SIGPIPE（未捕获的SIGPIPE可能导致您的程序无声地死掉）。这不是 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cab58b27e2de2ea6f8506a9492db28f36b0db46" translate="yes" xml:space="preserve">
          <source>You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too. SIGCHLD is sent when the backgrounded process finishes. SIGPIPE is sent when you write to a filehandle whose child process has closed (an untrapped SIGPIPE can cause your program to silently die). This is not an issue with &lt;code&gt;system(&quot;cmd&amp;amp;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c26c7e5ed49de9efc0c0dba307a9def27936a34" translate="yes" xml:space="preserve">
          <source>You'll have to choose the appropriate compiler (</source>
          <target state="translated">你必须选择合适的编译器(</target>
        </trans-unit>
        <trans-unit id="e62d384e427e6ef82a853693fc0380e3a4a6bcdd" translate="yes" xml:space="preserve">
          <source>You'll know your submission has been processed when you receive an email from our ticket tracking system. This email will give you a ticket number. Once your patch has made it to the ticket tracking system, it will also be sent to the perl5-porters@perl.org list.</source>
          <target state="translated">当您收到我们的票务跟踪系统发出的电子邮件时,您就会知道您的提交已被处理。这封邮件会给你一个票号。一旦你的补丁进入票务跟踪系统,它也会被发送到perl5-porters@perl.org 列表。</target>
        </trans-unit>
        <trans-unit id="feea2270863ca6e9573aba26122b77d4eeb6b2e7" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</source>
          <target state="translated">您需要 &lt;code&gt;nmake&lt;/code&gt; 实用程序，该程序可从CPAN上获得，&lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;网址&lt;/a&gt;为http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe或dmake。&lt;a href=&quot;http://search.cpan.org/dist/dmake/&quot;&gt;http://search.cpan.org/dist/dmake/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5c934ac89d7dfe4684c6e54f3c503e7b13b2e6d" translate="yes" xml:space="preserve">
          <source>You'll need the &lt;code&gt;nmake&lt;/code&gt; utility, available at &lt;a href=&quot;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&quot;&gt;http://download.microsoft.com/download/vc15/Patch/1.52/W95/EN-US/nmake15.exe&lt;/a&gt; or dmake, available on CPAN. &lt;a href=&quot;https://metacpan.org/release/dmake&quot;&gt;https://metacpan.org/release/dmake&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98bbda9e4101a6a3cc3bbb0d325b9faa857f4a3" translate="yes" xml:space="preserve">
          <source>You'll want to do that in your Perl source tree so the debugger can read the source code. You should see the copyright message, followed by the prompt.</source>
          <target state="translated">你会想在你的Perl源码树中这样做,这样调试器就可以读取源码。你应该看到版权信息,然后是提示。</target>
        </trans-unit>
        <trans-unit id="43eea0417aae56c41dd79afb85423b61a36ecf9b" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and backticks (``). &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="translated">您混淆了 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 和反引号（``）的用途。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运行命令并返回退出状态信息（作为16位值：低7位是进程退出的信号（如果有），高8位是实际退出值）。反引号（``）运行命令并将其发送给STDOUT的命令返回。</target>
        </trans-unit>
        <trans-unit id="08b0cf3cad789cb4d3af9f9bb75436a6878af698" translate="yes" xml:space="preserve">
          <source>You're confusing the purpose of &lt;code&gt;system()&lt;/code&gt; and backticks (``). &lt;code&gt;system()&lt;/code&gt; runs a command and returns exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if any, and the high 8 bits are the actual exit value). Backticks (``) run a command and return what it sent to STDOUT.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c524955aca90f8362890a62830c6184582bf776" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0067a9abf52f5d5adc52730de693ce9354a17edf" translate="yes" xml:space="preserve">
          <source>You're encouraged to create self-tests for your module to ensure it's working as intended on the myriad platforms Perl supports; if you upload your module to CPAN, a host of testers will build your module and send you the results of the tests. Again, &lt;code&gt;module-starter&lt;/code&gt; and &lt;code&gt;h2xs&lt;/code&gt; provide a test framework which you can extend - you should do something more than just checking your module will compile. &lt;a href=&quot;test/simple&quot;&gt;Test::Simple&lt;/a&gt; and &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; are good places to start when writing a test suite.</source>
          <target state="translated">我们鼓励您为模块创建自检，以确保其在Perl支持的众多平台上按预期工作。如果您将模块上传到CPAN，则大量的测试人员将构建您的模块并向您发送测试结果。再次， &lt;code&gt;module-starter&lt;/code&gt; 和 &lt;code&gt;h2xs&lt;/code&gt; 提供了可以扩展的测试框架-您应该做的不仅仅是检查模块是否可以编译。&lt;a href=&quot;test/simple&quot;&gt;测试：：简单&lt;/a&gt;和&lt;a href=&quot;test/more&quot;&gt;测试：：更多&lt;/a&gt;是编写测试套件时开始的好地方。</target>
        </trans-unit>
        <trans-unit id="1465c23d6a9abbc69d7c02001d0a261855c5206d" translate="yes" xml:space="preserve">
          <source>You're probably trying to convert a string to a number, which Perl only converts as a decimal number. When Perl converts a string to a number, it ignores leading spaces and zeroes, then assumes the rest of the digits are in base 10:</source>
          <target state="translated">你可能是想把一个字符串转换为数字,而 Perl 只把它转换为十进制数。当 Perl 将一个字符串转换为数字时,它会忽略前导空格和零,然后假设其余的数字都是以 10 为基数。</target>
        </trans-unit>
        <trans-unit id="f32dee0623a34d25e555f7bd9fe977163f048dfb" translate="yes" xml:space="preserve">
          <source>You're still out of luck if you need to keep track of decaying protons though.</source>
          <target state="translated">不过如果你需要追踪衰变的质子,你还是很倒霉的。</target>
        </trans-unit>
        <trans-unit id="4522acbd81c14b3349dda685727b4174a91c46c1" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserEndToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13c2c796fe95a445a68ec254f6e70e50cbdb3db7" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserStartToken-&amp;gt;new( &lt;i&gt;tagname&lt;/i&gt;, &lt;i&gt;attrhash&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63fdd43345f7726cfc85c93addac87c77eec8e6e" translate="yes" xml:space="preserve">
          <source>You're unlikely to ever need to construct an object of this class for yourself, but if you want to, call &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</source>
          <target state="translated">您几乎不需要自己构造此类的对象，但是如果愿意，请调用 &lt;code&gt;Pod::Simple::PullParserTextToken-&amp;gt;new( &lt;i&gt;text&lt;/i&gt; )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="244e1e138ccb1ddf345dc218bc4eb88a0d9affd5" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to replace a subroutine, but it's not a Perl built-in, and &lt;code&gt;Fatal&lt;/code&gt; couldn't find it as a regular subroutine. It either doesn't exist or has not yet been defined.</source>
          <target state="translated">您已经要求 &lt;code&gt;Fatal&lt;/code&gt; 替换一个子例程，但是它不是Perl内置的，并且 &lt;code&gt;Fatal&lt;/code&gt; 找不到它作为常规子例程。它不存在或尚未定义。</target>
        </trans-unit>
        <trans-unit id="e40be2d06acbdf1af8b44d624778687fbb9e49ee" translate="yes" xml:space="preserve">
          <source>You've asked &lt;code&gt;Fatal&lt;/code&gt; to try and replace a subroutine which does not exist, or has not yet been defined.</source>
          <target state="translated">您已要求 &lt;code&gt;Fatal&lt;/code&gt; 尝试替换不存在或尚未定义的子例程。</target>
        </trans-unit>
        <trans-unit id="b50e18d238da3dcc7957f257361d12bcaab56e61" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;Fatal&lt;/code&gt; with an argument that doesn't look like a subroutine name, nor a switch that this version of Fatal understands.</source>
          <target state="translated">您用一个看起来不像子例程名称的参数调用了 &lt;code&gt;Fatal&lt;/code&gt; ，也没有使用此版本的Fatal可以理解的开关。</target>
        </trans-unit>
        <trans-unit id="a27632c5e590274b1b4e11ad85f630e87b588ea0" translate="yes" xml:space="preserve">
          <source>You've called &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt; using a subroutine reference, but that reference could not be resolved back to a subroutine name. It may be an anonymous subroutine (which can't be made autodying), or may lack a name for other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf998c7dc1a2b4fcde7c406f8c5df0a1daf51ce" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt; . Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="translated">您已经在 &lt;code&gt;Fatal&lt;/code&gt; 中发现了一个错误。请使用 &lt;code&gt;perlbug&lt;/code&gt; 命令报告它。</target>
        </trans-unit>
        <trans-unit id="186dc5c770148f3dd87e1d02da09c16c26a5cddd" translate="yes" xml:space="preserve">
          <source>You've found a bug in &lt;code&gt;Fatal&lt;/code&gt;. Please report it using the &lt;code&gt;perlbug&lt;/code&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475fb69a6a2555d09a61f2284d19f582455e0ff5" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt; . However the subroutine in question does not have any hints available.</source>
          <target state="translated">您一直坚持在用户子例程的提示上，方法是在前面加 &lt;code&gt;!&lt;/code&gt; 子例程名称本身，或在 &lt;code&gt;autodie&lt;/code&gt; 的参数列表中的较早位置。但是，所讨论的子例程没有任何可用提示。</target>
        </trans-unit>
        <trans-unit id="f41835786752a38d494d7d5ae837f154ec2c37cb" translate="yes" xml:space="preserve">
          <source>You've insisted on hints for user-subroutines, either by pre-pending a &lt;code&gt;!&lt;/code&gt; to the subroutine name itself, or earlier in the list of arguments to &lt;code&gt;autodie&lt;/code&gt;. However the subroutine in question does not have any hints available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c13a053a1a459196298d76dc68f54350a5781eb" translate="yes" xml:space="preserve">
          <source>You've probably seen shuffling algorithms that work using splice, randomly picking another element to swap the current element with</source>
          <target state="translated">你可能见过使用拼接工作的洗牌算法,随机挑选另一个元素与当前元素进行交换</target>
        </trans-unit>
        <trans-unit id="bace4fda5dfa9e604000927d0b697f692a0161ba" translate="yes" xml:space="preserve">
          <source>You've provided either a &lt;code&gt;scalar&lt;/code&gt; hint without supplying a &lt;code&gt;list&lt;/code&gt; hint, or vice-versa. You</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7734dcac6827c63f3c8f78e3f70fe360dc90d8" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section of this documentation.</source>
          <target state="translated">您尝试在无法覆盖的Perl内置组件上使用 &lt;code&gt;Fatal&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ，这意味着 &lt;code&gt;Fatal&lt;/code&gt; 无法为您提供帮助，尽管某些其他模块可能会帮助您。请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&lt;/a&gt;本文档的另请参阅部分。</target>
        </trans-unit>
        <trans-unit id="f898c307fef56d8fb09d91955f3edb21ee3b471f" translate="yes" xml:space="preserve">
          <source>You've tried to use &lt;code&gt;Fatal&lt;/code&gt; on a Perl built-in that can't be overridden, such as &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, which means that &lt;code&gt;Fatal&lt;/code&gt; can't help you, although some other modules might. See the &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; section of this documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770547bed3b38328c9ebe9f8750573476f6753ff" translate="yes" xml:space="preserve">
          <source>Young and free of legacy weight, providing a lightweight and easy to learn API. Has a growing addon ecosystem. It is best used for smaller projects and very easy to learn for beginners.</source>
          <target state="translated">年轻,没有传统的重量,提供轻量级和易于学习的API。拥有一个不断发展的附加组件生态系统。它最适合用于小型项目,对于初学者来说非常容易学习。</target>
        </trans-unit>
        <trans-unit id="ba596fd35b1b636342c6fc7093ef0992a49f81fa" translate="yes" xml:space="preserve">
          <source>Your</source>
          <target state="translated">Your</target>
        </trans-unit>
        <trans-unit id="3c6f85b02933dd53061abea03a23ce712a1c9139" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="translated">您的 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 最有可能工作得很好。这些数字与您的想法不符。</target>
        </trans-unit>
        <trans-unit id="319f611f50fc6a22b8fa54c955965a1d3de00bce" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;int()&lt;/code&gt; is most probably working just fine. It's the numbers that aren't quite what you think.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9533f1ccc20bdaeae76d10a75b07a721d13705b3" translate="yes" xml:space="preserve">
          <source>Your Chinese translator emails right back -- he says both of these phrases translate to the same thing in Chinese, because, in linguistic jargon, Chinese &quot;doesn't have number as a grammatical category&quot; -- whereas English does. That is, English has grammatical rules that refer to &quot;number&quot;, i.e., whether something is grammatically singular or plural; and one of these rules is the one that forces nouns to take a plural suffix (generally &quot;s&quot;) when in a plural context, as they are when they follow a number other than &quot;one&quot; (including, oddly enough, &quot;zero&quot;). Chinese has no such rules, and so has just the one phrase where English has two. But, no problem, you can have this one Chinese phrase appear as the translation for the two English phrases in the &quot;zh&quot; gettext lexicon for your program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f7bdfd19e6ed7691bd6491da0df9046c99f10e" translate="yes" xml:space="preserve">
          <source>Your Italian translator emails you back and says that &quot;I searched 0 directories&quot; (a possible English output of your program) is stilted, and if you think that's fine English, that's your problem, but that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df53f54d51a07584d7be09d83850a7da9c15786b" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">您的基本测试。如果 &lt;code&gt;$test&lt;/code&gt; 为true，则通过；如果$ test为false，则失败。就像Test :: Simple的 &lt;code&gt;ok()&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="13c1c0455bcc3acdf9c65a36998e43b91fb907cc" translate="yes" xml:space="preserve">
          <source>Your basic test. Pass if &lt;code&gt;$test&lt;/code&gt; is true, fail if $test is false. Just like Test::Simple's &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b237ec1c8f3c84ff91c26a3b96b070c2410531e4" translate="yes" xml:space="preserve">
          <source>Your best bet is to use the single argument form:</source>
          <target state="translated">你最好的选择是使用单参数形式。</target>
        </trans-unit>
        <trans-unit id="30a923bd50861e3e1f2796d154bd6dcc6842fa55" translate="yes" xml:space="preserve">
          <source>Your choice:</source>
          <target state="translated">你自己选吧</target>
        </trans-unit>
        <trans-unit id="2240cd19d3c19a8cd0a6388378dc061fa17be90f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe what part of the Perl core you're changing and what you expect your patch to do.</source>
          <target state="translated">你的提交信息应该描述你要修改的 Perl 核心的哪一部分,以及你希望你的补丁做什么。</target>
        </trans-unit>
        <trans-unit id="9f522992b80d434f30bfc99a44403ac7ea5d333f" translate="yes" xml:space="preserve">
          <source>Your commit message should describe why the change you are making is important. When someone looks at your change in six months or six years, your intent should be clear.</source>
          <target state="translated">你的承诺信息应该描述为什么你所做的改变是重要的。当别人在六个月或六年后看到你的变化时,你的意图应该是明确的。</target>
        </trans-unit>
        <trans-unit id="0e92f837de5ea84ed03360a4aeae41a080276983" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="translated">您的当前&lt;b&gt;目录&lt;/b&gt;，&lt;b&gt;操作系统&lt;/b&gt;从该&lt;b&gt;目录&lt;/b&gt;解释相对路径名。操作系统知道您的当前目录是因为您使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 告诉了该目录，或者因为您是从出生时父&lt;b&gt;进程&lt;/b&gt;所在的地方开始的。</target>
        </trans-unit>
        <trans-unit id="d7167b4cc4e41309435c48692bb15d1df5a48299" translate="yes" xml:space="preserve">
          <source>Your current &lt;b&gt;directory&lt;/b&gt;, from which relative pathnames are interpreted by the &lt;b&gt;operating system&lt;/b&gt;. The operating system knows your current directory because you told it with a &lt;code&gt;chdir&lt;/code&gt;, or because you started out in the place where your parent &lt;b&gt;process&lt;/b&gt; was when you were born.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9200ca79b7b623bd2d92209c7c88d5edf0f0d25" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">然后，您的自定义类型应由&lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt;自动拾取。</target>
        </trans-unit>
        <trans-unit id="8f096288cb046102028aee2ab90a36c8f226071a" translate="yes" xml:space="preserve">
          <source>Your custom type should then be picked up automatically by the &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7f0615cde01baf7008f00eb9c075025028921a" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt; .</source>
          <target state="translated">您的发行版&lt;b&gt;必须&lt;/b&gt;有一个 &lt;code&gt;NAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7431b6da14bc1d6fd4725aa372c076a384c899d0" translate="yes" xml:space="preserve">
          <source>Your distribution &lt;b&gt;must&lt;/b&gt; have a &lt;code&gt;NAME&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae118bff15580dd943332f565267249fec4d8f3" translate="yes" xml:space="preserve">
          <source>Your entire first hard disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of your hard disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the hard disk. Writing raw sectors and certain other operations can seriously damage your files or the function of your computer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d2eb0a183e7ffe1856bdc0a5dc547498704b0f" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;Text::Balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df70fd54c497020a59006e2165eb78aadc748605" translate="yes" xml:space="preserve">
          <source>Your first try should probably be the &lt;a href=&quot;text/balanced&quot;&gt;Text::Balanced&lt;/a&gt; module, which is in the Perl standard library since Perl 5.8. It has a variety of functions to deal with tricky text. The &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; module can also help by providing canned patterns you can use.</source>
          <target state="translated">您的第一个尝试可能应该是&lt;a href=&quot;text/balanced&quot;&gt;Text :: Balanced&lt;/a&gt;模块，该模块自Perl 5.8起就位于Perl标准库中。它具有多种功能来处理棘手的文本。在&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;正则表达式::常见&lt;/a&gt;模块还可以通过提供罐装模式，您可以使用帮助。</target>
        </trans-unit>
        <trans-unit id="880f6f429e2d63ef4a94f9a2206ede8287e74da3" translate="yes" xml:space="preserve">
          <source>Your interfaces should be understandable by an average Perl programmer. The following guidelines may help you judge whether your API is sufficiently straightforward:</source>
          <target state="translated">你的接口应该是一个普通的Perl程序员可以理解的。下面的指南可以帮助你判断你的API是否足够简单。</target>
        </trans-unit>
        <trans-unit id="d26baf198cb18edde520e205142e25037414abf9" translate="yes" xml:space="preserve">
          <source>Your internet domain name</source>
          <target state="translated">您的互联网域名</target>
        </trans-unit>
        <trans-unit id="c8e05b300242eb52ca20c1b662ee525c5256fe27" translate="yes" xml:space="preserve">
          <source>Your interpreter doesn't know how to communicate with these extensions on its own. A little glue will help. Up until now you've been calling</source>
          <target state="translated">你的解释器自己不知道如何与这些扩展通信。一点胶水会有帮助。到目前为止,你一直在调用</target>
        </trans-unit>
        <trans-unit id="926b6183d26bfd81c7f17ff04a868dae347149ae" translate="yes" xml:space="preserve">
          <source>Your mileage may vary...</source>
          <target state="translated">您的里程数可能会有所不同...</target>
        </trans-unit>
        <trans-unit id="60a065094064545ff1123708e618e1b6cf8cbd1c" translate="yes" xml:space="preserve">
          <source>Your mileage will vary. If in any doubt &lt;b&gt;do not use it&lt;/b&gt;.</source>
          <target state="translated">您的里程会有所不同。如有任何疑问，&lt;b&gt;请勿使用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c8a47834f473426f773c0b79429bd305f3db3ac9" translate="yes" xml:space="preserve">
          <source>Your module may be object oriented (OO) or not, or it may have both kinds of interfaces available. There are pros and cons of each technique, which should be considered when you design your API.</source>
          <target state="translated">你的模块可能是面向对象(OO)的,也可能不是,或者它可能有两种接口可用。每种技术都有优点和缺点,当你设计API时,应该考虑到这一点。</target>
        </trans-unit>
        <trans-unit id="4936a62e724ff21109fff06e820adf4197164d03" translate="yes" xml:space="preserve">
          <source>Your module should also include a README file describing the module and giving pointers to further information (website, author email).</source>
          <target state="translated">你的模块还应该包含一个README文件,描述该模块,并提供进一步的信息(网站、作者邮箱)。</target>
        </trans-unit>
        <trans-unit id="290b95e5d44851668b2e9d3e7d74fdc415789c4e" translate="yes" xml:space="preserve">
          <source>Your module should have a clearly defined scope which is no longer than a single sentence. Can your module be broken down into a family of related modules?</source>
          <target state="translated">您的模块应该有一个明确定义的范围,不超过一句话。您的模块是否可以分解成一个相关模块的家族?</target>
        </trans-unit>
        <trans-unit id="8348552a40cd77a386588c2671c4e766e50a33bd" translate="yes" xml:space="preserve">
          <source>Your module should include documentation aimed at Perl developers. You should use Perl's &quot;plain old documentation&quot; (POD) for your general technical documentation, though you may wish to write additional documentation (white papers, tutorials, etc) in some other format. You need to cover the following subjects:</source>
          <target state="translated">你的模块应该包括针对 Perl 开发者的文档。你应该使用Perl的 &quot;老式文档&quot;(POD)来编写一般的技术文档,尽管你可能希望用其他格式来编写额外的文档(白皮书、教程等)。你需要涵盖以下主题。</target>
        </trans-unit>
        <trans-unit id="861d9c806a8066b7b2265b2640dfe765fcbec7fa" translate="yes" xml:space="preserve">
          <source>Your module should run successfully under the strict pragma and should run without generating any warnings. Your module should also handle taint-checking where appropriate, though this can cause difficulties in many cases.</source>
          <target state="translated">您的模块应该在strict pragma下成功运行,并且应该在不产生任何警告的情况下运行。您的模块也应该在适当的时候处理污点检查,尽管这在很多情况下会造成困难。</target>
        </trans-unit>
        <trans-unit id="55948057c1f1e500efb989c6858ac749bffed2dd" translate="yes" xml:space="preserve">
          <source>Your module will be part of a developer's toolkit. It will not, in itself, form the &lt;b&gt;entire&lt;/b&gt; toolkit. It's tempting to add extra features until your code is a monolithic system rather than a set of modular building blocks.</source>
          <target state="translated">您的模块将成为开发人员工具包的一部分。它本身不会构成&lt;b&gt;整个&lt;/b&gt;工具箱。诱人的是要添加额外的功能，直到您的代码是单片系统而不是一组模块化构建块。</target>
        </trans-unit>
        <trans-unit id="ad14f196f53d1d71d675a079baed8e60dbe25d0c" translate="yes" xml:space="preserve">
          <source>Your name for distributing the package with the version number included. This is used by 'make dist' to name the resulting archive file.</source>
          <target state="translated">你用来发布包含版本号的软件包的名称。这将被'make dist'用来命名生成的存档文件。</target>
        </trans-unit>
        <trans-unit id="175b500be69da19db3c39bbbb8f52b905fefd909" translate="yes" xml:space="preserve">
          <source>Your naming should be consistent. For instance, it's better to have:</source>
          <target state="translated">你的命名应该是一致的。比如说,最好有。</target>
        </trans-unit>
        <trans-unit id="f42ef3040bfea4a52c4a41099b15560c160072e6" translate="yes" xml:space="preserve">
          <source>Your new toolkit</source>
          <target state="translated">您的新工具箱</target>
        </trans-unit>
        <trans-unit id="ab842b2beec604e1059561d157771750a66116bd" translate="yes" xml:space="preserve">
          <source>Your patch may be returned with requests for changes, or requests for more detailed explanations about your fix.</source>
          <target state="translated">您的补丁可能会被退回,要求更改,或要求对您的修复进行更详细的解释。</target>
        </trans-unit>
        <trans-unit id="1fe050a844b774ad50502f71e6d05cbaaefcd33b" translate="yes" xml:space="preserve">
          <source>Your programs can use the Config module to check whether threads are enabled. If your program can't run without them, you can say something like:</source>
          <target state="translated">你的程序可以使用Config模块来检查是否启用了线程。如果你的程序没有线程就无法运行,你可以说这样的话。</target>
        </trans-unit>
        <trans-unit id="729e5a3fcb0f2511564ed50f52f86e5648feda76" translate="yes" xml:space="preserve">
          <source>Your random numbers are not that random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3998dbed349b6ee91c59e7ad32be8eef4f4d5eba" translate="yes" xml:space="preserve">
          <source>Your return address. The program will ask you to confirm its default if you don't use this option.</source>
          <target state="translated">您的返回地址。如果你不使用这个选项,程序会要求你确认它的默认地址。</target>
        </trans-unit>
        <trans-unit id="cba06454beaed255dda3071738eb1ee00c75c6c3" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ef3a10fbcdb1f56987b1c90e4c788bb1481b23" translate="yes" xml:space="preserve">
          <source>Your script will declare a skip with the reason why you skipped and exit immediately with a zero (success). See &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; for details.</source>
          <target state="translated">您的脚本将声明一个跳过，说明您跳过的原因并立即以零（成功）退出。有关详细信息，请参见&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c17c8db759a1044bdb9841bb5182137da0f0e667" translate="yes" xml:space="preserve">
          <source>Your subpattern can be just about anything, but for it to have some utility, it should match when called with either or both of a) the full name of the property value with underscores (and/or spaces in the Block property) and some things uppercase; or b) the property value in all lowercase with spaces and underscores squeezed out. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e050859bb44c130f248bd693464de24c2fe62560" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;a href=&quot;clock(3)&quot;&gt;&lt;code&gt;clock(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_gettime(2)&quot;&gt;&lt;code&gt;clock_gettime(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_getres(3)&quot;&gt;&lt;code&gt;clock_getres(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_nanosleep(3)&quot;&gt;&lt;code&gt;clock_nanosleep(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;clock_settime(2)&quot;&gt;&lt;code&gt;clock_settime(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;getitimer(2)&quot;&gt;&lt;code&gt;getitimer(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;gettimeofday(2)&quot;&gt;&lt;code&gt;gettimeofday(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sleep(3)&quot;&gt;&lt;code&gt;sleep(3)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stat(2)&quot;&gt;&lt;code&gt;stat(2)&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ualarm(3)&quot;&gt;&lt;code&gt;ualarm(3)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffadff849a0704c5040d7dc21528967305be780" translate="yes" xml:space="preserve">
          <source>Your system documentation for &lt;code&gt;clock&lt;/code&gt; , &lt;code&gt;clock_gettime&lt;/code&gt; , &lt;code&gt;clock_getres&lt;/code&gt; , &lt;code&gt;clock_nanosleep&lt;/code&gt; , &lt;code&gt;clock_settime&lt;/code&gt; , &lt;code&gt;getitimer&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , &lt;code&gt;setitimer&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt; .</source>
          <target state="translated">您的 &lt;code&gt;clock&lt;/code&gt; ， &lt;code&gt;clock_gettime&lt;/code&gt; ， &lt;code&gt;clock_getres&lt;/code&gt; ， &lt;code&gt;clock_nanosleep&lt;/code&gt; ， &lt;code&gt;clock_settime&lt;/code&gt; ， &lt;code&gt;getitimer&lt;/code&gt; ， &lt;code&gt;gettimeofday&lt;/code&gt; ， &lt;code&gt;setitimer&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;ualarm&lt;/code&gt; 的系统文档。</target>
        </trans-unit>
        <trans-unit id="f45278c990de17bddc07886e62872d5705e84df2" translate="yes" xml:space="preserve">
          <source>Your system may also have man pages installed for those modules, in which case you can probably just use the man(1) command.</source>
          <target state="translated">你的系统可能还安装了这些模块的手册,在这种情况下,你可以直接使用 man(1)命令。</target>
        </trans-unit>
        <trans-unit id="f67311ed40fd91017f49e031b08d5e66ea348e7f" translate="yes" xml:space="preserve">
          <source>Your system may use lockfiles to control multiple access. Make sure you follow the correct protocol. Unpredictable behavior can result from multiple processes reading from one device.</source>
          <target state="translated">您的系统可能会使用锁文件来控制多个访问。确保您遵循正确的协议。从一个设备读取多个进程会导致不可预测的行为。</target>
        </trans-unit>
        <trans-unit id="69b78ca3bd9762db3a1f2fc87f8707247fab00ca" translate="yes" xml:space="preserve">
          <source>Your terminal expects ISO-8859-1 (yes/no)?</source>
          <target state="translated">您的终端希望使用ISO-8859-1(是/否)?</target>
        </trans-unit>
        <trans-unit id="eb27aa8afa0df31a742a7c36ee000dde7a333d59" translate="yes" xml:space="preserve">
          <source>Your test suite additions should generally follow these guidelines (courtesy of Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;):</source>
          <target state="translated">您添加的测试套件通常应遵循以下准则（由Gurusamy Sarathy提供：&amp;lt;gsar@activestate.com&amp;gt;）：</target>
        </trans-unit>
        <trans-unit id="6757bbaa3e59b9eae8d3358f1cb54cb3839ec256" translate="yes" xml:space="preserve">
          <source>Your text string will be sent using the bytes in Perl's internal format. In some cases, Perl will warn you that you're doing something wrong, with a friendly warning:</source>
          <target state="translated">你的文本字符串将使用Perl的内部格式的字节来发送。在某些情况下,Perl 会警告你做错了什么,并发出友好的警告。</target>
        </trans-unit>
        <trans-unit id="e6fdf4d82698552aa3b04fea17dd3738278fad63" translate="yes" xml:space="preserve">
          <source>Your version number for distributing the package. This defaults to 0.1.</source>
          <target state="translated">您发布软件包的版本号。默认值为0.1。</target>
        </trans-unit>
        <trans-unit id="6470a2f4b416b0ce03b530f9156d5bf0649ff6c9" translate="yes" xml:space="preserve">
          <source>Your version number for the .xs file of this package. This defaults to the value of the VERSION attribute.</source>
          <target state="translated">你的这个软件包的.xs文件的版本号。这个默认为VERSION属性的值。</target>
        </trans-unit>
        <trans-unit id="f943e56eab4587790a7d8e3702190e81dcdaf111" translate="yes" xml:space="preserve">
          <source>YourModule.pm</source>
          <target state="translated">YourModule.pm</target>
        </trans-unit>
        <trans-unit id="a032b09d002bfec745ff9618af85165922efa0c5" translate="yes" xml:space="preserve">
          <source>YourPackage.pm</source>
          <target state="translated">YourPackage.pm</target>
        </trans-unit>
        <trans-unit id="96b451942b04b66df98082b51a96fd9c21c979e6" translate="yes" xml:space="preserve">
          <source>YourPackage.xs</source>
          <target state="translated">YourPackage.xs</target>
        </trans-unit>
        <trans-unit id="3a63a963c11724e54297328f1cd01fab7cc056fb" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_language_classes()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_language_classes()</target>
        </trans-unit>
        <trans-unit id="93d7ab614acf51e6ed84bd194c23c002e0bc546a" translate="yes" xml:space="preserve">
          <source>YourProjClass-&amp;gt;fallback_languages()</source>
          <target state="translated">YourProjClass-&amp;gt;fallback_languages()</target>
        </trans-unit>
        <trans-unit id="98d44898a77a54f7718ada94977059bdfaa937a9" translate="yes" xml:space="preserve">
          <source>Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</source>
          <target state="translated">Yuval Kogman &amp;lt;nothingmuch@woobling.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="07164f28ddae965cddce1176bfcf228c5d4cba8c" translate="yes" xml:space="preserve">
          <source>Yves Orton</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3031c81c2a11248f63acc5b78e4d34caa6f6e1" translate="yes" xml:space="preserve">
          <source>Yves Orton suggested and helped for making &lt;code&gt;Sys::Syslog&lt;/code&gt; use the native event logger under Win32 systems.</source>
          <target state="translated">Yves Orton建议并帮助使 &lt;code&gt;Sys::Syslog&lt;/code&gt; 在Win32系统下使用本机事件记录器。</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="d9d220ab2925c9b97a98a9d9b35059f864dbe73a" translate="yes" xml:space="preserve">
          <source>ZIP</source>
          <target state="translated">ZIP</target>
        </trans-unit>
        <trans-unit id="685e745370d7ffc08330b15ff0e898d01b1112c8" translate="yes" xml:space="preserve">
          <source>ZLIB</source>
          <target state="translated">ZLIB</target>
        </trans-unit>
        <trans-unit id="afc6c45769ec18ef9f8f79510ff88d4f56540059" translate="yes" xml:space="preserve">
          <source>Zero</source>
          <target state="translated">Zero</target>
        </trans-unit>
        <trans-unit id="acf70cc883c3ef52ca41acaeee58af2e53ac5854" translate="yes" xml:space="preserve">
          <source>Zero length \N{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48ab14b512dde996fa9a15aacd833945ec5f9a6" translate="yes" xml:space="preserve">
          <source>Zero or more embedded pattern-match modifiers, to be turned on (or turned off if preceded by &lt;code&gt;&quot;-&quot;&lt;/code&gt;) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f655446e726aef6fcbbbc67b592301154abfb5dd" translate="yes" xml:space="preserve">
          <source>ZeroD</source>
          <target state="translated">ZeroD</target>
        </trans-unit>
        <trans-unit id="0093edc3abc07bdec91d7aaaa812118b59df0952" translate="yes" xml:space="preserve">
          <source>Zeus</source>
          <target state="translated">Zeus</target>
        </trans-unit>
        <trans-unit id="f2fd2a56c54b7c37d0d9f4b109a0de518f12a9a8" translate="yes" xml:space="preserve">
          <source>Zeus for Windows is another Win32 multi-language editor/IDE that comes with support for Perl.</source>
          <target state="translated">Zeus for Windows是另一个支持Perl的Win32多语言编辑器/IDE。</target>
        </trans-unit>
        <trans-unit id="5922f5ceeff38bcfdb993efd6cfd5c472f827fa9" translate="yes" xml:space="preserve">
          <source>Zimbabwe</source>
          <target state="translated">Zimbabwe</target>
        </trans-unit>
        <trans-unit id="e1fe5d84561f30200d262fed8306805379c095f6" translate="yes" xml:space="preserve">
          <source>Zip Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222ddf368cdba35bc5af070a0978dbd9007e77f9" translate="yes" xml:space="preserve">
          <source>Zip64</source>
          <target state="translated">Zip64</target>
        </trans-unit>
        <trans-unit id="c5b305a4c34b7027cdd20c60babbc737e1ea5ce5" translate="yes" xml:space="preserve">
          <source>Zipdetails displays information about the internal record structure of the zip file. It is not concerned with displaying any details of the compressed data stored in the zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db104e2c14625f90e76e1788e4a37b936ee652b6" translate="yes" xml:space="preserve">
          <source>Zlib Library Version Support</source>
          <target state="translated">Zlib库版本支持</target>
        </trans-unit>
        <trans-unit id="b921378e5d6ffc3afd5712a860acbd0c806b6fd7" translate="yes" xml:space="preserve">
          <source>Zlib Resources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4711f7565028433a4314c92a81925825c798cf57" translate="yes" xml:space="preserve">
          <source>Zombies</source>
          <target state="translated">Zombies</target>
        </trans-unit>
        <trans-unit id="1e5c2f367f02e47a8c160cda1cd9d91decbac441" translate="yes" xml:space="preserve">
          <source>[</source>
          <target state="translated">[</target>
        </trans-unit>
        <trans-unit id="c3eb06ad4792b7cd40a4451742b55657a2707dfb" translate="yes" xml:space="preserve">
          <source>[ Note: previous editions of the spec had &lt;code&gt;dir&lt;/code&gt; instead of &lt;code&gt;directory&lt;/code&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1358ca17f4fbd1e63e273da592aecdd7f2d4541" translate="yes" xml:space="preserve">
          <source>[*] http://www.unicode.org/repos/cldr/tags/latest/seed/collation/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a987f8fd28617d0641e26e1ee23e3f1c471fb" translate="yes" xml:space="preserve">
          <source>[.Foo.Bar]</source>
          <target state="translated">[.Foo.Bar]</target>
        </trans-unit>
        <trans-unit id="4b6373280a08e827a1ab5c68abe6349dceef8925" translate="yes" xml:space="preserve">
          <source>[.Lib.Auto.</source>
          <target state="translated">[.Lib.Auto.</target>
        </trans-unit>
        <trans-unit id="630f50e0cd8cffab6e0a142979fe618389586858" translate="yes" xml:space="preserve">
          <source>[.pod]</source>
          <target state="translated">[.pod]</target>
        </trans-unit>
        <trans-unit id="1184f5b8d4b6dd08709cf1513f26744167065e0d" translate="yes" xml:space="preserve">
          <source>[0]</source>
          <target state="translated">[0]</target>
        </trans-unit>
        <trans-unit id="e9310b0c165be166c43d717718981dd6c9379fbe" translate="yes" xml:space="preserve">
          <source>[10]</source>
          <target state="translated">[10]</target>
        </trans-unit>
        <trans-unit id="ead435550bed6c7728d2f8005c87a3108ae51206" translate="yes" xml:space="preserve">
          <source>[10] Perl has &lt;code&gt;\X&lt;/code&gt; and &lt;code&gt;\b{gcb}&lt;/code&gt;. Unicode has retracted their &quot;Grapheme Cluster Mode&quot;, and recently added string properties, which Perl does not yet support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6431f9aef7720a5ded14cfda76812cbf19d9f7b5" translate="yes" xml:space="preserve">
          <source>[11] see &lt;a href=&quot;https://www.unicode.org/reports/tr29&quot;&gt;UAX#29 &quot;Unicode Text Segmentation&quot;&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee40540fe63a506ce6d36914c87bb4afea3cd2" translate="yes" xml:space="preserve">
          <source>[12] see &lt;a href=&quot;#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394d4974dd13620cf2e99365a3bb93bf704a4ae5" translate="yes" xml:space="preserve">
          <source>[13] Perl supports all the properties in the Unicode Character Database (UCD). It does not yet support the listed properties that come from other Unicode sources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ce2d0b777027047f49d6aebdade5275a4bb399" translate="yes" xml:space="preserve">
          <source>[14] The only optional property that Perl supports is Named Sequence. None of these properties are in the UCD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f629ae44b7b3dcfed444d363e626edf411ec69a8" translate="yes" xml:space="preserve">
          <source>[1]</source>
          <target state="translated">[1]</target>
        </trans-unit>
        <trans-unit id="0cf7207af93f70e6c641ba1e90b8e15f86916573" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://en.wikipedia.org/wiki/Base64#URL_applications&quot;&gt;http://en.wikipedia.org/wiki/Base64#URL_applications&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6819c355b216edc67b6c6a8c6dab5509cee1376" translate="yes" xml:space="preserve">
          <source>[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</source>
          <target state="translated">[1] &lt;a href=&quot;http://perl.plover.com/Rx/paper/&quot;&gt;http://perl.plover.com/Rx/paper/&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
