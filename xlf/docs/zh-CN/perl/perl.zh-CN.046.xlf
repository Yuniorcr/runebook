<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">现在你可以编译Perl了。种类。</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">现在您可以生成二进制分布。这是通过运行CPAN分发 &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; 的测试来完成的。调整文件</target>
        </trans-unit>
        <trans-unit id="93e496fadabb1e64e6e7d67223c19456b5dbe7c9" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt;. Tune up the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">现在您可以将文件重命名为</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">现在你可以用下面的(SDF)命令启动它。</target>
        </trans-unit>
        <trans-unit id="3fdb47077c25bbc7fd05ea6699ff777a03b6a0b4" translate="yes" xml:space="preserve">
          <source>Now you can switch back to blead locally:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">现在你可以写</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">现在，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 之一写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="dad49068c95ec062280fac9c3dcad77dc06ce94c" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">现在你可以了。</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">现在，您不能更改 &lt;code&gt;$PI&lt;/code&gt; ，这可能总体而言是一件好事。这与常量子例程不同，后者在编译时会进行优化。常量子例程是一种原型，不带任何参数并返回常量表达式。有关这些的详细信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 附注是这些方便的速记。</target>
        </trans-unit>
        <trans-unit id="c97546944079cddc1746ac13882c5e6cfa5ab3f9" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt;, which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;use constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">现在你检查$is_tiny_prime[$some_number]。</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">现在你有了所有必要的</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">现在，您将整个POD文档作为一棵巨大的大型分析树。您甚至可以使用&lt;b&gt;-expand_seq&lt;/b&gt;选项来&lt;b&gt;解析文本，&lt;/b&gt;以插入各种不同的对象。只是不要期望&lt;b&gt;Pod :: Parser&lt;/b&gt;在那之后知道如何处理它们。那将需要在您的代码中。或者，您也可以插入任何喜欢的对象，只要它符合&lt;b&gt;Pod :: ParseTree&lt;/b&gt;接口即可。</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">现在，您可以在该句柄上使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 之类的函数。可能最常见的输入函数是看起来像运算符的函数：</target>
        </trans-unit>
        <trans-unit id="367c47e849864052497095e9f7fa487dd90eceb2" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;getc&lt;/code&gt;, and &lt;code&gt;sysread&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">现在你应该非常小心,外括号类型是一个圆括号,也就是括号。这是因为你要分配给一个@array,所以你需要括号。如果你想要有</target>
        </trans-unit>
        <trans-unit id="d66b8a1ad54810e72ec52858762c88f3380e16c6" translate="yes" xml:space="preserve">
          <source>Now you'll see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">现在,你已经准备好建立。</target>
        </trans-unit>
        <trans-unit id="cb48a5248ec746855c13f0d7ab0feb804820903a" translate="yes" xml:space="preserve">
          <source>Now you're ready to run &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt;!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">现在，您的IO将在ASCII分区上为ASCII，在EBCDIC分区上为EBCDIC。有关更多可能性，请参见PerlIO的文档（无 &lt;code&gt;Encode::&lt;/code&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="7b95b8f4eb02584fba76319179b45221c640f17c" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt;!) for further possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">现在， &lt;code&gt;-h24&lt;/code&gt; 将选项 &lt;code&gt;h&lt;/code&gt; 设置为 &lt;code&gt;24&lt;/code&gt; ，但选项包（如 &lt;code&gt;-vxa&lt;/code&gt; 和 &lt;code&gt;-h24w80&lt;/code&gt; )被标记为错误。</target>
        </trans-unit>
        <trans-unit id="330db949eeb51ae2f426c6b4541a1ffbf72e90be" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt;, but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">现在， &lt;code&gt;-vax&lt;/code&gt; 将设置选项 &lt;code&gt;vax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e294ef877a18e50d3cf43096be573f3ba73196e" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">现在，关于您可能要使用这些处理程序做什么：也许您想记录什么键对于哪个类失败了，然后消失。也许您不喜欢 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，而是想将错误消息发送到STDOUT（或任何位置），然后仅 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8c9c99975917c3ed487322ad5c970c3faeddcbc" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;die&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">现在,由于顶层只包含引用,如果你试图用一个简单的print()函数打印出你的数组,你会得到一些看起来不太好的东西,就像这样。</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">现在,想想这个。</target>
        </trans-unit>
        <trans-unit id="d7ffbca375f24628b0da0f697f3844b6c5775889" translate="yes" xml:space="preserve">
          <source>Now, create a fork on GitHub to push your branch to, and add it as a remote if you haven't already, as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/working-with-forks&quot;&gt;https://help.github.com/en/articles/working-with-forks&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">现在，即使 &lt;code&gt;[0-9]&lt;/code&gt; 也可能会困扰多次写入，因此，为了节省击键次数和使正则表达式更具可读性，Perl为常见字符类提供了几种缩写，如下所示。自从引入Unicode以来，除非 &lt;code&gt;//a&lt;/code&gt; 修饰符生效，否则这些字符类不仅仅匹配ASCII范围内的几个字符。</target>
        </trans-unit>
        <trans-unit id="e2eacdfa4a021a03b4f7ed6c8878ca3eccdafc77" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">现在，如果 &lt;code&gt;junk&lt;/code&gt; 与我们要添加的字符串相同，我们可以直接从SV抓取字符串； &lt;code&gt;SvPVX&lt;/code&gt; 是SV中PV的地址。</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">现在,想象一下,我们要为一台具有不同字节顺序的机器打包数据。首先,我们必须弄清楚目标机器上的数据类型到底有多大。让我们假设长数据是32位宽,短数据是16位宽。然后你可以将模板重写为</target>
        </trans-unit>
        <trans-unit id="5e966fc4eb896c9493f50919b32baf5ee748e75c" translate="yes" xml:space="preserve">
          <source>Now, inside of the &lt;code&gt;WriteMakeFile()&lt;/code&gt; function in your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">现在,让我们扩展前面的例子,同时返回参数的和和差。</target>
        </trans-unit>
        <trans-unit id="ac0e50de65e6792eafd44dfb3d472e96b20f9034" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;Net::SMTP&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">现在，相当多的人拥有Acme Transmogrifier，并且您不得不写一些东西从头开始谈论协议-您几乎可以肯定希望将其纳入模块中。调整级别取决于您：您可能希望类似于&lt;a href=&quot;net/smtp&quot;&gt;Net :: SMTP的&lt;/a&gt;协议级别的模块，然后与类似于&lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Send的&lt;/a&gt;更高级别的模块进行通信。选择是您的，但是您确实想为该服务器协议提供一个模块。</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">现在,就在你刚刚写完上面几行文字之后,你通常要打开ThisProject/I18N/en.pm文件,并立即添加一个条目。</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">现在,运行make将产生类似于这样的输出(为了清晰起见,一些长行被缩短,一些无关的行被删除)。</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">现在，假设您要搜索单个字符 &lt;code&gt;/GX/&lt;/code&gt; 。Perl不了解Martian，因此它将在&amp;ldquo;我是CVSGXX！&amp;rdquo;中找到两个字节&amp;ldquo; GX&amp;rdquo;。字符串，即使该字符不存在：它看起来像是因为&amp;ldquo; SG&amp;rdquo;在&amp;ldquo; XX&amp;rdquo;旁边，但是没有真正的&amp;ldquo; GX&amp;rdquo;。这是个大问题。</target>
        </trans-unit>
        <trans-unit id="3510dbe78a5971908a5d18e000554027edb2cb1f" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt;. Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">现在，假设您要在XS中使用Perlio图层。我们将使用perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; 函数作为示例。</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">现在,这就是我们的数据解析。我想我们现在可能要做的是把我们的收入和支出合计起来,然后在我们的分类账的末尾再加一行--用同样的格式--说明我们带来了多少钱,花了多少钱。</target>
        </trans-unit>
        <trans-unit id="b6104104e2da85f59a70d3eb8135a126533dc183" translate="yes" xml:space="preserve">
          <source>Now, the Russian quant method here is responsible not only for implementing the strange logic necessary for figuring out how Russian number-phrases impose case and number on their noun-phrases, but also for inflecting the Russian word for &quot;directory&quot;. How that inflection is to be carried out is no small issue, and among the solutions I've seen, some (like variations on a simple lookup in a hash where all possible forms are provided for all necessary words) are straightforward but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">现在,以下对你的函数的调用都是完全等价的。</target>
        </trans-unit>
        <trans-unit id="cfc8866cddcad33148adff8ad6715f9f23dc807f" translate="yes" xml:space="preserve">
          <source>Now, there's no particularly obvious way to store anything but strings in a gettext lexicon; so it looks like we just have to start over and make something better, from scratch. I call my shot at a gettext-replacement system &quot;Maketext&quot;, or, in CPAN terms, Locale::Maketext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">现在，在命令行上使用 &lt;code&gt;--verbose&lt;/code&gt; 将启用 &lt;code&gt;$verbose&lt;/code&gt; ，如预期的那样。但是它也被允许使用 &lt;code&gt;--noverbose&lt;/code&gt; ，它将通过将 &lt;code&gt;$verbose&lt;/code&gt; 的值设置为 &lt;code&gt;0&lt;/code&gt; 来禁用$ verbose。使用合适的默认值，程序可以找出 &lt;code&gt;$verbose&lt;/code&gt; 默认为false还是使用 &lt;code&gt;--noverbose&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="d0e3286afdf8a8f15ad325a81b0628c314540334" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt;, as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt;, which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt;. Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">现在，我们知道在标量上下文中， &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; 返回true或false值。但是，在列表上下文中，它返回匹配值 &lt;code&gt;($1,$2,$3)&lt;/code&gt; 。所以我们可以更紧凑地编写代码</target>
        </trans-unit>
        <trans-unit id="c881bffc946b525469a86f23ed507e231ad46769" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt;. So we could write the code more compactly as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf36e6267baebdc3ed4fd5c4c6b178499170bce" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">现在，如果您不想将&amp;ldquo; and&amp;rdquo;大写怎么办？只需使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt;并继续处理下一个问题即可。:)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">现在,我们所做的就是在我们的脚本上启动内置的perl调试器。它停在第一行可执行代码处,等待输入。</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">现在,这是怎么回事?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">空的AV指针。</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">空的CV指针。</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">Null HV指针。</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">空SV指针。（在定义 &lt;code&gt;PERL_CORE&lt;/code&gt; 时不再可用。）</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">空字符指针。（在定义 &lt;code&gt;PERL_CORE&lt;/code&gt; 时不再可用。）</target>
        </trans-unit>
        <trans-unit id="ebc5c9f306915d4135b8053056b0178c088e8651" translate="yes" xml:space="preserve">
          <source>Null picture in formline</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa4bd9c62d3ecb53b530fd1a90e4da66bcf3402d" translate="yes" xml:space="preserve">
          <source>Null realloc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebe00d5eb5dc6465abbd73f1052105fa12c1088" translate="yes" xml:space="preserve">
          <source>Nullav</source>
          <target state="translated">Nullav</target>
        </trans-unit>
        <trans-unit id="0f70fd3842939caf1b28e5e61343267fb7df7093" translate="yes" xml:space="preserve">
          <source>Nullch</source>
          <target state="translated">Nullch</target>
        </trans-unit>
        <trans-unit id="32ecb682e3f060838162e9bbbbf1d860a0d1dca5" translate="yes" xml:space="preserve">
          <source>Nullcv</source>
          <target state="translated">Nullcv</target>
        </trans-unit>
        <trans-unit id="e547450e00d976847c97a5b3855e227ed6ee122c" translate="yes" xml:space="preserve">
          <source>Nullhv</source>
          <target state="translated">Nullhv</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Nullops显示为 &lt;code&gt;ex-opname&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="f59d50c5f13fde39f97b92afad489b0c203d91e4" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt;, where</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c3cf48b244deeb77cbf7fb2d31febc3616e04" translate="yes" xml:space="preserve">
          <source>Nullsv</source>
          <target state="translated">Nullsv</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">运行的迭代次数。</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">要保存的行数?</target>
        </trans-unit>
        <trans-unit id="39678ab676a3f472a8537a68ada508040f950313" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">有意义的数字的数量。前面的0不计算在内。当一个数中有0或尾数为0时,其准确度可能大于非零位数。例如,123.456的A为6,10203为5,123.0506为7,123.450000为8,0.000123为3。</target>
        </trans-unit>
        <trans-unit id="c5aadd077767ce8ba345b0317eb500c0c374d288" translate="yes" xml:space="preserve">
          <source>Number too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa074fe25a6265136343f6af71868d2eb3ffdf5" translate="yes" xml:space="preserve">
          <source>Number with no digits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">使用次数以16位无符号整数形式存储,因此不能超过65535。</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">编号捕捉回调</target>
        </trans-unit>
        <trans-unit id="2f3ef08b1556d451a2f171bcd8cc5fa9d0a67578" translate="yes" xml:space="preserve">
          <source>Numbers containing a fractional or exponential part will always be represented as numeric (floating point) values, possibly at a loss of precision (in which case you might lose perfect roundtripping ability, but the JSON number will still be re-encoded as a JSON number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">数字周围不需要引号。</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">数字密度和宽度</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">括号中的数字表示该属性所匹配的Unicode码点总数。为强调这一点,那些完全不匹配代码点的属性也被列在表格后的单独部分。</target>
        </trans-unit>
        <trans-unit id="34ed490a2fac8e8118b8b1dcb98a2f46ca2806fc" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For the entries that give the longest, most descriptive version of the property, the count is followed by a list of some of the code points matched by it. The list includes all the matched characters in the 0-255 range, enclosed in the familiar [brackets] the same as a regular expression bracketed character class. Following that, the next few higher matching ranges are also given. To avoid visual ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">160-255范围内的数字指的是Latin-1字符(Unicode也在此定义了,意义相同)。超过255的数字应理解为指Unicode字符。</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">数值字段</target>
        </trans-unit>
        <trans-unit id="8c7c98efa8c2ec06026f0650448ebfec04745d0d" translate="yes" xml:space="preserve">
          <source>Numeric comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">数值转换</target>
        </trans-unit>
        <trans-unit id="c721f5217c35d940494ce8935e78185eea92c32c" translate="yes" xml:space="preserve">
          <source>Numeric format result too large</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">数字功能</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">数字字元是以下列任何一种浮点或整数格式指定的。</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">数值运算符和数值转换</target>
        </trans-unit>
        <trans-unit id="44e5694a92fbb0b839eb3d472cdd4e3a72b88c8c" translate="yes" xml:space="preserve">
          <source>Numeric variables with more than one digit may not start with '0'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d013232ca01b901c06ddf5aa9483529f278d91" translate="yes" xml:space="preserve">
          <source>Numeric_Value</source>
          <target state="translated">Numeric_Value</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Numify返回实例数据的字节数。</target>
        </trans-unit>
        <trans-unit id="1930939e1cfe41540640ae63b0d1c9cd976b8003" translate="yes" xml:space="preserve">
          <source>NushuSources.txt</source>
          <target state="translated">NushuSources.txt</target>
        </trans-unit>
        <trans-unit id="785fb0c8fda67339daa5891e78532ef7046332eb" translate="yes" xml:space="preserve">
          <source>Nuts and bolts of testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-通往Perl编译器后端的通用接口。</target>
        </trans-unit>
        <trans-unit id="7f2e040017a2a32e5149e8541c71a3f6ab2be70d" translate="yes" xml:space="preserve">
          <source>OA_BASEOP</source>
          <target state="translated">OA_BASEOP</target>
        </trans-unit>
        <trans-unit id="a0232d9c77de9ad3ad30f960003fca0ebf21434a" translate="yes" xml:space="preserve">
          <source>OA_BINOP</source>
          <target state="translated">OA_BINOP</target>
        </trans-unit>
        <trans-unit id="dd4e2946f44fa938f47620909c47a03ec9907915" translate="yes" xml:space="preserve">
          <source>OA_COP</source>
          <target state="translated">OA_COP</target>
        </trans-unit>
        <trans-unit id="8bb6941ea27d2f4edcd36aa185a95c1934071dae" translate="yes" xml:space="preserve">
          <source>OA_LISTOP</source>
          <target state="translated">OA_LISTOP</target>
        </trans-unit>
        <trans-unit id="1f95f49a3cc0d9c9dce498b8fb55f7d434ffef98" translate="yes" xml:space="preserve">
          <source>OA_LOGOP</source>
          <target state="translated">OA_LOGOP</target>
        </trans-unit>
        <trans-unit id="080d4766c1c017ed91c21efdfd770542db5231ba" translate="yes" xml:space="preserve">
          <source>OA_LOOP</source>
          <target state="translated">OA_LOOP</target>
        </trans-unit>
        <trans-unit id="b82424ac68328551cd5b311d9b76afd01dc2b8ec" translate="yes" xml:space="preserve">
          <source>OA_PADOP</source>
          <target state="translated">OA_PADOP</target>
        </trans-unit>
        <trans-unit id="1c24597939e0dd807c389498cedbeb0fddd031c5" translate="yes" xml:space="preserve">
          <source>OA_PMOP</source>
          <target state="translated">OA_PMOP</target>
        </trans-unit>
        <trans-unit id="388be58f270e37e48cf5f4058c11eb99107d89f1" translate="yes" xml:space="preserve">
          <source>OA_PVOP_OR_SVOP</source>
          <target state="translated">OA_PVOP_OR_SVOP</target>
        </trans-unit>
        <trans-unit id="565cd3fb7a20fefb8a748b15fbc632d71f3b0236" translate="yes" xml:space="preserve">
          <source>OA_SVOP</source>
          <target state="translated">OA_SVOP</target>
        </trans-unit>
        <trans-unit id="6e405aaa77ee94bd8832317336e851e6173b598b" translate="yes" xml:space="preserve">
          <source>OA_UNOP</source>
          <target state="translated">OA_UNOP</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">对象方法</target>
        </trans-unit>
        <trans-unit id="bb24863eee0d4bd1920af16c1ccee60c7f9c3be6" translate="yes" xml:space="preserve">
          <source>OBJECT SERIALISATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">面向对象的基础知识</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">面向对象的接口(Object-ORIENTED INTERFACE)。</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="05862bdb9f65a88577df4e19fea889c438e90640" translate="yes" xml:space="preserve">
          <source>ODBM_File</source>
          <target state="translated">ODBM_File</target>
        </trans-unit>
        <trans-unit id="7e05f5ed4d1b9fde9620b516a5a0c77a7eb29821" translate="yes" xml:space="preserve">
          <source>ODBM_File - Tied access to odbm files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdefafa72aee75553cdc6a69cd8b93613e4f45c" translate="yes" xml:space="preserve">
          <source>OFFSETS</source>
          <target state="translated">OFFSETS</target>
        </trans-unit>
        <trans-unit id="90916aa5c9b7aec2f126aa735cbb92f018d5530c" translate="yes" xml:space="preserve">
          <source>OFFSETSDBG</source>
          <target state="translated">OFFSETSDBG</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK(比如说,这个系统依赖的模块构建在其他发行版的子目录中,或者被列为CPAN::Bundle中的依赖项,但在当前的架构上通过不同的方式支持该功能)。</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">好吧,相对于</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">好，这是一个开始，但是这些空间发生了什么？我们放了 &lt;code&gt;x&lt;/code&gt; ，不是吗？它不应该向前跳吗？让我们看一下&lt;a href=&quot;functions/pack&quot;&gt;包装上的内容&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="36f7ee24c9b6c25eb367d474e774055820afae57" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt;, didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt; says:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">好了,让我们再来看看我们的一些数据,事实上,我们将包括标题,以及一个方便的尺子,以便我们可以跟踪我们的位置。</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">好吧，让我们咬一下子弹。这是通过插入模板代码 &lt;code&gt;x&lt;/code&gt; 来获得正确对齐的一种方法，该模板代码不会从列表中获取相应的项目：</target>
        </trans-unit>
        <trans-unit id="5f004dfa733000f32dac52f2362a807ead5a0ec9" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt;, which don't take a corresponding item from the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">好吧,最后一个其实是混淆Perl比赛的作品。 :-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">好，接下来是什么？在日期和描述之间是空白列；我们想跳过那个。该 &lt;code&gt;x&lt;/code&gt; 模板的意思是&amp;ldquo;快进&amp;rdquo;，所以我们想其中的一个。接下来，我们还有另一组字符，从12到38。这又是27个字符，因此是 &lt;code&gt;A27&lt;/code&gt; 。（不要使该篱笆错误-在12到38之间有27个字符，而不是26。算上他们！）</target>
        </trans-unit>
        <trans-unit id="05a96155067c83cf8e468762a0e54175339f79a8" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt;. (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">好了,你知道了regexps的基础知识,你想知道更多。如果说匹配正则表达式类似于在树林里散步,那么第1部分讨论的工具就类似于拓扑图和指南针,是我们经常使用的基本工具。第2部分的大部分工具类似于信号枪和卫星电话。它们在徒步旅行中使用的频率并不高,但当我们被困时,它们可能是无价之宝。</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">好了,这就是C部分的工作。这就是C部分的工作。现在,在这个补丁准备就绪之前,我们必须做两件额外的事情:我们已经改变了 Perl 的行为,所以我们必须将这一改变记录下来;我们还必须提供一些回归测试,以确保我们的补丁能够工作,并且不会在其他地方产生错误。我们还必须提供更多的回归测试,以确保我们的补丁能够正常工作,并且不会在其他地方产生错误。</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">旧建筑说明</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">旧的PERL版本</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">一步步向前走</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">一步之遥</target>
        </trans-unit>
        <trans-unit id="65b7fafd1d758275b2afd66a14ad17bf21acd2fc" translate="yes" xml:space="preserve">
          <source>ONESIDED LEXICONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">OO INTERFACE</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">OO接口</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">OO Perl</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl相对简单，并且使用引用来实现，这些引用基于Perl的包概念知道它们属于哪种对象。但是，OO Perl在很大程度上超出了本文档的范围。阅读&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;和&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">OO系统总结</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">选择系统调用的OO接口</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">用户netrc文件的OO接口</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">OOP式</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">OP树</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">OP类缩略语</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">OP旗的缩写</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">OP标志可以是公共的,也可以是私有的。公共标志以一致的方式改变每个操作码的行为,用0或更多的单字符表示。</target>
        </trans-unit>
        <trans-unit id="4e1c899139139b6a62148bc5314166d68c3c0058" translate="yes" xml:space="preserve">
          <source>OP op_private flag definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">与《任择议定书》相关的课程</target>
        </trans-unit>
        <trans-unit id="134d5bae173a0d828238edb09ac60f90d32a7d18" translate="yes" xml:space="preserve">
          <source>OPEN this, filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION是LOCK_SH，LOCK_EX或LOCK_UN之一，可能与LOCK_NB结合使用。这些常量的传统值是1、2、8和4，但是如果从&lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt;模块中分别或通过使用 &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 标记将它们导入，则可以使用符号名。LOCK_SH请求共享锁，LOCK_EX请求排他锁，而LOCK_UN释放先前请求的锁。如果将LOCK_NB与LOCK_SH或LOCK_EX进行按位或运算，则 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 立即返回，而不是阻塞等待锁；检查退货状态以查看是否收到。</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION是LOCK_SH，LOCK_EX或LOCK_UN之一，可能与LOCK_NB结合使用。这些常量的传统值是1、2、8和4，但是如果从&lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;模块中分别或通过使用 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 标记将它们导入，则可以使用符号名。LOCK_SH请求共享锁，LOCK_EX请求排他锁，而LOCK_UN释放先前请求的锁。如果将LOCK_NB与LOCK_SH或LOCK_EX进行按位或运算，则 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 立即返回，而不是阻塞等待锁；检查退货状态以查看是否收到。</target>
        </trans-unit>
        <trans-unit id="58928b6b598b49fbbad1c76c170db949cd86f725" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:flock&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">运营商的差异</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="06c49349926c115048c467e62819168f88084bea" translate="yes" xml:space="preserve">
          <source>OPTIMISE</source>
          <target state="translated">OPTIMISE</target>
        </trans-unit>
        <trans-unit id="4f728fb4e19e018dc7c2672b0908d6be76bddf1f" translate="yes" xml:space="preserve">
          <source>OPTIMISEM</source>
          <target state="translated">OPTIMISEM</target>
        </trans-unit>
        <trans-unit id="02ce66c3b2f62920ab55a0e848d4ded3f5f982b7" translate="yes" xml:space="preserve">
          <source>OPTIMIZE</source>
          <target state="translated">OPTIMIZE</target>
        </trans-unit>
        <trans-unit id="8a61db568f56cdf729bb2bcffb35bc1a208ff62c" translate="yes" xml:space="preserve">
          <source>OPTIONAL FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463186385d27ae21b6cfb79380a5979894ad32c0" translate="yes" xml:space="preserve">
          <source>OPTIONAL PARAMETERS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">可选子程序/方法超标</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">备选方案和论点</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS包含创建 &lt;code&gt;$z&lt;/code&gt; 对象时可用的任何选项。</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS是下列选项的组合:</target>
        </trans-unit>
        <trans-unit id="443cfbc1735fa88324f99c052a719f69f770de00" translate="yes" xml:space="preserve">
          <source>OP_CLASS</source>
          <target state="translated">OP_CLASS</target>
        </trans-unit>
        <trans-unit id="257329c9527baa8930f69f20f88bd1b9492d9148" translate="yes" xml:space="preserve">
          <source>OP_DESC</source>
          <target state="translated">OP_DESC</target>
        </trans-unit>
        <trans-unit id="95a97252650f52a0edc590efc17643d272eecd14" translate="yes" xml:space="preserve">
          <source>OP_NAME</source>
          <target state="translated">OP_NAME</target>
        </trans-unit>
        <trans-unit id="664b383a7365636329fa816c917a23ae28c5aba2" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS</source>
          <target state="translated">OP_TYPE_IS</target>
        </trans-unit>
        <trans-unit id="745e8a6c1fc90c064d4d4edecae8bb1c615be59a" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS_OR_WAS</source>
          <target state="translated">OP_TYPE_IS_OR_WAS</target>
        </trans-unit>
        <trans-unit id="bf9f9c661a64325d7940c6088a152e09a3273a85" translate="yes" xml:space="preserve">
          <source>ORDER OF APPLICATION</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686fecd15046059a1461463f65cd5916d98af39b" translate="yes" xml:space="preserve">
          <source>ORIGMARK</source>
          <target state="translated">ORIGMARK</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">根据RFC3461,ORcpt也是SMTP DSN扩展的一部分。它是用来传递邮件第一次发送的原始收件人。生成DSN的机器会用这个地址通知发件人,因为他无法知道收件人是否会被邮件服务器重写。它的格式应该是RFC3461所要求的,xtext-encoded。</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">操作系统问题</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">操作系统调整了ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">操作系统级</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">与操作系统相关的参考资料</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="9b1d79b903ce0b8766b4e5764e59485f0c5a70da" translate="yes" xml:space="preserve">
          <source>OS/2 .INF file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS/2 _.INF_文件</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS/2是OS/2</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">OS/2工具箱</target>
        </trans-unit>
        <trans-unit id="fd3c79c993342fdc4845e0000fd358e72448a4b9" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390将支持 &lt;code&gt;#!&lt;/code&gt; shebang 2.8和更高版本中的技巧。对 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和反引号的调用可以在所有S / 390系统上使用POSIX Shell语法。</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS/390,z/OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="ce46010d8cbef8c9b0bbd999f8b39bd331eb9402" translate="yes" xml:space="preserve">
          <source>OS2::BootDrive()</source>
          <target state="translated">OS2::BootDrive()</target>
        </trans-unit>
        <trans-unit id="6b75ff49b64b08a5cbda19098841eaa70af4d838" translate="yes" xml:space="preserve">
          <source>OS2::SysInfo()</source>
          <target state="translated">OS2::SysInfo()</target>
        </trans-unit>
        <trans-unit id="aca5fea461e6f13c528c2c4f05a7be94b7faae70" translate="yes" xml:space="preserve">
          <source>OS2::get_control87()</source>
          <target state="translated">OS2::get_control87()</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="cb338bafdad45c9e72ba4f2b86d7dc19e8efe3a0" translate="yes" xml:space="preserve">
          <source>OTHER API EXPORTS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea1e1d8de28e316e4bbdddc4c0f8d93bcafa453" translate="yes" xml:space="preserve">
          <source>OTHER API FUNCTIONS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">其他组件</target>
        </trans-unit>
        <trans-unit id="f4819c79c3cf5d0855c9756e200236cb695ed79b" translate="yes" xml:space="preserve">
          <source>OTHER EXAMPLES</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">其他设施</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">其他功能</target>
        </trans-unit>
        <trans-unit id="c89d68a8b80355c832f177abfb0d1dd9e08c42b5" translate="yes" xml:space="preserve">
          <source>OURSTASH</source>
          <target state="translated">OURSTASH</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">输出提示</target>
        </trans-unit>
        <trans-unit id="cbbef8ce7e5bb98d49b97d0627758196498a036b" translate="yes" xml:space="preserve">
          <source>OUTSIDE</source>
          <target state="translated">OUTSIDE</target>
        </trans-unit>
        <trans-unit id="aed9198315d600f631cbfb4ab62949c42689f27b" translate="yes" xml:space="preserve">
          <source>OUTSIDE_SEQ</source>
          <target state="translated">OUTSIDE_SEQ</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">逾越式方法</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">凌驾于核心功能之上的功能</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">课程概述</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">对象方法</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">对象导向并不是每个问题的最佳解决方案。在</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">面向对象的编码器</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">面向对象的时间对象</target>
        </trans-unit>
        <trans-unit id="8a9d1904669ae5189957085d3ad744889ffa188e" translate="yes" xml:space="preserve">
          <source>Object Oriented/Tied Handle Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1a2199d628852802c93c71acfcb62c9006d4a9" translate="yes" xml:space="preserve">
          <source>Object interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">AF_INET域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">AF_UNIX域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">套接字通信的对象接口</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">系统轮询调用的对象接口</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">对象接口:</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">面向对象的接口</target>
        </trans-unit>
        <trans-unit id="26b3504ec46d1edff4f4783df6ad8b24180e673c" translate="yes" xml:space="preserve">
          <source>Object property methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">对象注册最好是在初始化对象时进行,以便与一个类一起使用。这样一来,每一个对象和每一个被初始化的字段都建立了垃圾回收和线程安全。</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">对象状态(即对象被祝福成的类)也被克隆。</target>
        </trans-unit>
        <trans-unit id="fe8c7731a828adbc9c6710de9659455410072a19" translate="yes" xml:space="preserve">
          <source>Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef528339319411e5d4f89f3a15d4db11ad2cbd90" translate="yes" xml:space="preserve">
          <source>Object to represent a testing context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fbf11227dc99e33421481b03ca2f68bc9536a37" translate="yes" xml:space="preserve">
          <source>Object used by Test2::API under the hood</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">对象有福,变量无福</target>
        </trans-unit>
        <trans-unit id="5bca7499b54d7016ce15937bcabd8353b693c22e" translate="yes" xml:space="preserve">
          <source>Objects based on the above</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">代表POD输入段落、命令等的对象。</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">Obscure-设置缓冲区的字节数。已经废弃。只有当PerlIO_canset_cnt()返回true时才可以使用。目前只在doio.c中使用,强制将小于-1的字节数改为-1。也许应该是PerlIO_set_empty或类似的函数。如果 &quot;count &quot;是由指针和 &quot;limit &quot;推导出来的,那么这个调用实际上可能什么都不做,不要使用这个--使用PerlIO_set_empty或类似的函数。不要使用这个-使用 PerlIO_set_ptrcnt()。</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">过时的向后兼容功能</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">过时的、废弃的方法。自5.21版起不再使用。</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">过时。所有之前与之匹配的代码点都已移至 &quot;Script=Common&quot;。可以考虑使用 &quot;Script_Extensions=片假名 &quot;或 &quot;Script_Extensions=平假名&quot;(或两者)。</target>
        </trans-unit>
        <trans-unit id="a9002afd81f2bf4ce6e9b9a4e6ca0a84152afb47" translate="yes" xml:space="preserve">
          <source>Obsoleted as of Unicode 9.0, but previously provided a visual display of the standard variant sequences derived from</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">获取服务器的响应。成功时,返回状态码的最重要数字。如果失败,超时等。</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">获取所有活跃的新闻组的信息,结果是对哈希的引用,其中键是组名,每个值是对数组的引用。结果是一个哈希引用,其中键是组名,每个值是一个数组的引用。这个数组中的元素是:-该组中最后的文章编号,该组中的第一个文章编号和该组的任何信息标志。</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">获取 &lt;code&gt;stdin&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="7789255329d3ffd1b99a0a2cd58f6fb55a93559e" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">获取stdout的属性。</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">获取所有指定消息的标题字段 &lt;code&gt;HEADER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">获得时间上 &lt;code&gt;HOST&lt;/code&gt; ，或一些默认主机如果 &lt;code&gt;HOST&lt;/code&gt; 如在RFC867中定义未给出或没有定义，使用的协议。可选参数 &lt;code&gt;PROTOCOL&lt;/code&gt; 应该定义要使用的协议 &lt;code&gt;tcp&lt;/code&gt; 或 &lt;code&gt;udp&lt;/code&gt; 。结果将是ASCII字符串或</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">使用RFC868中定义的协议，在 &lt;code&gt;HOST&lt;/code&gt; 上获取时间，或者在未指定或未定义 &lt;code&gt;HOST&lt;/code&gt; 的情况下获取一些默认主机上的时间。可选参数 &lt;code&gt;PROTOCOL&lt;/code&gt; 应该定义要使用的协议 &lt;code&gt;tcp&lt;/code&gt; 或 &lt;code&gt;udp&lt;/code&gt; 。结果将是与time（）返回的单位相同的时间值，或者</target>
        </trans-unit>
        <trans-unit id="795eb623dba4761a659c021e4b42f3958e340aa1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be an ASCII string or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74c2d6b8c1d1a064d7e0d2a2f0c8de41a911ec1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be a time value in the same units as returned by time() or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66bf08929fd5d420bb4c2ec86a67bddae583922" translate="yes" xml:space="preserve">
          <source>Obtaining and installing libnet</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">显然，由于所有这些编码字符集下的 &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; ，这些方法中的第一个将无法将大多数ASCII平台与CCSID 0037、1047或POSIX-BC EBCDIC平台区分开。但也请注意，因为在旧版Macintosh（这是ASCII平台）上， &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; ,而 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; ，第二个 &lt;code&gt;$is_ascii&lt;/code&gt; 测试将在此处造成麻烦。</target>
        </trans-unit>
        <trans-unit id="1d78b76872c5b56931c9b5c0301dbd8a6a7bb448" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; eq chr(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;chr(13)&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;chr(10)&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">显然,这是以可以将指针类型化为无符号长指针为前提的,反之亦然,这经常有效,但不应被视为普遍规律。-现在我们有了这个指针,下一个问题是:我们如何才能把它用好呢?我们需要对某个C函数进行调用,在那里我们需要一个指针。我想到了read(2)系统调用。</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">显然,包含补丁的bug是最好的。如果你喜欢,你可以通过匿名签到最新版本的方式打补丁防出血。</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">显然,在OS/2 API签名的最后一种类型的情况下,如果用die()ing来表示失败,对用户来说肯定是更方便的:人们不需要检查$^E就知道出了问题。但是,如果由于某种原因,这种解决方案不可取,那么在调用这个OS/2 API之前,相关代码应该将$^E重置为0,这样这个Perl可访问函数的调用者就有机会区分成功但0-返回值和失败。(可以返回 undef 作为报告错误的另一种方式。)</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">显然，对 &lt;code&gt;complicated&lt;/code&gt; 的第二次调用是在浪费时间，而存储其返回值则是在浪费空间。指定 &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; 将使 &lt;code&gt;memoize&lt;/code&gt; 的使用标量和列表上下文返回值相同的高速缓存，从而使第二调用使用由第一次调用填充标缓存。 &lt;code&gt;complicated&lt;/code&gt; 最终仅被调用一次，并且随后的两个调用都从缓存中返回 &lt;code&gt;3&lt;/code&gt; ，而与调用上下文无关。</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">偶尔需要将被绑定的对象的引用传递给绑定它的TIESCALAR、TIEHASH等。</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">有时，程序员会希望仅在函数失败而不是单独的状态值的情况下返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或空列表。rpcb_gettime（）函数提供了这种情况。如果函数成功，我们希望它返回时间，如果函数失败，我们希望返回undef。在下面的Perl代码中，$ timep的值将为undef或为有效时间。</target>
        </trans-unit>
        <trans-unit id="0ea7d0ab3870cda5bd5d012242ed94c158dde1fa" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;undef&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">有时，Attribute :: Handlers会费力地将数据参数（ &lt;code&gt;$_[4]&lt;/code&gt; ）转换为可用形式，然后再将其传递给处理程序。</target>
        </trans-unit>
        <trans-unit id="f13c9786193661170bf181a99c76dd0d6705b9c3" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler get in the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">有时，您不能仅使用 &lt;code&gt;/g&lt;/code&gt; 来使您可能想要的所有更改发生。这是两种常见情况：</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">八角形泄漏</target>
        </trans-unit>
        <trans-unit id="db84424f081d663bc203c1af1117e2bdc42e8773" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">在括号字符类之外的 &lt;code&gt;\000&lt;/code&gt; 格式的八进制转义符可能与旧的后向引用冲突（请参阅下面的&lt;a href=&quot;#Absolute-referencing&quot;&gt;绝对引用&lt;/a&gt;）。它们都由反斜杠和数字组成。因此，Perl必须使用启发式方法来确定它是反向引用还是八进制转义。Perl使用以下规则来消除歧义：</target>
        </trans-unit>
        <trans-unit id="87a50fff0e8349cdbe12625e1077c3ebe0fdfa7d" translate="yes" xml:space="preserve">
          <source>Octal number &amp;gt; 037777777777 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb34d0b5eb49bdff2904bd7acc2fa7d27c59806" translate="yes" xml:space="preserve">
          <source>Octal numbers are typically prefixed by &quot;0&quot;, but since leading zeros are stripped, these methods can not automatically recognize octal numbers, so use the constructor from_oct() to interpret octal strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8af566741591251972e43e0d36356b0e06a29bb7" translate="yes" xml:space="preserve">
          <source>Odd name/value argument for subroutine '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bda02e37792920d152c41b584876b2e10eb3c5" translate="yes" xml:space="preserve">
          <source>Odd number of arguments for overload::constant</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399492c4df4e28b7b58d749dc69161eed60f95f9" translate="yes" xml:space="preserve">
          <source>Odd number of elements in anonymous hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065c34a675ace7837e8fdf7122c9899906bd6b6e" translate="yes" xml:space="preserve">
          <source>Odd number of elements in hash assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8cc17f1e22c5e8c8c6d8e8b50d3e2d9acf218c8" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;cgi&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">当然，&lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt;和&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;会告诉您更多信息。</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">当然， &lt;code&gt;Moose&lt;/code&gt; 不是完美的。</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">当然， &lt;code&gt;vianame&lt;/code&gt; ， &lt;code&gt;viacode&lt;/code&gt; 和 &lt;code&gt;string_vianame&lt;/code&gt; 也将被覆盖。</target>
        </trans-unit>
        <trans-unit id="e69acfd1f99778b500da1a17ef29d78b995fb659" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt;, &lt;code&gt;viacode&lt;/code&gt;, and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">当然，在这里，Filter :: Simple在应用过滤器之前也必须知道您正在使用Exporter。几乎从来没有问题，但是如果您对此感到不安，可以通过确保 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; 始终位于 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 之前，确保一切正常。</target>
        </trans-unit>
        <trans-unit id="4302a9cf5fbe5aa02395c1781d6a9233de7d01db" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;use base Exporter&lt;/code&gt; always precedes your &lt;code&gt;use Filter::Simple&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">当然，如果 &lt;code&gt;@ISA&lt;/code&gt; 仅包含 &lt;code&gt;DynaLoader&lt;/code&gt; ，则根本不需要 &lt;code&gt;@ISA&lt;/code&gt; 分配；此外，如果不是 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 使用更向后兼容</target>
        </trans-unit>
        <trans-unit id="1eafec21d0ff2371b83827a03c0ee4872c0478b3" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt;, there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;our&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">当然,如果类名用的是标量,Perl也会做对。</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">当然，如果仅遵循&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;的准则，就不需要重新格式化。在编写代码时格式化代码的习惯将有助于防止错误。您的编辑可以并且应该帮助您。 emacs的perl模式或更新的cperl模式可以为大多数（但不是全部）代码提供大量帮助，甚至更少的可编程编辑器也可以提供大量帮助。 Tom Christiansen和许多其他VI用户发誓在vi及其克隆中采用以下设置：</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">当然，在诸如 &lt;code&gt;$obj + 1&lt;/code&gt; 类的上下文中，Perl将调用 &lt;code&gt;$obj&lt;/code&gt; 的 &lt;code&gt;+&lt;/code&gt; 实现，而不是（在此示例中）使用numify方法 &lt;code&gt;'0+'&lt;/code&gt; 将 &lt;code&gt;$obj&lt;/code&gt; 转换为数字（这是因为没有为 &lt;code&gt;'+'&lt;/code&gt; 提供任何方法，并且&lt;a href=&quot;#fallback&quot;&gt;后备&lt;/a&gt;时间设置为TRUE）。</target>
        </trans-unit>
        <trans-unit id="e64305345caaad0c4dd212ba7ea682cb2c014fca" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt;, Perl will invoke &lt;code&gt;$obj&lt;/code&gt;'s implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt; is set to TRUE).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">当然，在使用文字字符串的情况下，可以像使用字符串比较 &lt;code&gt;$string eq 'bert'&lt;/code&gt; 一样容易，这样会更高效。当我们在下面添加功能更强大的regexp工具时， &lt;code&gt;^...$&lt;/code&gt; regexp确实变得很有用。</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">当然，按照这个模块作者的愚见，我更倾向于使用现有的&lt;b&gt;Pod :: ParseTree&lt;/b&gt;对象，而不是简单的数组。这样，其中的所有内容（段落和序列）都将对所有解析树节点响应相同的核心接口。结果如下所示：</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">当然,根据不同的目的选择合适的分隔符串很重要。</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">当然,是否无视它们,由你来决定。</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">当然,我们可以直接用C语言写这种胶水代码,但是,这将是一项繁琐的工作,尤其是当我们需要为多个C函数写胶水,和/或对Perl堆栈纪律和其他类似的奥义不够熟悉的时候。XS在这里救了我们一命:与其用长手写这种胶水C代码,不如用更简洁的短手写一个</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">当然,测试1是$tests[0],等等。</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">当然,节省内存的最好方法是一开始就不做任何浪费内存的事情。良好的编程实践可以在很大程度上实现这一目标。</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">当然,这</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">当然,这需要底层调用支持缓冲器。参见上面关于缓冲区的说明。</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">当然,无论谁问你密码,你都要输入自己的密码,这是不明智的。</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">当然，除非您知道XSUB内某类型 &lt;code&gt;sometype **&lt;/code&gt; C数组中的元素数量，否则将难以解读 &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; 的返回值。由于所有细节都由XS作者（类型映射用户）决定，因此有几种解决方案，其中没有一种特别出色。最常见的解决方案是为N + 1个指针分配内存，并向第（N + 1）个分配 &lt;code&gt;NULL&lt;/code&gt; 以促进迭代。</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">当然，除非您的操作系统未实现access（），否则在这种情况下，编译指示将被忽略。最好不要在filetest编译指示处于活动状态的文件中使用 &lt;code&gt;_&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="abd96d1d300bf4e8daac5b50f895feff0cad5891" translate="yes" xml:space="preserve">
          <source>Of course, variables that are UTF-8 and are referred to in the string retain that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5481b8a258de1ea18c7a9b1b7f4086fab8bc96" translate="yes" xml:space="preserve">
          <source>Of course, you can also choose to import specific functions by name, as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">当然,你根本不需要临时数组有名字。</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">在转换中,只需要字符串、布尔值或数字中的一个,因为每一个都可以从其他两个中的任何一个生成。</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">在这些属性中,两个重要的属性是 Pattern_Syntax 和 Pattern_White_Space。它们被Unicode设置的目的正是为了决定正则表达式模式中哪些字符应该被引用。任何可以在标识符中的字符都没有这些属性。</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">ISO 3166维护机构的官方主页。</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">顶级域名的官方来源。</target>
        </trans-unit>
        <trans-unit id="3c0ccf7d9a2c2c9e1eedbe4cef2e4d0413088708" translate="yes" xml:space="preserve">
          <source>Offline sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b00389e2960ae2ee90ec24a50a5ce42fa29d6d" translate="yes" xml:space="preserve">
          <source>Offset outside string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">偏移量包含 &lt;code&gt;program&lt;/code&gt; 中偏移量到 &lt;code&gt;precomp&lt;/code&gt; 字符串中的偏移量的映射。这仅由ActiveState的可视化正则表达式调试器使用。</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">通常情况下,允许用逗号分隔的值列表以及选项的多次出现是很有用的。使用Perl的split()和join()运算符就可以轻松实现。</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">为选项提供备用的助记符名称通常是用户友好的。例如 &lt;code&gt;--height&lt;/code&gt; 可以是用于替代名称 &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。可选名称中可以包含其他名称，以竖线 &lt;code&gt;|&lt;/code&gt; 分隔。字符。要实现以上示例：</target>
        </trans-unit>
        <trans-unit id="7de86d17804fa632d98b8911860a7e7fb8a9bded" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--length&lt;/code&gt;. Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">通常，还会有另一条与语法错误相关的错误消息给出更多信息。（有时，打开&lt;b&gt;-w会&lt;/b&gt;有所帮助。）错误消息本身通常会告诉您在决定放弃时它在行中的位置。有时实际错误是在此之前的几个标记，因为Perl善于理解随机输入。有时行号可能会引起误解，并且一旦出现蓝月亮，找出导致错误的原因的唯一方法就是反复调用 &lt;code&gt;perl -c&lt;/code&gt; ，每次都切掉一半的程序以查看错误是否消失。是20个问题的控制论版本。</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">通常你想在主模块发行版中手动设置$VERSION,因为这是大家在CPAN上看到的版本,也许你想自定义一下。但是对于你的发行版中的其他模块来说,$VERSION其实只是一个记账的工具,重要的是每次模块被修改时它都会上升。手工做这个很麻烦,你经常会忘记。</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">哦,嗯。这不完全工作。让我们来看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">哦，最后一点建议：与您一起喝&lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;。当您返回时，我们希望它会被精心设计。</target>
        </trans-unit>
        <trans-unit id="6e84377d7eb2428d1c7c2ce684cd3d38c4564c15" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="306452191398ef5d817db7561b984ed6863ccdd5" translate="yes" xml:space="preserve">
          <source>Ok event type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f40dabdf47b8a6942bfc67e5bc1a841348e34c6a" translate="yes" xml:space="preserve">
          <source>Ok events are generated whenever you run a test that produces a result. Examples are &lt;code&gt;ok()&lt;/code&gt;, and &lt;code&gt;is()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">好吧,但是当你想真正看到你的数据时,在使用之前,那个动态变量里有什么呢?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">好吧,所以这不是很有趣,因为它没有找到那个特定的文件。但长篇大论的回答在这一页上是不合适的。</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">好的，因此可以有多个Test :: Builder对象，这就是您获取它的方式。如果要测试基于Test :: Builder的模块，则可以使用它代替 &lt;code&gt;new()&lt;/code&gt; ，但是否则您可能需要 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaf90bfe09c59916d02cd27cf9c5113342a8704b" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a981471d54adab918cf9e98c713f3fa8b6a31b7" translate="yes" xml:space="preserve">
          <source>Okay, concision isn't a buzzword. But it should be, so I decree that as a new buzzword, &quot;concision&quot; means that simple common things should be expressible in very few lines (or maybe even just a few characters) of code -- call it a special case of &quot;making simple things easy and hard things possible&quot;, and see also the role it played in the MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">好吧,如果你坚持:&quot;内部格式 &quot;是utf8,不是UTF-8。当它不是其他编码时)。</target>
        </trans-unit>
        <trans-unit id="c04bc9d828571306fd8ab607e050385638b7b499" translate="yes" xml:space="preserve">
          <source>Olaf Alders &amp;lt;olaf@wundersolutions.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">面向字节的旧程序应该在适当的时候神奇地开始在面向字符的新数据上工作。</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">旧的面向字节的程序不应该自发地破坏他们过去工作的旧的面向字节的数据。</target>
        </trans-unit>
        <trans-unit id="cdcb679c21ad16ffb1a74358af64068b9c8c43d4" translate="yes" xml:space="preserve">
          <source>Old package separator used in string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">旧的perl可执行文件是在新的可执行文件运行时加载了为旧的可执行文件编译的扩展时被启动的(ouph!).在这种情况下,旧的可执行文件会得到一个转发器DLL而不是旧的perl DLL,所以会与新的perl DLL链接。在这种情况下,旧的可执行文件会得到一个转发器 DLL,而不是旧的 perl DLL,所以会与新的 perl DLL 链接。虽然不是直接致命的,但它会和新的可执行文件表现一样。这比显式启动一个旧的可执行文件的目的要好得多。</target>
        </trans-unit>
        <trans-unit id="fc1b9547dcacdd8deb0b3a992300248da0a808c5" translate="yes" xml:space="preserve">
          <source>Old versions need to directly access Test::Builder singleton hash elements. The latest version on CPAN will still do this on old Test::Builder, but will defer to &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt; on Test2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e1c2932ecab8fa2b7abd4c5ef42f132f0546a7" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but have a minor test name behavior that breaks with Test2. Old versions will no longer install because of this. The latest version on CPAN will install just fine. Upgrading is not required, but is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686b6b48ccfd93fda8d202b7ab00cb50bff77185" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but would not install because &lt;a href=&quot;Test::Aggregate&quot;&gt;Test::Aggregate&lt;/a&gt; was in the dependency chain. An upgrade should not be needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">旧式与新式区块名称</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">旧的文档(和一些CPAN模块)鼓励这种语法,特别是对于构造函数,所以你可能仍然会在野外找到它。然而,我们鼓励你避免在新代码中使用它。</target>
        </trans-unit>
        <trans-unit id="74bfa7b0d7fbfaf100a04613f263acdd445ac2c9" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing  (space) or any character from the set &lt;code&gt;!#%&amp;amp;'()*;&amp;lt;=&amp;gt;?&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">VOS的较早版本（OpenVOS 17.0之前的版本）将文件名限制为32个或更少的字符，禁止文件名以 &lt;code&gt;-&lt;/code&gt; 字符开头，并且禁止文件名包含任何与 &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; 匹配的字符。 &amp;lt;=&amp;gt;？//。</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">较早的翻译人员可能会在L &amp;lt;&amp;gt;链接周围添加措辞，例如， &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 可能会成为&amp;ldquo; Foo :: Bar联机帮助页&amp;rdquo;。因此，如果您希望翻译后的文档明智地阅读，则不应编写 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; 类的东西。而是编写 &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 来控制链接的输出方式。</target>
        </trans-unit>
        <trans-unit id="14a3863272e849d79d3bd80306df053765edc2b6" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt;, to control how the link comes out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">旧版本的CPAN.pm在构建目录下有所有tarballs的原始根目录。现在,这些目录名后面总是附加一些随机字符。为什么要这样做呢?</target>
        </trans-unit>
        <trans-unit id="0de4f0e8390c99f19bd133eee1f9e0b1e299d545" translate="yes" xml:space="preserve">
          <source>Older versions of perl may have security vulnerabilities, some of which are serious (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; and search &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=Perl&quot;&gt;CVEs&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">在这种情况下，本文档的旧版本建议使用 &lt;code&gt;void&lt;/code&gt; 返回值。已经发现，如果XSUB是，则可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="c1039769adff260cb2734954cd648c56f4365afe" translate="yes" xml:space="preserve">
          <source>Olivier Mengu&amp;eacute; &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">Olivier Mengue</target>
        </trans-unit>
        <trans-unit id="0aa942a536d7cded5f6fc6f8772142dfcfdb221f" translate="yes" xml:space="preserve">
          <source>Olivier Mengue &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">忽略.xs文件中的 &lt;code&gt;constant()&lt;/code&gt; 以及.pm文件中的相应专用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">省略所有自动加载功能。这与&lt;b&gt;-c&lt;/b&gt;相同，但也会从.pm文件中删除 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="0e2601b286234df74dc051d8e9fbf4262affc4dd" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;use AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">只要不影响清晰度,就可以省略多余的标点符号。</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">省略XS部分。用于生成框架纯Perl模块。 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-f&lt;/code&gt; 隐式启用。</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">省略自动生成的存根POD部分。</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">省略了创建</target>
        </trans-unit>
        <trans-unit id="3b6794df4ab49e575f0969623fbbb9b4eead1f5f" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; section is equivalent to using an empty one, logically enough, so &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">从逻辑上讲，省略 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 部分等效于使用一个空的部分，因此 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 直接返回以检查循环顶部的条件。</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">从逻辑上讲，省略 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 部分等效于使用一个空的部分，因此 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 直接返回以检查循环顶部的条件。</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">省略第一个参数（输入文本）意味着改为处理 &lt;code&gt;$_&lt;/code&gt; 。省略第二个参数（定括号）表示仅使用 &lt;code&gt;'{'&lt;/code&gt; 。省略第三个参数（前缀参数）在开始时意味着可选的空格。省略第四个参数（最外面的定界括号）表示第二个参数的值将用于最外面的定界符。</target>
        </trans-unit>
        <trans-unit id="650eb97953ce5c6e07ebcb4164c35bedbbc7ac72" translate="yes" xml:space="preserve">
          <source>On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX) limit. On 32bit systems also strings between I32 and U32 (2G-4G). Since Storable 3.00 (not in perl5 core) we are able to store and retrieve these objects, even if perl5 itself is not able to handle them. These are strings longer then 4G, arrays with more then 2G elements and hashes with more then 2G elements. cperl forbids hashes with more than 2G elements, but this fail in cperl then. perl5 itself at least until 5.26 allows it, but cannot iterate over them. Note that creating those objects might cause out of memory exceptions by the operating system before perl has a chance to abort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">在AIX 4.2上使用xlC,我们继续。</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">在AIX 4.3上使用vac,我们继续。</target>
        </trans-unit>
        <trans-unit id="eeac3c2c2feb8a620697ff4a8d972aa2a092d986" translate="yes" xml:space="preserve">
          <source>On AIX, is &lt;code&gt;.exp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f8078cc0b8af6aad63b15eccc9063b75b69a03" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">在ASCII平台上，上面列出的结果字符是ASCII控件的完整集合。在EBCDIC平台上并非如此。有关ASCII与EBCDIC平台之间差异的完整讨论，请参见&lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic&lt;/a&gt;中的&amp;ldquo; 运算符差异&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">在ASCII编码的平台上,可以使用以下方法将字符从可打印集之外剥离。</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">在类似DOS的平台上,如果程序不包含目录分隔符,则会先在当前目录中搜索,然后再在PATH上搜索。在Unix平台上,程序将严格在PATH上搜索。</target>
        </trans-unit>
        <trans-unit id="2f93d8018989db4b239468fb46d0cdba5c2f0db5" translate="yes" xml:space="preserve">
          <source>On DOS/Windows like architectures where this layer is part of the defaults, it also acts like the &lt;code&gt;:perlio&lt;/code&gt; layer, and removing the CRLF translation (such as with &lt;code&gt;:raw&lt;/code&gt;) will only unset the CRLF translation flag. Since Perl 5.14, you can also apply another &lt;code&gt;:crlf&lt;/code&gt; layer later, such as when the CRLF translation must occur after an encoding layer. On other architectures, it is a mundane CRLF translation layer and can be added and removed normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">在DOSISH系统中,反斜线是一个有效的目录分隔符。在这种情况下,使用反斜线作为引号字符(通过GLOB_QUOTE)会干扰反斜线作为目录分隔符的使用。最好的(最简单、最可移植的)解决方案是使用正斜线作为目录分隔符,而使用反斜线作为引号。然而,这并不符合这些系统的 &quot;常规做法&quot;。因此,作为对用户期望的一种让步,反斜线(在 GLOB_QUOTE 下)只引用 glob 元字符 '[',']','{','}','-','~'和反斜线本身。所有其他的反斜杠都会被原封不动地通过。</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">在EBCDIC平台上,Latin 1字符集中的字符被视为UTF-EBCDIC字符的一部分。</target>
        </trans-unit>
        <trans-unit id="e55bcfcaea4d3f5091519d63553b94250f256406" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower than on ASCII. Prior to that, code points 2**31 and higher were simply unrepresentable, and a different, incompatible method was used to represent code points between 2**30 and 2**31 - 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6112256ee63f46a5e15ec3716f73262824a70fb0" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, code points above 0x3FFF_FFFF have a different representation in Perl v5.24 than before, so any file containing these that was written before that version will require conversion before being readable by a later Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">在v5.22之前的EBCDIC平台上，使用 &lt;code&gt;\N{U+...}&lt;/code&gt; 无法正常工作。</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">在EBCDIC平台上，内部Unicode编码形式为UTF-EBCDIC而不是UTF-8。区别在于，由于UTF-8是&amp;ldquo; ASCII安全的&amp;rdquo;，因为ASCII字符按原样编码为UTF-8，而UTF-EBCDIC是&amp;ldquo; EBCDIC安全的&amp;rdquo;，因为所有基本字符（包括所有那些具有ASCII等效项（例如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; ， &lt;code&gt;&quot;0&quot;&lt;/code&gt; ， &lt;code&gt;&quot;%&quot;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="69ff29e47116562e384d48eb5aae2111322261e8" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">在perl v5.14.0及更高版本的Linux上，除了自arg.4.000起perl所做的那样，除了通过 &lt;code&gt;argv[0]&lt;/code&gt; 更改POSIX名称外，还将使用 &lt;code&gt;prctl(2)&lt;/code&gt; 设置旧进程名称。现在，读取遗留进程名称（例如ps，top和killall）的系统实用程序将在分配给 &lt;code&gt;$0&lt;/code&gt; 时识别您设置的名称。您提供的字符串将被截断为16个字节，这是Linux施加的限制。</target>
        </trans-unit>
        <trans-unit id="971443928989b7bee0ac0a568694348131be6843" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt;, in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt;. The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">在MSWin32上,每个线程都维护自己的环境变量集。</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">在MSWin32上,每个线程都维护自己的当前工作目录设置。</target>
        </trans-unit>
        <trans-unit id="23b53b159dd238a66ca7c109ea8e5776a37bac8e" translate="yes" xml:space="preserve">
          <source>On Mac OS X the file system encoding is always UTF-8 while the locale can otherwise be set up as normal for POSIX systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">在Mac OS上,假设路径的最后一部分是文件名,除非$no_file为真或存在尾部分隔符&quot;:&quot;。</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">在Mac OS上,没有什么可做的。返回它所给的东西。</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">在OS/390或z/OS上,请参见以下内容</target>
        </trans-unit>
        <trans-unit id="5637d80de5f3ae2f3a457607d81fcd5653f85175" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the &lt;a href=&quot;http://man.he.net/man1/iconv&quot;&gt;iconv(1)&lt;/a&gt; manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">在关闭临时文件时会自动删除临时文件的操作系统上,调用此函数除了删除临时目录(可能包括临时文件)外,没有其他效果。</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">在PA-RISC上,你需要一个不同的编译器来处理32位应用和64位应用。在PA-RISC上,32位对象和64位对象不能混用。句号。HP C-ANSI-C或GNU gcc没有不同的行为。所以,如果你需要你的perl二进制文件使用64位库,比如Oracle-64bit,你必须构建一个64位的perl。</target>
        </trans-unit>
        <trans-unit id="a9150346abbcb79f7b8cfc1b292f802424998448" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;&quot;MAKE&quot;&lt;/a&gt; parameter for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">在POSIX系统上，该程序可能是GNU Make。在Microsoft Windows上，它将是Microsoft NMake，DMake或GNU Make。有关详细信息，请参见&lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt;参数部分。</target>
        </trans-unit>
        <trans-unit id="167592a5236c1f91d56ed9f91f8821eeb4df3832" translate="yes" xml:space="preserve">
          <source>On Perl 5.10 and above, using smart-match (&lt;code&gt;~~&lt;/code&gt;) with an &lt;code&gt;autodie::exception&lt;/code&gt; object will use &lt;code&gt;matches&lt;/code&gt; underneath. This module used to recommend using smart-match with the exception object on the left hand side, but in future Perls that is likely to stop working. The smart-match facility of this class should only be used with the exception object on the right hand side. Having the exception object on the right is both future-proof and portable to older Perls, back to 5.10. Beware that this facility can only be relied upon when it is certain that the exception object actually is an &lt;code&gt;autodie::exception&lt;/code&gt; object; it is no more capable than an explicit call to the &lt;code&gt;matches&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">在 5.7 之前的 Perl 版本中,值超过 255 的 Unicode 字符(如 lambda 或 emdash)无法传达。这个模块在这样的早期 Perl 版本下确实可以工作,但是在每个这样的字符的位置上,你会得到一个&quot;?&quot;。Latin-1 字符(字符 160-255)不受影响。</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">在路上</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">在Unix上,这些调用可能没有任何影响。在其他地方,它们会改变&quot;\n &quot;到CR,LF的翻译,并可能导致一个特殊的文本 &quot;文件结束 &quot;指示器被写入或在读取时兑现。在对句柄进行任何IO后进行调用的效果取决于实现。(它可能被忽略,也可能影响任何已经被缓冲的数据,或者只适用于后续数据。)</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">在Unix上。</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">在VMS上,默认情况下,%ENV哈希值的变化在perl退出后会持续存在。随后在同一进程中调用perl时,可能会无意中继承本应是临时的环境设置。</target>
        </trans-unit>
        <trans-unit id="7a7f6210c11a8722ba30917e3753a6ae39f636f9" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">仅在VMS上,记录读取会绕过PerlIO层和任何相关的缓冲,所以不能在同一个文件柄上混合记录和非记录读取。只有当两种模式使用相同的缓冲层时,记录模式才会与行模式混合。</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">在VMS系统中,与环境变量绑定的数组是只读的。试图改变任何东西都会引起警告。</target>
        </trans-unit>
        <trans-unit id="74564fe6ae7ff11070f358853ddf9ff8e6cf5db3" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;a href=&quot;perlfunc#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">在VMS上，perl从 &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 逻辑名称确定UTC偏移量。虽然VMS时代开始在11月17日- 1858年00：00：00.00，将呼叫 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 被调整得从01-JAN-00 1970年数补偿：00：00.00，就像Unix的。</target>
        </trans-unit>
        <trans-unit id="06a156290eaf8bb336152c15b3a6a3f335cfb709" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt;, &lt;code&gt;$ENV{TERM}&lt;/code&gt;, &lt;code&gt;$ENV{PATH}&lt;/code&gt;, and &lt;code&gt;$ENV{USER}&lt;/code&gt;, are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">在VMS上， &lt;code&gt;%ENV&lt;/code&gt; 哈希中的某些条目（如果以前不存在）在读取时使用它们的键来动态创建。已知 &lt;code&gt;$ENV{HOME}&lt;/code&gt; ， &lt;code&gt;$ENV{TERM}&lt;/code&gt; ， &lt;code&gt;$ENV{PATH}&lt;/code&gt; 和 &lt;code&gt;$ENV{USER}&lt;/code&gt; 是动态生成的。动态生成的特定名称可能会随VMS上C库的版本而变化，并且可能存在的名称比记录的名称更多。</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">在有卷概念的VMS上,这个字段将是空的,因为VMS文件规格被转换为绝对的UNIX格式,卷信息被透明地包含在内。</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">在VOS上,时间值是32位的量。</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">在Win32上， &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 需要打开文件以确定链接计数并更新可能已通过硬链接更改的属性。将 &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; 设置为真实值可通过不执行此操作来加快 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 的速度。（Win32的）</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">在Win32平台上,这</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">仅在Win32端口上，可以设置为Perl必须在内部用于执行&amp;ldquo;反引号&amp;rdquo;命令或system（）的备用Shell。在WindowsNT上默认为 &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; ，在Windows95 上默认为 &lt;code&gt;command.com /c&lt;/code&gt; 。该值被视为以空格分隔。在需要保护的任何字符（例如空格或反斜杠）之前都应加上另一个反斜杠。</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">在Win32上，此版本（5.14）中的默认值为&amp;ldquo; unix crlf&amp;rdquo;。Win32的&amp;ldquo; stdio&amp;rdquo;具有许多针对Perl IO的错误/错误功能，这在一定程度上取决于C编译器的版本和供应商。使用我们自己的 &lt;code&gt;crlf&lt;/code&gt; 层作为缓冲区可以避免这些问题，并使事情更加统一。所述 &lt;code&gt;crlf&lt;/code&gt; 层提供CRLF转换以及缓冲。</target>
        </trans-unit>
        <trans-unit id="c5cad1f19297cc76fd2c0f0cbe96d6c8b8641a99" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.30) is &quot;:unix:crlf&quot;. Win32's &quot;:stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;:crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b57948ea68a275535d9745ad7c79b49f92a2345" translate="yes" xml:space="preserve">
          <source>On Win32, is &lt;code&gt;.def&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">在WinNT上， &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 可以更改文件的用户和组ID。在Win9x上， &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 是no-op，尽管由于没有安全模型，所以这是适当的。</target>
        </trans-unit>
        <trans-unit id="67f45342ed2b9a9fadda985a145ee379fe5a5018" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;chown()&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;chown()&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2723b9ca133f3aa539e50122b610714bafdb1670" translate="yes" xml:space="preserve">
          <source>On Windows NT 4 SP6 and later this function returns the following additional values: SPMAJOR, SPMINOR, SUITEMASK, PRODUCTTYPE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a917d2cc116f1698163f4d2d945df6a75555b19b" translate="yes" xml:space="preserve">
          <source>On Windows and DOS, this class will not modify any environment variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">在Windows上,如果URI是指向网络共享,这个值可能是空的,在这种情况下,'share'属性将被定义。此外,使用'|'作为':'的卷规格将在读取时转换为使用':'。</target>
        </trans-unit>
        <trans-unit id="98136ca8ec46fb8ca78cee1f5eedf07f7ec52018" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Errno&lt;/code&gt; also defines and conditionally exports all the Winsock error constants defined in your system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">在Windows上，如果 &lt;code&gt;make_path&lt;/code&gt; 发出此警告，则可能意味着您已超出文件系统的最大路径长度。</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">在Windows上，只有 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 间接对象​​语法才能可靠地避免使用Shell；如果第一个生成失败，则 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 即使具有多个元素，也将退回到Shell。</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">在Windows上，只有 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 间接对象​​语法才能可靠地避免使用Shell；如果第一个生成失败，则 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 即使具有多个元素，也将退回到Shell。</target>
        </trans-unit>
        <trans-unit id="7e1ef63036ab0ac76882604ffa03e365a2cc3538" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;exec LIST&lt;/code&gt;, even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aceed2ebeb2b1d6033e61b3459bb2d4bb7870fd" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">在Windows上，您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;模块。为要影响的输出文件句柄创建对象后，调用 &lt;code&gt;Cls&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">在64位 &lt;code&gt;perl&lt;/code&gt; 上，对于那些真正长期运行的项目，您可以获得更大的日期：</target>
        </trans-unit>
        <trans-unit id="1241860881c4ad85f6cc345b32d854e56c75ec64" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt;, you can get even larger dates for those really long running projects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df92a12e7efed4b5a0ee3432bfa643483f4e66b5" translate="yes" xml:space="preserve">
          <source>On a Perl built without &lt;code&gt;-DDEBUGGING&lt;/code&gt;, or when the &lt;code&gt;-Di&lt;/code&gt; command-line switch is not specified, or under taint, PerlIO_debug() is a no-op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">在类似Unix的系统中,这些文档文件通常也会以manpages的形式出现,以便与</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">在一个二进制字符串上,你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">在新的安装中,它是 &quot;C:\\Windows CE Tools&quot;。在文件管理器中转到 &quot;C:\\Windows CE Tools&quot;,看看你的磁盘上是否存在 &quot;C:\\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot;。如果不存在,则需要将SDKROOT改为 &quot;C:\\Program Files\Windows CE Tools&quot;。</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">与此相关的是，如果您确实使用 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; ，那么您将需要在变量声明中使用 &lt;code&gt;dTARG&lt;/code&gt; ，以便 &lt;code&gt;*PUSH*&lt;/code&gt; 宏可以使用局部变量 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;dTARGET&lt;/code&gt; 和 &lt;code&gt;dXSTARG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75330f133f27aefde9a996a79a95540c06e5ca79" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt;. See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8ad329e5099ea252a3ca17c446006da287d9da" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; verb below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">成功匹配后， &lt;code&gt;$REGERROR&lt;/code&gt; 变量将设置为FALSE，而 &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为最后执行的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 模式的名称。有关更多详细信息，请参见下面的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 动词说明。</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">在一个文本字符串上,你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">在除MSWin32之外的所有平台上，当前工作目录的设置在所有线程之间共享，因此在一个线程中更改它（例如，使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ）将影响应用程序中的所有线程。</target>
        </trans-unit>
        <trans-unit id="ab64dc72a66da50a5cd3f10fe53225e1e0e96f58" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;chdir()&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">在所有已发布的Solaris版本(8、9和10)上,你需要确保安装了以下软件包(此信息摘自Solaris FAQ)。</target>
        </trans-unit>
        <trans-unit id="0adaab19e480042e586e12a800bf5b600ec97adc" translate="yes" xml:space="preserve">
          <source>On an exception during the execution of the request, the &lt;code&gt;status&lt;/code&gt; field will contain 599, and the &lt;code&gt;content&lt;/code&gt; field will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2b4cb070056fb4070c425608e71d9f9a08f8e3" translate="yes" xml:space="preserve">
          <source>On both platforms, ASCII and EBCDIC, &lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt; is set if Perl extended UTF-8 is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">在某些平台上，例如Win32，OS / 2，VMS和AIX，有必要在调用链接器之前执行一些操作。该 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 模块做到这一点，写创作动态扩展的共享库的过程中所使用的连接文件。写入的所有文件的名称将作为列表返回。</target>
        </trans-unit>
        <trans-unit id="68f10a6e0b39851d70a2411f9d6927ec33bc1d28" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different in Windows. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">在某些平台上,例如Windows,并不是所有由stat()返回的字段都可以进行比较。例如,在C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新消息队列时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新的信号量集时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新的共享内存段时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO层和PerlIO::*名称空间根的按需加载器。</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">每行上都有两个执行相同操作的表达式。左侧版本在数组 &lt;code&gt;@a&lt;/code&gt; 上操作。右边的版本在 &lt;code&gt;$aref&lt;/code&gt; 所引用的数组上运行。一旦找到要操作的阵列，两个版本会对阵列执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="8897d9218b422eeafd07a396a29ac11d0861b3d9" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt;. The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt;. Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">入职时</target>
        </trans-unit>
        <trans-unit id="5332f588a30c3ea7aadbd06e40cead0c170fd4cf" translate="yes" xml:space="preserve">
          <source>On entry &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;*len_p&lt;/code&gt; give the string to scan, &lt;code&gt;*flags&lt;/code&gt; gives conversion flags, and &lt;code&gt;result&lt;/code&gt; should be &lt;code&gt;NULL&lt;/code&gt; or a pointer to an NV. The scan stops at the end of the string, or at just before the first invalid character. Unless &lt;code&gt;PERL_SCAN_SILENT_ILLDIGIT&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt;, encountering an invalid character (except NUL) will also trigger a warning. On return &lt;code&gt;*len_p&lt;/code&gt; is set to the length of the scanned string, and &lt;code&gt;*flags&lt;/code&gt; gives output flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567461856d5e115d2b80a7fd737da1ad14817617" translate="yes" xml:space="preserve">
          <source>On entry, &lt;code&gt;pv&lt;/code&gt; points to the beginning of the string; &lt;code&gt;valptr&lt;/code&gt; points to a UV that will receive the converted value, if found; &lt;code&gt;endptr&lt;/code&gt; is either NULL or points to a variable that points to one byte beyond the point in &lt;code&gt;pv&lt;/code&gt; that this routine should examine. If &lt;code&gt;endptr&lt;/code&gt; is NULL, &lt;code&gt;pv&lt;/code&gt; is assumed to be NUL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bacb97a5d2d18dbb756caabc159aefdc9b27f2c" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; behaves just like &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt;: it returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a23d955ecebada1fa25792c21efad58d10123ee" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">出错时， &lt;code&gt;$out&lt;/code&gt; 将是</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">错误时， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的行为与select（2）相同：它返回-1并设置 &lt;code&gt;$!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">出现错误时， &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会告诉您无法删除哪些文件。如果您想知道无法删除的文件，请一次尝试一个：</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">错误时， &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的行为与select（2）相同：它返回-1并设置 &lt;code&gt;$!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">出现错误时， &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会告诉您无法删除哪些文件。如果您想知道无法删除的文件，请一次尝试一个：</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">错误时,它返回一个</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">失败时，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,并且 &lt;code&gt;$@&lt;/code&gt; 将包含失败的原因。</target>
        </trans-unit>
        <trans-unit id="50989ddb0a8dea38dc2bf4fcec10e5e4fe7a2870" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;undef&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">失败时,$decoder现在包含一个错误信息,所以整个事情会如下。</target>
        </trans-unit>
        <trans-unit id="e2a12adff03571a4d3b5aeaef29c5800c5825559" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;fileLastError()&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0d12758631e756bc101c1b7dbd8f7f1bdeb657" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;regLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">失败时，所有这些值（其余文本除外）均为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65448e86201e7fdba6e3baaecf1b7bd6e213136d" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fcaac32326ffae83caa0ffe515456c5f51d0d" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">如果失败，则将 &lt;code&gt;$REGERROR&lt;/code&gt; 变量设置为动词模式的ARG值，如果该动词与匹配失败有关。如果省略了模式的ARG部分，则 &lt;code&gt;$REGERROR&lt;/code&gt; 将设置为最后执行的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 模式的名称，如果没有，则设置为TRUE。同样， &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为FALSE。</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">失败时， &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将返回一个未定义的值，并可能设置 &lt;code&gt;$!&lt;/code&gt; 包含无法绑定文件的原因。</target>
        </trans-unit>
        <trans-unit id="d91548debf2b08e67d7bcf23bbc8c0787287ca77" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;tie&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">在输入时,它将指定字符集和编码中预期的字节转换为Perl字符串数据(Unicode和Perl内部的Unicode编码,UTF-8)。在输出时,它将Perl字符串数据转换为指定的字符集和编码。</target>
        </trans-unit>
        <trans-unit id="bbed2b20ba397a052877c8697b2b911fb1c6434c" translate="yes" xml:space="preserve">
          <source>On merging and rebasing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31535bab82f01485bf978083451a0bfcdeb0cd1c" translate="yes" xml:space="preserve">
          <source>On modern Linux systems these are typically GDBM files, which are not portable across platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">在大多数Unix平台上， &lt;code&gt;CHLD&lt;/code&gt; （有时也称为 &lt;code&gt;CLD&lt;/code&gt; ）信号相对于 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 值具有特殊的行为。设置 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 以 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 时，父进程没有这样的平台上还没有创建僵尸进程的影响 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 在其子进程（即子进程会自动收获）。调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 的使用 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 设置为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 通常返回 &lt;code&gt;-1&lt;/code&gt; 在这样的平台。</target>
        </trans-unit>
        <trans-unit id="42dd9a903659956c4b893b1487852dbdc8ae83fe" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt;) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;wait()&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;wait()&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">在大多数操作系统上,分配给程序的内存永远不能返回给系统。这就是为什么长期运行的程序有时会重新执行自己。一些操作系统(特别是使用mmap(2)来分配大块内存的系统)可以回收不再使用的内存,但是在这样的系统中,perl必须被配置和编译成使用操作系统的malloc,而不是perl的。</target>
        </trans-unit>
        <trans-unit id="5ddf61a72a0a9ae32d8b7111f593a7bce6fa31c0" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;Thread::Queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">在大多数系统上，频繁且连续地创建和销毁线程可能导致Perl解释器的内存占用量不断增加。虽然仅启动线程然后 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 很简单，但对于寿命长的应用程序，最好维护线程池，并使用&lt;a href=&quot;thread/queue&quot;&gt;队列&lt;/a&gt;将其重新用于需要的工作通知线程即将进行的工作。此模块的CPAN分发包含一个简单的示例（</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">在大多数系统中,除非你是超级用户,否则你不允许改变文件的所有权,尽管你应该能够将组改为你的任何一个辅助组。在不安全的系统中,这些限制可能会被放宽,但这不是一个可移植的假设。在POSIX系统上,你可以这样检测这种情况。</target>
        </trans-unit>
        <trans-unit id="55db381aabae41a989aa28b8f5a435f2f353e7d6" translate="yes" xml:space="preserve">
          <source>On multi-threaded builds on systems that do have per-thread locale operations, this function converts the thread it is running in to use the global locale. This is for code that has not yet or cannot be updated to handle multi-threaded locale operation. As long as only a single thread is so-converted, everything works fine, as all the other threads continue to ignore the global one, so only this thread looks at it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">在较新的64位版本的OpenVMS上,进程设置现在可以控制是否需要引用来保留命令行参数的大小写。</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">在较早版本的perl上，已知负epoch（ &lt;code&gt;time_t&lt;/code&gt; ）值在某些系统上不起作用，而负epoch（time_t）值尚未得到POSIX标准的正式支持。这些包括MacOS（pre-OSX）和Win32。</target>
        </trans-unit>
        <trans-unit id="ddfc76c9171838788051ad1318da16d035f5b0fe" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt;) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">在有卷的概念的操作系统上,文件://的第二个元素被认为是文件的卷规格。因此,在Win32上,这个例程返回卷,而在其他操作系统上,它不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">在perl 5.12.0和更新的版本中,完全支持负的epoch值。</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">在低于5.12.0的perl版本中，可以实际处理的日期范围取决于给定平台上 &lt;code&gt;time_t&lt;/code&gt; （通常是带符号整数）的大小。目前，对于大多数系统来说，这是32位，大约范围是1901年12月到2038年1月。</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">在 &lt;code&gt;need_prelink()&lt;/code&gt; 返回true的平台上， &lt;code&gt;prelink()&lt;/code&gt; 将被自动调用。</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">在重要的平台上，请确保在传递给Storable函数的描述符上调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="393fb98f717dd89ac6a03e530e4afbcbe5a39830" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;binmode()&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">在C99之前的编译器上， &lt;code&gt;bool&lt;/code&gt; 定义为等效于 &lt;code&gt;char&lt;/code&gt; 。因此，将任何较大的类型分配给 &lt;code&gt;bool&lt;/code&gt; 都是不安全的，并且可能会被截断。该 &lt;code&gt;cBOOL&lt;/code&gt; 宏的存在是为了正确地投放。</target>
        </trans-unit>
        <trans-unit id="96fc20ca3129c68549ac1ab95e6fa005be780a85" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt;. Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly; you may also find that using it is shorter and clearer than writing out the equivalent conditional expression longhand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">在极少数情况下,如数据库读取,你可能会得到需要解码的编码文本。</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">返回时,引用将覆盖*some_hash typeglob指定的符号表中的哈希槽。当你不希望必须记住显式去引用变量时,这是一种廉价传递引用的有点棘手的方法。</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">在简单的组中，例如模式 &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; ，可以通过负前瞻实现类似的效果，如 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; 。对于1000000 &lt;code&gt;a&lt;/code&gt; s 的字符串，这仅慢4倍。</target>
        </trans-unit>
        <trans-unit id="85475d75a07389a71a82f474a6904ca008087309" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative lookahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;&quot;a&quot;&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">在某些（但不是全部）操作系统上，分配给 &lt;code&gt;$0&lt;/code&gt; 会修改 &lt;code&gt;ps&lt;/code&gt; 程序看到的参数区域。在某些平台上，您可能必须使用特殊的 &lt;code&gt;ps&lt;/code&gt; 选项或其他 &lt;code&gt;ps&lt;/code&gt; 来查看更改。修改 &lt;code&gt;$0&lt;/code&gt; 作为指示当前程序状态的一种方法，比隐藏您正在运行的程序更有用。</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">在某些操作系统上,.有特殊含义的VERSION_SYM可以用来代替VERSION。</target>
        </trans-unit>
        <trans-unit id="a3f9bf6c90ba9706d9e17b2321836d771bd8fd28" translate="yes" xml:space="preserve">
          <source>On some Unixes, &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; would block. This can be avoided if you always use &lt;code&gt;O_NONBLOCK&lt;/code&gt; on the socket. See &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; and &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">在某些Unix上，即使没有可用数据，select（2）也会将套接字文件描述符报告为&amp;ldquo;准备读取&amp;rdquo;，因此任何后续 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 都会阻塞。如果始终在套接字上使用O_NONBLOCK，则可以避免这种情况。有关更多详细信息，请参见select（2）和fcntl（2）。</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">在某些Unix上，即使没有可用数据，select（2）也会将套接字文件描述符报告为&amp;ldquo;准备读取&amp;rdquo;，因此任何后续 &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 都会阻塞。如果始终在套接字上使用O_NONBLOCK，则可以避免这种情况。有关更多详细信息，请参见select（2）和fcntl（2）。</target>
        </trans-unit>
        <trans-unit id="a5313472f5f477e89baab3e33db4f6dd3bf9c900" translate="yes" xml:space="preserve">
          <source>On some older low-end devices -- think early 2.2 era -- some tests, particularly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">在一些旧系统上,它可能会比你要求的睡眠时间少一整秒,这取决于它如何计算秒数。大多数现代系统总是全量睡眠。然而,它们可能会出现比这个时间更长的睡眠时间,因为在一个繁忙的多任务系统中,你的进程可能不会立即被安排。</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">在某些操作系统上，某些信号处理程序应该在返回之前先&amp;ldquo;做某事&amp;rdquo;。一个示例可以是CHLD或CLD，它指示子进程已完成。在某些操作系统上，信号处理程序应 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 完成的子进程。在此类系统上，延迟信号方案将不适用于那些信号：它不会 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 。再次，该故障看起来像是一个循环，因为操作系统将重新发出该信号，因为尚未 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 完整的子进程。</target>
        </trans-unit>
        <trans-unit id="4baadfb850b3b420c9f511f27da50a1880c9c102" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;wait&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;wait&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;wait&lt;/code&gt;ed for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">在某些操作系统上,如Win32,可能要等到重启后才能安装。这可能会产生不同的后果:删除一个旧的DLL不会影响使用新DLL的程序,但是如果一个新的DLL在重启之前无法正常安装,那么任何依赖它的程序都必须等待。软件包变量</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">在某些操作系统上，尤其是Solaris和Unixware，从子进程调用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 将刷新并关闭父进程中打开的文件句柄，从而损坏文件句柄。在这些系统上，建议改为调用 &lt;code&gt;_exit()&lt;/code&gt; 。 &lt;code&gt;_exit()&lt;/code&gt; 可通过 &lt;code&gt;POSIX&lt;/code&gt; 模块在Perl中使用。请参考系统的手册页以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="78cb1737975a62fce19002f1001d673ccd249508" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;exit()&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">在某些平台（尤其是类似DOS的平台）上，shell可能无法处理多行命令，因此在字符串中添加换行符可能无法获得所需的内容。您可以通过将其与命令分隔符分隔，以评估在一行多个命令，如果你的shell支持该（例如 &lt;code&gt;;&lt;/code&gt; 在许多Unix外壳，并 &lt;code&gt;&amp;amp;&lt;/code&gt; 在Windows NT &lt;code&gt;cmd&lt;/code&gt; 外壳）。</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">在某些平台上,Perl 支持检索 C 级回溯(类似于 gdb 等符号调试器的工作)。</target>
        </trans-unit>
        <trans-unit id="f4483b458e9a6174b9a55320be46bd1995517e00" translate="yes" xml:space="preserve">
          <source>On some platforms inode numbers are of a type larger than perl knows how to handle as integer numerical values. If necessary, an inode number will be returned as a decimal string in order to preserve the entire value. If used in a numeric context, this will be converted to a floating-point numerical value, with rounding, a fate that is best avoided. Therefore, you should prefer to compare inode numbers using &lt;code&gt;eq&lt;/code&gt; rather than &lt;code&gt;==&lt;/code&gt;. &lt;code&gt;eq&lt;/code&gt; will work fine on inode numbers that are represented numerically, as well as those represented as strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c255f8c4da0102268758efe747d09a122b8f3a63" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">在某些平台上,比如Windows,系统调用fork()是不可用的,Perl可以在解释器层模拟fork()。对于在 Windows 上运行的代码和旨在可移植的代码,这种模拟有与 kill 有关的限制,必须加以考虑。</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">在某些平台上,比如Windows,系统调用fork()是不可用的,Perl可以在解释器级别上模拟fork()。虽然这种模拟被设计成在Perl程序级别上尽可能地与真正的fork()兼容,但是由于所有以这种方式创建的伪子 &quot;进程 &quot;就操作系统而言都生活在同一个真正的进程中,因此存在着某些重要的差异。</target>
        </trans-unit>
        <trans-unit id="acf7877caa8abc5986e73b196ee16707d5ded84d" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;. However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">在某些平台（例如Windows）上，其中fork（）系统调用不可用，可以构建Perl以在Perl解释器中模拟fork（）。在Perl程序级别，该仿真被设计为与&amp;ldquo; Unix&amp;rdquo; fork（）尽可能兼容。但是，它具有局限性，在旨在移植的代码中必须考虑这些限制。有关更多详细信息，请参见&lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">在某些平台（例如Windows）上，其中fork（）系统调用不可用，可以构建Perl以在Perl解释器中模拟fork（）。在Perl程序级别，该仿真被设计为与&amp;ldquo; Unix&amp;rdquo; fork（）尽可能兼容。但是，它具有局限性，在旨在移植的代码中必须考虑这些限制。有关更多详细信息，请参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">在某些平台上，如果结果缓冲区太小（例如，用户组数据库可能很大，并且可重入接口可能必须携带这些数据库的完整快照），则线程安全库接口可能会失败。Perl将以一个小的缓冲区开始，但是会继续重试并增加结果缓冲区，直到结果适合为止。如果出于安全性或内存消耗的原因，这种无限增长听起来很糟糕，则可以将 &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; 定义为允许的最大字节数，重新编译Perl 。</target>
        </trans-unit>
        <trans-unit id="24484214c7713626df068fed1666abc55fb655de" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;&quot;savesharedpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0080de19b8b9cfd716de6770d48e6fe48699a889" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;&quot;savesharedpvn&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4da91ee61a2307a1a8d5d2d26b5d850a91c43b4" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;&quot;savesharedsvpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">例如，在某些平台上，Windows会在线程结束时释放该线程拥有的所有已分配内存。因此，如果您不希望发生这种情况，则需要使用共享内存功能，例如 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">在某些平台上,例如Windows NT,不可能解除一个打开的文件的链接(必须先关闭该文件)。在这些平台上,实际的解链会被推迟到程序结束并返回良好状态时进行。仍然会进行检查,以确保文件柄和文件名指向同一个东西(但不是在执行结束块时,因为延迟删除可能无法访问文件柄)。</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">在某些平台上,可能无法销毁。</target>
        </trans-unit>
        <trans-unit id="5fad4eee060ffd46b78c54eef932b8d7ced75bff" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;a href=&quot;#-Dletters&quot;&gt;-Dp&lt;/a&gt; switch to Perl shows how the search progresses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">在某些平台上，这还使Perl在搜索文件名时将后缀附加到文件名。例如，在Win32平台上，如果对原始名称的查找失败，并且名称尚未以这些后缀之一结尾，则会附加&amp;ldquo; .bat&amp;rdquo;和&amp;ldquo; .cmd&amp;rdquo;后缀。如果您的Perl是在打开 &lt;code&gt;DEBUGGING&lt;/code&gt; 的情况下编译的，则使用&lt;b&gt;-Dp&lt;/b&gt;切换到Perl将显示搜索的进度。</target>
        </trans-unit>
        <trans-unit id="680d4319c3ebb1bf0096b308bc1e22323b5e0529" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">在某些系统上 (一般来说,基于 DOS 和 Windows 的系统)binmode()是必要的,当你不是在处理一个文本文件。为了便于移植,最好总是在合适的时候使用它,而在不合适的时候千万不要使用它。另外,大家可以将自己的I/O默认设置为UTF8编码的Unicode,而不是字节。</target>
        </trans-unit>
        <trans-unit id="dfca44fbb2c1ebee7c90ad249ff37ac61a808901" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with &lt;code&gt;new_from_fd&lt;/code&gt;, or created with &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; from such an object, the &lt;a href=&quot;IO::Socket#protocol&quot;&gt;&quot;protocol&quot; in IO::Socket&lt;/a&gt;, &lt;a href=&quot;IO::Socket#sockdomain&quot;&gt;&quot;sockdomain&quot; in IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Socket#socktype&quot;&gt;&quot;socktype&quot; in IO::Socket&lt;/a&gt; methods may return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">在某些系统中,对于用new_from_fd()创建的IO::Socket对象,或者用accept()从这样的对象中创建的IO::Socket对象,protocol()、sockdomain()和socktype()方法可能返回undef。</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">在某些系统上，&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的 &lt;code&gt;strftime()&lt;/code&gt; 函数已以非标准方式扩展为使用 &lt;code&gt;%C&lt;/code&gt; 格式，他们有时称这种格式为&amp;ldquo;世纪&amp;rdquo;。并非如此，因为在大多数此类系统上，这仅是四位数年份的前两位数字，因此无法可靠地确定当前世纪或千年。</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">在某些系统中,可以同时运行合作线程和抢先线程。例如,以实时优先级运行的线程通常表现为合作性,而以正常优先级运行的线程则表现为先发制人)。</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">在某些系统中,您可能需要将单引号改为双引号,这时您必须</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">在列表上下文中成功后,将返回一个包含3个元素的数组。这些元素是:</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">在列表上下文中成功后,将返回一个包含6个元素的数组。这些元素是:</target>
        </trans-unit>
        <trans-unit id="f87025d22f7460aebebdbcf7b85259c2cc5a7d3a" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">成功时，$ decoder是一个在&lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding中&lt;/a&gt;记录的对象。因此，您现在可以执行此操作；</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">成功后， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的自动染色形式将返回</target>
        </trans-unit>
        <trans-unit id="1e391581d76d0c24968f00549dd5c8fda5e3d997" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;system&lt;/code&gt; returns the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">在不支持HIGH或MEDIUM安全级别的系统上(例如Win NT或OS/2),任何改变级别的尝试都将被忽略。忽略而不是提出异常的决定允许在编写可移植程序时考虑到可以支持的系统的高安全性,而不会让这些程序在额外测试不相关的系统上失败。</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">在没有locale的系统上,这个pragma会让你的操作表现得像在 &quot;C &quot;区一样;试图改变locale会失败。</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">在有语法指示文件名的系统中,这将忽略$base文件名。否则,所有的路径组件都被认为是目录。</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">在具有指示文件名语法的系统上，这也会忽略 &lt;code&gt;$base&lt;/code&gt; 文件名。否则，所有路径组件均假定为目录。</target>
        </trans-unit>
        <trans-unit id="901b07c2e1b3c74e80e092e6a7bf36ca0bfb33ee" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, you may pass a filehandle or directory handle as the argument. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, passing handles raises an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04beca51e696b3f570d383d77ccd733902d428c1" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ad9738faaa35969ac19d2d964d2e11949f987b" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7ce7f23ab496e21c30f598c258278a01062849" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1d6ffed6769b46e37f0d82df8acb444f49f35b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt;s are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">在那些支持对文件的close-on-exec标志系统，该标志被设置对所有新开的文件描述符，其 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s为</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">在那些支持对文件的close-on-exec标志系统，该标志被设置对所有新开的文件描述符，其 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; s为</target>
        </trans-unit>
        <trans-unit id="11350e333ae0f2472a99aa4945fb651bbd8808b9" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由 &lt;code&gt;$^F&lt;/code&gt; 的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由 &lt;code&gt;$^F&lt;/code&gt; 的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a9abf94cd4611a410ac6fca9a398911a42fa5c0" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">在支持文件上执行时关闭标志的系统上，将为新打开的文件描述符设置该标志，该标志由$ ^ F的值确定。见&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$ ^ F在perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc9058ec5b96236598bf0d8742f7fe61dd91e63f" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c803cb6cc476af479d34a3bc1112251dd81782" translate="yes" xml:space="preserve">
          <source>On systems that support a real &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, locks are inherited across &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; calls, whereas those that must resort to the more capricious &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function lose their locks, making it seriously harder to write servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">在支持真正的flock(2)的系统上,锁是在fork()调用中继承的,而那些必须求助于更任性的fcntl(2)函数的系统则会失去锁,这使得服务器的编写变得严重困难。</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">在支持 fchdir(2)的系统中,可以传递一个 filehandle 或目录句柄作为参数。在不支持 fchdir(2)的系统中,传递句柄会引起异常。</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持fchmod(2)的系统中,你可以在文件中传递filehandles,在不支持fchmod(2)的系统中,传递filehandles会引起异常。在不支持fchmod(2)的系统上,传递文件柄会引起异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持 fchown(2)的系统中,你可以在文件之间传递 filehandles。在不支持 fchown(2)的系统中,传递文件柄会引起异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">在支持futimes(2)的系统中,可以在文件之间传递filehandles,在不支持futimes(2)的系统中,传递filehandles会引起异常。在不支持 futimes(2)的系统中,传递文件手柄会引发异常。Filehandles 必须以 globs 或 glob 引用的形式传递才能被识别;裸词被视为文件名。</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">在支持它的系统中,旧版本的Perl在安装%SIG处理程序时使用SA_RESTART标志。这意味着可重启的系统调用会继续,而不是在信号到达时返回。为了及时传递延迟信号,Perl 5.8.0及以后的版本会做</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">在传统上缺少可用的&lt;b&gt;man&lt;/b&gt;命令的系统上，调试器调用&lt;b&gt;perldoc&lt;/b&gt;。有时候，这种决定是不正确的，这是由于顽强的销售商，或更确切地说，是进取的用户。如果您属于这两个类别，只需手动将$ DB :: doccmd变量设置为任何查看器，以查看系统上的Perl文档。这可以在rc文件中设置，也可以通过直接分配来设置。我们仍在等待以下方面的可行示例：</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">在支持负纪元值的系统上,这个模块应该能够处理纪元开始前的日期,以系统的最小值time_t为基准。</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">在对文件名长度有限制的系统中,子程序对应的文件名可能比例程本身的名字要短。这可能导致文件名冲突。在</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">在具有网络共享概念的系统上（当前仅Windows）从&lt;a href=&quot;file://&quot;&gt;file：////&lt;/a&gt; url 返回共享名。在其他操作系统上，返回空。</target>
        </trans-unit>
        <trans-unit id="8a4f2ea2521e9d2bed452fc1750b2f44d1e70008" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a file://// url. On other operating systems returns empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">在具有卷概念的系统上，如果 &lt;code&gt;$path&lt;/code&gt; 和 &lt;code&gt;$base&lt;/code&gt; 似乎位于两个不同的卷上，则我们将不尝试解析这两个路径，而只是返回 &lt;code&gt;$path&lt;/code&gt; 。请注意，此模块的先前版本忽略了 &lt;code&gt;$base&lt;/code&gt; 的数量，这部分时间导致了垃圾结果。</target>
        </trans-unit>
        <trans-unit id="7d73de0a58277977e444ac1cca08eacb14a895ab" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt;. Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt;, which resulted in garbage results part of the time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3890814a89a9eb1b787653006ab22422f5ccc270" translate="yes" xml:space="preserve">
          <source>On systems without locale support, or on typical single-threaded builds, or on platforms that do not support per-thread locale operations, this function does nothing. On such systems that do have locale support, only a locale global to the whole program is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">在文本字段上，插入号启用一种填充模式。提供的值必须是包含文本字符串的标量变量，而不是任意表达式。Perl将文本的下一部分放入字段中，然后将字符串的前面切掉，以便下次引用该变量时，可以打印更多的文本。（是的，这意味着变量本身在执行write（）调用期间会更改，并且不会恢复。）文本的下一部分由粗略的换行算法确定。您可以使用回车符（ &lt;code&gt;\r&lt;/code&gt; ）强制换行。您可以通过更改变量 &lt;code&gt;$:&lt;/code&gt; 来更改哪些字符可合法使用： （如果您使用的是英语模块，则为$ FORMAT_LINE_BREAK_CHARACTERS）到所需字符的列表。</target>
        </trans-unit>
        <trans-unit id="c85b198c2a1ea3057ddf98fa6e2eafccce107220" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt;) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">在AS/400上,如果PERL5在你的库列表中,你可能需要把你的Perl脚本包在一个CL过程中来调用它们,就像这样。</target>
        </trans-unit>
        <trans-unit id="16a3b552e4784bd03ff647bc0e4cf0bd441e7074" translate="yes" xml:space="preserve">
          <source>On the DSM management page start the Control Panel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124c561154829ad2caaa2d7dfa3f126afe450312" translate="yes" xml:space="preserve">
          <source>On the flip side, don't be tempted to prematurely declare a test incorrect just because you're having trouble finding the bug. Invalidating a test isn't something to be taken lightly, and don't use it as a cop out to avoid work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">在由 &lt;code&gt;program_name&lt;/code&gt; 标识的给定程序上。</target>
        </trans-unit>
        <trans-unit id="12dc585208a0e91c8b1cc0d400c475b21cd97b26" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">在大型机上，Perl当前在&amp;ldquo;用于OS / 390的Unix系统服务&amp;rdquo;（以前称为OpenEdition），VM / ESA OpenEdition或BS200 POSIX-BC系统（在Perl 5.6和更高版本中支持BS2000）下工作。有关详细信息，请参见&lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt;。请注意，对于OS / 400，PASE还存在一个Perl 5.8.1 / 5.10.0或更高版本的端口，该端口是基于ASCII的（与基于EBCDIC的ILE相反），请参见&lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">在天平的另一端,像这样的声明</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">另一方面,如果你想要其他的意思,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">另一方面，如果您实际上希望将数组元素视为列表，则需要研究引用的工作方式，因为Perl不会为您在标量和列表之间神奇地转换。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">另一方面，如果您实际上希望将hash元素视为列表，则需要研究引用的工作方式，因为Perl不会为您在标量和列表之间神奇地转换。参见&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">另一方面,混合各种国标编码自动工作,除非$data太短,无法猜测。</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">另一方面,有时你会想把已经存在的东西打掉。为了在开始向文件写入之前清空文件,你可以用只写模式打开它。</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">另一方面:</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">在列表运算符的右侧，逗号的优先级非常低，因此它控制在那里找到的所有逗号分隔的表达式。唯一具有较低优先级的运算符是逻辑运算符 &lt;code&gt;&quot;and&quot;&lt;/code&gt; ， &lt;code&gt;&quot;or&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;not&quot;&lt;/code&gt; ，它们可以用于评估对列表运算符的调用，而无需括号：</target>
        </trans-unit>
        <trans-unit id="dd64949dc6542722891696f1747da1386b28ed4e" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt;, &lt;code&gt;&quot;or&quot;&lt;/code&gt;, and &lt;code&gt;&quot;not&quot;&lt;/code&gt;, which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05c9d06262a8b8894dbad99cc8b7ff5cbcc3e919" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;&lt;/a&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;&quot;Newlines&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">在这些平台上，请记住，EBCDIC字符集可能会对某些Perl函数（例如 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ）发生的影响以及对使用 &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 等运算符的ASCII常量，更不用说处理ASCII计算机的套接字接口了（请参阅&lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">在 &lt;code&gt;bool&lt;/code&gt; 确实是布尔值（C ++，C99）的那些平台和编译器上，很容易忘记转换。通过使用 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; 进行编译，可以强制 &lt;code&gt;bool&lt;/code&gt; 成为 &lt;code&gt;char&lt;/code&gt; 。您可能还希望运行 &lt;code&gt;Configure&lt;/code&gt; 的东西，如</target>
        </trans-unit>
        <trans-unit id="ba599ad520fca93f96bd6d59495057f2e3221a03" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt;. You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">在线程构建中，可能需要复制一个正则表达式，以便多个线程可以使用该模式。预期该例程将处理 &lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 成员指向的所有私有数据的重复。将使用预先构造的新 &lt;code&gt;regexp&lt;/code&gt; 结构作为参数调用它， &lt;code&gt;pprivate&lt;/code&gt; 成员将指向&lt;b&gt;旧的&lt;/b&gt;私有结构，并且此例程负责构造一个副本并返回指向它的指针（然后，Perl将使用该指针来覆盖字段传递给此例程。）&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f7d01cda50f9d06f5abacea7dcc3dcdce0e0aef" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e92c3a98c94fccb8ba5784670e12e223f435cc2" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called; see &lt;a href=&quot;#WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; for a more contained way to ensure that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">在非线程构建中,这个字段并不存在。</target>
        </trans-unit>
        <trans-unit id="fb3efd91222592d2901cd1f317fee4fadb20e2bc" translate="yes" xml:space="preserve">
          <source>On versions of Perl before 5.26, activating taint mode will also remove the current directory (&quot;.&quot;) from the default value of &lt;code&gt;@INC&lt;/code&gt;. Since version 5.26, the current directory isn't included in &lt;code&gt;@INC&lt;/code&gt; by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">一旦 &lt;code&gt;test_out&lt;/code&gt; 或 &lt;code&gt;test_err&lt;/code&gt; （或 &lt;code&gt;test_fail&lt;/code&gt; 或 &lt;code&gt;test_diag&lt;/code&gt; ）一直呼吁，从所有进一步的输出&lt;a href=&quot;../builder&quot;&gt;测试::生成器&lt;/a&gt;将被捕获&lt;a href=&quot;tester&quot;&gt;的Test ::生成器::测试仪&lt;/a&gt;。这意味着您将无法以正常方式对正常输出执行进一步的测试，直到调用 &lt;code&gt;test_test&lt;/code&gt; （好吧，除非您手动插入输出文件句柄）</target>
        </trans-unit>
        <trans-unit id="083880b888c49c9dba31b5a1a1d83eae3051aea8" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt;) have been called, all further output from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">一旦运行了 &lt;code&gt;test_test&lt;/code&gt; ,测试输出将被重定向回&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;所连接的原始文件句柄（可能是STDOUT和STDERR），这意味着您运行的任何其他测试都将正常运行并导致&lt;a href=&quot;../harness&quot;&gt;Test :: Harness的&lt;/a&gt;成功/错误。</target>
        </trans-unit>
        <trans-unit id="6814624afd4c6e39f83bea80e53ce4d9099ae560" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">一旦检测到EOF（ &lt;code&gt;$status&lt;/code&gt; 为零），过滤器就会在源流中插入一条额外的行。当执行此额外的行时，它将打印实际进行的替换次数的计数。请注意，在这种情况下， &lt;code&gt;$status&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">一旦Perl在程序中的任何位置看到您需要这些变量之一，它就会在每个模式匹配项中提供它们。这意味着在每个模式匹配项上，整个字符串都将被复制，一部分复制到$`，一部分复制到$＆，部分复制到$'。因此，对于经常匹配的长字符串和模式，惩罚是最严重的。如果可以，请避免使用$＆，$'和$`，但如果不能使用，则一旦使用它们，请立即使用它们，因为您已经支付了价格。请记住，有些算法真的很欣赏它们。从5.005版本开始，$＆变量不再像其他两个变量那样&amp;ldquo;昂贵&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">将功能，构造或模块标记为不赞成使用后，我们可以将其从Perl核心中删除。毫不奇怪，我们说我们已经&lt;b&gt;删除了&lt;/b&gt;这些东西。卸下模块后，它将不再与Perl一起提供，但将继续在CPAN上可用。</target>
        </trans-unit>
        <trans-unit id="a0837f9cee9c8dc066f294cad80d931eedcddeed" translate="yes" xml:space="preserve">
          <source>Once a handle is open, its layers can be altered using &lt;code&gt;binmode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">然而,一旦一个模块被包含在Perl核心中,每一个参与维护Perl的人都应该意识到,该模块仍然是原作者的财产,除非原作者明确放弃对它的所有权。尤其是:</target>
        </trans-unit>
        <trans-unit id="fb8472b689cb77838766fd3ad6c514d183c9cd46" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">引用对象获得祝福后，来自&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;核心模块的 &lt;code&gt;blessed&lt;/code&gt; 功能便可以告诉我们其类名。传递给对象时，此子例程返回对象的类，否则返回false。</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">一旦一个线程脱离,它可能不会被加入,它可能产生的任何返回数据(如果它已经完成并等待加入)都会丢失。</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">一旦一个todo测试开始成功,只需将其移到块外即可。当区块为空时,将其删除。</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">一旦一个变量被删除,它的使用就会触发一个错误,告诉你这个变量是不支持的。</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">再次， &lt;code&gt;module-starter&lt;/code&gt; 或 &lt;code&gt;h2xs&lt;/code&gt; 为您完成了所有工作。它们生成标准的 &lt;code&gt;Makefile.PL&lt;/code&gt; ,您在下载和安装模块时会看到它们，这将生成带有 &lt;code&gt;dist&lt;/code&gt; 目标的Makefile 。</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">批准后，更改将合并到&lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;（驱动&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;的存储库）中，并随下一个Perl 5版本一起分发。</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">在命令行中，输入 &lt;code&gt;h&lt;/code&gt; 进入一页帮助屏幕；其余的应该不言自明。</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">一旦调用FILE *,应</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">一旦结束,不得再将任何物品放入队列中。</target>
        </trans-unit>
        <trans-unit id="6742558d45b013c0f52c3e462293464937a542ee" translate="yes" xml:space="preserve">
          <source>Once installed you may delete the temporary archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14db76a9667a7b9782c3a5e1dfcf95186773ac9a" translate="yes" xml:space="preserve">
          <source>Once it has created those helpers TAP::Harness starts running the tests. For each test it creates a new parser (TAP::Parser) which is responsible for running the test script and parsing its output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">映射后，您可以像对待任何其他字符串一样对待 &lt;code&gt;$string&lt;/code&gt; string。由于不必加载数据，因此映射速度非常快，并且可能不会增加内存占用。</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">创建 miniperl.exe 后,从 NetWare 文件夹中运行 nmake。这将为 NetWare 创建一个 Perl 解释器,名为</target>
        </trans-unit>
        <trans-unit id="b72bd7ffb13635f0115e40bb684ebf6013fb4223" translate="yes" xml:space="preserve">
          <source>Once perl is installed you can read this document in the following way</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">一旦选择了版本号,重要的是要坚持您的版本方案,而不要减少数字的数量。这是因为 &quot;下游 &quot;的打包程序,例如 FreeBSD ports 系统,会以不同的方式解释版本号。如果您改变了版本方案中的数字,就会使这些系统感到困惑,从而使它们对您的模块的版本不按顺序排列,这显然是不好的。</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">曾经制作过MacOS Classic的Makefiles</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">一旦注册，就没有关闭这些挂钩的机制，因此，如果有必要，您将需要自己执行此操作。 &lt;code&gt;%^H&lt;/code&gt; 的条目可能是最好的方法，因此效果在词法范围内；但是，也可以使用 &lt;code&gt;BhkDISABLE&lt;/code&gt; 和 &lt;code&gt;BhkENABLE&lt;/code&gt; 宏来临时打开和关闭条目。您还应该知道，通常来讲，在加载扩展之前至少会打开一个作用域，因此您会看到一些没有匹配的 &lt;code&gt;start&lt;/code&gt; 的 &lt;code&gt;pre/post_end&lt;/code&gt; 对。</target>
        </trans-unit>
        <trans-unit id="6126376d608e0a08175eebdf21cea20073d31c49" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">一旦字符串开头的'aaab'匹配并且执行了 &lt;code&gt;(*SKIP)&lt;/code&gt; ，下一个起始点将是执行 &lt;code&gt;(*SKIP)&lt;/code&gt; 时光标所在的位置。</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">一旦创建了AV,就可以对其进行以下操作。</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">一旦创建了 HV,就可以对其进行以下操作。</target>
        </trans-unit>
        <trans-unit id="7b0782b5689e0608cbf6133cde75f1c5a3739fbd" translate="yes" xml:space="preserve">
          <source>Once the build is completed you need to create the DLL SIS file by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">一旦应用了过滤，通过将每个占位符替换为相应的原始组件（来自 &lt;code&gt;@components&lt;/code&gt; ），可以将原始字符串，正则表达式，POD等重新插入到代码中。请注意，这意味着 &lt;code&gt;@components&lt;/code&gt; 变量必须在过滤器内格外小心。所述 &lt;code&gt;@components&lt;/code&gt; 阵列存储&amp;ldquo;背翻译&amp;rdquo;每一个占位符插入到 &lt;code&gt;$_&lt;/code&gt; ，以及用作占位符之间的间隙的源代码。如果在 &lt;code&gt;@components&lt;/code&gt; 中更改了占位符的反向翻译，则在完成过滤器后从 &lt;code&gt;$_&lt;/code&gt; 中删除占位符时，也会类似地更改它们。</target>
        </trans-unit>
        <trans-unit id="cd6cbdddebea04b989e355c0ed247c28cfea9f3d" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt;). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt;, as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt;, they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">一旦第一行处理完毕,流程将是这样的。</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">使用上述参数创建通用服务器套接字后，服务器将等待新的客户端连接到该套接字。服务器阻塞了 &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 方法，该方法最终接受来自远程客户端的双向连接。（确保自动刷新此句柄以避开缓冲。）</target>
        </trans-unit>
        <trans-unit id="f10049f7656078a8b871ef2357d99fe6e6157f3d" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;accept&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f78b2677c2893cae03c215c7f1cb2296b9c1aa" translate="yes" xml:space="preserve">
          <source>Once the headers have been installed, you can create a SIS for the PerlApp:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">一旦解析器完成,将返回退出状态。如果解析器运行了一个可执行文件,它将返回该可执行文件的退出状态。</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">一旦解析器完成,将返回解析后的TAP的版本号。版本号是在TAP版本13中引入的,所以如果没有找到版本号,则假定为版本12。</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">解析器完成后，将返回等待状态。如果解析器运行了可执行文件，它将返回可执行文件的等待状态。否则，这仅返回 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="58ee32eca6824b955eaf78744f8a028137e28ac5" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;exit&lt;/code&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">一旦前缀和最外侧的分隔符括号被识别出来,代码块就会被提取出来,方法是对输入文本进行步进,并依次尝试以下选项。</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">一旦完成了该程序，并且对第一种语言的本地化工作正常（通过Projname :: L10N :: en_us中的数据和方法），您就可以将数据汇总在一起进行翻译。如果您的第一语言词典不是_AUTO词典，那么您已经在词典中显式包含了所有消息（否则，在调用$ lh-&amp;gt; maketext来获取不在此处的消息时，您将抛出异常。 ）。但是，如果（建议）您是懒惰的，并且正在使用_AUTO词典，那么您必须列出迄今为止为止让_AUTO为您生成的所有短语的列表。有很多方法可以汇编这样的列表。最直接的方法是简单地grep每次出现&amp;ldquo; maketext&amp;rdquo;（或围绕它的包装器的调用）的源代码，就像上面的 &lt;code&gt;pmt&lt;/code&gt; 功能），并记录以下短语。</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">一旦引用被存储在一个像$aref或$href这样的变量中,你就可以像其他标量值一样复制或存储它。</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">确定了程序的大小后，将再次解析模式，但这一次是真实的。现在 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 将为false，并且可以进行实际构造。</target>
        </trans-unit>
        <trans-unit id="7c79022e55900699b84f2aa1eb3cdbe226323760" translate="yes" xml:space="preserve">
          <source>Once the socket has been connected to the peer, &lt;code&gt;connect&lt;/code&gt; will return true and the socket will now be ready to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba841c18d878724cf95fcf3049c21ef759f81a9" translate="yes" xml:space="preserve">
          <source>Once the source was patched, &lt;code&gt;./Configure&lt;/code&gt; and &lt;code&gt;make test_prep&lt;/code&gt; were called and completed successfully, enabling confirmation of the findings in RT #72414.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">一旦这样做,做以下工作来建立任何扩展。</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">一旦给定函数的这个过程完成,它就被定义了,所以未来对子程序的调用将绕过AUTOLOAD机制。</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">一旦上传,它就会被放在你的作者目录中,不被人注意。如果您想让它与CPAN的其他部分连接起来,您需要到PAUSE上的 &quot;注册命名空间&quot;。一旦注册,您的模块将出现在CPAN上的by-module和by-category列表中。</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">从前，C代码可在BSD和SysV下编译。通常，可以轻松转换为在另一个&lt;b&gt;平台&lt;/b&gt;上运行的代码，可以根据自己的喜好（通常是这样）定义&amp;ldquo;轻松&amp;rdquo;。如果您足够努力，任何东西都可以认为是便携式的，例如活动房屋或伦敦桥。</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">很久以前,我写过一个叫pstruct的程序。这是一个perl程序,它试图解析出C结构,并为你显示它们的成员偏移量。这对于那些看二进制转储的人或者在内核里摸索的人来说特别有用。</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">从前,MakeMaker可以在MacOS Classic(MacPerl)上生成一个近似正确的Makefile。由于缺乏维护者,这与MakeMaker的其他部分不同步,已经多年没有工作了。由于修复的机会不大,MacOS Classic也渐渐消失,而且一开始的代码就很恶心,为了方便维护,这段代码已经被删除。</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">很久以前,有一个图书馆叫做</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">一旦祝福了 &lt;code&gt;$self&lt;/code&gt; 所引用的哈希，我们就可以开始对其调用方法。如果要将对象初始化放在其自己的单独方法中，这将很有用：</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">一旦你能识别出各个区块,试着让它们嵌套。这也不难。</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">一旦你有了一个引用,你可以使用下面的宏来取消引用。</target>
        </trans-unit>
        <trans-unit id="8475608c1eecbfff6034af7fbbf89552dc6e6321" translate="yes" xml:space="preserve">
          <source>Once you have changed into the repository directory, you can inspect it. After a clone the repository will contain a single local branch, which will be the current branch as well, as indicated by the asterisk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">完成此操作后，您可以直接使用&lt;b&gt;DB_File&lt;/b&gt;方法访问Berkeley DB API函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">开启后,只需调出PASE shell,提取tarball即可。</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">一旦你有了密钥列表,你就可以在处理哈希元素之前处理这个列表。例如,你可以对密钥进行排序,这样你就可以按照词法顺序处理它们。</target>
        </trans-unit>
        <trans-unit id="fba888926fbbe98be022401817b7a70ac357c498" translate="yes" xml:space="preserve">
          <source>Once you have the toolchain set up properly, the only remaining hurdle is actually locating where in the device it was installed in. For example, CCTools installs its toolchain in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">一旦你有了这段代码,就把它贴到了</target>
        </trans-unit>
        <trans-unit id="1eb08c46cb14cd90ec6426a049fef10ebf7f995f" translate="yes" xml:space="preserve">
          <source>Once you have unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c09803658da900e84c748f878a847903987255" translate="yes" xml:space="preserve">
          <source>Once you have write access, you will need to modify the URL for the origin remote to enable pushing. Edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">在正确的模式下正确打开二进制文件后，便可以使用与文本文件相同的所有Perl I / O功能。但是，您可能希望使用固定大小的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ，而不是可变大小 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 您的输入。</target>
        </trans-unit>
        <trans-unit id="23e5339b1fa0074bcbf688df51973daa79c9a799" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;read&lt;/code&gt; instead of the variable-sized &lt;code&gt;readline&lt;/code&gt; for your input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">一旦有了钩子函数，就需要一个 &lt;code&gt;BHK&lt;/code&gt; 结构来放入它们。最好是静态分配它，因为一旦注册，就无法释放它。应该使用 &lt;code&gt;BhkENTRY_set&lt;/code&gt; 宏将函数指针插入此结构，该宏还将设置标志，指​​示哪些条目有效。如果由于某些原因确实需要动态分配 &lt;code&gt;BHK&lt;/code&gt; ，请确保在开始之前将其归零。</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">一旦你知道一个对象的类型是什么,你就知道它属于什么子类,从而知道它支持什么方法。</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">一旦你开始积累用户,他们就会给你发错误报告。如果你幸运的话,他们甚至会给你发送补丁。欢迎来到维护软件项目的乐趣......</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">一旦你这样做了,你可以通过添加新的渲染样式来改变Concise的输出,也可以通过添加回调例程来填充新的变量,如果这些变量是从这些(刚刚添加的)样式中引用的。</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">在这里完成操作后，接下来请查看&lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">一旦你实际设置了任何你想要的选项(如果有的话),你就可以继续使用以下方法以特定方式搜索Pod文件。</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">一旦你做到了这一点,你就可以放心地省略开放模式的编码部分。</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">一旦确保模块通过了自己的测试-确保始终是一件好事-您可以 &lt;code&gt;make dist&lt;/code&gt; ，并且Makefile有望为您生成模块的漂亮tarball，准备上载。</target>
        </trans-unit>
        <trans-unit id="43b912c28f1dbb1c2e7aca4c90fa70b6b6f3dc13" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make distcheck&lt;/code&gt; to make sure everything looks OK, followed by &lt;code&gt;make dist&lt;/code&gt;, and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9742159929b90169a3b9a1d6ff201b11bb8fe7b" translate="yes" xml:space="preserve">
          <source>Once you've finished writing your commit message and exited your editor, git will write your change to disk and tell you something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">安装NDK并设置设备后，剩下要做的就是设置设备和交叉编译环境。 Blackberry提供了一个脚本 &lt;code&gt;bbndk-env.sh&lt;/code&gt; （有时名为bbndk-env_10_1_0_4828.sh之类的 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ）可用于执行此操作。但是，我们需要解决一些问题：脚本修改了PATH，以便'gcc'或'ar'指向它们的交叉编译等效项，这会干扰构建过程。</target>
        </trans-unit>
        <trans-unit id="0ecc1cbc4b8ed0cfb9b6e01c2a2f1591b2619c6e" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt;) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">一旦你将你的程序/网站/等本地化为所有需要的语言,一定要将结果展示给翻译人员(无论是现场,还是通过屏幕截图)。一旦他们同意,就尽一切努力让至少一位讲该语言的人检查。这一点即使在翻译是由你自己的程序员完成的情况下也是如此。有些系统可能比其他系统更难找到测试者,这取决于所涉及的特定领域的术语和概念的数量--在一个email-via-Web界面中,找到能告诉你他们是否同意你的 &quot;删除这条消息 &quot;的翻译的人,比找到能给你一个XML查询工具界面中的 &quot;属性值 &quot;的翻译的人更容易。</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">一旦你了解了这些,在C语言中嵌入Perl就很容易了。</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">解压后,运行 &quot;sh Configure&quot; (参见 INSTALL 以了解 Configure 选项的完整讨论)。os390有一个 &quot;提示 &quot;文件,它指定了大多数事情的正确值。一些需要注意的地方包括</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">一旦你的扩展完成并通过了所有的测试,安装它就很简单了:你只需运行 &quot;make install&quot;。你需要有写权限进入安装Perl的目录,或者让你的系统管理员为你运行make。</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">进行了一个额外的翻译:将</target>
        </trans-unit>
        <trans-unit id="ec03014fcac8a461acd2bab0b3f3f4c4647a9956" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure Perl code outside the lexical scope of &lt;code&gt;use locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3A-Numeric-Formatting&quot;&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">关于C语言环境，存在冲突的一个方面。 （请参阅&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。）perl例外，除非另有说明，否则将程序运行的基础语言环境设置为从环境传递到该语言环境的语言环境。这是与通用C语言程序的重要区别，在通用C语言程序中，除非程序对其进行了更改，否则基本语言环境是&amp;ldquo; C&amp;rdquo;语言环境。从v5.20开始，该基本语言环境在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境的词法范围之外完全对纯perl代码隐藏除了必须使用POSIX模块中的几个函数调用。但是底层语言环境（只有一个例外）暴露于XS代码，从而影响了行为依赖于语言环境的所有C库例程。您的XS代码最好不要假定基础语言环境是&amp;ldquo; C&amp;rdquo;。唯一的例外是&lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC&lt;/a&gt;语言环境类别，这是一个异常的原因是，经验表明，它可以为XS码有问题，而我们还没有与该问题的报告，&lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;其他语言环境类别&lt;/a&gt;。并且这一类出现问题的原因是用作小数点的字符可能会有所不同。许多欧洲语言使用逗号，而英语（因此Perl）期望使用点号（U + 002E：FULL STOP）。许多模块只能处理作为点的基数字符，因此perl尝试这样做。在Perl v5.20之前，仅尝试在启动时将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言环境。否则，任何&lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;都会对其进行更改；这导致了一些失败。因此，从v5.22开始，perl尝试将XS代码的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 始终设置为 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">基于ASCII的字符集和EBCDIC的字符集之间的最大区别是，按本机顺序排序时，字符的相对位置。最需要注意的是大写和小写字母，数字和下划线（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）。在ASCII平台上，本机排序顺序的数字在大写字母之前，在下划线之前，在下划线之前在小写字母之前。在EBCDIC上，下划线位于第一个，然后是小写字母，然后是大写字母，最后是数字。如果在基于ASCII的平台上排序，则医师的两个字母的缩写位于驱动器的两个字母的缩写之前；那是：</target>
        </trans-unit>
        <trans-unit id="4d27487c78325597c40568b8011491df0ed50a95" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">也可以用 &quot;短 &quot;名。</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">人们可以随时开始</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">通过提供 &lt;code&gt;-D usethreads&lt;/code&gt; 选项，可以构建启用了线程支持的perl。</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">可以通过设置$ Getopt :: Std :: OUTPUT_HELP_VERSION来更改消息的输出文件句柄。通过 &lt;code&gt;Usage:&lt;/code&gt; 开关字符串作为参数调用函数help_mess（）和version_mess（），可以打印 &lt;code&gt;--help&lt;/code&gt; （不使用用法：行）和 &lt;code&gt;--version&lt;/code&gt; 的消息。</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">可以通过检查相应的 &lt;code&gt;Features&lt;/code&gt; 来检查当前加载的ReadLine包是否支持这些方法。</target>
        </trans-unit>
        <trans-unit id="0c393381162c37f504c3308b016602c8a38b83d3" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db862b22399f31abaed4d1d2c6d6ed9c25d9c230" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;a href=&quot;Data::Dumper&quot;&gt;&lt;code&gt;Data::Dumper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;storable&quot;&gt;&lt;code&gt;Storable&lt;/code&gt;&lt;/a&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">一个人可以通过两种方式规避这两个问题。总是以文本格式而不是原始二进制格式传输和存储数字，或者考虑使用诸如 &lt;code&gt;Data::Dumper&lt;/code&gt; 和 &lt;code&gt;Storable&lt;/code&gt; （自Perl 5.8起包含）之类的模块。将所有数据保留为文本可大大简化事务。</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">我们可以从以下地方获得RSX</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">人们可以从EMX的不同部分获得,比如说</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">我们可以在标识符名称中使用Unicode,但不能在包/类或子程序名称中使用Unicode。虽然在Perl 5.8.0中确实存在一些有限的功能,但这更多的是偶然的,而不是设计的;不支持为上述目的使用Unicode。</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">您可以以下列格式阅读本文件:</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">可以用括号内的模板信代替一个数字重复计数,使用括号内模板的打包字节长度作为重复计数。</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">有一种情况是没有设置 SvFAKE 的 gv 不能处理。在</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">这里有一种常见的调试方法,就是随意地洒上几条打印语句,在我们打印出数据之前加一个检查,在打印之后再加一个检查。</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">将此端口与 &lt;code&gt;Tk&lt;/code&gt; 之类的GUI库一起使用时，一个常见的错误是假设Perl打开命令行窗口的正常行为将消失。事实并非如此。如果要在不打开命令行窗口的情况下启动 &lt;code&gt;perl&lt;/code&gt; 的副本，请使用在安装过程中生成的 &lt;code&gt;wperl&lt;/code&gt; 可执行文件。用法与Windows上的常规 &lt;code&gt;perl&lt;/code&gt; 完全相同，除了 &lt;code&gt;-h&lt;/code&gt; 之类的选项不起作用（因为它们需要命令行窗口才能打印到）。</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">通过将 &lt;code&gt;&amp;amp;&lt;/code&gt; 替换为参数之前的 &lt;code&gt;*&lt;/code&gt; ，可以将此信息传达给&lt;b&gt;xsubpp&lt;/b&gt;。 &lt;code&gt;&amp;amp;&lt;/code&gt; 表示该参数应通过其地址传递给库函数。上面的两个函数可以用XSUB表示为</target>
        </trans-unit>
        <trans-unit id="fcbea60b30cb68b4498f395be71fe8caca1d66b2" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt;. &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">可以使用它为特定命令创建&lt;b&gt;Pod :: Paragraphs&lt;/b&gt;和&lt;b&gt;Pod :: InteriorSequences的&lt;/b&gt;子类（或在解析树中创建自己的自定义节点类型），然后向每个自定义节点/ 添加某种类型的&lt;b&gt;generate（）&lt;/b&gt;方法树中的子类对象。然后，您所需要做的就是以所需顺序递归地遍历树，处理子级（最有可能是从左到右），方法是格式化子级（如果它们是文本字符串），或者调用子级的&lt;b&gt;embed（）&lt;/b&gt;方法&lt;b&gt;（&lt;/b&gt;如果它们是文本字符串&lt;b&gt;）。&lt;/b&gt;对象/引用。</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">其中,在表中标有 &quot;ASCII范围Unicode &quot;的一栏中,只匹配ASCII字符集中的字符。</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Perl代码的一个特别常见的地方是打开了一个发送&lt;b&gt;sendmail&lt;/b&gt;的管道：</target>
        </trans-unit>
        <trans-unit id="42325abeeacce413a34de5a75512b4be08cb249a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;PerlIO::via::QuotedPrint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">Perl 5.8.0附带了一个示例模块&lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt;，CPAN也提供了更多示例模块，例如&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt;。例如，PerlIO :: via :: StripHTML模块允许您说：</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">默认标量变量是一个例外：从perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; 始终会剥离$ _中的所有魔术，以使可以安全地在子例程中重用$ _。</target>
        </trans-unit>
        <trans-unit id="dd6c9b4252819413fc14053d624bb7bb0e0b2769" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;local($_)&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">一个设施,一个重点。</target>
        </trans-unit>
        <trans-unit id="c1af03124d01c283a40e813bb6152573293c3a58" translate="yes" xml:space="preserve">
          <source>One final point -- obviously &lt;code&gt;InputLength&lt;/code&gt; can only be used whenever you know the length of the compressed data beforehand, like here with a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">从Perl 5.14开始可用的一种形式看起来像 &lt;code&gt;\o{...}&lt;/code&gt; ，其中的点代表一个或多个八进制数字。它可以用于任何Unicode字符。</target>
        </trans-unit>
        <trans-unit id="6706d7cc152004a9fcc100843796f293fa434aa5" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt;, where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">人们一般是这样使用的。</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">一个很好的理由是,当你已经有了一个用另一种语言编写的现有应用程序,而且都已经完成了(而且做得很好),或者你有了一种专门为某项任务设计的应用程序语言(如prolog、make)。</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">向我们展示如何打开文件之前的最后一件事：打开文件并不会（通常）自动将它们锁定在Perl中。有关如何锁定，请参见&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">首先完成一个双引号解释级别，但是您不能说 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; 因为这是上一段所述的间接文件句柄。（在旧版本的Perl中，程序员会插入大括号以强制将其解释为文件名glob： &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 。这些天来，将内部函数直接调用为 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; 被认为是更干净的方法，这可能是首先要做的正确方法。）例如：</target>
        </trans-unit>
        <trans-unit id="c5cfad95a16b5735e117bc2fe294d5a66682c4eb" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt;. These days, it's considered cleaner to call the internal function directly as &lt;code&gt;glob($foo)&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">一行模块说明。将包含在PPD文件中。</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">一次一个木头。</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">一个宏控制主要的Perl构建风味。MULTIPLICITY。MULTIPLICITY构建有一个C结构,它可以封装所有的解释器状态。对于支持多线程的perls,通常还定义了PERL_IMPLICIT_CONTEXT,并实现了支持传递一个 &quot;隐藏的 &quot;第一个参数,代表所有三个数据结构。MULTIPLICITY 使得多线程 perls 成为可能 (使用 ithreads 线程模型,与宏 USE_ITHREADS 相关。)</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">我们也可以使用pod指令来快速注释出一段代码。</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">也许有人会问,为什么我们把上述计算器称为符号式。原因是实际计算表达式的值的时间被推迟到了</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">最初可能有人猜测Perl会在 &lt;code&gt;cat&lt;/code&gt; 中找到 &lt;code&gt;at&lt;/code&gt; 并在那里停下来，但这不会给第一个限定符 &lt;code&gt;.*&lt;/code&gt; 带来最长的字符串。取而代之的是，第一个量词 &lt;code&gt;.*&lt;/code&gt; 会在保持正则表达式匹配的同时获取尽可能多的字符串。在此示例中，这意味着在字符串中具有 &lt;code&gt;at&lt;/code&gt; 序列和最后一个 &lt;code&gt;at&lt;/code&gt; 。此处说明的另一个重要原理是，当正则表达式中包含两个或多个元素时，</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">可能会认为 &lt;code&gt;\s&lt;/code&gt; 等效于 &lt;code&gt;[\h\v]&lt;/code&gt; 。从Perl v5.18开始确实如此，但是在此之前，唯一的区别是垂直制表符（ &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ）与 &lt;code&gt;\s&lt;/code&gt; 不匹配。</target>
        </trans-unit>
        <trans-unit id="032953fa379d00cbfc247f44c2a8260cf97dce47" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt;. This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt;) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">这里还有一件事。箭头是可选的</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">必须小心处理传递给打印的包含ASCII编码的标量和字符串。一个常见的地方是在CGI脚本编写的MIME类型头的输出中出现这种情况。例如,许多Perl编程指南都推荐类似于这样的内容。</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">文件的一个名称。此名称在&lt;b&gt;目录中&lt;/b&gt;列出。您可以在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 中使用它，以告诉&lt;b&gt;操作系统&lt;/b&gt;确切要打开的文件，并将该文件与&lt;b&gt;filehandle&lt;/b&gt;关联，该文件&lt;b&gt;句柄&lt;/b&gt;将在程序中带有该&lt;b&gt;文件&lt;/b&gt;的后续标识，直到您将其关闭。</target>
        </trans-unit>
        <trans-unit id="336da35cb3021da58e89132b50e38c873db1f14d" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;open&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">一 &lt;code&gt;Moo&lt;/code&gt; 的最引人注目的功能是它的互操作性 &lt;code&gt;Moose&lt;/code&gt; 。当有人尝试在 &lt;code&gt;Moo&lt;/code&gt; 类或角色上使用 &lt;code&gt;Moose&lt;/code&gt; 的自省API时，它会透明地膨胀为 &lt;code&gt;Moose&lt;/code&gt; 类或角色。这使得将使用 &lt;code&gt;Moo&lt;/code&gt; 的代码合并到 &lt;code&gt;Moose&lt;/code&gt; 代码库中变得更加容易，反之亦然。</target>
        </trans-unit>
        <trans-unit id="3e12d82a19550be538457962eb8c1b445867682c" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt;'s most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt;. When someone tries to use &lt;code&gt;Moose&lt;/code&gt;'s introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt;-using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">HP移植中心URL之一是&lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt;当前可用的端口是使用GNU gcc构建的。</target>
        </trans-unit>
        <trans-unit id="886b780bbc161a993310017e62754b9a44143e58" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc. As porting modern GNU gcc is extremely hard on HP-UX, they are stuck at version gcc-4.2.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Perl的内部格式之一恰好是UTF-8。不幸的是,Perl无法保守秘密,所以每个人都知道这一点。这也是造成很多混乱的原因。最好假装内部格式是某种未知的编码,你总是要明确地进行编码和解码。</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">数据与输入的数据或最终输出的数据之间的过滤器之一。</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">其中一个小技巧是在Perl启动时禁用浮点异常(EMX的默认值)。这只对编译时关联的DLL在main()被调用之前改变标志有帮助。</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perl中古老的，千年前的套接字代码的主要问题之一是，它对某些常量使用了硬编码的值，这严重损害了可移植性。如果您看到执行类似显式设置 &lt;code&gt;$AF_INET = 2&lt;/code&gt; 代码的代码，那么您就知道自己陷入了大麻烦。一种无与伦比的优越方法是使用 &lt;code&gt;Socket&lt;/code&gt; 模块，它可以更可靠地授予对所需的各种常量和函数的访问权限。</target>
        </trans-unit>
        <trans-unit id="3521b3f28c5fee40e9a650a969731031f1a61ee7" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt;, you know you're in for big trouble. An immeasurably superior approach is to use the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548d34337bf348093d461254c9e13628f931676b" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Perl 5 中最重要的新特性之一就是能够管理复杂的数据结构,比如多维数组和嵌套哈希。为了实现这些功能,Perl 5引入了一个叫做 &quot;引用 &quot;的功能,而使用引用是Perl中管理复杂的结构化数据的关键。不幸的是,有很多有趣的语法需要学习,而且主要的手册页面可能很难遵循。手册相当完整,有时人们会觉得这是个问题,因为很难区分哪些是重要的,哪些不是。</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">样的过滤器的问题之一。</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Perl的强大之处在于,Perl的黑客们往往希望分享他们所遇到的问题的解决方案,这样你我就不必再为同一个问题而战。</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">perlivp使用的两个模块中的一个没有在安装中出现。这是一个严重的错误,因为它会对 perlivp 的功能产生不利影响。你可以通过正确安装perl来纠正这个问题。</target>
        </trans-unit>
        <trans-unit id="3cf9aca6d76537483035c3c858a1ba395bda4fb6" translate="yes" xml:space="preserve">
          <source>One of these is because that, contrary to the claims, Unicode is not completely locale insensitive. Turkish and some related languages have two types of &lt;code&gt;&quot;I&quot;&lt;/code&gt; characters. One is dotted in both upper- and lowercase, and the other is dotless in both cases. Unicode allows a locale to use either the Turkish rules, or the rules used in all other instances, where there is only one type of &lt;code&gt;&quot;I&quot;&lt;/code&gt;, which is dotless in the uppercase, and dotted in the lower. The perl core does not (yet) handle the Turkish case, and this message warns you of that. Instead, the &lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt; module allows you to mostly implement the Turkish casing rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">一个或多个嵌入式模式匹配修饰符，将为其余模式或封闭模式组的剩余模式（如果有的话）打开（或关闭，如果以 &lt;code&gt;-&lt;/code&gt; 开头）。</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">根据在 &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; 运行的ExtUtils :: Installed-&amp;gt; validate（），一个或多个文件丢失。通过进行正确的安装进行纠正。</target>
        </trans-unit>
        <trans-unit id="a650068eaca265c5b79bfe09b24d5cc755bb9020" translate="yes" xml:space="preserve">
          <source>One or more licenses that apply to some or all of the files in the distribution. If multiple licenses are listed, the distribution documentation should be consulted to clarify the interpretation of multiple licenses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">下面的一个或多个修饰符可以选择跟在TEMPLATE中的某些字母后面(第二列列出修饰符有效的字母)。</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">一个或多个章节或小节,更详细地介绍现有方法和例行程序以及任何其他相关信息;</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 标志允许的另一件有趣的事情是链接替换：</target>
        </trans-unit>
        <trans-unit id="494e3ba4d63dc7d4d1f0f89cdfe24cd0f1c04a4f" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;s///r&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">要考虑的另一件事是CV可能只是未定义而不是被释放，例如 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 。在这种情况下，其引用计数可能尚未达到零，但我们仍会删除其填充和 &lt;code&gt;CvROOT&lt;/code&gt; 等。由于各种子代可能仍将其 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 指向此未定义的CV，因此我们 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 保留其自己的CvOUTSIDE，以便词汇范围的链是不间断的。例如，以下应打印123：</target>
        </trans-unit>
        <trans-unit id="014675b4f1afe81572052832b23ba392c4d8e3a4" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;undef &amp;amp;foo&lt;/code&gt;. In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2da08b06ed54d7d3369e11557c08e9b0920593" translate="yes" xml:space="preserve">
          <source>One particularly interesting aspect is that if the op has no kids (i.e., &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) the op is freed and replaced with an entirely new one that references &lt;code&gt;*ARGV&lt;/code&gt; (lines 12-16).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Windows 下的 4NT 命令壳有一个特别有害的问题,那就是它(几乎)总是把 % 字符当作是需要扩展环境变量。因此,在这个 shell 下,重要的是始终将任何你想让 Perl 看到的 % 字符(例如,对于哈希变量)加倍,即使它们是引号。</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">一种可能性是将针对这些代码点的任何匹配都视为未定义。但是由于Perl没有定义未定义匹配的概念，因此将其转换为failure或 &lt;code&gt;FALSE&lt;/code&gt; 。这几乎是（但不完全是）Perl从v5.14（使用这些代码点变得普遍可靠）到v5.18所做的事情。区别在于Perl将所有 &lt;code&gt;\p{}&lt;/code&gt; 匹配都视为失败，而所有 &lt;code&gt;\P{}&lt;/code&gt; 匹配都视为成功。</target>
        </trans-unit>
        <trans-unit id="fbed2ea5d12cf5ca5a7dda7729be8ef0a1f5a584" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt;. This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">造成这种情况的一个可能原因是，您希望通过&lt;b&gt;使用&lt;/b&gt;或&lt;b&gt;导入&lt;/b&gt;将常量导入名称空间，而没有进行任何此类导入，例如，可能是您的操作系统不支持该常量。希望您对期望看到的常量使用了明确的导入列表；请参阅&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;和&lt;a href=&quot;functions/import&quot;&gt;导入&lt;/a&gt;。尽管显式导入列表很可能早已捕获了此错误，但它自然无法解决您的操作系统仍不支持该常数的事实。也许在&lt;b&gt;使用&lt;/b&gt;或&lt;b&gt;导入&lt;/b&gt;的符号导入列表的常量中或在触发此错误的行的常量名称中有错字？</target>
        </trans-unit>
        <trans-unit id="039c34047140e161ac3c3f3d67a00d920ec9253f" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b7cfe9d2aa74b9a194cf633078d5ffa3af4a9c3" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use &lt;code&gt;Encode::decode('UTF-8', ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">一个可能的原因是,你自己设置了UTF8标志,你认为是UTF-8的数据,但它不是(例如,它是传统的8位数据)。为了防止这种情况,你可以使用Encode::decode_utf8。</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">一个可能对 &quot;fail &quot;属性有用的值是方法名 &quot;fail_handler_auto&quot;。这是一个定义在类Locale::Maketext本身的方法。你可以用以下方法来设置它。</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">一个经常出现的问题是需要一个值是列表的哈希。当然,Perl 的哈希值必须是标量,不能是列表。</target>
        </trans-unit>
        <trans-unit id="b4ad2adff47d9f54cd5e7bc6c9a916046c09e993" translate="yes" xml:space="preserve">
          <source>One problem with creating a zip archive directly from STDIN can be demonstrated by looking at the contents of the zip file, output.zip, that we have just created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b95f68790db1176c6962a262914d43124b34ed" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusing results in some cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">这样做的一个问题是,它在某些情况下会导致意想不到的、令人困惑的结果。</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">这种未完成性的原因之一是它(目前)固有的不可移植性:因为包名和子程序名都可能需要映射到文件和目录名,文件系统的Unicode能力就变得很重要--而且不幸的是没有可移植的答案。</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">在这种情况下，Perl不尝试解决Unicode角色的原因之一是答案高度依赖于操作系统和文件系统。例如，文件名是否可以采用Unicode以及采用哪种编码方式，并不是完全可移植的概念。对于 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 同样：&amp;ldquo;命令行界面&amp;rdquo;（以及其中的哪个？）将如何处理Unicode？</target>
        </trans-unit>
        <trans-unit id="19ce00dd1106586a8ff2ee123627cfb803c2703c" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">一个参考计数被盗，因此您可能需要执行 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="670ea0271b09cb55acf778b559eb456bd6341e38" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9dade105e4e2f60c0a165dad2f91b1cd7cbd6b9" translate="yes" xml:space="preserve">
          <source>One should write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">检查事情是否正确的一种简单方法是打印出perl查找库的硬编码 &lt;code&gt;@INC&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="40125cf7ac08509271fa2127b7fe01c46836ef0d" translate="yes" xml:space="preserve">
          <source>One solution for that could use &lt;code&gt;Number::Format&lt;/code&gt; like that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">解决您的问题的一种方法可能是自动升级。查看&lt;a href=&quot;../bigrat&quot;&gt;实用程序&lt;/a&gt;&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;，&lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt;和bigrat可以轻松实现此目的。</target>
        </trans-unit>
        <trans-unit id="2481b8adeee425ef556bd2bb817f713879888ab4" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43c39e037892e8d1c938d57ac2c0beb9ba304a9c" translate="yes" xml:space="preserve">
          <source>One subtest fails due to the uncommon structure of the Synology file system. The file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">其中一个概念是</target>
        </trans-unit>
        <trans-unit id="4c38cfb2cc0fa83015bbf2caee9f3438eaaff452" translate="yes" xml:space="preserve">
          <source>One such defect of standard &lt;code&gt;numf&lt;/code&gt; is to not be able to use a certain decimal precision. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d757b7ae7bf4edf5a451dca67abbf950db74e0a2" translate="yes" xml:space="preserve">
          <source>One such sequence is &lt;code&gt;\b&lt;/code&gt;, which matches a boundary of some sort. &lt;code&gt;\b{wb}&lt;/code&gt; and a few others give specialized types of boundaries. (They are all described in detail starting at &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt;.) Note that these don't match characters, but the zero-width spaces between characters. They are an example of a &lt;a href=&quot;#Assertions&quot;&gt;zero-width assertion&lt;/a&gt;. Consider again,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Perl 移植者需要注意的是</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">有一件事你可能不想依赖EBCDIC编码的标点符号,因为这些符号可能会因代码页的不同而不同(一旦你的模块或脚本据说可以使用EBCDIC,人们就会希望它可以使用所有EBCDIC字符集)。</target>
        </trans-unit>
        <trans-unit id="47095331b77aa8c0bd7b8cd8bf856b6f81ef9c2e" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, a stripped-down version the code which implements the addition operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">关于Perl源代码,你会注意到一件事,那就是它充满了宏。有人称宏的普遍使用是最难理解的东西,也有人认为它增加了清晰度。我们举个例子,实现加法运算符的代码。</target>
        </trans-unit>
        <trans-unit id="3d7413c1ef4de3f560bf3b6da33dd42dda59d66b" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">一种技巧是使用&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt;，它从文件末尾开始。该模块提供了一个包装实际文件句柄的对象，使您可以轻松地在文件中移动。到达所需的位置后，您可以获取实际的文件句柄并像往常一样使用它。在这种情况下，您将在要保留的最后一行的末尾找到文件位置，并将文件截断到该位置：</target>
        </trans-unit>
        <trans-unit id="867c8b371a8323be6dd9b1df9a9ab1f91f9da2fc" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits, including hexadecimal and binary digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd71d85a3c1d14096e3d0dd58527e3bd9ae1e0f0" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">一个有用值 &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; 是 &lt;code&gt;less -+C -E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16342fee4b1c5a929e46db4d5c80b063641a8ef3" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">我执行此操作的一种方法涉及替换运算符和double &lt;code&gt;/e&lt;/code&gt; 标志。第一个 &lt;code&gt;/e&lt;/code&gt; 在替换端求值 &lt;code&gt;$1&lt;/code&gt; ，并将其转换为 &lt;code&gt;$foo&lt;/code&gt; 。第二个/ e以 &lt;code&gt;$foo&lt;/code&gt; 开头，并将其替换为它的值。然后， &lt;code&gt;$foo&lt;/code&gt; 变成'Fred'，最后就是字符串中剩下的：</target>
        </trans-unit>
        <trans-unit id="bec707f167a013990074f651461c1eabbee251f8" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt;. The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt;, then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">一种方法是将返回值当作一个列表,并将其索引进去。</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">窥视Unicode字符的内部编码的一种方法是使用 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; 获取任意字符串编码碰巧的字节，或 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; 获取UTF-8编码的字节：</target>
        </trans-unit>
        <trans-unit id="77d927c43f13ed4bce0c8303d398089ab5954c32" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;unpack(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">在这种情况下，避免名称空间冲突的一种方法是将文件名转换为保证唯一的包名称，然后使用&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;将代码编译到该包中。在下面的示例中，每个文件仅被编译一次。或者，应用程序可能会选择不再需要与文件关联的符号表。&lt;a href=&quot;perlapi#call_argv&quot;&gt;在perlapi中&lt;/a&gt;使用call_argv，我们将调用子例程 &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; （位于文件 &lt;code&gt;persistent.pl&lt;/code&gt; 中)，并将文件名和布尔值cleanup / cache标志作为参数传递。</target>
        </trans-unit>
        <trans-unit id="dd0896a1b110e7eaa3676883c702b6cfbe8bca14" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;&quot;call_argv&quot; in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">一种方法是在您要查找的位置附近插入一个罕见的呼叫。例如，您可以在方法之前添加 &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="676f2533e9c53ebcfbdadc653fb856c314a5321b" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;study&lt;/code&gt; before your method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">了解Perl数据结构使用了多少内存的方法之一是安装CPAN的Devel::Size模块:它提供了存储特定数据结构所需的最小字节数。请注意size()和total_size()之间的区别。</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">绕过这个宏地狱的方法之一是使用在</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">您可以贡献的一种方式是为您安装的每个模块发送测试结果。如果安装了CPAN::Reporter模块,每当你在CPAN包上运行测试时,你就可以选择自动生成并向CPAN测试人员发送测试报告。</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">一个变通的办法是在Test::More (或任何其他测试模块)加载之前,尽可能早地将编码应用到STDOUT和STDERR。</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">人们会使用其中的一种。</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">单行命令提示</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">具有重定向或shell元字符的一参数system（）（请参阅&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;），exec（）（请参阅&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;）；</target>
        </trans-unit>
        <trans-unit id="ed7881b6406ffe431f1d2534257a9ed284c28da6" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;), exec() (see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">单行BLOCK可以放在一条线上,包括卷线。</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">单向可见性是指这些防火墙尽量使自己对防火墙内的用户不可见。FTP数据连接通常是通过向远程服务器发送你的IP地址,然后监听返回的连接来建立的。但由于防火墙的存在,远程服务器将无法与你连接。对于这种类型的防火墙,FTP连接需要在被动模式下进行。</target>
        </trans-unit>
        <trans-unit id="e8b6f242edd1b92d8a41abce051eb1d237af2a29" translate="yes" xml:space="preserve">
          <source>Only 'chunked' &lt;code&gt;Transfer-Encoding&lt;/code&gt; is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">仅 &lt;code&gt;#define&lt;/code&gt; 符号得到翻译；您仍然必须正确打包自己的参数以将其作为args传递给锁定函数等。</target>
        </trans-unit>
        <trans-unit id="67da903cfa08873440f868f7f70e613649689d61" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in &lt;code&gt;PL_op-&amp;gt;op_targ&lt;/code&gt;), wasting a name SV for them doesn't make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">只测试了Intel C++Compiler v12.1。其他版本可能也可以使用。使用Intel C++Compiler代替Visual C的好处是可以兼容C99,这也是一些CPAN XS模块所需要的,同时与Visual C对象代码和Visual C调试基础架构保持兼容,而不像GCC。</target>
        </trans-unit>
        <trans-unit id="2928fa0640b76bf7cac1897ae55dedc071303baa" translate="yes" xml:space="preserve">
          <source>Only a few characters (all of them being ASCII punctuation characters) are metacharacters. The most commonly used one is a dot &lt;code&gt;&quot;.&quot;&lt;/code&gt;, which normally matches almost any character (including a dot itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">仅在5.9及以后的版本中可用。</target>
        </trans-unit>
        <trans-unit id="30aa8b56cc2760e31377798957b93c84973ea0a2" translate="yes" xml:space="preserve">
          <source>Only certain operations (all originating outside Perl) should be affected, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">只有某些源自Perl之外的操作才会受到影响,具体如下:</target>
        </trans-unit>
        <trans-unit id="be338b7ec52f196b66facaa0396ba0dea14b732e" translate="yes" xml:space="preserve">
          <source>Only gives you a reader, no &lt;code&gt;set_foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc54816219df4139d06acf1bbc8f828314bd1c1" translate="yes" xml:space="preserve">
          <source>Only gives you a write (&lt;code&gt;set_foo&lt;/code&gt;), no &lt;code&gt;foo&lt;/code&gt; method is defined at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">只适用于改变 &quot;所有者 &quot;和 &quot;其他 &quot;读写访问。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">只适合改变 &quot;所有者 &quot;的读写权限,&quot;组&quot;,&quot;其他 &quot;位没有意义。(Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">只有十六进制数字在方括号之间有效。如果遇到无效字符,将发出警告,无效字符和括号内所有后续字符(有效或无效)将被丢弃。</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 之后仅十六进制数字有效。当 &lt;code&gt;\x&lt;/code&gt; 后跟少于两个有效数字时，任何有效数字都将补零。这意味着 &lt;code&gt;\x7&lt;/code&gt; 将被解释为 &lt;code&gt;\x07&lt;/code&gt; ，而单独的 &lt;code&gt;&quot;\x&quot;&lt;/code&gt; 将被解释为 &lt;code&gt;\x00&lt;/code&gt; 。除字符串末尾外，少于两个有效数字将导致警告。请注意，尽管警告指出非法字符将被忽略，但它仅作为转义的一部分而被忽略，仍将用作字符串中的后续字符。例如：</target>
        </trans-unit>
        <trans-unit id="2b0998a6fdfd5f4525206c6e0b3be59bf209f58a" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt;. When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt;, and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt;. Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">包的符号表中仅存储以字母（或下划线）开头的标识符。所有其他符号都保留在包 &lt;code&gt;main&lt;/code&gt; 中，包括所有标点符号变量，例如$ _。另外，如果不合格，则标识符STDIN，STDOUT，STDERR，ARGV，ARGVOUT，ENV，INC和SIG被强制放入包 &lt;code&gt;main&lt;/code&gt; 中，即使用于内置目的之外的其他目的。如果您有一个名为 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 的程序包，则不能使用标识符的限定形式，因为它会被解释为模式匹配，替换或音译。</target>
        </trans-unit>
        <trans-unit id="5258552aeae790433b734336886e3f62b2ea5d9a" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt;, including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt;, even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;y&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">仅在套接字上实现。(Win32,VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">只有在非常早期的版本中才会出现;是一个子集。</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">仅在极少数情况下，才需要使用Unicode（而不是本机）代码点来处理代码。在这几种情况下，请改用 &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1d353340ff172b5c39b6a28e69782441add5fac" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead. If you are not absolutely sure this is one of those cases, then assume it isn't and use plain &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">只记录错误。</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">只有当PADNAMEt_OUTER被设置时才有意义。</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">只有我/我们的可变插槽会获得有效的名称。其余的是操作目标/ GV /常量，它们在编译时静态分配或解析。这些没有名称，可以在运行时通过我的/我们的变量通过eval&amp;ldquo;''从Perl代码中查找它们。由于不能通过&amp;ldquo;名称&amp;rdquo;来查找它们，而只能通过在编译时分配的索引来查找它们（通常在PL_op-&amp;gt; op_targ中），因此为它们浪费名称SV是没有意义的。</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">仅在VMS（路径的文件和目录部分之间没有歧义）和AmigaOS（可能由于此模块中的实现古怪）上， &lt;code&gt;dirname()&lt;/code&gt; 就像 &lt;code&gt;fileparse($path)&lt;/code&gt; 一样工作，仅返回$ dirs。</target>
        </trans-unit>
        <trans-unit id="3f431144993e10d84cbfadd9a3e65deba1582a5e" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt;, returning just the $dirs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">只允许使用一种编码。如果你在一个程序中组合了具有不同编码的模块,那么实际上只会使用一种编码。</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">一次只能计数一个计时器。每次调用都会禁用前一个计时器，并且可以提供一个参数 &lt;code&gt;0&lt;/code&gt; 来取消前一个计时器而无需启动新的计时器。返回的值是前一个计时器上剩余的时间。</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">只有包变量(globals,即使是本地化的)对符号引用是可见的。词法变量(用my()声明)不在符号表中,因此对这个机制是不可见的。例如</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">只有读取访问（通过获取值或 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; ）才导致对函数的调用。修改访问的执行与普通哈希相同。</target>
        </trans-unit>
        <trans-unit id="52379b3e8ed9b5889624849f89178e4a78f9060a" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;exists&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">仅在插座上可靠。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="3d6a8b56f94127e52f27217f818b2868b3bb285a" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;&quot;add_style&quot;&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;&quot;add_callback&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">标准样式仅使用其中一些样式，如果您希望添加使用它们的新样式（请参见下面的&lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt;），则提供了其他样式供您深入研究optree机制。您也可以使用&lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;添加新对象。</target>
        </trans-unit>
        <trans-unit id="e48dbe443fdc8ea64a9d98b0d46ac35972125215" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Bzip2&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2aad383963ab78287aafa9360d0376650b94059" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Lzma&lt;/code&gt; module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">只找到至少包含一条有效的POD命令的文本文件。</target>
        </trans-unit>
        <trans-unit id="f768ea168f773a1d4344405cac8e79c05d1cb7bc" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;&quot;\&quot;&lt;/code&gt; is always a metacharacter. The others are metacharacters just sometimes. The following tables lists all of them, summarizes their use, and gives the contexts where they are metacharacters. Outside those contexts or if prefixed by a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, they match their corresponding punctuation character. In some cases, their meaning varies depending on various pattern modifiers that alter the default behaviors. See &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">只有INPUT部分实现了(Perl转XSUB),核心和CPAN上没有已知的用户。</target>
        </trans-unit>
        <trans-unit id="71019c006a2a3164840206c64e5cdd82e48eb2b0" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; is considered. (This is important only if &lt;code&gt;&quot;S&quot;&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">仅考虑与 &lt;code&gt;S&lt;/code&gt; 的最佳匹配。（这仅在 &lt;code&gt;S&lt;/code&gt; 具有捕获括号并且在整个正则表达式的其他位置使用反向引用时才重要。）</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">仅支持最新的运行时，当前为 &lt;code&gt;0.9d fix 03&lt;/code&gt; 。Perl可以在EMX的早期版本下运行，但这未经测试。</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">只更新修改时间。(VMS,RISC OS)</target>
        </trans-unit>
        <trans-unit id="a5196d88a77f964c944cd0486d4d8632d3d224b8" translate="yes" xml:space="preserve">
          <source>Only the values for English are returned. &lt;code&gt;YESSTR&lt;/code&gt; and &lt;code&gt;NOSTR&lt;/code&gt; have been removed from POSIX 2008, and are retained here for backwards compatibility. Your platform's &lt;code&gt;nl_langinfo&lt;/code&gt; may not support them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">仅支持Perl 5.9.4</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">仅在r-magic上有效,返回存储在MAGIC中的REGEX的整数值。</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">仅在r-magic上有效,返回生成regexp的字符串。</target>
        </trans-unit>
        <trans-unit id="b4b3937a0e7df666bbee5731bdcd7cfebd5a56b8" translate="yes" xml:space="preserve">
          <source>Only votes if $source is an array, or a scalar with newlines. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6f39472d96fc49b5d83aad7e124fec307fa8f3" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977cc058c727306e27dd1d2114879e4b0b58691f" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a regular file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30aa9fef235074c84d54a1603c93e02bcc5a7db6" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like an executable file. Casts the following votes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">只有当perl用ithreads编译时才会出现。</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">里面有很多非常有用的信息--这似乎是前进的方向。</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">糟糕，我们忘记了一件事：如果模式开头有空格怎么办？ &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; 将 &lt;code&gt;U&lt;/code&gt; 作为第一个活动字符，即使它不是模式中的第一件事。在这种情况下，当我们看到空格时，我们必须将 &lt;code&gt;patcopy&lt;/code&gt; 和 &lt;code&gt;pat&lt;/code&gt; 一起推进：</target>
        </trans-unit>
        <trans-unit id="fe3ce4b3ad2d706be60b57c6678f0db7ee5828e3" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;pack(&quot; U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63b9b9665fa74c8ca88979a5af8db7577060be" translate="yes" xml:space="preserve">
          <source>OpHAS_SIBLING</source>
          <target state="translated">OpHAS_SIBLING</target>
        </trans-unit>
        <trans-unit id="8df5fc95b743ffdf06c754aebef9648088f82a06" translate="yes" xml:space="preserve">
          <source>OpLASTSIB_set</source>
          <target state="translated">OpLASTSIB_set</target>
        </trans-unit>
        <trans-unit id="6a2ac06a5c16d049ff2c9de33162907d6eaa1974" translate="yes" xml:space="preserve">
          <source>OpMAYBESIB_set</source>
          <target state="translated">OpMAYBESIB_set</target>
        </trans-unit>
        <trans-unit id="95d54e30cf7a8a2ef55bbad2e9fb47bd84433509" translate="yes" xml:space="preserve">
          <source>OpMORESIB_set</source>
          <target state="translated">OpMORESIB_set</target>
        </trans-unit>
        <trans-unit id="ad6188b517e063a47318e5c2bad924c90d8e314e" translate="yes" xml:space="preserve">
          <source>OpSIBLING</source>
          <target state="translated">OpSIBLING</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Opcode-编译perl代码时禁用命名的操作码。</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">操作码功能</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">打开压缩文件中的 &quot;会员名 &quot;进行阅读。</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">打开/dev/tty并在上面使用TIOCNOTTY ioctl。请看</target>
        </trans-unit>
        <trans-unit id="bc45a01f475e91b2d1ed078654549eddc2aa2632" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See &lt;a href=&quot;http://man.he.net/man1/tty&quot;&gt;tty(1)&lt;/a&gt; for details. Or better yet, you can just use the &lt;code&gt;POSIX::setsid()&lt;/code&gt; function, so you don't have to worry about process groups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">V2R8以后的开放版(UNIX系统服务)确实支持#!/path/to/perl脚本调用。IBM公司为V2R7提供了一个PTF,它将允许shell/kernel支持#!。V2R7之前的USS版本不支持#!的脚本调用方式。如果你正在运行V2R6或更早的版本,那么请看。</target>
        </trans-unit>
        <trans-unit id="adcf2a78c9cad4950930fad20f18fb46173fc5ee" translate="yes" xml:space="preserve">
          <source>Open Perl IDE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDE是一个集成的开发环境,用于在Windows 95/98/NT/2000下使用ActiveState的ActivePerl发行版编写和调试Perl脚本。</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">打开一个目录进行阅读。</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">打开一个文件进行读写。</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">打开一个文件以进行读取以进行写入。这将返回文件描述符，而不是Perl文件句柄。使用 &lt;code&gt;POSIX::close&lt;/code&gt; 关闭文件。</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">打开一个文件进行写入,并进行截断。</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">用模式0666打开一个只读文件。</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">使用open2()打开一个读写进程。</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">使用open3()打开一个进程进行读写和错误处理。</target>
        </trans-unit>
        <trans-unit id="3de25d7ff3a7f69d51ceb431d7513e0facbf39f4" translate="yes" xml:space="preserve">
          <source>Open a shell on the Synology using ssh and become root.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e426002e74b080358a024e5f7a561b3384b60d" translate="yes" xml:space="preserve">
          <source>Open directory handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a5a34e79d6531a1ea990bc264a097033a1025e" translate="yes" xml:space="preserve">
          <source>Open filehandles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92666893f36170e45fd93845fbf133686bc20a39" translate="yes" xml:space="preserve">
          <source>Open handles to files, directories and network sockets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open成功则返回非零值，否则返回未定义的值。如果 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 涉及管道，则返回值恰好是子流程的pid。</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Open成功则返回非零值，否则返回未定义的值。如果 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 涉及管道，则返回值恰好是子流程的pid。</target>
        </trans-unit>
        <trans-unit id="f405ae83374967e27b5349888fde9a222df40df7" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;open&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">Open应该（也许间接地）调用 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; 在表中分配一个插槽，并通过调用 &lt;code&gt;PerlIO_push&lt;/code&gt; 将其与打开文件的层信息相关联。的</target>
        </trans-unit>
        <trans-unit id="6ae8476e410284d0c0ba1054077caf01d110fd6a" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt;. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b90a08dc8612f90c1076481f4ad779beb7a5f7e" translate="yes" xml:space="preserve">
          <source>Open the scalar handle on a new scalar, pointed to by SCALARREF. If no SCALARREF is given, a &quot;private&quot; scalar is created to hold the file data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">使用选项 &lt;code&gt;ndelay&lt;/code&gt; 和 &lt;code&gt;pid&lt;/code&gt; 以及设施 &lt;code&gt;LOCAL0&lt;/code&gt; 打开系统日志：</target>
        </trans-unit>
        <trans-unit id="8811a98a6a9653fddfc77b8259113c776713824a" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt;, and with facility &lt;code&gt;LOCAL0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads.</target>
        </trans-unit>
        <trans-unit id="64310839a246c6fc794d722f4304cd08f25d7b05" translate="yes" xml:space="preserve">
          <source>OpenVMS</source>
          <target state="translated">OpenVMS</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1和更高版本以及所有版本的OpenVMS I64支持区分大小写作为过程设置（请参阅 &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; ）。Perl当前不支持VMS区分大小写，但是将来可能会支持，因此Perl程序应使用 &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; 方法确定状态，而不是 &lt;code&gt;$^O&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="f9ff604a4dd28e6202581dca695c5bed829ec062" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt;). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">打开二进制文件</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">开启管道</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">打开文本文件</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">打开文本文件进行阅读</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">打开文本文件进行写作</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">打开Berkeley DB数据库文件</target>
        </trans-unit>
        <trans-unit id="03b0ff1f775aaa0c11a96201f8ff9e088550422d" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into a command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af9988c3fefcdee028653737bea0a8e9c417094" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into an in-memory scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821c0d97ab3d21f2ce24f411389616d6c9dc3c0d" translate="yes" xml:space="preserve">
          <source>Opening a pipe for reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1420eefdd30517effef954306a645ff5d1c69e" translate="yes" xml:space="preserve">
          <source>Opening a pipe for writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">在某些平台上,打开一个进程不会自动刷新输出句柄。(SunOS,Solaris,HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">打开和设置功能</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">当条件跨越多行时,用 &quot;if &quot;开头括号行,否则应在行尾。</target>
        </trans-unit>
        <trans-unit id="4ac11216b92d2f325685b22de245cded12e40d13" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">轻量级回调的开括号。请参阅&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall中的轻量级回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="626f042395527b903c8db8f898fdb1f1cdc87f96" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;&lt;a href=&quot;#PUTBACK&quot;&gt;&quot;PUTBACK&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调参数的左括号。请参阅 &lt;code&gt;PUTBACK&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31ad94341ea4379f427305bb05c070cf8053b4ad" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;&lt;a href=&quot;#FREETMPS&quot;&gt;&quot;FREETMPS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调临时成员的开括号。请参阅 &lt;code&gt;FREETMPS&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e132601e5a7953c8bcffa1c453157f71ea1d34e" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;&lt;a href=&quot;#LEAVE&quot;&gt;&quot;LEAVE&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调的左括号。参见 &lt;code&gt;LEAVE&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">开头大写与关键词在同一行,如有可能,否则要排队。</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">如果使用stdio(普通的perl文件句柄),目前不支持打开文件进行读写。</target>
        </trans-unit>
        <trans-unit id="414a4a46ddb98d37ef4a18659fc5e836c58095fc" translate="yes" xml:space="preserve">
          <source>Opening in-memory files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">不支持以只写或追加模式打开数据文件。</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">在追加模式下打开 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96c4834766ebccdcd74e84c8bb745c2565822fc0" translate="yes" xml:space="preserve">
          <source>Opens a Perl file handle based on an already open Win32 native file handle [much like C's &lt;code&gt;fdopen()&lt;/code&gt; does with a file descriptor]. Returns a true value if the open operation succeeded. For failure, returns a false value and sets &lt;code&gt;$!&lt;/code&gt; [and possibly &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;] to the reason for the failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8372328aea71570194ef6ece0a3348d285cc61e1" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#telldir-DIRHANDLE&quot;&gt;&lt;code&gt;telldir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seekdir-DIRHANDLE%2CPOS&quot;&gt;&lt;code&gt;seekdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#rewinddir-DIRHANDLE&quot;&gt;&lt;code&gt;rewinddir&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#closedir-DIRHANDLE&quot;&gt;&lt;code&gt;closedir&lt;/code&gt;&lt;/a&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. Dirhandles are the same objects as filehandles; an I/O object can only be open as one of these handle types at once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">打开一个名为EXPR的目录，以供 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 处理。如果成功，则返回true。 DIRHANDLE可以是一个表达式，其值可以用作间接dirhandle，通常是实际dirhandle名称。如果DIRHANDLE是未定义的标量变量（或数组或哈希元素），则为该变量分配对新匿名目录句柄的引用。也就是说，它是自动生存的。 DIRHANDLE具有与FILEHANDLE分开的名称空间。</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">打开一个名为EXPR的目录，以供 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 处理。如果成功，则返回true。 DIRHANDLE可以是一个表达式，其值可以用作间接dirhandle，通常是实际dirhandle名称。如果DIRHANDLE是未定义的标量变量（或数组或哈希元素），则为该变量分配对新匿名目录句柄的引用。也就是说，它是自动生存的。 DIRHANDLE具有与FILEHANDLE分开的名称空间。</target>
        </trans-unit>
        <trans-unit id="249fc18914652625c802e629d561a8d541cf9f3e" translate="yes" xml:space="preserve">
          <source>Opens a file descriptor [&lt;code&gt;$ivFD&lt;/code&gt;] based on an already open Win32 native file handle, &lt;code&gt;$hNativeHandle&lt;/code&gt;. This just calls the Win32-specific C routine &lt;code&gt;_open_osfhandle()&lt;/code&gt; or Perl's &quot;improved&quot; version called &lt;code&gt;win32_open_osfhandle()&lt;/code&gt;. Prior to Perl5.005 and in Cygwin Perl, C's &lt;code&gt;_open_osfhandle()&lt;/code&gt; is called which will fail if &lt;code&gt;GetFileType($hNativeHandle)&lt;/code&gt; would return &lt;code&gt;FILE_TYPE_UNKNOWN&lt;/code&gt;. For Perl5.005 and later, &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; calls &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; from the Perl DLL which doesn't have this restriction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2665f3d96f1b25c433ed44735df54d5716eb0ca" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">打开一对连接的管道，如相应的系统调用。请注意，如果您设置了管道处理循环，除非非常小心，否则可能会发生死锁。另外，请注意，Perl的管道使用IO缓冲，因此您可能需要设置 &lt;code&gt;$|&lt;/code&gt; 在每个命令之后刷新WRITEHANDLE，具体取决于应用程序。</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">打开指定种类的套接字，并将其附加到文件句柄SOCKET。指定的DOMAIN，TYPE和PROTOCOL与具有相同名称的syscall相同。您应该首先 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 来导入正确的定义。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">打开指定种类的套接字，并将其附加到文件句柄SOCKET。指定的DOMAIN，TYPE和PROTOCOL与具有相同名称的syscall相同。您应该首先 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 来导入正确的定义。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="bd4febc0253215fa9b6c0a61a1123c275d66541f" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;use Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b29b07c25945e487dbff4de1e81a446b3bf071a" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and returns it. Domain, type, and protocol are specified the same as for the syscall of the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">打开文件名由EXPR给出的文件,并将其与FILEHANDLE关联。</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">打开文件名由FILENAME给出的文件,并将其与FILEHANDLE关联。如果FILEHANDLE是一个表达式,那么它的值将被用作真正的文件柄;一个未定义的标量将被适当地自动转换。这个函数调用底层操作系统的</target>
        </trans-unit>
        <trans-unit id="4b9ccea513e25adc54a594c4a2c7b7e82197b4e8" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; function with the parameters FILENAME, MODE, and PERMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">打开系统日志。 &lt;code&gt;$ident&lt;/code&gt; 在每个消息之前。 &lt;code&gt;$logopt&lt;/code&gt; 包含零个或多个下面详细说明的选项。 &lt;code&gt;$facility&lt;/code&gt; 指定要报告的系统部分，例如 &lt;code&gt;LOG_USER&lt;/code&gt; 或 &lt;code&gt;LOG_LOCAL0&lt;/code&gt; ：请参阅&lt;a href=&quot;#Facilities&quot;&gt;设施&lt;/a&gt;以获取知名设施的列表，以及有关系统中可用设施的 &lt;code&gt;syslog(3)&lt;/code&gt; 文档。还请&lt;a href=&quot;#SEE-ALSO&quot;&gt;参阅&lt;/a&gt; &amp;ldquo;有用的链接&amp;rdquo;。设施可以以字符串或数字宏的形式给出。</target>
        </trans-unit>
        <trans-unit id="d67ac2c393c850f9198943cd6ad27b36c7d7a81b" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt;: see &lt;a href=&quot;#Facilities&quot;&gt;&quot;Facilities&quot;&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7ead7f438c26f4d24f0c5553cfa1b2b48237a8" translate="yes" xml:space="preserve">
          <source>Operand with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">操作系统接口</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">对哈希的引用进行操作。</target>
        </trans-unit>
        <trans-unit id="ac9fb6f30a90f215146103f81004effdabcea9ae" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for UTF-16 surrogate U+%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b576c5bb0b11a4350e3bf4fdc21259831b2084c" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for non-Unicode code point 0x%X</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d671b8f2f76102a15b0bf4d4a39249d6ad4b4ece" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot;: no method found, %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">使用重载操作符的操作会保留参数,这正是你所期望的。</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">使用重载操作符的操作会保留参数,这正是你所期望的。</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">操作员名称和操作员列表</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">操作员超载</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">操作者优先和关联性</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">操作员关联性</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">运算符实现（值）可以是子例程，对子例程的引用或匿名子例程-换句话说，在 &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; 调用中合法的任何内容。指定为字符串的值将解释为方法名称。从而</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">操作符名称通常是小写的单词,如enterloop、leaveloop、last、next、redo等。有时它们是相当神秘的,比如gv2cv、i_ncmp和ftsvtx。</target>
        </trans-unit>
        <trans-unit id="0bc65caf3b0a75a378aedfadf66730c78a4537cf" translate="yes" xml:space="preserve">
          <source>Operator or semicolon missing before %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">操作者优先</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">操作符优先性和关联性在 Perl 中的工作方式与数学中差不多。</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">操作符标签可以用来指代操作符的组(或组)。标签名称总是以冒号开头。Opcode模块定义了几个optag,用户可以使用define_optag函数定义其他的optag。</target>
        </trans-unit>
        <trans-unit id="093964ff1bd20f7f1bfa027cf984852f6646a0fc" translate="yes" xml:space="preserve">
          <source>Operator vs literal overloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">处理文件名的操作符就是例子。</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; 等运算符将参数强制为浮点格式。</target>
        </trans-unit>
        <trans-unit id="004496b42fcc360f8e82fa5c56c3b096a2155421" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; force arguments to floating point format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1c419f9c87704707f20d16f008ba41b567fa7e" translate="yes" xml:space="preserve">
          <source>Operators which expect a string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192b9459597426145afa81f1d9a3ad900bb8bd5d" translate="yes" xml:space="preserve">
          <source>Operators which expect an integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">像chdir这样的操作显然会影响整个过程,而不仅仅是隔间里的代码。rand和srand等操作也有类似但更微妙的影响。</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">可以使用perl位向量运算符＆（和）来操作Opset。（或），^（异或）和〜（取反/取反）。</target>
        </trans-unit>
        <trans-unit id="0b7b13995f2b05a4fbd9b6bef85fdd40cc461955" translate="yes" xml:space="preserve">
          <source>OptiPerl</source>
          <target state="translated">OptiPerl</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl是一个具有模拟CGI环境的Windows IDE,包括调试器和语法高亮编辑器。</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">优化数据;可能会有变化。</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">优化标志;可能会有变化。</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="6bc76b02fc66f0ca691dc22aabcdcd333e409136" translate="yes" xml:space="preserve">
          <source>Optimization of regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">优化后的旁门左道语句呈现为'??'。这包括那些在编译时有副作用的语句,例如晦涩的</target>
        </trans-unit>
        <trans-unit id="40dbe8ccfe714d9a944d448d1c3b1b3c2bfff946" translate="yes" xml:space="preserve">
          <source>Optimizing</source>
          <target state="translated">Optimizing</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">对 &lt;code&gt;p5p&lt;/code&gt; 进行进一步优化是一项工作。</target>
        </trans-unit>
        <trans-unit id="7d18d459b985af7984ff90200899087216246ead" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">选项格式</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">期权粘性</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">选项词用逗号(不是空格)隔开,并遵循编译器后台选项的通常惯例。</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">选项、参数、参数和配置文件处理。</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">可选-当该层即将被移除时调用。</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">可选-如果不存在,则由下层进行打开。如果存在,在层被推送后调用,用于传递数字文件描述符的打开。这个函数可能会改变,因为没有简单的方法让下层做打开,然后重新获得控制权。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
