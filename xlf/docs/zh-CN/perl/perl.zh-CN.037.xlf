<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="883c9501bfde5d52c5604a1b12447c3d9a8fe23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_MARK_EARLY&lt;/code&gt; set, then the handling of a GV reference is modified. If a GV was examined and its CV slot was found to be empty, then the &lt;code&gt;gv&lt;/code&gt; op has the &lt;code&gt;OPpEARLY_CV&lt;/code&gt; flag set. If the op is not optimised away, and the CV slot is later populated with a subroutine having a prototype, that flag eventually triggers the warning &quot;called too early to check prototype&quot;.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 将 &lt;code&gt;RV2CVOPCV_MARK_EARLY&lt;/code&gt; 位置1，则将修改GV参考的处理。如果检查了GV且发现其CV插槽为空，则 &lt;code&gt;gv&lt;/code&gt; op设置了 &lt;code&gt;OPpEARLY_CV&lt;/code&gt; 标志。如果没有对op进行优化，并且CV插槽随后填充了具有原型的子例程，则该标志最终会触发警告&amp;ldquo;调用时过早，无法检查原型&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="94ba87252f4445bc6642c895685a2b0c13a4c9f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the bit &lt;code&gt;RV2CVOPCV_RETURN_NAME_GV&lt;/code&gt; set, then instead of returning a pointer to the subroutine it returns a pointer to the GV giving the most appropriate name for the subroutine in this context. Normally this is just the &lt;code&gt;CvGV&lt;/code&gt; of the subroutine, but for an anonymous (&lt;code&gt;CvANON&lt;/code&gt;) subroutine that is referenced through a GV it will be the referencing GV. The resulting &lt;code&gt;GV*&lt;/code&gt; is cast to &lt;code&gt;CV*&lt;/code&gt; to be returned. A null pointer is returned as usual if there is no statically-determinable subroutine.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 设置了 &lt;code&gt;RV2CVOPCV_RETURN_NAME_GV&lt;/code&gt; 位，则与其返回指向该子例程的指针，不返回指向GV的指针，该指针为该上下文中的子例程提供最合适的名称。通常，这只是子例程的 &lt;code&gt;CvGV&lt;/code&gt; ，但是对于通过GV引用的匿名（ &lt;code&gt;CvANON&lt;/code&gt; ）子例程，它将是引用GV。生成的 &lt;code&gt;GV*&lt;/code&gt; 被强制转换为 &lt;code&gt;CV*&lt;/code&gt; 以返回。如果没有静态可确定的子例程，则照常返回空指针。</target>
        </trans-unit>
        <trans-unit id="242a2d0b6758ae9991c2578558a99b10e3dde258" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; in non-zero, it can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, and with the same meanings.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 的值非零，则可以是 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 接受的 &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; 标志的任意组合，并且含义相同。</target>
        </trans-unit>
        <trans-unit id="16ac1f6f577ac784401bb8130dc871e9c34ad1b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, any well-formed UTF-8, as extended by Perl, is accepted without restriction. If the final few bytes of the buffer do not form a complete code point, this will return TRUE anyway, provided that &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char_flags&quot;&gt;&quot;is_utf8_valid_partial_char_flags&quot;&lt;/a&gt;&lt;/code&gt; returns TRUE for them.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为0，则不受限制地接受Perl扩展的任何格式正确的UTF-8。如果缓冲区的最后几个字节没有形成完整的代码点，则只要 &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char_flags&quot;&gt;&quot;is_utf8_valid_partial_char_flags&quot;&lt;/a&gt;&lt;/code&gt; 为它们返回TRUE，无论如何它将返回TRUE。</target>
        </trans-unit>
        <trans-unit id="23848029d478b456b26bba2286d77574bebc75c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this behaves identically to &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char&quot;&gt;&quot;is_utf8_valid_partial_char&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; can be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags accepted by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. If there is any sequence of bytes that can complete the input partial character in such a way that a non-prohibited character is formed, the function returns TRUE; otherwise FALSE. Non character code points cannot be determined based on partial character input. But many of the other possible excluded types can be determined from just the first one or two bytes.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为0，则其行为与 &lt;code&gt;&lt;a href=&quot;#is_utf8_valid_partial_char&quot;&gt;&quot;is_utf8_valid_partial_char&quot;&lt;/a&gt;&lt;/code&gt; 相同。否则， &lt;code&gt;flags&lt;/code&gt; 可以是 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 接受的 &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; 标志的任意组合。如果有任何字节序列可以完成输入部分字符的方式，从而形成一个非禁止字符，则该函数返回TRUE；否则，该函数返回TRUE。否则为FALSE。无法根据部分字符输入来确定非字符代码点。但是，许多其他可能的排除类型只能从前一个或两个字节中确定。</target>
        </trans-unit>
        <trans-unit id="7776c59483454fdc128e37c2b654f9e899314281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this function accepts any code point from 0..&lt;code&gt;IV_MAX&lt;/code&gt; as input. &lt;code&gt;IV_MAX&lt;/code&gt; is typically 0x7FFF_FFFF in a 32-bit word.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为0，则此函数接受0 &lt;code&gt;IV_MAX&lt;/code&gt; 任何代码点。IV_MAX作为输入。在32位字中， &lt;code&gt;IV_MAX&lt;/code&gt; 通常为0x7FFF_FFFF。</target>
        </trans-unit>
        <trans-unit id="10e5eab05bd09c8fe9f56a01b844bac5e3765d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为0，则结果与 &lt;code&gt;&lt;a href=&quot;#isUTF8_CHAR&quot;&gt;&quot;isUTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 相同；如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; ，则结果与 &lt;code&gt;&lt;a href=&quot;#isSTRICT_UTF8_CHAR&quot;&gt;&quot;isSTRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 相同；如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; ，则结果与 &lt;code&gt;&lt;a href=&quot;#isC9_STRICT_UTF8_CHAR&quot;&gt;&quot;isC9_STRICT_UTF8_CHAR&quot;&lt;/a&gt;&lt;/code&gt; 相同。否则， &lt;code&gt;flags&lt;/code&gt; 可以是 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 理解的 &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; 标志的任意组合，含义相同。</target>
        </trans-unit>
        <trans-unit id="c01ee327fde250472c539a32455541306b4bc120" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is 0, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;; and if &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt;, this gives the same results as &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise &lt;code&gt;flags&lt;/code&gt; may be any combination of the &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; flags understood by &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;, with the same meanings.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 为0，则结果与 &lt;code&gt;&lt;a href=&quot;#is_utf8_string&quot;&gt;&quot;is_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; 相同；如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_INTERCHANGE&lt;/code&gt; ，则结果与 &lt;code&gt;&lt;a href=&quot;#is_strict_utf8_string&quot;&gt;&quot;is_strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; 相同；如果 &lt;code&gt;flags&lt;/code&gt; 为 &lt;code&gt;UTF8_DISALLOW_ILLEGAL_C9_INTERCHANGE&lt;/code&gt; ，则结果与 &lt;code&gt;&lt;a href=&quot;#is_c9strict_utf8_string&quot;&gt;&quot;is_c9strict_utf8_string&quot;&lt;/a&gt;&lt;/code&gt; 相同。否则， &lt;code&gt;flags&lt;/code&gt; 可以是 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 理解的 &lt;code&gt;UTF8_DISALLOW_&lt;i&gt;foo&lt;/i&gt;&lt;/code&gt; 标志的任意组合，含义相同。</target>
        </trans-unit>
        <trans-unit id="3ef48bc44bf4f8b7aeee22cccd386b0d4dcfb8f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; , arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; , overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame
&amp;amp; 16&lt;/code&gt; , the return value from the subroutine is printed.</source>
          <target state="translated">如果为 &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; ，则输出函数的参数，以及上下文和调用者信息。如果为 &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; ，则在打印的参数上启用重载的 &lt;code&gt;stringify&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; 。如果为 &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; ，则打印子例程的返回值。</target>
        </trans-unit>
        <trans-unit id="f6ef7c333faaf2cb26f8747450c37161f8d75370" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame &amp;amp; 4&lt;/code&gt;, arguments to functions are printed, plus context and caller info. If &lt;code&gt;frame &amp;amp; 8&lt;/code&gt;, overloaded &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;tie&lt;/code&gt;d &lt;code&gt;FETCH&lt;/code&gt; is enabled on the printed arguments. If &lt;code&gt;frame &amp;amp; 16&lt;/code&gt;, the return value from the subroutine is printed.</source>
          <target state="translated">如果为 &lt;code&gt;frame &amp;amp; 4&lt;/code&gt; ，则输出函数的参数，以及上下文和调用者信息。如果为 &lt;code&gt;frame &amp;amp; 8&lt;/code&gt; ，则在打印的参数上启用重载的 &lt;code&gt;stringify&lt;/code&gt; 和 &lt;code&gt;tie&lt;/code&gt; d &lt;code&gt;FETCH&lt;/code&gt; 。如果为 &lt;code&gt;frame &amp;amp; 16&lt;/code&gt; ，则打印子例程的返回值。</target>
        </trans-unit>
        <trans-unit id="b54e3981c02655a1fab1a806eaa02120a0c9bfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;function&lt;/code&gt; was the name of a function, then &lt;code&gt;memoize&lt;/code&gt; hides the old version and installs the new memoized version under the old name, so that &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; actually invokes the memoized version.</source>
          <target state="translated">如果 &lt;code&gt;function&lt;/code&gt; 是函数的名称，则 &lt;code&gt;memoize&lt;/code&gt; 隐藏旧版本，并以旧名称安装新的备忘录版本，以便 &lt;code&gt;&amp;amp;function(...)&lt;/code&gt; 实际上会调用备忘录版本。</target>
        </trans-unit>
        <trans-unit id="4823580da2e2f493ed7ea495228a6fb43531c2a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;get_handle&lt;/code&gt; 感觉到它正在作为CGI调用的程序中运行，则它将尝试从环境变量&amp;ldquo; HTTP_ACCEPT_LANGUAGE&amp;rdquo;中获取语言标签，并假装这些语言是作为参数传递给 &lt;code&gt;get_handle&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="7b8f1bd59bcb9836018bddcc2b5f32a734b99099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get_handle&lt;/code&gt; senses that it's running in program that was invoked as a CGI, then it tries to get language-tags out of the environment variable &quot;HTTP_ACCEPT_LANGUAGE&quot;, and it pretends that those were the languages passed as parameters to &lt;code&gt;get_handle&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;get_handle&lt;/code&gt; 感觉到它正在作为CGI调用的程序中运行，则它将尝试从环境变量&amp;ldquo; HTTP_ACCEPT_LANGUAGE&amp;rdquo;中获取语言标签，并假装这些语言是作为参数传递给 &lt;code&gt;get_handle&lt;/code&gt; 的。</target>
        </trans-unit>
        <trans-unit id="0a5501c614e6eee43f2f2b50112bdb8a824a2fea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a completely empty typeglob, it is deleted from the stash.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是完全空的typeglob，则将其从存储中删除。</target>
        </trans-unit>
        <trans-unit id="171c792393c3bd16ce8492fbf51df1d34df47fa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob containing only a sufficiently-ordinary constant sub, the typeglob is replaced with a scalar-reference placeholder that more compactly represents the same thing.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是仅包含足够普通的常数sub的typeglob，则将typeglob替换为更紧凑地表示同一事物的标量引用占位符。</target>
        </trans-unit>
        <trans-unit id="91c336e511b07c506517b1f2fbdfac89a7b69625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是一个typeglob，其子例程条目是可以进行内联的常量子程序，或者 &lt;code&gt;gv&lt;/code&gt; 是一个占位符引用，将被提升为此类typeglob，则返回该子程序返回的值。否则，返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15863e2e3bcfe9bf34415295eb886e40c8b84a73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gv&lt;/code&gt; is a typeglob whose subroutine entry is a constant sub eligible for inlining, or &lt;code&gt;gv&lt;/code&gt; is a placeholder reference that would be promoted to such a typeglob, then returns the value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 是一个typeglob，其子例程条目是可以进行内联的常量子程序，或者 &lt;code&gt;gv&lt;/code&gt; 是一个占位符引用，将被提升为此类typeglob，则返回该子程序返回的值。否则，返回NULL。</target>
        </trans-unit>
        <trans-unit id="5b76926b7fe43456ac634077129deadebe6d1749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt; ) on each line.</source>
          <target state="translated">如果使用 &lt;code&gt;ignoreName&lt;/code&gt; 或 &lt;code&gt;undefName&lt;/code&gt; ，则应在每行上将字符名称指定为注释（在 &lt;code&gt;#&lt;/code&gt; 之后）。</target>
        </trans-unit>
        <trans-unit id="c67ec45488470986d50d9732fc06ac7df6e89db8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ignoreName&lt;/code&gt; or &lt;code&gt;undefName&lt;/code&gt; is used, character names should be specified as a comment (following &lt;code&gt;#&lt;/code&gt;) on each line.</source>
          <target state="translated">如果使用 &lt;code&gt;ignoreName&lt;/code&gt; 或 &lt;code&gt;undefName&lt;/code&gt; ，则应在每行上将字符名称指定为注释（在 &lt;code&gt;#&lt;/code&gt; 之后）。</target>
        </trans-unit>
        <trans-unit id="606bfb04b8810dddbc165299090455517c6f31d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt; , (which means if you use this option, that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 为0，则将使用 &lt;code&gt;strlen(s)&lt;/code&gt; 进行计算（这意味着，如果使用此选项，则 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 不能嵌入 &lt;code&gt;NUL&lt;/code&gt; 字符，而必须具有终止 &lt;code&gt;NUL&lt;/code&gt; 字节）。</target>
        </trans-unit>
        <trans-unit id="35a8aa529d970b1105047bbf5eb8254c1640c25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is 0, it will be calculated using &lt;code&gt;strlen(s)&lt;/code&gt;, (which means if you use this option, that &lt;code&gt;s&lt;/code&gt; can't have embedded &lt;code&gt;NUL&lt;/code&gt; characters and has to have a terminating &lt;code&gt;NUL&lt;/code&gt; byte).</source>
          <target state="translated">如果 &lt;code&gt;len&lt;/code&gt; 为0，则将使用 &lt;code&gt;strlen(s)&lt;/code&gt; 进行计算（这意味着，如果使用此选项，则 &lt;code&gt;s&lt;/code&gt; 不能嵌入 &lt;code&gt;NUL&lt;/code&gt; 字符，而必须具有终止 &lt;code&gt;NUL&lt;/code&gt; 字节）。</target>
        </trans-unit>
        <trans-unit id="564f6927aa67faeb8390b79eb296fc0609382f07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_archive()&lt;/code&gt; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.</source>
          <target state="translated">如果将 &lt;code&gt;list_archive()&lt;/code&gt; 传递给数组引用作为其第三个参数，则它将返回包含每个文件的请求属性的哈希引用列表。支持以下属性列表：full_path，名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀，类型。</target>
        </trans-unit>
        <trans-unit id="30b6892ba87f6c10d6419b32b55f7a86419b6ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;list_files()&lt;/code&gt; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.</source>
          <target state="translated">如果将 &lt;code&gt;list_files()&lt;/code&gt; 作为第一个参数传递给数组引用，则它将返回包含每个文件的请求属性的哈希引用列表。支持以下属性列表：名称，大小，mtime（上次修改日期），模式，uid，gid，链接名，uname，gname，devmajor，devminor，前缀。</target>
        </trans-unit>
        <trans-unit id="6b6ca16484970453642612331b9f95d68983da46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounter an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors), or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">如果 &lt;code&gt;make_path&lt;/code&gt; 或 &lt;code&gt;remove_tree&lt;/code&gt; 遇到错误，诊断消息将通过 &lt;code&gt;carp&lt;/code&gt; （对于非致命错误）或通过 &lt;code&gt;croak&lt;/code&gt; （对于致命错误）打印到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1dea29744b11722e865e983de60cdb68d486715" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;make_path&lt;/code&gt; or &lt;code&gt;remove_tree&lt;/code&gt; encounters an error, a diagnostic message will be printed to &lt;code&gt;STDERR&lt;/code&gt; via &lt;code&gt;carp&lt;/code&gt; (for non-fatal errors) or via &lt;code&gt;croak&lt;/code&gt; (for fatal errors).</source>
          <target state="translated">如果 &lt;code&gt;make_path&lt;/code&gt; 或 &lt;code&gt;remove_tree&lt;/code&gt; 遇到错误，将通过 &lt;code&gt;carp&lt;/code&gt; （对于非致命错误）或通过 &lt;code&gt;croak&lt;/code&gt; （对于致命错误）将诊断消息打印到 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e12005256b82b7dbf15e43b617aa6446b9ea3caa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge&lt;/code&gt; is true the harness will create parsers that merge STDOUT and STDERR together for any processes they start.</source>
          <target state="translated">如果 &lt;code&gt;merge&lt;/code&gt; 为true，则线束将创建解析器，以将STDOUT和STDERR合并到一起以启动任何进程。</target>
        </trans-unit>
        <trans-unit id="a65b7746a43b203ecde7cf3199ef2365227c5212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified, with the stash defaulting in the same manner as for &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt;. &lt;code&gt;flags&lt;/code&gt; may contain flag bits understood by &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt; with the same meaning as they have there, such as &lt;code&gt;GV_ADDWARN&lt;/code&gt;. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 为null，则子例程将是匿名的，其 &lt;code&gt;CvGV&lt;/code&gt; 引用 &lt;code&gt;__ANON__&lt;/code&gt; glob。如果 &lt;code&gt;name&lt;/code&gt; 为非null，则子例程将相应地命名，并由适当的glob引用。 &lt;code&gt;name&lt;/code&gt; 是一个长度为 &lt;code&gt;len&lt;/code&gt; 字节的字符串，提供无符号符号名称，如果 &lt;code&gt;flags&lt;/code&gt; 设置了 &lt;code&gt;SVf_UTF8&lt;/code&gt; 位，则为UTF-8，否则为Latin-1。名称可以是限定名称，也可以是非限定名称，默认存储方式与 &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt; 相同。 &lt;code&gt;flags&lt;/code&gt; 可能包含 &lt;code&gt;gv_fetchpvn_flags&lt;/code&gt; 理解的标志位具有与那里相同的含义，例如 &lt;code&gt;GV_ADDWARN&lt;/code&gt; 。如有必要，始终使用 &lt;code&gt;GV_ADDMULTI&lt;/code&gt; 语义将符号添加到存储中。</target>
        </trans-unit>
        <trans-unit id="8ab07e7506173a92d684e99bcaa1a4031e98f0c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is null then the subroutine will be anonymous, with its &lt;code&gt;CvGV&lt;/code&gt; referring to an &lt;code&gt;__ANON__&lt;/code&gt; glob. If &lt;code&gt;name&lt;/code&gt; is non-null then the subroutine will be named accordingly, referenced by the appropriate glob. &lt;code&gt;name&lt;/code&gt; is a string of length &lt;code&gt;len&lt;/code&gt; bytes giving a sigilless symbol name, in UTF-8 if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SVf_UTF8&lt;/code&gt; bit set and in Latin-1 otherwise. The name may be either qualified or unqualified. If the name is unqualified then it defaults to being in the stash specified by &lt;code&gt;stash&lt;/code&gt; if that is non-null, or to &lt;code&gt;PL_curstash&lt;/code&gt; if &lt;code&gt;stash&lt;/code&gt; is null. The symbol is always added to the stash if necessary, with &lt;code&gt;GV_ADDMULTI&lt;/code&gt; semantics.</source>
          <target state="translated">如果 &lt;code&gt;name&lt;/code&gt; 为null，则子例程将是匿名的，其 &lt;code&gt;CvGV&lt;/code&gt; 引用 &lt;code&gt;__ANON__&lt;/code&gt; glob。如果 &lt;code&gt;name&lt;/code&gt; 为非null，则子例程将相应地命名，并由适当的glob引用。 &lt;code&gt;name&lt;/code&gt; 是一个长度为 &lt;code&gt;len&lt;/code&gt; 字节的字符串，提供无符号符号名称，如果 &lt;code&gt;flags&lt;/code&gt; 设置了 &lt;code&gt;SVf_UTF8&lt;/code&gt; 位，则为UTF-8，否则为Latin-1。名称可以是合格的或不合格的。如果名称是不合格则默认为按指定的藏匿处被 &lt;code&gt;stash&lt;/code&gt; 如果非空，或者 &lt;code&gt;PL_curstash&lt;/code&gt; 如果 &lt;code&gt;stash&lt;/code&gt; 一片空白。如有必要，始终使用 &lt;code&gt;GV_ADDMULTI&lt;/code&gt; 语义将符号添加到存储中。</target>
        </trans-unit>
        <trans-unit id="a5a417a1f8bba03650439d46556e6b5e2f42cdc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;namlen&lt;/code&gt; is greater than zero then a &lt;code&gt;savepvn&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;namlen&lt;/code&gt; 大于零，则执行 &lt;code&gt;savepvn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5b4f60a5261a12c3ad5e79f21f3b4cceb3007ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">如果使用参数调用 &lt;code&gt;new()&lt;/code&gt; 且 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; 方法由于任何原因而失败，则 &lt;code&gt;new()&lt;/code&gt; 返回undef。</target>
        </trans-unit>
        <trans-unit id="7cef9a9221becdc1b22f8b33e94c433da6581c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new()&lt;/code&gt; is invoked with arguments and the &lt;code&gt;read()&lt;/code&gt; method fails for any reason, &lt;code&gt;new()&lt;/code&gt; returns undef.</source>
          <target state="translated">如果使用参数调用 &lt;code&gt;new()&lt;/code&gt; 且 &lt;code&gt;read()&lt;/code&gt; 方法由于任何原因而失败，则 &lt;code&gt;new()&lt;/code&gt; 返回undef。</target>
        </trans-unit>
        <trans-unit id="33de51c2b233ea7368e7ccccf568c1e624835ecc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o&lt;/code&gt; is null, the state op is returned. Otherwise the state op is combined with &lt;code&gt;o&lt;/code&gt; into a &lt;code&gt;lineseq&lt;/code&gt; list op, which is returned. &lt;code&gt;o&lt;/code&gt; is consumed by this function and becomes part of the returned op tree.</source>
          <target state="translated">如果 &lt;code&gt;o&lt;/code&gt; 为null，则返回状态op。否则，将状态op与 &lt;code&gt;o&lt;/code&gt; 组合成一个 &lt;code&gt;lineseq&lt;/code&gt; 列表op，然后将其返回。 &lt;code&gt;o&lt;/code&gt; 被此函数使用，并成为返回的op树的一部分。</target>
        </trans-unit>
        <trans-unit id="d5c8f13fd0a4ec2abf65b26b0dde9b71cbc468dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is null, then the subroutine will be anonymous. If &lt;code&gt;o_is_gv&lt;/code&gt; is false and &lt;code&gt;o&lt;/code&gt; is non-null, then &lt;code&gt;o&lt;/code&gt; must point to a &lt;code&gt;const&lt;/code&gt; op, which will be consumed by this function, and its string value supplies a name for the subroutine. The name may be qualified or unqualified, and if it is unqualified then a default stash will be selected in some manner. If &lt;code&gt;o_is_gv&lt;/code&gt; is true, then &lt;code&gt;o&lt;/code&gt; doesn't point to an &lt;code&gt;OP&lt;/code&gt; at all, but is instead a cast pointer to a &lt;code&gt;GV&lt;/code&gt; by which the subroutine will be named.</source>
          <target state="translated">如果 &lt;code&gt;o_is_gv&lt;/code&gt; 为false且 &lt;code&gt;o&lt;/code&gt; 为null，则子例程将是匿名的。如果 &lt;code&gt;o_is_gv&lt;/code&gt; 为false且 &lt;code&gt;o&lt;/code&gt; 为非null，则 &lt;code&gt;o&lt;/code&gt; 必须指向该 &lt;code&gt;const&lt;/code&gt; 将使用的const op，并且其字符串值将为子例程提供名称。名称可以是合格的或不合格的，如果不合格，则将以某种方式选择默认存储。如果 &lt;code&gt;o_is_gv&lt;/code&gt; 为true，则 &lt;code&gt;o&lt;/code&gt; 根本不指向 &lt;code&gt;OP&lt;/code&gt; ，而是指向 &lt;code&gt;GV&lt;/code&gt; 的强制转换指针，通过该GV可以命名子例程。</target>
        </trans-unit>
        <trans-unit id="dcf32c805e2ddc81931fd2560a08109645dce7e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is &lt;code&gt;OP_ANDASSIGN&lt;/code&gt;, &lt;code&gt;OP_ORASSIGN&lt;/code&gt;, or &lt;code&gt;OP_DORASSIGN&lt;/code&gt;, then a suitable conditional optree is constructed. If &lt;code&gt;optype&lt;/code&gt; is the opcode of a binary operator, such as &lt;code&gt;OP_BIT_OR&lt;/code&gt;, then an op is constructed that performs the binary operation and assigns the result to the left argument. Either way, if &lt;code&gt;optype&lt;/code&gt; is non-zero then &lt;code&gt;flags&lt;/code&gt; has no effect.</source>
          <target state="translated">如果 &lt;code&gt;optype&lt;/code&gt; 为 &lt;code&gt;OP_ANDASSIGN&lt;/code&gt; ， &lt;code&gt;OP_ORASSIGN&lt;/code&gt; 或 &lt;code&gt;OP_DORASSIGN&lt;/code&gt; ，则将构造一个合适的条件optree。如果 &lt;code&gt;optype&lt;/code&gt; 是二进制运算符的操作码，例如 &lt;code&gt;OP_BIT_OR&lt;/code&gt; ，则构造一个执行二进制运算并将结果分配给left参数的op。无论哪种方式，如果 &lt;code&gt;optype&lt;/code&gt; 不为零，则 &lt;code&gt;flags&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="35ecad3c0cc7408f92e26472fcb7141e48a993e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;optype&lt;/code&gt; is zero, then a plain scalar or list assignment is constructed. Which type of assignment it is is automatically determined. &lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt;, except that &lt;code&gt;OPf_KIDS&lt;/code&gt; will be set automatically, and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt;, except that the bit with value 1 or 2 is automatically set as required.</source>
          <target state="translated">如果 &lt;code&gt;optype&lt;/code&gt; 为零，则构造普通标量或列表分配。它是自动确定的分配类型。 &lt;code&gt;flags&lt;/code&gt; 给出的八位 &lt;code&gt;op_flags&lt;/code&gt; ，不同之处在于 &lt;code&gt;OPf_KIDS&lt;/code&gt; 将被自动设置，并且，向上移位八个位，则8位 &lt;code&gt;op_private&lt;/code&gt; ，不同的是如需要具有值1或2位被自动设置。</target>
        </trans-unit>
        <trans-unit id="14b4ce4ab1caa8905ea03f71030c64a0c404abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pass_through&lt;/code&gt; is also enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first.</source>
          <target state="translated">如果还启用了 &lt;code&gt;pass_through&lt;/code&gt; ，则选项处理将在第一个无法识别的选项或非选项（以先到者为准）处终止。</target>
        </trans-unit>
        <trans-unit id="9243fb188fd78661a99b6e8ffc13a07c0c193e45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and the pointer it points to is not &lt;code&gt;NULL&lt;/code&gt;, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt;). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt;, the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pe1&lt;/code&gt; 为非 &lt;code&gt;NULL&lt;/code&gt; ,并且其指向的指针也不为 &lt;code&gt;NULL&lt;/code&gt; ，则该指针将被视为指向 &lt;code&gt;s1&lt;/code&gt; 中最大点之后1​​个字节的位置的结束指针，在任何情况下都不能继续扫描。 （此例程假定UTF-8编码的输入字符串没有格式错误；格式错误的输入可能会导致它读取到 &lt;code&gt;pe1&lt;/code&gt; 之后）。这意味着如果同时指定了 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;pe1&lt;/code&gt; ，并且 &lt;code&gt;pe1&lt;/code&gt; 小于 &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; ，则匹配将永远不会成功，因为它永远无法达到其目标（实际上是反对）。对应于 &lt;code&gt;pe2&lt;/code&gt; 关于 &lt;code&gt;s2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c02b449190a1b90198a28e96aea10bbc105c7788" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pe1&lt;/code&gt; is non-NULL and the pointer it points to is not NULL, that pointer is considered an end pointer to the position 1 byte past the maximum point in &lt;code&gt;s1&lt;/code&gt; beyond which scanning will not continue under any circumstances. (This routine assumes that UTF-8 encoded input strings are not malformed; malformed input can cause it to read past &lt;code&gt;pe1&lt;/code&gt; ). This means that if both &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;pe1&lt;/code&gt; are specified, and &lt;code&gt;pe1&lt;/code&gt; is less than &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; , the match will never be successful because it can never get as far as its goal (and in fact is asserted against). Correspondingly for &lt;code&gt;pe2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;pe1&lt;/code&gt; 为非NULL，并且其指向的指针也不为NULL，则该指针将被视为指向 &lt;code&gt;s1&lt;/code&gt; 中最大点之后1​​个字节的位置的结束指针，在任何情况下，该点都将无法继续扫描。 （此例程假定UTF-8编码的输入字符串没有格式错误；格式错误的输入可能会导致它读取到 &lt;code&gt;pe1&lt;/code&gt; 之后）。这意味着，如果同时指定了 &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;pe1&lt;/code&gt; ，并且 &lt;code&gt;pe1&lt;/code&gt; 小于 &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; ，则匹配将永远不会成功，因为它永远无法达到目标（实际上是反对）。相对于 &lt;code&gt;s2&lt;/code&gt; ,对应于 &lt;code&gt;pe2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5414852c94de9d937514c7b2ffd918737261abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;permute&lt;/code&gt; is enabled, this means that</source>
          <target state="translated">如果启用了 &lt;code&gt;permute&lt;/code&gt; ，则意味着</target>
        </trans-unit>
        <trans-unit id="e47709e624b959c659a6f5424e397b7429bd08c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess&lt;/code&gt; and/or &lt;code&gt;normalization&lt;/code&gt; is applied, the code points of the string after them (in NFD by default) are used.</source>
          <target state="translated">如果应用了 &lt;code&gt;preprocess&lt;/code&gt; 和/或 &lt;code&gt;normalization&lt;/code&gt; 则使用其后的字符串的代码点（默认为NFD）。</target>
        </trans-unit>
        <trans-unit id="c7a3e0b813ddb5c552aec4199fd49e48847ff2c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;prompt()&lt;/code&gt; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting. This prevents automated processes from blocking on user input.</source>
          <target state="translated">如果hint &lt;code&gt;prompt()&lt;/code&gt; 检测到它不是交互运行的，并且STDIN上没有任何内容，或者如果PERL_MM_USE_DEFAULT环境变量设置为true，则将使用$ default而不提示。这样可以防止自动过程阻止用户输入。</target>
        </trans-unit>
        <trans-unit id="9d8185228e8e06faca877b9d0926aab5904e951a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing terminates when the first non-option is encountered.</source>
          <target state="translated">如果启用了 &lt;code&gt;require_order&lt;/code&gt; ，则遇到第一个非选项时，选项处理将终止。</target>
        </trans-unit>
        <trans-unit id="7ec89b0e13a7db5b1125011c45839f2c6cfb36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;require_order&lt;/code&gt; is enabled, options processing will terminate at the first unrecognized option, or non-option, whichever comes first and all remaining arguments are passed to &lt;code&gt;@ARGV&lt;/code&gt; instead of the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present. However, if &lt;code&gt;permute&lt;/code&gt; is enabled instead, results can become confusing.</source>
          <target state="translated">如果启用了 &lt;code&gt;require_order&lt;/code&gt; ，则选项处理将在第一个无法识别的选项（或非选项）（以先到者为准）终止，并且所有剩余参数都传递给 &lt;code&gt;@ARGV&lt;/code&gt; 而不是catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; (如果存在）。但是，如果改为启用 &lt;code&gt;permute&lt;/code&gt; ，则结果可能会造成混淆。</target>
        </trans-unit>
        <trans-unit id="6e12b0dc8bb5978452519b2af8436776d186cd58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 没有指向格式正确的UTF-8字符，并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不是 &lt;code&gt;NULL&lt;/code&gt; ）。如果关闭了这些警告，则将静默返回计算值（如果定义正确）（如果没有，则返回Unicode REPLACEMENT CHARACTER），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不是 &lt;code&gt;NULL&lt;/code&gt; ），则（ &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;s&lt;/code&gt; 中的下一个可能位置，该位置可能会开始一个格式不正确的字符。有关何时返回REPLACEMENT CHARACTER的详细信息，请参见&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&amp;ldquo; utf8n_to_uvchr&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e07d4919d304923f37fe1dc7b33e0707c964ce0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不能指向格式正确的UTF-8字符，并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果禁用了这些警告，则将静默返回计算值（如果定义正确）（或Unicode REPLACEMENT CHARACTER，否则），并且设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;s&lt;/code&gt; 中可能出现的下一个可能位置，该位置可以开始一个格式正确的字符。有关何时返回REPLACEMENT CHARACTER的详细信息，请参见&lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;perlapi中的&amp;ldquo; utf8n_to_uvchr&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="344a52db4b11baa26a523460842709ff1b386ede" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 指向检测到的一种 &lt;code&gt;*retlen&lt;/code&gt; ，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不指向NULL）。如果禁用了这些警告，则将静默返回计算值（如果定义正确）（或Unicode REPLACEMENT CHARACTER，否则），并且设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;s&lt;/code&gt; 中可能出现的下一个可能位置，该位置可以开始一个格式正确的字符。有关何时返回REPLACEMENT CHARACTER的详细信息，请参见&lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;perlapi中的&amp;ldquo; utf8n_to_uvchr&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ee7a15600127f4d0959a8f8bcd7fe929dc1bb55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't &lt;code&gt;NULL&lt;/code&gt;) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 指向检测到的 &lt;code&gt;*retlen&lt;/code&gt; 之一，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不是 &lt;code&gt;NULL&lt;/code&gt; ）。如果禁用了这些警告，则将静默返回计算值（如果定义正确）（或Unicode REPLACEMENT CHARACTER，否则），并且设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;s&lt;/code&gt; 中可能出现的下一个可能位置，该位置可以开始一个格式正确的字符。有关何时返回REPLACEMENT CHARACTER的详细信息，请参见&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&amp;ldquo; utf8n_to_uvchr&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba0fe2f6810522d3880f034d6ed2e0c1aaeec082" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_locale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;set_locale()&lt;/code&gt; 由于某种原因（例如，尝试设置为系统未知的语言环境）而失败，则该类别的语言环境不会更改，并且该函数将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00fbad40868135a15b1b3119d64c803fbf76e3ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setlocale()&lt;/code&gt; fails for some reason (for example, an attempt to set to a locale unknown to the system), the locale for the category is not changed, and the function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;setlocale()&lt;/code&gt; 由于某种原因失败（例如，尝试设置为系统未知的语言环境），则类别的语言环境不会更改，并且该函数将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7def84ba14c7da181889f798540180404e1bc96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setmagic&lt;/code&gt; is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. &lt;code&gt;'local $x = $y'&lt;/code&gt;), and that will handle the magic.</source>
          <target state="translated">如果 &lt;code&gt;setmagic&lt;/code&gt; 为false，则不会在新的（空）SV上调用已设置的魔术。这通常意味着分配将很快进行（例如 &lt;code&gt;'local $x = $y'&lt;/code&gt; ），并且将处理魔术。</target>
        </trans-unit>
        <trans-unit id="6f1f3673ad86da277d3ff5d2cf4aee1d0694c871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;split&lt;/code&gt; is invoked as &lt;code&gt;split ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;split(' ', $_)&lt;/code&gt;, see &lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">如果 &lt;code&gt;split&lt;/code&gt; 是作为 &lt;code&gt;split ' '&lt;/code&gt; 或没有参数调用的（这实际上意味着 &lt;code&gt;split(' ', $_)&lt;/code&gt; ，请参见&lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt;），Perl将设置此标志。然后，正则表达式引擎可以对其进行检查并设置SKIPWHITE和WHITE extflags。为此，Perl引擎执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6d3fb59ce22521f54bad3dad454399653c576366" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start_color&lt;/code&gt; is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If &lt;code&gt;end_color&lt;/code&gt; is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">如果 &lt;code&gt;start_color&lt;/code&gt; 不为null，则将其插入在引号（如果有）之后，但在转义文本之前。如果 &lt;code&gt;end_color&lt;/code&gt; 不为null，则它将在转义文本之后但在任何引号或省略号之前插入。</target>
        </trans-unit>
        <trans-unit id="f49431f91057c4dbcea93169afee875e80cb6ef1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; already is UTF-8 (or if it is not &lt;code&gt;POK&lt;/code&gt;), or if &lt;code&gt;encoding&lt;/code&gt; is not a reference, nothing is done to &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;encoding&lt;/code&gt; is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">如果 &lt;code&gt;sv&lt;/code&gt; 已经是UTF-8（或者不是 &lt;code&gt;POK&lt;/code&gt; ），或者 &lt;code&gt;encoding&lt;/code&gt; 不是引用，则不会对 &lt;code&gt;sv&lt;/code&gt; 进行任何操作。如果 &lt;code&gt;encoding&lt;/code&gt; 不是 &lt;code&gt;Encode::XS&lt;/code&gt; Encoding对象，则将发生不良情况。（看</target>
        </trans-unit>
        <trans-unit id="04ffb889ba3672c819c8ebc2556d3ca7f2216415" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt; . Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">如果 &lt;code&gt;sv&lt;/code&gt; 并不是很神奇，则Perl使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏将 &lt;code&gt;sv&lt;/code&gt; 转换为 &lt;code&gt;SVt_PVMG&lt;/code&gt; 类型。然后，Perl继续，将新的魔术添加到魔术功能的链接列表的开头。之前所有相同类型的魔法条目都会被删除。请注意，这可以被覆盖，并且相同类型的魔术的多个实例可以与SV相关联。</target>
        </trans-unit>
        <trans-unit id="4ab681f247e800a443c2ee4cb6d285861bd3cf7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is not already magical, Perl uses the &lt;code&gt;SvUPGRADE&lt;/code&gt; macro to convert &lt;code&gt;sv&lt;/code&gt; to type &lt;code&gt;SVt_PVMG&lt;/code&gt;. Perl then continues by adding new magic to the beginning of the linked list of magical features. Any prior entry of the same type of magic is deleted. Note that this can be overridden, and multiple instances of the same type of magic can be associated with an SV.</source>
          <target state="translated">如果 &lt;code&gt;sv&lt;/code&gt; 并不是很神奇，则Perl使用 &lt;code&gt;SvUPGRADE&lt;/code&gt; 宏将 &lt;code&gt;sv&lt;/code&gt; 转换为 &lt;code&gt;SVt_PVMG&lt;/code&gt; 类型。然后，Perl继续，将新的魔术添加到魔术功能的链接列表的开头。相同类型的魔法的所有先前输入都将被删除。请注意，这可以被覆盖，并且相同类型的魔术的多个实例可以与SV相关联。</target>
        </trans-unit>
        <trans-unit id="dbc4779d92424b9ed1e872ef029dc61c2a85f827" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sv&lt;/code&gt; is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sv&lt;/code&gt; 是弱引用的目标，则它将返回与sv关联的反向引用结构；否则，返回sv。否则返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6f965fbaf23253043bd3c46cbaac3045ccac1cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;system&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt;, then it uses &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">如果将 &lt;code&gt;system&lt;/code&gt; 指定为 &lt;code&gt;autodie&lt;/code&gt; 的参数，则它将使用&lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;进行繁重的工作。有关更多信息，请参见该模块的描述。</target>
        </trans-unit>
        <trans-unit id="e0b89db42e4e190758019494213d834ead62fc5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tgtsv&lt;/code&gt; is non-null then the string will be written into that SV (overwriting existing content) and it will be returned. If &lt;code&gt;tgtsv&lt;/code&gt; is a null pointer then the string will be written into a new mortal SV which will be returned.</source>
          <target state="translated">如果 &lt;code&gt;tgtsv&lt;/code&gt; 不为null，则该字符串将被写入该SV（覆盖现有内容），并将其返回。如果 &lt;code&gt;tgtsv&lt;/code&gt; 是空指针，则该字符串将被写入新的凡人SV，并将其返回。</target>
        </trans-unit>
        <trans-unit id="c5c3008df77cfa39eeaefce991da14fbe22117ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;u1&lt;/code&gt; 为true，则假定字符串 &lt;code&gt;s1&lt;/code&gt; 以UTF-8编码的Unicode编码；否则，假定为本地8位编码。相对于 &lt;code&gt;s2&lt;/code&gt; 对应于 &lt;code&gt;u2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5369cdc9e4df17df0fab9c265cc2a668b2d5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u1&lt;/code&gt; is true, the string &lt;code&gt;s1&lt;/code&gt; is assumed to be in UTF-8-encoded Unicode; otherwise it is assumed to be in native 8-bit encoding. Correspondingly for &lt;code&gt;u2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;u1&lt;/code&gt; 为true，则假定字符串 &lt;code&gt;s1&lt;/code&gt; 以UTF-8编码的Unicode表示；否则，假定为本地8位编码。相对于 &lt;code&gt;s2&lt;/code&gt; 对应于 &lt;code&gt;u2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff7ae9da7000e2b33b5ec7b9b74b0d3b4543ad4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt;) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt;) is ordered after &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt;. In this point, &lt;code&gt;(normalization =&amp;gt; undef, preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;undef&lt;/code&gt; （不是字符串 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ）显式传递为该键的值，则不会执行任何规范化（如果不需要任何规范化，这可能会使剪裁更加容易）。在 &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; ，仅解决了连续收缩；例如即使 &lt;code&gt;A-ring&lt;/code&gt; （和 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ）的后有序 &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;A-cedilla-ring&lt;/code&gt; 将初级等于 &lt;code&gt;A&lt;/code&gt; 。在这一点上， &lt;code&gt;(normalization =&amp;gt; undef, preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt; &lt;b&gt;不&lt;/b&gt;等于 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1772452ed00715f0d1bcb6cc8461b97a45b8aa33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt;).</source>
          <target state="translated">如果将 &lt;code&gt;undef&lt;/code&gt; 作为此键的值显式传递，则不会读取任何文件（但是您可以通过 &lt;code&gt;entry&lt;/code&gt; 定义归类元素）。</target>
        </trans-unit>
        <trans-unit id="1540dc791175456aa90cb4fef436e0dad501ecf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">如果将 &lt;code&gt;undef&lt;/code&gt; 作为此键的值显式传递，则将韩文音节的权重视为未定义，而不会分解为韩文Jamo。但是 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中韩语音节的权重定义仍然有效。</target>
        </trans-unit>
        <trans-unit id="87a9ff2f9d0e73da828c40d03f80e90b35d67f88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt; (see &lt;a href=&quot;perlrun#-Dletters&quot;&gt;&lt;b&gt;-D&lt;/b&gt; flags in perlrun&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;use Devel::Peek&lt;/code&gt; 指令具有 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 参数，则将打开操作码调度的调试。 &lt;code&gt;FLAGS&lt;/code&gt; 应该是 &lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 的组合（请参见&lt;a href=&quot;perlrun#-Dletters&quot;&gt;perlrun中的&lt;/a&gt;&lt;b&gt;-D&lt;/b&gt;标志）。</target>
        </trans-unit>
        <trans-unit id="8e67b351362fc2288e4d85d1df0a7cb4397d6517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">如果 &lt;code&gt;use bytes&lt;/code&gt; 有效：</target>
        </trans-unit>
        <trans-unit id="b63d1c4b73014a212e1adcb7458310fbabfcada8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) is in force then signed C integers are used (</source>
          <target state="translated">如果强制 &lt;code&gt;use integer&lt;/code&gt; （请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&amp;ldquo;整数算术&amp;rdquo;&lt;/a&gt;），则使用带符号的C整数（</target>
        </trans-unit>
        <trans-unit id="055cb8f0eb7094e6bf1d58d9d0a382f3cec04e19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is disabled, then the result is also correctly encoded in those character sets (as both are proper subsets of Unicode, meaning that a Unicode string with all character values &amp;lt; 256 is the same thing as a ISO-8859-1 string, and a Unicode string with all character values &amp;lt; 128 is the same thing as an ASCII string in Perl).</source>
          <target state="translated">如果禁用 &lt;code&gt;utf8&lt;/code&gt; ，则结果也将正确编码在这些字符集中（因为这两个都是Unicode的正确子集，这意味着所有字符值均小于256的Unicode字符串与ISO-8859-1字符串相同，并且所有字符值均小于128的Unicode字符串与Perl中的ASCII字符串相同。</target>
        </trans-unit>
        <trans-unit id="91b6b629aef61b3ce3a48a95ca6e7795616126f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;utf8&lt;/code&gt; is enabled, you still get a correct UTF-8-encoded string, regardless of these flags, just some more characters will be escaped using &lt;code&gt;\uXXXX&lt;/code&gt; then before.</source>
          <target state="translated">如果启用了 &lt;code&gt;utf8&lt;/code&gt; ，则无论这些标志如何，您仍将获得正确的UTF-8编码的字符串，然后将使用 &lt;code&gt;\uXXXX&lt;/code&gt; 转义更多的字符。</target>
        </trans-unit>
        <trans-unit id="ac03d59f846f562239a0cc40bb258a33efc729e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and &lt;code&gt;UNICODE_WARN_SURROGATE&lt;/code&gt; is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead &lt;code&gt;UNICODE_DISALLOW_SURROGATE&lt;/code&gt; is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">如果 &lt;code&gt;uv&lt;/code&gt; 是Unicode代理代码点，并且已设置 &lt;code&gt;UNICODE_WARN_SURROGATE&lt;/code&gt; ，则在启用UTF8警告的情况下，该函数将发出警告。如果改为设置 &lt;code&gt;UNICODE_DISALLOW_SURROGATE&lt;/code&gt; ，则该函数将失败并返回NULL。如果同时设置了两个标志，则该函数将同时发出警告并返回NULL。</target>
        </trans-unit>
        <trans-unit id="fcb599464a46f537e87d3017df24f3e8e2283ffd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;uv&lt;/code&gt; is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set, the function will raise a warning, provided UTF8 warnings are enabled. If instead UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL. If both flags are set, the function will both warn and return NULL.</source>
          <target state="translated">如果 &lt;code&gt;uv&lt;/code&gt; 是Unicode代理代码点，并且设置了UNICODE_WARN_SURROGATE，则在启用UTF8警告的情况下，该函数将发出警告。如果改为设置UNICODE_DISALLOW_SURROGATE，则该函数将失败并返回NULL。如果同时设置了两个标志，则该函数将同时发出警告并返回NULL。</target>
        </trans-unit>
        <trans-unit id="0c44318124964ccd942d87918bc5a4d0e5a866fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;val&lt;/code&gt; is true, do not print any errors/warnings.</source>
          <target state="translated">如果 &lt;code&gt;val&lt;/code&gt; 为true，请不要打印任何错误/警告。</target>
        </trans-unit>
        <trans-unit id="ae30129230a55488ef814c14253472811e67904d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; in</source>
          <target state="translated">如果 &lt;code&gt;value&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="02c3454635e56b23178636e2bb6aec32fcd96776" translate="yes" xml:space="preserve">
          <source>If @DynaLoader::dl_resolve_using contains &lt;code&gt;-L*&lt;/code&gt; or &lt;code&gt;-l*&lt;/code&gt; entries then Mkbootstrap will automatically add a dl_findfile() call to the generated &lt;code&gt;*.bs&lt;/code&gt; file.</source>
          <target state="translated">如果@DynaLoader :: dl_resolve_using包含 &lt;code&gt;-L*&lt;/code&gt; 或 &lt;code&gt;-l*&lt;/code&gt; 条目，则Mkbootstrap将自动将dl_findfile（）调用添加到生成的 &lt;code&gt;*.bs&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="203a87ac5779da1d943be09c716f0304a892b601" translate="yes" xml:space="preserve">
          <source>If @args is not given, an empty list will be used.</source>
          <target state="translated">如果没有给定@args,将使用一个空列表。</target>
        </trans-unit>
        <trans-unit id="f3523d8b4dddaad91344458f88af994bb31e6c10" translate="yes" xml:space="preserve">
          <source>If @imports are given, they are passed through to the use. So this:</source>
          <target state="translated">如果给了@imports,就会传递给使用。所以这。</target>
        </trans-unit>
        <trans-unit id="649b9ffd5b70f81915b08f4bc8291a1a2ce523f9" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">如果给出了@后缀，则每个元素都是与$ filename末尾匹配的模式（字符串或 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）。匹配部分将被删除并成为$后缀。</target>
        </trans-unit>
        <trans-unit id="352f4bf8960a2fcba781ac944722d04a3329314f" translate="yes" xml:space="preserve">
          <source>If @suffixes are given each element is a pattern (either a string or a &lt;code&gt;qr//&lt;/code&gt;) matched against the end of the $filename. The matching portion is removed and becomes the $suffix.</source>
          <target state="translated">如果给定了@后缀，则每个元素都是一个与$ filename末尾匹配的模式（字符串或 &lt;code&gt;qr//&lt;/code&gt; ）。匹配的部分将被删除并成为$后缀。</target>
        </trans-unit>
        <trans-unit id="d4498a59b542ad3816d9e8760461f7daf1fdeee5" translate="yes" xml:space="preserve">
          <source>If ATTR includes aliases, those aliases will be expanded at definition time and their values will be used to define the new alias. This means that if you define an alias A in terms of another alias B, and then later redefine alias B, the value of alias A will not change.</source>
          <target state="translated">如果ATTR包括别名,这些别名将在定义时被扩展,它们的值将被用来定义新的别名。这意味着,如果你用另一个别名B来定义别名A,然后再重新定义别名B,别名A的值将不会改变。</target>
        </trans-unit>
        <trans-unit id="8fb13f58bf6ef66c743c6f31498345464e172f61" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard attribute or attributes to which ALIAS is aliased, if any, or undef if ALIAS does not exist. If it is aliased to multiple attributes, the return value will be a single string and the attributes will be separated by spaces.</source>
          <target state="translated">如果没有指定ATTR,coloralias()将返回ALIAS被别名的标准属性(如果有的话),如果ALIAS不存在,则返回undef。如果它被别名为多个属性,返回值将是一个单一的字符串,属性之间用空格隔开。</target>
        </trans-unit>
        <trans-unit id="e062bfde8c040f50084c09a806e3edbdcdba4c2d" translate="yes" xml:space="preserve">
          <source>If ATTR is not specified, coloralias() returns the standard color name to which ALIAS is aliased, if any, or undef if ALIAS does not exist.</source>
          <target state="translated">如果没有指定ATTR,coloralias()会返回ALIAS被别名的标准颜色名称(如果有),如果ALIAS不存在,则返回undef。</target>
        </trans-unit>
        <trans-unit id="f999d6f241c02db8ba7aa5052a43f699b6917b00" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, coloralias() sets up an alias of ALIAS for the standard color ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt; , and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">如果指定了ATTR，coloralias（）将为标准颜色ATTR设置ALIAS的别名。从那时起，可以将ALIAS传递到color（），colored（）和colorvalid（）中，并且将具有与ATTR相同的含义。该功能的一种可能用途是为256色RGB颜色赋予更有意义的名称。仅字母数字， &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 允许使用别名。</target>
        </trans-unit>
        <trans-unit id="ef24de7525ed9aebc1ebe9e4502b970287362ec8" translate="yes" xml:space="preserve">
          <source>If ATTR is specified, it is interpreted as a list of space-separated strings naming attributes or existing aliases. In this case, coloralias() sets up an alias of ALIAS for the set of attributes given by ATTR. From that point forward, ALIAS can be passed into color(), colored(), and colorvalid() and will have the same meaning as the sequence of attributes given in ATTR. One possible use of this facility is to give more meaningful names to the 256-color RGB colors. Only ASCII alphanumerics, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are allowed in alias names.</source>
          <target state="translated">如果指定了ATTR，它将被解释为以空格分隔的字符串的命名属性或现有别名的列表。在这种情况下，coloralias（）为ATTR给定的属性集设置ALIAS的别名。从那时起，可以将ALIAS传递到color（），colored（）和colorvalid（）中，并且将具有与ATTR中给定的属性序列相同的含义。该功能的一种可能用途是为256色RGB颜色赋予更有意义的名称。仅ASCII字母数字， &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;_&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 允许使用别名。</target>
        </trans-unit>
        <trans-unit id="ba5f4e8c9b9a52c1f24694fe0f51b01b3e6fce9d" translate="yes" xml:space="preserve">
          <source>If BASE is less than or equal to 94, and a collation sequence is not specified, the following default collation sequence is used. It contains of all the 94 printable ASCII characters except space/blank:</source>
          <target state="translated">如果BASE小于或等于94,且未指定整理序列,则使用以下默认整理序列。它包含除空格/空白以外的所有94个可打印ASCII字符。</target>
        </trans-unit>
        <trans-unit id="3759a11aeec37a7d745f2f4cdae15ec5d06a83ce" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; with big-endian formats &lt;code&gt;n&lt;/code&gt;/&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">如果BITS为16或更大，则将输入字符串的字节分组为大小为BITS / 8的块，然后将每个组转换为数字，如使用大尾数格式 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; 的&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;（对于BITS == 64）。有关详细信息，请参见&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed33ee3bf815a6c3c728d6a64deacab551214ad3" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;#pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">如果BITS为16或更大，则将输入字符串的字节分组为大小为BITS / 8的块，然后将每个组转换为数字，如pack（）/ unpack（）那样，使用大尾数格式 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; （并且类似地）对于BITS == 64）。有关详细信息，请参见&lt;a href=&quot;#pack&quot;&gt;包装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5890dee5bd815a9a6b870ab0d81456c70fdb6033" translate="yes" xml:space="preserve">
          <source>If BITS is 16 or more, bytes of the input string are grouped into chunks of size BITS/8, and each group is converted to a number as with pack()/unpack() with big-endian formats &lt;code&gt;n&lt;/code&gt; /&lt;code&gt;N&lt;/code&gt; (and analogously for BITS==64). See &lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt; for details.</source>
          <target state="translated">如果BITS为16或更大，则将输入字符串的字节分组为大小为BITS / 8的块，然后将每个组转换为数字，如pack（）/ unpack（）那样，使用大尾数格式 &lt;code&gt;n&lt;/code&gt; / &lt;code&gt;N&lt;/code&gt; （并且类似地）对于BITS == 64）。有关详细信息，请参见&lt;a href=&quot;pack&quot;&gt;包装&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eafc581ec466397a85b26357c350bc4ac6773df9" translate="yes" xml:space="preserve">
          <source>If BITS is 8, &quot;elements&quot; coincide with bytes of the input string.</source>
          <target state="translated">如果BITS为8,则 &quot;元素 &quot;与输入字符串的字节重合。</target>
        </trans-unit>
        <trans-unit id="1e3d642ff4115aae3b45ab10f3f174f7b8799465" translate="yes" xml:space="preserve">
          <source>If BUILD_REQUIRES is not empty, it will be dumped as $BUILD_REQUIRES hashref.</source>
          <target state="translated">如果BUILD_REQUIRES不是空的,它将被转储为$BUILD_REQUIRES hashref。</target>
        </trans-unit>
        <trans-unit id="2f52aed81a4b81abc4bfb5eb234cabe8285fe520" translate="yes" xml:space="preserve">
          <source>If CHLD_IN begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">如果CHLD_IN以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头，则在父级中将关闭CHLD_IN，而子级将直接从中读取。如果CHLD_OUT或CHLD_ERR以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子代将直接将输出发送到该文件句柄。在这两种情况下，都将使用dup（2）而不是使用pipe（2）。</target>
        </trans-unit>
        <trans-unit id="7212fe99a84e995b8956769eedd21cc0b4318074" translate="yes" xml:space="preserve">
          <source>If Configure detects &lt;code&gt;mmap()&lt;/code&gt; functions this layer is provided (with &quot;perlio&quot; as a &quot;base&quot;) which does &quot;read&quot; operations by mmap()ing the file. Performance improvement is marginal on modern systems, so it is mainly there as a proof of concept. It is likely to be unbundled from the core at some point. The &quot;mmap&quot; layer is a reasonable model for a minimalist &quot;derived&quot; layer.</source>
          <target state="translated">如果Configure检测到 &lt;code&gt;mmap()&lt;/code&gt; 函数，则提供该层（以&amp;ldquo; perlio&amp;rdquo;作为&amp;ldquo;基础&amp;rdquo;），该层通过mmap（）处理文件来&amp;ldquo;读取&amp;rdquo;操作。在现代系统上，性能改进是微不足道的，因此主要是作为概念证明。在某个时候，它可能会从核心中解开。&amp;ldquo; mmap&amp;rdquo;层是极简&amp;ldquo;派生&amp;rdquo;层的合理模型。</target>
        </trans-unit>
        <trans-unit id="47e49834bb6e6d998b14887fad543f4fe5a1147b" translate="yes" xml:space="preserve">
          <source>If Configure detects this system has a signbit() that will work with our NVs, then we just use it via the #define in perl.h. Otherwise, fall back on this implementation. The main use of this function is catching -0.0.</source>
          <target state="translated">如果Configure检测到这个系统有一个可以和我们的NV一起工作的signbit(),那么我们只要通过perl.h中的#define来使用它。否则,就回落到这个实现上。这个函数的主要用途是捕捉-0.0。</target>
        </trans-unit>
        <trans-unit id="14abe49a0e4ae66bc9fb22dcac00158a0e0ddd4d" translate="yes" xml:space="preserve">
          <source>If D calls an autoloaded method 'foo' which is defined in class A, then the method is loaded into class A, then executed. If C then calls method 'foo', and that method was reimplemented in class B, but set to be autoloaded, then the lookup mechanism never gets to the AUTOLOAD mechanism in B because it first finds the method already loaded in A, and so erroneously uses that. If the method foo had been stubbed in B, then the lookup mechanism would have found the stub, and correctly loaded and used the sub from B.</source>
          <target state="translated">如果D调用一个在类A中定义的自动加载的方法'foo',那么该方法被加载到类A中,然后执行。如果C接着调用方法'foo',而该方法在类B中被重新实现,但被设置为自动加载,那么查找机制永远不会进入B中的AUTOLOAD机制,因为它首先发现A中已经加载的方法,所以错误地使用该方法。如果方法foo在B中被存根,那么查找机制就会找到存根,并正确加载和使用B中的子。</target>
        </trans-unit>
        <trans-unit id="91710ed7923201057d536dad32d2aa3d9a3bd35e" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from &lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt; to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">如果未安装DUCET，建议手动将文件从&lt;a href=&quot;http://www.unicode.org/Public/UCA/latest/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/latest/allkeys.txt&lt;/a&gt;复制到&amp;lt;INC中的位置&amp;gt; /Unicode/Collat​​e/allkeys.txt 。</target>
        </trans-unit>
        <trans-unit id="16f5960189e018481d4424c6116d78e40717c6a6" translate="yes" xml:space="preserve">
          <source>If DUCET is not installed, it is recommended to copy the file from http://www.unicode.org/Public/UCA/latest/allkeys.txt to &amp;lt;a place in @INC&amp;gt;/Unicode/Collate/allkeys.txt manually.</source>
          <target state="translated">如果未安装DUCET，建议手动将文件从http://www.unicode.org/Public/UCA/latest/allkeys.txt复制到&amp;lt;INC中的位置&amp;gt; /Unicode/Collat​​e/allkeys.txt 。</target>
        </trans-unit>
        <trans-unit id="63ee7188cb79ae72f03905ea0c72ed0cf711430e" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the list of file descriptors and the next call to poll will check for any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be removed from the list of file descriptors.</source>
          <target state="translated">如果给定了EVENT_MASK,那么,如果EVENT_MASK为非零,IO将被添加到文件描述符列表中,下一次调用poll将检查EVENT_MASK中指定的任何事件。如果EVENT_MASK为零,那么IO将从文件描述符列表中删除。</target>
        </trans-unit>
        <trans-unit id="bd3d21a82a01626375b0a1ef9fd969a22666fce2" translate="yes" xml:space="preserve">
          <source>If EVENT_MASK is not given then the return value will be the current event mask value for IO.</source>
          <target state="translated">如果没有给出EVENT_MASK,那么返回值将是IO的当前事件掩码值。</target>
        </trans-unit>
        <trans-unit id="24c1cc8102964c640118dc422f140e282d6a071d" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/and&quot;&gt;and&lt;/a&gt; EXPR2&lt;/code&gt; ，则应用测试</target>
        </trans-unit>
        <trans-unit id="c34219724e950095cf8c95b322a2257c22c1fa96" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; or &lt;code&gt;EXPR1 and EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 &amp;amp;&amp;amp; EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 and EXPR2&lt;/code&gt; ，则应用测试</target>
        </trans-unit>
        <trans-unit id="34b0086c490eacc160b851838628c17c1a42195c" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; , &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; , or &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; , the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; ， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 &lt;a href=&quot;functions/or&quot;&gt;or&lt;/a&gt; EXPR2&lt;/code&gt; ，将应用测试</target>
        </trans-unit>
        <trans-unit id="64f0ed02041dd1423cf4f2ba1123160eb703a531" translate="yes" xml:space="preserve">
          <source>If EXPR is &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt;, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt;, or &lt;code&gt;EXPR1 or EXPR2&lt;/code&gt;, the test is applied</source>
          <target state="translated">如果EXPR为 &lt;code&gt;EXPR1 || EXPR2&lt;/code&gt; ， &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; 或 &lt;code&gt;EXPR1 or EXPR2&lt;/code&gt; ，将应用测试</target>
        </trans-unit>
        <trans-unit id="872b533779048230ee59539b4fa97acddf5e7f67" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; assumes a</source>
          <target state="translated">如果EXPR是一个简单的词，则&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;假设一个</target>
        </trans-unit>
        <trans-unit id="204a0454b1de60634e71646d68fb30fb2441fd3c" translate="yes" xml:space="preserve">
          <source>If EXPR is a bareword, the require assumes a &quot;</source>
          <target state="translated">如果EXPR是一个裸词,那么require就假定是一个&quot;</target>
        </trans-unit>
        <trans-unit id="5f142acc4fb900bf97a751d8d7ecef7ff58633e0" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; uses the current time (as returned by &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果省略EXPR，则&lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt;使用当前时间（由&lt;a href=&quot;#time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt;返回）。</target>
        </trans-unit>
        <trans-unit id="9736cd87f1cff71e99f8827cbdbed7d4bb55c258" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">如果省略EXPR，则 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 使用当前时间（由time（3）返回）。</target>
        </trans-unit>
        <trans-unit id="6546ecbea2a684b1dddb3701f62d17cc4c008989" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; uses the current time (as returned by time(3)).</source>
          <target state="translated">如果省略EXPR，则 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 使用当前时间（由time（3）返回）。</target>
        </trans-unit>
        <trans-unit id="1a53ae320a45163e84b47c2cc6fa7f3f20a64bbd" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果省略EXPR，则统计&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cc0b8d50332776e14a75cf158fdbe3c24ae9c657" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, stats &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略EXPR，则统计 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac7e9e53a5fc19d51bc46a87435c0e28a0433901" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">如果省略EXPR，则将&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;字符串解压缩。有关此功能的介绍，请参见&lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="456f6be70dd618e1ee3287e7f4f8da001e29c2cb" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">如果省略EXPR，则将 &lt;code&gt;$_&lt;/code&gt; 字符串解压缩。有关此功能的介绍，请参见&lt;a href=&quot;../perlpacktut&quot;&gt;perlpacktut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b61a1720b65aee85f5ca14d3364f5d86fb223f23" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, unpacks the &lt;code&gt;$_&lt;/code&gt; string. See &lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt; for an introduction to this function.</source>
          <target state="translated">如果省略EXPR，则将 &lt;code&gt;$_&lt;/code&gt; 字符串解压缩。有关此功能的介绍，请参见&lt;a href=&quot;perlpacktut&quot;&gt;perlpacktut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26a60e10a6d0c75eb8213877c8d12c780af7f80d" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果省略EXPR，则使用&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfe2e417f8e1e00ae0478764fd05788fcd47c267" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. To go the other way (produce a number in octal), use &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果省略EXPR，则使用&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。反之（使用八进制产生一个数字），请使用&lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d36eccdc92b1d6936c118cc354859012973685d8" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1172cb3a4a7f1f2dfc6dcf55076a98d031996813" translate="yes" xml:space="preserve">
          <source>If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; . To go the other way (produce a number in octal), use sprintf() or printf():</source>
          <target state="translated">如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。反之（使用八进制产生数字），请使用sprintf（）或printf（）：</target>
        </trans-unit>
        <trans-unit id="0835de1ae9d548d447faabd3d40dd3e5da356962" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE -- the first argument in a call to &lt;code&gt;open&lt;/code&gt; -- is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">如果FILEHANDLE-调用 &lt;code&gt;open&lt;/code&gt; 中的第一个参数-是未定义的标量变量（或数组或哈希元素），则将自动保存新的文件句柄，这意味着该变量被分配了对新分配的匿名文件句柄的引用。否则，如果FILEHANDLE是一个表达式，则其值为真实的文件句柄。（这被认为是象征性的参考，所以 &lt;code&gt;use strict &quot;refs&quot;&lt;/code&gt; 应该</target>
        </trans-unit>
        <trans-unit id="488f2cec4909ee80d1ac152c113a7f5b407ac400" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">如果FILEHANDLE是未定义的标量变量（或数组或哈希元素），则会自动生成新的文件句柄，这意味着该变量被分配了对新分配的匿名文件句柄的引用。否则，如果FILEHANDLE是一个表达式，则其值为真实的文件句柄。（这被认为是象征性的参考，所以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 应该</target>
        </trans-unit>
        <trans-unit id="7bf316535c25573b5c20cc7acfbdffbec7d384a1" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is an undefined scalar variable (or array or hash element), a new filehandle is autovivified, meaning that the variable is assigned a reference to a newly allocated anonymous filehandle. Otherwise if FILEHANDLE is an expression, its value is the real filehandle. (This is considered a symbolic reference, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; should</source>
          <target state="translated">如果FILEHANDLE是未定义的标量变量（或数组或哈希元素），则会自动生成新的文件句柄，这意味着该变量被分配了对新分配的匿名文件句柄的引用。否则，如果FILEHANDLE是一个表达式，则其值为真实的文件句柄。（这被认为是象征性的参考，所以 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 应该</target>
        </trans-unit>
        <trans-unit id="78b86feaadc89f11ca72025d1989c281686ea22c" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">如果未指定FILEHANDLE，则输出转到当前的默认输出通道，该通道以STDOUT开头，但可以由&lt;a href=&quot;#select-FILEHANDLE&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;运算符更改。如果FILEHANDLE是EXPR，则对表达式求值，并使用所得的字符串在运行时查找FILEHANDLE的名称。有关格式的更多信息，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7edd9359c1108403094d8175c9c20835e326b96f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">如果未指定FILEHANDLE，输出将转到当前的默认输出通道，该通道以STDOUT开头，但可以由 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 运算符更改。如果FILEHANDLE是EXPR，则将对表达式求值，并使用所得字符串在运行时查找FILEHANDLE的名称。有关格式的更多信息，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64a3c2a915faecffdca2e95dc4489ca8da06212f" translate="yes" xml:space="preserve">
          <source>If FILEHANDLE is unspecified, output goes to the current default output channel, which starts out as STDOUT but may be changed by the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; operator. If the FILEHANDLE is an EXPR, then the expression is evaluated and the resulting string is used to look up the name of the FILEHANDLE at run time. For more on formats, see &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;.</source>
          <target state="translated">如果未指定FILEHANDLE，输出将转到当前的默认输出通道，该通道以STDOUT开头，但可以由 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 运算符更改。如果FILEHANDLE是EXPR，则将对表达式求值，并使用所得字符串在运行时查找FILEHANDLE的名称。有关格式的更多信息，请参见&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7746cb09d04e425daae32ba450ffb46bfb9b6e05" translate="yes" xml:space="preserve">
          <source>If FILENAME doesn't exist on the filesystem, or if the filesystem doesn't support short ANSI filenames, then this function will translate the Unicode name into the system codepage using replacement characters.</source>
          <target state="translated">如果FILENAME在文件系统中不存在,或者文件系统不支持短的ANSI文件名,那么这个函数将使用替换字符将Unicode名称翻译成系统代码页。</target>
        </trans-unit>
        <trans-unit id="42bee98ad679afc0b47a6a37b45d0b7a351045fa" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">如果FUNCTION是以 &lt;code&gt;CORE::&lt;/code&gt; 开头的字符串，则其余部分将作为Perl内置函数的名称。如果原型（例如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ）无法充分表达内置参数，则prototype（）返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为内置函数的行为实际上不像Perl函数。否则，返回描述等效原型的字符串。</target>
        </trans-unit>
        <trans-unit id="cae550505561d57b299b4a003dc8830ba8e1ee71" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt; , the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;), prototype() returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">如果FUNCTION是以 &lt;code&gt;CORE::&lt;/code&gt; 开头的字符串，则其余部分将作为Perl内置函数的名称。如果原型（例如 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ）无法充分表达内置参数，则prototype（）返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因为内置函数的行为实际上不像Perl函数。否则，返回描述等效原型的字符串。</target>
        </trans-unit>
        <trans-unit id="0166703daf5c496c4bec8f243a081750014163a4" translate="yes" xml:space="preserve">
          <source>If FUNCTION is a string starting with &lt;code&gt;CORE::&lt;/code&gt;, the rest is taken as a name for a Perl builtin. If the builtin's arguments cannot be adequately expressed by a prototype (such as &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;), &lt;a href=&quot;#prototype-FUNCTION&quot;&gt;&lt;code&gt;prototype&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, because the builtin does not really behave like a Perl function. Otherwise, the string describing the equivalent prototype is returned.</source>
          <target state="translated">如果FUNCTION是以 &lt;code&gt;CORE::&lt;/code&gt; 开头的字符串，则其余部分将作为Perl内置函数的名称。如果原型（例如&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;）不能充分表达内建函数的参数，则&lt;a href=&quot;#prototype-FUNCTION&quot;&gt; &lt;code&gt;prototype&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;，因为内建函数的行为实际上不像Perl函数。否则，返回描述等效原型的字符串。</target>
        </trans-unit>
        <trans-unit id="cc31873f684622a14f7af2ea2005b39a1781e830" translate="yes" xml:space="preserve">
          <source>If G_ARRAY is specified</source>
          <target state="translated">如果指定了G_ARRAY</target>
        </trans-unit>
        <trans-unit id="abc56a2d0a54c75c4dee47cdfefa046b0f36c198" translate="yes" xml:space="preserve">
          <source>If G_DISCARD is specified, the return value will always be 0.</source>
          <target state="translated">如果指定了G_DISCARD,则返回值将始终为0。</target>
        </trans-unit>
        <trans-unit id="61b15d293eca2c7db4238b66ac8714ddc363a1b1" translate="yes" xml:space="preserve">
          <source>If G_SCALAR is specified</source>
          <target state="translated">如果指定了G_SCALAR</target>
        </trans-unit>
        <trans-unit id="5c71a194d71e5b8b3f592792b3f56c1d07d85df4" translate="yes" xml:space="preserve">
          <source>If I don't have My::TAP::Harness installed on @INC I need to provide the correct path to perl when I run prove:</source>
          <target state="translated">如果我没有在 @INC 上安装 My::TAP::Harness,当我运行 prove 时,我需要提供 perl 的正确路径。</target>
        </trans-unit>
        <trans-unit id="bd626ea4da9803c896a3f690bf6350bffa4a5047" translate="yes" xml:space="preserve">
          <source>If I don't see that &quot;Perl:&quot;, it's not from perl.</source>
          <target state="translated">如果我没有看到那个 &quot;Perl:&quot;,那就不是来自perl。</target>
        </trans-unit>
        <trans-unit id="03be8548f702da2e594e410d893934eeb0d8222b" translate="yes" xml:space="preserve">
          <source>If I have failing tests in a test suite that consists of more than a handful of scripts and takes more than a few seconds to run it rapidly becomes tedious to run the whole test suite repeatedly as I track down the problems.</source>
          <target state="translated">如果我在一个测试套件中出现了失败的测试,而这个测试套件由多个脚本组成,并且运行时间超过了几秒钟,那么当我追踪问题时,重复运行整个测试套件就会迅速变得乏味。</target>
        </trans-unit>
        <trans-unit id="da15fab02b636d1da580f8c8673ab702a8e74b65" translate="yes" xml:space="preserve">
          <source>If I need a feature that prove doesn't provide I can easily write my own.</source>
          <target state="translated">如果我需要一个证明没有提供的功能,我可以很容易地写出自己的功能。</target>
        </trans-unit>
        <trans-unit id="605963fd1be7406e13c1ff42eab8cd0d74775641" translate="yes" xml:space="preserve">
          <source>If I need to reach even deeper into the internals of the harness I can replace the classes that TAP::Parser uses to execute test scripts and tokenise their output. Before running a test script TAP::Parser creates a grammar (TAP::Parser::Grammar) to decode the raw TAP into tokens, a result factory (TAP::Parser::ResultFactory) to turn the decoded TAP results into objects and, depending on whether it's running a test script or reading TAP from a file, scalar or array a source or an iterator (TAP::Parser::IteratorFactory).</source>
          <target state="translated">如果我需要更深入地了解线束的内部结构,我可以替换TAP::Parser用来执行测试脚本和标记其输出的类。在运行测试脚本之前,TAP::Parser 会创建一个语法 (TAP::Parser::Grammar)来将原始的 TAP 解码为标记,一个结果工厂 (TAP::Parser::ResultFactory)来将解码后的 TAP 结果转化为对象,并根据是运行测试脚本还是从文件、标量或数组中读取 TAP,创建一个源或迭代器 (TAP::Parser::IteratorFactory)。</target>
        </trans-unit>
        <trans-unit id="985d558aa1f93c1b25225dff89cbd31a5a5a4d9a" translate="yes" xml:space="preserve">
          <source>If I save that as t/phptest.t the shebang line will ensure that it runs correctly along with all my other tests.</source>
          <target state="translated">如果我把它保存为t/phptest.t,shebang行将确保它和我所有其他测试一起正确运行。</target>
        </trans-unit>
        <trans-unit id="b9a5f2df715ea2336595f87758abbc0f6cdbf051" translate="yes" xml:space="preserve">
          <source>If I write a subclass of App::Prove I can customise any aspect of the test runner while inheriting all of prove's behaviour. Here's myprove:</source>
          <target state="translated">如果我写一个App::Prove的子类,我可以自定义测试运行器的任何方面,同时继承prove的所有行为。这里是myprove。</target>
        </trans-unit>
        <trans-unit id="74809ed417c3b37088be3b29e4f08e09fd27f388" translate="yes" xml:space="preserve">
          <source>If I'm running my tests in parallel there may also be a multiplexer (TAP::Parser::Multiplexer) - the component that allows multiple tests to run simultaneously.</source>
          <target state="translated">如果我的测试是并行运行的,还可能有一个多路复用器(TAP::Parser::Multiplexer)--允许多个测试同时运行的组件。</target>
        </trans-unit>
        <trans-unit id="7f881d9fe9fd9028d68d11b8271492af01bf7e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt; . If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">如果省略ID，则默认为 &lt;code&gt;1&lt;/code&gt; 。如果为ID指定单个字符，则使用该字符的数字值。</target>
        </trans-unit>
        <trans-unit id="3edb552ee59d2dff01961b99b98b93b199000e3c" translate="yes" xml:space="preserve">
          <source>If ID is omitted, it defaults to &lt;code&gt;1&lt;/code&gt;. If a single character is given for ID, the numeric value of that character is used.</source>
          <target state="translated">如果省略ID，则默认为 &lt;code&gt;1&lt;/code&gt; 。如果为ID指定单个字符，则使用该字符的数字值。</target>
        </trans-unit>
        <trans-unit id="b781e9bc0c2157f6dabdbd2804f21e2dc4d3a773" translate="yes" xml:space="preserve">
          <source>If KEY starts and ends with a slash, the string in between is treated as a regular expression and only keys matching this regexp are displayed</source>
          <target state="translated">如果KEY以斜杠开头和结尾,则中间的字符串将被视为正则表达式,并且只显示与此regexp匹配的键。</target>
        </trans-unit>
        <trans-unit id="97bf7fa576e4d2080ce6127c0f4cd5a7adce4cf1" translate="yes" xml:space="preserve">
          <source>If LAYER is omitted or specified as &lt;code&gt;:raw&lt;/code&gt; the filehandle is made suitable for passing binary data. This includes turning off possible CRLF translation and marking it as bytes (as opposed to Unicode characters). Note that, despite what may be implied in</source>
          <target state="translated">如果省略LAYER或将其指定为 &lt;code&gt;:raw&lt;/code&gt; ,则文件句柄适合于传递二进制数据。这包括关闭可能的CRLF转换并将其标记为字节（与Unicode字符相对）。请注意，尽管可能暗示</target>
        </trans-unit>
        <trans-unit id="283b8c8f4ffd49cdc5f923f3f2b2ef054e93376f" translate="yes" xml:space="preserve">
          <source>If LAYER is present it is a single string, but may contain multiple directives. The directives alter the behaviour of the filehandle. When LAYER is present, using binmode on a text file makes sense.</source>
          <target state="translated">如果LAYER存在,它是一个单一的字符串,但可能包含多个指令。这些指令会改变文件柄的行为。当LAYER存在时,在文本文件上使用binmode是有意义的。</target>
        </trans-unit>
        <trans-unit id="bc78056370f87ab6c8598a43f74f4b98bd9074c2" translate="yes" xml:space="preserve">
          <source>If LIMIT is negative, it is treated as if it were instead arbitrarily large; as many fields as possible are produced.</source>
          <target state="translated">如果LIMIT为负值,它将被当作任意大的字段来处理;产生尽可能多的字段。</target>
        </trans-unit>
        <trans-unit id="0394dbfeda7095aa516dcefff51b8b66aab7006b" translate="yes" xml:space="preserve">
          <source>If LIMIT is omitted (or, equivalently, zero), then it is usually treated as if it were instead negative but with the exception that trailing empty fields are stripped (empty leading fields are always preserved); if all fields are empty, then all fields are considered to be trailing (and are thus stripped in this case). Thus, the following:</source>
          <target state="translated">如果LIMIT被省略(或者,等价于零),那么它通常被当作负值处理,但例外的是,尾部的空字段会被剥离(空的前导字段总是被保留);如果所有字段都是空的,那么所有字段都被认为是尾部的(因此在这种情况下会被剥离)。因此,以下是:</target>
        </trans-unit>
        <trans-unit id="ec1ca6d6c3c8c30d74e46da0d1f8dfee1a937ce1" translate="yes" xml:space="preserve">
          <source>If LIMIT is specified and positive, it represents the maximum number of fields into which the EXPR may be split; in other words, LIMIT is one greater than the maximum number of times EXPR may be split. Thus, the LIMIT value &lt;code&gt;1&lt;/code&gt; means that EXPR may be split a maximum of zero times, producing a maximum of one field (namely, the entire value of EXPR). For instance:</source>
          <target state="translated">如果指定LIMIT并且为正，则表示EXPR可拆分为的最大字段数；换句话说，LIMIT比EXPR可以分割的最大次数大一个。因此，LIMIT值 &lt;code&gt;1&lt;/code&gt; 意味着EXPR最多可被拆分零次，从而最多生成一个字段（即EXPR的整个值）。例如：</target>
        </trans-unit>
        <trans-unit id="a1e79f492508e7edc8814a0c2f8fb560a886956d" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">如果LIST由空字符串组成，则 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 生成交互式DCL子&lt;b&gt;进程&lt;/b&gt;，其方式与在DCL提示符下键入&lt;b&gt;SPAWN&lt;/b&gt;相同。</target>
        </trans-unit>
        <trans-unit id="d577e3a6f68cf3804f6d29aac95c4927c6f793ba" translate="yes" xml:space="preserve">
          <source>If LIST consists of the empty string, &lt;code&gt;system&lt;/code&gt; spawns an interactive DCL subprocess, in the same fashion as typing &lt;b&gt;SPAWN&lt;/b&gt; at the DCL prompt.</source>
          <target state="translated">如果LIST由空字符串组成，则 &lt;code&gt;system&lt;/code&gt; 生成交互式DCL子&lt;b&gt;进程&lt;/b&gt;，其方式与在DCL提示符下键入&lt;b&gt;SPAWN&lt;/b&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c2cae660b4a3baec9a67c4d2cf72f2806437ed21" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果省略LIST，则&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;使用&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8af421f1352b89476d8e2fb680c100c5c55fb16a" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略LIST，则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15ba1dd13707a281770468c5a2f35927f1cf24ea" translate="yes" xml:space="preserve">
          <source>If LIST is omitted, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略LIST，则 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4da7e6771ebdbb0d68b845baa0f1af30e2550323" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value (typically from a previous &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;), then that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt;. This is useful for propagating exceptions:</source>
          <target state="translated">如果LIST为空或为空字符串，并且&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;已经包含一个异常值（通常来自先前的&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;），则在附加 &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 之后将重用该值。这对于传播异常很有用：</target>
        </trans-unit>
        <trans-unit id="84674bcf3d3a118952a055d14ce31826e4bf5479" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;; i.e., as if &lt;code&gt;$@ = eval { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">如果LIST为空或为空字符串，并且&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;包含具有 &lt;code&gt;PROPAGATE&lt;/code&gt; 方法的对象引用，则将使用其他文件和行号参数来调用该方法。返回值替换&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;的值；即，好像 &lt;code&gt;$@ = eval { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 被称为。</target>
        </trans-unit>
        <trans-unit id="281f7b6eb5d507578f647b0d70c67bd5a086771f" translate="yes" xml:space="preserve">
          <source>If LIST was empty or made an empty string, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is also empty, then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">如果LIST为空或为空字符串，并且&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;也为空，则使用字符串 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e6165dd99b5382a91584396109e05b591d171e0" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt;, the file is opened for input (read-only). If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, the file is opened for appending, again being created if necessary.</source>
          <target state="translated">如果MODE是 &lt;code&gt;&amp;lt;&lt;/code&gt; ，则打开文件以供输入（只读）。如果MODE为 &lt;code&gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行输出，首先将现有文件截断（&amp;ldquo;弄皱&amp;rdquo;），然后重新创建不存在的文件。如果MODE为 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，则打开文件以进行追加，并在必要时再次创建。</target>
        </trans-unit>
        <trans-unit id="17ef4f93ed053708e4daa4192a3c5a507017945b" translate="yes" xml:space="preserve">
          <source>If MODE is &lt;code&gt;|-&lt;/code&gt;, then the filename is interpreted as a command to which output is to be piped, and if MODE is &lt;code&gt;-|&lt;/code&gt;, the filename is interpreted as a command that pipes output to us. In the two-argument (and one-argument) form, one should replace dash (&lt;code&gt;-&lt;/code&gt;) with the command. See &lt;a href=&quot;perlipc#Using-open%28%29-for-IPC&quot;&gt;&quot;Using open() for IPC&quot; in perlipc&lt;/a&gt; for more examples of this. (You are not allowed to &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; to a command that pipes both in</source>
          <target state="translated">如果MODE是 &lt;code&gt;|-&lt;/code&gt; ，则文件名将解释为将输出传递到的命令，并且如果MODE是 &lt;code&gt;-|&lt;/code&gt; 。，文件名被解释为将输出传递给我们的命令。在二参数（和一参数）形式中，应使用命令替换破折号（ &lt;code&gt;-&lt;/code&gt; ）。有关更多示例，请参见&lt;a href=&quot;perlipc#Using-open%28%29-for-IPC&quot;&gt;perlipc中的&amp;ldquo;对IPC使用open（）&amp;rdquo;&lt;/a&gt;。（不允许您&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;同时将两个管道</target>
        </trans-unit>
        <trans-unit id="f8725f581ae126bd53637cc6004bb31b10e046db" translate="yes" xml:space="preserve">
          <source>If Mac::Files could not be loaded, the empty string is returned.</source>
          <target state="translated">如果Mac::Files不能被加载,则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="9556835597cabed412f1a27672edf9d6d8a5a68b" translate="yes" xml:space="preserve">
          <source>If N is &amp;gt; 0, rounds to the Nth digit from the left. If N &amp;lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &amp;lt; 0 is a no-op for them.</source>
          <target state="translated">如果N&amp;gt; 0，则从左舍入到第N个数字。如果N &amp;lt;0，则四舍五入到点后的第N位。由于BigInts是整数，因此N &amp;lt;0的情况对它们而言是空操作。</target>
        </trans-unit>
        <trans-unit id="7bb11b5e3bbf2cecd073552e16a6087ed08e448b" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果省略NUMBER，则使用&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="809aa45c402e18c1090663e0bbd2fdac630054bb" translate="yes" xml:space="preserve">
          <source>If NUMBER is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果省略NUMBER，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41978e4e598bdad208f30664c01c64d67097badb" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">如果OFFSET和LENGTH指定了部分位于字符串外部的子字符串，则仅返回字符串中的部分。如果子字符串超出字符串的任何一端，则&lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt;返回未定义的值并产生警告。当用作左值时，指定完全在字符串之外的子字符串会引发异常。这是显示边界情况的行为的示例：</target>
        </trans-unit>
        <trans-unit id="6e18ed7b6aa1dfe2acf7667704a25f494c6c53b1" translate="yes" xml:space="preserve">
          <source>If OFFSET and LENGTH specify a substring that is partly outside the string, only the part within the string is returned. If the substring is beyond either end of the string, substr() returns the undefined value and produces a warning. When used as an lvalue, specifying a substring that is entirely outside the string raises an exception. Here's an example showing the behavior for boundary cases:</source>
          <target state="translated">如果OFFSET和LENGTH指定的子串有一部分在字符串之外,那么只返回字符串内的部分。如果子串超出了字符串的任何一端,substr()将返回未定义的值并产生一个警告。当作为一个l值使用时,指定一个完全在字符串之外的子串会引发一个异常。这里有一个例子显示了边界情况下的行为。</target>
        </trans-unit>
        <trans-unit id="805a2c8a87b8f6b59ee6ee34433c46d30a4b7687" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">如果PATTERN是 &lt;code&gt;/^/&lt;/code&gt; ，则将其视为使用了&lt;a href=&quot;../perlreref#OPERATORS&quot;&gt;多行修饰符&lt;/a&gt;（ &lt;code&gt;/^/m&lt;/code&gt; ），因为在其他情况下它并没有太多用处。</target>
        </trans-unit>
        <trans-unit id="f31e710fa5dc3bb0149beaea0c04322fd5b027e6" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt; , then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt; ), since it isn't much use otherwise.</source>
          <target state="translated">如果PATTERN是 &lt;code&gt;/^/&lt;/code&gt; ，则将其视为使用了&lt;a href=&quot;perlreref#OPERATORS&quot;&gt;多行修饰符&lt;/a&gt;（ &lt;code&gt;/^/m&lt;/code&gt; ），因为在其他情况下它并没有太多用处。</target>
        </trans-unit>
        <trans-unit id="0d84847fbb60054df16b3ab82d500263906bc774" translate="yes" xml:space="preserve">
          <source>If PATTERN is &lt;code&gt;/^/&lt;/code&gt;, then it is treated as if it used the &lt;a href=&quot;perlreref#OPERATORS&quot;&gt;multiline modifier&lt;/a&gt; (&lt;code&gt;/^/m&lt;/code&gt;), since it isn't much use otherwise.</source>
          <target state="translated">如果PATTERN是 &lt;code&gt;/^/&lt;/code&gt; ，则将其视为使用了&lt;a href=&quot;perlreref#OPERATORS&quot;&gt;多行修饰符&lt;/a&gt;（ &lt;code&gt;/^/m&lt;/code&gt; ），因为在其他情况下它并没有太多用处。</target>
        </trans-unit>
        <trans-unit id="8ab2206e4a8b71981bc3526b21e6f961d2fc978f" translate="yes" xml:space="preserve">
          <source>If PATTERN matches the empty string, the EXPR is split at the match position (between characters). As an example, the following:</source>
          <target state="translated">如果PATTERN与空字符串匹配,则EXPR在匹配位置(字符之间)被分割。举个例子,如下。</target>
        </trans-unit>
        <trans-unit id="bf4c909b9fa78435a98bf6dd9ce2fb396fdd71cb" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">如果未定义PERL5LIB，则使用&lt;a href=&quot;#PERLLIB&quot;&gt;&amp;ldquo; PERLLIB&amp;rdquo;&lt;/a&gt;。目录由Unixish平台上的冒号和Windows上的分号分隔（如PATH中的路径）（适当的路径分隔符由命令 &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; 给出）。</target>
        </trans-unit>
        <trans-unit id="d1b7e2477c70af9a1ce418a622d9557a0b72af87" translate="yes" xml:space="preserve">
          <source>If PERL5LIB is not defined, PERLLIB is used. Directories are separated (like in PATH) by a colon on Unixish platforms and by a semicolon on Windows (the proper path separator being given by the command &lt;code&gt;perl
-V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt;).</source>
          <target state="translated">如果未定义PERL5LIB，则使用PERLLIB。目录由Unixish平台上的冒号和Windows上的分号分隔（如PATH中的路径）（适当的路径分隔符由命令 &lt;code&gt;perl -V:&lt;i&gt;path_sep&lt;/i&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e3cb4284864a564ca2b51274a4f3fa62dd73a592" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_ALL is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if PERL_PV_ESCAPE_NONASCII is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt; . Otherwise, if PERL_PV_ESCAPE_NOBACKSLASH then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_ALL，则将使用 &lt;code&gt;\x01F1&lt;/code&gt; 样式转义符输出所有输入字符，否则，如果设置了PERL_PV_ESCAPE_NONASCII，将仅使用此样式转义非ASCII字符；否则，只有255以上的字符会被转义；其他不可打印的字符将使用八进制或常见的转义模式，例如 &lt;code&gt;\n&lt;/code&gt; 。否则，如果PERL_PV_ESCAPE_NOBACKSLASH，则所有低于255的字符都将被视为可打印，并将其输出为文字。</target>
        </trans-unit>
        <trans-unit id="03a5b31adb12c35d2862c64e653c8076e4f81a1b" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_FIRSTCHAR is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_FIRSTCHAR，则无论最大字符数如何，仅字符串的第一个字符都将被转义。如果输出为十六进制，则将其作为普通十六进制序列返回。因此输出将是单个字符，八进制转义序列，特殊转义（如 &lt;code&gt;\n&lt;/code&gt; 或十六进制值）。</target>
        </trans-unit>
        <trans-unit id="4fd0e08a5001bbfc2db16575c706877131f99c11" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_RE is set then the escape char used will be a '%' and not a '\\'. This is because regexes very often contain backslashed sequences, whereas '%' is not a particularly common character in patterns.</source>
          <target state="translated">如果PERL_PV_ESCAPE_RE被设置,那么使用的转义字符将是'%'而不是'\\'。这是因为regexes经常包含反斜线序列,而'%'在模式中不是一个特别常见的字符。</target>
        </trans-unit>
        <trans-unit id="c327fff20e1a2d0d479391141282091e826a55c6" translate="yes" xml:space="preserve">
          <source>If PERL_PV_ESCAPE_UNI is set then the input string is treated as UTF-8 if PERL_PV_ESCAPE_UNI_DETECT is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">如果设置了PERL_PV_ESCAPE_UNI，则将输入字符串视为UTF-8；如果设置了PERL_PV_ESCAPE_UNI_DETECT，则将使用 &lt;code&gt;is_utf8_string()&lt;/code&gt; 扫描输入字符串，以确定其是否为UTF-8。</target>
        </trans-unit>
        <trans-unit id="19515a44b91c296bde08fb195c3206ce5ee06393" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt; . If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">如果PID是由管道 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 启动的子过程（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;），则 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 将等待该子过程，并以 &lt;code&gt;$?&lt;/code&gt; 返回其最终状态值。。如果PID是以其他方式创建的子进程（例如，在调用Perl之前被SPAWNed），则 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 将仅每秒检查一次该进程是否已完成，并在完成时返回。（如果PID指定的进程不是当前进程的子进程，并且您使用 &lt;code&gt;-w&lt;/code&gt; 开关调用了Perl，则会发出警告。）</target>
        </trans-unit>
        <trans-unit id="e7c89908fc623a7d026e9fd9f90cd1799c25d8d3" translate="yes" xml:space="preserve">
          <source>If PID is a subprocess started by a piped &lt;code&gt;open()&lt;/code&gt; (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;), &lt;code&gt;waitpid&lt;/code&gt; will wait for that subprocess, and return its final status value in &lt;code&gt;$?&lt;/code&gt;. If PID is a subprocess created in some other way (e.g. SPAWNed before Perl was invoked), &lt;code&gt;waitpid&lt;/code&gt; will simply check once per second whether the process has completed, and return when it has. (If PID specifies a process that isn't a subprocess of the current process, and you invoked Perl with the &lt;code&gt;-w&lt;/code&gt; switch, a warning will be issued.)</source>
          <target state="translated">如果PID是通过管道 &lt;code&gt;open()&lt;/code&gt; 启动的子过程（请参见&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;），则 &lt;code&gt;waitpid&lt;/code&gt; 将等待该子过程，并以 &lt;code&gt;$?&lt;/code&gt; 返回其最终状态值。。如果PID是通过其他方式创建的子进程（例如，在调用Perl之前被SPAWNed），则 &lt;code&gt;waitpid&lt;/code&gt; 将简单地每秒检查一次该进程是否完成，并在完成时返回。 （如果PID指定的进程不是当前进程的子进程，并且您使用 &lt;code&gt;-w&lt;/code&gt; 开关调用了Perl，则会发出警告。）</target>
        </trans-unit>
        <trans-unit id="2833d231deee2ce7c48c3ef06baaabad2e5a0de9" translate="yes" xml:space="preserve">
          <source>If PPCODE: directive is not used, &lt;code&gt;void&lt;/code&gt; return value should be used only for subroutines which do not return a value,</source>
          <target state="translated">如果未使用PPCODE：指令，则 &lt;code&gt;void&lt;/code&gt; 返回值应仅用于不返回值的子例程，</target>
        </trans-unit>
        <trans-unit id="c393beed824f2acf513d9860e129eb5ffe2baeec" translate="yes" xml:space="preserve">
          <source>If PadnameOUTER is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">如果PadnameOUTER被设置在垫名上,那么框架AV中的那个槽就是一个来自 &quot;外部 &quot;的词条的REFCNT'ed引用。这种条目有时被称为'假'。在这种情况下,名字没有使用'low'和'high'来存储cop_seq范围,因为它在整个范围内。相反,'high'存储了一些包含真实词库信息的标志(它是否在anon中声明,是否能够被多次实例化?),对于假的anon,'low'包含了父代pad内的索引,在那里存储了词库的值,以使克隆更快。</target>
        </trans-unit>
        <trans-unit id="40be3d27de878e5185ba9875f176a67d8334894d" translate="yes" xml:space="preserve">
          <source>If Perl cannot find the method in any of these classes, it will die with an error message.</source>
          <target state="translated">如果Perl找不到这些类中的任何一个方法,它就会以错误信息死亡。</target>
        </trans-unit>
        <trans-unit id="ef114bcc0bbc93d31f879d70b2e23b29c28c176d" translate="yes" xml:space="preserve">
          <source>If Perl detects that there are problems with the locale collation order, it reverts to using non-locale collation rules for that locale.</source>
          <target state="translated">如果Perl检测到locale整理顺序有问题,它就会恢复使用该locale的非locale整理规则。</target>
        </trans-unit>
        <trans-unit id="3a89c2d4d03a490ab54c26429553ad753f25a36f" translate="yes" xml:space="preserve">
          <source>If Perl finds that the found executable is of PM type when the current session is not, it will start the new process in a separate session of necessary type. Call via &lt;code&gt;OS2::Process&lt;/code&gt; to disable this magic.</source>
          <target state="translated">如果Perl在当前会话不在时发现找到的可执行文件是PM类型，它将在必要类型的单独会话中启动新进程。通过 &lt;code&gt;OS2::Process&lt;/code&gt; 调用以禁用此魔术。</target>
        </trans-unit>
        <trans-unit id="289a7b0542dd20aefdd9191d5f173083a238571f" translate="yes" xml:space="preserve">
          <source>If Perl has been compiled using Perl's malloc you can analyze Perl memory usage by setting $ENV{PERL_DEBUG_MSTATS}.</source>
          <target state="translated">如果Perl是使用Perl的malloc编译的,你可以通过设置$ENV{PERL_DEBUG_MSTATS}来分析Perl的内存使用情况。</target>
        </trans-unit>
        <trans-unit id="230e2bfc79d0ba462c1beaf813fc67b45a5f8378" translate="yes" xml:space="preserve">
          <source>If Perl is not built to use PerlIO as its IO system then only the two pseudo-layers &lt;code&gt;:bytes&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; are available.</source>
          <target state="translated">如果未构建Perl来使用PerlIO作为其IO系统，则只有两个伪层 &lt;code&gt;:bytes&lt;/code&gt; 和 &lt;code&gt;:crlf&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="6264d3e40b3079f00ff5fcba981797a472b669d0" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">如果Perl不是由套接字支持构建的，则 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的系统调用版本完全不可用。如果存在套接字支持，则 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 函数的系统调用版本仅适用于附加到套接字的文件描述符。它不会提供有关常规文件或管道的信息，因为CRTL &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 例程不提供此功能。</target>
        </trans-unit>
        <trans-unit id="35e051c99f37dfed774297cb967d8106c5e199d4" translate="yes" xml:space="preserve">
          <source>If Perl was not built with socket support, the system call version of &lt;code&gt;select&lt;/code&gt; is not available at all. If socket support is present, then the system call version of &lt;code&gt;select&lt;/code&gt; functions only for file descriptors attached to sockets. It will not provide information about regular files or pipes, since the CRTL &lt;code&gt;select()&lt;/code&gt; routine does not provide this functionality.</source>
          <target state="translated">如果Perl不是由套接字支持构建的，则 &lt;code&gt;select&lt;/code&gt; 的系统调用版本完全不可用。如果存在套接字支持，则 &lt;code&gt;select&lt;/code&gt; 函数的系统调用版本仅适用于附加到套接字的文件描述符。它不会提供有关常规文件或管道的信息，因为CRTL &lt;code&gt;select()&lt;/code&gt; 例程不提供此功能。</target>
        </trans-unit>
        <trans-unit id="f4a129f6da7edb3d3e9d992e64ee7ec5edc1382d" translate="yes" xml:space="preserve">
          <source>If Perldoc is running under MSWin and uses this class as a formatter, the output will be opened with</source>
          <target state="translated">如果Perldoc在MSWin下运行,并且使用这个类作为格式化器,那么输出将用以下方式打开</target>
        </trans-unit>
        <trans-unit id="48a7e7d61da87b6e49574cb96f576ab3af92a97c" translate="yes" xml:space="preserve">
          <source>If Pod::Man is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Man and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">如果为Pod :: Man提供了 &lt;code&gt;utf8&lt;/code&gt; 选项，则在可能的情况下，其输出文件句柄的编码将被强制为UTF-8，从而覆盖任何现有编码。即使文件句柄不是由Pod :: Man创建的，也不是从外部传入的，也可以这样做。无论PERL_UNICODE和其他设置如何，都可以保持一致性。</target>
        </trans-unit>
        <trans-unit id="89e668a66a16049973d228d4291fce70e3c9695a" translate="yes" xml:space="preserve">
          <source>If Pod::Man is unavailable, this function will warn and return undef.</source>
          <target state="translated">如果Pod::Man不可用,该函数将发出警告并返回undef。</target>
        </trans-unit>
        <trans-unit id="0b2424487d45dbfa5c1b518ecd9497b822e7398c" translate="yes" xml:space="preserve">
          <source>If Pod::Simple sends an event where the element name has a dash, period, or colon, the corresponding method name will have a underscore in its place. For example, &quot;foo.bar:baz&quot; becomes start_foo_bar_baz and end_foo_bar_baz.</source>
          <target state="translated">如果Pod::Simple发送的事件中元素名有破折号、句号或冒号,那么对应的方法名就会有一个下划线。例如,&quot;foo.bar:baz &quot;会变成start_foo_bar_baz和end_foo_bar_baz。</target>
        </trans-unit>
        <trans-unit id="9e0153ee2898f6429d842dbcd6c0696456ff28ca" translate="yes" xml:space="preserve">
          <source>If Pod::Text is given the &lt;code&gt;utf8&lt;/code&gt; option, the encoding of its output file handle will be forced to UTF-8 if possible, overriding any existing encoding. This will be done even if the file handle is not created by Pod::Text and was passed in from outside. This maintains consistency regardless of PERL_UNICODE and other settings.</source>
          <target state="translated">如果为Pod :: Text提供了 &lt;code&gt;utf8&lt;/code&gt; 选项，则如果可能的话，其输出文件句柄的编码将被强制为UTF-8，从而覆盖任何现有编码。即使文件句柄不是由Pod :: Text创建的，也不是从外部传入的，也可以这样做。无论PERL_UNICODE和其他设置如何，都可以保持一致性。</target>
        </trans-unit>
        <trans-unit id="a28c6ae29cd39f20d43e841a87f74f6e887bacb7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will behave like &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">如果除了此标志之外还设置了RXf_WHITE，则在Perl引擎下， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的行为将类似于 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; &quot; &quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf4453d6aaace8cb227f665bb65347d32d2472e7" translate="yes" xml:space="preserve">
          <source>If RXf_WHITE is set in addition to this flag, &lt;code&gt;split&lt;/code&gt; will behave like &lt;code&gt;split &quot; &quot;&lt;/code&gt; under the Perl engine.</source>
          <target state="translated">如果除了此标志之外还设置了RXf_WHITE，则在Perl引擎下， &lt;code&gt;split&lt;/code&gt; 的行为类似于 &lt;code&gt;split &quot; &quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03dddb9eda0980e6158ca2dd506258dca11f657b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">如果SIGNAL是数字0或字符串 &lt;code&gt;ZERO&lt;/code&gt; （或 &lt;code&gt;SIGZERO&lt;/code&gt; ），则不会向该进程发送任何信号，但是 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 检查它是否为</target>
        </trans-unit>
        <trans-unit id="a487625a13afee57a95232e398ffaae21162742b" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt; ), no signal is sent to the process, but &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks whether it's</source>
          <target state="translated">如果SIGNAL是数字0或字符串 &lt;code&gt;ZERO&lt;/code&gt; （或 &lt;code&gt;SIGZERO&lt;/code&gt; ），则不会向该进程发送任何信号，但是 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 检查它是否为</target>
        </trans-unit>
        <trans-unit id="760e1ef9a0dd7acd780a886234880aed4a2bbd19" translate="yes" xml:space="preserve">
          <source>If SIGNAL is either the number 0 or the string &lt;code&gt;ZERO&lt;/code&gt; (or &lt;code&gt;SIGZERO&lt;/code&gt;), no signal is sent to the process, but &lt;a href=&quot;#kill-SIGNAL%2C-LIST&quot;&gt;&lt;code&gt;kill&lt;/code&gt;&lt;/a&gt; checks whether it's</source>
          <target state="translated">如果SIGNAL是数字0或字符串 &lt;code&gt;ZERO&lt;/code&gt; （或 &lt;code&gt;SIGZERO&lt;/code&gt; ），则不会向该进程发送任何信号，但是&lt;a href=&quot;#kill-SIGNAL%2C-LIST&quot;&gt; &lt;code&gt;kill&lt;/code&gt; &lt;/a&gt;检查它是否为</target>
        </trans-unit>
        <trans-unit id="e68aad72417aeb3ce465d6bb5919f187ede4dff2" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt;, depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">如果省略SUBNAME或BLOCK，则按标准字符串比较顺序&lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;s进行排序。如果指定了SUBNAME，它将给出一个子例程的名称，该子例程返回一个小于，等于或大于 &lt;code&gt;0&lt;/code&gt; 的整数，具体取决于列表元素的排序方式。 （ &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;cmp&lt;/code&gt; 运算符在此类例程中非常有用。）SUBNAME可以是标量变量名称（未下标），在这种情况下，该值提供要使用的实际子例程的名称（或引用）。您可以提供一个BLOCK作为匿名的内联排序子例程来代替SUBNAME。</target>
        </trans-unit>
        <trans-unit id="34e4af5120e01452063bdba16ab4dbac8800d707" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">如果省略SUBNAME或BLOCK，则按标准字符串比较顺序 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; s进行排序。如果指定了SUBNAME，它将给出一个子例程的名称，该子例程将返回一个小于，等于或大于 &lt;code&gt;0&lt;/code&gt; 的整数，具体取决于列表元素的排序方式。 （ &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;cmp&lt;/code&gt; 运算符在此类例程中非常有用。）SUBNAME可能是标量变量名称（未下标），在这种情况下，该值提供要使用的实际子例程的名称（或引用）。您可以提供一个BLOCK作为匿名的内联排序子例程来代替SUBNAME。</target>
        </trans-unit>
        <trans-unit id="6247155ef0e0949eed5f5b9ad662fcdc5e0b1a55" translate="yes" xml:space="preserve">
          <source>If SUBNAME or BLOCK is omitted, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;s in standard string comparison order. If SUBNAME is specified, it gives the name of a subroutine that returns an integer less than, equal to, or greater than &lt;code&gt;0&lt;/code&gt; , depending on how the elements of the list are to be ordered. (The &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators are extremely useful in such routines.) SUBNAME may be a scalar variable name (unsubscripted), in which case the value provides the name of (or a reference to) the actual subroutine to use. In place of a SUBNAME, you can provide a BLOCK as an anonymous, in-line sort subroutine.</source>
          <target state="translated">如果省略SUBNAME或BLOCK，则按标准字符串比较顺序 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; s进行排序。如果指定了SUBNAME，它将给出一个子例程的名称，该子例程将返回一个小于，等于或大于 &lt;code&gt;0&lt;/code&gt; 的整数，具体取决于列表元素的排序方式。 （ &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 和 &lt;code&gt;cmp&lt;/code&gt; 运算符在此类例程中非常有用。）SUBNAME可能是标量变量名称（未下标），在这种情况下，该值提供要使用的实际子例程的名称（或引用）。您可以提供一个BLOCK作为匿名的内联排序子例程来代替SUBNAME。</target>
        </trans-unit>
        <trans-unit id="e18998d6455bfefedf4a886cffa8b0ef65421368" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; is given, &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">如果模板需要的参数比&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;给出，&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;承担额外的 &lt;code&gt;&quot;&quot;&lt;/code&gt; 论据。如果TEMPLATE需要的参数少于给定的参数，则多余的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="3a13dff4a6a23dd2b6f1693ccf60f7a4736231a4" translate="yes" xml:space="preserve">
          <source>If TEMPLATE requires more arguments than pack() is given, pack() assumes additional &lt;code&gt;&quot;&quot;&lt;/code&gt; arguments. If TEMPLATE requires fewer arguments than given, extra arguments are ignored.</source>
          <target state="translated">如果TEMPLATE需要的参数多于给定的pack（），则pack（）会采用其他 &lt;code&gt;&quot;&quot;&lt;/code&gt; 参数。如果TEMPLATE需要的参数少于给定的参数，则多余的参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="6967af7192ea24b7740b2426c675e802544ce8cd" translate="yes" xml:space="preserve">
          <source>If UTF-8 is not an option, it is recommended that one use a simple source filter, such as that provided by &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter::Encoding&lt;/a&gt; on CPAN or this pragma's own &lt;code&gt;Filter&lt;/code&gt; option (see below).</source>
          <target state="translated">如果不选择UTF-8，建议使用简单的源过滤器，例如CPAN上的&lt;a href=&quot;Filter::Encoding&quot;&gt;Filter :: Encoding&lt;/a&gt;提供的过滤器或此编译指示自己的 &lt;code&gt;Filter&lt;/code&gt; 选项（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="fcb29e6534b18adbdd32bd69eb254a626c55b85e" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (See &lt;a href=&quot;Test::API&quot;&gt;Test::API&lt;/a&gt;) then any event that has made its way through a hub will be tagged with a UUID. A newly created event will not yet be tagged in most cases.</source>
          <target state="translated">如果启用了UUID标记（请参阅&lt;a href=&quot;Test::API&quot;&gt;Test :: API&lt;/a&gt;），则任何通过集线器进行的事件都将被标记为UUID。在大多数情况下，新创建的事件仍不会被标记。</target>
        </trans-unit>
        <trans-unit id="8de2a274592488096eee3c1b57b817384e167ac5" translate="yes" xml:space="preserve">
          <source>If UUID tagging is enabled (see &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt;) then the hub will have a UUID.</source>
          <target state="translated">如果启用了UUID标记（请参阅&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt;），则集线器将具有UUID。</target>
        </trans-unit>
        <trans-unit id="71eeb63629102190a2491abe8e8c2cd018b18803" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">如果Unix级别的 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 不适合（例如）套接字，则&amp;ldquo; unix&amp;rdquo;层可以用&amp;ldquo; socket&amp;rdquo;层替换（在开放时间甚至动态地）。</target>
        </trans-unit>
        <trans-unit id="4ad97d1c9f2c86a7f96565662052eb1a286aaff7" translate="yes" xml:space="preserve">
          <source>If Unix level &lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;/&lt;code&gt;lseek&lt;/code&gt; is not appropriate for (say) sockets then the &quot;unix&quot; layer can be replaced (at open time or even dynamically) with a &quot;socket&quot; layer.</source>
          <target state="translated">如果Unix级别的 &lt;code&gt;read&lt;/code&gt; / &lt;code&gt;write&lt;/code&gt; / &lt;code&gt;lseek&lt;/code&gt; 不适合（例如）套接字，则&amp;ldquo; unix&amp;rdquo;层可以用&amp;ldquo; socket&amp;rdquo;层替换（在开放时间或什至是动态地）。</target>
        </trans-unit>
        <trans-unit id="a45f1369b52ed08794c418037dc006ec04f43394" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; iterator in the process.</source>
          <target state="translated">如果VARIABLE是散列，则它将剔除散列的值，而不是其键，从而重置进程中的&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;迭代器。</target>
        </trans-unit>
        <trans-unit id="adc19b00b38eb533e11534d089e59dc6d18d7552" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">如果VARIABLE是散列，则它将剔除散列的值而不是其键，从而重置进程中的 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="dafdb7a192ed4ebf56859ae04ece9ebbc7f84c1d" translate="yes" xml:space="preserve">
          <source>If VARIABLE is a hash, it chomps the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">如果VARIABLE是散列，则它将剔除散列的值而不是其键，从而重置进程中的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="748a0699c69c26183bfd333929c05d94a8696f0e" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;a href=&quot;#package-NAMESPACE&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">如果提供了VERSION，则&lt;a href=&quot;#package-NAMESPACE&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; &lt;code&gt;$VERSION&lt;/code&gt; 给定名称空间中的$ VERSION变量设置为具有VERSION的&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。VERSION必须是&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块定义的&amp;ldquo;严格&amp;rdquo;样式版本号：不带指数的正十进制数字（整数或十进制小数），或者是带小数点后的v字符串（带有前导&amp;ldquo; v&amp;rdquo;字符和至少三个）成分。每个软件包只应设置一次 &lt;code&gt;$VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9c742cbb93e88b3095e1366a5e0ca8820689343" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">如果提供了VERSION，则 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$VERSION&lt;/code&gt; 给定名称空间中的$ VERSION变量设置为具有VERSION的&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;对象。VERSION必须是&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块所定义的&amp;ldquo;严格&amp;rdquo;样式版本号：不带幂的十进制正数（整数或十进制小数），或者是带小数点后的v字符串（带有前导&amp;ldquo; v&amp;rdquo;字符和至少三个）组件。每个软件包只应设置一次 &lt;code&gt;$VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bfad8b6a5366a04a7526e534903361716196c11" translate="yes" xml:space="preserve">
          <source>If VERSION is provided, &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; sets the &lt;code&gt;$VERSION&lt;/code&gt; variable in the given namespace to a &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; object with the VERSION provided. VERSION must be a &quot;strict&quot; style version number as defined by the &lt;a href=&quot;../version&quot;&gt;version&lt;/a&gt; module: a positive decimal number (integer or decimal-fraction) without exponentiation or else a dotted-decimal v-string with a leading 'v' character and at least three components. You should set &lt;code&gt;$VERSION&lt;/code&gt; only once per package.</source>
          <target state="translated">如果提供了VERSION，则 &lt;code&gt;&lt;a href=&quot;package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; &lt;code&gt;$VERSION&lt;/code&gt; 给定名称空间中的$ VERSION变量设置为具有VERSION的&lt;a href=&quot;../version&quot;&gt;版本&lt;/a&gt;对象。VERSION必须是&lt;a href=&quot;../version&quot;&gt;版本&lt;/a&gt;模块所定义的&amp;ldquo;严格&amp;rdquo;样式版本号：不带幂的十进制正数（整数或十进制小数），或者是带小数点后的v字符串（带有前导&amp;ldquo; v&amp;rdquo;字符和至少三个）组件。每个软件包只应设置一次 &lt;code&gt;$VERSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">如果一个</target>
        </trans-unit>
        <trans-unit id="d95c8bef773580433166be7c2c32b85e8e849e6f" translate="yes" xml:space="preserve">
          <source>If a 2-digit code is entered, it is converted to 3 digits by prepending a 0.</source>
          <target state="translated">如果输入的是2位数的代码,则会在前面加上0,转换为3位数。</target>
        </trans-unit>
        <trans-unit id="e64a7d7369be70b0218a1b95be79c2c2deb28c1d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; is used in a context that is looking for a list, a list comprising all input lines is returned, one line per list element. It's easy to grow to a rather large data space this way, so use with care.</source>
          <target state="translated">如果在正在查找列表的上下文中使用 &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; ，则返回包含所有输入行的列表，每个列表元素一行。这样很容易扩展到相当大的数据空间，因此请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="259cdf2dd383c0f84fbe2ca3b6aceeeeaeccb785" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt; ; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt; , a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 可以在上下文堆栈中找到 &lt;code&gt;CxEVAL&lt;/code&gt; 块，则将堆栈弹出到该级别，并将该块中的返回操作分配给 &lt;code&gt;PL_restartop&lt;/code&gt; ；然后执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。通常，这会将控制权交还给警卫队。在 &lt;code&gt;perl_run&lt;/code&gt; 和 &lt;code&gt;call_sv&lt;/code&gt; 的情况下，非null的 &lt;code&gt;PL_restartop&lt;/code&gt; 触发重新进入runops循环。这是在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中处理 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的正常方法。</target>
        </trans-unit>
        <trans-unit id="2e842b426c14ec5c17e64ac341313bcce514b5ce" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式有效（请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 所使用的大小写映射是从当前语言环境获取的。如果使用Unicode（例如 &lt;code&gt;\N{}&lt;/code&gt; 或0x100或更高的代码点），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 使用的大小写映射由Unicode定义。这意味着对单个字符进行大小写映射有时会产生多个字符的序列。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境下， &lt;code&gt;\F&lt;/code&gt; 产生的结果与 &lt;code&gt;\L&lt;/code&gt; 用于除UTF-8之外的所有语言环境，它使用Unicode定义。</target>
        </trans-unit>
        <trans-unit id="549e5fcf45cf7944f8141812970bb7a27ad11345" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">如果在调用 &lt;code&gt;quit&lt;/code&gt; 方法之前 &lt;code&gt;Net::POP3&lt;/code&gt; 对象超出范围，则在关闭连接之前将调用 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 方法。这意味着任何标记为要删除的消息都不会。</target>
        </trans-unit>
        <trans-unit id="a47a3059ef284fb95d6b9b8a42daebf746f1630a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Net::POP3&lt;/code&gt; object goes out of scope before &lt;code&gt;quit&lt;/code&gt; method is called then the &lt;code&gt;reset&lt;/code&gt; method will called before the connection is closed. This means that any messages marked to be deleted will not be.</source>
          <target state="translated">如果在调用 &lt;code&gt;quit&lt;/code&gt; 方法之前 &lt;code&gt;Net::POP3&lt;/code&gt; 对象超出范围，则将在关闭连接之前调用 &lt;code&gt;reset&lt;/code&gt; 方法。这意味着任何标记为要删除的邮件都不会。</target>
        </trans-unit>
        <trans-unit id="50ca4e33c078b9485b94c680710b01ed3f239b5b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;die&lt;/code&gt; can find a &lt;code&gt;CxEVAL&lt;/code&gt; block on the context stack, then the stack is popped to that level and the return op in that block is assigned to &lt;code&gt;PL_restartop&lt;/code&gt;; then a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; is performed. This normally passes control back to the guard. In the case of &lt;code&gt;perl_run&lt;/code&gt; and &lt;code&gt;call_sv&lt;/code&gt;, a non-null &lt;code&gt;PL_restartop&lt;/code&gt; triggers re-entry to the runops loop. The is the normal way that &lt;code&gt;die&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; is handled within an &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;die&lt;/code&gt; 可以在上下文堆栈中找到 &lt;code&gt;CxEVAL&lt;/code&gt; 块，则将堆栈弹出到该级别，并将该块中的返回操作分配给 &lt;code&gt;PL_restartop&lt;/code&gt; ；然后执行 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。通常，这会将控制权交还给警卫队。对于 &lt;code&gt;perl_run&lt;/code&gt; 和 &lt;code&gt;call_sv&lt;/code&gt; ，非null的 &lt;code&gt;PL_restartop&lt;/code&gt; 触发重新进入runops循环。这是在 &lt;code&gt;eval&lt;/code&gt; 处理 &lt;code&gt;die&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 的正常方式。</target>
        </trans-unit>
        <trans-unit id="bb19ff7cc72a6855d9adc1ecae2faf667648c06d" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;glob&lt;/code&gt; expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a &lt;code&gt;glob&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;glob&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">如果将 &lt;code&gt;glob&lt;/code&gt; 表达式用作 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环的条件，则它将被隐式分配给 &lt;code&gt;$_&lt;/code&gt; 。如果无论是 &lt;code&gt;glob&lt;/code&gt; 表达式或一个明确的分配 &lt;code&gt;glob&lt;/code&gt; 表达一个标作为 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 条件，则条件实际测试的表达式的值的definedness，不为其经常真值。</target>
        </trans-unit>
        <trans-unit id="c439913b54ad4e9472f5fab7228ffbede4917134" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout&lt;/code&gt; in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">如果 &lt;code&gt;timeout&lt;/code&gt; 被设置以秒，当超时没有给出对ping（）方法（下文）就使用它。超时时间必须大于0，如果未指定，则默认值为5秒。</target>
        </trans-unit>
        <trans-unit id="05512b28e37ad32af54fde978f1e0fe4ada4db04" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is taken from the current locale. If Unicode (for example, &lt;code&gt;\N{}&lt;/code&gt; or code points of 0x100 or beyond) is being used, the case map used by &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, and &lt;code&gt;\U&lt;/code&gt; is as defined by Unicode. That means that case-mapping a single character can sometimes produce a sequence of several characters. Under &lt;code&gt;use locale&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt; produces the same results as &lt;code&gt;\L&lt;/code&gt; for all locales but a UTF-8 one, where it instead uses the Unicode definition.</source>
          <target state="translated">如果包含 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 &lt;code&gt;use locale&lt;/code&gt; 形式有效（请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 使用的大小写映射是从当前语言环境中获取的。如果使用Unicode（例如 &lt;code&gt;\N{}&lt;/code&gt; 或0x100或更高的代码点），则 &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 使用的大小写映射由Unicode定义。这意味着对单个字符进行大小写映射有时会产生多个字符的序列。在 &lt;code&gt;use locale&lt;/code&gt; ， &lt;code&gt;\F&lt;/code&gt; 产生与 &lt;code&gt;\L&lt;/code&gt; 相同的结果 对于除UTF-8之外的所有语言环境，它使用Unicode定义。</target>
        </trans-unit>
        <trans-unit id="043d74f31a25532198b1527d3ae5c4b1da9715ef" translate="yes" xml:space="preserve">
          <source>If a CODE reference is not used, a</source>
          <target state="translated">如果没有使用CODE参考,则会出现</target>
        </trans-unit>
        <trans-unit id="e12066458359083bdcf249636aa07df8a14816c7" translate="yes" xml:space="preserve">
          <source>If a CODE reference is used then a</source>
          <target state="translated">如果使用CODE参考,那么</target>
        </trans-unit>
        <trans-unit id="f9ad0abaf0eff45a492a44f419b412cf87f4dd03" translate="yes" xml:space="preserve">
          <source>If a FILEHANDLE is supplied, it must be writable and opened in append mode (i.e., use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt;. If a filename is supplied, it should not be held open elsewhere. (Win32)</source>
          <target state="translated">如果提供了FILEHANDLE，则它必须是可写的，并且必须以附加模式 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FH, '&amp;gt;&amp;gt;filename')&lt;/code&gt; （即，使用open（FH，'&amp;gt;&amp;gt; filename'）或 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen(FH,...,O_APPEND|O_RDWR)&lt;/a&gt;&lt;/code&gt; 。不应在其他地方打开（Win​​32）</target>
        </trans-unit>
        <trans-unit id="4d47de1f691dd0b1134ca70f07b0ea6e9d81891d" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt;-marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding.</source>
          <target state="translated">如果Perl脚本以Unicode &lt;code&gt;BOM&lt;/code&gt; （UTF-16LE，UTF16-BE）开头，或者该脚本看起来像是非 &lt;code&gt;BOM&lt;/code&gt; 表标记的任意字节序的UTF-16，则Perl将以适当的Unicode编码正确读取脚本。</target>
        </trans-unit>
        <trans-unit id="24e2f604f1de94503f88fcf2788fa5b11ed58ca8" translate="yes" xml:space="preserve">
          <source>If a Perl script begins with the bytes that form the UTF-8 encoding of the Unicode BYTE ORDER MARK (&lt;code&gt;BOM&lt;/code&gt;, see &lt;a href=&quot;#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot;&lt;/a&gt;), those bytes are completely ignored.</source>
          <target state="translated">如果Perl脚本以构成Unicode BYTE ORDER MARK（ &lt;code&gt;BOM&lt;/code&gt; ，请参阅&lt;a href=&quot;#Unicode-Encodings&quot;&gt;&amp;ldquo; Unicode编码&amp;rdquo;&lt;/a&gt;）的UTF-8编码的字节开头，则这些字节将被完全忽略。</target>
        </trans-unit>
        <trans-unit id="3af3f41934dd0fe8f979cc12d4f4c701b5fb0dcf" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any command other than the ones listed above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by default treat this as an error. It must not process the paragraph beginning with that command, must by default warn of this as an error, and may abort the parse. A Pod parser may allow a way for particular applications to add to the above list of known commands, and to stipulate, for each additional command, whether formatting codes should be processed.</source>
          <target state="translated">如果一个花苞处理器看到上面列出的命令以外的任何命令(如&quot;=head&quot;,或&quot;=haed1&quot;,或&quot;=stuff&quot;,或&quot;=cuttlefish&quot;,或&quot;=w123&quot;),该处理器必须默认将其视为一个错误。它必须不处理以该命令开始的段落,默认情况下必须警告这是一个错误,并可能中止解析。Pod解析器可以允许特定的应用程序添加到上述已知命令列表中,并为每个附加命令规定是否应该处理格式代码。</target>
        </trans-unit>
        <trans-unit id="84d7b60c1fec814496b3c4bc1816a8d5d03c5699" translate="yes" xml:space="preserve">
          <source>If a Pod processor sees any formatting code other than the ones listed above (as in &quot;N&amp;lt;...&amp;gt;&quot;, or &quot;Q&amp;lt;...&amp;gt;&quot;, etc.), that processor must by default treat this as an error. A Pod parser may allow a way for particular applications to add to the above list of known formatting codes; a Pod parser might even allow a way to stipulate, for each additional command, whether it requires some form of special processing, as L&amp;lt;...&amp;gt; does.</source>
          <target state="translated">如果Pod处理器看到除上面列出的格式代码之外的任何其他格式代码（如&amp;ldquo; N &amp;lt;...&amp;gt;&amp;rdquo;或&amp;ldquo; Q &amp;lt;...&amp;gt;&amp;rdquo;等），则该处理器必须默认将其视为错误。 。Pod解析器可能允许特定应用程序添加到上面的已知格式代码列表中；Pod解析器甚至可以允许为每个附加命令规定是否需要某种形式的特殊处理，如L &amp;lt;...&amp;gt;那样。</target>
        </trans-unit>
        <trans-unit id="a69d2c6e5370a359253a714b367c144cea0b32a3" translate="yes" xml:space="preserve">
          <source>If a SKIP directive is included with the plan, this method will return it.</source>
          <target state="translated">如果计划中包含SKIP指令,本方法将返回该指令。</target>
        </trans-unit>
        <trans-unit id="fc36fbb42452cd08e5fbc977b40571fcb5ba6163" translate="yes" xml:space="preserve">
          <source>If a SKIP directive was included with the plan, this method will return the explanation, if any.</source>
          <target state="translated">如果计划中包含SKIP指令,本方法将返回解释(如果有)。</target>
        </trans-unit>
        <trans-unit id="21c8d4e7e9fdf0b61712f2ee7b9d5069189ec21c" translate="yes" xml:space="preserve">
          <source>If a TODO test does succeed, then the feature in question shouldn't be on the TODO list, now should it?</source>
          <target state="translated">如果TODO测试确实成功了,那么相关功能就不应该出现在TODO列表中了,现在应该是这样吧?</target>
        </trans-unit>
        <trans-unit id="2e556764eb70dadb149264cc71dd4704e1aa8ecf" translate="yes" xml:space="preserve">
          <source>If a TODO test passes, &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will report it &quot;UNEXPECTEDLY SUCCEEDED&quot;. When that happens, remove the TODO block with &lt;code&gt;local $TODO&lt;/code&gt; and turn it into a real test.</source>
          <target state="translated">如果TODO测试通过，则&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;将报告&amp;ldquo;异常成功&amp;rdquo;。发生这种情况时，请使用 &lt;code&gt;local $TODO&lt;/code&gt; 删除TODO块，然后将其转换为真实测试。</target>
        </trans-unit>
        <trans-unit id="5bc13fa8b4104f174148a214dadae282567de13a" translate="yes" xml:space="preserve">
          <source>If a character that isn't an octal digit is encountered, a warning is raised, and the value is based on the octal digits before it, discarding it and all following characters up to the closing brace. It is a fatal error if there are no octal digits at all.</source>
          <target state="translated">如果遇到一个不是八位数的字符,就会发出警告,并根据它前面的八位数来计算值,丢弃它和后面的所有字符,直到最后的括号。如果根本没有八位数,则是一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="b895fdf53ccf75b6f1d6a0f2ed9f43fb2b3e2bde" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;&quot;Scalar values&quot; in perldata&lt;/a&gt;):</source>
          <target state="translated">如果要检查非空值，则将其放在布尔上下文中（请参阅&lt;a href=&quot;perldata#Scalar-values&quot;&gt;perldata中的&amp;ldquo;标量值&amp;rdquo;&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="22ce7778730981e7a416c117aaec163fa0497dba" translate="yes" xml:space="preserve">
          <source>If a check for non-empty is what you wanted then just put it in boolean context (see &lt;a href=&quot;perldata#Scalar-values&quot;&gt;Scalar values in perldata&lt;/a&gt;):</source>
          <target state="translated">如果要检查非空&lt;a href=&quot;perldata#Scalar-values&quot;&gt;值，则将&lt;/a&gt;其放在布尔上下文中（请参阅perldata中的标量值）：</target>
        </trans-unit>
        <trans-unit id="7bbe66a04a030c6e054fb0dfd4a30c2a7ed6df30" translate="yes" xml:space="preserve">
          <source>If a child calls &quot;skip_all&quot; in the plan, a &lt;code&gt;Test::Builder::Exception&lt;/code&gt; is thrown. Trap this error, call &lt;code&gt;finalize()&lt;/code&gt; and don't run any more tests on the child.</source>
          <target state="translated">如果孩子在计划中调用&amp;ldquo; skip_all&amp;rdquo;，则会抛出 &lt;code&gt;Test::Builder::Exception&lt;/code&gt; 。捕获此错误，调用 &lt;code&gt;finalize()&lt;/code&gt; ,并且不再对子级运行任何测试。</target>
        </trans-unit>
        <trans-unit id="d87e3904bd84922ce3c7497d798c1def1d62966e" translate="yes" xml:space="preserve">
          <source>If a collation sequence is not given, a default collation sequence is used. If the base is less than or equal to 36, the collation sequence is the string consisting of the 36 characters &quot;0&quot; to &quot;9&quot; and &quot;A&quot; to &quot;Z&quot;. In this case, the letter case in the input is ignored. If the base is greater than 36, and smaller than or equal to 62, the collation sequence is the string consisting of the 62 characters &quot;0&quot; to &quot;9&quot;, &quot;A&quot; to &quot;Z&quot;, and &quot;a&quot; to &quot;z&quot;. A base larger than 62 requires the collation sequence to be specified explicitly.</source>
          <target state="translated">如果没有给出整理序列,则使用默认的整理序列。如果基数小于或等于36,整理序列是由36个字符 &quot;0 &quot;到 &quot;9 &quot;和 &quot;A &quot;到 &quot;Z &quot;组成的字符串。在这种情况下,输入中的字母大小写会被忽略。如果基数大于36,小于或等于62,则整理序列是由62个字符 &quot;0 &quot;到 &quot;9&quot;,&quot;A &quot;到 &quot;Z&quot;,以及 &quot;a &quot;到 &quot;z &quot;组成的字符串。大于62的基数需要明确指定整理序列。</target>
        </trans-unit>
        <trans-unit id="9e2b6a0e0e45f39177eb31d01e15e452bd57cce8" translate="yes" xml:space="preserve">
          <source>If a comparison subroutine (comp) is defined, it must return less than zero, zero, or greater than zero, if the first comparand is less than, equal, or greater than the second comparand.</source>
          <target state="translated">如果定义了一个比较子程序(comp),如果第一个比较数小于、等于或大于第二个比较数,它必须返回小于零、零或大于零。</target>
        </trans-unit>
        <trans-unit id="6bcefbb01c642f7f0fc9b06ad8c1d9b86690b30e" translate="yes" xml:space="preserve">
          <source>If a config variable name ends with &lt;code&gt;list&lt;/code&gt; , it is a list. &lt;code&gt;o conf
KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; removes the first element of the list, &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; removes the last element of the list. &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; prepends a list of values to the list, &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; appends a list of valued to the list.</source>
          <target state="translated">如果配置变量名称以 &lt;code&gt;list&lt;/code&gt; 结尾，则它是一个列表。 &lt;code&gt;o conf KEY &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 删除列表的第一个元素， &lt;code&gt;o conf KEY &lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 删除列表的最后一个元素。 &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt; LIST&lt;/code&gt; 将值 &lt;code&gt;o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST&lt;/code&gt; 添加到列表中，o conf KEYS &lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt; LIST将值列表添加到列表中。</target>
        </trans-unit>
        <trans-unit id="5109117db036bd8645f50a5e04d368af63084ec5" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; , any other thread doing a &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; won't block.</source>
          <target state="translated">如果容器对象（例如哈希或数组）被锁定，则该容器的所有元素都不会被锁定。例如，如果一个线程执行了 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt; @a&lt;/code&gt; &lt;a href=&quot;functions/lock&quot;&gt;锁定&lt;/a&gt;，则其他执行 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock($a[12])&lt;/a&gt;&lt;/code&gt; 其他线程都不会阻塞。</target>
        </trans-unit>
        <trans-unit id="0b9475795c5acef3f94e436ae886fcd1f2079b25" translate="yes" xml:space="preserve">
          <source>If a container object, such as a hash or array, is locked, all the elements of that container are not locked. For example, if a thread does a &lt;code&gt;lock @a&lt;/code&gt;, any other thread doing a &lt;code&gt;lock($a[12])&lt;/code&gt; won't block.</source>
          <target state="translated">如果容器对象（例如哈希或数组）被锁定，则该容器的所有元素都不会被锁定。例如，如果一个线程执行了 &lt;code&gt;lock @a&lt;/code&gt; ，则其他执行 &lt;code&gt;lock($a[12])&lt;/code&gt; 其他线程都不会阻塞。</target>
        </trans-unit>
        <trans-unit id="86e40904bfdd4ce1f2ea77e8cac744710e6b6d3c" translate="yes" xml:space="preserve">
          <source>If a custom key refers to a data structure, a deep clone is returned.</source>
          <target state="translated">如果自定义键指向一个数据结构,则返回一个深度克隆。</target>
        </trans-unit>
        <trans-unit id="35f34b9c616480c978cfd69625d6aeaae5e87694" translate="yes" xml:space="preserve">
          <source>If a data type is a Map or Map subtype, valid subkeys will be described as well.</source>
          <target state="translated">如果一个数据类型是Map或Map子类型,有效的子键也会被描述。</target>
        </trans-unit>
        <trans-unit id="dca4e72f15d2d8185a5bffef1f8b63be490eec41" translate="yes" xml:space="preserve">
          <source>If a default timeout ($def_timeout) in seconds is provided, it is used when a timeout is not given to the ping() method (below). The timeout must be greater than 0 and the default, if not specified, is 5 seconds.</source>
          <target state="translated">如果提供了以秒为单位的默认超时时间 ($def_timeout),那么当 ping()方法没有超时时,就会使用这个超时时间 (如下)。超时时间必须大于0,如果没有指定,默认为5秒。</target>
        </trans-unit>
        <trans-unit id="9cb3d5a547282377cc66b4c5457632db46bb8ed9" translate="yes" xml:space="preserve">
          <source>If a dereference operator is overloaded then it must return a</source>
          <target state="translated">如果一个dereference操作符是重载的,那么它必须返回一个</target>
        </trans-unit>
        <trans-unit id="fe98464b03f834d1a964476866ec0454738cfc5e" translate="yes" xml:space="preserve">
          <source>If a directory name is specified, Perl will switch to that directory before running the program. The &lt;b&gt;-x&lt;/b&gt; switch controls only the disposal of leading garbage. The program must be terminated with &lt;code&gt;__END__&lt;/code&gt; if there is trailing garbage to be ignored; the program can process any or all of the trailing garbage via the &lt;code&gt;DATA&lt;/code&gt; filehandle if desired.</source>
          <target state="translated">如果指定了目录名称，则Perl将在运行程序之前切换到该目录。该&lt;b&gt;-x&lt;/b&gt;开关只控制处置领导垃圾。如果要忽略尾随垃圾，则该程序必须以 &lt;code&gt;__END__&lt;/code&gt; 终止；如果需要，程序可以通过 &lt;code&gt;DATA&lt;/code&gt; 文件句柄处理任何或所有尾随垃圾。</target>
        </trans-unit>
        <trans-unit id="5aaf565f5088172c3b4f50e88e5260fa4d43f871" translate="yes" xml:space="preserve">
          <source>If a distribution defines a minimal required perl version, this is added to the output as an additional line of the form:</source>
          <target state="translated">如果一个发行版定义了一个最小的所需的perl版本,那么这个版本就会被添加到输出中,作为额外的一行形式。</target>
        </trans-unit>
        <trans-unit id="42b6266ffbedee9d19b5a6a2dc00e2ab21c075e3" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（但不是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideHangul&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="d7bef52fc8efdf02d89c731e11f307c96984c0d4" translate="yes" xml:space="preserve">
          <source>If a false value (but not &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideHangul&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（但不是 &lt;code&gt;undef&lt;/code&gt; ），则 &lt;code&gt;overrideHangul&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideHangul =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="41f3060c136c5cb39245327e845028b89a018338" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideCJK&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="4ce3e5ab6913747cb34ccc5fe411d22f75b39a20" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则 &lt;code&gt;overrideOut&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="2efe2419737305523ab6685944b8e5967c625c40" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideCJK&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;undef&lt;/code&gt; ），则 &lt;code&gt;overrideCJK&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideCJK =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="b769b78df558ed0ae95630bec3fdf7981f2aba03" translate="yes" xml:space="preserve">
          <source>If a false value (including &lt;code&gt;undef&lt;/code&gt;) is passed, &lt;code&gt;overrideOut&lt;/code&gt; has no effect. &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; resets the old one.</source>
          <target state="translated">如果传递了错误的值（包括 &lt;code&gt;undef&lt;/code&gt; ），则 &lt;code&gt;overrideOut&lt;/code&gt; 无效。 &lt;code&gt;$Collator-&amp;gt;change(overrideOut =&amp;gt; 0)&lt;/code&gt; 重置旧的。</target>
        </trans-unit>
        <trans-unit id="14cf492ed81687842dddeeef058d5e33b14e6b8c" translate="yes" xml:space="preserve">
          <source>If a field width obtained through &lt;code&gt;*&lt;/code&gt; is negative, it has the same effect as the &lt;code&gt;-&lt;/code&gt; flag: left-justification.</source>
          <target state="translated">如果通过 &lt;code&gt;*&lt;/code&gt; 获得的字段宽度为负，则其与 &lt;code&gt;-&lt;/code&gt; 标志相同：左对齐。</target>
        </trans-unit>
        <trans-unit id="b67747c87623a5829c474216ed820d9c376a76fd" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;a href=&quot;#-n&quot;&gt;&quot;-n&quot;&lt;/a&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">如果由于某种原因而无法打开由参数命名的文件，则Perl会警告您，然后移至下一个文件。请注意，这些行是自动打印的。在打印过程中发生的错误被视为致命错误。要禁止打印，请使用&lt;a href=&quot;#-n&quot;&gt;&amp;ldquo; -n&amp;rdquo;&lt;/a&gt;开关。甲&lt;b&gt;-p&lt;/b&gt;覆盖一个&lt;b&gt;-n&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="9605e9893d52ad305cb79e90d906d025024d5412" translate="yes" xml:space="preserve">
          <source>If a file named by an argument cannot be opened for some reason, Perl warns you about it, and moves on to the next file. Note that the lines are printed automatically. An error occurring during printing is treated as fatal. To suppress printing use the &lt;b&gt;-n&lt;/b&gt; switch. A &lt;b&gt;-p&lt;/b&gt; overrides a &lt;b&gt;-n&lt;/b&gt; switch.</source>
          <target state="translated">如果由于某种原因而无法打开由参数命名的文件，则Perl会警告您，然后移至下一个文件。请注意，这些行是自动打印的。打印期间发生的错误被视为致命错误。要禁止打印，请使用&lt;b&gt;-n&lt;/b&gt;开关。甲&lt;b&gt;-p&lt;/b&gt;覆盖一个&lt;b&gt;-n&lt;/b&gt;开关。</target>
        </trans-unit>
        <trans-unit id="7607c4673d0f39465175ed86077289b9bf56cef9" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a key from a DBM database.</source>
          <target state="translated">如果用这个方法安装了过滤器,那么每次从DBM数据库中读取密钥时都会被调用。</target>
        </trans-unit>
        <trans-unit id="ffcdc45cfdda9fabc4fc72ffad32b6bd83924c58" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you read a value from a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次从DBM数据库中读取一个值时都会被调用。</target>
        </trans-unit>
        <trans-unit id="cd250eca2a3b32b9a72984e5551322c2a78954ba" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a key to a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次向DBM数据库写入一个密钥时都会被调用。</target>
        </trans-unit>
        <trans-unit id="6d4a7b6c0f00f48df8682a8b26e45e64646603ea" translate="yes" xml:space="preserve">
          <source>If a filter has been installed with this method, it will be invoked every time you write a value to a DBM database.</source>
          <target state="translated">如果用这个方法安装了一个过滤器,那么每次向DBM数据库写入一个值时,它都会被调用。</target>
        </trans-unit>
        <trans-unit id="07c279eee0e239fdbb7a9180f0e7ca0c343b1372" translate="yes" xml:space="preserve">
          <source>If a finalized set of requirements is cloned, the cloned requirements are not also finalized.</source>
          <target state="translated">如果克隆了一套最终确定的需求,则克隆的需求不也是最终确定的。</target>
        </trans-unit>
        <trans-unit id="e3c644e7c4d09f78ea460ddc805cbed0f24eef71" translate="yes" xml:space="preserve">
          <source>If a fully qualified $class is given, its abbreviated version is checked first.</source>
          <target state="translated">如果给出了一个完全限定的$class,则首先检查它的缩写版本。</target>
        </trans-unit>
        <trans-unit id="61efacc190b96b684717f3100b2802427ca3f5f2" translate="yes" xml:space="preserve">
          <source>If a hyphen in a character class cannot syntactically be part of a range, for instance because it is the first or the last character of the character class, or if it immediately follows a range, the hyphen isn't special, and so is considered a character to be matched literally. If you want a hyphen in your set of characters to be matched and its position in the class is such that it could be considered part of a range, you must escape that hyphen with a backslash.</source>
          <target state="translated">如果一个字符类中的连字符在语法上不能成为一个范围的一部分,例如因为它是该字符类的第一个或最后一个字符,或者如果它紧跟在一个范围之后,那么这个连字符并不特殊,因此被认为是一个要按字面意思匹配的字符。如果您希望在您的字符集中的连字符被匹配,并且它在字符类中的位置可以被认为是范围的一部分,您必须用反斜线转义该连字符。</target>
        </trans-unit>
        <trans-unit id="8e9b736d2bd9dc9660e81744f77377a13eb0a302" translate="yes" xml:space="preserve">
          <source>If a key appears more than once in the initializer list of a hash, the last occurrence wins:</source>
          <target state="translated">如果一个键在哈希的初始化列表中出现超过一次,最后出现的键获胜。</target>
        </trans-unit>
        <trans-unit id="e38101b895429346e058b0e8e435924731bb16b2" translate="yes" xml:space="preserve">
          <source>If a layer provides &lt;code&gt;Open()&lt;/code&gt; it should normally call the &lt;code&gt;Open()&lt;/code&gt; method of next layer down (if any) and then push itself on top if that succeeds. &lt;code&gt;PerlIOBase_open&lt;/code&gt; is provided to do exactly that, so in most cases you don't have to write your own &lt;code&gt;Open()&lt;/code&gt; method. If this method is not defined, other layers may have difficulty pushing themselves on top of it during open.</source>
          <target state="translated">如果某个层提供 &lt;code&gt;Open()&lt;/code&gt; ，则通常应向下调用下一层的 &lt;code&gt;Open()&lt;/code&gt; 方法（如果有），如果成功，则将其自身推到顶部。提供 &lt;code&gt;PerlIOBase_open&lt;/code&gt; 可以完全做到这一点，因此在大多数情况下，您不必编写自己的 &lt;code&gt;Open()&lt;/code&gt; 方法。如果未定义此方法，则其他层在打开过程中可能难以将自身推到其顶部。</target>
        </trans-unit>
        <trans-unit id="73dbe9c1af884c682c784ff2164f939b559495d3" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt; ) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt; .</source>
          <target state="translated">如果为词法变量赋予属性，则该词法变量所属的符号表不存在，因此在这种情况下，符号表参数（ &lt;code&gt;$_[1]&lt;/code&gt; ）设置为字符串 &lt;code&gt;'LEXICAL'&lt;/code&gt; 。同样，将属性归于匿名子例程会导致符号表自变量 &lt;code&gt;'ANON'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e69004ab41c9f2ba069a062aa5bbadc27b894ffc" translate="yes" xml:space="preserve">
          <source>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (&lt;code&gt;$_[1]&lt;/code&gt;) is set to the string &lt;code&gt;'LEXICAL'&lt;/code&gt; in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of &lt;code&gt;'ANON'&lt;/code&gt;.</source>
          <target state="translated">如果为词法变量赋予了属性，则该词法变量所属的符号表将不存在，因此在这种情况下，符号表参数（ &lt;code&gt;$_[1]&lt;/code&gt; ）设置为字符串 &lt;code&gt;'LEXICAL'&lt;/code&gt; 。同样，将属性归于匿名子例程会导致符号表自变量 &lt;code&gt;'ANON'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="373e9d26b4e220dbf14e875851af78e4ef70cdec" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt; . A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt; . The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">如果源流中有一行，则 &lt;code&gt;filter_read()&lt;/code&gt; 返回大于零的状态值，并将该行追加到 &lt;code&gt;$_&lt;/code&gt; 。状态值为零表示文件结束，小于零表示错误。期望filter函数本身以相同的方式返回其状态，并将要写入的过滤后的行放入 &lt;code&gt;$_&lt;/code&gt; 。使用 &lt;code&gt;$_&lt;/code&gt; 可以简化大多数Perl源过滤器。</target>
        </trans-unit>
        <trans-unit id="b437e27438def56dcad1625b5eefb30ef0e6432f" translate="yes" xml:space="preserve">
          <source>If a line was available from the source stream, &lt;code&gt;filter_read()&lt;/code&gt; returns a status value greater than zero and appends the line to &lt;code&gt;$_&lt;/code&gt;. A status value of zero indicates end-of-file, less than zero means an error. The filter function itself is expected to return its status in the same way, and put the filtered line it wants written to the source stream in &lt;code&gt;$_&lt;/code&gt;. The use of &lt;code&gt;$_&lt;/code&gt; accounts for the brevity of most Perl source filters.</source>
          <target state="translated">如果源流中有一行，则 &lt;code&gt;filter_read()&lt;/code&gt; 返回大于零的状态值，并将该行追加到 &lt;code&gt;$_&lt;/code&gt; 。状态值为零表示文件结束，小于零表示错误。期望filter函数本身以相同的方式返回其状态，并将想要写入的已过滤行放入 &lt;code&gt;$_&lt;/code&gt; 。使用 &lt;code&gt;$_&lt;/code&gt; 可以简化大多数Perl源过滤器。</target>
        </trans-unit>
        <trans-unit id="9579e356ad7f9bb206c2b31ab9df7d7dd13fd989" translate="yes" xml:space="preserve">
          <source>If a list is given then it is evaluated from left to right so that any specifications in the list that conflict with a previous specification are overridden by the later.</source>
          <target state="translated">如果给定了一个列表,那么它将从左到右进行评估,这样列表中任何与前一个规格冲突的规格都会被后一个规格所覆盖。</target>
        </trans-unit>
        <trans-unit id="eb73e02f11dc05b75008088bd5b205cf808a5add" translate="yes" xml:space="preserve">
          <source>If a matching entry cannot be found, and a default entry exists, then a reference to the default entry is returned.</source>
          <target state="translated">如果找不到匹配的条目,并且存在默认条目,则返回对默认条目的引用。</target>
        </trans-unit>
        <trans-unit id="c613dbc045a6d1ccd39d5e4d8985654cb6efdedb" translate="yes" xml:space="preserve">
          <source>If a message can be controlled by the &lt;code&gt;warnings&lt;/code&gt; pragma, its warning category is included with the classification letter in the description below. E.g. &lt;code&gt;(W closed)&lt;/code&gt; means a warning in the &lt;code&gt;closed&lt;/code&gt; category.</source>
          <target state="translated">如果消息可以由 &lt;code&gt;warnings&lt;/code&gt; 实用程序控制，则其警告类别包括在以下描述中的分类字母中。例如 &lt;code&gt;(W closed)&lt;/code&gt; 表示已 &lt;code&gt;closed&lt;/code&gt; 类别中的警告。</target>
        </trans-unit>
        <trans-unit id="f00576e48e7083129f4536c4d9542b2af3efddb9" translate="yes" xml:space="preserve">
          <source>If a method for an operation is not found then Perl tries to autogenerate a substitute implementation from the operations that have been defined.</source>
          <target state="translated">如果没有找到一个操作的方法,那么Perl会尝试从已经定义的操作中自动生成一个替代实现。</target>
        </trans-unit>
        <trans-unit id="0bdd74a3b17bde34780674e393224f07968f9f1d" translate="yes" xml:space="preserve">
          <source>If a module attempts to import any of these symbols the Exporter will give the module an opportunity to handle the situation before generating an error. The Exporter will call an export_fail method with a list of the failed symbols:</source>
          <target state="translated">如果一个模块试图导入这些符号中的任何一个,Exporter将在产生错误之前给模块一个机会来处理这种情况。Exporter将调用export_fail方法,并提供一个失败的符号列表。</target>
        </trans-unit>
        <trans-unit id="a6c5a19663c54ceb738fad6d48fbb290bbe10648" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">如果某个模块由于某种原因无法构建，请仔细查看其失败原因，并向模块作者报告问题。如果扩展构建支持似乎有问题，&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;请&lt;/a&gt;使用GitHub问题跟踪器在https://github.com/Perl/perl5/issues上报告构建失败的完整详细信息。</target>
        </trans-unit>
        <trans-unit id="46e9244ade28e8f11cc0bc5968d58da31945ce21" translate="yes" xml:space="preserve">
          <source>If a module does not build for some reason, look carefully for why it failed, and report problems to the module author. If it looks like the extension building support is at fault, report that with full details of how the build failed using the perlbug utility.</source>
          <target state="translated">如果一个模块由于某种原因没有构建,请仔细查找它失败的原因,并向模块作者报告问题。如果看起来是扩展构建支持出了问题,请使用 perlbug 工具报告构建失败的全部细节。</target>
        </trans-unit>
        <trans-unit id="094a8b4d892c0d307d87dac5429320ae267e0ba1" translate="yes" xml:space="preserve">
          <source>If a module implements XSUBs, you will need one of the supported C compilers. You must make sure you have set up the environment for the compiler for command-line compilation before running &lt;code&gt;perl Makefile.PL&lt;/code&gt; or any invocation of make.</source>
          <target state="translated">如果模块实现XSUB，则将需要受支持的C编译器之一。在运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或make的任何调用之前，必须确保已为编译器设置了用于命令行编译的环境。</target>
        </trans-unit>
        <trans-unit id="9711733a9e84337767e9b5acb7ff59757c774ea1" translate="yes" xml:space="preserve">
          <source>If a name does not already have a suitable prefix and/or suffix then the corresponding file will be searched for by trying combinations of prefix and suffix appropriate to the platform: &quot;$name.o&quot;, &quot;lib$name.*&quot; and &quot;$name&quot;.</source>
          <target state="translated">如果一个名字没有合适的前缀和/或后缀,那么将通过尝试适合平台的前缀和后缀组合来搜索相应的文件。&quot;$name.o&quot;、&quot;lib$name.*&quot;和&quot;$name&quot;。</target>
        </trans-unit>
        <trans-unit id="71674c3e4540508bc53564e31d00df9a0af1f1d2" translate="yes" xml:space="preserve">
          <source>If a name resolve operation fails to provide a name, then this flag will cause getnameinfo() to indicate an error, rather than returning the numeric representation as a human-readable string.</source>
          <target state="translated">如果名称解析操作未能提供名称,那么这个标志将导致getnameinfo()指示一个错误,而不是以人类可读的字符串形式返回数字表示。</target>
        </trans-unit>
        <trans-unit id="31b368c0d757e116a5dfb072a97b4193c426b9b0" translate="yes" xml:space="preserve">
          <source>If a negative array index is used to read from an array, the index will be translated to a positive one internally by calling FETCHSIZE before being passed to FETCH. You may disable this feature by assigning a true value to the variable &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; in the tied array class.</source>
          <target state="translated">如果使用负数组索引从数组中读取数据，则在传递给FETCH之前，可以通过调用FETCHSIZE在内部将索引转换为正索引。您可以通过为绑定数组类中的变量 &lt;code&gt;$NEGATIVE_INDICES&lt;/code&gt; 分配一个真值来禁用此功能。</target>
        </trans-unit>
        <trans-unit id="77fd7f19527eab5261c210a54c173bb0abc87920" translate="yes" xml:space="preserve">
          <source>If a package uses overload, it carries a special flag. This flag is also set when new functions are defined or @ISA is modified. There will be a slight speed penalty on the very first operation thereafter that supports overloading, while the overload tables are updated. If there is no overloading present, the flag is turned off. Thus the only speed penalty thereafter is the checking of this flag.</source>
          <target state="translated">如果一个包使用了重载,它就会携带一个特殊的标志。当定义新函数或修改@ISA时,这个标志也会被设置。在此后的第一个支持重载的操作中会有轻微的速度惩罚,同时重载表也会被更新。如果没有重载存在,则关闭该标志。因此,此后唯一的速度惩罚就是检查这个标志。</target>
        </trans-unit>
        <trans-unit id="eef6b1875e2dcae080c75ee35ffb78afc980a5f8" translate="yes" xml:space="preserve">
          <source>If a pattern does not contain a special backtracking verb that allows an argument, then &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; are not touched at all.</source>
          <target state="translated">如果模式不包含允许参数的特殊回溯动词，则 &lt;code&gt;$REGMARK&lt;/code&gt; 不会触及 &lt;code&gt;$REGERROR&lt;/code&gt; 和$ REGMARK。</target>
        </trans-unit>
        <trans-unit id="9f0b6253b5fcfd411b56a12da1005e8889d7cecd" translate="yes" xml:space="preserve">
          <source>If a piece of code is under the control of the &lt;code&gt;warnings&lt;/code&gt; pragma, both the &lt;code&gt;$^W&lt;/code&gt; variable and the &lt;b&gt;-w&lt;/b&gt; flag will be ignored for the scope of the lexical warning.</source>
          <target state="translated">如果一段代码在 &lt;code&gt;warnings&lt;/code&gt; 编译指示的控制下，则对于词法警告的范围， &lt;code&gt;$^W&lt;/code&gt; 变量和&lt;b&gt;-w&lt;/b&gt;标志都将被忽略。</target>
        </trans-unit>
        <trans-unit id="dc66a04b7fd6c8f1331b2adb91a4455713a61616" translate="yes" xml:space="preserve">
          <source>If a plan has not yet been output, it will do so.</source>
          <target state="translated">如果一个计划还没有输出,它就会输出。</target>
        </trans-unit>
        <trans-unit id="f9d2f49ea2b290886ecf360d9425d5113040021a" translate="yes" xml:space="preserve">
          <source>If a precision obtained through &lt;code&gt;*&lt;/code&gt; is negative, it counts as having no precision at all.</source>
          <target state="translated">如果通过 &lt;code&gt;*&lt;/code&gt; 获得的精度为负，则认为完全没有精度。</target>
        </trans-unit>
        <trans-unit id="2493d17a98c3b1f685aa6fcd91f6a228a3382409" translate="yes" xml:space="preserve">
          <source>If a precompiled pattern is embedded in a larger pattern then the effect of &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; will be propagated appropriately. The effect that the &lt;code&gt;/o&lt;/code&gt; modifier has is not propagated, being restricted to those patterns explicitly using it.</source>
          <target state="translated">如果将预编译的模式嵌入较大的模式，则 &lt;code&gt;&quot;msixpluadn&quot;&lt;/code&gt; 的效果将适当传播。 &lt;code&gt;/o&lt;/code&gt; 修饰符所具有的效果不会传播，仅限于使用它的显式模式。</target>
        </trans-unit>
        <trans-unit id="cfe77c7e04c6532a52f2ea4bb204b4b081b46114" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">如果程序的环境指定了LC_NUMERIC语言环境，并且在声明格式时 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 生效，则该语言环境用于在格式化输出中指定小数点字符。调用write（）时，无法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 来控制格式化输出。有关语言环境处理的进一步讨论，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bedf07956f494f1e8bca1dc60af93c0e865cbc39" translate="yes" xml:space="preserve">
          <source>If a program's environment specifies an LC_NUMERIC locale and &lt;code&gt;use locale&lt;/code&gt; is in effect when the format is declared, the locale is used to specify the decimal point character in formatted output. Formatted output cannot be controlled by &lt;code&gt;use locale&lt;/code&gt; at the time when write() is called. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for further discussion of locale handling.</source>
          <target state="translated">如果程序的环境指定了LC_NUMERIC语言环境，并且在声明格式时 &lt;code&gt;use locale&lt;/code&gt; 生效，则该语言环境用于在格式化输出中指定小数点字符。调用write（）时，无法 &lt;code&gt;use locale&lt;/code&gt; 来控制格式化输出。有关语言环境处理的进一步讨论，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f41131148d4a0b9a531181bbeee21c21fa27808" translate="yes" xml:space="preserve">
          <source>If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">如果属性是过时的，等等，该条目将与在表中使用的相同的字符进行标记&lt;a href=&quot;#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;上面的部分&lt;/a&gt;，象&lt;b&gt;d&lt;/b&gt;或&lt;b&gt;小号&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dbdd7653484d14bb99878153118f9a9fc7a64201" translate="yes" xml:space="preserve">
          <source>If a queue is empty, &lt;code&gt;dequeue()&lt;/code&gt; blocks until another thread enqueues something. This makes queues ideal for event loops and other communications between threads.</source>
          <target state="translated">如果队列为空，则 &lt;code&gt;dequeue()&lt;/code&gt; 阻塞，直到另一个线程入队。这使队列非常适合事件循环和线程之间的其他通信。</target>
        </trans-unit>
        <trans-unit id="d8a808372475f8c939dd3899bae64db28b71a73e" translate="yes" xml:space="preserve">
          <source>If a reference happens to be a reference to an object, then there are probably methods to access the things referred to, and you should probably stick to those methods unless you're in the class package that defines the object's methods. In other words, be nice, and don't violate the object's encapsulation without a very good reason. Perl does not enforce encapsulation. We are not totalitarians here. We do expect some basic civility though.</source>
          <target state="translated">如果一个引用恰好是对一个对象的引用,那么可能有方法来访问被引用的东西,你可能应该坚持使用这些方法,除非你在定义对象方法的类封装中。换句话说,如果没有很好的理由,就不要违反对象的封装。Perl不强制封装。我们不是极权主义者。不过我们确实希望有一些基本的文明。</target>
        </trans-unit>
        <trans-unit id="c8efe9417a8ca522054e8e0f20aa5ebe3ad20734" translate="yes" xml:space="preserve">
          <source>If a regexp has a variable that interpolates a code expression, Perl treats the regexp as an error. If the code expression is precompiled into a variable, however, interpolating is ok. The question is, why is this an error?</source>
          <target state="translated">如果一个 regexp 中有一个插值代码表达式的变量,Perl 就会把这个 regexp 作为一个错误处理。然而,如果代码表达式被预先编译成一个变量,那么插值是可以的。问题是,为什么这是一个错误?</target>
        </trans-unit>
        <trans-unit id="d5bd95a2da72abd4235bfb3025f329041ecd2afc" translate="yes" xml:space="preserve">
          <source>If a regexp matches in more than one place in the string, Perl will always match at the earliest possible point in the string:</source>
          <target state="translated">如果一个regexp在字符串中的一个以上的位置匹配,Perl将总是在字符串中最早的位置进行匹配。</target>
        </trans-unit>
        <trans-unit id="eaf4b93182f52023e0f84b564980685b7296c6d9" translate="yes" xml:space="preserve">
          <source>If a regular bracketed character class contains a &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\P{}&lt;/code&gt; and is matched against a non-Unicode code point, a warning may be raised, as the result is not Unicode-defined. No such warning will come when using this extended form.</source>
          <target state="translated">如果常规方括号字符类包含 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\P{}&lt;/code&gt; 并与非Unicode代码点匹配，则可能会出现警告，因为结果未定义Unicode。使用此扩展格式时不会出现此类警告。</target>
        </trans-unit>
        <trans-unit id="f85e430ff8e0f946fbbcd7fbdf03ad676d0029b5" translate="yes" xml:space="preserve">
          <source>If a result does not have a callback defined for it, this callback will be invoked. Thus, if all of the previous result types are specified as callbacks, this callback will</source>
          <target state="translated">如果一个结果没有为它定义回调,这个回调将被调用。因此,如果前面所有的结果类型都被指定为回调,那么这个回调将是</target>
        </trans-unit>
        <trans-unit id="7c88e9a20d1a229d11dbc65d34fee24d0f8252b1" translate="yes" xml:space="preserve">
          <source>If a script does not contain such a cooky, then to avoid calling</source>
          <target state="translated">如果一个脚本不包含这样的cooky,那么为了避免调用</target>
        </trans-unit>
        <trans-unit id="7e6d780b3e70414e72c5be7308b60f82c00d250e" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt; . (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">如果给定第二个参数且该参数对应于有效的语言环境，则将类别的语言环境设置为该值，然后该函数返回当前的语言环境值。然后，您可以在另一个对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中使用它。 （在某些实现中，返回值有时可能与您作为第二个参数提供的值有所不同-将其视为您提供的值的别名。）</target>
        </trans-unit>
        <trans-unit id="3e39a56243de1505c2a60308e0e3b7ae64ceb413" translate="yes" xml:space="preserve">
          <source>If a second argument is given and it corresponds to a valid locale, the locale for the category is set to that value, and the function returns the now-current locale value. You can then use this in yet another call to &lt;code&gt;setlocale()&lt;/code&gt;. (In some implementations, the return value may sometimes differ from the value you gave as the second argument--think of it as an alias for the value you gave.)</source>
          <target state="translated">如果给定第二个参数且该参数对应于有效的语言环境，则将类别的语言环境设置为该值，然后该函数返回当前的语言环境值。然后，您可以在另一个对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中使用它。（在某些实现中，返回值有时可能与您作为第二个参数提供的值有所不同-将其视为您提供的值的别名。）</target>
        </trans-unit>
        <trans-unit id="91a945f54fa17399a38d6421bac299acb5873c21" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should be the name of the desired output file. If the special output filename &quot;-&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; is given then the STDOUT filehandle is used for output (and no open or close is performed). If the special output filename &quot;&amp;gt;&amp;amp;STDERR&quot; is given then the STDERR filehandle is used for output (and no open or close is performed). If no output filehandle is currently in use and no output filename is specified, then &quot;-&quot; is implied. Alternatively, filehandle references or objects that support the regular IO operations (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, e.g. &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt;) are also accepted; the object must already be opened.</source>
          <target state="translated">如果给定第二个参数，则它应该是所需输出文件的名称。如果给出了特殊的输出文件名&amp;ldquo;-&amp;rdquo;或&amp;ldquo; &amp;amp;&amp;amp;&amp;amp; STDOUT&amp;rdquo;，则将STDOUT文件句柄用于输出（并且不执行打开或关闭操作）。如果给出了特殊的输出文件名&amp;ldquo;&amp;ldquo;&amp;gt; &amp;amp;&amp;amp;&amp;amp; STDERR&amp;rdquo;，那么将使用STDERR文件句柄进行输出（并且不执行打开或关闭操作）。如果当前未使用任何输出文件句柄，并且未指定输出文件名，则意味着&amp;ldquo;-&amp;rdquo;。另外，也可以接受支持常规IO操作的文件句柄引用或对象（例如 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ，例如&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;）；该对象必须已经打开。</target>
        </trans-unit>
        <trans-unit id="477169172ccc2cfa646e6b1ff7ebcaf7ea663dbd" translate="yes" xml:space="preserve">
          <source>If a second argument is given then it should correspond to a filehandle where output should be sent (otherwise the default output filehandle is &lt;code&gt;STDOUT&lt;/code&gt; if no output filehandle is currently in use).</source>
          <target state="translated">如果给定第二个参数，则它应对应于应将输出发送到的文件句柄（否则，如果当前未使用任何输出文件句柄，则默认输出文件句柄为 &lt;code&gt;STDOUT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="93e01c4263faa2fd7e903bd96fbfc6f719b4224a" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">如果任何给定类型的信号在操作码期间多次触发（例如从细粒度的计时器触发），则在操作码完成后，该信号的处理程序将仅被调用一次；所有其他实例将被丢弃。此外，如果系统的信号队列泛滥到某个操作码完成时已经提出但尚未捕获（因此未推迟）的信号，则这些信号很可能在后续操作码中被捕获并推迟。有时结果令人惊讶。例如，即使在调用 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm(0)&lt;/a&gt;&lt;/code&gt; 之后，您也可能会看到警报已传递因为后者会停止发出警报，但不会取消已发出但尚未捕获的警报的传递。不要依赖本段中描述的行为，因为它们是当前实现的副作用，并且在Perl的将来版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="1391421af9c89c0d87f56f7e90949f1788025d04" translate="yes" xml:space="preserve">
          <source>If a signal of any given type fires multiple times during an opcode (such as from a fine-grained timer), the handler for that signal will be called only once, after the opcode completes; all other instances will be discarded. Furthermore, if your system's signal queue gets flooded to the point that there are signals that have been raised but not yet caught (and thus not deferred) at the time an opcode completes, those signals may well be caught and deferred during subsequent opcodes, with sometimes surprising results. For example, you may see alarms delivered even after calling &lt;code&gt;alarm(0)&lt;/code&gt; as the latter stops the raising of alarms but does not cancel the delivery of alarms raised but not yet caught. Do not depend on the behaviors described in this paragraph as they are side effects of the current implementation and may change in future versions of Perl.</source>
          <target state="translated">如果任何给定类型的信号在操作码期间多次触发（例如，从细粒度的计时器触发），则在操作码完成后，该信号的处理程序将仅被调用一次；否则，该操作将被调用一次。所有其他实例将被丢弃。此外，如果系统的信号队列泛滥到某个操作码完成时已经提出但尚未捕获（因此未推迟）的信号，则这些信号很可能在后续的操作码中被捕获和推迟。有时会产生令人惊讶的结果。例如，即使在调用 &lt;code&gt;alarm(0)&lt;/code&gt; 之后，您也可能会看到警报已传递因为后者会停止发出警报，但不会取消已发出但尚未捕获的警报的传递。不要依赖本段中描述的行为，因为它们是当前实现的副作用，并且在Perl的将来版本中可能会更改。</target>
        </trans-unit>
        <trans-unit id="54c4924d3d30f658cd6ca34abca8d30fc0b456c3" translate="yes" xml:space="preserve">
          <source>If a single version is listed, then that version is considered to be the minimum version supported.</source>
          <target state="translated">如果只列出一个版本,那么该版本被认为是支持的最低版本。</target>
        </trans-unit>
        <trans-unit id="8ca9f14adad1a4346557fbd963ffe8837b4e2de6" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt; . You may use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">如果系统上不存在指定的常量 &lt;code&gt;EFOO&lt;/code&gt; ，则 &lt;code&gt;$!{EFOO}&lt;/code&gt; 返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{EFOO}&lt;/code&gt; 来检查常量在系统上是否可用。</target>
        </trans-unit>
        <trans-unit id="bf4eb314d513c3316ce1fa9889a8d0bccfeb7ad3" translate="yes" xml:space="preserve">
          <source>If a specified constant &lt;code&gt;EFOO&lt;/code&gt; does not exist on the system, &lt;code&gt;$!{EFOO}&lt;/code&gt; returns &lt;code&gt;&quot;&quot;&lt;/code&gt;. You may use &lt;code&gt;exists $!{EFOO}&lt;/code&gt; to check whether the constant is available on the system.</source>
          <target state="translated">如果系统上不存在指定的常量 &lt;code&gt;EFOO&lt;/code&gt; ，则 &lt;code&gt;$!{EFOO}&lt;/code&gt; 返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。您可以使用 &lt;code&gt;exists $!{EFOO}&lt;/code&gt; 来检查常量在系统上是否可用。</target>
        </trans-unit>
        <trans-unit id="f800d47729ac41db50a73befe5a0c18db31026bf" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt; .</source>
          <target state="translated">如果字符串是UTF-8，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 获取该值，除非 &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5565b45434f39b2ddc21d26b181951efb62cd428" translate="yes" xml:space="preserve">
          <source>If a string is UTF-8, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; to get at the value, unless &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; in which case you can use &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">如果字符串是UTF-8，请&lt;b&gt;始终&lt;/b&gt;使用 &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; 获取该值，除非 &lt;code&gt;UTF8_IS_INVARIANT(*s)&lt;/code&gt; 在这种情况下可以使用 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1be10a035bc9dd04a9faa3e7d6666d736bd26b25" translate="yes" xml:space="preserve">
          <source>If a sub has both a PROTO and a BLOCK, the prototype is not applied until after the BLOCK is completely defined. This means that a recursive function with a prototype has to be predeclared for the prototype to take effect, like so:</source>
          <target state="translated">如果一个子有PROTO和BLOCK,那么在BLOCK被完全定义后,原型才会被应用。这意味着必须预先声明一个具有原型的递归函数,原型才能生效,就像这样。</target>
        </trans-unit>
        <trans-unit id="0608dc713e7e2ffc835fe7b94ed6aa1dd9da10a4" translate="yes" xml:space="preserve">
          <source>If a subroutine reference was given, it is invoked as:</source>
          <target state="translated">如果给出了一个子程序的引用,那么它的调用是:</target>
        </trans-unit>
        <trans-unit id="b5b26c7bacf7c0c773c98a08b7cfd7b95eaadc8d" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt; , as in &lt;code&gt;floating 'k'$&lt;/code&gt; .</source>
          <target state="translated">如果已知子字符串仅在行尾匹配，则可以跟在 &lt;code&gt;$&lt;/code&gt; 后面，如在 &lt;code&gt;floating 'k'$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2a7b0f64e136490191d68028d9bfc30ff8c824f" translate="yes" xml:space="preserve">
          <source>If a substring is known to match at end-of-line only, it may be followed by &lt;code&gt;$&lt;/code&gt;, as in &lt;code&gt;floating 'k'$&lt;/code&gt;.</source>
          <target state="translated">如果已知子字符串仅在行尾匹配，则可以跟在 &lt;code&gt;$&lt;/code&gt; 后面，如在 &lt;code&gt;floating 'k'$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8bac00f48a56f95c981f68b27c67c1613b3abed" translate="yes" xml:space="preserve">
          <source>If a test had either a &lt;code&gt;TODO&lt;/code&gt; or &lt;code&gt;SKIP&lt;/code&gt; directive, this method will return the accompanying explanation, if present.</source>
          <target state="translated">如果测试具有 &lt;code&gt;TODO&lt;/code&gt; 或 &lt;code&gt;SKIP&lt;/code&gt; 指令，则此方法将返回附带的说明（如果存在）。</target>
        </trans-unit>
        <trans-unit id="65b9290b4f037c914cf42f893f1aba1433a9e97a" translate="yes" xml:space="preserve">
          <source>If a test number is greater than the number of planned tests, this method will return true. Unplanned tests will</source>
          <target state="translated">如果测试次数大于计划的测试次数,这个方法将返回true。未计划的测试将返回</target>
        </trans-unit>
        <trans-unit id="6169b8ce6480907cccaf2d8c56d0f00c7332c0b3" translate="yes" xml:space="preserve">
          <source>If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt;).</source>
          <target state="translated">如果在标量上下文中计算绑定哈希，则将调用 &lt;code&gt;SCALAR&lt;/code&gt; 方法（回 &lt;code&gt;FIRSTKEY&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="99f0a88031cba297a38b9bb2a8d9794138cdfcc6" translate="yes" xml:space="preserve">
          <source>If a transformation subroutine (xfrm) is defined, its value is used to transform the lines read from the filehandle before their comparison.</source>
          <target state="translated">如果定义了一个转换子程序(xfrm),它的值就用来在比较之前转换从filehandle读取的行。</target>
        </trans-unit>
        <trans-unit id="571f9ad4d812cfdda52b01e4ae41c48c7aa1a889" translate="yes" xml:space="preserve">
          <source>If a true value is given (non-zero but should be positive), it will be added as a terminator primary weight to the end of every standard Hangul syllable. Secondary and any higher weights for terminator are set to zero. If the value is false or &lt;code&gt;hangul_terminator&lt;/code&gt; key does not exist, insertion of terminator weights will not be performed.</source>
          <target state="translated">如果给定一个真值（非零，但应为正数），它将作为终止符的主要权重添加到每个标准韩文音节的末尾。终结器的辅助权重和任何更高的权重都设置为零。如果值为false或 &lt;code&gt;hangul_terminator&lt;/code&gt; 键不存在，将不执行终止符权重的插入。</target>
        </trans-unit>
        <trans-unit id="06c503e180fbd73d4ade263d4ec3fc736e96785b" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class
$var&lt;/code&gt; ) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">如果使用包含引用的类型化词法变量（ &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Class $var&lt;/code&gt; ）来访问哈希元素，并且具有与该类型相同名称的包使用此编译指示符声明了类字段，则在编译时将验证哈希键。如果未键入变量，则仅在运行时检查访问。</target>
        </trans-unit>
        <trans-unit id="748870f6864101e2665ecfedb42ab9a1b32e539e" translate="yes" xml:space="preserve">
          <source>If a typed lexical variable (&lt;code&gt;my Class $var&lt;/code&gt;) holding a reference is used to access a hash element and a package with the same name as the type has declared class fields using this pragma, then the hash key is verified at compile time. If the variables are not typed, access is only checked at run time.</source>
          <target state="translated">如果使用包含引用的类型化词法变量（ &lt;code&gt;my Class $var&lt;/code&gt; ）来访问哈希元素，并且具有与该类型相同名称的包已使用此编译指示声明了类字段，则在编译时将验证哈希键。如果未键入变量，则仅在运行时检查访问。</target>
        </trans-unit>
        <trans-unit id="a56a688e323d9747dee356792880eafa156d2877" translate="yes" xml:space="preserve">
          <source>If a utility or module isn't available, it will be marked in a cache (see the &lt;code&gt;$METHOD_FAIL&lt;/code&gt; variable further down), so it will not be tried again. The &lt;code&gt;fetch&lt;/code&gt; method will only fail when all options are exhausted, and it was not able to retrieve the file.</source>
          <target state="translated">如果某个实用程序或模块不可用，则会在缓存中将其标记出来（请参阅 &lt;code&gt;$METHOD_FAIL&lt;/code&gt; 变量进一步说明），因此不会再次尝试。仅当所有选项都用尽并且无法检索文件时， &lt;code&gt;fetch&lt;/code&gt; 方法才会失败。</target>
        </trans-unit>
        <trans-unit id="17e415afdb54d5332d73e9d658477c2317a9747c" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt; -type or &lt;code&gt;+&lt;/code&gt; -type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;Initializing Function Parameters&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">如果在CODE：节中声明了变量，它将遵循为输入参数发出的任何类型映射代码。这可能导致声明以C代码结尾，这是C语法错误。显式可能会发生类似的错误 &lt;code&gt;;&lt;/code&gt; 型或 &lt;code&gt;+&lt;/code&gt; 型的使用参数初始化（见&lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;初始化功能参数&lt;/a&gt;）。在INIT：部分中声明这些变量将无济于事。</target>
        </trans-unit>
        <trans-unit id="1207e0b0d0efedf009a2fba67d60a91b64445106" translate="yes" xml:space="preserve">
          <source>If a variable is declared inside a CODE: section it will follow any typemap code that is emitted for the input parameters. This may result in the declaration ending up after C code, which is C syntax error. Similar errors may happen with an explicit &lt;code&gt;;&lt;/code&gt;-type or &lt;code&gt;+&lt;/code&gt;-type initialization of parameters is used (see &lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;&quot;Initializing Function Parameters&quot;&lt;/a&gt;). Declaring these variables in an INIT: section will not help.</source>
          <target state="translated">如果在CODE：节中声明了变量，它将遵循为输入参数发出的任何类型映射代码。这可能会导致声明以C代码结尾，这是C语法错误。显式可能会发生类似的错误 &lt;code&gt;;&lt;/code&gt; 使用参数的-type或 &lt;code&gt;+&lt;/code&gt; -type初始化（请参见&lt;a href=&quot;#Initializing-Function-Parameters&quot;&gt;&amp;ldquo;初始化函数参数&amp;rdquo;&lt;/a&gt;）。在INIT：部分中声明这些变量将无济于事。</target>
        </trans-unit>
        <trans-unit id="7b3996807bb1f09e79ba835867b4d5ba2a1e4f04" translate="yes" xml:space="preserve">
          <source>If a version object is compared against a non-version object, the non-object term will be converted to a version object using &lt;code&gt;parse()&lt;/code&gt;. This may give surprising results:</source>
          <target state="translated">如果将版本对象与非版本对象进行比较，则将使用 &lt;code&gt;parse()&lt;/code&gt; 将非对象术语转换为版本对象。这可能会产生令人惊讶的结果：</target>
        </trans-unit>
        <trans-unit id="b1e1471095c4d68dab8592febf94b7e3ac2a2016" translate="yes" xml:space="preserve">
          <source>If accept() is interrupted by a signal, $! will be set to EINTR. If this happens, we can safely continue to the next iteration of the loop and another call to accept(). It is important that your signal handling code not modify the value of $!, or else this test will likely fail. In the REAPER subroutine we create a local version of $! before calling waitpid(). When waitpid() sets $! to ECHILD as it inevitably does when it has no more children waiting, it updates the local copy and leaves the original unchanged.</source>
          <target state="translated">如果accept()被一个信号打断,$!将被设置为EINTR。如果发生这种情况,我们可以安全地继续下一个循环的迭代,再调用accept()。重要的是,你的信号处理代码不能修改$!的值,否则这个测试很可能会失败。在REAPER子程序中,我们在调用waitpid()之前创建一个本地版本的$!。当waitpid()将$!设置为ECHILD时,因为当它没有更多的子程序等待时,它必然会更新本地副本,并保持原始副本不变。</target>
        </trans-unit>
        <trans-unit id="752e6cffd40215caddfd723588dccf4863a5ed16" translate="yes" xml:space="preserve">
          <source>If adding a new module to a set, follow the original author's standards for naming modules and the interface to methods in those modules.</source>
          <target state="translated">如果在一个集合中增加一个新的模块,按照原作者的标准来命名模块和这些模块中的方法接口。</target>
        </trans-unit>
        <trans-unit id="740a7df0564a13f66fe6f00e1a8f73b803531ecf" translate="yes" xml:space="preserve">
          <source>If after any stripping of indentation in verbatim blocks, there remain tabs, this method call indicates what to do with them. &lt;code&gt;0&lt;/code&gt; means leave them as tabs, any other number indicates that each tab is to be translated so as to have tab stops every &lt;code&gt;n&lt;/code&gt; columns.</source>
          <target state="translated">如果在逐字删除任何缩进后仍然保留制表符，则此方法调用指示如何处理它们。 &lt;code&gt;0&lt;/code&gt; 表示将其保留为制表符，任何其他数字表示每个制表符都将被翻译，以使制表符每隔 &lt;code&gt;n&lt;/code&gt; 列停一次。</target>
        </trans-unit>
        <trans-unit id="c30aaa76b20fc01d8891caaf8c421bdbbefa39ad" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; will fail.</source>
          <target state="translated">如果在该过程之后仍未定义该层，则 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="c550e6d69474a6a7c10a80260775c6595e782f16" translate="yes" xml:space="preserve">
          <source>If after that process the layer is still not defined then the &lt;code&gt;open&lt;/code&gt; will fail.</source>
          <target state="translated">如果在该过程之后仍未定义该层，则 &lt;code&gt;open&lt;/code&gt; 将失败。</target>
        </trans-unit>
        <trans-unit id="3f5b65dba45a85e174c3b613f61ee902daa93694" translate="yes" xml:space="preserve">
          <source>If all actions were successful install will return a hashref of the results as described above for the $result parameter. If any action is a failure then install will die, therefore it is recommended to pass in the $result parameter instead of using the return value. If the result parameter is provided then the returned hashref will be the passed in hashref.</source>
          <target state="translated">如果所有的操作都是成功的,那么 install 将会像上面描述的 $result 参数那样返回一个结果的哈希夫。如果任何操作都是失败的,那么 install 就会死掉,因此建议传入 $result 参数而不是使用返回值。如果提供了result参数,那么返回的hashref将是传入的hashref。</target>
        </trans-unit>
        <trans-unit id="127255eea385053cfe8f53f8f2c648f76a8be49c" translate="yes" xml:space="preserve">
          <source>If all data that comes from a certain handle is encoded in exactly the same way, you can tell the PerlIO system to automatically decode everything, with the &lt;code&gt;encoding&lt;/code&gt; layer. If you do this, you can't accidentally forget to decode or encode anymore, on things that use the layered handle.</source>
          <target state="translated">如果来自某个句柄的所有数据都以完全相同的方式编码，则可以告诉PerlIO系统使用 &lt;code&gt;encoding&lt;/code&gt; 层自动解码所有内容。如果这样做，您就不会偶然忘记对使用分层句柄的东西进行解码或编码了。</target>
        </trans-unit>
        <trans-unit id="3e7d1b1bb140827b5655410f34d1155c7f80618e" translate="yes" xml:space="preserve">
          <source>If all goes okay and no errors during a build, you'll get two independent distributions: &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; and &lt;code&gt;mips-wce300-thr&lt;/code&gt; .</source>
          <target state="translated">如果一切顺利，并且在构建过程中没有错误，您将获得两个独立的发行版： &lt;code&gt;wince-mips-pocket-wce300&lt;/code&gt; 和 &lt;code&gt;mips-wce300-thr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9089d68477d6441e4f9e9f5ebed86f489f07115" translate="yes" xml:space="preserve">
          <source>If all is well then update your blead branch:</source>
          <target state="translated">如果一切正常,那么更新你的blead分支。</target>
        </trans-unit>
        <trans-unit id="2ab3e0df4f550d075ed2874e19cdd1793f373e2a" translate="yes" xml:space="preserve">
          <source>If all this is intimidating, have no (well, maybe only a little) fear. There are modules that can help. The &lt;code&gt;File::Spec&lt;/code&gt; modules provide methods to do the Right Thing on whatever platform happens to be running the program.</source>
          <target state="translated">如果所有这些都令人生畏，那就不要（好，也许只有一点）恐惧。有些模块可以提供帮助。该 &lt;code&gt;File::Spec&lt;/code&gt; 模块提供的方法做正确的事情就什么平台恰好是运行程序。</target>
        </trans-unit>
        <trans-unit id="ae7ad2a8e725968ebffe98c6ec06a2f880b60f52" translate="yes" xml:space="preserve">
          <source>If all you want to do is pretend to be telnet but don't need the initial telnet handshaking, then the standard dual-process approach will suffice:</source>
          <target state="translated">如果你想做的只是假装是telnet,但不需要最初的telnet握手,那么标准的双进程方式就足够了。</target>
        </trans-unit>
        <trans-unit id="9403f48a0d39d844d9c0ac74b1c19be5f1602977" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果所有测试都通过，则&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;将以零退出（这是正常的）。如果有任何失败，它将以多少失败退出。如果您运行的测试数量少于计划的数量（或更多），那么缺失（或额外）的测试将被视为失败。如果没有运行过任何测试，则&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;将发出警告并以255退出。如果测试失败，即使在成功完成所有测试之后，仍将视为失败并以255退出。</target>
        </trans-unit>
        <trans-unit id="114fc5763881eaed2b695ddb5eda1e514b33dd63" translate="yes" xml:space="preserve">
          <source>If all your tests passed, &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果所有测试均通过，则&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;将以零退出（正常）。如果有任何失败，它将以多少失败退出。如果您运行的测试次数少于计划的次数（或更多），那么缺失（或额外）的测试将被视为失败。如果从未运行过任何测试，则&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;将发出警告并以255退出。如果测试失败，即使在成功完成所有测试之后，仍将视为失败并以255退出。</target>
        </trans-unit>
        <trans-unit id="a98f6624ef41fa5865752ff72d1c88c5adce8ff1" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Builder will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Builder will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果你的所有测试都通过了,Test::Builder将以0退出(这是正常的)。如果有任何测试失败,它将以失败的次数退出。如果您运行的测试比您计划的少(或多),缺少的(或额外的)测试将被视为失败。如果没有运行过任何测试,Test::Builder将抛出一个警告并以255退出。如果测试死了,即使成功地完成了所有的测试,它仍然会被认为是失败的,并以 255 退出。</target>
        </trans-unit>
        <trans-unit id="ec52cc18e24a40a3b425f46525ccb32d3bbfcd0d" translate="yes" xml:space="preserve">
          <source>If all your tests passed, Test::Simple will exit with zero (which is normal). If anything failed it will exit with how many failed. If you run less (or more) tests than you planned, the missing (or extras) will be considered failures. If no tests were ever run Test::Simple will throw a warning and exit with 255. If the test died, even after having successfully completed all its tests, it will still be considered a failure and will exit with 255.</source>
          <target state="translated">如果你的所有测试都通过了,Test::Simple将以0退出(这是正常的)。如果有任何测试失败,它将以失败的次数退出。如果你运行的测试比你计划的少(或多),缺少的(或额外的)测试将被视为失败。如果没有运行过任何测试,Test::Simple将抛出一个警告并以255退出。如果测试死了,即使在成功地完成了所有测试之后,它仍然会被认为是失败的,并以 255 退出。</target>
        </trans-unit>
        <trans-unit id="bf21a78dfdb342ccff4796ddae824fa3095f386e" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项并且它是一个简单的标量，则它必须符合RFC 1952中定义的子字段结构。</target>
        </trans-unit>
        <trans-unit id="703bb32d1796efb54146381859e7e166335fd702" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified and it is a simple scalar, the structure will not be checked. The only error is if the length is too big.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项，并且它是简单的标量，则不会检查结构。唯一的错误是长度太大。</target>
        </trans-unit>
        <trans-unit id="d5888ada14b086770c285ef36da99e64d4b36a12" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExtraField&lt;/code&gt; option is specified the second byte of the ID will be checked in each subfield to ensure that it does not contain the reserved value 0x00.</source>
          <target state="translated">如果指定了 &lt;code&gt;ExtraField&lt;/code&gt; 选项，则将在每个子字段中检查ID的第二个字节，以确保它不包含保留值0x00。</target>
        </trans-unit>
        <trans-unit id="bba67c55f0a73d622c034c758b4c54c06d0297ce" translate="yes" xml:space="preserve">
          <source>If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable of the XSUB's package.</source>
          <target state="translated">如果一个AUTOLOAD例程是一个XSUB,就像Perl子程序一样,Perl将自动加载的子程序的完全限定名放在XSUB包的$AUTOLOAD变量中。</target>
        </trans-unit>
        <trans-unit id="5f16d14b8173a324e3c6a5e5bf643eb4986c26e1" translate="yes" xml:space="preserve">
          <source>If an IPC encounters a fatal error it should use this. This will print the message to STDERR with &lt;code&gt;'IPC Fatal Error: '&lt;/code&gt; prefixed to it, then it will forcefully exit 255. IPC errors may occur in threads or processes other than the main one, this method provides the best chance of the harness noticing the error.</source>
          <target state="translated">如果IPC遇到致命错误，则应使用此错误。这会将带有 &lt;code&gt;'IPC Fatal Error: '&lt;/code&gt; 前缀的消息打印到STDERR ，然后将其强制退出255。IPC错误可能发生在除主要线程之外的线程或进程中，此方法提供了最大的机会来利用线束注意到错误。</target>
        </trans-unit>
        <trans-unit id="42bdc376fb833e498b49e6edb80ebe7de88f4149" translate="yes" xml:space="preserve">
          <source>If an Input glob matches the same file more than once, only the first will be used.</source>
          <target state="translated">如果一个Input glob与同一个文件匹配超过一次,将只使用第一个文件。</target>
        </trans-unit>
        <trans-unit id="4c7ac1d42b2433b8600fc2dd6eb1a16139df0641" translate="yes" xml:space="preserve">
          <source>If an XSUB is created to offer a direct translation between this function and Perl, then this XSUB will be used from Perl with the following code. The $status and $timep variables will contain the output of the function.</source>
          <target state="translated">如果创建了一个XSUB来提供函数和Perl之间的直接转换,那么这个XSUB将通过以下代码在Perl中使用。$status 和 $timep 变量将包含函数的输出。</target>
        </trans-unit>
        <trans-unit id="b382afe3d07f60c5f6eced5294d3838170432890" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt; , it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">如果XSUB名称包含 &lt;code&gt;::&lt;/code&gt; ，则将其视为C ++方法。生成的Perl函数将假定其第一个参数是对象指针。对象指针将存储在名为THIS的变量中。该对象应该已经由C ++使用new（）函数创建，并且应该由Perl使用sv_setref_pv（）宏来祝福。Perl对对象的祝福可以通过类型映射来处理。本节末尾显示了一个示例类型映射。</target>
        </trans-unit>
        <trans-unit id="1b3718c1d670d39036e818ea2e8844505748f38c" translate="yes" xml:space="preserve">
          <source>If an XSUB name contains &lt;code&gt;::&lt;/code&gt;, it is considered to be a C++ method. The generated Perl function will assume that its first argument is an object pointer. The object pointer will be stored in a variable called THIS. The object should have been created by C++ with the new() function and should be blessed by Perl with the sv_setref_pv() macro. The blessing of the object by Perl can be handled by a typemap. An example typemap is shown at the end of this section.</source>
          <target state="translated">如果XSUB名称包含 &lt;code&gt;::&lt;/code&gt; ，则将其视为C ++方法。生成的Perl函数将假定其第一个参数是对象指针。对象指针将存储在名为THIS的变量中。该对象应该已经由C ++使用new（）函数创建，并且应该由Perl使用sv_setref_pv（）宏来祝福。Perl对对象的祝福可以通过类型映射来处理。本节末尾显示了一个示例类型映射。</target>
        </trans-unit>
        <trans-unit id="5b2e1d1934ece2d63d504b4355cb9c8a6aa0fa5a" translate="yes" xml:space="preserve">
          <source>If an angle-bracket-based globbing expression is used as the condition of a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loop, then it will be implicitly assigned to &lt;code&gt;$_&lt;/code&gt;. If either a globbing expression or an explicit assignment of a globbing expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="translated">如果将基于尖括号的globlob表达式用作 &lt;code&gt;while&lt;/code&gt; 或 &lt;code&gt;for&lt;/code&gt; 循环的条件，则它将被隐式分配给 &lt;code&gt;$_&lt;/code&gt; 。如果将通配表达式或通配符对标量的显式分配用作 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 条件，则条件实际上将测试表达式值的定义性，而不是其正则真值。</target>
        </trans-unit>
        <trans-unit id="a5be5707a4fed01d7fc6a9c5c683f16ea2406809" translate="yes" xml:space="preserve">
          <source>If an argument callback routine is specified, &lt;code&gt;@ARGV&lt;/code&gt; will always be empty upon successful return of GetOptions() since all options have been processed. The only exception is when &lt;code&gt;--&lt;/code&gt; is used:</source>
          <target state="translated">如果指定了参数回调例程，则在成功返回GetOptions（）时，@ &lt;code&gt;@ARGV&lt;/code&gt; 将始终为空，因为已处理所有选项。唯一的例外是使用 &lt;code&gt;--&lt;/code&gt; 时：</target>
        </trans-unit>
        <trans-unit id="b39b97b3c5875ed6ddbb4cadef1665f0d49ebbe7" translate="yes" xml:space="preserve">
          <source>If an argument is given, it must correspond to the desired section heading number, in which case only the specified section heading is returned. If there is no current section heading at the specified level, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果给出参数，则它必须对应于所需的节标题号，在这种情况下，仅返回指定的节标题。如果没有指定级别的当前节标题，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7271fc38171101f8ded47e78d280e28ab4aefe24" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , or &lt;code&gt;CODE&lt;/code&gt; ), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">如果声明了属性处理程序，并且为 &lt;code&gt;:ATTR&lt;/code&gt; 说明符指定了内置类型的名称（ &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; 或 &lt;code&gt;CODE&lt;/code&gt; ），则该处理程序仅应用于该类型的声明。例如，以下定义：</target>
        </trans-unit>
        <trans-unit id="99c7ef44f90555314050f910e8588b5f9dbab3f7" translate="yes" xml:space="preserve">
          <source>If an attribute handler is declared and the &lt;code&gt;:ATTR&lt;/code&gt; specifier is given the name of a built-in type (&lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, or &lt;code&gt;CODE&lt;/code&gt;), the handler is only applied to declarations of that type. For example, the following definition:</source>
          <target state="translated">如果声明了属性处理程序，并为 &lt;code&gt;:ATTR&lt;/code&gt; 说明符指定了内置类型的名称（ &lt;code&gt;SCALAR&lt;/code&gt; ， &lt;code&gt;ARRAY&lt;/code&gt; ， &lt;code&gt;HASH&lt;/code&gt; 或 &lt;code&gt;CODE&lt;/code&gt; ），则该处理程序仅应用于该类型的声明。例如，以下定义：</target>
        </trans-unit>
        <trans-unit id="62eb757e944d2fdd579513e058242369fd9ee059" translate="yes" xml:space="preserve">
          <source>If an element of</source>
          <target state="translated">如果一个元素</target>
        </trans-unit>
        <trans-unit id="12dcad5cabf51c630b511f4237ee95faf62760f4" translate="yes" xml:space="preserve">
          <source>If an element, call it ELEMENT, is not on this list, try using this command to find out why:</source>
          <target state="translated">如果一个元素,称它为ELEMENT,不在这个列表中,可以尝试使用这个命令来找出原因。</target>
        </trans-unit>
        <trans-unit id="ac822e62f394feec698ce4d683fc3173f8604479" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, or nothing that matches the first 3 values above is returned, then &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks at the remaining elements of &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt;. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">如果返回一个空列表，&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;或与上面的前三个值不匹配的任何内容，则&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;将查看&lt;a href=&quot;perlvar#%40INC&quot;&gt; &lt;code&gt;@INC&lt;/code&gt; &lt;/a&gt;的其余元素。请注意，此文件句柄必须是真实的文件句柄（严格来说是typeglob或对typeglob的引用，无论是有福的还是无福的）；绑定的文件句柄将被忽略，处理将在那里停止。</target>
        </trans-unit>
        <trans-unit id="34964fb1164dd648c7d2582c841b9ac59c8a6438" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">如果返回一个空列表， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或与上面的前三个值不匹配的任何内容，则 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 查看@INC的其余元素。请注意，此文件句柄必须是真实的文件句柄（严格来说是typeglob或对typeglob的引用，无论是有福的还是无福的）；绑定的文件句柄将被忽略，处理将在那里停止。</target>
        </trans-unit>
        <trans-unit id="e6b9ed06c157d2ccb39c11bcda5c6ea1f6b42a42" translate="yes" xml:space="preserve">
          <source>If an empty list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or nothing that matches the first 3 values above is returned, then &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks at the remaining elements of @INC. Note that this filehandle must be a real filehandle (strictly a typeglob or reference to a typeglob, whether blessed or unblessed); tied filehandles will be ignored and processing will stop there.</source>
          <target state="translated">如果返回一个空列表， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或与上面的前三个值不匹配的任何内容，则 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 查看@INC的其余元素。请注意，此文件句柄必须是真实的文件句柄（严格来说是typeglob或对typeglob的引用，无论是有福的还是无福的）；绑定的文件句柄将被忽略，处理将在那里停止。</target>
        </trans-unit>
        <trans-unit id="f919dfddbef4a1a12f08337d7a834831006d9b11" translate="yes" xml:space="preserve">
          <source>If an error is encountered during conversion, output file will be removed and a warning emitted instead of terminating the conversion immediately.</source>
          <target state="translated">如果在转换过程中遇到错误,输出文件将被删除并发出警告,而不是立即终止转换。</target>
        </trans-unit>
        <trans-unit id="9714806e81ca60318ef1d507fb9add3187535d9b" translate="yes" xml:space="preserve">
          <source>If an error occurs &lt;code&gt;blocking&lt;/code&gt; will return undef and &lt;code&gt;$!&lt;/code&gt; will be set.</source>
          <target state="translated">如果发生错误， &lt;code&gt;blocking&lt;/code&gt; 将返回undef和 &lt;code&gt;$!&lt;/code&gt; 将被设置。</target>
        </trans-unit>
        <trans-unit id="223081f636c4dc0e612cdeecd4fd8749800bcc2c" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree (most likely null) is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">如果在解析或编译过程中发生错误,在大多数情况下,还是会返回一个有效的操作树(很可能是null)。错误会反映在解析器状态中,通常会在解析的顶层产生一个异常,它涵盖了所有发生的编译错误。然而,有些编译错误会立即抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="409c88cc16ea56deb3ee2fd13496f8443cdeb8ed" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing or compilation, in most cases a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. Some compilation errors, however, will throw an exception immediately.</source>
          <target state="translated">如果在解析或编译过程中发生错误,在大多数情况下,还是会返回一个有效的操作树。错误会反映在解析器状态中,通常会在解析的顶层产生一个单一的异常,它涵盖了所有发生的编译错误。然而,有些编译错误会立即抛出一个异常。</target>
        </trans-unit>
        <trans-unit id="fb3a0347b1d41b96c13bdbefc10e2d1afbf9de50" translate="yes" xml:space="preserve">
          <source>If an error occurs in parsing, which can only occur if the label is mandatory, a valid label is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred.</source>
          <target state="translated">如果在解析过程中发生错误,只有在标签是强制性的情况下才会发生,无论如何都会返回一个有效的标签。该错误会反映在解析器状态中,通常会在解析的最高层产生一个异常,该异常涵盖了所有发生的编译错误。</target>
        </trans-unit>
        <trans-unit id="d9bdcdf03abe1ba577aa0e79f3435579268caad1" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the fragment of string that has been converted and modify $octets in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">如果发生错误,它将返回被转换的字符串片段,并在原地修改$octets以删除转换后的部分,让它从问题片段开始。如果perlio_ok()为真,SHOULD变成MUST。</target>
        </trans-unit>
        <trans-unit id="5cf7457198e3f9cd671a04a577836ab4a9017358" translate="yes" xml:space="preserve">
          <source>If an error occurs, it SHOULD return the octet sequence for the fragment of string that has been converted and modify $string in-place to remove the converted part leaving it starting with the problem fragment. If perlio_ok() is true, SHOULD becomes MUST.</source>
          <target state="translated">如果发生错误,它将返回被转换的字符串片段的八位数序列,并在原地修改$string以删除转换后的部分,使其从问题片段开始。如果perlio_ok()为真,SHOULD变成了MUST。</target>
        </trans-unit>
        <trans-unit id="0c2d11e497e2ae0afa960e508853e27c914d2845" translate="yes" xml:space="preserve">
          <source>If an existing module &lt;b&gt;almost&lt;/b&gt; does what you want, consider writing a patch, writing a subclass, or otherwise extending the existing module rather than rewriting it.</source>
          <target state="translated">如果现有模块&lt;b&gt;几乎&lt;/b&gt;可以满足您的要求，请考虑编写补丁程序，编写子类或以其他方式扩展现有模块，而不是重写它。</target>
        </trans-unit>
        <trans-unit id="82c1aacb1c3709d4e7d697aae2bed5c77802f47c" translate="yes" xml:space="preserve">
          <source>If an exit status</source>
          <target state="translated">如果退出状态</target>
        </trans-unit>
        <trans-unit id="cea12036a9c231320c44066b7b5457646bd39537" translate="yes" xml:space="preserve">
          <source>If an exit status is</source>
          <target state="translated">如果退出状态为</target>
        </trans-unit>
        <trans-unit id="e2873de2f1e9af5ea740b20953d89320900ebe0e" translate="yes" xml:space="preserve">
          <source>If an extant $SIG{__WARN__} handler is discovered, it will continue to be honored, but only after the diagnostics::splainthis() function (the module's $SIG{__WARN__} interceptor) has had its way with your warnings.</source>
          <target state="translated">如果发现了一个现存的 $SIG{__WARN__}处理程序,它将继续被尊重,但只有在 diagnostics::splainthis()函数 (模块的 $SIG{__WARN__}拦截器)处理完你的警告之后才会被尊重。</target>
        </trans-unit>
        <trans-unit id="d72e4c503af6f4a09cfa2171e2474d37da483a9b" translate="yes" xml:space="preserve">
          <source>If an extension is being built away from the perl source then MakeMaker will leave PERL_SRC undefined and default to using the installed copy of the perl library. The other variables default to the following:</source>
          <target state="translated">如果正在构建一个远离perl源码的扩展,那么MakeMaker将不定义PERL_SRC,默认使用已安装的perl库副本。其他变量默认为如下。</target>
        </trans-unit>
        <trans-unit id="a1c876b366d6c58e85d7243f2dbcbb0c36548470" translate="yes" xml:space="preserve">
          <source>If an extension is being built below the &lt;code&gt;ext/&lt;/code&gt; directory of the perl source then MakeMaker will set PERL_SRC automatically (e.g., &lt;code&gt;../..&lt;/code&gt;). If PERL_SRC is defined and the extension is recognized as a standard extension, then other variables default to the following:</source>
          <target state="translated">如果在perl源的 &lt;code&gt;ext/&lt;/code&gt; 目录下构建扩展名，那么MakeMaker将自动设置PERL_SRC（例如 &lt;code&gt;../..&lt;/code&gt; ）。如果定义了PERL_SRC并将扩展名识别为标准扩展名，则其他变量默认为以下内容：</target>
        </trans-unit>
        <trans-unit id="a0316d054e0262fb322cda466200340b0b6b9a08" translate="yes" xml:space="preserve">
          <source>If an extractor returns a defined value, that value is immediately treated as the next extracted field and pushed onto the list of fields. If the extractor was specified in a hash reference, the field is also blessed into the appropriate class,</source>
          <target state="translated">如果提取器返回一个定义的值,该值会立即被视为下一个提取的字段,并被推送到字段列表中。如果提取器是在哈希引用中指定的,该字段也会被祝福到相应的类中。</target>
        </trans-unit>
        <trans-unit id="19aae17e0a99010e0b921850c1a03e6076850e68" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, &lt;code&gt;*sp&lt;/code&gt; will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and &lt;code&gt;*sp&lt;/code&gt; will not move.</source>
          <target state="translated">如果识别出无穷大或非数字，则 &lt;code&gt;*sp&lt;/code&gt; 将指向识别的字符串末尾的一个字节。如果识别失败，则返回零，并且 &lt;code&gt;*sp&lt;/code&gt; 将不会移动。</target>
        </trans-unit>
        <trans-unit id="f7e24bf211ae35444c0a5b02834d4c163f847646" translate="yes" xml:space="preserve">
          <source>If an infinity or a not-a-number is recognized, the *sp will point to one byte past the end of the recognized string. If the recognition fails, zero is returned, and the *sp will not move.</source>
          <target state="translated">如果识别出一个无穷大或非数字,*sp将指向识别出的字符串末端的一个字节。如果识别失败,则返回0,并且*sp不会移动。</target>
        </trans-unit>
        <trans-unit id="ce09f2ed6b39791e05ffc528e1a968457528299e" translate="yes" xml:space="preserve">
          <source>If an object does not support the method specified (determined using UNIVERSAL::can()) then the call will be skipped. If the method dies a warning will be generated.</source>
          <target state="translated">如果一个对象不支持指定的方法(使用UNIVERSAL::can()确定),那么调用将被跳过。如果该方法失效,则会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="24adf3fb9ad8a72560fd633d7f97a817649bd630" translate="yes" xml:space="preserve">
          <source>If an operation is trapped in this way, then the code in STRING will not be executed. If such a trapped operation occurs or any other compile-time or return error, then $@ is set to the error message, just as with an eval().</source>
          <target state="translated">如果一个操作以这种方式被捕获,那么STRING中的代码将不会被执行。如果发生这样的陷阱操作或任何其他编译时或返回错误,那么$@就会被设置为错误信息,就像eval()一样。</target>
        </trans-unit>
        <trans-unit id="010067cf6d54e236b69f60d21b2be969b22dcb45" translate="yes" xml:space="preserve">
          <source>If an optional feature is used by a consumer to add additional prerequisites, the consumer should merge the optional feature prerequisites into those given by the &lt;code&gt;prereqs&lt;/code&gt; key using the same semantics. See &lt;a href=&quot;#Merging-and-Resolving-Prerequisites&quot;&gt;&quot;Merging and Resolving Prerequisites&quot;&lt;/a&gt; for details on merging prerequisites.</source>
          <target state="translated">如果使用者使用可选功能来添加其他先决条件，则使用者应使用相同的语义将可选功能先决条件合并到 &lt;code&gt;prereqs&lt;/code&gt; 键所给定的先决条件中。有关&lt;a href=&quot;#Merging-and-Resolving-Prerequisites&quot;&gt;合并先决条件&lt;/a&gt;的详细信息，请参见&amp;ldquo;合并和解决先决条件&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ed03e924684c92a9ff3960f906eb5ec6eb3ba279" translate="yes" xml:space="preserve">
          <source>If an output file depends on extra input files beside the script itself, a hash ref can be used in version 7.36 and above:</source>
          <target state="translated">如果输出文件依赖于脚本本身以外的额外输入文件,可以在7.36及以上版本中使用哈希引用。</target>
        </trans-unit>
        <trans-unit id="c694eae799a264caff23c78599d66c65a6eff8ab" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; with this pseudocode:</source>
          <target state="translated">如果未捕获的异常导致解释器退出，则退出代码由&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;的值确定。和&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;使用此伪代码：</target>
        </trans-unit>
        <trans-unit id="215592828190613f91a4fc9378ebe41cd5d2be61" translate="yes" xml:space="preserve">
          <source>If an uncaught exception results in interpreter exit, the exit code is determined from the values of &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; with this pseudocode:</source>
          <target state="translated">如果未捕获的异常导致解释器退出，则退出代码由 &lt;code&gt;$!&lt;/code&gt; 的值确定。和 &lt;code&gt;$?&lt;/code&gt; 使用此伪代码：</target>
        </trans-unit>
        <trans-unit id="9816162ad52f74eb6f76cc05f87a2c2e46e90fd4" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;CreateFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="translated">如果当前有另一个进程具有对该文件的读取，写入和/或删除访问权限，并且您不允许该级别的共享，则对 &lt;code&gt;CreateFile&lt;/code&gt; 的调用将失败。如果您请求读取，写入和/或删除访问权限，并且另一个进程已经打开了文件但不允许该级别的共享，则对 &lt;code&gt;createFile&lt;/code&gt; 的调用将失败。打开文件后，如果另一个进程尝试以读取，写入和/或删除访问权限打开它，并且您不允许该级别的共享，则将不允许该进程打开文件。</target>
        </trans-unit>
        <trans-unit id="92c5b88805d10f4113bd0a0998d163f4bc00c5dc" translate="yes" xml:space="preserve">
          <source>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to &lt;code&gt;createFile&lt;/code&gt; will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</source>
          <target state="translated">如果当前有另一个进程具有对该文件的读取，写入和/或删除访问权限，并且您不允许该级别的共享，则对 &lt;code&gt;createFile&lt;/code&gt; 的调用将失败。如果您请求读取，写入和/或删除访问权限，并且另一个进程已经打开了文件但不允许该级别的共享，则对 &lt;code&gt;createFile&lt;/code&gt; 的调用将失败。打开文件后，如果另一个进程尝试以读取，写入和/或删除访问权限打开它，并且您不允许该级别的共享，则将不允许该进程打开文件。</target>
        </trans-unit>
        <trans-unit id="7b864a885bc89443cbce8d662bf2be7249be99d8" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;test_args&lt;/code&gt; are given they will be appended to the end of the command argument list.</source>
          <target state="translated">如果给出任何 &lt;code&gt;test_args&lt;/code&gt; ，它们将被附加到命令参数列表的末尾。</target>
        </trans-unit>
        <trans-unit id="37251314e00b333d40467d467ca5c0c35c0e366e" translate="yes" xml:space="preserve">
          <source>If any argument to &lt;b&gt;podselect&lt;/b&gt; is a reference to a hash (associative array) then the values with the following keys are processed as follows:</source>
          <target state="translated">如果&lt;b&gt;podselect的&lt;/b&gt;任何参数是对哈希（关联数组）的引用，则具有以下键的值将按以下方式处理：</target>
        </trans-unit>
        <trans-unit id="0fa7b6de1acc5eb4980a2653a96afb04a72dd14b" translate="yes" xml:space="preserve">
          <source>If any arguments remain, and &lt;code&gt;GetOptionsFromString&lt;/code&gt; was not called in list context, a message will be given and &lt;code&gt;GetOptionsFromString&lt;/code&gt; will return failure.</source>
          <target state="translated">如果有任何争论依然存在，并 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 没有在列表上下文中调用时，一条消息将被赋予与 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 将返回失败。</target>
        </trans-unit>
        <trans-unit id="59b5cfa2ac91aed4f93a07d4f29fc54a851c06d0" translate="yes" xml:space="preserve">
          <source>If any destructors are triggered as a result, the hv itself may be freed.</source>
          <target state="translated">如果因此触发了任何破坏者,那么hv本身可能会被释放。</target>
        </trans-unit>
        <trans-unit id="dd7074163e07f37b8a41bd25ef8050c203f85577" translate="yes" xml:space="preserve">
          <source>If any directories are included in @names they are searched before @dl_library_path. Directories may be specified as &lt;b&gt;-Ldir&lt;/b&gt;. Any other names are treated as filenames to be searched for.</source>
          <target state="translated">如果@name中包含任何目录，则在@dl_library_path之前搜索它们。目录可以指定为&lt;b&gt;-Ldir&lt;/b&gt;。其他任何名称均视为要搜索的文件名。</target>
        </trans-unit>
        <trans-unit id="864b32c42a324d7506e9ca2ec49f2bbc8bbdcf83" translate="yes" xml:space="preserve">
          <source>If any element of LIST is an lvalue, you can modify it by modifying VAR inside the loop. Conversely, if any element of LIST is NOT an lvalue, any attempt to modify that element will fail. In other words, the &lt;code&gt;foreach&lt;/code&gt; loop index variable is an implicit alias for each item in the list that you're looping over.</source>
          <target state="translated">如果LIST的任何元素是左值，则可以通过在循环内修改VAR来对其进行修改。相反，如果LIST的任何元素不是左值，则任何修改该元素的尝试都将失败。换句话说， &lt;code&gt;foreach&lt;/code&gt; 循环索引变量是您要遍历的列表中每个项目的隐式别名。</target>
        </trans-unit>
        <trans-unit id="3cbc5bd59ee7e5290e2a6a24d40e5bd7de01e87c" translate="yes" xml:space="preserve">
          <source>If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">如果任何一个函数有OVERLOAD:关键字,那么在xsubpp生成的c文件中会有几行额外的定义,以便用过载魔法注册。</target>
        </trans-unit>
        <trans-unit id="705cbac0d6d9464ed1b8a92ba681b4a46a07d153" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。</target>
        </trans-unit>
        <trans-unit id="cec7c53718240c968018769a330928a1255918e0" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。例如，由于命名的一元运算符的优先级高于 &lt;code&gt;||&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fc09b29b0e202c3ba1b9de2b8c7b1a00d9fcb394" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;print()&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;chdir()&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。</target>
        </trans-unit>
        <trans-unit id="189e6bb75ad5ffde9c93fb5cd316abd2034296e1" translate="yes" xml:space="preserve">
          <source>If any list operator (&lt;code&gt;print()&lt;/code&gt;, etc.) or any unary operator (&lt;code&gt;chdir()&lt;/code&gt;, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call. For example, because named unary operators are higher precedence than &lt;code&gt;||&lt;/code&gt;:</source>
          <target state="translated">如果任何列表运算符（ &lt;code&gt;print()&lt;/code&gt; 等）或任何一元运算符（ &lt;code&gt;chdir()&lt;/code&gt; 等）后跟左括号作为下一个标记，则括号中的运算符和参数将具有最高优先级，只是就像正常的函数调用一样。例如，由于命名的一元运算符的优先级高于 &lt;code&gt;||&lt;/code&gt; 。：</target>
        </trans-unit>
        <trans-unit id="b227e6f9b5d8d36337845d9688db6eb8efa3551d" translate="yes" xml:space="preserve">
          <source>If any module's own AUTOLOAD subroutine has no need to fallback to the AutoLoader's AUTOLOAD subroutine (because it doesn't have any AutoSplit subroutines), then that module should not use &lt;b&gt;AutoLoader&lt;/b&gt; at all.</source>
          <target state="translated">如果任何模块自己的AUTOLOAD子例程不需要回退到AutoLoader的AUTOLOAD子例程（因为它没有任何AutoSplit子例程），则该模块完全不应使用&lt;b&gt;AutoLoader&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="54f05d2b51008f086be29ce06ad2dc1e36ce0970" translate="yes" xml:space="preserve">
          <source>If any of the alternatives matches, the hash &lt;code&gt;%+&lt;/code&gt; is bound to contain the three key-value pairs.</source>
          <target state="translated">如果任何一个替代项都匹配，则哈希 &lt;code&gt;%+&lt;/code&gt; 绑定为包含三个键值对。</target>
        </trans-unit>
        <trans-unit id="dde2e9ba6df88b543ea738e9014946a615cc8feb" translate="yes" xml:space="preserve">
          <source>If any of the entries in an import list begins with !, : or / then the list is treated as a series of specifications which either add to or delete from the list of names to import. They are processed left to right. Specifications are in the form:</source>
          <target state="translated">如果导入列表中的任何条目以 !、:或/开头,那么该列表将被视为一系列规格,它们要么添加到要导入的名称列表中,要么从列表中删除。它们从左到右进行处理。规格的形式是:</target>
        </trans-unit>
        <trans-unit id="eed3f110a3402c08d6252799be2b5ee0618e62e2" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt;, and you need to remember that &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;stat _&lt;/code&gt;). Example:</source>
          <target state="translated">如果为任何文件测试（或&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt;运算符）提供了特殊的文件句柄（由单独的下划线组成），则使用先前文件测试（或&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;运算符）的stat结构，从而保存系统调用。 （这不适用于 &lt;code&gt;-t&lt;/code&gt; ，您需要记住&lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;-l&lt;/code&gt; 在stat结构中为符号链接而不是实际文件保留值。）（此外，如果stat缓冲区由&lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt;调用填充， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 将使用 &lt;code&gt;stat _&lt;/code&gt; 的结果将其重置。例子：</target>
        </trans-unit>
        <trans-unit id="3fd2433b191431a7e89003ab4a4e523c3a5de0d9" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">如果为任何文件测试（或 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 运算符）提供了特殊的文件句柄（由单独的下划线组成），则使用先前文件测试（或stat运算符）的stat结构，从而保存系统调用。 （这不适用于 &lt;code&gt;-t&lt;/code&gt; ，并且您需要记住lstat（）和 &lt;code&gt;-l&lt;/code&gt; 在stat结构中为符号链接而不是实际文件保留值。）（此外，如果stat缓冲区由一个 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 的结果将其重置。例：</target>
        </trans-unit>
        <trans-unit id="c70d4afb0f7f0b8a4b2bcb0de7d2fe106cb41892" translate="yes" xml:space="preserve">
          <source>If any of the file tests (or either the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; operator) is given the special filehandle consisting of a solitary underline, then the stat structure of the previous file test (or stat operator) is used, saving a system call. (This doesn't work with &lt;code&gt;-t&lt;/code&gt; , and you need to remember that lstat() and &lt;code&gt;-l&lt;/code&gt; leave values in the stat structure for the symbolic link, not the real file.) (Also, if the stat buffer was filled by an &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; will reset it with the results of &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; ). Example:</source>
          <target state="translated">如果为任何文件测试（或 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 运算符）提供了特殊的文件句柄（由单独的下划线组成），则使用先前文件测试（或stat运算符）的stat结构，从而保存系统调用。 （这不适用于 &lt;code&gt;-t&lt;/code&gt; ，并且您需要记住lstat（）和 &lt;code&gt;-l&lt;/code&gt; 在stat结构中为符号链接而不是实际文件保留值。）（此外，如果stat缓冲区由一个 &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 将使用 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt; _&lt;/code&gt; 的结果将其重置。例：</target>
        </trans-unit>
        <trans-unit id="4eae7869337353cadd5cbfe4d84a955fd03cd8ba" translate="yes" xml:space="preserve">
          <source>If any of the given search directories contains a</source>
          <target state="translated">如果任何一个给定的搜索目录包含一个</target>
        </trans-unit>
        <trans-unit id="0865eba790bb7da4cb38d4fafb11a71c0ca93d75" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">如果这三个值中的任何一个为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将不使用该时间值。因此，例如，仅设置 &lt;code&gt;$mtime&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="f9ae80c94036ecc3639a1310fc69fc12fe61781c" translate="yes" xml:space="preserve">
          <source>If any of the three values is &lt;code&gt;undef&lt;/code&gt; that time value will not be used. So, for example, to set only the &lt;code&gt;$mtime&lt;/code&gt; you would use this</source>
          <target state="translated">如果这三个值中的任何一个为 &lt;code&gt;undef&lt;/code&gt; ，则将不使用该时间值。因此，例如，仅设置 &lt;code&gt;$mtime&lt;/code&gt; 您将使用此方法</target>
        </trans-unit>
        <trans-unit id="341a4d7e4dbc9eeb69d34b947d58bc6f15ecb9f2" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;. So don't do that.</source>
          <target state="translated">如果LIST的任何部分是数组，则在循环体内添加或删除元素（例如，使用 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; )时， &lt;code&gt;foreach&lt;/code&gt; 会非常困惑。所以不要那样做。</target>
        </trans-unit>
        <trans-unit id="a6977803bb4132cdee0ca3d69dd5582749d63459" translate="yes" xml:space="preserve">
          <source>If any part of LIST is an array, &lt;code&gt;foreach&lt;/code&gt; will get very confused if you add or remove elements within the loop body, for example with &lt;code&gt;splice&lt;/code&gt;. So don't do that.</source>
          <target state="translated">如果LIST的任何部分是数组，则在循环体内添加或删除元素（例如，使用 &lt;code&gt;splice&lt;/code&gt; )时， &lt;code&gt;foreach&lt;/code&gt; 会非常困惑。所以不要那样做。</target>
        </trans-unit>
        <trans-unit id="31cf9c709860eea50a338d60ff5edf1e2478723c" translate="yes" xml:space="preserve">
          <source>If applicable, please include details on what the user should do to correct the error; documenting an error as indicating &quot;the input buffer is too small&quot; without telling the user how to increase the size of the input buffer (or at least telling them that it isn't possible) aren't very useful.</source>
          <target state="translated">如果适用,请包括用户应该如何纠正错误的细节;将错误记录为表明 &quot;输入缓冲区太小&quot;,而不告诉用户如何增加输入缓冲区的大小(或至少告诉他们这是不可能的),这不是很有用。</target>
        </trans-unit>
        <trans-unit id="17ebb7f065dcd7d1005a6e70cd7fc9ddab662a16" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">如果指定了参数，则它是关于要包含在历史记录中的最小行大小的建议。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 表示不将任何内容纳入历史记录。返回旧值。</target>
        </trans-unit>
        <trans-unit id="558be544e424e324e7828785f1d0946baec4a52b" translate="yes" xml:space="preserve">
          <source>If argument is specified, it is an advice on minimal size of line to be included into history. &lt;code&gt;undef&lt;/code&gt; means do not include anything into history. Returns the old value.</source>
          <target state="translated">如果指定了参数，则它是关于要包含在历史记录中的最小行大小的建议。 &lt;code&gt;undef&lt;/code&gt; 表示不将任何内容包含在历史记录中。返回旧值。</target>
        </trans-unit>
        <trans-unit id="2dfd62fe55f271b39c6841425a803e9153fccfd7" translate="yes" xml:space="preserve">
          <source>If at least one handle is ready for the specified kind of operation, the result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon timeout, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; unchanged. Upon error, an empty list is returned, with &lt;code&gt;$!&lt;/code&gt; set to indicate the error. To distinguish between timeout and error, set &lt;code&gt;$!&lt;/code&gt; to zero before calling this method, and check it after an empty list is returned.</source>
          <target state="translated">如果至少有一个句柄准备好用于指定种类的操作，则结果将是一个由3个元素组成的数组，每个元素引用一个数组，该数组将保存分别准备好进行读取，写入和具有异常处理的句柄。超时后，将返回一个空列表，并带有 &lt;code&gt;$!&lt;/code&gt; 不变。出现错误时，将返回一个空列表，并带有 &lt;code&gt;$!&lt;/code&gt; 设置以指示错误。要区分超时和错误，请设置 &lt;code&gt;$!&lt;/code&gt; 为零，然后再调用此方法，并在返回空列表后进行检查。</target>
        </trans-unit>
        <trans-unit id="84097126d5165e3f6c46b39868c8cad17c6bb873" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls &lt;b&gt;under&lt;/b&gt; 5.6 is important, one must write instead a &lt;code&gt;use vars&lt;/code&gt; statement.</source>
          <target state="translated">如果皮尔斯向后兼容性&lt;b&gt;下&lt;/b&gt;5.6是非常重要的，一个人必须写，而不是 &lt;code&gt;use vars&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="fd699eb48fd240fe4a2bcf57e3a3520a6ee8d6f2" translate="yes" xml:space="preserve">
          <source>If backward compatibility for Perls under 5.6 is important, one must write instead a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; statement.</source>
          <target state="translated">如果对5.6以下的Perls的向后兼容性很重要，则必须改写 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="b7d0b9799b974e77c25f857fd60005fd09516395" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">如果bits为4或更少，则将字符串拆分为字节，然后将每个字节的位拆分为8 / BITS组。一个字节的位进行编号，在小尾数十岁上下的方式，为 &lt;code&gt;0x01&lt;/code&gt; ， &lt;code&gt;0x02&lt;/code&gt; ， &lt;code&gt;0x04&lt;/code&gt; ， &lt;code&gt;0x08&lt;/code&gt; ， &lt;code&gt;0x10&lt;/code&gt; ， &lt;code&gt;0x20&lt;/code&gt; ， &lt;code&gt;0x40&lt;/code&gt; 的， &lt;code&gt;0x80&lt;/code&gt; 的。例如，将单个输入字节 &lt;code&gt;&lt;a href=&quot;chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 分成两组，得到一个列表 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ；将其分为4组将得到 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77d4537f5763ddf89d58388ac5f77f55fec21e75" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt; , &lt;code&gt;0x02&lt;/code&gt; , &lt;code&gt;0x04&lt;/code&gt; , &lt;code&gt;0x08&lt;/code&gt; , &lt;code&gt;0x10&lt;/code&gt; , &lt;code&gt;0x20&lt;/code&gt; , &lt;code&gt;0x40&lt;/code&gt; , &lt;code&gt;0x80&lt;/code&gt; . For example, breaking the single input byte &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; .</source>
          <target state="translated">如果bits为4或更少，则将字符串拆分为字节，然后将每个字节的位拆分为8 / BITS组。一个字节的位进行编号，在小尾数十岁上下的方式，为 &lt;code&gt;0x01&lt;/code&gt; ， &lt;code&gt;0x02&lt;/code&gt; ， &lt;code&gt;0x04&lt;/code&gt; ， &lt;code&gt;0x08&lt;/code&gt; ， &lt;code&gt;0x10&lt;/code&gt; ， &lt;code&gt;0x20&lt;/code&gt; ， &lt;code&gt;0x40&lt;/code&gt; 的， &lt;code&gt;0x80&lt;/code&gt; 的。例如，将单个输入字节 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0x36)&lt;/a&gt;&lt;/code&gt; 分成两组，得到一个列表 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ；将其分为4组将得到 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0fce82eab0f0647014ec432d0b3fa1af89e83a3" translate="yes" xml:space="preserve">
          <source>If bits is 4 or less, the string is broken into bytes, then the bits of each byte are broken into 8/BITS groups. Bits of a byte are numbered in a little-endian-ish way, as in &lt;code&gt;0x01&lt;/code&gt;, &lt;code&gt;0x02&lt;/code&gt;, &lt;code&gt;0x04&lt;/code&gt;, &lt;code&gt;0x08&lt;/code&gt;, &lt;code&gt;0x10&lt;/code&gt;, &lt;code&gt;0x20&lt;/code&gt;, &lt;code&gt;0x40&lt;/code&gt;, &lt;code&gt;0x80&lt;/code&gt;. For example, breaking the single input byte &lt;code&gt;chr(0x36)&lt;/code&gt; into two groups gives a list &lt;code&gt;(0x6, 0x3)&lt;/code&gt;; breaking it into 4 groups gives &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt;.</source>
          <target state="translated">如果bits为4或更少，则将字符串拆分为字节，然后将每个字节的bits拆分为8 / BITS组。一个字节的位进行编号，在小尾数十岁上下的方式，为 &lt;code&gt;0x01&lt;/code&gt; ， &lt;code&gt;0x02&lt;/code&gt; ， &lt;code&gt;0x04&lt;/code&gt; ， &lt;code&gt;0x08&lt;/code&gt; ， &lt;code&gt;0x10&lt;/code&gt; ， &lt;code&gt;0x20&lt;/code&gt; ， &lt;code&gt;0x40&lt;/code&gt; 的， &lt;code&gt;0x80&lt;/code&gt; 的。例如，将单个输入字节 &lt;code&gt;chr(0x36)&lt;/code&gt; 分成两组，得到一个列表 &lt;code&gt;(0x6, 0x3)&lt;/code&gt; ；将其分为4组将得到 &lt;code&gt;(0x2, 0x1, 0x3, 0x0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf0f5d848a9043e820336aaa7c2b5b535010685b" translate="yes" xml:space="preserve">
          <source>If both arguments to &lt;code&gt;copy&lt;/code&gt; are not file handles, then &lt;code&gt;copy&lt;/code&gt; will perform a &quot;system copy&quot; of the input file to a new output file, in order to preserve file attributes, indexed file structure,</source>
          <target state="translated">如果要 &lt;code&gt;copy&lt;/code&gt; 两个参数都不是文件句柄，那么 &lt;code&gt;copy&lt;/code&gt; 将对输入文件执行&amp;ldquo;系统复制&amp;rdquo;到新的输出文件，以保留文件属性，索引文件结构，</target>
        </trans-unit>
        <trans-unit id="e9104a77e501731bf3173e5f8cc7012527cca560" translate="yes" xml:space="preserve">
          <source>If both the SIGNAL and the PROCESS are negative, the results are undefined. A warning may be produced in a future version.</source>
          <target state="translated">如果SIGNAL和PROCESS都是负数,则结果未定义。在未来的版本中可能会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="43c2b718c80fc2756eb63ba9991217396d36da72" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt; ), the left column contains both forms, with and without braces.</source>
          <target state="translated">如果不需要大括号来指定属性（例如 &lt;code&gt;\pL&lt;/code&gt; ），则左列包含两种形式，带和不带大括号。</target>
        </trans-unit>
        <trans-unit id="8260701f533c58633eabb2e152bfb995da51c762" translate="yes" xml:space="preserve">
          <source>If braces are not needed to specify a property (e.g., &lt;code&gt;\pL&lt;/code&gt;), the left column contains both forms, with and without braces.</source>
          <target state="translated">如果不需要大括号来指定属性（例如 &lt;code&gt;\pL&lt;/code&gt; ），则左列包含两种形式，带和不带大括号。</target>
        </trans-unit>
        <trans-unit id="0a4169e83148646605b11ff599e0ccd6579a7d78" translate="yes" xml:space="preserve">
          <source>If branches are involved (ie. $Revision: 1.5.3.4$) it's a little more complicated.</source>
          <target state="translated">如果涉及到分支(例如:$Revision:1.5.3.4$),那就比较复杂了。</target>
        </trans-unit>
        <trans-unit id="2c0abc37f0d263edf159adfc0dd160a4e923f046" translate="yes" xml:space="preserve">
          <source>If building completes successfully, you can set up smoke testing as described in the Test::Smoke documentation.</source>
          <target state="translated">如果构建成功,就可以按照 Test::Smoke 文档中的描述设置烟雾测试。</target>
        </trans-unit>
        <trans-unit id="2c319407a62fb715df8d4d26f7931f9374106237" translate="yes" xml:space="preserve">
          <source>If building natively on PASE, please do the build under the /QOpenSys directory, since Perl is happier when built on a case sensitive filesystem.</source>
          <target state="translated">如果在PASE上原生构建,请在/QOpenSys目录下进行构建,因为Perl在大小写敏感的文件系统上构建会更快乐。</target>
        </trans-unit>
        <trans-unit id="973afa89149c95161585621016fbc1be5e704a2e" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.org you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">如果使用mingw-w64.org提供的交叉编译器,你需要取消makefile.mk中设置GCCCROSS的那一行。只有在使用交叉编译器的情况下才需要这样做--也就是说,只有在bin文件夹中没有gcc.exe的情况下才需要这样做(交叉编译器不提供gcc.exe、g++.exe、ar.exe等。相反,所有这些可执行文件的前缀都是'x86_64-w64-mingw32-')。)</target>
        </trans-unit>
        <trans-unit id="2edb493675bf68411bac8372236ccf07c63ce62d" translate="yes" xml:space="preserve">
          <source>If building with the cross-compiler provided by mingw-w64.sourceforge.net you'll need to uncomment the line that sets GCCCROSS in the makefile.mk. Do this only if it's the cross-compiler - ie only if the bin folder doesn't contain a gcc.exe. (The cross-compiler does not provide a gcc.exe, g++.exe, ar.exe, etc. Instead, all of these executables are prefixed with 'x86_64-w64-mingw32-'.)</source>
          <target state="translated">如果使用mingw-w64.sourceforge.net提供的交叉编译器,你需要取消makefile.mk中设置GCCCROSS的那一行。只有在交叉编译器的情况下才需要这样做--即只有在bin文件夹中没有gcc.exe的情况下才需要这样做(交叉编译器不提供gcc.exe、g++.exe、ar.exe等。相反,所有这些可执行文件的前缀都是'x86_64-w64-mingw32-')。)</target>
        </trans-unit>
        <trans-unit id="9e17d613e1404f153f1b0ce16d928004818ba4b8" translate="yes" xml:space="preserve">
          <source>If by daemon process you mean one that's detached (disassociated from its tty), then the following process is reported to work on most Unixish systems. Non-Unix users should check their Your_OS::Process module for other solutions.</source>
          <target state="translated">如果你所说的守护进程是指一个分离的进程 (与它的 tty 脱钩),那么下面的进程据说可以在大多数 Unix 系统上工作。非Unix用户应该检查他们的Your_OS::Process模块以获得其他解决方案。</target>
        </trans-unit>
        <trans-unit id="f14156857ddead4c835ba55e44d3f79ccfb246a2" translate="yes" xml:space="preserve">
          <source>If by some reasons</source>
          <target state="translated">如果由于某些原因</target>
        </trans-unit>
        <trans-unit id="85a1911ef5d789d9bb6809a0f2c6b323a8f5cec0" translate="yes" xml:space="preserve">
          <source>If callbacks are used, they will be issued before this call returns.</source>
          <target state="translated">如果使用了回调,它们将在这个调用返回之前发出。</target>
        </trans-unit>
        <trans-unit id="313e870db9c5d448dca42a14416b5684a916e7ce" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set, calls get magic.</source>
          <target state="translated">如果调用 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 或将标志设置为 &lt;code&gt;SV_GMAGIC&lt;/code&gt; ，则调用会变魔术。</target>
        </trans-unit>
        <trans-unit id="706aad3a29650f166c943e5c886b39dcd0a4394e" translate="yes" xml:space="preserve">
          <source>If called as &lt;code&gt;sv_vcatpvfn&lt;/code&gt; or flags include &lt;code&gt;SV_GMAGIC&lt;/code&gt; , calls get magic.</source>
          <target state="translated">如果称为 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 或标志包含 &lt;code&gt;SV_GMAGIC&lt;/code&gt; ，则调用会变得神奇。</target>
        </trans-unit>
        <trans-unit id="614a0f52f1c33eb959730f1d5d32f8786b9d57d8" translate="yes" xml:space="preserve">
          <source>If called as an instance method (i.e. $md5-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case.</source>
          <target state="translated">如果作为实例方法（即$ md5-&amp;gt; new）调用，它将仅将对象的状态重置为新创建的对象的状态。在这种情况下，不会创建新对象。</target>
        </trans-unit>
        <trans-unit id="9eff0140ef6933e6b5cb7ac53c50b2609e62aacb" translate="yes" xml:space="preserve">
          <source>If called as an instance method, the value is assigned to the invocand.</source>
          <target state="translated">如果作为实例方法调用,则将值分配给调用者。</target>
        </trans-unit>
        <trans-unit id="8679ce9e8862eb205bcd677039372fd6e97a03da" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用并且全局变量 &lt;code&gt;$INSTANCES&lt;/code&gt; 为真值，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到则返回空列表。</target>
        </trans-unit>
        <trans-unit id="df3b5a11aab4c086bd9cac6e1ddae966355312d8" translate="yes" xml:space="preserve">
          <source>If called in a list context and the global variable &lt;code&gt;$INSTANCES&lt;/code&gt; is a true value, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用并且全局变量 &lt;code&gt;$INSTANCES&lt;/code&gt; 为真值，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到则返回空列表。</target>
        </trans-unit>
        <trans-unit id="b8293e343dafdb403ea7c5d5ddbde243205b61a6" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt; , or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="f5370268c560e6f64c9874ef2c0fc0f892b2ca25" translate="yes" xml:space="preserve">
          <source>If called in a list context, it will return a list of the full paths to instances of the binary where found in &lt;code&gt;PATH&lt;/code&gt;, or an empty list if it was not found.</source>
          <target state="translated">如果在列表上下文中调用，它将返回在 &lt;code&gt;PATH&lt;/code&gt; 中找到的二进制实例的完整路径的列表，如果未找到，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="522ffa67a9fbac5fe032f13cc8e4e97e4f0b245b" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it was not.</source>
          <target state="translated">如果在标量上下文中调用，它将返回您要求的二进制文件的完整路径，如果找不到，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8320f2054497a9bae0f18de5b046bd415cc37b89" translate="yes" xml:space="preserve">
          <source>If called in a scalar context it will return the full path to the binary you asked for if it was found, or &lt;code&gt;undef&lt;/code&gt; if it was not.</source>
          <target state="translated">如果在标量上下文中调用，它将返回您要求的二进制文件的完整路径（如果未找到），或者返回 &lt;code&gt;undef&lt;/code&gt; (如果未找到）。</target>
        </trans-unit>
        <trans-unit id="95f63f3ffa5199ae8cbe82545b9235a06bf20e5c" translate="yes" xml:space="preserve">
          <source>If called in a scalar context, &lt;code&gt;getsym&lt;/code&gt; returns the value of the symbol whose name is given as the argument to the call, or &lt;code&gt;undef&lt;/code&gt; if no such symbol exists. Symbols in the local symbol table are always used in preference to symbols in the global symbol table. If called in a list context, &lt;code&gt;getsym&lt;/code&gt; returns a two-element list, whose first element is the value of the symbol, and whose second element is the string 'GLOBAL' or 'LOCAL', indicating the table from which the symbol's value was read.</source>
          <target state="translated">如果在标量上下文中调用， &lt;code&gt;getsym&lt;/code&gt; 返回其名称作为调用参数给出的符号的值，如果不存在此类符号，则返回 &lt;code&gt;undef&lt;/code&gt; 。本地符号表中的符号始终优先于全局符号表中的符号使用。如果在列表上下文中调用， &lt;code&gt;getsym&lt;/code&gt; 将返回一个由两个元素组成的列表，该列表的第一个元素是符号的值，第二个元素是字符串&amp;ldquo; GLOBAL&amp;rdquo;或&amp;ldquo; LOCAL&amp;rdquo;，指示从中读取符号值的表。</target>
        </trans-unit>
        <trans-unit id="b5dcbe2314e7e7c1c4c1bcc0ca660c9625dfb9c3" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the &lt;code&gt;O_TEMPORARY&lt;/code&gt; flag) the file is marked for deletion when the program ends (equivalent to setting UNLINK to 1). The &lt;code&gt;UNLINK&lt;/code&gt; flag is ignored if present.</source>
          <target state="translated">如果在标量上下文中调用，则仅返回文件句柄，并且在支持该文件的操作系统上关闭该文件句柄时，该文件将被自动删除（请参见本文档其他地方对tmpfile（）的描述）。这是首选的操作模式，就好像您只有一个文件句柄一样，您永远无法通过摸索文件名来创建竞争条件。在 &lt;code&gt;O_TEMPORARY&lt;/code&gt; 链接打开的文件或不能在打开文件时将其标记为临时文件的系统上（例如，Windows NT使用O_TEMPORARY标志），该文件在程序结束时被标记为删除（相当于将UNLINK设置为1）。 。该 &lt;code&gt;UNLINK&lt;/code&gt; 如果存在标志被忽略。</target>
        </trans-unit>
        <trans-unit id="5e86b593d758e5e3c8998823e4b17f5dfdc961bc" translate="yes" xml:space="preserve">
          <source>If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of tmpfile() elsewhere in this document). This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the C</source>
          <target state="translated">如果在标量上下文中调用,则只返回文件柄,并且在支持此功能的操作系统上,文件将在关闭时自动删除(参见本文档其他地方对tmpfile()的描述)。这是首选的操作模式,因为如果你只有一个文件柄,你就永远无法通过摸索文件名来创造一个竞赛条件。在不能解开已打开的文件的链接或不能在打开文件时将其标记为临时文件的系统中(例如,Windows NT 使用 C</target>
        </trans-unit>
        <trans-unit id="2926650808a88d22bd30c27717549af3be1de564" translate="yes" xml:space="preserve">
          <source>If called when &lt;code&gt;use utf8&lt;/code&gt; is in effect, the string will be assumed to be encoded in UTF-8, and &lt;code&gt;evalbytes&lt;/code&gt; will make a temporary copy to work from, downgraded to non-UTF-8. If this is not possible (because one or more characters in it require UTF-8), the &lt;code&gt;evalbytes&lt;/code&gt; will fail with the error stored in &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;use utf8&lt;/code&gt; 生效时调用了该字符串，则该字符串将被假定为以UTF-8编码，而 &lt;code&gt;evalbytes&lt;/code&gt; 将成为一个临时副本以供使用，并将其降级为非UTF-8。如果这不可能（因为其中一个或多个字符需要UTF-8），则 &lt;code&gt;evalbytes&lt;/code&gt; 将失败，并在 &lt;code&gt;$@&lt;/code&gt; 存储错误。</target>
        </trans-unit>
        <trans-unit id="c83187abf3e8e59deed13ec45be5007e63c321fb" translate="yes" xml:space="preserve">
          <source>If called with a property that doesn't have synonyms for its values, it returns the input value, possibly normalized with capitalization and underscores, but not necessarily checking that the input value is valid.</source>
          <target state="translated">如果用一个没有同义词的属性调用它的值,它就会返回输入值,可能会用大写和下划线规范化,但不一定会检查输入值是否有效。</target>
        </trans-unit>
        <trans-unit id="abcbf5b218ac08698c7495d3bca85cf2f5fc593a" translate="yes" xml:space="preserve">
          <source>If called with an argument &lt;code&gt;blocking&lt;/code&gt; will turn on non-blocking IO if &lt;code&gt;BOOL&lt;/code&gt; is false, and turn it off if &lt;code&gt;BOOL&lt;/code&gt; is true.</source>
          <target state="translated">如果有一个参数叫做 &lt;code&gt;blocking&lt;/code&gt; 会打开非阻塞IO如果 &lt;code&gt;BOOL&lt;/code&gt; 是假的，并关闭它，如果 &lt;code&gt;BOOL&lt;/code&gt; 是真实的。</target>
        </trans-unit>
        <trans-unit id="cd8fbca057a7b0f8546bef2e8eba78cd01155b5c" translate="yes" xml:space="preserve">
          <source>If called with an argument the &lt;code&gt;list&lt;/code&gt; returns the size of the message in octets.</source>
          <target state="translated">如果使用参数调用， &lt;code&gt;list&lt;/code&gt; 将以八位字节为单位返回消息的大小。</target>
        </trans-unit>
        <trans-unit id="d3101b42b801bc480044d4583af8814cf3a6fda1" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt; 's of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">如果不带参数调用，则返回对哈希的引用。密钥将是所有未删除消息的 &lt;code&gt;MSGNUM&lt;/code&gt; ，其值将是它们的大小（以八位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="9173f9598d9b0aafc765ff35df05afedacca6dc3" translate="yes" xml:space="preserve">
          <source>If called without arguments a reference to a hash is returned. The keys will be the &lt;code&gt;MSGNUM&lt;/code&gt;'s of all undeleted messages and the values will be their size in octets.</source>
          <target state="translated">如果不带参数调用，则返回对哈希的引用。密钥将是所有未删除消息的 &lt;code&gt;MSGNUM&lt;/code&gt; ，其值将是它们的大小（以八位字节为单位）。</target>
        </trans-unit>
        <trans-unit id="048702f1da8ec8b9e869f3d2d0c04bad9a57c4d8" translate="yes" xml:space="preserve">
          <source>If can not unlink open file, defer removal until later available since 0.06.</source>
          <target state="translated">如果不能解除打开的文件的链接,推迟到0.06以后可用。</target>
        </trans-unit>
        <trans-unit id="e77963c1065ed922557c941a37ed57186c92ec48" translate="yes" xml:space="preserve">
          <source>If capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such</source>
          <target state="translated">如果在正则表达式中使用了捕捉小括号,我们可以引用源字符串中被匹配的部分,并匹配出完全相同的东西。有三种方式可以引用这样的</target>
        </trans-unit>
        <trans-unit id="ca37e501b1a5684a1fb419774ed5fda0c1e909b2" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; (&lt;code&gt;-Accflags=-DPERL_MEM_LOG&lt;/code&gt;), both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">如果使用 &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; （ &lt;code&gt;-Accflags=-DPERL_MEM_LOG&lt;/code&gt; ）进行编译，则内存和SV分配都会通过日志记录功能，这对于设置断点非常方便。</target>
        </trans-unit>
        <trans-unit id="8ef19162a844967deef3f5d85d04764641f71041" translate="yes" xml:space="preserve">
          <source>If compiled with &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; , both memory and SV allocations go through logging functions, which is handy for breakpoint setting.</source>
          <target state="translated">如果使用 &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 进行编译，则内存和SV分配都会通过日志记录功能，这对于设置断点非常方便。</target>
        </trans-unit>
        <trans-unit id="505c257963541e6d1081b0bfdec05dc2d7991e03" translate="yes" xml:space="preserve">
          <source>If constant folding was not performed, the execution-order thread is created.</source>
          <target state="translated">如果没有进行恒定的折叠,则创建执行顺序线程。</target>
        </trans-unit>
        <trans-unit id="9c0592ae26e8bb261300ebbed2b588cacc05e4ff" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable can be used to modify the environment on the target system. However, how and where it's used, and even if it's used at all, is entirely dependent on both the transport mechanism (targetrun) and what the target system is. Unless the relevant documentation says otherwise, it is genereally not useful.</source>
          <target state="translated">如果是交叉编译,这个变量可以用来修改目标系统上的环境,但是,如何使用,在哪里使用,甚至是否使用,完全取决于传输机制(targetrun)和目标系统是什么。然而,如何使用它,在哪里使用它,甚至是否使用它,完全取决于传输机制(targetrun)和目标系统是什么。除非相关文档中另有说明,否则它基本没有用处。</target>
        </trans-unit>
        <trans-unit id="c66c617b16e576e77dc9dc8e186d44f33fe447f3" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the location of sh on the target system. If not, this will be the same as $sh.</source>
          <target state="translated">如果是交叉编译,这个变量包含sh在目标系统中的位置。如果不交叉编译,则与$sh的位置相同。</target>
        </trans-unit>
        <trans-unit id="60357fb3a62a70cdf0b8804a617b55fe7b82dc59" translate="yes" xml:space="preserve">
          <source>If cross-compiling, this variable contains the target architecture. If not, this will be empty.</source>
          <target state="translated">如果交叉编译,这个变量包含目标架构。如果不是,这个变量将是空的。</target>
        </trans-unit>
        <trans-unit id="e5ce981aa84829db1548a6d11516c6b5fa9cbc60" translate="yes" xml:space="preserve">
          <source>If d_procselfexe is defined, $procselfexe is the filename of the symbolic link pointing to the absolute pathname of the executing program.</source>
          <target state="translated">如果定义了d_procselfexe,$procselfexe是指向执行程序绝对路径名的符号链接的文件名。</target>
        </trans-unit>
        <trans-unit id="dc4c096ee5da0f37bd52c68590795a5281826f8c" translate="yes" xml:space="preserve">
          <source>If declared at the outermost scope (the file scope), then lexicals work somewhat like C's file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.</source>
          <target state="translated">如果声明在最外层的作用域(文件作用域),那么词法的工作原理有点像C语言的文件静态。它们对在它们下面声明的同一个文件中的所有函数都是可用的,但从该文件之外是无法访问的。这种策略有时在模块中被用来创建整个模块都能看到的私有变量。</target>
        </trans-unit>
        <trans-unit id="145d6c1efc9692f7f88fb5f7ebc95c113e29dc12" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. If not specified it defaults to &lt;code&gt;1&lt;/code&gt; (blocking mode).</source>
          <target state="translated">如果已定义但为false，则套接字将设置为非阻塞模式。如果未指定，则默认为 &lt;code&gt;1&lt;/code&gt; （阻止模式）。</target>
        </trans-unit>
        <trans-unit id="9038caa549899b94401a0838d72ace7d4bde5fe6" translate="yes" xml:space="preserve">
          <source>If defined but false, the socket will be set to non-blocking mode. Otherwise it will default to blocking mode. See the NON-BLOCKING section below for more detail.</source>
          <target state="translated">如果定义为false,则套接字将被设置为非阻塞模式,否则将默认为阻塞模式。否则它将默认为阻塞模式。更多细节请参见下面的NON-BLOCKING部分。</target>
        </trans-unit>
        <trans-unit id="6ae3059e06d397630c09d4c165cce518cf89f33b" translate="yes" xml:space="preserve">
          <source>If defined specifies whether color output is desired. If &lt;code&gt;color&lt;/code&gt; is not defined it will default to color output if color support is available on the current platform and output is not being redirected.</source>
          <target state="translated">如果定义，则指定是否需要颜色输出。如果 &lt;code&gt;color&lt;/code&gt; 没有定义，则默认为彩色输出，如果颜色支持可在当前平台上和输出没有被重定向。</target>
        </trans-unit>
        <trans-unit id="f94a897ccd9f764c01b106a5cdfcd1ac35d63b36" translate="yes" xml:space="preserve">
          <source>If defined, gives a maximum time in seconds to block per &lt;code&gt;connect()&lt;/code&gt; call when in blocking mode. If missing, no timeout is applied other than that provided by the underlying operating system. When in non-blocking mode this parameter is ignored.</source>
          <target state="translated">如果定义，则在阻塞模式下以秒为单位给出最长时间来阻塞每个 &lt;code&gt;connect()&lt;/code&gt; 调用。如果丢失，则除了基础操作系统提供的超时外，不会应用任何超时。在非阻塞模式下，此参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="2f028cf73562b9d54628306ef212e57f51c8b344" translate="yes" xml:space="preserve">
          <source>If defined, puts the socket into listening mode where new connections can be accepted using the &lt;code&gt;accept&lt;/code&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="translated">如果已定义，则将套接字置于侦听模式，在该模式下可以使用 &lt;code&gt;accept&lt;/code&gt; 方法接受新的连接。给定的值用作 &lt;code&gt;listen(2)&lt;/code&gt; 队列大小。</target>
        </trans-unit>
        <trans-unit id="e020a19c9382a48776779d2ba22b74e383d938da" translate="yes" xml:space="preserve">
          <source>If defined, set the &lt;code&gt;IPV6_V6ONLY&lt;/code&gt; sockopt when creating &lt;code&gt;PF_INET6&lt;/code&gt; sockets to the given value. If true, a listening-mode socket will only listen on the &lt;code&gt;AF_INET6&lt;/code&gt; addresses; if false it will also accept connections from &lt;code&gt;AF_INET&lt;/code&gt; addresses.</source>
          <target state="translated">如果已定义，则在创建 &lt;code&gt;PF_INET6&lt;/code&gt; 套接字时将 &lt;code&gt;IPV6_V6ONLY&lt;/code&gt; sockopt设置为给定值。如果为true，则侦听模式套接字将仅侦听 &lt;code&gt;AF_INET6&lt;/code&gt; 地址；否则，侦听模式套接字将仅侦听AF_INET6地址。如果为false，它还将接受来自 &lt;code&gt;AF_INET&lt;/code&gt; 地址的连接。</target>
        </trans-unit>
        <trans-unit id="dc3bd5a9c7fbd30c1f819a008f41219b5c451f73" translate="yes" xml:space="preserve">
          <source>If desired, an optional hash-ref may be specified as the first argument to customize certain aspects of the parse-tree that is created and returned. The set of recognized option keywords are:</source>
          <target state="translated">如果需要,可以指定一个可选的hash-ref作为第一个参数,以自定义创建和返回的解析树的某些方面。一组公认的选项关键字是:</target>
        </trans-unit>
        <trans-unit id="c417457bb41c44d12dd8e05efc098db997c407b3" translate="yes" xml:space="preserve">
          <source>If developing modules for private internal or project specific use, that will never be released to the public, then you should ensure that their names will not clash with any future public module. You can do this either by using the reserved Local::* category or by using a category name that includes an underscore like Foo_Corp::*.</source>
          <target state="translated">如果开发的模块是供内部或项目特定使用的,并且永远不会向公众发布,那么你应该确保它们的名字不会与任何未来的公共模块冲突。你可以通过使用保留的 Local::*类别或者使用一个包含下划线的类别名称,比如 Foo_Corp::*。</target>
        </trans-unit>
        <trans-unit id="1bf0d1f77248c2c58d4104ac428f32e38cbba679" translate="yes" xml:space="preserve">
          <source>If either (or both!) is a subroutine reference, it is run and used as the value for comparing. For example:</source>
          <target state="translated">如果其中一个(或两个!)是子程序引用,则运行它并作为比较的值。例如</target>
        </trans-unit>
        <trans-unit id="28e0eb14814bacb4c751344661d230f561ecbcda" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;LocalHost&lt;/code&gt; or &lt;code&gt;PeerHost&lt;/code&gt; (or their &lt;code&gt;...Addr&lt;/code&gt; synonyms) have any of the following special forms then special parsing is applied.</source>
          <target state="translated">如果 &lt;code&gt;LocalHost&lt;/code&gt; 或 &lt;code&gt;PeerHost&lt;/code&gt; （或它们的 &lt;code&gt;...Addr&lt;/code&gt; 同义词）具有以下任何特殊形式，则将应用特殊解析。</target>
        </trans-unit>
        <trans-unit id="0201c4d3bcdfd14f6a2e27e712be0d303b850c91" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果其中一个名称未知，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。请注意，Perl通常会在正则表达式中以前缀名称（例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; ）为前缀的可选 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）来识别属性名称。此函数无法识别属性参数中的那些，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2293e2a6915536d356b477a7689ee15921487cbe" translate="yes" xml:space="preserve">
          <source>If either name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果其中一个名称未知，则返回 &lt;code&gt;undef&lt;/code&gt; 。请注意，Perl通常在正则表达式中以前缀可选的 &lt;code&gt;&quot;Is_&lt;/code&gt; _&amp;rdquo;（带或不带下划线）的方式识别正则表达式中的属性名称，例如 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; 。此函数无法识别属性参数中的那些，返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3926f5454427802efbe3e6cffcb07732270c9a24" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt; ) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">如果标量 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 任何一个操作数是一个常量表达式，则该操作数如果等于（ &lt;code&gt;==&lt;/code&gt; ）当前输入行号（ &lt;code&gt;$.&lt;/code&gt; 变量），则认为该操作数为true 。</target>
        </trans-unit>
        <trans-unit id="5ec204ca8034e3ccafb322d0a50a88db1356b7fd" translate="yes" xml:space="preserve">
          <source>If either operand of scalar &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a constant expression, that operand is considered true if it is equal (&lt;code&gt;==&lt;/code&gt;) to the current input line number (the &lt;code&gt;$.&lt;/code&gt; variable).</source>
          <target state="translated">如果标量 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 任何一个操作数都是一个常量表达式，则该操作数如果等于（ &lt;code&gt;==&lt;/code&gt; ）当前输入行号（ &lt;code&gt;$.&lt;/code&gt; 变量），则认为该操作数为true 。</target>
        </trans-unit>
        <trans-unit id="f2cb5b8cc9c4debb5e9c1cd9b0aff54bfa3a6950" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the empty string or undefined, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">如果reader或writer是空字符串或未定义,这将被一个自动生成的filehandle代替。如果是这样,你必须在参数槽中传递一个有效的lvalue,这样它就可以在调用程序中被覆盖,否则会引发异常。</target>
        </trans-unit>
        <trans-unit id="f99b132bd00ba92228931c93b4096f125672ade0" translate="yes" xml:space="preserve">
          <source>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</source>
          <target state="translated">如果reader或writer是空字符串,将被一个自动生成的filehandle替换。如果是这样,你必须在参数槽中传递一个有效的lvalue,这样它就可以在调用者中被覆盖,否则会引发异常。</target>
        </trans-unit>
        <trans-unit id="c51794930a0cb952da1b5da2c73c8a1455bd1093" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">如果在脚本中检测到嵌入式文档（以pod格式，请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;），则 &lt;code&gt;--help&lt;/code&gt; 还将显示如何访问文档。</target>
        </trans-unit>
        <trans-unit id="497536c61f20254b3ce1e548c2f1737e3ae2f43e" translate="yes" xml:space="preserve">
          <source>If embedded documentation (in pod format, see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) is detected in the script, &lt;code&gt;--help&lt;/code&gt; will also show how to access the documentation.</source>
          <target state="translated">如果在脚本中检测到嵌入式文档（以pod格式，请参见&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;），则 &lt;code&gt;--help&lt;/code&gt; 还将显示如何访问文档。</target>
        </trans-unit>
        <trans-unit id="69dc58793e20f2f8fe02b29cbd122e892cc2714a" translate="yes" xml:space="preserve">
          <source>If empty is false, mark gv with GVf_INTRO so the next reference assigned is localized, which is how &lt;code&gt; local *foo = $someref; &lt;/code&gt; works.</source>
          <target state="translated">如果empty为false，则用GVf_INTRO标记gv，以便对下一个引用进行本地化，这就是 &lt;code&gt; local *foo = $someref; &lt;/code&gt; 作品。</target>
        </trans-unit>
        <trans-unit id="d0235b3841ba3dad5d7f48423a5cbad1433ac050" translate="yes" xml:space="preserve">
          <source>If empty is true, replace the GP with a new GP.</source>
          <target state="translated">如果空为真,则用新的GP替换GP。</target>
        </trans-unit>
        <trans-unit id="29d066b26000935ae7bb2e10a40ebaebacd4b8b0" translate="yes" xml:space="preserve">
          <source>If enabled, case is ignored when matching option names. If, however, bundling is enabled as well, single character options will be treated case-sensitive.</source>
          <target state="translated">如果启用,在匹配选项名时将忽略大小写。但如果也启用了捆绑功能,单字符选项将被区分大小写。</target>
        </trans-unit>
        <trans-unit id="db7040756e9968d1786c608e978b27880a9b3f0b" translate="yes" xml:space="preserve">
          <source>If everything else fails, you need to build a stand-alone DLL for perl. Contact me, I did it once. Sockets would not work, as a lot of other stuff.</source>
          <target state="translated">如果其他一切都失败了,你需要为perl建立一个独立的DLL。联系我,我做过一次。套接字就不行了,其他很多东西也不行。</target>
        </trans-unit>
        <trans-unit id="86e67737b28b03a977f15c49feac3a8313e09ab0" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">如果您感兴趣的只是异常处理，请使用许多处理异常的CPAN模块之一，例如&lt;a href=&quot;Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3a7b09ae5de32a801bf3504292c1ba7f8a26bf8f" translate="yes" xml:space="preserve">
          <source>If exception handling is all you're interested in, use one of the many CPAN modules that handle exceptions, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try::Tiny&lt;/a&gt;.</source>
          <target state="translated">如果您对异常处理感兴趣，请使用许多处理异常的CPAN模块之一，例如&lt;a href=&quot;http://search.cpan.org/perldoc/Try::Tiny&quot;&gt;Try :: Tiny&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24299a423807f4b77a396032f4cc65f70fe49537" translate="yes" xml:space="preserve">
          <source>If explicitly enabled by</source>
          <target state="translated">如果明确启用</target>
        </trans-unit>
        <trans-unit id="8ede30fd7e2f6fae82106f61a77ef1de04cb5cb3" translate="yes" xml:space="preserve">
          <source>If false, STDERR is not captured (though it is 'relayed' to keep it somewhat synchronized with STDOUT.)</source>
          <target state="translated">如果为false,则不捕获STDERR(尽管它被 &quot;中继 &quot;以保持与STDOUT的某种同步)。</target>
        </trans-unit>
        <trans-unit id="9b5838f52003c96db3e6bffb7f5e0838c7d79e5c" translate="yes" xml:space="preserve">
          <source>If false, readline support in the debugger is disabled in order to debug applications that themselves use ReadLine.</source>
          <target state="translated">如果为false,则禁用调试器中的读线支持,以便调试本身使用ReadLine的应用程序。</target>
        </trans-unit>
        <trans-unit id="b1fe899108d979b4e6baf329c011d799eeebe85b" translate="yes" xml:space="preserve">
          <source>If filenames might use strange characters, it is safest to open it with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is magic and can translate characters like &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt; , and &lt;code&gt;|&lt;/code&gt;, which may be the wrong thing to do. (Sometimes, though, it's the right thing.) Three-arg open can also help protect against this translation in cases where it is undesirable.</source>
          <target state="translated">如果文件名可能使用奇怪的字符，则最安全的方法是使用 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 是魔术，可以翻译 &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 等字符 ，这可能是错误的事情。（但是，有时候这是对的。）在不需要的情况下，三参数开放也可以帮助防止这种翻译。</target>
        </trans-unit>
        <trans-unit id="6f78c1ed61e34e06bf280f0bbcc412ab7e6a2d2f" translate="yes" xml:space="preserve">
          <source>If find is used in &lt;a href=&quot;perlsec#Taint-mode&quot;&gt;taint-mode&lt;/a&gt; (-T command line switch or if EUID != UID or if EGID != GID), then internally directory names have to be untainted before they can be &lt;code&gt;chdir&lt;/code&gt;'d to. Therefore they are checked against a regular expression</source>
          <target state="translated">如果发现在使用&lt;a href=&quot;perlsec#Taint-mode&quot;&gt;污点模式&lt;/a&gt;（-T命令行开关，或者如果EUID！= UID或者如果EGID！= GID），然后在内部目录名必须玷污它们可以是前 &lt;code&gt;chdir&lt;/code&gt; &amp;ldquo;d到。因此，将根据正则表达式对它们进行检查</target>
        </trans-unit>
        <trans-unit id="5ca04d4d675b32f985d24c749a113dd2e8503548" translate="yes" xml:space="preserve">
          <source>If find is used in taint-mode (-T command line switch or if EUID != UID or if EGID != GID) then internally directory names have to be untainted before they can be chdir'ed to. Therefore they are checked against a regular expression</source>
          <target state="translated">如果find是在污点模式下使用的(-T命令行开关或EUID !=UID或EGID !=GID),那么内部的目录名在被chdir'ed之前必须是未被污染的。因此,它们会根据正则表达式进行检查</target>
        </trans-unit>
        <trans-unit id="ea1ec16d1d9147a52b3c1c50c90741c5c208db46" translate="yes" xml:space="preserve">
          <source>If flags contains &lt;code&gt;PERL_PV_ESCAPE_QUOTE&lt;/code&gt; then any double quotes in the string will also be escaped.</source>
          <target state="translated">如果标志包含 &lt;code&gt;PERL_PV_ESCAPE_QUOTE&lt;/code&gt; ,则字符串中的任何双引号也将被转义。</target>
        </trans-unit>
        <trans-unit id="ae542d10e971a673bbde2971d115357debc351d4" translate="yes" xml:space="preserve">
          <source>If flags contains PERL_PV_ESCAPE_QUOTE then any double quotes in the string will also be escaped.</source>
          <target state="translated">如果flags包含PERL_PV_ESCAPE_QUOTE,那么字符串中的任何双引号也将被转义。</target>
        </trans-unit>
        <trans-unit id="5f11c4bbd633be0ac4ec3da7d6d4106626b272c7" translate="yes" xml:space="preserve">
          <source>If for some reason you want to have complete control over the data connection, this includes generating it and calling the &lt;code&gt;response&lt;/code&gt; method when required, then the user can use these methods to do so.</source>
          <target state="translated">如果出于某种原因要完全控制数据连接（包括生成数据并在需要时调用 &lt;code&gt;response&lt;/code&gt; 方法），则用户可以使用这些方法来进行控制。</target>
        </trans-unit>
        <trans-unit id="527032a383661eed954e5386c22fa00fa6ffa0b3" translate="yes" xml:space="preserve">
          <source>If generating a manual page from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="translated">如果从标准输入生成手册页，则如果未提供此选项，则名称将设置为 &lt;code&gt;STDIN&lt;/code&gt; 。强烈建议提供此选项以设置有意义的手册页名称。</target>
        </trans-unit>
        <trans-unit id="33f20d3ebb86a1fb4909973670b43aa80acbb4c8" translate="yes" xml:space="preserve">
          <source>If hash values couldn't be lists, you lose. You'd probably have to combine all the cities into a single string somehow, and then when time came to write the output, you'd have to break the string into a list, sort the list, and turn it back into a string. This is messy and error-prone. And it's frustrating, because Perl already has perfectly good lists that would solve the problem if only you could use them.</source>
          <target state="translated">如果哈希值不能是列表,你就输了。你可能不得不以某种方式将所有的城市合并成一个单一的字符串,然后当写输出的时候,你必须将字符串分解成一个列表,对列表进行排序,然后再将它变成一个字符串。这很乱,而且容易出错。而且这很令人沮丧,因为Perl已经有了完美的列表,只要你能使用它们就能解决这个问题。</target>
        </trans-unit>
        <trans-unit id="774c1ecd49cf47f66e5a805e842abcc07904cbac" translate="yes" xml:space="preserve">
          <source>If hints are not available for the specified subroutines, this will cause a compile-time error. Insisting on hints for Perl's built-in functions (eg, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt;) is always successful.</source>
          <target state="translated">如果提示对于指定的子例程不可用，则将导致编译时错误。坚持使用Perl内置功能的提示（例如 &lt;code&gt;open&lt;/code&gt; 和 &lt;code&gt;close&lt;/code&gt; ）始终是成功的。</target>
        </trans-unit>
        <trans-unit id="7e8d248524799b9e3f004b01925fdada9567cc4f" translate="yes" xml:space="preserve">
          <source>If i&amp;lt;checked_at&amp;gt; is a reference to a scalar, then instead it gives the characters pre-checked at the beginning, (and the number of chars by which the C variable name has been advanced. These need to be chopped from the front of</source>
          <target state="translated">如果i &amp;lt;checked_at&amp;gt;是对标量的引用，那么它会在开头提供预先检查的字符（以及C变量名称已使用的字符数。这些字符必须从前面截去）</target>
        </trans-unit>
        <trans-unit id="0cd56861a4473054d59049046296e1c9cc1b21dc" translate="yes" xml:space="preserve">
          <source>If illegalproto warnings are enabled, the prototype declared inside this attribute will be sanity checked at compile time.</source>
          <target state="translated">如果启用了 illegalproto 警告,那么在此属性中声明的原型将在编译时进行理智检查。</target>
        </trans-unit>
        <trans-unit id="4d3aefb53a3e40d895443465bbfd3168415b47af" translate="yes" xml:space="preserve">
          <source>If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.</source>
          <target state="translated">如果有疑问,可以将表达式分解成更简单的语句,或者将所有操作数转为所需的结果类型。</target>
        </trans-unit>
        <trans-unit id="ce224243c2c27e9c319eeded5da4d7520f7a48e0" translate="yes" xml:space="preserve">
          <source>If instead of the recommended GNU make you would like to use the system supplied make program then be sure to install the default rules file properly via the shell command:</source>
          <target state="translated">如果你不想使用推荐的GNU make,而想使用系统提供的make程序,那么一定要通过shell命令正确安装默认规则文件。</target>
        </trans-unit>
        <trans-unit id="8c224a826076db854fafc0daefe6f5025badc4ce" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">相反，如果您打算在行的末尾匹配单词&amp;ldquo; foo&amp;rdquo;，然后在下一行匹配单词&amp;ldquo; bar&amp;rdquo;，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/$(?)\/&lt;/a&gt;&lt;/code&gt; （例如： &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo$(?)\s+bar/&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="835a22059d43bc5ff6100b52d4ba22bb32621c13" translate="yes" xml:space="preserve">
          <source>If instead you intended to match the word 'foo' at the end of the line followed by whitespace and the word 'bar' on the next line then you can use &lt;code&gt;m/$(?)\/&lt;/code&gt; (for example: &lt;code&gt;m/foo$(?)\s+bar/&lt;/code&gt;).</source>
          <target state="translated">相反，如果您打算在行的末尾匹配单词'foo'，然后在下一行匹配单词'bar'，则可以使用 &lt;code&gt;m/$(?)\/&lt;/code&gt; （例如： &lt;code&gt;m/foo$(?)\s+bar/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d629d0bcda097aa38909a34c55f2d4899baf7fd4" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array &lt;code&gt;@key&lt;/code&gt; with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">相反，如果您想使用比较例程 &lt;code&gt;find_records()&lt;/code&gt; 对 &lt;code&gt;@key&lt;/code&gt; 数组进行排序，则可以使用：</target>
        </trans-unit>
        <trans-unit id="d03def7cbe4cc9c7f39111662b050f07a1bc1197" translate="yes" xml:space="preserve">
          <source>If instead you want to sort the array @key with the comparison routine &lt;code&gt;find_records()&lt;/code&gt; then you can use:</source>
          <target state="translated">相反，如果您想使用比较例程 &lt;code&gt;find_records()&lt;/code&gt; 对@key数组进行排序，则可以使用：</target>
        </trans-unit>
        <trans-unit id="d1fc62400435ca2b18e437e1de72ea45d0c40705" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt; ) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">如果无效，则会生成 &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; 警告。&amp;ldquo; C0&amp;rdquo;的意思是&amp;ldquo;处理每个字符的字符串字符&amp;rdquo;。否则， &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U*&quot;, ...)&lt;/code&gt; 将在 &lt;code&gt;U0&lt;/code&gt; 模式下运行（如果格式字符串以 &lt;code&gt;U&lt;/code&gt; 开头，则为默认值），它将返回组成目标字符串UTF-8编码的字节。那将永远有效。</target>
        </trans-unit>
        <trans-unit id="7e4f3a7639737362f11e314ec120738bd4bec5b1" translate="yes" xml:space="preserve">
          <source>If invalid, a &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; warning is produced. The &quot;C0&quot; means &quot;process the string character per character&quot;. Without that, the &lt;code&gt;unpack(&quot;U*&quot;, ...)&lt;/code&gt; would work in &lt;code&gt;U0&lt;/code&gt; mode (the default if the format string starts with &lt;code&gt;U&lt;/code&gt;) and it would return the bytes making up the UTF-8 encoding of the target string, something that will always work.</source>
          <target state="translated">如果无效，则会生成 &lt;code&gt;Malformed UTF-8 character&lt;/code&gt; 警告。&amp;ldquo; C0&amp;rdquo;的意思是&amp;ldquo;处理每个字符的字符串字符&amp;rdquo;。否则， &lt;code&gt;unpack(&quot;U*&quot;, ...)&lt;/code&gt; 将在 &lt;code&gt;U0&lt;/code&gt; 模式下运行（如果格式字符串以 &lt;code&gt;U&lt;/code&gt; 开头，则为默认值），它将返回组成目标字符串UTF-8编码的字节。那将永远有效。</target>
        </trans-unit>
        <trans-unit id="51c33e52f177d40ae2c3679305c70e4a9572745e" translate="yes" xml:space="preserve">
          <source>If it ain't broke, don't fix it! Perl 4 library scripts should continue to work with no problems. You may need to make some minor changes (like escaping non-array @'s in double quoted strings) but there is no need to convert a .pl file into a Module for just that.</source>
          <target state="translated">如果它没有坏,就不要去修它! Perl 4 库脚本应该可以继续工作,不会有任何问题。你可能需要做一些小的改动(比如在双引号字符串中转义非数组的@),但不需要为此而将.pl文件转换为模块。</target>
        </trans-unit>
        <trans-unit id="5ae3aaa5715ffc32724b48d8610f7a354399dcc4" translate="yes" xml:space="preserve">
          <source>If it does not yet provide support for any encoding, one could write a derived class with such a &lt;code&gt;param&lt;/code&gt; method:</source>
          <target state="translated">如果尚不支持任何编码，则可以使用这种 &lt;code&gt;param&lt;/code&gt; 方法编写派生类：</target>
        </trans-unit>
        <trans-unit id="9548720aabed2519dabd7936701802a11d8a7465" translate="yes" xml:space="preserve">
          <source>If it exists, this field must contains a</source>
          <target state="translated">如果存在,该字段必须包含一个</target>
        </trans-unit>
        <trans-unit id="6ed0026aa4685c99082bcd85012c95fb26671228" translate="yes" xml:space="preserve">
          <source>If it is defined and perl is compiled with the C macro &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; defined, then it is called automatically when the interpreter exits for every shared object or library loaded by DynaLoader::bootstrap. All such library references are stored in @dl_librefs by DynaLoader::Bootstrap as it loads the libraries. The files are unloaded in last-in, first-out order.</source>
          <target state="translated">如果已定义并且用定义的C宏 &lt;code&gt;DL_UNLOAD_ALL_AT_EXIT&lt;/code&gt; 编译perl ，则当解释器针对DynaLoader :: bootstrap加载的每个共享对象或库退出时，将自动调用它。所有此类库引用在加载库时由DynaLoader :: Bootstrap存储在@dl_librefs中。文件以后进先出的顺序卸载。</target>
        </trans-unit>
        <trans-unit id="5b2268451c0f057ce91551f0143bc7efcca84a61" translate="yes" xml:space="preserve">
          <source>If it is determined to be case insensitive, during survey() it may skip pod files/modules that happen to be equal to names it's already seen, ignoring case.</source>
          <target state="translated">如果确定不区分大小写,在survey()期间,它可能会跳过那些恰好等于它已经看到的名字的pod文件/模块,而忽略大小写。</target>
        </trans-unit>
        <trans-unit id="96d25babefad3e04149e431c9fc9b4ab7fa3f715" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the issue tracker (you will be subscribed to notifications for issues you submit or comment on) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">如果你觉得你的 bug 被修正对你很重要,那么请关注问题跟踪器 (你会收到你提交或评论的问题的通知),以及 Perl 开发版本的提交日志,并且用善意的话语或冰冻的饮料来鼓励维护者。(请对维护者友好一点。骚扰或抨击他们很可能会产生你想要的相反效果)。)</target>
        </trans-unit>
        <trans-unit id="860a9992a29a5bed07a92916afafcc39c4466897" translate="yes" xml:space="preserve">
          <source>If it is important to you that your bug be fixed, do monitor the perl5-porters@perl.org mailing list (mailing lists are moderated, your message may take a while to show up) and the commit logs to development versions of Perl, and encourage the maintainers with kind words or offers of frosty beverages. (Please do be kind to the maintainers. Harassing or flaming them is likely to have the opposite effect of the one you want.)</source>
          <target state="translated">如果您希望您的 bug 得到修正,请关注 perl5-porters@perl.org 邮件列表 (邮件列表是有版主的,您的信息可能需要一段时间才能显示出来),以及 Perl 开发版本的提交日志,并鼓励维护者说些好话或提供冰冻饮料。(请对维护者友好一点。骚扰或抨击他们很可能会产生你想要的相反效果)。)</target>
        </trans-unit>
        <trans-unit id="835fcc1c62a963fd6a71d84d2861d08fa2d6dba4" translate="yes" xml:space="preserve">
          <source>If it is impossible to tell from the parameters passed back from the C callback what the context is, then you may need to create a sequence of C callback interface functions, and store pointers to each in an array.</source>
          <target state="translated">如果无法从C回调传回的参数中判断出上下文是什么,那么你可能需要创建一个C回调接口函数序列,并将每个函数的指针存储在一个数组中。</target>
        </trans-unit>
        <trans-unit id="5680f195fb6f8f7119b1a5d53970a5a24089ffc3" translate="yes" xml:space="preserve">
          <source>If it is intended that a new perl binary be produced, this variable may hold a name for that binary. Defaults to perl</source>
          <target state="translated">如果打算生成一个新的perl二进制文件,这个变量可以存放该二进制文件的名称。默认值为perl</target>
        </trans-unit>
        <trans-unit id="3922ec0b4a5411b9d0c3915227bde5d37e804a93" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;&quot;&lt;code&gt;PERL_BADFREE&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">如果问题仍然存在，则可以禁用此警告，请参阅&lt;a href=&quot;#PERL_BADFREE&quot;&gt;&amp;ldquo; &lt;code&gt;PERL_BADFREE&lt;/code&gt; &amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb1ca7ba722f679f82900212b2623b7a140c3fd8" translate="yes" xml:space="preserve">
          <source>If it persists, you may disable this warnings, see &lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;.</source>
          <target state="translated">如果仍然存在，则可以禁用此警告，请参阅&lt;a href=&quot;#PERL_BADFREE&quot;&gt;PERL_BADFREE&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3596d2c66fdea5d09f2cf7238ff867c93df8d69a" translate="yes" xml:space="preserve">
          <source>If it runs thru the entire given list of language-tags, and finds no classes for those exact terms, it then tries &quot;superordinate&quot; language classes. So if no &quot;en-US&quot; class (i.e., YourProjClass::en_us) was found, nor classes for anything else in that list, we then try its superordinate, &quot;en&quot; (i.e., YourProjClass::en), and so on thru the other language-tags in the given list: &quot;es&quot;. (The other language-tags in our example list: happen to have no superordinates.)</source>
          <target state="translated">如果它运行了整个给定的语言标签列表,并且没有找到这些术语的类,它就会尝试 &quot;上级 &quot;语言类。因此,如果没有找到 &quot;en-US &quot;类(即 YourProjClass::en_us),也没有找到列表中其他语言的类,我们就会尝试它的上级类 &quot;en&quot;(即 YourProjClass::en),以此类推,在给定列表中的其他语言标记。&quot;es&quot;。(在我们的示例列表中的其他语言标记:恰好没有上级。)</target>
        </trans-unit>
        <trans-unit id="956013cc75574f32898bd3291e14ae9c281c9d63" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;Time::Local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">如果它是足够规则的字符串，始终具有相同的格式，则可以将其拆分，然后将这些部分传递给标准&lt;a href=&quot;Time::Local&quot;&gt;Time :: Local&lt;/a&gt;模块中的 &lt;code&gt;timelocal&lt;/code&gt; 。否则，您应该查看CPAN中的&lt;a href=&quot;Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;，&lt;a href=&quot;Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt;和&lt;a href=&quot;Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="9e9c27ad93f7400ed6fd8cabde972a2941b1fcc1" translate="yes" xml:space="preserve">
          <source>If it's a regular enough string that it always has the same format, you can split it up and pass the parts to &lt;code&gt;timelocal&lt;/code&gt; in the standard &lt;a href=&quot;time/local&quot;&gt;Time::Local&lt;/a&gt; module. Otherwise, you should look into the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date::Parse&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt; modules from CPAN.</source>
          <target state="translated">如果它是一个足够常规的字符串，始终具有相同的格式，则可以将其拆分，然后将这些部分传递给标准&lt;a href=&quot;time/local&quot;&gt;Time :: Local&lt;/a&gt;模块中的 &lt;code&gt;timelocal&lt;/code&gt; 。否则，您应该查看CPAN中的&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Parse&quot;&gt;Date :: Parse&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="95cd7c9791eb757b708be268b21d99a1603edf51" translate="yes" xml:space="preserve">
          <source>If it's run from a terminal,</source>
          <target state="translated">如果是在终端运行。</target>
        </trans-unit>
        <trans-unit id="6e686f47ff84852246c986f46416264b0b26f101" translate="yes" xml:space="preserve">
          <source>If just a raw diff is provided, it is also possible use this two-step process:</source>
          <target state="translated">如果只是提供一个原始的diff,也可以使用这两个步骤。</target>
        </trans-unit>
        <trans-unit id="86e1fe8c1c0f93c5cc464283fb0d88ef22d53da9" translate="yes" xml:space="preserve">
          <source>If layers are not explicitly specified, the handle will be opened with the layers specified by the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;${^OPEN}&lt;/a&gt; variable (usually set by using the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma for a lexical scope, or the &lt;code&gt;-C&lt;/code&gt; command-line switch or &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable for the main program scope).</source>
          <target state="translated">如果未明确指定层，则将使用&lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;$ {^ OPEN}&lt;/a&gt;变量指定的层（通常通过对词法作用域使用&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma或 &lt;code&gt;-C&lt;/code&gt; 命令行开关或 &lt;code&gt;PERL_UNICODE&lt;/code&gt; 环境变量来设置）来打开句柄。主程序范围）。</target>
        </trans-unit>
        <trans-unit id="e46426c1bbbb04008f9627a6d4ae412c2a64f7b8" translate="yes" xml:space="preserve">
          <source>If layers are not specified in the open() call or &lt;code&gt;${^OPEN}&lt;/code&gt; variable, the handle will be opened with the default layer stack configured for that architecture; see &lt;a href=&quot;#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot;&lt;/a&gt;.</source>
          <target state="translated">如果未在open（）调用或 &lt;code&gt;${^OPEN}&lt;/code&gt; 变量中指定层，则将使用为该体系结构配置的默认层堆栈来打开句柄；否则，将打开该句柄。请参见&lt;a href=&quot;#Defaults-and-how-to-override-them&quot;&gt;&amp;ldquo;默认值以及如何覆盖它们&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8ec1e5cfa3f1d5f23853bddc58974b89d51e4343" translate="yes" xml:space="preserve">
          <source>If linking miniperl</source>
          <target state="translated">如果连接miniperl</target>
        </trans-unit>
        <trans-unit id="6f1ded59583efe50b40fd8b1ab3b5be326101642" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed, unless the locale is a UTF-8 one. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">如果有效的语言环境匹配规则，则对于小于255的代码点，从当前语言环境获取案例映射，对于较大的代码点，则从Unicode规则获取案例映射。但是，除非语言环境是UTF-8，否则将跨越Unicode规则/非Unicode规则边界（ords 255/256）的匹配将不会成功。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4bdbff6d4225cd79b23186ed9cad6253292a76ca" translate="yes" xml:space="preserve">
          <source>If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points. However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">如果有效的语言环境匹配规则，则对于小于255的代码点，从当前语言环境获取案例映射，对于较大的代码点，则从Unicode规则获取案例映射。但是，将跨越Unicode规则/非Unicode规则边界（ords 255/256）的匹配将不会成功。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="763f933c48615038adc7019dfce8f6c0c593c306" translate="yes" xml:space="preserve">
          <source>If locale rules are not in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="translated">如果locale规则没有生效,使用Unicode属性将迫使正则表达式使用Unicode规则,如果它还没有生效的话。</target>
        </trans-unit>
        <trans-unit id="d834fc3f63056ccac9737e1620e9488be6eb7541" translate="yes" xml:space="preserve">
          <source>If maketext goes to look in an individual %Lexicon for an entry for</source>
          <target state="translated">如果maketext在一个单独的%Lexicon中寻找一个条目,那么这个条目就是</target>
        </trans-unit>
        <trans-unit id="3e3dcee3a8b9bd973fa29d705bfdb80867c80c81" translate="yes" xml:space="preserve">
          <source>If many functions use the same failure indication based on the return value, you may want to create a special typedef to handle this situation. Put</source>
          <target state="translated">如果许多函数基于返回值使用相同的失败指示,你可能需要创建一个特殊的类型定义来处理这种情况。把</target>
        </trans-unit>
        <trans-unit id="b606db88e20200612d730cc961241a27da21957f" translate="yes" xml:space="preserve">
          <source>If module is installed, peeks into the module's manpage, reads the headline, and returns it. Moreover, if the module has been downloaded within this session, does the equivalent on the downloaded module even if it hasn't been installed yet.</source>
          <target state="translated">如果模块已经安装好,就进入模块的manpage,读取标题,然后返回。此外,如果在这个会话中下载了模块,即使还没有安装,也会在下载的模块上做相应的操作。</target>
        </trans-unit>
        <trans-unit id="dd58d8ff347dcd8c05f67e1fd3ee4d2440157ff1" translate="yes" xml:space="preserve">
          <source>If more arguments are provided then they are all appended to the message, thus all these lines will have the same effect on the state of the $ctx object:</source>
          <target state="translated">如果提供了更多的参数,那么它们都会被附加到消息中,因此所有这些行将对$ctx对象的状态产生同样的影响。</target>
        </trans-unit>
        <trans-unit id="d7d32d6074826a3d2d75814ea308b5ddeaca2f3c" translate="yes" xml:space="preserve">
          <source>If more delimiters than escape chars are specified, the last escape char is used for the remaining delimiters. If no escape char is specified for a given specified delimiter, '\' is used.</source>
          <target state="translated">如果指定的定界符比转义符多,那么剩余的定界符将使用最后一个转义符。如果没有为指定的定界符指定转义字符,则使用'\'。</target>
        </trans-unit>
        <trans-unit id="285c13c421c908ec1b5157ff1d11ce664fe6f585" translate="yes" xml:space="preserve">
          <source>If more than one argument is given then the entire argument list is assumed to be a hash. If a hash is supplied (either as a reference or as a list) it should contain one or more elements with the following keys:</source>
          <target state="translated">如果给出了一个以上的参数,那么整个参数列表被认为是一个哈希值。如果提供了一个哈希值(无论是作为参考还是作为一个列表),它应该包含一个或多个具有以下键的元素:</target>
        </trans-unit>
        <trans-unit id="39e41b545db315dc5126671cc2bd5d88f5c30e3d" translate="yes" xml:space="preserve">
          <source>If more than one restriction of &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;distribution&lt;/code&gt; , etc. is specified, the results of the separately computed match values must all match. If so, the hashref represented by the YAML document is returned as the preference structure for the current distribution.</source>
          <target state="translated">如果指定了 &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;distribution&lt;/code&gt; 等多个限制，则分别计算的匹配值的结果必须全部匹配。如果是这样，则返回YAML文档表示的hashref作为当前分发的首选项结构。</target>
        </trans-unit>
        <trans-unit id="da05e2a6f3037e503e2698db0f33736532af13ae" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">如果列出了多个变量,则必须将列表放在括号中。</target>
        </trans-unit>
        <trans-unit id="463724a0fef86ec9bcf7097a4a23f19c350c87fd" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder. However, since initialization of state variables in such lists is currently not possible this would serve no purpose.</source>
          <target state="translated">如果列出了多个变量，则该列表必须放在括号中。使用带括号的列表，&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;可以用作虚拟占位符。但是，由于当前无法在此类列表中初始化状态变量，因此这将毫无用处。</target>
        </trans-unit>
        <trans-unit id="5915108dabbdb47d0e6487842fce0264a4b8c92e" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">如果列出了多个变量，则该列表必须放在括号中。使用带括号的列表， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符。但是，由于当前无法在列表上下文中初始化状态变量，因此这将毫无用处。</target>
        </trans-unit>
        <trans-unit id="13f0dd65ec56750a188884a636ba7b4f0428367d" translate="yes" xml:space="preserve">
          <source>If more than one variable is listed, the list must be placed in parentheses. With a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder. However, since initialization of state variables in list context is currently not possible this would serve no purpose.</source>
          <target state="translated">如果列出了多个变量，则该列表必须放在括号中。使用带括号的列表， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符。但是，由于当前无法在列表上下文中初始化状态变量，因此这将毫无用处。</target>
        </trans-unit>
        <trans-unit id="cc246b70384e8a417eb59e4e6e4575312d9d1e0a" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">如果将多个变量或表达式赋给 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ，则必须将它们放在括号中。该运算符的工作方式是将这些变量的当前值保存在其参数列表中的隐藏堆栈中，并在退出块，子例程或eval时恢复它们。这意味着被调用的子例程也可以引用局部变量，但不能引用全局变量。如果需要，可以将参数列表分配给它，这使您可以初始化局部变量。（如果未为特定变量提供初始化程序，则会使用未定义的值来创建它。）</target>
        </trans-unit>
        <trans-unit id="085c88b116674b900e024434a6a7c1e9689729b6" translate="yes" xml:space="preserve">
          <source>If more than one variable or expression is given to &lt;code&gt;local&lt;/code&gt;, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</source>
          <target state="translated">如果将多个变量或表达式赋给 &lt;code&gt;local&lt;/code&gt; ，则必须将它们放在括号中。该运算符的工作方式是将这些变量的当前值保存在其参数列表中的隐藏堆栈中，并在退出块，子例程或eval时恢复它们。这意味着被调用的子例程也可以引用局部变量，但不能引用全局变量。如果需要，可以将参数列表分配给它，这使您可以初始化局部变量。（如果未为特定变量提供初始值设定项，则会使用未定义的值创建该初始值设定项。）</target>
        </trans-unit>
        <trans-unit id="e6e3db41fbfcf6140e9c02e059dd4c934fd6f5ad" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name then the $+{NAME} will refer to the leftmost defined group in the match.</source>
          <target state="translated">如果多个不同的捕获组具有相同的名称,那么$+{NAME}将引用匹配中最左边的定义组。</target>
        </trans-unit>
        <trans-unit id="585d6ab5fb9075615690fae06a03a5a68fb5033a" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="translated">如果多个不同的捕获组具有相同的名称，则 &lt;code&gt;$+{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 将引用匹配项中最左侧定义的组。</target>
        </trans-unit>
        <trans-unit id="ba43723459a9559595b0c9aa2500eb340a4dc46e" translate="yes" xml:space="preserve">
          <source>If multiple distinct capture groups have the same name, then &lt;code&gt;$+{NAME}&lt;/code&gt; will refer to the leftmost defined group in the match.</source>
          <target state="translated">如果多个不同的捕获组具有相同的名称，则 &lt;code&gt;$+{NAME}&lt;/code&gt; 将引用匹配项中最左侧定义的组。</target>
        </trans-unit>
        <trans-unit id="0bfee97a70420feb4c2945973c34123d251dd9c2" translate="yes" xml:space="preserve">
          <source>If multiple files from one program are desired an array ref can be used.</source>
          <target state="translated">如果需要一个程序中的多个文件,可以使用数组引用。</target>
        </trans-unit>
        <trans-unit id="081ad6caef0052cfab1aad2ae1061ca747e43248" translate="yes" xml:space="preserve">
          <source>If multiple transliterations are given for a character, only the first one is used:</source>
          <target state="translated">如果一个字符有多个音译,则只使用第一个音译。</target>
        </trans-unit>
        <trans-unit id="c414b75ce1c860047ef0a566364396ec60b38e43" translate="yes" xml:space="preserve">
          <source>If my tests take too long to run I may be able to speed them up by running multiple test scripts in parallel. This is particularly effective if the tests are I/O bound or if I have multiple CPU cores. I tell prove to run my tests in parallel like this:</source>
          <target state="translated">如果我的测试运行时间太长,我可以通过并行运行多个测试脚本来加快测试速度。如果测试是 I/O 绑定的,或者我有多个 CPU 核,这就特别有效。我告诉证明这样并行运行我的测试。</target>
        </trans-unit>
        <trans-unit id="766c6735ff098a4b925a773897fe49012fa4895d" translate="yes" xml:space="preserve">
          <source>If name passed in doesn't specify a readable file, appends</source>
          <target state="translated">如果传入的文件名没有指定可读的文件,则添加</target>
        </trans-unit>
        <trans-unit id="1afec739c7f1e924deac0edbd4a6af96f74019ce" translate="yes" xml:space="preserve">
          <source>If necessary switch the input stream to handle unicode. This only has any effect for I/O handle based streams.</source>
          <target state="translated">如果需要,将输入流切换为处理unicode。这只对基于I/O句柄的流有影响。</target>
        </trans-unit>
        <trans-unit id="1f88753647459114bf0fff92153d71fa3be1ef0c" translate="yes" xml:space="preserve">
          <source>If needed, &lt;code&gt;$new_size&lt;/code&gt; will be rounded up to the next multiple of the memory page size (usually 4096 or 8192).</source>
          <target state="translated">如果需要， &lt;code&gt;$new_size&lt;/code&gt; 将舍入到内存页面大小的下一个倍数（通常为4096或8192）。</target>
        </trans-unit>
        <trans-unit id="13ffb9e8f4aa9a45a3175ee9916b5d80efc23ef5" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; . This will cause the thread to return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">如果需要，可以通过调用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 随时退出线程。这将导致线程在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，或者在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="7fa85a1effefc4c0579975cf6db618b5a32a7f98" translate="yes" xml:space="preserve">
          <source>If needed, a thread can be exited at any time by calling &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt;. This will cause the thread to return &lt;code&gt;undef&lt;/code&gt; in a scalar context, or the empty list in a list context.</source>
          <target state="translated">如果需要，可以随时通过调用 &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; 退出线程。这将导致线程在标量上下文中返回 &lt;code&gt;undef&lt;/code&gt; ，或者在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="ba4f2509d5dd63a76d44f087cc7f42f7f77c757a" translate="yes" xml:space="preserve">
          <source>If needed, scripts can be written so as to run on both threaded and non-threaded Perls:</source>
          <target state="translated">如果需要,可以编写脚本,以便在有线程和无线程的Perls上运行。</target>
        </trans-unit>
        <trans-unit id="91fbdba912e7cde9b89fa3cefbc9b3e7d8d65343" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">如果需要，这些方法应该由继承自&lt;b&gt;Tie :: Hash&lt;/b&gt;，&lt;b&gt;Tie :: StdHash&lt;/b&gt;或&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;的包定义。有关详细信息，请参见&lt;a href=&quot;../perltie#SCALAR&quot;&gt;SCALAR，&lt;/a&gt;以查找不存在 &lt;code&gt;SCALAR&lt;/code&gt; 时发生的情况。</target>
        </trans-unit>
        <trans-unit id="e7be13126ea530b0bd8ee259471daa2d8234b8a5" translate="yes" xml:space="preserve">
          <source>If needed, these methods should be defined by the package inheriting from &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. See &lt;a href=&quot;perltie#SCALAR&quot;&gt;&quot;SCALAR&quot; in perltie&lt;/a&gt; to find out what happens when &lt;code&gt;SCALAR&lt;/code&gt; does not exist.</source>
          <target state="translated">如果需要，这些方法应该由继承自&lt;b&gt;Tie :: Hash&lt;/b&gt;，&lt;b&gt;Tie :: StdHash&lt;/b&gt;或&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;的包定义。请参阅&lt;a href=&quot;perltie#SCALAR&quot;&gt;perltie中的&amp;ldquo; SCALAR&amp;rdquo;，&lt;/a&gt;以了解不存在 &lt;code&gt;SCALAR&lt;/code&gt; 时会发生什么。</target>
        </trans-unit>
        <trans-unit id="f7a52a7ddea6d450e656d921a0db2fecb1485c60" translate="yes" xml:space="preserve">
          <source>If needed, thread warnings can be suppressed by using:</source>
          <target state="translated">如果需要,线程警告可以通过使用。</target>
        </trans-unit>
        <trans-unit id="7aac81b2bba7d90df4570fdaec9abe8879fce464" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Family&lt;/code&gt; nor any hosts or addresses are passed, nor any &lt;code&gt;*AddrInfo&lt;/code&gt;, then the constructor has no information on which to decide a socket family to create. In this case, it performs a &lt;code&gt;getaddinfo&lt;/code&gt; call with the &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; flag, no host name, and a service name of &lt;code&gt;&quot;0&quot;&lt;/code&gt;, and uses the family of the first returned result.</source>
          <target state="translated">如果既不传递 &lt;code&gt;Family&lt;/code&gt; 也不传递任何主机或地址，也不传递任何 &lt;code&gt;*AddrInfo&lt;/code&gt; ，则构造方法将不具有决定要创建的套接字家族的信息。在这种情况下，它将执行带有 &lt;code&gt;AI_ADDRCONFIG&lt;/code&gt; 标志，没有主机名和服务名 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 的 &lt;code&gt;getaddinfo&lt;/code&gt; 调用，并使用第一个返回结果的族。</target>
        </trans-unit>
        <trans-unit id="e1d589a6c51332c7705521b2b0ef94169fba9785" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;Type&lt;/code&gt; nor &lt;code&gt;Proto&lt;/code&gt; hints are provided, a default of &lt;code&gt;SOCK_STREAM&lt;/code&gt; and &lt;code&gt;IPPROTO_TCP&lt;/code&gt; respectively will be set, to maintain compatibility with &lt;code&gt;IO::Socket::INET&lt;/code&gt;. Other named arguments that are not recognised are ignored.</source>
          <target state="translated">如果既不提供 &lt;code&gt;Type&lt;/code&gt; 提示也不提供 &lt;code&gt;Proto&lt;/code&gt; 提示，则将分别设置默认的 &lt;code&gt;SOCK_STREAM&lt;/code&gt; 和 &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ，以保持与 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 兼容性。其他无法识别的命名参数将被忽略。</target>
        </trans-unit>
        <trans-unit id="620d906a2e9dd53f3e33bb69b96c36a7f678920a" translate="yes" xml:space="preserve">
          <source>If neither of those work, then you can't use adb to cross-compile to your device. Either try rooting it, or go for the ssh route.</source>
          <target state="translated">如果这两种方法都不行,那么你就不能用adb交叉编译到你的设备上。要么尝试root它,要么走ssh路线。</target>
        </trans-unit>
        <trans-unit id="7b8270c68932b39381b724db912d7e0064edb351" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;-L&lt;/code&gt; or &lt;code&gt;-l&lt;/code&gt; prefix is present in an entry, the entry is considered a directory to search if it is in fact a directory, and a library to search for otherwise. The &lt;code&gt;$Config{lib_ext}&lt;/code&gt; suffix will be appended to any entries that are not directories and don't already have the suffix.</source>
          <target state="translated">如果条目中没有 &lt;code&gt;-L&lt;/code&gt; 或 &lt;code&gt;-l&lt;/code&gt; 前缀，则该条目实际上是目录，将被视为目录，否则将被视为库。在 &lt;code&gt;$Config{lib_ext}&lt;/code&gt; 后缀将追加到不属于目录，还没有后缀的所有条目。</target>
        </trans-unit>
        <trans-unit id="2d1c5c51b75ebf17552d122abb9f110644200dac" translate="yes" xml:space="preserve">
          <source>If neither the &lt;code&gt;G_METHOD&lt;/code&gt; nor &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, the SV may be any of a CV, a GV, a reference to a CV, a reference to a GV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the sub to call.</source>
          <target state="translated">如果未提供 &lt;code&gt;G_METHOD&lt;/code&gt; 和 &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; 标志，则SV可以是CV，GV，对CV的引用，对GV的引用或 &lt;code&gt;SvPV(sv)&lt;/code&gt; 中的任何一个将用作要调用的子项的名称。</target>
        </trans-unit>
        <trans-unit id="33d1d1804f2f0f5f5a1b0fb679650c8cfecd87fb" translate="yes" xml:space="preserve">
          <source>If neither the exit status nor the verbose level is specified, then the default is to use an exit status of 2 with a verbose level of 0.</source>
          <target state="translated">如果既不指定退出状态,也不指定verbose级别,则默认使用退出状态为2,verbose级别为0。</target>
        </trans-unit>
        <trans-unit id="ca010fd55b822b0537501828b1432d2b69dedb67" translate="yes" xml:space="preserve">
          <source>If neither your configured &lt;code&gt;yaml_module&lt;/code&gt; nor YAML.pm is installed, CPAN.pm falls back to using Data::Dumper and Storable and looks for files with the extensions &lt;code&gt;.dd&lt;/code&gt; or &lt;code&gt;.st&lt;/code&gt; in the &lt;code&gt;prefs_dir&lt;/code&gt; directory. These files are expected to contain one or more hashrefs. For Data::Dumper generated files, this is expected to be done with by defining &lt;code&gt;$VAR1&lt;/code&gt; , &lt;code&gt;$VAR2&lt;/code&gt; , etc. The YAML shell would produce these with the command</source>
          <target state="translated">如果未安装配置的 &lt;code&gt;yaml_module&lt;/code&gt; 或YAML.pm，则CPAN.pm将退回到使用Data :: Dumper和Storable的位置，并在 &lt;code&gt;prefs_dir&lt;/code&gt; 目录中查找扩展名为 &lt;code&gt;.dd&lt;/code&gt; 或 &lt;code&gt;.st&lt;/code&gt; 的文件。这些文件应包含一个或多个哈希引用。对于Data :: Dumper生成的文件，可以通过定义 &lt;code&gt;$VAR1&lt;/code&gt; ， &lt;code&gt;$VAR2&lt;/code&gt; 等来完成。YAML shell将使用以下命令生成这些文件：</target>
        </trans-unit>
        <trans-unit id="1ff3f3f68e857a065a27224d0e20ede58778f1ae" translate="yes" xml:space="preserve">
          <source>If new() is called as an instance method (i.e. $ctx-&amp;gt;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case, and the return value is the reference to the object (i.e. $ctx).</source>
          <target state="translated">如果将new（）作为实例方法（即$ ctx-&amp;gt; new）调用，它将仅将对象的状态重置为新创建的对象的状态。在这种情况下，不会创建新对象，并且返回值是该对象的引用（即$ ctx）。</target>
        </trans-unit>
        <trans-unit id="2e13ee0a65adecfa0d8e7d8968c5c8fbe048cddb" translate="yes" xml:space="preserve">
          <source>If no $default is provided an empty string will be used instead.</source>
          <target state="translated">如果没有提供$default,将使用一个空字符串代替。</target>
        </trans-unit>
        <trans-unit id="0472c17854436e8327aa450d7bb9d0ca29c0fa4c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$VERSION&lt;/code&gt; was specified on the &lt;code&gt;bootstrap&lt;/code&gt; line, the last line becomes</source>
          <target state="translated">如果在 &lt;code&gt;bootstrap&lt;/code&gt; 行上未指定 &lt;code&gt;$VERSION&lt;/code&gt; ，则最后一行变为</target>
        </trans-unit>
        <trans-unit id="1b4091cfd69b61e159053e0bbc2425f479136432" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;$section_spec&lt;/code&gt; arguments are given, then the existing set of selected sections is cleared out (which means &lt;code&gt;all&lt;/code&gt; sections will be processed).</source>
          <target state="translated">如果没有给出 &lt;code&gt;$section_spec&lt;/code&gt; 参数，那么将清除现有的选定节集（这意味着将处理 &lt;code&gt;all&lt;/code&gt; 节）。</target>
        </trans-unit>
        <trans-unit id="c0be16a9153a991182a683ab2886f1fa902dd9f4" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; , the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">如果未找到 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 值，并且最后一条语句是表达式，则返回其值。如果最后一条语句是诸如 &lt;code&gt;foreach&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 的循环控制结构，则返回的值不确定。空子返回空列表。</target>
        </trans-unit>
        <trans-unit id="97d668cbdc526d3cbea7edc6414a728eb26feaf0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;return&lt;/code&gt; is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a &lt;code&gt;foreach&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt;, the returned value is unspecified. The empty sub returns the empty list.</source>
          <target state="translated">如果未找到 &lt;code&gt;return&lt;/code&gt; 值，并且最后一条语句是表达式，则返回其值。如果最后一条语句是诸如 &lt;code&gt;foreach&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 的循环控制结构，则返回的值不确定。空子返回空列表。</target>
        </trans-unit>
        <trans-unit id="bf9cd2f55bd05fa55b1648853a5a5e34325f19ca" translate="yes" xml:space="preserve">
          <source>If no @args are given, no @cmds will be returned.</source>
          <target state="translated">如果没有给出@args,将不会返回@cmds。</target>
        </trans-unit>
        <trans-unit id="d11be4d28581ad6cd28ff2cca82d45474710696d" translate="yes" xml:space="preserve">
          <source>If no MANIFEST.SKIP file is found, a default set of skips will be used, similar to the example above. If you want nothing skipped, simply make an empty MANIFEST.SKIP file.</source>
          <target state="translated">如果没有找到 MANIFEST.SKIP 文件,将使用默认的跳过集,类似于上面的例子。如果你不想跳过任何东西,只需制作一个空的 MANIFEST.SKIP 文件。</target>
        </trans-unit>
        <trans-unit id="482e18ae3dbe759dbfcebf52b00cc2a6c84ee16a" translate="yes" xml:space="preserve">
          <source>If no argument is given, the highest possible setting will be used, which is rarely useful.</source>
          <target state="translated">如果没有给出论据,就会使用可能的最高设置,这很少有用。</target>
        </trans-unit>
        <trans-unit id="6fc9afdb8826971e1f36212e96bd04623eb38e92" translate="yes" xml:space="preserve">
          <source>If no argument is given, the limit check will be deactivated (same as when &lt;code&gt;0&lt;/code&gt; is specified).</source>
          <target state="translated">如果未提供任何参数，则将禁用极限检查（与指定 &lt;code&gt;0&lt;/code&gt; 时相同）。</target>
        </trans-unit>
        <trans-unit id="cae10c8870eae9f10da944c7a01e813768cc713b" translate="yes" xml:space="preserve">
          <source>If no arguments are given to pod2man it will read from @ARGV.</source>
          <target state="translated">如果没有给pod2man提供参数,它将从@ARGV读取。</target>
        </trans-unit>
        <trans-unit id="87c6b87283ba7c4ecec068cb48f3ae13420b59ed" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">如果未提供任何参数， &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 将以字符串形式返回整个格式化的归档文件，如果您想将归档文件放入套接字或通向gzip的管道中，则可能很有用。</target>
        </trans-unit>
        <trans-unit id="0ab20efd7be2867edc836fd9f4e9fd1df47b1ae4" translate="yes" xml:space="preserve">
          <source>If no arguments are given, &lt;code&gt;write&lt;/code&gt; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</source>
          <target state="translated">如果未提供任何参数， &lt;code&gt;write&lt;/code&gt; 将以字符串形式返回整个格式化的存档文件，如果您想将存档文件塞入套接字或通向gzip的管道中，这可能会很有用。</target>
        </trans-unit>
        <trans-unit id="886a141165f04df6d6f369bc4c3d2d482bb6efce" translate="yes" xml:space="preserve">
          <source>If no arguments are passed then the current article in the currently selected newsgroup is fetched.</source>
          <target state="translated">如果没有传递任何参数,那么将获取当前所选新闻组中的当前文章。</target>
        </trans-unit>
        <trans-unit id="1361c81765e284924a4726230ee621f378f42412" translate="yes" xml:space="preserve">
          <source>If no error occurs, &lt;code&gt;eval&lt;/code&gt; sets &lt;code&gt;$@&lt;/code&gt; to the empty string.</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;eval&lt;/code&gt; 将 &lt;code&gt;$@&lt;/code&gt; 设置为空字符串。</target>
        </trans-unit>
        <trans-unit id="ddc296f09027fdaaecb023b3cebc4e9cba37abbb" translate="yes" xml:space="preserve">
          <source>If no extension is supplied, and your system supports it, the original</source>
          <target state="translated">如果没有提供任何扩展,而你的系统又支持它,那么原来的</target>
        </trans-unit>
        <trans-unit id="85c571c913f7bfa21e872b065c24a094b4bb7659" translate="yes" xml:space="preserve">
          <source>If no files or directories are supplied, &lt;code&gt;prove&lt;/code&gt; looks for all files matching the pattern &lt;code&gt;t/*.t&lt;/code&gt;.</source>
          <target state="translated">如果未提供文件或目录，则 &lt;code&gt;prove&lt;/code&gt; 查找与模式 &lt;code&gt;t/*.t&lt;/code&gt; 。t匹配的所有文件。</target>
        </trans-unit>
        <trans-unit id="a4c68647b34bca31278b9d9c157de53c4f611c93" translate="yes" xml:space="preserve">
          <source>If no flags argument is give then &lt;code&gt;GLOB_CSH&lt;/code&gt; is set, and on VMS and Windows systems, &lt;code&gt;GLOB_NOCASE&lt;/code&gt; too. Otherwise the flags to use are determined solely by the flags argument. The POSIX defined flags are:</source>
          <target state="translated">如果没有给出flags参数，则设置 &lt;code&gt;GLOB_CSH&lt;/code&gt; ，在VMS和Windows系统上也设置 &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 。否则，要使用的标志仅由flags参数确定。POSIX定义的标志是：</target>
        </trans-unit>
        <trans-unit id="cea57f19921408109bb2fb4d00e16350d27b4844" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible VMS-specific features are assumed. Currently, there are four VMS-specific features available: 'status' (a.k.a '$?'), 'exit', 'time' and 'hushed'.</source>
          <target state="translated">如果没有提供导入列表,则假定所有可能的VMS特定特性。目前,有四个VMS特有的特性:'status'(又名'$?')、'exit'、'time'和'hushed'。</target>
        </trans-unit>
        <trans-unit id="d4ceff2a6aadec6052244b97bba7012539a0b105" translate="yes" xml:space="preserve">
          <source>If no import list is supplied, all possible restrictions are assumed. (This is the safest mode to operate in, but is sometimes too strict for casual programming.) Currently, there are three possible things to be strict about: &quot;subs&quot;, &quot;vars&quot;, and &quot;refs&quot;.</source>
          <target state="translated">如果没有提供导入列表,则假设所有可能的限制。(这是最安全的操作模式,但对于随意编程来说,有时过于严格。)目前,有三种可能的东西需要严格。&quot;subs&quot;、&quot;vars &quot;和 &quot;refs&quot;。</target>
        </trans-unit>
        <trans-unit id="c1d6512b9a9d5a5a9bf4112bcb1e3a393263f0b9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定索引处不存在任何项（即，队列为空，或者索引超出了队列中的项数），则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78d629698ed39f1b937dab840c0e7631f8015fc9" translate="yes" xml:space="preserve">
          <source>If no items exists at the specified index (i.e., the queue is empty, or the index is beyond the number of items on the queue), then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果指定索引处不存在任何项目（即，队列为空，或者索引超出队列中的项目数），则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc9e3e2a819c8fb3d75385fda77f033e08dfb423" translate="yes" xml:space="preserve">
          <source>If no options are given, Pod::Man uses the name of the input file with any trailing &lt;code&gt;.pod&lt;/code&gt;, &lt;code&gt;.pm&lt;/code&gt;, or &lt;code&gt;.pl&lt;/code&gt; stripped as the man page title, to section 1 unless the file ended in &lt;code&gt;.pm&lt;/code&gt; in which case it defaults to section 3, to a centered title of &quot;User Contributed Perl Documentation&quot;, to a centered footer of the Perl version it is run with, and to a left-hand footer of the modification date of its input (or the current date if given &lt;code&gt;STDIN&lt;/code&gt; for input).</source>
          <target state="translated">如果没有给出选项，波德::人使用与任何尾随的输入文件名 &lt;code&gt;.pod&lt;/code&gt; ， &lt;code&gt;.pm&lt;/code&gt; 后缀，或 &lt;code&gt;.pl&lt;/code&gt; 剥离作为男人页面标题，第1，除非在结束文件 &lt;code&gt;.pm&lt;/code&gt; 在这种情况下，默认为第3节，以&amp;ldquo; User Contributed Perl Documentation&amp;rdquo;为中心标题，以其为运行时所在的Perl版本的中心为页脚，以其输入的修改日期（或当前日期为给定 &lt;code&gt;STDIN&lt;/code&gt; 作为输入）。</target>
        </trans-unit>
        <trans-unit id="1f1608fb3d0f72aad27d7541f9de6e52f802b4ee" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt; , the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your</source>
          <target state="translated">如果未提供第二个参数，并且类别为 &lt;code&gt;LC_ALL&lt;/code&gt; ，则结果取决于实现。它可以是一串串联的语言环境名称（分隔符也取决于实现）或单个语言环境名称。请咨询您的</target>
        </trans-unit>
        <trans-unit id="267c1696e15f2baca20bbece162193151736f0bb" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is &lt;code&gt;LC_ALL&lt;/code&gt;, the result is implementation-dependent. It may be a string of concatenated locale names (separator also implementation-dependent) or a single locale name. Please consult your &lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale(3)&lt;/a&gt; man page for details.</source>
          <target state="translated">如果未提供第二个参数，并且类别为 &lt;code&gt;LC_ALL&lt;/code&gt; ，则结果取决于实现。它可以是一串串联的语言环境名称（分隔符也取决于实现）或单个语言环境名称。有关详细信息，请查阅&lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale（3）&lt;/a&gt;手册页。</target>
        </trans-unit>
        <trans-unit id="ed489574b7ebc8c696d017fb9515c4a591232a34" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt; , the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt; , &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">如果没有提供第二个参数，并且类别不是 &lt;code&gt;LC_ALL&lt;/code&gt; ，则该函数返回一个字符串，为该类别的当前语言环境命名。您可以在后续对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中将此值用作第二个参数，&lt;b&gt;但是&lt;/b&gt;在某些平台上，字符串是不透明的，大多数人都无法理解该字符串的含义。</target>
        </trans-unit>
        <trans-unit id="64041fec58a65d66b2f703a3782bbd84be6d1203" translate="yes" xml:space="preserve">
          <source>If no second argument is provided and the category is something other than &lt;code&gt;LC_ALL&lt;/code&gt;, the function returns a string naming the current locale for the category. You can use this value as the second argument in a subsequent call to &lt;code&gt;setlocale()&lt;/code&gt;, &lt;b&gt;but&lt;/b&gt; on some platforms the string is opaque, not something that most people would be able to decipher as to what locale it means.</source>
          <target state="translated">如果未提供第二个参数，并且类别不是 &lt;code&gt;LC_ALL&lt;/code&gt; ，则该函数将返回一个字符串，为该类别的当前语言环境命名。您可以在随后对 &lt;code&gt;setlocale()&lt;/code&gt; 的调用中将此值用作第二个参数，&lt;b&gt;但是&lt;/b&gt;在某些平台上，字符串是不透明的，大多数人都无法理解字符串的含义。</target>
        </trans-unit>
        <trans-unit id="53385049e198591f3af9c0f621b19586d0e6e03c" translate="yes" xml:space="preserve">
          <source>If no string is specified via the &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator, the &lt;code&gt;$_&lt;/code&gt; variable is searched and modified. Unless the &lt;code&gt;/r&lt;/code&gt; option is used, the string specified must be a scalar variable, an array element, a hash element, or an assignment to one of those; that is, some sort of scalar lvalue.</source>
          <target state="translated">如果没有通过 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符指定任何字符串，则搜索并修改 &lt;code&gt;$_&lt;/code&gt; 变量。除非使用 &lt;code&gt;/r&lt;/code&gt; 选项，否则指定的字符串必须是标量变量，数组元素，哈希元素或对其中之一的赋值；即某种标量左值。</target>
        </trans-unit>
        <trans-unit id="9ee4d303ec9de35b4bd6b8caf1f726ddd4ca7c6e" translate="yes" xml:space="preserve">
          <source>If no such Pod file is found, this method returns undef.</source>
          <target state="translated">如果没有找到这样的Pod文件,本方法返回undef。</target>
        </trans-unit>
        <trans-unit id="34cd3d77c3969309ab95d1d80fe464b5d299344d" translate="yes" xml:space="preserve">
          <source>If no urllist has been chosen yet, would you prefer CPAN.pm to connect to the built-in default sites without asking? (yes/no)?</source>
          <target state="translated">如果还没有选择urllist,您是否希望CPAN.pm不需要询问就能连接到内置的默认站点?(是/否)?</target>
        </trans-unit>
        <trans-unit id="b1457b54499e074ed5ffc48ffd57a11b298ba627" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed.</source>
          <target state="translated">如果没有值与该属性关联，则传递 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e6ead3ce8c862f9ee6e9b2af0ca9c9d3945d613" translate="yes" xml:space="preserve">
          <source>If no value is associated with the attribute, &lt;code&gt;undef&lt;/code&gt; is passed.</source>
          <target state="translated">如果没有值与该属性相关联，则传递 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbf2ca53d71d01f547a112c6b13519e5e34d198d" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;a href=&quot;#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">如果非空括号是&lt;a href=&quot;#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; 中&lt;/a&gt;唯一使用的通配符，则不会匹配任何文件名，但可能会返回许多字符串。例如，这产生了九个字符串，每对水果和颜色配对一个：</target>
        </trans-unit>
        <trans-unit id="3641612d3261f449a8b25c55086ede32d34dbbcb" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">如果非空括号是 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 中唯一使用的通配符，则不匹配任何文件名，但可能返回许多字符串。例如，这产生了九个字符串，每对水果和颜色配对一个：</target>
        </trans-unit>
        <trans-unit id="1328c99f7fc26be401ecc4c3daf8d11e272b065b" translate="yes" xml:space="preserve">
          <source>If non-empty braces are the only wildcard characters used in the &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, no filenames are matched, but potentially many strings are returned. For example, this produces nine strings, one for each pairing of fruits and colors:</source>
          <target state="translated">如果非空括号是 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 中唯一使用的通配符，则不匹配任何文件名，但可能返回许多字符串。例如，这产生了九个字符串，每对水果和颜色配对一个：</target>
        </trans-unit>
        <trans-unit id="cf3289643abb0e0247bc66bf82c16e180f16eb54" translate="yes" xml:space="preserve">
          <source>If none of the above apply, for backwards compatibility reasons, the &lt;code&gt;/d&lt;/code&gt; modifier is the one in effect by default. As this can lead to unexpected results, it is best to specify which other rule set should be used.</source>
          <target state="translated">如果以上都不适用，则出于向后兼容的原因， &lt;code&gt;/d&lt;/code&gt; 修饰符默认为有效。由于这可能会导致意外结果，因此最好指定应使用哪个其他规则集。</target>
        </trans-unit>
        <trans-unit id="c4f8a0262880dda1d52bfe8a37ad85562f38ba99" translate="yes" xml:space="preserve">
          <source>If none of the settings are enabled or the respective methods are missing, &lt;code&gt;JSON::PP&lt;/code&gt; throws an exception.</source>
          <target state="translated">如果未启用任何设置或缺少相应的方法，则 &lt;code&gt;JSON::PP&lt;/code&gt; 会引发异常。</target>
        </trans-unit>
        <trans-unit id="ca7c7d8696c46f8858c11c99d7d1a93c5e34454b" translate="yes" xml:space="preserve">
          <source>If none of the three command line flags (&lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt;) that control warnings is used and neither &lt;code&gt;$^W&lt;/code&gt; nor the &lt;code&gt;warnings&lt;/code&gt; pragma are used, then default warnings will be enabled and optional warnings disabled. This means that legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">如果没有使用用于控制警告的三个命令行标志（&lt;b&gt;-w&lt;/b&gt;，&lt;b&gt;-W&lt;/b&gt;或&lt;b&gt;-X&lt;/b&gt;），并且未使用 &lt;code&gt;$^W&lt;/code&gt; 或 &lt;code&gt;warnings&lt;/code&gt; 编译指示，则将启用默认警告，并禁用可选警告。这意味着不尝试控制警告的旧代码将保持不变。</target>
        </trans-unit>
        <trans-unit id="3318e55dc39962c8bcf2ab6429b4489bcf36fce0" translate="yes" xml:space="preserve">
          <source>If none of those language-tags leads to loadable classes, we then try classes derived from YourProjClass-&amp;gt;fallback_languages() and then if nothing comes of that, we use classes named by YourProjClass-&amp;gt;fallback_language_classes(). Then in the (probably quite unlikely) event that that fails, we just return undef.</source>
          <target state="translated">如果这些语言标签都没有导致可加载的类，则尝试使用从YourProjClass-&amp;gt; fallback_languages（）派生的类，然后如果没有任何结果，则使用由YourProjClass-&amp;gt; fallback_language_classes（）命名的类。然后，在失败的（可能非常不可能的）事件中，我们只返回undef。</target>
        </trans-unit>
        <trans-unit id="92205bb5b979576b7a4566bdd880e8993ef8accb" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section</source>
          <target state="translated">如果不是0,那么它将是子程序返回的项目数。这些项目将被存储在Perl栈中。这一节</target>
        </trans-unit>
        <trans-unit id="59c73f98889212850b2a78b85e24e752ffbdf926" translate="yes" xml:space="preserve">
          <source>If not 0, then it will be a count of the number of items returned by the subroutine. These items will be stored on the Perl stack. The section &lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;&quot;Returning a List of Values&quot;&lt;/a&gt; gives an example of using the G_ARRAY flag and the mechanics of accessing the returned items from the Perl stack.</source>
          <target state="translated">如果不为0，则它​​将是该子例程返回的项目数的计数。这些项目将存储在Perl堆栈中。节&lt;a href=&quot;#Returning-a-List-of-Values&quot;&gt;的&amp;ldquo;返回值列表&amp;rdquo;&lt;/a&gt;提供了使用G_ARRAY标志和访问来自Perl的栈返回的项的力学的一个例子。</target>
        </trans-unit>
        <trans-unit id="15089e00b79e7ab36a4d99102807c33fe5f2fa61" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">如果尚未进行线程共享，则将其他复杂数据类型（如果需要，将以递归方式克隆，包括任何 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 和只读设置）克隆到线程共享结构中，然后再放入队列中。</target>
        </trans-unit>
        <trans-unit id="bd2af9d148c476fa264b6faed90957e58a463b95" translate="yes" xml:space="preserve">
          <source>If not already thread-shared, the other complex data types will be cloned (recursively, if needed, and including any &lt;code&gt;bless&lt;/code&gt;ings and read-only settings) into thread-shared structures before being placed onto a queue.</source>
          <target state="translated">如果尚未进行线程共享，则将其他复杂数据类型（如果需要的话，将以递归方式克隆，包括任何 &lt;code&gt;bless&lt;/code&gt; 和只读设置）克隆到线程共享结构中，然后再放入队列中。</target>
        </trans-unit>
        <trans-unit id="68037dc7029dc4e3c365e1435ac66af09bfe7401" translate="yes" xml:space="preserve">
          <source>If not defined, the socket option will not be changed, and default value set by the operating system will apply. For repeatable behaviour across platforms it is recommended this value always be defined for listening-mode sockets.</source>
          <target state="translated">如果没有定义,套接字选项将不会被改变,操作系统设置的默认值将被应用。为了实现跨平台的可重复行为,建议对监听模式的套接字始终定义这个值。</target>
        </trans-unit>
        <trans-unit id="3e6242ea32a785a3ff0172e42255ea915052f271" translate="yes" xml:space="preserve">
          <source>If not explicitly stated, the thread's context is implied from the context of the &lt;code&gt;-&amp;gt;create()&lt;/code&gt; call:</source>
          <target state="translated">如果未明确说明，则从 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 调用的上下文隐含线程的上下文：</target>
        </trans-unit>
        <trans-unit id="546f552a865a929b4eb67739806b6d1165a21c9a" translate="yes" xml:space="preserve">
          <source>If not present or if it returns false, then the stream is left with the UTF-8 flag clear. The</source>
          <target state="translated">如果不存在或返回false,那么流将以UTF-8标志清除。列表中的</target>
        </trans-unit>
        <trans-unit id="2aa39c0e8f5ce84edfe0042135e7b88219cc53b5" translate="yes" xml:space="preserve">
          <source>If not specified, this parameter defaults to the OS code of the Operating System this module was built on. The value 3 is used as a catch-all for all Unix variants and unknown Operating Systems.</source>
          <target state="translated">如果没有指定,这个参数默认为这个模块所基于的操作系统的代码。值为3的时候,是对所有Unix变体和未知操作系统的统称。</target>
        </trans-unit>
        <trans-unit id="5be9107047108eada41300dc934c5b436deb60f0" translate="yes" xml:space="preserve">
          <source>If not successful &lt;code&gt;$status&lt;/code&gt; will hold the</source>
          <target state="translated">如果不成功， &lt;code&gt;$status&lt;/code&gt; 将保留</target>
        </trans-unit>
        <trans-unit id="aff9c9f30e8137171bc8ec7e751402e0d4e840fb" translate="yes" xml:space="preserve">
          <source>If not successful, &lt;code&gt;$i&lt;/code&gt; will be</source>
          <target state="translated">如果不成功， &lt;code&gt;$i&lt;/code&gt; 将是</target>
        </trans-unit>
        <trans-unit id="b50aafa5c3c8fb148f77f7f985f1a7044430dc1d" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">如果失败，则返回的压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="12b14a0f96d5dc839995d0658014681616dce040" translate="yes" xml:space="preserve">
          <source>If not successful, the returned compression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="translated">如果未成功，则返回的压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="e8abade20743149de14f55b6a98559ef8ef9d29a" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt; , will be</source>
          <target state="translated">如果失败，则返回的通缩对象 &lt;code&gt;$d&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="a55077829587b52f718a05dd4622ff7cb59c31d0" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation object, &lt;code&gt;$d&lt;/code&gt;, will be</source>
          <target state="translated">如果失败，则返回的通缩对象 &lt;code&gt;$d&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="98576d6e30e44a960914f7dcf4587ee17092e2df" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt; ) will be</source>
          <target state="translated">如果未成功，则返回的放气流（ &lt;code&gt;$d&lt;/code&gt; ）将是</target>
        </trans-unit>
        <trans-unit id="31b0629650565b4db9feee16aed7f875e955eba9" translate="yes" xml:space="preserve">
          <source>If not successful, the returned deflation stream (&lt;code&gt;$d&lt;/code&gt;) will be</source>
          <target state="translated">如果未成功，则返回的通货紧缩流（ &lt;code&gt;$d&lt;/code&gt; ）将是</target>
        </trans-unit>
        <trans-unit id="b7bd4ba1b78daba8a26ec4a9a7d4b9cf1b5da29e" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt; , will be</source>
          <target state="translated">如果未成功，则返回的解压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="ff81451b912d52c5c65d903982a9c2e6578403e7" translate="yes" xml:space="preserve">
          <source>If not successful, the returned uncompression object, &lt;code&gt;$z&lt;/code&gt;, will be</source>
          <target state="translated">如果未成功，则返回的解压缩对象 &lt;code&gt;$z&lt;/code&gt; 将为</target>
        </trans-unit>
        <trans-unit id="5c88e7dc3b6ede485e4fd5bdcc2d18ce257150ea" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the source is treated as ASCII + 128 extra controls, and identifiers should match</source>
          <target state="translated">如果不 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，则将源视为ASCII + 128个额外的控件，并且标识符应匹配</target>
        </trans-unit>
        <trans-unit id="6275358c6fb498ac9c62eac9a2037ee571ebd990" translate="yes" xml:space="preserve">
          <source>If not under &lt;code&gt;use utf8&lt;/code&gt;, the source is treated as ASCII + 128 extra generic characters, and identifiers should match</source>
          <target state="translated">如果未 &lt;code&gt;use utf8&lt;/code&gt; ，则将源视为ASCII + 128个额外的通用字符，并且标识符应匹配</target>
        </trans-unit>
        <trans-unit id="adf92a54eaec2aef254d98d2b3572cf157430f6f" translate="yes" xml:space="preserve">
          <source>If not, you can use a Fisher-Yates shuffle.</source>
          <target state="translated">如果没有,你可以用Fisher-Yates洗牌。</target>
        </trans-unit>
        <trans-unit id="63aa47bb8d880da4c29744c1e2b5b0be9d2d8c10" translate="yes" xml:space="preserve">
          <source>If not, you may need to dig in the indices to find it in the directory of the current maintainer.</source>
          <target state="translated">如果没有,你可能需要在当前维护者的目录中挖掘索引来找到它。</target>
        </trans-unit>
        <trans-unit id="86c0e89f96b9aaaff68e6f577691cea5717917d9" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the description is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="translated">如果ob为真且SV为福,则说明是类名,否则是SV的类型,&quot;SCALAR&quot;、&quot;ARRAY &quot;等。</target>
        </trans-unit>
        <trans-unit id="89bf684ef82a39d22f842daf13f965778d5ecf34" translate="yes" xml:space="preserve">
          <source>If ob is true and the SV is blessed, the string is the class name, otherwise it is the type of the SV, &quot;SCALAR&quot;, &quot;ARRAY&quot; etc.</source>
          <target state="translated">如果ob为真且SV为福,则该字符串为类名,否则为SV的类型,&quot;SCALAR&quot;、&quot;ARRAY &quot;等。</target>
        </trans-unit>
        <trans-unit id="e3dd66c8bbe90e184bf0c3b78ff920f066856ccf" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt; , triggering the previously described</source>
          <target state="translated">如果省略，则PATTERN默认为单个空格 &lt;code&gt;&quot; &quot;&lt;/code&gt; ，从而触发前述</target>
        </trans-unit>
        <trans-unit id="48ccc574ab641252333c06cf11483c32d32127b7" translate="yes" xml:space="preserve">
          <source>If omitted, PATTERN defaults to a single space, &lt;code&gt;&quot; &quot;&lt;/code&gt;, triggering the previously described</source>
          <target state="translated">如果省略，则PATTERN默认为单个空格 &lt;code&gt;&quot; &quot;&lt;/code&gt; ，从而触发先前描述的</target>
        </trans-unit>
        <trans-unit id="9db6f61ce06c88ac7402efe003ec5c4f69fd8d53" translate="yes" xml:space="preserve">
          <source>If omitted, the maximum is the 4th.</source>
          <target state="translated">如果省略,最大的是第4个。</target>
        </trans-unit>
        <trans-unit id="8cf02da092076b8bc64e89cb4d51247518c5d4fc" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt; , which will lead to an infinite loop.</source>
          <target state="translated">如果尝试打印此值，则将调用重载的运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，这将调用 &lt;code&gt;nomethod&lt;/code&gt; 运算符。该运算符的结果将再次被字符串化，但是该结果再次为 &lt;code&gt;symbolic&lt;/code&gt; 类型，这将导致无限循环。</target>
        </trans-unit>
        <trans-unit id="d9a4c46026548a387f73d613ce2e2d57e8735167" translate="yes" xml:space="preserve">
          <source>If one attempts to print this value, then the overloaded operator &lt;code&gt;&quot;&quot;&lt;/code&gt; will be called, which will call &lt;code&gt;nomethod&lt;/code&gt; operator. The result of this operator will be stringified again, but this result is again of type &lt;code&gt;symbolic&lt;/code&gt;, which will lead to an infinite loop.</source>
          <target state="translated">如果尝试打印此值，则将调用重载的运算符 &lt;code&gt;&quot;&quot;&lt;/code&gt; ，这将调用 &lt;code&gt;nomethod&lt;/code&gt; 运算符。该运算符的结果将再次被字符串化，但是该结果再次为 &lt;code&gt;symbolic&lt;/code&gt; 类型，这将导致无限循环。</target>
        </trans-unit>
        <trans-unit id="e1adcb84ff8cdfac7bb94b3520eb9afd47061bae" translate="yes" xml:space="preserve">
          <source>If one can be sure that a particular program is a Perl script expecting filenames in @ARGV, the clever programmer can write something like this:</source>
          <target state="translated">如果可以确定某个程序是一个期望以@ARGV为文件名的Perl脚本,聪明的程序员可以写出这样的东西。</target>
        </trans-unit>
        <trans-unit id="b9a4785b4cb95e8fee7a09364380427defe0f204" translate="yes" xml:space="preserve">
          <source>If one is compiling Perl with the &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; the &lt;code&gt;dVAR&lt;/code&gt; definition is needed if the Perl global variables (see</source>
          <target state="translated">如果一个与编译的Perl &lt;code&gt;-DPERL_GLOBAL_STRUCT&lt;/code&gt; 的 &lt;code&gt;dVAR&lt;/code&gt; 需要，如果Perl的全局变量定义（见</target>
        </trans-unit>
        <trans-unit id="e3e822ed5577ab52cc19452e08717fd8eeaeaafa" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt; , one can substitute the name of the length-argument by &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">如果C函数的输入参数之一是字符串参数 &lt;code&gt;NAME&lt;/code&gt; 的长度，则可以在XSUB声明中用 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; 替换长度参数的名称。调用生成的Perl函数时，必须忽略此参数。例如，</target>
        </trans-unit>
        <trans-unit id="9ecfea0dc1bd53f365a6275977cf6664ba11e8c2" translate="yes" xml:space="preserve">
          <source>If one of the input arguments to the C function is the length of a string argument &lt;code&gt;NAME&lt;/code&gt;, one can substitute the name of the length-argument by &lt;code&gt;length(NAME)&lt;/code&gt; in the XSUB declaration. This argument must be omitted when the generated Perl function is called. E.g.,</source>
          <target state="translated">如果C函数的输入参数之一是字符串参数 &lt;code&gt;NAME&lt;/code&gt; 的长度，则可以在XSUB声明中用 &lt;code&gt;length(NAME)&lt;/code&gt; 替换长度参数的名称。调用生成的Perl函数时，必须忽略此参数。例如，</target>
        </trans-unit>
        <trans-unit id="80356b3107601264757c736090081f30d00dbd0c" translate="yes" xml:space="preserve">
          <source>If one of the values is the string &quot;FATAL&quot;, then all the warnings in that list will be considered fatal, just as with the &lt;b&gt;warnings&lt;/b&gt; pragma itself. Should you need to specify that some warnings are fatal, and others are merely enabled, you can pass the &lt;b&gt;warnings&lt;/b&gt; parameter twice:</source>
          <target state="translated">如果值之一是字符串&amp;ldquo; FATAL&amp;rdquo;，则该列表中的所有警告都将被视为致命&lt;b&gt;警告&lt;/b&gt;，就像&lt;b&gt;警告&lt;/b&gt;杂注本身一样。如果您需要指定某些警告是致命的，而其他警告仅被启用，则可以两次传递&lt;b&gt;警告&lt;/b&gt;参数：</target>
        </trans-unit>
        <trans-unit id="58b3d6b8eb5c53fb4bf738ec026bd17996fb8d7b" translate="yes" xml:space="preserve">
          <source>If one wants to use pure Perl and to be compatible with Perl versions prior to 5.10, the general answer is to use &lt;code&gt;if-elsif-else&lt;/code&gt;:</source>
          <target state="translated">如果要使用纯Perl并与5.10之前的Perl版本兼容，通常的答案是使用 &lt;code&gt;if-elsif-else&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4cca592d5a52d0591c75e10935311d781bcd5906" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果仅给出PATTERN，则EXPR默认为&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="12b8235b34f1e041150a031d0b9fbd780bdea304" translate="yes" xml:space="preserve">
          <source>If only PATTERN is given, EXPR defaults to &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果仅给出PATTERN，则EXPR默认为 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b59bbcd014d4d50d7bf3779e9aa4f7e93178c1ba" translate="yes" xml:space="preserve">
          <source>If only a filename is available, the following approach may be used:</source>
          <target state="translated">如果只有一个文件名,可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="63b33dab707b9e6e2b41538d9f24bfd52b59d430" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also set &lt;code&gt;$uFlags&lt;/code&gt; to include &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="translated">如果打开命名管道的客户端，则还可以设置 &lt;code&gt;$uFlags&lt;/code&gt; 包括 &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; 以及其他 &lt;code&gt;SECURITY_*&lt;/code&gt; 常量之一，以指定要使用的服务的安全质量。</target>
        </trans-unit>
        <trans-unit id="19f62f719bae656eebb99613fc3c3f5af6bf3f5f" translate="yes" xml:space="preserve">
          <source>If opening the client side of a named pipe, then you can also specify &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; along with one of the other &lt;code&gt;SECURITY_*&lt;/code&gt; constants to specify the security quality of service to be used.</source>
          <target state="translated">如果打开命名管道的客户端，则还可以指定 &lt;code&gt;SECURITY_SQOS_PRESENT&lt;/code&gt; 以及其他 &lt;code&gt;SECURITY_*&lt;/code&gt; 常量之一，以指定要使用的服务的安全质量。</target>
        </trans-unit>
        <trans-unit id="16392afc89510c0fc9dd7ff46ccb0d1b3e97fcef" translate="yes" xml:space="preserve">
          <source>If other charset support is needed, please file a bug report against CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend the support or maybe UTF-8 terminals become widely available.</source>
          <target state="translated">如果需要其他的字符集支持,请在rt.cpan.org上针对CPAN.pm提交一个bug报告,并描述你的需求。也许我们可以扩大支持范围,或者UTF-8终端变得更广泛。</target>
        </trans-unit>
        <trans-unit id="a07176206cda4e320bb3d161ccf541de7489aeb9" translate="yes" xml:space="preserve">
          <source>If our include file had contained #include directives, these would not have been processed by h2xs. There is no good solution to this right now.</source>
          <target state="translated">如果我们的include文件包含了#include指令,这些指令就不会被h2xs处理。现在还没有很好的解决办法。</target>
        </trans-unit>
        <trans-unit id="1342cd54e96ee75c7832a17e50d7545968334b8a" translate="yes" xml:space="preserve">
          <source>If parse errors are found in the TAP output, a note of this will be made in the summary report. To see all of the parse errors, set this argument to true:</source>
          <target state="translated">如果在TAP输出中发现了解析错误,将在摘要报告中进行说明。要查看所有的解析错误,请将此参数设置为true。</target>
        </trans-unit>
        <trans-unit id="390961095f8040e196a232b583180a54cb19ea61" translate="yes" xml:space="preserve">
          <source>If passed a filehandle will write a copy of all parsed TAP to that handle.</source>
          <target state="translated">如果传递一个filehandle,将把所有解析过的TAP的副本写入该handle。</target>
        </trans-unit>
        <trans-unit id="5a4f883097b033ba66596455cc092c01c5e9be39" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt;, and then &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">如果性能是一个问题，并且您不关心输出是否与输入相同，请使用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 转换为数据中最常用的情况。如果数据主要是大写非Latin1，则应用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[a-z]/[A-Z]/&lt;/a&gt;&lt;/code&gt; ，然后应用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 。如果数据主要是小写的非Latin1，则在排序之前应用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/[A-Z]/[a-z]/&lt;/a&gt;&lt;/code&gt; 。如果数据主要是大写并包含Latin-1字符，则适用：</target>
        </trans-unit>
        <trans-unit id="9462aa1810ea1a2dacbf899e5d319c5498156bac" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and you don't care if the output is in the same case as the input, Use &lt;code&gt;tr///&lt;/code&gt; to transform to the case most employed within the data. If the data are primarily UPPERCASE non-Latin1, then apply &lt;code&gt;tr/[a-z]/[A-Z]/&lt;/code&gt;, and then &lt;code&gt;sort()&lt;/code&gt;. If the data are primarily lowercase non Latin1 then apply &lt;code&gt;tr/[A-Z]/[a-z]/&lt;/code&gt; before sorting. If the data are primarily UPPERCASE and include Latin-1 characters then apply:</source>
          <target state="translated">如果性能是一个问题，并且您不关心输出是否与输入大小写相同，请使用 &lt;code&gt;tr///&lt;/code&gt; 转换为数据中最常用的大小写。如果数据主要是大写而非Latin1，则应用 &lt;code&gt;tr/[a-z]/[A-Z]/&lt;/code&gt; ，然后应用 &lt;code&gt;sort()&lt;/code&gt; 。如果数据主要是小写的非Latin1，则在排序之前应用 &lt;code&gt;tr/[A-Z]/[a-z]/&lt;/code&gt; 。如果数据主要是大写并包含Latin-1字符，则适用：</target>
        </trans-unit>
        <trans-unit id="751a8c8edea51ef360f8293f82ac9e36b697517a" translate="yes" xml:space="preserve">
          <source>If perl has been configured to not have the current directory in &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; by default, this variable can be set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; to reinstate it. It's primarily intended for use while building and testing modules that have not been updated to deal with &quot;.&quot; not being in &lt;code&gt;@INC&lt;/code&gt; and should not be set in the environment for day-to-day use.</source>
          <target state="translated">如果默认情况下已将perl配置为在&lt;a href=&quot;perlvar#%40INC&quot;&gt; &lt;code&gt;@INC&lt;/code&gt; 中&lt;/a&gt;不具有当前目录，则可以将该变量设置为 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 以将其恢复。它主要用于构建和测试尚未更新以处理&amp;ldquo;。&amp;rdquo;的模块。不在 &lt;code&gt;@INC&lt;/code&gt; 中,并且不应将其设置在日常使用的环境中。</target>
        </trans-unit>
        <trans-unit id="ab79de5389c6af407dc202c7877566f66fb7264b" translate="yes" xml:space="preserve">
          <source>If perl has not yet been installed then PERL_SRC can be defined on the command line as shown in the previous section.</source>
          <target state="translated">如果perl还没有安装,那么PERL_SRC可以在命令行中定义,如上一节所示。</target>
        </trans-unit>
        <trans-unit id="527ed5a2bdcdb5849d3d992698d64bca35b1da28" translate="yes" xml:space="preserve">
          <source>If perl is invoked using the &lt;b&gt;-e&lt;/b&gt; option or the perl script is read from &lt;code&gt;STDIN&lt;/code&gt; then FindBin sets both &lt;code&gt;$Bin&lt;/code&gt; and &lt;code&gt;$RealBin&lt;/code&gt; to the current directory.</source>
          <target state="translated">如果使用&lt;b&gt;-e&lt;/b&gt;选项调用perl 或从 &lt;code&gt;STDIN&lt;/code&gt; 读取perl脚本，则FindBin会将 &lt;code&gt;$Bin&lt;/code&gt; 和 &lt;code&gt;$RealBin&lt;/code&gt; 设置为当前目录。</target>
        </trans-unit>
        <trans-unit id="c28bb9f5b57ae9540614c1c058beb6e3302cae11" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see</source>
          <target state="translated">如果正确安装了perl并正确编写了影子库，则理论上&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;中描述的 &lt;code&gt;getpw*()&lt;/code&gt; 函数应提供对影子密码文件中条目的（只读）访问权限。要更改文件，请制作一个新的影子密码文件（格式因系统而异-请参阅</target>
        </trans-unit>
        <trans-unit id="eba76bf8bea1221ff81d36866fefb38b38f1c83e" translate="yes" xml:space="preserve">
          <source>If perl was installed correctly and your shadow library was written properly, the &lt;code&gt;getpw*()&lt;/code&gt; functions described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; should in theory provide (read-only) access to entries in the shadow password file. To change the file, make a new shadow password file (the format varies from system to system--see &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd(1)&lt;/a&gt; for specifics) and use &lt;code&gt;pwd_mkdb(8)&lt;/code&gt; to install it (see &lt;a href=&quot;http://man.he.net/man8/pwd_mkdb&quot;&gt;pwd_mkdb(8)&lt;/a&gt; for more details).</source>
          <target state="translated">如果正确安装了perl并正确编写了影子库，则理论上&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;中描述的 &lt;code&gt;getpw*()&lt;/code&gt; 函数应提供对影子密码文件中条目的（只读）访问权限。要更改该文件，请创建一个新的影子密码文件（格式因系统而异，有关详细信息，请参见&lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd（1）&lt;/a&gt;），然后使用 &lt;code&gt;pwd_mkdb(8)&lt;/code&gt; 进行安装（有关更多详细信息，请参见&lt;a href=&quot;http://man.he.net/man8/pwd_mkdb&quot;&gt;pwd_mkdb（8）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4aa77499616bd2f38224ed594fc316a580948f20" translate="yes" xml:space="preserve">
          <source>If possible, move() will simply rename the file. Otherwise, it copies the file to the new location and deletes the original. If an error occurs during this copy-and-delete process, you may be left with a (possibly partial) copy of the file under the destination name.</source>
          <target state="translated">如果可能的话,move()会简单地重命名文件。否则,它会将文件复制到新的位置,并删除原来的文件。如果在这个复制和删除过程中发生错误,你可能会留下一个(可能是部分)目标名称下的文件副本。</target>
        </trans-unit>
        <trans-unit id="2306ef44bf2f2a60c7ac6a896505074bcea6c96c" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. Follow the instructions and links on:</source>
          <target state="translated">如有可能,在CPAN注册该模块。遵循下列指示和链接:</target>
        </trans-unit>
        <trans-unit id="821e3f8f257e241afb18f9d12ceda656792b21cb" translate="yes" xml:space="preserve">
          <source>If possible, register the module with CPAN. You should include details of its location in your announcement.</source>
          <target state="translated">如有可能,请在CPAN登记该模块。您应在公告中详细说明该模块的位置。</target>
        </trans-unit>
        <trans-unit id="00df1bad6fa3810b7a0fb796a7103c7f28a05f8c" translate="yes" xml:space="preserve">
          <source>If possible, this form should be used to prevent possible race conditions.</source>
          <target state="translated">如果可能的话,应该使用这种形式,以防止可能的比赛条件。</target>
        </trans-unit>
        <trans-unit id="34d4da8aa87987ec9ceda1c43801e78b64cdc28a" translate="yes" xml:space="preserve">
          <source>If present on a regex, &lt;code&gt;&quot;#&quot;&lt;/code&gt; comments will be handled differently by the tokenizer in some cases.</source>
          <target state="translated">如果出现在正则表达式上，则在某些情况下，令牌处理程序将对 &lt;code&gt;&quot;#&quot;&lt;/code&gt; 注释进行不同的处理。</target>
        </trans-unit>
        <trans-unit id="fcb106d01e2834098b09ad25220c5df2510aa768" translate="yes" xml:space="preserve">
          <source>If present, $hints should be a reference to a hash, where the following keys are recognised:</source>
          <target state="translated">如果存在的话,$hints应该是一个哈希值的引用,在这个哈希值中,可以识别以下键。</target>
        </trans-unit>
        <trans-unit id="768b78e920d55b41dde42ac4d330e515e86f1cd7" translate="yes" xml:space="preserve">
          <source>If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used:</source>
          <target state="translated">如果存在，则使用 &lt;code&gt;run&lt;/code&gt; 方法时，将使用结果作为参数调用与给定结果类型相对应的每个回调：</target>
        </trans-unit>
        <trans-unit id="80e76146570d6b35c93035dd97f6090cb9b7cbba" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store all files and directories unlinked during the call. If nothing is unlinked, the array will be empty.</source>
          <target state="translated">如果存在,它应该是一个标量的引用。这个标量将被用来引用一个数组,该数组将用于存储在调用过程中未链接的所有文件和目录。如果没有任何未链接的内容,那么数组将是空的。</target>
        </trans-unit>
        <trans-unit id="865f6f3c95c9ee0c681ecdf2cdcadf01272955ae" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;&quot;ERROR HANDLING&quot;&lt;/a&gt; section for more information.</source>
          <target state="translated">如果存在，则应引用标量。将使这个标量引用一个数组，该数组将用于存储遇到的任何错误。有关更多信息，请参见&lt;a href=&quot;#ERROR-HANDLING&quot;&gt;&amp;ldquo;错误处理&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="eaf6326ff6faceb306eebc039298d3cef21ae0f2" translate="yes" xml:space="preserve">
          <source>If present, it should be a reference to a scalar. This scalar will be made to reference an array, which will be used to store any errors that are encountered. See the &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;ERROR HANDLING&lt;/a&gt; section for more information.</source>
          <target state="translated">如果存在，则应引用标量。将使这个标量引用一个数组，该数组将用于存储遇到的任何错误。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;#ERROR-HANDLING&quot;&gt;错误处理&amp;rdquo;&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="28236ec2fcbd77071db6f4df51ebe2ad1353410f" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;make_path&lt;/code&gt; to print the name of each directory as it is created. By default nothing is printed.</source>
          <target state="translated">如果存在，将使 &lt;code&gt;make_path&lt;/code&gt; 在创建每个目录时显示其名称。默认情况下，不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="ba616b58ac8bd248e0e92e90224a9f0e82a7126d" translate="yes" xml:space="preserve">
          <source>If present, will cause &lt;code&gt;remove_tree&lt;/code&gt; to print the name of each file as it is unlinked. By default nothing is printed.</source>
          <target state="translated">如果存在，将导致 &lt;code&gt;remove_tree&lt;/code&gt; 打印每个未链接的文件的名称。默认情况下，不打印任何内容。</target>
        </trans-unit>
        <trans-unit id="da38e80a5de666bdd4124bbd72eac17c8b7acaf5" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt; . If the value is numeric, it will be interpreted as a uid, otherwise as username is assumed. An error will be issued if the username cannot be mapped to a uid, or the uid does not exist, or the process lacks the privileges to change ownership.</source>
          <target state="translated">如果存在，将导致任何创建的目录归 &lt;code&gt;$owner&lt;/code&gt; 。如果值为数字，则将其解释为uid，否则假定为username。如果用户名无法映射到uid，或者uid不存在，或者进程缺少更改所有权的特权，将发出错误。</target>
        </trans-unit>
        <trans-unit id="0ff53c547d7a4dd3bf846157fd728900f2d937f3" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by &lt;code&gt;$owner&lt;/code&gt;. If the value is numeric, it will be interpreted as a uid; otherwise a username is assumed. An error will be issued if the username cannot be mapped to a uid, the uid does not exist or the process lacks the privileges to change ownership.</source>
          <target state="translated">如果存在，将导致任何创建的目录归 &lt;code&gt;$owner&lt;/code&gt; 。如果值为数字，则将其解释为uid；否则，将其解释为uid。否则，假定使用用户名。如果用户名无法映射到uid，uid不存在或进程缺少更改所有权的特权，则将发出错误。</target>
        </trans-unit>
        <trans-unit id="c6bc6a6c714ec1098b00e8f4665bf29765d41191" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt; . If the value is numeric, it will be interpreted as a gid, otherwise as group name is assumed. An error will be issued if the group name cannot be mapped to a gid, or the gid does not exist, or the process lacks the privileges to change group ownership.</source>
          <target state="translated">如果存在，将使所有创建的目录归组 &lt;code&gt;$group&lt;/code&gt; 拥有。如果值为数字，则将其解释为gid，否则假定为组名。如果无法将组名映射到一个gid，或者该gid不存在，或者该进程缺少更改组所有权的特权，则将发出错误。</target>
        </trans-unit>
        <trans-unit id="5ebd22cc8259df10471aba5e6db2f4331d3b55f7" translate="yes" xml:space="preserve">
          <source>If present, will cause any created directory to be owned by the group &lt;code&gt;$group&lt;/code&gt;. If the value is numeric, it will be interpreted as a gid; otherwise a group name is assumed. An error will be issued if the group name cannot be mapped to a gid, the gid does not exist or the process lacks the privileges to change group ownership.</source>
          <target state="translated">如果存在，将使所有创建的目录归组 &lt;code&gt;$group&lt;/code&gt; 拥有。如果该值为数字，则将其解释为gid；否则为false。否则，假定为组名。如果不能将组名映射到一个gid，该gid不存在或该进程缺少更改组所有权的特权，则将发出错误。</target>
        </trans-unit>
        <trans-unit id="a365bb62991d043cada86ad3beb15687e9b5977b" translate="yes" xml:space="preserve">
          <source>If program usage has been explicitly requested by the user, it is often desirable to exit with a status of 1 (as opposed to 0) after issuing the user-requested usage message. It is also desirable to give a more verbose description of program usage in this case.</source>
          <target state="translated">如果程序的使用是由用户明确要求的,那么在发出用户要求的使用信息后,通常最好以状态为1(而不是0)退出。在这种情况下,也最好对程序使用情况进行更详细的描述。</target>
        </trans-unit>
        <trans-unit id="8bf641be539c33c01972d9eed772b4572f957d25" translate="yes" xml:space="preserve">
          <source>If provided, this argument will place the socket into listening mode. New connections can then be accepted using the &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; method. The value given is used as the &lt;code&gt;listen(2)&lt;/code&gt; queue size.</source>
          <target state="translated">如果提供，则此参数将使套接字进入侦听模式。然后可以使用&lt;a href=&quot;IO::Socket#accept&quot;&gt;IO :: Socket&lt;/a&gt;方法中的&amp;ldquo;接受&amp;rdquo;来接受新的连接。给定的值用作 &lt;code&gt;listen(2)&lt;/code&gt; 队列大小。</target>
        </trans-unit>
        <trans-unit id="ff3608d191706961b1f05c1c4d43ca10631cdf8b" translate="yes" xml:space="preserve">
          <source>If run on any operating system other than Windows, this will import the functions &lt;code&gt;setlocale&lt;/code&gt; and &lt;code&gt;LC_ALL&lt;/code&gt; from &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;. On Windows it does nothing.</source>
          <target state="translated">如果在Windows以外的任何操作系统上运行，这将从&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;导入功能 &lt;code&gt;setlocale&lt;/code&gt; 和 &lt;code&gt;LC_ALL&lt;/code&gt; 。在Windows上不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="9d9d2ff0e902fe5020fe3d38bdc23ea71c9ea208" translate="yes" xml:space="preserve">
          <source>If run with no arguments, filters standard input to standard output.</source>
          <target state="translated">如果运行时没有参数,则将标准输入过滤为标准输出。</target>
        </trans-unit>
        <trans-unit id="53f4c878607755d2bdfa2564e4393c026538b21e" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if $ENV{TMPDIR} is tainted, it is not used.</source>
          <target state="translated">如果在污点模式下运行,并且如果$ENV{TMPDIR}被污点,则不使用它。</target>
        </trans-unit>
        <trans-unit id="c028c3067c9e1833a7b2f721beaf502c1d3b87c3" translate="yes" xml:space="preserve">
          <source>If running under taint mode, and if the environment variables are tainted, they are not used.</source>
          <target state="translated">如果在污点模式下运行,且环境变量被污点,则不使用这些变量。</target>
        </trans-unit>
        <trans-unit id="bc42709752d603d6e86a31cea878bd9ef78c5a40" translate="yes" xml:space="preserve">
          <source>If safety matters to you (and why else would you be using the Opcode module?) then you should not rely on the definition of this, or indeed any other, optag!</source>
          <target state="translated">如果安全对您来说很重要(否则您为什么要使用Opcode模块?),那么您就不应该依赖这个或任何其他opag的定义!</target>
        </trans-unit>
        <trans-unit id="84fe2228be06f7c485981c30717e0cd96c85c324" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">如果设置，则 &lt;code&gt;formatter&lt;/code&gt; 必须是能够格式化TAP输出的对象。有关示例，请参见&lt;a href=&quot;TAP::Formatter::Console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c49a3b26a25358ee584c0e87edb350360c053486" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;formatter&lt;/code&gt; must be an object that is capable of formatting the TAP output. See &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt; for an example.</source>
          <target state="translated">如果设置，则 &lt;code&gt;formatter&lt;/code&gt; 必须是能够格式化TAP输出的对象。有关示例，请参见&lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d7e12ada666ebe5ce88788573ab7d416ccee0e3" translate="yes" xml:space="preserve">
          <source>If set and Encode is not available, silently fall back to non-UTF-8 mode without complaining to standard error. This environment variable is set during Perl core builds, which build Encode after podlators. Encode is expected to not (yet) be available in that case.</source>
          <target state="translated">如果设置了Encode,并且Encode不可用,就会默默地退回到非UTF-8模式,而不会向标准错误抱怨。这个环境变量是在Perl核心编译过程中设置的,它在podlators之后编译Encode。在这种情况下,Encode 应该是不可用的。</target>
        </trans-unit>
        <trans-unit id="cc6406e3d3c8ec686d43e0bd0630b45054571335" translate="yes" xml:space="preserve">
          <source>If set forward, the details of the missing tests are filled in as 'unknown'. if set backward, the details of the intervening tests are deleted. You can erase history if you really want to.</source>
          <target state="translated">如果向前设置,则将缺失的测试细节填写为 &quot;未知&quot;。如果向后设置,则删除中间测试的细节。如果你真的想删除历史记录,你可以删除。</target>
        </trans-unit>
        <trans-unit id="94a6b6735d1cf67d97faf5afa93385c976f8d9ca" translate="yes" xml:space="preserve">
          <source>If set to 'none', no man pages will be installed.</source>
          <target state="translated">如果设置为 &quot;无&quot;,则不会安装任何手册页。</target>
        </trans-unit>
        <trans-unit id="35193d3a52f1a67d3457cb0804a53caff3b762a2" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">如果设置为0，则 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法的输出参数的内容将被未压缩的数据覆盖。</target>
        </trans-unit>
        <trans-unit id="0eba3cfab3094093ee2a0a7a3f1a02110ff8208f" translate="yes" xml:space="preserve">
          <source>If set to 0, the contents of the output parameter of the &lt;code&gt;read&lt;/code&gt; method will be overwritten by the uncompressed data.</source>
          <target state="translated">如果设置为0，则 &lt;code&gt;read&lt;/code&gt; 方法的输出参数的内容将被未压缩的数据覆盖。</target>
        </trans-unit>
        <trans-unit id="63134c061d53f609b58fe4db77f806b2b217214c" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">如果设置为1，则所有未压缩的数据将附加到 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法的输出参数中。</target>
        </trans-unit>
        <trans-unit id="b9f5b0a88e94e90aa98c8ce846cf8f2a8299b4e1" translate="yes" xml:space="preserve">
          <source>If set to 1, all uncompressed data will be appended to the output parameter of the &lt;code&gt;read&lt;/code&gt; method.</source>
          <target state="translated">如果设置为1，则所有未压缩的数据将附加到 &lt;code&gt;read&lt;/code&gt; 方法的输出参数中。</target>
        </trans-unit>
        <trans-unit id="a99badbf73893e25506e2b45aeb306043f0421e4" translate="yes" xml:space="preserve">
          <source>If set to a true value instruct &lt;code&gt;TAP::Parser&lt;/code&gt; to ignore exit and wait status from test scripts.</source>
          <target state="translated">如果设置为真值，请指示 &lt;code&gt;TAP::Parser&lt;/code&gt; 忽略测试脚本的退出和等待状态。</target>
        </trans-unit>
        <trans-unit id="7addd0cdb6e060b7f425d641cdc5802f63dc6646" translate="yes" xml:space="preserve">
          <source>If set to a true value then MakeMaker's prompt function will always return the default without waiting for user input.</source>
          <target state="translated">如果设置为真值,那么MakeMaker的提示函数将始终返回默认值,而不需要等待用户输入。</target>
        </trans-unit>
        <trans-unit id="37acce4270c3ae4d059b2f5d5497684bcefbd070" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::PlainText will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">如果设置为true,Pod::PlainText将假设每个句子以两个空格结束,并将尝试保留该间距。如果设置为false,所有非逐字段落中的连续空白都会被压缩为一个空格。默认为true。</target>
        </trans-unit>
        <trans-unit id="9fb9b386eec98159e51954bb5d28974ecee8a0eb" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to false.</source>
          <target state="translated">如果设置为true,Pod::Text将假设每个句子以两个空格结束,并将尝试保留该间距。如果设置为false,所有非逐字段落中的连续空白都会被压缩为一个空格。默认值为false。</target>
        </trans-unit>
        <trans-unit id="a1e0bdf314190ede062d43bfa363f6d6ba57f992" translate="yes" xml:space="preserve">
          <source>If set to a true value, Pod::Text will assume that each sentence ends in two spaces, and will try to preserve that spacing. If set to false, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space. Defaults to true.</source>
          <target state="translated">如果设置为true,Pod::Text将假设每个句子以两个空格结束,并将尝试保留该间距。如果设置为false,所有非逐字段落中的连续空白都会被压缩为一个空格。默认值为true。</target>
        </trans-unit>
        <trans-unit id="c7ea67874e15073f2f8a8748dd116175b232517b" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt; , although one is still printed after &lt;code&gt;=head2&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">如果设置为true值，则在 &lt;code&gt;=head1&lt;/code&gt; 标题之后打印空白行。如果设置为false（缺省值），没有空行之后打印 &lt;code&gt;=head1&lt;/code&gt; ，虽然其中一个后仍印刷 &lt;code&gt;=head2&lt;/code&gt; 。这是默认设置，因为它是手册页的预期格式。如果您要格式化任意文本文档，则将其设置为true可能会导致更令人满意的输出。</target>
        </trans-unit>
        <trans-unit id="12cadcd0631c167f67b19339e2f3ebc608babfe8" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=head1&lt;/code&gt; heading. If set to false (the default), no blank line is printed after &lt;code&gt;=head1&lt;/code&gt;, although one is still printed after &lt;code&gt;=head2&lt;/code&gt;. This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">如果设置为true值，则在 &lt;code&gt;=head1&lt;/code&gt; 标题之后打印空白行。如果设置为false（缺省值），没有空行之后打印 &lt;code&gt;=head1&lt;/code&gt; ，虽然其中一个后仍印刷 &lt;code&gt;=head2&lt;/code&gt; 。这是默认设置，因为它是手册页的预期格式。如果您要格式化任意文本文档，则将其设置为true可能会导致更令人愉悦的输出。</target>
        </trans-unit>
        <trans-unit id="79c7d693600594b39fe949ae434a7a5fc8a792dc" translate="yes" xml:space="preserve">
          <source>If set to a true value, a blank line is printed after a &lt;code&gt;=headN&lt;/code&gt; headings. If set to false (the default), no blank line is printed after &lt;code&gt;=headN&lt;/code&gt; . This is the default because it's the expected formatting for manual pages; if you're formatting arbitrary text documents, setting this to true may result in more pleasing output.</source>
          <target state="translated">如果设置为true值，则在 &lt;code&gt;=headN&lt;/code&gt; 标题之后打印空白行。如果设置为false（默认值），则在 &lt;code&gt;=headN&lt;/code&gt; 之后不打印空白行。这是默认设置，因为它是手册页的预期格式。如果您要格式化任意文本文档，则将其设置为true可能会导致更令人满意的输出。</target>
        </trans-unit>
        <trans-unit id="3fb0153c7c54ce2bccc40f5b7e2d5aff19532ce7" translate="yes" xml:space="preserve">
          <source>If set to a true value, indicates to the debugger that the code being debugged uses threads.</source>
          <target state="translated">如果设置为真值,则向调试器表明被调试的代码使用了线程。</target>
        </trans-unit>
        <trans-unit id="e75bb2ef91a1a8c8b0ee4cbc07e5ef237213911f" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; , &lt;code&gt;failures&lt;/code&gt; , or &lt;code&gt;comments&lt;/code&gt; .</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; ， &lt;code&gt;failures&lt;/code&gt; 或 &lt;code&gt;comments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6403db7bde854649adecbe2fe72bc17d3ded2ac7" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt; .</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; 或 &lt;code&gt;failures&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5dc7bcb42a07b398704f1044000bc451673cf348" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt; or &lt;code&gt;failures&lt;/code&gt;.</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; 或 &lt;code&gt;failures&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56370371763a8fe8f684fb9af4f85fc5b478e2a6" translate="yes" xml:space="preserve">
          <source>If set to a true value, only test results with directives will be displayed. This overrides other settings such as &lt;code&gt;verbose&lt;/code&gt;, &lt;code&gt;failures&lt;/code&gt;, or &lt;code&gt;comments&lt;/code&gt;.</source>
          <target state="translated">如果设置为真值，则仅显示带有指令的测试结果。这将覆盖其他设置，例如 &lt;code&gt;verbose&lt;/code&gt; ， &lt;code&gt;failures&lt;/code&gt; 或 &lt;code&gt;comments&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ace0eebb3ad1da3562cf6ba2f4eb062020ce0829" translate="yes" xml:space="preserve">
          <source>If set to a true value, selects an alternate output format that, among other things, uses a different heading style and marks &lt;code&gt;=item&lt;/code&gt; entries with a colon in the left margin. Defaults to false.</source>
          <target state="translated">如果设置为true值，则选择一种替代输出格式，该格式除其他外将使用不同的标题样式，并在左边距处用冒号标记 &lt;code&gt;=item&lt;/code&gt; 条目。默认为false。</target>
        </trans-unit>
        <trans-unit id="341f05ae650241bc98a8aa05ba502f05572aa8ee" translate="yes" xml:space="preserve">
          <source>If set to a true value, source entries will be converted into utf8-strings (available in Perl 5.6.1 or later). This feature needs the &lt;b&gt;Encode&lt;/b&gt; or &lt;b&gt;Encode::compat&lt;/b&gt; module.</source>
          <target state="translated">如果设置为true值，则源条目将转换为utf8字符串（在Perl 5.6.1或更高版本中可用）。此功能需要&lt;b&gt;Encode&lt;/b&gt;或&lt;b&gt;Encode :: compat&lt;/b&gt;模块。</target>
        </trans-unit>
        <trans-unit id="e52de704a5928c9a6d768f4b0d7d8f6e786b6b18" translate="yes" xml:space="preserve">
          <source>If set to a true value, the non-POD parts of the input file will be included in the output. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">如果设置为true,输入文件的非POD部分将被包含在输出中。对于查看带有POD块的文档代码时,POD渲染和代码保持完整是有用的。</target>
        </trans-unit>
        <trans-unit id="77ffaa19bbb496da1b7f2a485ed0c35990cc9fa8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt; for that. See &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">如果设置为非零，则在当前选定的输出通道上每次写入或打印后立即强制执行刷新。缺省值为0（无论通道是否真正被系统缓冲； &lt;code&gt;$|&lt;/code&gt; 仅告诉您是否在每次写入后都明确要求Perl刷新）。如果输出到终端，则STDOUT通常将被行缓冲，否则将被块缓冲。设置此变量主要在输出到管道或套接字时很有用，例如，在&lt;b&gt;rsh&lt;/b&gt;下运行Perl程序并希望看到正在发生的输出时。这对输入缓冲没有影响。参见&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;。请参阅&lt;a href=&quot;functions/select&quot;&gt;选择&lt;/a&gt;如何选择输出通道。另请参见&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b32ab50f4a2e4d52971c50b3ce21204c6ea713f8" translate="yes" xml:space="preserve">
          <source>If set to nonzero, forces a flush right away and after every write or print on the currently selected output channel. Default is 0 (regardless of whether the channel is really buffered by the system or not; &lt;code&gt;$|&lt;/code&gt; tells you only whether you've asked Perl explicitly to flush after each write). STDOUT will typically be line buffered if output is to the terminal and block buffered otherwise. Setting this variable is useful primarily when you are outputting to a pipe or socket, such as when you are running a Perl program under &lt;b&gt;rsh&lt;/b&gt; and want to see the output as it's happening. This has no effect on input buffering. See &lt;a href=&quot;perlfunc#getc&quot;&gt;&quot;getc&quot; in perlfunc&lt;/a&gt; for that. See &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt; on how to select the output channel. See also &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="translated">如果设置为非零，则在当前选定的输出通道上每次写入或打印后立即强制执行刷新。缺省值为0（无论通道是否真正被系统缓冲； &lt;code&gt;$|&lt;/code&gt; 仅告诉您是否在每次写操作后都明确要求Perl刷新）。如果输出到终端，则STDOUT通常将被行缓冲，否则将被块缓冲。设置此变量主要在输出到管道或套接字时很有用，例如在&lt;b&gt;rsh&lt;/b&gt;下运行Perl程序并希望看到正在发生的输出时。这对输入缓冲没有影响。为此，请参见&lt;a href=&quot;perlfunc#getc&quot;&gt;perlfunc中的&amp;ldquo; getc&amp;rdquo;&lt;/a&gt;。有关如何选择输出通道的信息，请参见&lt;a href=&quot;perlfunc#select&quot;&gt;perlfunc中的&amp;ldquo;选择&amp;rdquo;&lt;/a&gt;。另请参阅&lt;a href=&quot;IO::Handle&quot;&gt;IO ::处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="615ff3b3ad3b33807d03afb15df6a2d1917cfce6" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device when Perl is run with the &lt;a href=&quot;#-Dletters&quot;&gt;-Di&lt;/a&gt; command-line switch, the logging of certain operations of the PerlIO subsystem will be redirected to the specified file rather than going to stderr, which is the default. The file is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">如果在使用&lt;a href=&quot;#-Dletters&quot;&gt;-Di&lt;/a&gt;命令行开关运行Perl时将其设置为文件或设备的名称，则PerlIO子系统的某些操作的日志记录将被重定向到指定的文件，而不是默认的stderr。该文件以追加模式打开。典型用途是在Unix中：</target>
        </trans-unit>
        <trans-unit id="910076b95e48e767183ba95d8bfd82a29fd1f4b7" translate="yes" xml:space="preserve">
          <source>If set to the name of a file or device, certain operations of PerlIO subsystem will be logged to that file, which is opened in append mode. Typical uses are in Unix:</source>
          <target state="translated">如果设置为文件或设备的名称,PerlIO子系统的某些操作将被记录到该文件中,该文件以追加模式打开。典型的用途是在Unix中。</target>
        </trans-unit>
        <trans-unit id="a2a487ec4b2cdae05d408b6e8c6a9dd6b1beda15" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果设置为true，则在模板验证期间发生错误时，&lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt;将发出 &lt;code&gt;croak&lt;/code&gt; ，而不是返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39e47711b0a2673f5f59abca021e0aa968949985" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt;将不再将用户输入中的所有键都转换为小写字母，而是希望它们与所提供的模板一样。当您要在模板中使用相似的键和不同的大小写时，此功能很有用。</target>
        </trans-unit>
        <trans-unit id="2f253f67365056571734a093e4d2ab45914323e0" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;defined&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;defined&lt;/code&gt; instead.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt;将要求所有传递的值都被 &lt;code&gt;defined&lt;/code&gt; 。如果希望基于&amp;ldquo;每个键&amp;rdquo;启用此功能，请改用 &lt;code&gt;defined&lt;/code&gt; 的模板选项。</target>
        </trans-unit>
        <trans-unit id="42e74293048eac70b152d671b3afa7d17f3695a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;Params::Check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;Params::Check&quot;&gt;Params :: Check&lt;/a&gt;将进行完整性检查模板，以验证错误和未知密钥。尽管对于调试非常有用，但是在热代码和大型循环中这可能会有点慢。</target>
        </trans-unit>
        <trans-unit id="907b3689c8943c9530c2bccd5f2399b3ea311ce8" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will &lt;code&gt;croak&lt;/code&gt; when an error during template validation occurs, rather than return &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">如果设置为true，则在模板验证期间发生错误时，&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将发出 &lt;code&gt;croak&lt;/code&gt; ，而不是返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="262e77d8ecddf65d8252c722de18aca6dafa7dd4" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will no longer convert all keys from the user input to lowercase, but instead expect them to be in the case the template provided. This is useful when you want to use similar keys with different casing in your templates.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将不再将所有键从用户输入转换为小写字母，而是期望它们在提供的模板的情况下。当您要在模板中使用相似的键和不同的大小写时，这很有用。</target>
        </trans-unit>
        <trans-unit id="fcd2802dc60a0f5aa656aa8d36630b4a5a1195a7" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will require all values passed to be &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. If you wish to enable this on a 'per key' basis, use the template option &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将要求所有传递的值都被 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 。如果希望基于&amp;ldquo;每个键&amp;rdquo;启用此功能，请改用 &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 的模板选项。</target>
        </trans-unit>
        <trans-unit id="b62a3740f4d2f3949ae331d68aff300bd8b9c5aa" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;check&quot;&gt;Params::Check&lt;/a&gt; will sanity check templates, validating for errors and unknown keys. Although very useful for debugging, this can be somewhat slow in hot-code and large loops.</source>
          <target state="translated">如果设置为true，则&lt;a href=&quot;check&quot;&gt;Params :: Check&lt;/a&gt;将进行完整性检查模板，以验证错误和未知密钥。尽管对于调试非常有用，但是在热代码和大型循环中这可能会有点慢。</target>
        </trans-unit>
        <trans-unit id="df88f116b1eff18f21bd345796868ca93d04ee66" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的crc32校验和。使用 &lt;code&gt;$d-&amp;gt;crc32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="bbd8aed6bbb2cb495083f75e98d7497f01edca37" translate="yes" xml:space="preserve">
          <source>If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的crc32校验和。使用 &lt;code&gt;$i-&amp;gt;crc32&lt;/code&gt; 方法检索该值。</target>
        </trans-unit>
        <trans-unit id="d4a8f4d307b72654b7c09182b593e029ffb7af20" translate="yes" xml:space="preserve">
          <source>If set to true, all keys in the template that are marked as to be stored in a scalar, will also be removed from the result set.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则模板中所有被标记为存储在标量中的键,也将从结果集中删除。</target>
        </trans-unit>
        <trans-unit id="8a9a61d55c40cdf983928fb90e5f246e820a5b49" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的adler32校验和。使用 &lt;code&gt;$d-&amp;gt;adler32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="a5a30a93daed908c592b28db82a1a0b5d4a5ffc0" translate="yes" xml:space="preserve">
          <source>If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; method to retrieve this value.</source>
          <target state="translated">如果设置为true，将计算未压缩数据的adler32校验和。使用 &lt;code&gt;$i-&amp;gt;adler32&lt;/code&gt; 方法检索此值。</target>
        </trans-unit>
        <trans-unit id="dbc945146e02b49c89057b1636cf31aa2669f101" translate="yes" xml:space="preserve">
          <source>If set to true, immediately extract entries when reading them. This gives you the same memory break as the &lt;code&gt;extract_archive&lt;/code&gt; function. Note however that entries will not be read into memory, but written straight to disk. This means no &lt;code&gt;Archive::Tar::File&lt;/code&gt; objects are created for you to inspect.</source>
          <target state="translated">如果设置为true，则在读取条目时立即提取它们。这为您提供了与 &lt;code&gt;extract_archive&lt;/code&gt; 函数相同的内存中断。但是请注意，条目不会读入内存，而是直接写入磁盘。这意味着没有创建 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象供您检查。</target>
        </trans-unit>
        <trans-unit id="8be646f7a5def96ccc7c7343df2cffa456a1c220" translate="yes" xml:space="preserve">
          <source>If set to true, no &quot;1..N&quot; header will be printed.</source>
          <target state="translated">如果设置为 &quot;true&quot;,则不会打印 &quot;1...N &quot;页眉。</target>
        </trans-unit>
        <trans-unit id="7adb95e8ec0ed6e84fcb01131c2b90c160ee5335" translate="yes" xml:space="preserve">
          <source>If set to true, this option will remove compressed data from the input buffer of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method as the inflate progresses.</source>
          <target state="translated">如果设置为true，则此选项将随着膨胀的进行从 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法的输入缓冲区中删除压缩数据。</target>
        </trans-unit>
        <trans-unit id="d55732bd7089a68f6b5548af27b4b056d17dc65d" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt; .</source>
          <target state="translated">如果设置为true，则不会打印诊断信息。这包括对 &lt;code&gt;diag()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="5397281aac6b794ebe8bf86c258022bd58733ebd" translate="yes" xml:space="preserve">
          <source>If set true no diagnostics will be printed. This includes calls to &lt;code&gt;diag()&lt;/code&gt;.</source>
          <target state="translated">如果设置为true，则不会打印诊断信息。这包括对 &lt;code&gt;diag()&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="6758cd1f0be9e6394226a98fea1a97b18f4a012d" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;TAP::Parser::Source#config_for&quot;&gt;&quot;config_for&quot; in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">如果设置，则 &lt;code&gt;sources&lt;/code&gt; 必须是包含要加载和/或配置的&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;的名称的hashref。这些值是配置的哈希值，源处理程序可以通过&lt;a href=&quot;TAP::Parser::Source#config_for&quot;&gt;TAP :: Parser :: Source中的&amp;ldquo; config_for&amp;rdquo;&lt;/a&gt;来访问这些值。</target>
        </trans-unit>
        <trans-unit id="767e45d99bc3772f600dade44827bcaf3503a3c0" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;sources&lt;/code&gt; must be a hashref containing the names of the &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;s to load and/or configure. The values are a hash of configuration that will be accessible to the source handlers via &lt;a href=&quot;parser/source#config_for&quot;&gt;config_for in TAP::Parser::Source&lt;/a&gt;.</source>
          <target state="translated">如果设置，则 &lt;code&gt;sources&lt;/code&gt; 必须是包含要加载和/或配置的&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;的名称的hashref。这些值是配置的哈希，源处理程序可以通过&lt;a href=&quot;parser/source#config_for&quot;&gt;TAP :: Parser :: Source中的config_for&lt;/a&gt;访问这些配置。</target>
        </trans-unit>
        <trans-unit id="1f1db51044dc4cdaf8453a0cac36827443c78520" translate="yes" xml:space="preserve">
          <source>If set, END blocks are executed when the interpreter is destroyed. This is normally set by perl itself after the interpreter is constructed.</source>
          <target state="translated">如果设置,当解释器被销毁时,END块将被执行。这通常是由perl在解释器被构造后自己设置的。</target>
        </trans-unit>
        <trans-unit id="7a162adb7a0dc8b66567284e3d48459cecdcd046" translate="yes" xml:space="preserve">
          <source>If set, a directory which fails the</source>
          <target state="translated">如果设置,则会出现一个不合格的目录。</target>
        </trans-unit>
        <trans-unit id="430e0a0ebf21ab8f824a0951a1408be6d39c892f" translate="yes" xml:space="preserve">
          <source>If set, and POD_MAN_DATE and the &lt;code&gt;date&lt;/code&gt; options are not set, this will be used as the modification time of the source file, overriding the timestamp of the input file or the current time. It should be set to the desired time in seconds since UNIX epoch. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent. See &lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt; for the full specification.</source>
          <target state="translated">如果设置，并且未设置POD_MAN_DATE和 &lt;code&gt;date&lt;/code&gt; 选项，它将用作源文件的修改时间，覆盖输入文件的时间戳或当前时间。应该将其设置为自UNIX时代以来的所需时间（以秒为单位）。在给定相同源和Pod :: Man版本的情况下，这对于确保可重复生成相同输出文件的构建非常有用，即使文件时间戳可能不一致。有关完整规范，请参见&lt;a href=&quot;https://reproducible-builds.org/specs/source-date-epoch/&quot;&gt;https://reproducible-builds.org/specs/source-date-epoch/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50fc3d2d4510057c46811e96115fbf4e2aa5439b" translate="yes" xml:space="preserve">
          <source>If set, general protection faults do not generate a dialogue box but can instead be handled by the process via an exception handler. This bit should not be set by programs that don't know how to handle such faults.</source>
          <target state="translated">如果设置,一般保护故障不会产生对话框,而是可以由进程通过异常处理程序来处理。不知道如何处理此类故障的程序不应设置该位。</target>
        </trans-unit>
        <trans-unit id="36dd77001e7c6eaf4c115da0bfdc18f666edd086" translate="yes" xml:space="preserve">
          <source>If set, indicates that when a critical error is encountered, the call that triggered the error fails immediately. Normally this bit is not set, which means that a critical error causes a dialogue box to appear notifying the desktop user that some application has triggered a critical error. The dialogue box allows the desktop user to decide whether the critical error is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="translated">如果设置,表示当遇到严重错误时,触发错误的调用立即失败。正常情况下该位不设置,这意味着临界错误会导致出现一个对话框,通知桌面用户某个应用程序已经触发了一个临界错误。对话框允许桌面用户决定是将严重错误返回给进程、忽略还是重试违规操作。</target>
        </trans-unit>
        <trans-unit id="41e6aaabd1216511f49764603b89114f7c2c7520" translate="yes" xml:space="preserve">
          <source>If set, should be the name of a file (in the output directory) to write the HTML index to. The default value is &quot;index.html&quot;. If you set this to a false value, no contents file will be written.</source>
          <target state="translated">如果设置,应该是要写入HTML索引的文件名(在输出目录中)。默认值是 &quot;index.html&quot;。如果设置为false,则不会写入内容文件。</target>
        </trans-unit>
        <trans-unit id="fed7ed0698b463358f79ea435791a3f79370827d" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into &lt;code&gt;NonStop&lt;/code&gt; mode and will not connect to a TTY. If interrupted (or if control goes to the debugger via explicit setting of $DB::signal or $DB::single from the Perl script), it connects to a TTY specified in the &lt;code&gt;TTY&lt;/code&gt; option at startup, or to a tty found at runtime using the &lt;code&gt;Term::Rendezvous&lt;/code&gt; module of your choice.</source>
          <target state="translated">如果设置，调试器将进入非 &lt;code&gt;NonStop&lt;/code&gt; 模式，并且不会连接到TTY。如果被中断（或者如果通过Perl脚本中的$ DB :: signal或$ DB :: single的显式设置将控制权交给调试器），它将在启动时连接到 &lt;code&gt;TTY&lt;/code&gt; 选项中指定的TTY或在以下位置找到的tty：使用您选择的 &lt;code&gt;Term::Rendezvous&lt;/code&gt; 模块运行时。</target>
        </trans-unit>
        <trans-unit id="f19bf560504f7c9497b672610231bba49eba7830" translate="yes" xml:space="preserve">
          <source>If set, the debugger goes into non-interactive mode until interrupted, or programmatically by setting $DB::signal or $DB::single.</source>
          <target state="translated">如果设置,则调试器进入非交互模式,直到被中断,或者通过设置$DB::signal或$DB::single进行编程。</target>
        </trans-unit>
        <trans-unit id="f315d5d8357d35b3e7a9f240785d04d5f2c0b17f" translate="yes" xml:space="preserve">
          <source>If set, then when an attempt to continue reading from or writing to an already open file [usually on a removable medium like a floppy diskette] finds the file no longer available, the call will immediately fail. Normally this bit is not set, which means that instead a dialogue box will appear notifying the desktop user that some application has run into this problem. The dialogue box allows the desktop user to decide whether the failure is returned to the process, is ignored, or the offending operation is retried.</source>
          <target state="translated">如果设置了,那么当试图继续从一个已经打开的文件[通常是在软盘等可移动介质上]读或写时,发现文件不再可用,调用将立即失败。通常这个位是不设置的,这意味着反而会出现一个对话框,通知桌面用户某个应用程序遇到了这个问题。对话框允许桌面用户决定是将失败返回给进程,还是忽略,或者重试违规操作。</target>
        </trans-unit>
        <trans-unit id="d8533dab20da5503a1d14e1f563a58d7fccbc547" translate="yes" xml:space="preserve">
          <source>If set, this causes memory access misalignment faults to be automatically fixed in a manner invisible to the process. This flag is ignored on x86-based versions of Windows NT. This flag is not supported on Windows 95.</source>
          <target state="translated">如果设置,则会导致内存访问错位故障以进程不可见的方式自动修复。在基于x86的Windows NT版本上,该标志被忽略。在Windows 95上不支持该标志。</target>
        </trans-unit>
        <trans-unit id="825ea211f8cc0b564969fbeabe2d0a330315f1a6" translate="yes" xml:space="preserve">
          <source>If set, this dumps out memory statistics after execution. If set to an integer greater than one, also dumps out memory statistics after compilation.</source>
          <target state="translated">如果设置为,则在执行后会转储出内存统计。如果设置为大于1的整数,也会在编译后转出内存统计。</target>
        </trans-unit>
        <trans-unit id="8b969433f335481102ca199a1faf8cf07ca2debd" translate="yes" xml:space="preserve">
          <source>If set, this symbol indicates that only the version-specific components of a perl installation should be installed. This may be useful for making a test installation of a new version without disturbing the existing installation. Setting versiononly is equivalent to setting installperl's -v option. In particular, the non-versioned scripts and programs such as a2p, c2ph, h2xs, pod2*, and perldoc are not installed (see &lt;code&gt;INSTALL&lt;/code&gt; for a more complete list). Nor are the man pages installed. Usually, this is undef.</source>
          <target state="translated">如果设置，则此符号表示仅应安装perl安装的特定于版本的组件。这对于在不干扰现有安装的情况下进行新版本的测试安装很有用。设置versiononly等效于设置installperl的-v选项。特别是，未安装非版本化的脚本和程序，例如a2p，c2ph，h2xs，pod2 *和perldoc（有关完整列表，请参阅 &lt;code&gt;INSTALL&lt;/code&gt; ）。手册页也没有安装。通常，这是不确定的。</target>
        </trans-unit>
        <trans-unit id="80c94ecda6e710c6fc8e753f6f4382b5d0835ec4" translate="yes" xml:space="preserve">
          <source>If set, this will be used as the value of the left-hand footer unless the &lt;code&gt;date&lt;/code&gt; option is explicitly set, overriding the timestamp of the input file or the current time. This is primarily useful to ensure reproducible builds of the same output file given the same source and Pod::Man version, even when file timestamps may not be consistent.</source>
          <target state="translated">如果设置，则除非明确设置了 &lt;code&gt;date&lt;/code&gt; 选项，否则它将用作左页脚的值，从而覆盖输入文件的时间戳或当前时间。在给定相同源和Pod :: Man版本的情况下，这对于确保可重复生成相同输出文件的构建非常有用，即使文件时间戳可能不一致。</target>
        </trans-unit>
        <trans-unit id="5be95242fd4f1700426db0866219ce183a7c4d43" translate="yes" xml:space="preserve">
          <source>If setmagic is false then no set magic will be called on the new (empty) SV. This typically means that assignment will soon follow (e.g. 'local $x = $y'), and that will handle the magic.</source>
          <target state="translated">如果setmagic为false,那么在新的(空的)SV上将不会调用set magic。这通常意味着赋值将很快跟上(例如'local $x=$y'),这将处理魔法。</target>
        </trans-unit>
        <trans-unit id="b7db0eb29b687c30aa2094a54d8f1f63ca4df7c5" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; , it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">如果 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中存在多个符号类别，通常创建实用程序&amp;ldquo;：all&amp;rdquo;以简化&amp;ldquo; use&amp;rdquo;语句通常很有用。</target>
        </trans-unit>
        <trans-unit id="3f21602986b59b3bc1a9d6d50edec0ff3a9a1224" translate="yes" xml:space="preserve">
          <source>If several symbol categories exist in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt;, it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.</source>
          <target state="translated">如果 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中存在几个符号类别，通常创建实用程序&amp;ldquo;：all&amp;rdquo;来简化&amp;ldquo; use&amp;rdquo;语句通常很有用。</target>
        </trans-unit>
        <trans-unit id="1d650df7f1b284cce9178200761c079c663691a8" translate="yes" xml:space="preserve">
          <source>If so, please try to reuse the existing modules either in whole or by inheriting useful features into a new class. If this is not practical try to get together with the module authors to work on extending or enhancing the functionality of the existing modules. A perfect example is the plethora of packages in perl4 for dealing with command line options.</source>
          <target state="translated">如果是这样的话,请尝试重新使用现有的模块,或者将有用的功能继承到一个新的类中。如果这不切实际,请与模块作者一起努力扩展或增强现有模块的功能。一个很好的例子就是perl4中大量的用于处理命令行选项的包。</target>
        </trans-unit>
        <trans-unit id="dcc2c875ef26b86def7f4287ef7a97e0b0212c08" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please attach your patch to the report using the &lt;code&gt;-p&lt;/code&gt; option. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">如果是这样，那是个好消息；与没有补丁程序的错误报告相比，有补丁程序的错误报告可能会受到更多的关注和关注。请使用 &lt;code&gt;-p&lt;/code&gt; 选项将补丁程序附加到报告中。发送补丁时，请尽可能使用 &lt;code&gt;git format-patch&lt;/code&gt; 创建补丁，尽管使用 &lt;code&gt;diff -pu&lt;/code&gt; 创建的统一diff 也差不多。</target>
        </trans-unit>
        <trans-unit id="dfaefac0caf9158c6cac0a67edf5328c9dac8509" translate="yes" xml:space="preserve">
          <source>If so, that's great news; bug reports with patches are likely to receive significantly more attention and interest than those without patches. Please submit your patch via the GitHub Pull Request workflow as described in &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;. You may also send patches to &lt;b&gt;perl5-porters@perl.org&lt;/b&gt;. When sending a patch, create it using &lt;code&gt;git format-patch&lt;/code&gt; if possible, though a unified diff created with &lt;code&gt;diff -pu&lt;/code&gt; will do nearly as well.</source>
          <target state="translated">如果是这样，那是个好消息；与没有补丁程序的bug报告相比，有补丁程序的bug报告可能会受到更多的关注和关注。请按照&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlhack&quot;&gt;perlhack中&lt;/a&gt;所述通过GitHub Pull Request工作流程提交补丁。您也可以将补丁发送至&lt;b&gt;perl5-porters@perl.org&lt;/b&gt;。发送补丁时，请尽可能使用 &lt;code&gt;git format-patch&lt;/code&gt; 创建补丁，尽管用 &lt;code&gt;diff -pu&lt;/code&gt; 创建的统一diff也差不多。</target>
        </trans-unit>
        <trans-unit id="e41db44860ffe2b84a712b997e64175db6318266" translate="yes" xml:space="preserve">
          <source>If some events detected in</source>
          <target state="translated">如果检测到一些事件,在</target>
        </trans-unit>
        <trans-unit id="4a24b9aa82fff6a4581557ce8337d0476898456b" translate="yes" xml:space="preserve">
          <source>If some threads have not finished running when the main Perl thread ends, Perl will warn you about it and die, since it is impossible for Perl to clean up itself while other threads are running.</source>
          <target state="translated">如果在Perl主线程结束时,有些线程还没有运行完,Perl就会警告你,然后死掉,因为在其他线程运行的时候,Perl是不可能自己清理的。</target>
        </trans-unit>
        <trans-unit id="5c202d6491a5606cc9c88606232cf0104e601803" translate="yes" xml:space="preserve">
          <source>If something in a program isn&amp;rsquo;t the value you&amp;rsquo;re looking for but indicates where the value is, that&amp;rsquo;s indirection. This can be done with either &lt;b&gt;symbolic references&lt;/b&gt; or &lt;b&gt;hard&lt;/b&gt;.</source>
          <target state="translated">如果程序中的某些内容不是您要查找的值，而是指示该值在哪里，那就是间接的。可以使用&lt;b&gt;符号引用&lt;/b&gt;或&lt;b&gt;hard&lt;/b&gt;来完成。</target>
        </trans-unit>
        <trans-unit id="6d353132ec4a6837954d3ce352dc8e97cba1ae50" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;deprecated&lt;/b&gt;, we may remove it from the core in the future, though we might not. Generally, backward incompatible changes will have deprecation warnings for two release cycles before being removed, but may be removed after just one cycle if the risk seems quite low or the benefits quite high.</source>
          <target state="translated">如果将Perl核心中的某些内容标记为&lt;b&gt;已弃用&lt;/b&gt;，则将来可能会将其从核心中删除，尽管可能不会。通常，向后不兼容的更改在删除之前将有两个发布周期的弃用警告，但如果风险似乎很低或收益很高，则可能仅在一个周期后就将其删除。</target>
        </trans-unit>
        <trans-unit id="5fdc0cac0824435fe5437bd44fc271afb23e92f6" translate="yes" xml:space="preserve">
          <source>If something in the Perl core is marked as &lt;b&gt;experimental&lt;/b&gt;, we may change its behaviour, deprecate or remove it without notice. While we'll always do our best to smooth the transition path for users of experimental features, you should contact the perl5-porters mailinglist if you find an experimental feature useful and want to help shape its future.</source>
          <target state="translated">如果Perl核心中的某些内容标记为&lt;b&gt;实验&lt;/b&gt;，我们可能会更改其行为，不建议使用或删除它，恕不另行通知。尽管我们将始终竭尽全力为实验功能的用户简化过渡路径，但如果您发现实验功能有用并希望帮助其发展，则应联系perl5-porters邮件列表。</target>
        </trans-unit>
        <trans-unit id="5fae6eb432d77d8528c8b9785dccec21b272faf2" translate="yes" xml:space="preserve">
          <source>If something in there fails, you'll know which one it was and that will make tracking down the problem easier. Try to put a bit of debugging information into the test names.</source>
          <target state="translated">如果里面有什么东西失败了,你就会知道是哪一个,这将使追踪问题变得更容易。尽量在测试名称中加入一点调试信息。</target>
        </trans-unit>
        <trans-unit id="12083dc2cfbc1c39486c5540691a063ce5c5018f" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">如果空格延伸到下一个输入文本块,下一个块将被读入。通常,当前的文本块将被同时丢弃,但如果</target>
        </trans-unit>
        <trans-unit id="14e709a02e4eecb15fa27505b7e71a09c11f743c" translate="yes" xml:space="preserve">
          <source>If spaces extend into the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="translated">如果空格延伸到输入文本的下一个块中，则下一个块将被读入。通常，当前块将同时被丢弃，但是如果 &lt;code&gt;flags&lt;/code&gt; 的 &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; 位置1，则当前块将不被丢弃。</target>
        </trans-unit>
        <trans-unit id="593e478a0d37f7a9d8665d309a9a7733f6ec02c1" translate="yes" xml:space="preserve">
          <source>If specified the contents of &lt;code&gt;DATA&lt;/code&gt; and a termination string &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; is sent to the server. The result will be true if the data was accepted.</source>
          <target state="translated">如果指定了 &lt;code&gt;DATA&lt;/code&gt; 的内容，则将终止字符串 &lt;code&gt;&quot;.\r\n&quot;&lt;/code&gt; 发送到服务器。如果数据被接受，则结果为true。</target>
        </trans-unit>
        <trans-unit id="b6dd58d3559146e497eb5b446f27a9cb126713f8" translate="yes" xml:space="preserve">
          <source>If specified, strings are normalized before preparation of sort keys (the normalization is executed after preprocess).</source>
          <target state="translated">如果指定,则在准备排序键之前对字符串进行归一化处理(归一化处理在预处理之后执行)。</target>
        </trans-unit>
        <trans-unit id="c54d25c0a371a4a7533e5b6eb7a37c54566669f4" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to preprocess each string before the formation of sort keys.</source>
          <target state="translated">如果指定了coderef,那么在形成排序键之前,coderef被用来对每个字符串进行预处理。</target>
        </trans-unit>
        <trans-unit id="df742ffc92755882ac205c4e8f1710a25c417cf9" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; . The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">如果指定，则coderef用于重写 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中的行。coderef将获取每一行，然后应根据UCA文件格式返回重写的行。如果coderef返回空行，则该行将被跳过。</target>
        </trans-unit>
        <trans-unit id="65a1895406fe003bd9c8df18e562302ad473cb2d" translate="yes" xml:space="preserve">
          <source>If specified, the coderef is used to rewrite lines in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt;. The coderef will get each line, and then should return a rewritten line according to the UCA file format. If the coderef returns an empty line, the line will be skipped.</source>
          <target state="translated">如果指定，则coderef用于重写 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中的行。coderef将获取每一行，然后应根据UCA文件格式返回重写的行。如果coderef返回空行，则该行将被跳过。</target>
        </trans-unit>
        <trans-unit id="fd186f184cd201e115617cc1e9809ac56ff41627" translate="yes" xml:space="preserve">
          <source>If specified, the given string will be stripped off from the beginning of the C function name in the generated XS functions (if it starts with that prefix). This only applies to XSUBs without &lt;code&gt;CODE&lt;/code&gt; or &lt;code&gt;PPCODE&lt;/code&gt; blocks. For example, the XS:</source>
          <target state="translated">如果指定，将在生成的XS函数中从C函数名称的开头剥离给定的字符串（如果以该前缀开头）。这仅适用于没有 &lt;code&gt;CODE&lt;/code&gt; 或 &lt;code&gt;PPCODE&lt;/code&gt; 块的XSUB。例如，XS：</target>
        </trans-unit>
        <trans-unit id="db33e17f1262611ad9b1ad5050ad6146c6b090c4" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt; , &lt;code&gt;exUnix2&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; , &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">如果指定，此选项将禁止在zip本地和中央标题中创建所有其他字段。因此， &lt;code&gt;exTime&lt;/code&gt; ， &lt;code&gt;exUnix2&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; ， &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 和 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="6aa95b55da4c40155f92625ffd4e21427121a5f5" translate="yes" xml:space="preserve">
          <source>If specified, this option will disable the creation of all extra fields in the zip local and central headers. So the &lt;code&gt;exTime&lt;/code&gt;, &lt;code&gt;exUnix2&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt;, &lt;code&gt;ExtraFieldLocal&lt;/code&gt; and &lt;code&gt;ExtraFieldCentral&lt;/code&gt; options will be ignored.</source>
          <target state="translated">如果指定，此选项将禁止在zip本地和中央标题中创建所有其他字段。因此， &lt;code&gt;exTime&lt;/code&gt; ， &lt;code&gt;exUnix2&lt;/code&gt; ， &lt;code&gt;exUnixN&lt;/code&gt; ， &lt;code&gt;ExtraFieldLocal&lt;/code&gt; 和 &lt;code&gt;ExtraFieldCentral&lt;/code&gt; 选项将被忽略。</target>
        </trans-unit>
        <trans-unit id="4d0066c7ecc8871ce3a62f9b83ef61508d6113e7" translate="yes" xml:space="preserve">
          <source>If specified, this option will force the creation of the smallest possible compliant gzip header (which is exactly 10 bytes long) as defined in RFC 1952.</source>
          <target state="translated">如果指定了这个选项,将强制创建 RFC 1952 中定义的尽可能小的符合标准的 gzip 头(长度正好是 10 字节)。</target>
        </trans-unit>
        <trans-unit id="74b346bb75048f3d43315e1f91c059eb29d865aa" translate="yes" xml:space="preserve">
          <source>If speed is of little concern, the common idiom uses grep in scalar context (which returns the number of items that passed its condition) to traverse the entire list. This does have the benefit of telling you how many matches it found, though.</source>
          <target state="translated">如果对速度没有什么关注,常用的习惯是在标量上下文中使用grep(返回通过其条件的项目数)来遍历整个列表。不过这样做的好处是可以告诉你它找到了多少个匹配项。</target>
        </trans-unit>
        <trans-unit id="8029f3ea6d316f66b8a86b9af29af453cce204da" translate="yes" xml:space="preserve">
          <source>If start_color is non-null then it will be inserted after the opening quote (if there is one) but before the escaped text. If end_color is non-null then it will be inserted after the escaped text but before any quotes or ellipses.</source>
          <target state="translated">如果start_color是非空的,那么它将被插入到开头引号(如果有的话)之后,但在转义文本之前。如果end_color是非空的,那么它将被插入到转义文本之后,但在任何引号或省略号之前。</target>
        </trans-unit>
        <trans-unit id="741bc8e54000bbf6547a93a37e27f9bd7b7bf22e" translate="yes" xml:space="preserve">
          <source>If straightforward stream-based parsing wont meet your needs (as is likely the case for tasks such as translating PODs into structured markup languages like HTML and XML) then you may need to take the tree-based approach. Rather than doing everything in one pass and calling the &lt;b&gt;interpolate()&lt;/b&gt; method to expand sequences into text, it may be desirable to instead create a parse-tree using the &lt;b&gt;parse_text()&lt;/b&gt; method to return a tree-like structure which may contain an ordered list of children (each of which may be a text-string, or a similar tree-like structure).</source>
          <target state="translated">如果简单的基于流的解析无法满足您的需求（如将POD转换为结构化标记语言（如HTML和XML）之类的任务，那么您可能需要采用基于树的方法。与其一口气完成所有工作并调用&lt;b&gt;interpolate（）&lt;/b&gt;方法以将序列扩展为文本，&lt;b&gt;不如&lt;/b&gt;使用&lt;b&gt;parse_text（）&lt;/b&gt;方法创建一个分析树以返回一个可能包含有序列表的树状结构，可能是合乎需要的的孩子（每个孩子可能是文本字符串或类似的树状结构）。</target>
        </trans-unit>
        <trans-unit id="2063c72cde7216e8c8fe940ebf2fb1f781846427" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">如果启用了子例程签名（请参阅&lt;a href=&quot;#Signatures&quot;&gt;&amp;ldquo;签名&amp;rdquo;&lt;/a&gt;），则较短的PROTO语法将不可用，因为它将与签名冲突。在这种情况下，原型只能以属性的形式声明。</target>
        </trans-unit>
        <trans-unit id="5d14b7e2a788098ee234bfc1585ff4767dfdaee2" translate="yes" xml:space="preserve">
          <source>If subroutine signatures are enabled (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;), then the shorter PROTO syntax is unavailable, because it would clash with signatures. In that case, a prototype can only be declared in the form of an attribute.</source>
          <target state="translated">如果启用了子例程签名（请参见&lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt;），则较短的PROTO语法将不可用，因为它将与签名冲突。在这种情况下，原型只能以属性的形式声明。</target>
        </trans-unit>
        <trans-unit id="42c7d01f7359f4959eaf7c155ab3009451137cea" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将持有通胀对象， &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf6796a439d489957a46f406c119c69951b658a8" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation object and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将保留通胀对象， &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec38a973765ca012bc6fc104f4b8ef70937c9614" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将保持通货膨胀，而 &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6af1f82c337ffb0cd08fe17aa27a424683eba9a" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;$i&lt;/code&gt; will hold the inflation stream and &lt;code&gt;$status&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">如果成功， &lt;code&gt;$i&lt;/code&gt; 将保持通货膨胀， &lt;code&gt;$status&lt;/code&gt; 将为 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f34b524a05a94eda9eec45a5e52e923221e9853a" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回内存中的gzip文件。否则，它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="81c786291c2ee4a09a4250b9266414c8b0d7512f" translate="yes" xml:space="preserve">
          <source>If successful, it returns the in-memory gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回内存中的gzip文件。否则，它将返回 &lt;code&gt;undef&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="a4a46b7cfb2406db4688f3a0ac9d424f4865a652" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回未压缩的gzip文件。否则，它将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="b546e05843ef34edaf10ea0003e7e36111124750" translate="yes" xml:space="preserve">
          <source>If successful, it returns the uncompressed gzip file. Otherwise it returns &lt;code&gt;undef&lt;/code&gt; and the &lt;code&gt;$gzerrno&lt;/code&gt; variable will store the zlib error code.</source>
          <target state="translated">如果成功，它将返回未压缩的gzip文件。否则，它将返回 &lt;code&gt;undef&lt;/code&gt; 并且 &lt;code&gt;$gzerrno&lt;/code&gt; 变量将存储zlib错误代码。</target>
        </trans-unit>
        <trans-unit id="0f77490ec0c061ac3ae6e48aedaf1d41d413b95c" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afab4c4ec82d17a0d3d79f9261a109b3948960bc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised compression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="translated">如果成功，它将返回初始化压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="003d593630b18abe30c9939f8d44076e1ce90807" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化通缩对象， &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;Z_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回通缩对象 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9aa536487df74029d769a48c392afba84c5f24e" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation object, &lt;code&gt;$d&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="translated">如果成功，它将返回初始化通缩对象， &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;Z_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回通缩对象 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f86208486cf7be6093bb8b7191e306d09fb04dc" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将在列表上下文中 &lt;code&gt;Z_OK&lt;/code&gt; 的初始化通缩流 &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 。在标量上下文中，它仅返回放气流 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab6fec9c63017bda459ab8c2b830d444d4282cf" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised deflation stream, &lt;code&gt;$d&lt;/code&gt; and &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;Z_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation stream, &lt;code&gt;$d&lt;/code&gt;, only.</source>
          <target state="translated">如果成功，它将在列表上下文中 &lt;code&gt;Z_OK&lt;/code&gt; 的初始化通缩流 &lt;code&gt;$d&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 。在标量上下文中，它仅返回放气流 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05d2c70da3dce90528345981e79d77f52c5f5ddb" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt; , only.</source>
          <target state="translated">如果成功，它将返回初始化解压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2677208b617b8465686e69e5dcf570d05d7bc09" translate="yes" xml:space="preserve">
          <source>If successful, it will return the initialised uncompression object, &lt;code&gt;$z&lt;/code&gt; and a &lt;code&gt;$status&lt;/code&gt; of &lt;code&gt;BZ_OK&lt;/code&gt; in a list context. In scalar context it returns the deflation object, &lt;code&gt;$z&lt;/code&gt;, only.</source>
          <target state="translated">如果成功，它将返回初始化解压缩对象， &lt;code&gt;$z&lt;/code&gt; 和 &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;BZ_OK&lt;/code&gt; 在列表环境。在标量上下文中，它仅返回放气对象 &lt;code&gt;$z&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9905dac4184f6f7193dddf39eab6d02ad4540f03" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, &lt;code&gt;charblock()&lt;/code&gt; tries to do the opposite and interpret the argument as an old-style block name. On an ASCII platform, the return value is a</source>
          <target state="translated">如果提供的参数不能是代码点，则 &lt;code&gt;charblock()&lt;/code&gt; 会尝试执行相反的操作，并将该参数解释为旧式块名称。在ASCII平台上，返回值为</target>
        </trans-unit>
        <trans-unit id="343b1f1d2e0b0c3a0e2a3dffed0083feca7d527c" translate="yes" xml:space="preserve">
          <source>If supplied with an argument that can't be a code point, charscript() tries to do the opposite and interpret the argument as a script name. The return value is a</source>
          <target state="translated">如果提供的参数不能是代码点,charscript()会尝试做相反的事情,并将参数解释为一个脚本名称。返回值是一个</target>
        </trans-unit>
        <trans-unit id="95ecffacfac149266d204e25c816abb11a57c234" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version</source>
          <target state="translated">如果核心Perl版本支持</target>
        </trans-unit>
        <trans-unit id="f6599907df819640d703f0de46e603f79205c931" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name for the current directory if the long pathname cannot be represented in the system codepage.</source>
          <target state="translated">如果核心Perl版本支持,如果长路径名不能在系统代码页中表示,该函数将返回当前目录的ANSI路径名。</target>
        </trans-unit>
        <trans-unit id="2dcad45e80ec56c1bf86fbe3660554c170755ed1" translate="yes" xml:space="preserve">
          <source>If supported by the core Perl version, this function will return an ANSI path name if the full pathname cannot be represented in the system codepage.</source>
          <target state="translated">如果核心Perl版本支持,如果系统代码页中不能表示完整的路径名,该函数将返回一个ANSI路径名。</target>
        </trans-unit>
        <trans-unit id="608c69ec5dc593b8e31469808e911c9b8c28fab1" translate="yes" xml:space="preserve">
          <source>If tcsh is your login shell then use the setenv command.</source>
          <target state="translated">如果tcsh是你的登录shell,那么使用setenv命令。</target>
        </trans-unit>
        <trans-unit id="6722301f4d6d5b294f3eee46d693b203a67e97d7" translate="yes" xml:space="preserve">
          <source>If that doesn't make much sense, consider the analogy of a command pipeline. Say you have a shell script stored in the compressed file</source>
          <target state="translated">如果这没什么意义,可以考虑一下命令管道的比喻。假设你有一个存储在压缩文件中的shell脚本</target>
        </trans-unit>
        <trans-unit id="e0190f66a1f731aebdad4c16cbe570cf5e90169e" translate="yes" xml:space="preserve">
          <source>If that doesn't suit your needs, you can explicitly set the filename used in the zip archive by specifying the &lt;a href=&quot;#File-Naming-Options&quot;&gt;Name&lt;/a&gt; option, like so</source>
          <target state="translated">如果这不满足您的需求，则可以通过指定&amp;ldquo;&lt;a href=&quot;#File-Naming-Options&quot;&gt;名称&amp;rdquo;&lt;/a&gt;选项来显式设置zip归档文件中使用的文件名，如下所示</target>
        </trans-unit>
        <trans-unit id="0ce337d0a942d7a20e0ccbeff20a1fe0816cdba5" translate="yes" xml:space="preserve">
          <source>If that doesn't work (it relies on features of your stdio implementation), then you need something more like this:</source>
          <target state="translated">如果这还不行(它依赖于你的stdio实现的特性),那么你需要更多类似这样的东西。</target>
        </trans-unit>
        <trans-unit id="ace9cde0327f63e0372278440efb1605dee92be3" translate="yes" xml:space="preserve">
          <source>If that doesn't work (some I/O implementations are particularly cantankerous), you might need something like this:</source>
          <target state="translated">如果这样不行(有些I/O实现特别暴躁),你可能需要这样的东西。</target>
        </trans-unit>
        <trans-unit id="76b21d1151e484221dbc92ea1c2c56d3ec4082a9" translate="yes" xml:space="preserve">
          <source>If that doesn't work, give up on your stdio package and use sysread.</source>
          <target state="translated">如果不行的话,放弃你的stdio包,使用sysread。</target>
        </trans-unit>
        <trans-unit id="0580b926aa13464eaf5222ef23bd075e2a2e806d" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file and then back.</source>
          <target state="translated">如果不行,请尝试寻找到文件的不同部分,然后再返回。</target>
        </trans-unit>
        <trans-unit id="b4eb30982662b9e20db4ab3ae1666e6a76a6e58a" translate="yes" xml:space="preserve">
          <source>If that doesn't work, try seeking to a different part of the file, reading something, and then seeking back.</source>
          <target state="translated">如果不行,请尝试寻找文件的不同部分,读取一些东西,然后再寻找回来。</target>
        </trans-unit>
        <trans-unit id="4c63d398b08eb5cb7f3f37514cbe92856008dc42" translate="yes" xml:space="preserve">
          <source>If that gives too much output every day, you may want to watch only for three modules. You can write</source>
          <target state="translated">如果每天给的输出太多,你可能想只看三个模块。你可以写</target>
        </trans-unit>
        <trans-unit id="b86041bbbb4cc3f3c7bede4e6b1882292fbc734e" translate="yes" xml:space="preserve">
          <source>If that module is not available, then HTTP::Tiny will search several system-specific default locations for a CA certificate file:</source>
          <target state="translated">如果该模块不可用,那么HTTP::Tiny将搜索几个系统特定的默认位置来寻找CA证书文件。</target>
        </trans-unit>
        <trans-unit id="0c73f5392dc820a97b0a4426cb998de73cb28f26" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">如果该警告类别在调用模块中被设置为 &quot;FATAL&quot;,则死机。否则返回。</target>
        </trans-unit>
        <trans-unit id="313f3cd86007469b883802f17e39affb3f8c8794" translate="yes" xml:space="preserve">
          <source>If that warnings category has been set to &quot;FATAL&quot; in the scope where &lt;code&gt;$object&lt;/code&gt; is first used then die. Otherwise return.</source>
          <target state="translated">如果在第一次使用 &lt;code&gt;$object&lt;/code&gt; 的范围内将该警告类别设置为&amp;ldquo; FATAL&amp;rdquo;，则将死亡。否则返回。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="dea88bea19f46633af98810723372bbf40ef70b7" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt;. This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;undef&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt;) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;&quot;nomethod&quot;&lt;/a&gt;.</source>
          <target state="translated">如果启用了&amp;ldquo;按位&amp;rdquo;功能（请参见&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;），则将第五个TRUE参数传递给处理 &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; 的子例程。， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。这表明呼叫者正在期待数字行为。第四个参数将是 &lt;code&gt;undef&lt;/code&gt; ，因为该位置（ &lt;code&gt;$_[3]&lt;/code&gt; ）保留供&lt;a href=&quot;#nomethod&quot;&gt;&amp;ldquo; nomethod&amp;rdquo;使用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="961ec9e4bcc802a6b4814ce90b4ef69a38577267" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28 this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">如果通过 &lt;code&gt;use feature 'bitwise'&lt;/code&gt; 或 &lt;code&gt;use v5.28&lt;/code&gt; 启用了&amp;ldquo;按位&amp;rdquo;功能，则此运算符始终将其操作数视为数字。在Perl 5.28之前，此功能在 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 类别中产生警告。</target>
        </trans-unit>
        <trans-unit id="64579e960549e55b6b337ed2444636b1b80df4aa" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then this operator always treats its operands as numbers. Before Perl 5.28. this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">如果通过 &lt;code&gt;use feature 'bitwise'&lt;/code&gt; 或 &lt;code&gt;use v5.28&lt;/code&gt; 启用了&amp;ldquo;按位&amp;rdquo;功能，则此运算符始终将其操作数视为数字。在Perl 5.28之前。此功能在 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 类别中产生警告。</target>
        </trans-unit>
        <trans-unit id="27af0b330e562f7c0bf54946fd3c82282b9d8b27" translate="yes" xml:space="preserve">
          <source>If the &quot;bitwise&quot; feature is enabled via &lt;code&gt;use feature 'bitwise'&lt;/code&gt; or &lt;code&gt;use v5.28&lt;/code&gt;, then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt;, always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt;. Until Perl 5.28, this feature produced a warning in the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; category.</source>
          <target state="translated">如果通过 &lt;code&gt;use feature 'bitwise'&lt;/code&gt; 或 &lt;code&gt;use v5.28&lt;/code&gt; 启用了&amp;ldquo;按位&amp;rdquo;功能，则一元 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 始终将其自变量视为数字，并使用运算符 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; 的替代形式。，始终将其参数视为字符串。所以 &lt;code&gt;~0&lt;/code&gt; 和 &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 将两者得到2 ** 32-1在32位的平台，而 &lt;code&gt;~.0&lt;/code&gt; 和 &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 将两者收率 &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 。在Perl 5.28之前，此功能在 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 类别中产生警告。</target>
        </trans-unit>
        <trans-unit id="4493cf703f913ddbd099cc80db075e294c3617b1" translate="yes" xml:space="preserve">
          <source>If the &quot;external&quot; protocol is specified, the ping() method attempts to use the &lt;code&gt;Net::Ping::External&lt;/code&gt; module to ping the remote host. &lt;code&gt;Net::Ping::External&lt;/code&gt; interfaces with your system's default &lt;code&gt;ping&lt;/code&gt; utility to perform the ping, and generally produces relatively accurate results. If &lt;code&gt;Net::Ping::External&lt;/code&gt; if not installed on your system, specifying the &quot;external&quot; protocol will result in an error.</source>
          <target state="translated">如果指定了&amp;ldquo;外部&amp;rdquo;协议，则ping（）方法将尝试使用 &lt;code&gt;Net::Ping::External&lt;/code&gt; 模块对远程主机执行ping操作。 &lt;code&gt;Net::Ping::External&lt;/code&gt; 与系统的默认 &lt;code&gt;ping&lt;/code&gt; 实用程序进行交互以执行ping，并且通常会产生相对准确的结果。如果未在系统上安装 &lt;code&gt;Net::Ping::External&lt;/code&gt; ，则指定&amp;ldquo;外部&amp;rdquo;协议将导致错误。</target>
        </trans-unit>
        <trans-unit id="b022b01a378125712b4875c54365686882089f63" translate="yes" xml:space="preserve">
          <source>If the &quot;icmp&quot; protocol is specified, the ping() method sends an icmp echo message to the remote host, which is what the UNIX ping program does. If the echoed message is received from the remote host and the echoed information is correct, the remote host is considered reachable. Specifying the &quot;icmp&quot; protocol requires that the program be run as root or that the program be setuid to root.</source>
          <target state="translated">如果指定了 &quot;icmp &quot;协议,ping()方法就会向远程主机发送一个icmp回音信息,这就是UNIX ping程序的工作。如果收到远程主机的回音信息,并且回音信息正确,则认为远程主机是可以到达的。指定 &quot;icmp &quot;协议需要程序以root身份运行,或者程序的setuid为root。</target>
        </trans-unit>
        <trans-unit id="20101303a26c3ad1b48f828a91b98648450fed40" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. This protocol does not require any special privileges.</source>
          <target state="translated">如果指定了&amp;ldquo; syn&amp;rdquo;协议，则&lt;a href=&quot;#ping&quot;&gt;&amp;ldquo; ping&amp;rdquo;&lt;/a&gt;方法将仅向远程主机发送TCP SYN数据包，然后立即返回。如果成功发送了syn数据包，它将返回true值，否则将返回false。注意：与其他协议不同，该返回值不能确定远程主机是否处于活动状态，因为完整的TCP三向握手可能尚未完成。仅当远程主机在指定的超时时间内收到TCP ACK时，才认为该远程主机是可访问的。要开始等待ACK数据包，请使用&lt;a href=&quot;#ack&quot;&gt;&amp;ldquo; ack&amp;rdquo;&lt;/a&gt;方法如下所述。通过发送并行TCP SYN数据包，使用&amp;ldquo; syn&amp;rdquo;协议而不是&amp;ldquo; tcp&amp;rdquo;协议来同时确定多个目标的可达性。在测试每个远程主机时，它不会阻塞。该协议不需要任何特殊特权。</target>
        </trans-unit>
        <trans-unit id="c3280089081e0a65bf27928777cbd13d99f6f66b" translate="yes" xml:space="preserve">
          <source>If the &quot;syn&quot; protocol is specified, the ping() method will only send a TCP SYN packet to the remote host then immediately return. If the syn packet was sent successfully, it will return a true value, otherwise it will return false. NOTE: Unlike the other protocols, the return value does NOT determine if the remote host is alive or not since the full TCP three-way handshake may not have completed yet. The remote host is only considered reachable if it receives a TCP ACK within the timeout specified. To begin waiting for the ACK packets, use the ack() method as explained below. Use the &quot;syn&quot; protocol instead the &quot;tcp&quot; protocol to determine reachability of multiple destinations simultaneously by sending parallel TCP SYN packets. It will not block while testing each remote host. demo/fping is provided in this distribution to demonstrate the &quot;syn&quot; protocol as an example. This protocol does not require any special privileges.</source>
          <target state="translated">如果指定了 &quot;syn &quot;协议,ping()方法将只向远程主机发送一个TCP SYN数据包,然后立即返回。如果syn数据包发送成功,它将返回一个true值,否则将返回false。注意:与其他协议不同,返回值并不决定远程主机是否还活着,因为完整的TCP三方握手可能还没有完成。只有在指定的超时内收到TCP ACK,远程主机才被认为是可到达的。要开始等待ACK数据包,请使用下面解释的ack()方法。使用 &quot;syn &quot;协议代替 &quot;tcp &quot;协议,通过发送平行的tcp SYN数据包来同时确定多个目的地的可到达性。在这个发行版中提供了demo/fping作为例子来演示 &quot;syn &quot;协议。这个协议不需要任何特殊的权限。</target>
        </trans-unit>
        <trans-unit id="7238cf0824cb05db1486e3141c96b6c642d31d1f" translate="yes" xml:space="preserve">
          <source>If the &quot;user:password&quot; stanza contains reserved characters, they must be percent-escaped:</source>
          <target state="translated">如果 &quot;user:password &quot;段中包含保留字符,则必须对其进行百分数封装。</target>
        </trans-unit>
        <trans-unit id="318d6b49d6250a4816190433cf297845eb70cba7" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">如果$ crc参数为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将重置crc值。</target>
        </trans-unit>
        <trans-unit id="abcc06c7fad286b05b36114515df89ab3f899db0" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">如果$ crc参数为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则将重置crc值。</target>
        </trans-unit>
        <trans-unit id="0e9952545241861fa2f27861c631fbcce0156104" translate="yes" xml:space="preserve">
          <source>If the $crc parameters is &lt;code&gt;undef&lt;/code&gt;, the crc value will be reset.</source>
          <target state="translated">如果$ crc参数为 &lt;code&gt;undef&lt;/code&gt; ，则将重置crc值。</target>
        </trans-unit>
        <trans-unit id="302e31c3384df8bb8c31ef52a9d8291c6e65b38e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">如果提供了$ must_be_file参数且该参数为TRUE，则除非图像看起来像属于文件转储，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32046e73c61ab6dfbb991e61669caae203688f3e" translate="yes" xml:space="preserve">
          <source>If the $must_be_file argument is provided and is TRUE, then return &lt;code&gt;undef&lt;/code&gt; unless the image looks like it belongs to a file dump.</source>
          <target state="translated">如果提供了$ must_be_file参数且该参数为TRUE，则除非图像看起来像属于文件转储，否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="865165ad77b0593f721d466f6d0ebabfe1d34482" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果$ string是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="688f0ecd47d63e749a9dd5c5cac2e57d32b8ed3a" translate="yes" xml:space="preserve">
          <source>If the $string is &lt;code&gt;undef&lt;/code&gt;, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果$ string是 &lt;code&gt;undef&lt;/code&gt; ，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="076c07280263c9d15e3255695b14d837c538bc87" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;$input_filename_or_reference&amp;gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">如果&amp;lt;$ input_filename_or_reference&amp;gt;参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行读取，并从中读取输入数据。</target>
        </trans-unit>
        <trans-unit id="e6e87357913d48be4073006d8b0866ceef5457d5" translate="yes" xml:space="preserve">
          <source>If the 'name' is '&amp;amp;' the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">如果&amp;ldquo;名称&amp;rdquo;为&amp;ldquo;＆&amp;rdquo;，则PAD中的对应条目为表示可能关闭的CV。</target>
        </trans-unit>
        <trans-unit id="85fe5da8ded285f9f24f40aa84216e564fcc0c0a" translate="yes" xml:space="preserve">
          <source>If the 'name' is &lt;code&gt;&amp;amp;&lt;/code&gt; the corresponding entry in the PAD is a CV representing a possible closure.</source>
          <target state="translated">如果&amp;ldquo;名称&amp;rdquo;为 &lt;code&gt;&amp;amp;&lt;/code&gt; ，则PAD中的相应条目为表示可能关闭的CV。</target>
        </trans-unit>
        <trans-unit id="cab0adefdbb8eb1bb75234fb2c512e529ae68ac9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;Mozilla::CA&quot;&gt;Mozilla::CA&lt;/a&gt; module is installed, HTTP::Tiny will use the CA file included with it as a source of trusted CA's. (This means you trust Mozilla, the author of Mozilla::CA, the CPAN mirror where you got Mozilla::CA, the toolchain used to install it, and your operating system security, right?)</source>
          <target state="translated">如果安装了&lt;a href=&quot;Mozilla::CA&quot;&gt;Mozilla :: CA&lt;/a&gt;模块，则HTTP :: Tiny将使用随附的CA文件作为受信任CA的来源。（这意味着您信任Mozilla：Mozilla :: CA的作者，Mozilla :: CA所在的CPAN镜像，用于安装该工具的工具链以及您的操作系统安全性，对吗？）</target>
        </trans-unit>
        <trans-unit id="45cb5ded2282f7dcd41dd84a212cb40770ba3961" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt; . This includes all files that get included via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">如果&lt;b&gt;-W&lt;/b&gt;标志在命令行中使用，它将使整个程序中的所有警告，无论是否警告被禁用本地使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 或 &lt;code&gt;$^W =0&lt;/code&gt; 。这包括通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 包含的所有文件。可以将其视为Perl中&amp;ldquo; lint&amp;rdquo;命令的等效项。</target>
        </trans-unit>
        <trans-unit id="67f0f299ae6f5832a23754313dcbdf3deeea5b62" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;-W&lt;/b&gt; flag is used on the command line, it will enable all warnings throughout the program regardless of whether warnings were disabled locally using &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W =0&lt;/code&gt;. This includes all files that get included via &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;do&lt;/code&gt;. Think of it as the Perl equivalent of the &quot;lint&quot; command.</source>
          <target state="translated">如果在命令行上使用&lt;b&gt;-W&lt;/b&gt;标志，它将启用整个程序中的所有警告，无论是否在本地禁用警告而不使用 &lt;code&gt;no warnings&lt;/code&gt; 或 &lt;code&gt;$^W =0&lt;/code&gt; 。这包括通过 &lt;code&gt;use&lt;/code&gt; ， &lt;code&gt;require&lt;/code&gt; 或 &lt;code&gt;do&lt;/code&gt; 包含的所有文件。可以将其视为Perl中&amp;ldquo; lint&amp;rdquo;命令的等效项。</target>
        </trans-unit>
        <trans-unit id="544ad5b88e657a2b04055790eb69377a583771e6" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">如果&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;模块不是Perl发行版的一部分，则可以从&lt;a href=&quot;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&quot;&gt;http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/&lt;/a&gt;检索（如果此文档来自您的Perl发行版，那么您正在运行5.004或更高版本，并且已经拥有它。）</target>
        </trans-unit>
        <trans-unit id="e9d6651b3488b419cbb556cfd921ab740de960ba" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;ExtUtils::Embed&lt;/b&gt; module isn't part of your Perl distribution, you can retrieve it from &lt;a href=&quot;https://metacpan.org/pod/ExtUtils::Embed&quot;&gt;https://metacpan.org/pod/ExtUtils::Embed&lt;/a&gt; (If this documentation came from your Perl distribution, then you're running 5.004 or better and you already have it.)</source>
          <target state="translated">如果&lt;b&gt;ExtUtils :: Embed&lt;/b&gt;模块不是Perl发行版的一部分，则可以从&lt;a href=&quot;https://metacpan.org/pod/ExtUtils::Embed&quot;&gt;https://metacpan.org/pod/ExtUtils::Embed&lt;/a&gt;检索它（如果该文档来自Perl发行版，则说明您正在运行5.004或更高，并且您已经拥有它。）</target>
        </trans-unit>
        <trans-unit id="40e97ddfc26315857071022b6a58a8c5330f9bda" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;-S&quot;&lt;/code&gt; or &lt;code&gt;-&quot;S&quot;&lt;/code&gt; switch is present</source>
          <target state="translated">如果存在 &lt;code&gt;&quot;-S&quot;&lt;/code&gt; 或 &lt;code&gt;-&quot;S&quot;&lt;/code&gt; 开关</target>
        </trans-unit>
        <trans-unit id="bcfb6b5f36fe9b097b6d4cfdd0d5b8347d4498d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot; the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt; , because they can tell a program that their SHELL is</source>
          <target state="translated">如果是 &lt;code&gt;#!&lt;/code&gt; 行以 &lt;code&gt;#!&lt;/code&gt; 命名的程序中不包含单词&amp;ldquo; perl&amp;rdquo;或单词&amp;ldquo; indir&amp;rdquo; 。执行而不是Perl解释器。这有点奇怪，但是它可以帮助不使用 &lt;code&gt;#!&lt;/code&gt; 机器上的人！，因为他们可以告诉程序其外壳是</target>
        </trans-unit>
        <trans-unit id="604833b3bed6d2cdd6969680b3567a88335ca6e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;#!&lt;/code&gt; line does not contain the word &quot;perl&quot; nor the word &quot;indir&quot;, the program named after the &lt;code&gt;#!&lt;/code&gt; is executed instead of the Perl interpreter. This is slightly bizarre, but it helps people on machines that don't do &lt;code&gt;#!&lt;/code&gt;, because they can tell a program that their SHELL is</source>
          <target state="translated">如果是 &lt;code&gt;#!&lt;/code&gt; 该行不包含单词&amp;ldquo; perl&amp;rdquo;或单词&amp;ldquo; indir&amp;rdquo;，该程序以 &lt;code&gt;#!&lt;/code&gt; 命名！执行而不是Perl解释器。这有点奇怪，但是它可以帮助不使用 &lt;code&gt;#!&lt;/code&gt; 机器上的人！，因为他们可以告诉程序他们的外壳是</target>
        </trans-unit>
        <trans-unit id="263d47f71006c52e232d04a65727d383732b439a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; 变量设置为true值，则不会对UTF8 / 16/32施加启发式方法，并且结果将限于可疑对象和 &lt;code&gt;ascii&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="353ab226583ec1c10fd3aef68a690f9c11e31e86" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and &lt;code&gt;ascii&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;$Encode::Guess::NoUTFAutoGuess&lt;/code&gt; 变量设置为true值，则不会对UTF8 / 16/32进行启发式操作，结果将仅限于可疑对象和 &lt;code&gt;ascii&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ad3f883582e4c647a3748b90c080c6161d8d898" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle, the compressed data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数是一个文件句柄，则将从中读取压缩的数据。字符串&amp;ldquo;-&amp;rdquo;可用作标准输入的别名。</target>
        </trans-unit>
        <trans-unit id="fe51b5d7f895a2847c85f0654d41581417ffbf8a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数是文件名，则 &lt;code&gt;$input&lt;/code&gt; 的值将用于</target>
        </trans-unit>
        <trans-unit id="7b21ca0ba17da1de5557b8c2561a39c672e345ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is a scalar, it is assumed to be a filename. This file will be opened for reading and the compressed data will be read from it.</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数为标量，则假定为文件名。将打开该文件以进行读取，并从中读取压缩的数据。</target>
        </trans-unit>
        <trans-unit id="f3e74e002fc30cd5c7fe440b4d039e155035cde7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, the</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 参数不是文件名，则</target>
        </trans-unit>
        <trans-unit id="8c806bbadc7d9dce5be50aca2c285d39455523f0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a filehandle, the input data will be read from it. The string '-' can be used as an alias for standard input.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是一个文件句柄，则将从中读取输入数据。字符串&amp;ldquo;-&amp;rdquo;可用作标准输入的别名。</target>
        </trans-unit>
        <trans-unit id="b1c3cf35342f4c34421c4e26433c64dd55c114d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for reading and the input data will be read from it.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行读取，并从中读取输入数据。</target>
        </trans-unit>
        <trans-unit id="573972f31f94bcc5ce697159aca1ad87294adc22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95490becd5727b45000e58c74b6e1c6ae0970e6a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f4cccbcdf0c65cc8f40030797afae3d268325f9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt; ; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;$need&lt;/code&gt; 参数，它将检查当前版本（由包中的$ VERSION变量定义）是否大于或等于 &lt;code&gt;$need&lt;/code&gt; ；如果不是这种情况，它将死亡。此方法由 &lt;code&gt;VERSION&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 形式自动调用。</target>
        </trans-unit>
        <trans-unit id="6a6a3d7b2f8102b10a0c4c1e7ed04569381bcca7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$need&lt;/code&gt; argument is given then it will check that the current version (as defined by the $VERSION variable in the package) is greater than or equal to &lt;code&gt;$need&lt;/code&gt;; it will die if this is not the case. This method is called automatically by the &lt;code&gt;VERSION&lt;/code&gt; form of &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">如果给出了 &lt;code&gt;$need&lt;/code&gt; 参数，它将检查当前版本（由包中的$ VERSION变量定义）是否大于或等于 &lt;code&gt;$need&lt;/code&gt; ；如果不是这种情况，它将死亡。此方法由 &lt;code&gt;VERSION&lt;/code&gt; &lt;code&gt;use&lt;/code&gt; 形式自动调用。</target>
        </trans-unit>
        <trans-unit id="4e612a8de15e6e3ebce7b57945845f8b7dc29222" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数是一个文件句柄，则将压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="ca1b12c1cf4a15c9b6156dfb74283d87ea201fd5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行写入，并将压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="59757227a4fe8fdd27a95b595bd3ff8c8a163939" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="837bf156c80a35ed162d613d42ade6562e2894a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt;::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="cadc0cd9a0990edba8eef6811ffbf43a8f495bbc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="196148e89da9cfbfe329bbc55db61beb8a5968d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="3e714bc9d0ca60a68f45566881bf3e6145bc1ce5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="08b9bed1be5f46be48a5455f8dcb9b223a356d8d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="876928fea8ebdaa591df8075f9c404fb23d04a28" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="5fc1018e332332481571232c14a9c9881c4640fa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="38552f9e6ec9c67c09d8bddc8275dd8bdd5d8803" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; ::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="c1b6039aa2ae2d0c506fff4cceb4d05934eba7f6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output&lt;/code&gt; parameter is any other type, &lt;code&gt;IO::Compress::Zip&lt;/code&gt;::new will return undef.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 参数为任何其他类型，则 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; :: new将返回undef。</target>
        </trans-unit>
        <trans-unit id="cc18113fea92f93f29a91b56f7f76e4dd3fc2c3e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the compressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是文件句柄，则将压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="b000e8d3bf3971a53c3d271eb802381bc6b99814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a filehandle, the uncompressed data will be written to it. The string '-' can be used as an alias for standard output.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是文件句柄，则将未压缩的数据写入其中。字符串&amp;ldquo;-&amp;rdquo;可用作标准输出的别名。</target>
        </trans-unit>
        <trans-unit id="4843925dd2f30aabd060449fee92e5566394585d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the compressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。将打开该文件以进行写入，并将压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="82c61471bec0e7ab85ea6d51b841a7cd924bb91c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is a simple scalar, it is assumed to be a filename. This file will be opened for writing and the uncompressed data will be written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是一个简单的标量，则假定它是一个文件名。该文件将被打开以进行写入，并且未压缩的数据将被写入其中。</target>
        </trans-unit>
        <trans-unit id="171f6debdc3c19e16dbddc9b4ccb5eb09a1f9e1d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7817f217aafc05c7b99d4b799af6c64aa75fd355" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter is any other type, &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 参数是任何其他类型，则将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2259a2e974894cbf8831f8e74de6dee67d652d9c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">如果 &lt;code&gt;$regexp&lt;/code&gt; 变量包含一个代码表达式，则用户可以执行任意Perl代码。例如，一些小丑可以搜索 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;('rm -rf *');&lt;/code&gt; 删除文件。从这个意义上讲，内插和代码表达式的组合</target>
        </trans-unit>
        <trans-unit id="f36385595fbe40440c2dd4edd9a51197f185c95d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$regexp&lt;/code&gt; variable contains a code expression, the user could then execute arbitrary Perl code. For instance, some joker could search for &lt;code&gt;system('rm -rf *');&lt;/code&gt; to erase your files. In this sense, the combination of interpolation and code expressions</source>
          <target state="translated">如果 &lt;code&gt;$regexp&lt;/code&gt; 变量包含一个代码表达式，则用户可以执行任意Perl代码。例如，一些小丑可以搜索 &lt;code&gt;system('rm -rf *');&lt;/code&gt; 删除文件。从这个意义上讲，内插和代码表达式的组合</target>
        </trans-unit>
        <trans-unit id="cead10e67b406c29ab565d567b9609063d5776ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与缓冲区关联，则此方法将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e56611d957be7289e8984a9c8a2d5654cbe3409" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a buffer, this method will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与缓冲区关联，则此方法将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58dcaddb355cecd931c021172a4bedf908dd76a9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与文件或文件句柄关联，则 &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 将返回基础文件描述符。一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法， &lt;code&gt;&lt;a href=&quot;../../functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 将返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd0509a249a2be85806909612af8871ff25800ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, &lt;code&gt;fileno&lt;/code&gt; will return the underlying file descriptor. Once the &lt;code&gt;close&lt;/code&gt; method is called &lt;code&gt;fileno&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与文件或文件句柄关联，则 &lt;code&gt;fileno&lt;/code&gt; 将返回基础文件描述符。一旦调用 &lt;code&gt;close&lt;/code&gt; 方法， &lt;code&gt;fileno&lt;/code&gt; 将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8acbfda88a1601bef7d039c62529de82f9b15c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$z&lt;/code&gt; object is associated with a file or a filehandle, this method returns the current autoflush setting for the underlying filehandle. If &lt;code&gt;EXPR&lt;/code&gt; is present, and is non-zero, it will enable flushing after every write/print operation.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 对象与文件或文件句柄关联，则此方法返回基础文件句柄的当前自动刷新设置。如果存在 &lt;code&gt;EXPR&lt;/code&gt; ，并且EXPR不为零，则它将在每次写入/打印操作后启用刷新。</target>
        </trans-unit>
        <trans-unit id="4f22b38f141c1394908e5c44c3cf641e6013a601" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;(*ACCEPT)&lt;/code&gt; is inside of capturing groups then the groups are marked as ended at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; was encountered. For instance:</source>
          <target state="translated">如果 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 在捕获组中，则将这些组标记为在遇到 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 的点结束。例如：</target>
        </trans-unit>
        <trans-unit id="d96d9f9f8c91a22bdf7e1a3536eeb47596adfe1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is disabled, the comment field can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">如果禁用 &lt;code&gt;-Strict&lt;/code&gt; 选项，则注释字段可以包含除NULL之外的任何字符。如果存在任何null字符，则该字段将在第一个NULL处被截断。</target>
        </trans-unit>
        <trans-unit id="8a0625a9517209d9c735d420fbb7b372c06cae56" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, &lt;code&gt;$string&lt;/code&gt; can only consist of ISO 8859-1 characters.</source>
          <target state="translated">如果启用了 &lt;code&gt;-Strict&lt;/code&gt; 选项，则 &lt;code&gt;$string&lt;/code&gt; 只能包含ISO 8859-1字符。</target>
        </trans-unit>
        <trans-unit id="7e727e67c9a9b626ab111993b625d6fae0b44b5e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-Strict&lt;/code&gt; option is enabled, the comment can only consist of ISO 8859-1 characters plus line feed.</source>
          <target state="translated">如果启用了 &lt;code&gt;-Strict&lt;/code&gt; 选项，则注释只能由ISO 8859-1字符加换行符组成。</target>
        </trans-unit>
        <trans-unit id="687858bb0364e03075315214e49915f4063efd20" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-i&lt;/code&gt; switch is present but no extension for a backup copy is given, then inplace editing creates a new version of a file; the existing copy is not deleted. (Note that if an extension is given, an existing file is renamed to the backup file, as is the case under other operating systems, so it does not remain as a previous version under the original filename.)</source>
          <target state="translated">如果存在 &lt;code&gt;-i&lt;/code&gt; 开关，但未提供备份副本的扩展名，则就地编辑将创建文件的新版本；现有副本不会被删除。（请注意，如果指定了扩展名，则现有文件将重命名为备份文件，就像在其他操作系统下一样，因此它不会保留为原始文件名下的先前版本。）</target>
        </trans-unit>
        <trans-unit id="ee96a00037808dbdc95697095ca0c22513112f61" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;-v&lt;/code&gt; option is present, column 1 is expanded to include</source>
          <target state="translated">如果存在 &lt;code&gt;-v&lt;/code&gt; 选项，则列1扩展为包括</target>
        </trans-unit>
        <trans-unit id="8e7588692ec4768237d3953ea6a6c6164462271b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;...Host&lt;/code&gt; argument is in this special form and the corresponding &lt;code&gt;...Service&lt;/code&gt; or &lt;code&gt;...Port&lt;/code&gt; argument is also defined, the one parsed from the &lt;code&gt;...Host&lt;/code&gt; argument will take precedence and the other will be ignored.</source>
          <target state="translated">如果 &lt;code&gt;...Host&lt;/code&gt; 参数采用这种特殊形式，并且还定义了相应的 &lt;code&gt;...Service&lt;/code&gt; 或 &lt;code&gt;...Port&lt;/code&gt; 参数，则从 &lt;code&gt;...Host&lt;/code&gt; 参数解析的一个优先。</target>
        </trans-unit>
        <trans-unit id="4eacdf4c079f427c39ca731549e9ca77acc2ef88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier is in effect ...</source>
          <target state="translated">如果 &lt;code&gt;/a&lt;/code&gt; 修饰符有效...</target>
        </trans-unit>
        <trans-unit id="e67bdd40f66f8b280f344ca0cd6466ca71728404" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/a&lt;/code&gt; modifier, is in effect ...</source>
          <target state="translated">如果 &lt;code&gt;/a&lt;/code&gt; 修饰符有效...</target>
        </trans-unit>
        <trans-unit id="45a06195ed61d1ad05b053f7cec670bab3d1b47d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the</source>
          <target state="translated">如果指定了 &lt;code&gt;/c&lt;/code&gt; 修饰符，则</target>
        </trans-unit>
        <trans-unit id="d41dfd0659ebb24e37b486d073bb483e95d40816" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/c&lt;/code&gt; modifier is specified, the characters to be transliterated are the ones NOT in</source>
          <target state="translated">如果指定了 &lt;code&gt;/c&lt;/code&gt; 修饰符，则要音译的字符是NOT中的字符</target>
        </trans-unit>
        <trans-unit id="d32f95725bf186859393e8afb0285f817b2b2c4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is specified, any characters specified by</source>
          <target state="translated">如果指定了 &lt;code&gt;/d&lt;/code&gt; 修饰符，则由</target>
        </trans-unit>
        <trans-unit id="61f363164df63c08b01c2f8d842eb83178238fca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/d&lt;/code&gt; modifier is used, the</source>
          <target state="translated">如果使用 &lt;code&gt;/d&lt;/code&gt; 修饰符，则</target>
        </trans-unit>
        <trans-unit id="228d53bdcd18fe101fa332b95e05c49d501e9bd9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; ...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">如果未使用 &lt;code&gt;/g&lt;/code&gt; 选项，则列表上下文中的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 将返回一个列表，该列表由与该模式中的括号匹配的子表达式组成，即（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; ...）（请注意此处 &lt;code&gt;$1&lt;/code&gt; 等。也设置）。当模式中没有括号时，返回值是成功的列表 &lt;code&gt;(1)&lt;/code&gt; 。有或没有括号，失败时将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="4847a17bc99ad2bd83a46004a16f9056518239f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/g&lt;/code&gt; option is not used, &lt;code&gt;m//&lt;/code&gt; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, that is, (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;...) (Note that here &lt;code&gt;$1&lt;/code&gt; etc. are also set). When there are no parentheses in the pattern, the return value is the list &lt;code&gt;(1)&lt;/code&gt; for success. With or without parentheses, an empty list is returned upon failure.</source>
          <target state="translated">如果未使用 &lt;code&gt;/g&lt;/code&gt; 选项，则 &lt;code&gt;m//&lt;/code&gt; 在列表上下文中将返回一个列表，该列表由与该模式中的括号匹配的子表达式组成，即（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; ...）（请注意此处 &lt;code&gt;$1&lt;/code&gt; 等。也设置）。如果模式中没有括号，则返回值是成功的列表 &lt;code&gt;(1)&lt;/code&gt; 。有或没有括号，失败时将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="f3f80ef36f0d767bd1b67ec24494f102a4ec7c1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is present, a new copy of the string is made and its characters transliterated, and this copy is returned no matter whether it was modified or not: the original string is always left unchanged. The new copy is always a plain string, even if the input string is an object or a tied variable.</source>
          <target state="translated">如果存在 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，则将创建字符串的新副本并将其字符音译，并且无论是否对其进行了修改，都将返回此副本：原始字符串始终保持不变。即使输入字符串是对象或绑定变量，新副本也始终是纯字符串。</target>
        </trans-unit>
        <trans-unit id="a9229f75d9765b6c9e80a754666b4ec3786ce235" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option is used then it runs the substitution on a copy of the string and instead of returning the number of substitutions, it returns the copy whether or not a substitution occurred. The original string is never changed when &lt;code&gt;/r&lt;/code&gt; is used. The copy will always be a plain string, even if the input is an object or a tied variable.</source>
          <target state="translated">如果使用 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，则它将在字符串的副本上运行替换，并且不返回替换数，而是返回副本（无论是否发生替换）。使用 &lt;code&gt;/r&lt;/code&gt; 时，原始字符串永远不会更改。即使输入是对象或绑定变量，副本也始终是纯字符串。</target>
        </trans-unit>
        <trans-unit id="c65b706b15e1b297f5f1c28d84acdcb1bb86c23a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;/s&lt;/code&gt; modifier is specified, sequences of characters, all in a row, that were transliterated to the same character are squashed down to a single instance of that character.</source>
          <target state="translated">如果指定了 &lt;code&gt;/s&lt;/code&gt; 修饰符，则将连续音译为相同字符的所有字符序列压缩为该字符的单个实例。</target>
        </trans-unit>
        <trans-unit id="98015ad9cab949396e11223bb4b809b828f32a12" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADLER32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">如果在构造函数中未为此对象启用 &lt;code&gt;ADLER32&lt;/code&gt; 选项，则此方法将始终返回0；否则，此方法将始终返回0。</target>
        </trans-unit>
        <trans-unit id="e7e3cc3b120420d3fe3e5903cbe74d0d544abd6d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to false, the output buffers in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods will be truncated before uncompressed data is written to them.</source>
          <target state="translated">如果 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为false，则 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法中的输出缓冲区将被截断，然后再将未压缩的数据写入它们。</target>
        </trans-unit>
        <trans-unit id="dc67d2e9493b30b20a1a27f63c6bc36f875e42fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果在 &lt;code&gt;$d&lt;/code&gt; 对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true ，则压缩数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="894535f526af30d884a71d76dd392439745e70a6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for the &lt;code&gt;$d&lt;/code&gt; object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果在 &lt;code&gt;$d&lt;/code&gt; 对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true ，则压缩后的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="241ec910d4c3fc198870214959a19e4587117b91" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">如果在此对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true，则未压缩的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 之前，$ output将被截断。</target>
        </trans-unit>
        <trans-unit id="41b5894e323b1e78083ec3fd1e539c059bbe6e54" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AppendOutput&lt;/code&gt; option is set to true in the constructor for this object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If it is false, &lt;code&gt;$output&lt;/code&gt; will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">如果在此对象的构造函数中将 &lt;code&gt;AppendOutput&lt;/code&gt; 选项设置为true，则未压缩的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果为false，则在将任何未压缩的数据写入 &lt;code&gt;$output&lt;/code&gt; 之前，$ output将被截断。</target>
        </trans-unit>
        <trans-unit id="23a4bdafd5b4aee2bfba5a403d17509d788319bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Archive::Tar&lt;/code&gt; module is installed and either the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files.</source>
          <target state="translated">如果安装了 &lt;code&gt;Archive::Tar&lt;/code&gt; 模块并且 &lt;code&gt;uncompress&lt;/code&gt; 程序或 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用以下变通办法之一来读取 &lt;code&gt;.tar.Z&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="da717ba776ac7b943780ea377cd85c35cc7f2655" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Bzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: Bzip2的对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="2451f14f493fd0c1b2a744f1ca680885802c97fb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Deflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩::减缩对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="a262cca6ca624ccbcc230f0a9a299f301469ea87" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Gzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: Gzip已物体时选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="e1abc2a1019c01d985ed7b90e95e969f6f299bf2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::RawDeflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩:: RawDeflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="f5ea66329ad2b4187630d779016bfcf01873661d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Compress::Zip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::压缩::邮编对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="efa0131be286b8ee087293f106c69cc7176b941b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: AnyInflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d7295924866c46c6268e8a714d1d64a580c31683" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::AnyUncompress object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: AnyUncompress对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d590344cfdd3022553efe336602191d1dbf477b6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Bunzip2 object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: bunzip2命令对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="d48a250e20975c54010e5628db4f5baad9a34122" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Gunzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: gunzip文件对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="52452c9550cd8363c6c8237af362cc345e53f457" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Inflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩::膨胀对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="34f0502573716752984911463b9f0d1cdbf46468" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::RawInflate object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩:: RawInflate对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="a4a69474f66acefa05c78e7afea37ef49d0b67b4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;AutoClose&lt;/code&gt; option has been enabled when the IO::Uncompress::Unzip object was created, and the object is associated with a file, the underlying file will also be closed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 创建IO ::解压缩解压::对象时，选择已启用，并且对象是与文件相关联，底层文件也将被关闭。</target>
        </trans-unit>
        <trans-unit id="94bf536d1f0d5c1626e7c3b73aa7b49722d0966b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is set in &lt;code&gt;gflags&lt;/code&gt; then it indicates that the caller only knows about the genuine GV version of &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit will always be set in &lt;code&gt;*ckflags_p&lt;/code&gt;, regardless of the check function's recorded requirements. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is clear in &lt;code&gt;gflags&lt;/code&gt; then it indicates the caller knows about the possibility of passing something other than a GV as &lt;code&gt;namegv&lt;/code&gt;, and accordingly the corresponding bit may be either set or clear in &lt;code&gt;*ckflags_p&lt;/code&gt;, indicating the check function's recorded requirements.</source>
          <target state="translated">如果在 &lt;code&gt;gflags&lt;/code&gt; 中设置了 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 位，则表明调用者仅知道 &lt;code&gt;namegv&lt;/code&gt; 的真正GV版本， &lt;code&gt;*ckflags_p&lt;/code&gt; ，无论检查功能记录在哪里，都将始终在* ckflags_p中设置相应的位。如果在 &lt;code&gt;gflags&lt;/code&gt; 中清除了 &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; 位，则表明调用方知道可以通过GV以外的其他名称作为 &lt;code&gt;namegv&lt;/code&gt; ，并且相应的位可以在 &lt;code&gt;*ckflags_p&lt;/code&gt; 中设置或清除，表示检查功能的记录要求。</target>
        </trans-unit>
        <trans-unit id="4c82a8f9dcfd859cf531bf1cebfe4f1f3355707c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; environment variable does not exist, and if &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt;. If &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown. Note that at the time of writing, the only useful values are 1, which will tell &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; to guess, or &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; - if you want to use a newer JSON module, see &lt;a href=&quot;#CPAN_META_JSON_BACKEND&quot;&gt;&quot;CPAN_META_JSON_BACKEND&quot;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;CPAN_META_JSON_BACKEND&lt;/code&gt; 环境变量不存在，并且如果 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 环境变量存在，则为true且不是&amp;ldquo; JSON :: PP&amp;rdquo;，则将加载&lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt;模块（版本2.5或更高版本）并用于解释 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 。如果未安装&lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt;或它太旧，则将引发异常。请注意，在撰写本文时，唯一有用的值为1，它将告诉&lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt;进行猜测，或者为&lt;a href=&quot;JSON::XS&quot;&gt;JSON :: XS-&lt;/a&gt;如果要使用更新的JSON模块，请参见&lt;a href=&quot;#CPAN_META_JSON_BACKEND&quot;&gt;&amp;ldquo; CPAN_META_JSON_BACKEND&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5ac2a9fbc05192cf46afe1261683a81419aaa4d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CRC32&lt;/code&gt; option is not enabled in the constructor for this object, this method will always return 0;</source>
          <target state="translated">如果在构造函数中未为此对象启用 &lt;code&gt;CRC32&lt;/code&gt; 选项，则此方法将始终返回0；否则，此方法将始终返回0。</target>
        </trans-unit>
        <trans-unit id="1078abcc96e5bc5e00a4c013f64ebcf42ad64647" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">如果在 &lt;code&gt;ConsumeInput&lt;/code&gt; &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; 对象时ConsumeInput选项已设置为true ，则 &lt;code&gt;$input&lt;/code&gt; 参数将由 &lt;code&gt;inflate&lt;/code&gt; 修改。完成后，它将包含充气后输入缓冲区的剩余内容。实际上，这意味着当返回状态为 &lt;code&gt;Z_OK&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含一个空字符串，而当返回状态为 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含在放气数据之后存储在输入缓冲区中的内容（如果有的话）流。</target>
        </trans-unit>
        <trans-unit id="fc67951579ca54e84043acbb0bb761bab4628359" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ConsumeInput&lt;/code&gt; option has been set to true when the &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; object is created, the &lt;code&gt;$input&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &lt;code&gt;Z_OK&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contain an empty string, and when the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$input&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">如果在 &lt;code&gt;ConsumeInput&lt;/code&gt; &lt;code&gt;Compress::Raw::Zlib::Inflate&lt;/code&gt; 对象时ConsumeInput选项已设置为true ，则 &lt;code&gt;$input&lt;/code&gt; 参数将由 &lt;code&gt;inflate&lt;/code&gt; 修改。完成后，它将包含充气后输入缓冲区的剩余内容。实际上，这意味着当返回状态为 &lt;code&gt;Z_OK&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含一个空字符串，而当返回状态为 &lt;code&gt;Z_STREAM_END&lt;/code&gt; 时， &lt;code&gt;$input&lt;/code&gt; 参数将包含在放气数据之后存储在输入缓冲区中的内容（如果有的话）溪流。</target>
        </trans-unit>
        <trans-unit id="6a12981a50e52bd8360e58342fda216fd19888ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; bit is</source>
          <target state="translated">如果 &lt;code&gt;Encode::LEAVE_SRC&lt;/code&gt; 位为</target>
        </trans-unit>
        <trans-unit id="62a22e2f1c67e582e14dc75490b36c8927949628" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD&lt;/code&gt; flag is supplied, the SV may be a reference to a CV or &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="translated">如果提供了 &lt;code&gt;G_METHOD&lt;/code&gt; 标志，则SV可能是对CV的引用，或者 &lt;code&gt;SvPV(sv)&lt;/code&gt; 将用作调用方法的名称。</target>
        </trans-unit>
        <trans-unit id="60434689d4799ff053da9df2280e53454e60d84f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; flag is supplied, &lt;code&gt;SvPV(sv)&lt;/code&gt; will be used as the name of the method to call.</source>
          <target state="translated">如果提供了 &lt;code&gt;G_METHOD_NAMED&lt;/code&gt; 标志，则 &lt;code&gt;SvPV(sv)&lt;/code&gt; 将用作调用方法的名称。</target>
        </trans-unit>
        <trans-unit id="1bd3991b928d2bed7eef1e209952394cc1a3b16f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">如果给出 &lt;code&gt;Listen&lt;/code&gt; 参数，但为false，则队列大小将设置为5。</target>
        </trans-unit>
        <trans-unit id="1143100ee61e97ea2197747ccc58abb62c39ba7a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Minimal&lt;/code&gt; option is set to true, this option will be ignored.</source>
          <target state="translated">如果将&amp;ldquo; &lt;code&gt;Minimal&lt;/code&gt; 选项设置为true，则将忽略此选项。</target>
        </trans-unit>
        <trans-unit id="9ef4eef7ec7365669f7a6fdd21df15f840876c21" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_ELLIPSES&lt;/code&gt; flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_PRETTY_ELLIPSES&lt;/code&gt; 标志，并且没有输出字符串中的所有字符，则在字符串后附加省略号 &lt;code&gt;...&lt;/code&gt; 。请注意，这种情况发生在引用之后。</target>
        </trans-unit>
        <trans-unit id="49e3d7b68bb44fc1098b8d656037c9de9b76dfb2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERL_PV_PRETTY_QUOTE&lt;/code&gt; flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the &lt;code&gt;PERL_PV_PRETTY_LTGT&lt;/code&gt; flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_PRETTY_QUOTE&lt;/code&gt; 标志，则结果将用双引号引起来，并在转义的字符串中包含任何双引号。否则，如果设置了 &lt;code&gt;PERL_PV_PRETTY_LTGT&lt;/code&gt; 标志，则将结果包装在尖括号中。</target>
        </trans-unit>
        <trans-unit id="113ffd5bd789ac46d3a6013680e6ad870731e0ce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;REQUEST_METHOD&lt;/code&gt; environment variable is set, then this might be a CGI process and &lt;code&gt;HTTP_PROXY&lt;/code&gt; would be set from the &lt;code&gt;Proxy:&lt;/code&gt; header, which is a security risk. If &lt;code&gt;REQUEST_METHOD&lt;/code&gt; is set, &lt;code&gt;HTTP_PROXY&lt;/code&gt; (the upper case variant only) is ignored.</source>
          <target state="translated">如果设置了 &lt;code&gt;REQUEST_METHOD&lt;/code&gt; 环境变量，则这可能是一个CGI进程，并且将从 &lt;code&gt;Proxy:&lt;/code&gt; 标头设置 &lt;code&gt;HTTP_PROXY&lt;/code&gt; ，这存在安全隐患。如果设置了 &lt;code&gt;REQUEST_METHOD&lt;/code&gt; ，则将忽略 &lt;code&gt;HTTP_PROXY&lt;/code&gt; （仅大写形式）。</target>
        </trans-unit>
        <trans-unit id="9b0cd9b590461a3324fa8fa68396f36ebee97301" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Strict&lt;/code&gt; is on it will automatically enable this option.</source>
          <target state="translated">如果启用 &lt;code&gt;Strict&lt;/code&gt; ，它将自动启用此选项。</target>
        </trans-unit>
        <trans-unit id="1a5a03dfea212cb5b29a1fbf2d5e717d48359451" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;YAML&lt;/code&gt; or the &lt;code&gt;YAML::Syck&lt;/code&gt; module is installed a record of the internal state of all modules is written to disk after each step. The files contain a signature of the currently running perl version for later perusal.</source>
          <target state="translated">如果安装了 &lt;code&gt;YAML&lt;/code&gt; 或 &lt;code&gt;YAML::Syck&lt;/code&gt; 模块，则在每个步骤之后，所有模块的内部状态记录都会写入磁盘。这些文件包含当前运行的perl版本的签名，以供日后阅读。</target>
        </trans-unit>
        <trans-unit id="c82a6fc0a2f95bf7629d02360284d3c7a1ca8a6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt; . If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">如果 &lt;code&gt;can&lt;/code&gt; 返回false，则将其传递给 &lt;code&gt;ok&lt;/code&gt; 。如果返回true，那么更大的表达式 &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; 返回1，即 &lt;code&gt;ok&lt;/code&gt; 认为是成功的一个简单的信号，如你所愿。</target>
        </trans-unit>
        <trans-unit id="876835f5a189b420b4b1dda2b457e7a93555e339" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;can&lt;/code&gt; returns false, then that is passed to &lt;code&gt;ok&lt;/code&gt;. If it returns true, then the larger expression &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; returns 1, which &lt;code&gt;ok&lt;/code&gt; sees as a simple signal of success, as you would expect.</source>
          <target state="translated">如果 &lt;code&gt;can&lt;/code&gt; 返回false，则将其传递给 &lt;code&gt;ok&lt;/code&gt; 。如果返回true，那么更大的表达式 &lt;code&gt;$thingy-&amp;gt;can('some_method') &amp;amp;&amp;amp; 1&lt;/code&gt; 返回1，即 &lt;code&gt;ok&lt;/code&gt; 认为是成功的一个简单的信号，如你所愿。</target>
        </trans-unit>
        <trans-unit id="8bb03363c1cc83c40db7187bc0c1808c11643507" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charscript()&lt;/code&gt; 参数不是已知脚本，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ecb007ef4038a90f65cf1dae4d321b995b3815d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;charscript()&lt;/code&gt; argument is not a known script, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charscript()&lt;/code&gt; 参数不是已知脚本，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abc210b43b03b8ee41f920df8c0e913cce7e9cdb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is a code reference, it will be called iteratively to provide the content body of the request. It should return the empty string or undef when the iterator is exhausted.</source>
          <target state="translated">如果 &lt;code&gt;content&lt;/code&gt; 选项是代码引用，它将被迭代调用以提供请求的内容主体。迭代器用尽时，它应该返回空字符串或undef。</target>
        </trans-unit>
        <trans-unit id="9c7688f4c054c95562671f461204e8d1909c8763" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;content&lt;/code&gt; option is the empty string, no &lt;code&gt;content-type&lt;/code&gt; or &lt;code&gt;content-length&lt;/code&gt; headers will be generated.</source>
          <target state="translated">如果 &lt;code&gt;content&lt;/code&gt; 选项为空字符串，则不会生成 &lt;code&gt;content-type&lt;/code&gt; 或 &lt;code&gt;content-length&lt;/code&gt; 标头。</target>
        </trans-unit>
        <trans-unit id="5a6115ecc6df609b525cd058a3289a9b186700a5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;data_callback&lt;/code&gt; option is provided, it will be called iteratively until the entire response body is received. The first argument will be a string containing a chunk of the response body, the second argument will be the in-progress response hash reference, as described below. (This allows customizing the action of the callback based on the &lt;code&gt;status&lt;/code&gt; or &lt;code&gt;headers&lt;/code&gt; received prior to the content body.)</source>
          <target state="translated">如果提供了 &lt;code&gt;data_callback&lt;/code&gt; 选项，它将被迭代调用，直到接收到整个响应主体为止。第一个参数将是一个包含响应主体块的字符串，第二个参数将是进行中的响应哈希引用，如下所述。 （这允许根据在内容主体之前接收到的 &lt;code&gt;status&lt;/code&gt; 或 &lt;code&gt;headers&lt;/code&gt; 定义回调的操作。）</target>
        </trans-unit>
        <trans-unit id="15aaa040db904ad0d7e939ff87d0289e4ed113e7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; . In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">如果不能在不丢失信息的情况下完成 &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; 转换，则结果与转换顺序十进制字符串- &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; 。特别是，尽管 &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; 类的数字可能会四舍五入，但舍入强烈偏向0 。</target>
        </trans-unit>
        <trans-unit id="c844a354fc5d5e3ba8448bfcc0461c2e96ef53fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; conversion cannot be done without loss of information, the result is compatible with the conversion sequence &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt;. In particular, rounding is strongly biased to 0, though a number like &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; has a chance of being rounded to 1.</source>
          <target state="translated">如果不能在不丢失信息的情况下完成 &lt;code&gt;decimal string --&amp;gt; native integer&lt;/code&gt; 转换，则结果与转换顺序 &lt;code&gt;decimal_string --&amp;gt; native_floating_point --&amp;gt; native_integer&lt;/code&gt; 。特别是，虽然 &lt;code&gt;&quot;0.99999999999999999999&quot;&lt;/code&gt; 类的数字可能会四舍五入，但舍入强烈偏向0 。</target>
        </trans-unit>
        <trans-unit id="6e4484ac7779a53de50aea47a7a5981f680fda36" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;encoding&lt;/code&gt; pragma is in scope then the lengths returned are calculated from the length of &lt;code&gt;$/&lt;/code&gt; in Unicode characters, which is not always the same as the length of &lt;code&gt;$/&lt;/code&gt; in the native encoding.</source>
          <target state="translated">如果 &lt;code&gt;encoding&lt;/code&gt; 杂项在范围内，则返回的长度是根据Unicode字符中 &lt;code&gt;$/&lt;/code&gt; 的长度计算得出的，而该长度并不总是与本机编码中 &lt;code&gt;$/&lt;/code&gt; 的长度相同。</target>
        </trans-unit>
        <trans-unit id="bb917cbee0d97141aac38b7ae445c57c18b27f43" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;export_fail&lt;/code&gt; method returns an empty list then no error is recorded and all the requested symbols are exported. If the returned list is not empty then an error is generated for each symbol and the export fails. The Exporter provides a default &lt;code&gt;export_fail&lt;/code&gt; method which simply returns the list unchanged.</source>
          <target state="translated">如果 &lt;code&gt;export_fail&lt;/code&gt; 方法返回一个空列表，则不会记录任何错误，并且会导出所有请求的符号。如果返回的列表不为空，则为每个符号生成错误，并且导出失败。导出器提供了默认的 &lt;code&gt;export_fail&lt;/code&gt; 方法，该方法只返回不变的列表。</target>
        </trans-unit>
        <trans-unit id="276362d098a443c72a3870f2a2d48ae260499ef9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 存在并且不在符号表中，则此函数简单地返回。如果 &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; 将被跳过。</target>
        </trans-unit>
        <trans-unit id="9956d32eb4cf510432b5c2113065ce4d2ab05fcd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gv&lt;/code&gt; is present and is not in the symbol table, then this function simply returns. This checked will be skipped if &lt;code&gt;flags &amp;amp; 1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;gv&lt;/code&gt; 存在并且不在符号表中，则此函数简单地返回。如果 &lt;code&gt;flags &amp;amp; 1&lt;/code&gt; 将被跳过。</target>
        </trans-unit>
        <trans-unit id="798f35bb0e17493f55f47f1e0e601507174d7021" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maxdepth&lt;/code&gt; is included, it must be a numeral</source>
          <target state="translated">如果包括 &lt;code&gt;maxdepth&lt;/code&gt; ，则必须为数字</target>
        </trans-unit>
        <trans-unit id="58bc648a8e07d1ab46d67c368d31d1e61d6eb6fc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;realpath&lt;/code&gt; function is not available, or is unable to return the real path of the file, &lt;code&gt;unixrealpath&lt;/code&gt; will use the same internal procedure as the &lt;code&gt;vmsrealpath&lt;/code&gt; function and convert the output to a Unix format specification. It is not available on non-VMS systems.</source>
          <target state="translated">如果 &lt;code&gt;realpath&lt;/code&gt; 函数不可用，或者无法返回文件的真实路径，则 &lt;code&gt;unixrealpath&lt;/code&gt; 将使用与 &lt;code&gt;vmsrealpath&lt;/code&gt; 函数相同的内部过程，并将输出转换为Unix格式规范。在非VMS系统上不可用。</target>
        </trans-unit>
        <trans-unit id="622e9bbb1973cba189a5047eab876b3fea0127f4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;table&lt;/code&gt; attribute (see below) is set then a renderer may choose to display the table instead of the details.</source>
          <target state="translated">如果设置了 &lt;code&gt;table&lt;/code&gt; 属性（请参见下文），则渲染器可以选择显示表而不是显示详细信息。</target>
        </trans-unit>
        <trans-unit id="4672f4a6483db1b05eeb609d8e652aab384c295c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;timelocal()&lt;/code&gt; function is given a non-existent local time, it will simply return an epoch value for the time one hour later.</source>
          <target state="translated">如果给 &lt;code&gt;timelocal()&lt;/code&gt; 函数提供了不存在的本地时间，则它将仅在一个小时后返回该时间的纪元值。</target>
        </trans-unit>
        <trans-unit id="d8b1721e1ae657f367e4018c29dc66b147cf1c09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;uncompress&lt;/code&gt; or &lt;code&gt;gunzip&lt;/code&gt; programs are available, you can use one of these workarounds to read &lt;code&gt;.tar.Z&lt;/code&gt; files from &lt;code&gt;Archive::Tar&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;uncompress&lt;/code&gt; 程序或 &lt;code&gt;gunzip&lt;/code&gt; 程序可用，则可以使用以下变通办法之一来从 &lt;code&gt;Archive::Tar&lt;/code&gt; 读取 &lt;code&gt;.tar.Z&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="cddc99dbc25aed0c730c0fe2bb39cef906b6e6a7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">如果启用了 &lt;code&gt;unicode_eval&lt;/code&gt; 功能（这是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 或更高版本的声明中的默认设置），则EXPR或 &lt;code&gt;$_&lt;/code&gt; 被视为字符串，因此 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明无效，并且禁止源过滤器。在缺少 &lt;code&gt;unicode_eval&lt;/code&gt; 功能的情况下，根据内部编码，有时会将字符串视为字符，有时视为字节，并且在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中激活的源过滤器会表现出影响某些外部文件范围的不稳定但历史性的行为。仍在编译。另请参阅&lt;a href=&quot;#evalbytes&quot;&gt;evalbytes&lt;/a&gt;关键字，该关键字始终将其输入视为字节流，并且可以与源过滤器和&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;杂注一起正常使用。</target>
        </trans-unit>
        <trans-unit id="87e45908e093ce58a5e789307a68cc9a88437767" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;unicode_eval&lt;/code&gt; feature is enabled (which is the default under a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; or higher declaration), EXPR or &lt;code&gt;$_&lt;/code&gt; is treated as a string of characters, so &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declarations have no effect, and source filters are forbidden. In the absence of the &lt;code&gt;unicode_eval&lt;/code&gt; feature, the string will sometimes be treated as characters and sometimes as bytes, depending on the internal encoding, and source filters activated within the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; exhibit the erratic, but historical, behaviour of affecting some outer file scope that is still compiling. See also the &lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt; keyword, which always treats its input as a byte stream and works properly with source filters, and the &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; pragma.</source>
          <target state="translated">如果启用了 &lt;code&gt;unicode_eval&lt;/code&gt; 功能（这是 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; 5.16&lt;/code&gt; 或更高版本的声明中的默认设置），则EXPR或 &lt;code&gt;$_&lt;/code&gt; 被视为字符串，因此 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 声明无效，并且禁止源过滤器。在缺少 &lt;code&gt;unicode_eval&lt;/code&gt; 功能的情况下，根据内部编码，有时会将字符串视为字符，有时视为字节，并且在 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 中激活的源过滤器会表现出影响某些外部文件范围的不稳定但历史性的行为。仍在编译。另请参阅&lt;a href=&quot;evalbytes&quot;&gt;evalbytes&lt;/a&gt;关键字，该关键字始终将其输入视为字节流，并且可以与源过滤器和&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;杂注一起正常使用。</target>
        </trans-unit>
        <trans-unit id="094a307e3b02182e7190ab8c7d41908a31be7b6f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt; option is not given, the encoding of its output file handle will be forced to the detected encoding of the input POD, which preserves whatever the input text is. This ensures backward compatibility with earlier, pre-Unicode versions of this module, without large numbers of Perl warnings.</source>
          <target state="translated">如果未提供 &lt;code&gt;utf8&lt;/code&gt; 选项，则其输出文件句柄的编码将被强制为检测到的输入POD的编码，这将保留输入文本的内容。这样可确保与该模块的早期Unicode以前版本向后兼容，而不会出现大量Perl警告。</target>
        </trans-unit>
        <trans-unit id="9d9b06ad91f4e14141b1e47f8d38395a6c62e787" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;utf8&lt;/code&gt;-flag is enabled, &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; will encode all characters using the corresponding UTF-8 multi-byte sequence, and will expect your input strings to be encoded as UTF-8, that is, no &quot;character&quot; of the input string must have any value &amp;gt; 255, as UTF-8 does not allow that.</source>
          <target state="translated">如果启用了 &lt;code&gt;utf8&lt;/code&gt; -flag，则 &lt;code&gt;encode&lt;/code&gt; / &lt;code&gt;decode&lt;/code&gt; 将使用相应的UTF-8多字节序列对所有字符进行编码，并且将期望您的输入字符串被编码为UTF-8，即输入中没有&amp;ldquo;字符&amp;rdquo;字符串必须具有大于255的任何值，因为UTF-8不允许这样做。</target>
        </trans-unit>
        <trans-unit id="b5abb9df31ef6516fcae104f653339d0026bd9e0" translate="yes" xml:space="preserve">
          <source>If the AIX Toolbox version of lib gdbm &amp;lt; 1.8.3-5 is installed on your system then Perl will not work. This library contains the header files /opt/freeware/include/gdbm/dbm.h|ndbm.h which conflict with the AIX system versions. The lib gdbm will be automatically removed from the wanted libraries if the presence of one of these two header files is detected. If you want to build Perl with GDBM support then please install at least gdbm-devel-1.8.3-5 (or higher).</source>
          <target state="translated">如果您的系统上安装了lib gdbm &amp;lt;1.8.3-5的AIX Toolbox版本，则Perl将不起作用。该库包含与AIX系统版本冲突的头文件/opt/freeware/include/gdbm/dbm.h|ndbm.h。如果检测到这两个头文件之一，则lib gdbm将自动从所需的库中删除。如果要使用GDBM支持构建Perl，请至少安装gdbm-devel-1.8.3-5（或更高版本）。</target>
        </trans-unit>
        <trans-unit id="e4f37200eb3cc7a4dd0c87959fbb6c2e093e138e" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; , except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">如果C函数setvbuf（）可用，则 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 设置FileHandle的缓冲策略。 Perl函数的调用顺序与其C对应的调用顺序相同，包括宏 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; ，不同之处在于buffer参数指定了用作缓冲区的标量变量。警告：在关闭 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 或再次调用FileHandle :: setvbuf之前，不得以任何方式修改 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 用作缓冲区的变量，否则可能导致内存损坏！</target>
        </trans-unit>
        <trans-unit id="299d706db577fab624c88622bc091e3abdb77143" translate="yes" xml:space="preserve">
          <source>If the C function setvbuf() is available, then &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; sets the buffering policy for the FileHandle. The calling sequence for the Perl function is the same as its C counterpart, including the macros &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt;, except that the buffer parameter specifies a scalar variable to use as a buffer. WARNING: A variable used as a buffer by &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; must not be modified in any way until the FileHandle is closed or until &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; is called again, or memory corruption may result!</source>
          <target state="translated">如果C函数setvbuf（）可用，则 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 设置FileHandle的缓冲策略。 Perl函数的调用顺序与其C对应的调用顺序相同，包括宏 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; ，不同之处在于buffer参数指定了用作缓冲区的标量变量。警告：在关闭 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 或再次调用FileHandle :: setvbuf之前，不得以任何方式修改 &lt;code&gt;FileHandle::setvbuf&lt;/code&gt; 用作缓冲区的变量，否则可能导致内存损坏！</target>
        </trans-unit>
        <trans-unit id="1a7ae4abb775cdaecaa965021a5be89b2c2a0678" translate="yes" xml:space="preserve">
          <source>If the C functions fgetpos() and fsetpos() are available, then &lt;code&gt;FileHandle::getpos&lt;/code&gt; returns an opaque value that represents the current position of the FileHandle, and &lt;code&gt;FileHandle::setpos&lt;/code&gt; uses that value to return to a previously visited position.</source>
          <target state="translated">如果C函数fgetpos（）和fsetpos（）可用，则 &lt;code&gt;FileHandle::getpos&lt;/code&gt; 返回一个不透明的值，该值表示FileHandle的当前位置，而 &lt;code&gt;FileHandle::setpos&lt;/code&gt; 使用该值返回到先前访问的位置。</target>
        </trans-unit>
        <trans-unit id="50ebbabfe865d409f0b42636c02f4e83fa99aca9" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt; , &lt;code&gt;_IOLBF&lt;/code&gt; , and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">如果C函数setbuf（）和/或setvbuf（）可用，则 &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; 和 &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; 设置IO :: Handle的缓冲策略。 Perl函数的调用序列与C函数的调用序列相同-包括setvbuf（）的常量 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; -区别在于buffer参数指定了用作缓冲区的标量变量。您仅应在任何I / O之前或在调用flush之后立即更改缓冲区。</target>
        </trans-unit>
        <trans-unit id="4b39a4db83d5ceb015a67a35d8f623bb0eb08d0e" translate="yes" xml:space="preserve">
          <source>If the C functions setbuf() and/or setvbuf() are available, then &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; and &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; set the buffering policy for an IO::Handle. The calling sequences for the Perl functions are the same as their C counterparts--including the constants &lt;code&gt;_IOFBF&lt;/code&gt;, &lt;code&gt;_IOLBF&lt;/code&gt;, and &lt;code&gt;_IONBF&lt;/code&gt; for setvbuf()--except that the buffer parameter specifies a scalar variable to use as a buffer. You should only change the buffer before any I/O, or immediately after calling flush.</source>
          <target state="translated">如果C函数setbuf（）和/或setvbuf（）可用，则 &lt;code&gt;IO::Handle::setbuf&lt;/code&gt; 和 &lt;code&gt;IO::Handle::setvbuf&lt;/code&gt; 设置IO :: Handle的缓冲策略。 Perl函数的调用序列与C的调用序列相同-包括setvbuf（）的常量 &lt;code&gt;_IOFBF&lt;/code&gt; ， &lt;code&gt;_IOLBF&lt;/code&gt; 和 &lt;code&gt;_IONBF&lt;/code&gt; ，除了buffer参数指定要用作缓冲区的标量变量之外。您仅应在任何I / O之前或在调用flush之后立即更改缓冲区。</target>
        </trans-unit>
        <trans-unit id="cb7a6c24ac237588ebe82997b3227d4077970889" translate="yes" xml:space="preserve">
          <source>If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the header must match the crc16 value of the gzip header actually read.</source>
          <target state="translated">如果在gzip FLG头字节中设置了FHCRC位,则头中的CRC16字节必须与实际读取的gzip头的crc16值相匹配。</target>
        </trans-unit>
        <trans-unit id="716df9a8cd6dfb775c171f4188701d3aabf993bd" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;../perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">如果PATTERN包含&lt;a href=&quot;../perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;捕获组&lt;/a&gt;，那么对于每个分隔符，将为由组捕获的每个子字符串生成一个附加字段（按照&lt;a href=&quot;../perlretut#Backreferences&quot;&gt;反向引用的&lt;/a&gt;方式指定组的顺序）；如果任何组不匹配，则它将捕获 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值而不是子字符串。此外，请注意，任何这样的附加字段产生每当有一个分离器（即，每当发生分裂），并且这样的一个附加的字段也&lt;b&gt;未&lt;/b&gt;向限制计数。考虑在列表上下文中评估的以下表达式（每个返回的列表在关联的注释中提供）：</target>
        </trans-unit>
        <trans-unit id="19ac8a832643510531c14e9722a2a956f43fd56c" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">如果PATTERN包含&lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;捕获组&lt;/a&gt;，则对于每个分隔符，将为由组捕获的每个子字符串生成一个附加字段（按照&lt;a href=&quot;perlretut#Backreferences&quot;&gt;反向引用的&lt;/a&gt;方式指定组的顺序）；如果任何组不匹配，则它将捕获&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;值而不是子字符串。此外，请注意，任何这样的附加字段产生每当有一个分离器（即，每当发生分裂），并且这样的一个附加的字段也&lt;b&gt;未&lt;/b&gt;向限制计数。考虑在列表上下文中评估的以下表达式（相关注释中提供了每个返回的列表）：</target>
        </trans-unit>
        <trans-unit id="82d842f2ab3731c9a4a0e7946b2b84aa92b80adc" translate="yes" xml:space="preserve">
          <source>If the PATTERN contains &lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;capturing groups&lt;/a&gt;, then for each separator, an additional field is produced for each substring captured by a group (in the order in which the groups are specified, as per &lt;a href=&quot;perlretut#Backreferences&quot;&gt;backreferences&lt;/a&gt;); if any group does not match, then it captures the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value instead of a substring. Also, note that any such additional field is produced whenever there is a separator (that is, whenever a split occurs), and such an additional field does &lt;b&gt;not&lt;/b&gt; count towards the LIMIT. Consider the following expressions evaluated in list context (each returned list is provided in the associated comment):</source>
          <target state="translated">如果PATTERN包含&lt;a href=&quot;perlretut#Grouping-things-and-hierarchical-matching&quot;&gt;捕获组&lt;/a&gt;，那么对于每个分隔符，将为由组捕获的每个子字符串生成一个附加字段（按照&lt;a href=&quot;perlretut#Backreferences&quot;&gt;反向引用的&lt;/a&gt;方式指定组的顺序）；如果任何组不匹配，则它将捕获 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值而不是子字符串。此外，请注意，任何这样的附加字段产生每当有一个分离器（即，每当发生分裂），并且这样的一个附加的字段也&lt;b&gt;未&lt;/b&gt;向限制计数。考虑在列表上下文中评估的以下表达式（每个返回的列表在关联的注释中提供）：</target>
        </trans-unit>
        <trans-unit id="4e7443d40abaa23829b9ab709311a1922fe461b6" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_ELLIPSES flag is set and not all characters in string were output then an ellipsis &lt;code&gt;...&lt;/code&gt; will be appended to the string. Note that this happens AFTER it has been quoted.</source>
          <target state="translated">如果设置了PERL_PV_PRETTY_ELLIPSES标志，并且没有输出字符串中的所有字符，则在字符串后附加省略号 &lt;code&gt;...&lt;/code&gt; 。请注意，这种情况发生在引用之后。</target>
        </trans-unit>
        <trans-unit id="09680d261a6a88f2e5836c919a2510509957b1e5" translate="yes" xml:space="preserve">
          <source>If the PERL_PV_PRETTY_QUOTE flag is set then the result will be double quoted with any double quotes in the string escaped. Otherwise if the PERL_PV_PRETTY_LTGT flag is set then the result be wrapped in angle brackets.</source>
          <target state="translated">如果PERL_PV_PRETTY_QUOTE标志被设置,那么结果将使用双引号,并将字符串中的任何双引号转义。否则,如果PERL_PV_PRETTY_LTGT标志被设置,那么结果将被包裹在角括号中。</target>
        </trans-unit>
        <trans-unit id="b990fe2846203877eedfbcf554045c1e773431f8" translate="yes" xml:space="preserve">
          <source>If the POD is inconsistent about the indentation of verbatim blocks, but you have figured out a heuristic to determine how much a particular verbatim block is indented, you can pass a code reference instead. The code reference will be executed with one argument, an array reference of all the lines in the verbatim block, and should return the value to be stripped from each line. For example, if you decide that you're fine to use the first line of the verbatim block to set the standard for indentation of the rest of the block, you can look at the first line and return the appropriate value, like so:</source>
          <target state="translated">如果POD对逐字块的缩进程度不一致,但你已经想出了一个启发式方法来确定某个逐字块的缩进程度,你可以传递一个代码引用来代替。该代码引用将以一个参数来执行,这个参数是逐字记录块中所有行的数组引用,并且应该返回要从每一行中剥离的值。例如,如果你决定用逐字块的第一行来设置其余块的缩进标准是没有问题的,你可以查看第一行并返回适当的值,就像这样。</target>
        </trans-unit>
        <trans-unit id="d38f09a374f3f254883a79ac66d4d89714b8faea" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or CP 1252) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;. (If the POD source contains only ASCII bytes, the encoding is assumed to be ASCII.)</source>
          <target state="translated">如果POD源不包含 &lt;code&gt;=encoding&lt;/code&gt; 声明，则解析器将通过检查第一个非ASCII字节并应用&lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec中&lt;/a&gt;描述的启发式方法来尝试猜测编码（选择UTF-8或CP 1252中的一个）。（如果POD源仅包含ASCII字节，则假定编码为ASCII。）</target>
        </trans-unit>
        <trans-unit id="e9fd97e2c853d040e2b1f08382eba5acd7317a9d" translate="yes" xml:space="preserve">
          <source>If the POD source does not include an &lt;code&gt;=encoding&lt;/code&gt; declaration, the parser will attempt to guess the encoding (selecting one of UTF-8 or Latin-1) by examining the first non-ASCII bytes and applying the heuristic described in &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;.</source>
          <target state="translated">如果POD源不包含 &lt;code&gt;=encoding&lt;/code&gt; 声明，则解析器将通过检查第一个非ASCII字节并应用&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec中&lt;/a&gt;描述的启发式方法来尝试猜测编码（选择UTF-8或Latin-1中的一个）。</target>
        </trans-unit>
        <trans-unit id="539121ee50a224917b8fad7fe828de50a4356761" translate="yes" xml:space="preserve">
          <source>If the POD you're parsing adheres to a consistent indentation policy, you can have such indentation stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what to strip. For two-space indents, you'd use:</source>
          <target state="translated">如果您正在解析的POD遵循一致的缩进策略,您可以从您的逐字块的每一行开始剥离这种缩进。这个方法告诉Pod::Simple要去掉什么。对于两个空格的缩进,你可以使用。</target>
        </trans-unit>
        <trans-unit id="41c4b629a3e2e0346fc506d9a6f6a02afa0eab8b" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in Perl's extended UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns FALSE if the PV is invalid UTF-8.</source>
          <target state="translated">如果SV的PV是Perl扩展的UTF-8中的八位字节序列，并且包含多字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志将打开，使其看起来像一个字符。如果PV仅包含单字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志保持关闭状态。扫描PV的有效性，如果PV无效的UTF-8，则返回FALSE。</target>
        </trans-unit>
        <trans-unit id="767d61bbd817028665e597ffd44d52d2f3072a5a" translate="yes" xml:space="preserve">
          <source>If the PV of the SV is an octet sequence in UTF-8 and contains a multiple-byte character, the &lt;code&gt;SvUTF8&lt;/code&gt; flag is turned on so that it looks like a character. If the PV contains only single-byte characters, the &lt;code&gt;SvUTF8&lt;/code&gt; flag stays off. Scans PV for validity and returns false if the PV is invalid UTF-8.</source>
          <target state="translated">如果SV的PV是UTF-8中的八位字节序列，并且包含多字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志将打开，以使其看起来像一个字符。如果PV仅包含单字节字符，则 &lt;code&gt;SvUTF8&lt;/code&gt; 标志保持关闭状态。扫描PV的有效性，如果PV无效的UTF-8，则返回false。</target>
        </trans-unit>
        <trans-unit id="5ce916c1cc7717c4e805155c2d7548fbc24c77ee" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt; , then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">如果Perl脚本被作为执行 &lt;code&gt;perl scriptname&lt;/code&gt; ，然后&lt;b&gt;- ％C&lt;/b&gt;选项就必须出现在命令行： &lt;code&gt;perl -%c scriptname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f041d8f750e7891231f6ef945e98ccc9b459b45e" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as &lt;code&gt;perl scriptname&lt;/code&gt;, then the &lt;b&gt;-%c&lt;/b&gt; option must appear on the command line: &lt;code&gt;perl -%c scriptname&lt;/code&gt;.</source>
          <target state="translated">如果Perl脚本被作为执行 &lt;code&gt;perl scriptname&lt;/code&gt; ，然后&lt;b&gt;- ％C&lt;/b&gt;选项就必须出现在命令行： &lt;code&gt;perl -%c scriptname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde4187a6aa163d9c96f574141763bdd38ae34f7" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt; .</source>
          <target state="translated">如果使用＃！将Perl脚本作为命令执行。机制（或其本地等效项），通常可以通过编辑＃！来解决此错误。行，以便&lt;b&gt;-％c&lt;/b&gt;选项成为Perl第一个参数的一部分：例如，将 &lt;code&gt;perl -n -%c&lt;/code&gt; 更改为 &lt;code&gt;perl -%c -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8bf71d735699bc0d3dafa8fc7795c33b9452d54" translate="yes" xml:space="preserve">
          <source>If the Perl script is being executed as a command using the #! mechanism (or its local equivalent), this error can usually be fixed by editing the #! line so that the &lt;b&gt;-%c&lt;/b&gt; option is a part of Perl's first argument: e.g. change &lt;code&gt;perl -n -%c&lt;/code&gt; to &lt;code&gt;perl -%c -n&lt;/code&gt;.</source>
          <target state="translated">如果正在使用＃！将Perl脚本作为命令执行。机制（或其本地等效项），通常可以通过编辑＃！来解决此错误。行，以便&lt;b&gt;-％c&lt;/b&gt;选项成为Perl第一个参数的一部分：例如，将 &lt;code&gt;perl -n -%c&lt;/code&gt; 更改为 &lt;code&gt;perl -%c -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c878ced38c4f673dcc4c3921e7ce406e54b4b71" translate="yes" xml:space="preserve">
          <source>If the README file seems to be getting too large you may wish to split out some of the sections into separate files: INSTALL, Copying, ToDo etc.</source>
          <target state="translated">如果README文件似乎变得太大了,你可能会希望把一些部分拆成单独的文件。INSTALL,Copying,ToDo等等。</target>
        </trans-unit>
        <trans-unit id="bcda0ef071779fc235b5cd85b1d75a393d7ae1e4" translate="yes" xml:space="preserve">
          <source>If the Time::HiRes module has been installed, you can specify the special tag &lt;code&gt;:hireswallclock&lt;/code&gt; for Benchmark (if Time::HiRes is not available, the tag will be silently ignored). This tag will cause the wallclock time to be measured in microseconds, instead of integer seconds. Note though that the speed computations are still conducted in CPU time, not wallclock time.</source>
          <target state="translated">如果已安装Time :: HiRes模块， &lt;code&gt;:hireswallclock&lt;/code&gt; 以为Benchmark 指定特殊标签：hireswallclock（如果Time :: HiRes不可用，则该标签将被忽略）。此标签将使挂钟时间以微秒为单位，而不是整数秒。请注意，尽管速度计算仍以CPU时间而非壁钟时间进行。</target>
        </trans-unit>
        <trans-unit id="1e0de044d27a1f06d198fa6cd4b199e7a501a7e3" translate="yes" xml:space="preserve">
          <source>If the UNTIE method exists then the warning above does not occur. Instead the UNTIE method is passed the count of &quot;extra&quot; references and can issue its own warning if appropriate. e.g. to replicate the no UNTIE case this method can be used:</source>
          <target state="translated">如果UNTIE方法存在,那么上述警告就不会发生。取而代之的是,UNTIE方法被传递了 &quot;额外 &quot;引用的数量,并且可以在适当的时候发出自己的警告。例如,为了复制没有UNTIE的情况,可以使用这个方法。</target>
        </trans-unit>
        <trans-unit id="143e00ba94fc0b7d94b37e36ca76fc91860f4e9a" translate="yes" xml:space="preserve">
          <source>If the URL includes a &quot;user:password&quot; stanza, they will be used for Basic-style authorization headers. (Authorization headers will not be included in a redirected request.) For example:</source>
          <target state="translated">如果URL包含 &quot;user:password &quot;段,它们将被用于Basic风格的授权头。(授权头不会被包含在重定向请求中。)例如。</target>
        </trans-unit>
        <trans-unit id="0ecfe64b91fdc6593a92259993f050bf990c0868" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; will call the &lt;code&gt;VERSION&lt;/code&gt; method in class Module with the given version as an argument:</source>
          <target state="translated">如果VERSION参数存在于Module和LIST之间，则&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;将使用给定版本作为参数调用Module类中的 &lt;code&gt;VERSION&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="afcfedf6cd11f719819da193333a7cf6de0732a7" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">如果VERSION参数存在于Module和LIST之间，则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用给定版本作为参数调用Module类中的VERSION方法。如果给定版本大于变量 &lt;code&gt;$Module::VERSION&lt;/code&gt; 的值，则从UNIVERSAL类继承的默认VERSION方法将崩溃。</target>
        </trans-unit>
        <trans-unit id="28fd8c6bb88e030936b47d8b396e97702a34b855" translate="yes" xml:space="preserve">
          <source>If the VERSION argument is present between Module and LIST, then the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will call the VERSION method in class Module with the given version as an argument. The default VERSION method, inherited from the UNIVERSAL class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt; .</source>
          <target state="translated">如果VERSION参数存在于Module和LIST之间，则 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 将使用给定版本作为参数调用Module类中的VERSION方法。如果给定版本大于变量 &lt;code&gt;$Module::VERSION&lt;/code&gt; 的值，则从UNIVERSAL类继承的默认VERSION方法将崩溃。</target>
        </trans-unit>
        <trans-unit id="333bd150f2ebb931ff98dd0682381076be3b30d6" translate="yes" xml:space="preserve">
          <source>If the XSUB has a return type of &lt;code&gt;void&lt;/code&gt; then the compiler will not declare a RETVAL variable for that function. When using a PPCODE: section no manipulation of the RETVAL variable is required, the section may use direct stack manipulation to place output values on the stack.</source>
          <target state="translated">如果XSUB的返回类型为 &lt;code&gt;void&lt;/code&gt; ,则编译器将不会为该函数声明RETVAL变量。当使用PPCODE：节时，不需要对RETVAL变量进行任何操作，该节可以使用直接堆栈操作将输出值放在堆栈上。</target>
        </trans-unit>
        <trans-unit id="bebee72fc9aa0a9b169227a410e90f7f3df000ed" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">如果上述方法不起作用，或不足以适合您的应用程序，请针对有问题的模块，在&lt;a href=&quot;http://rt.cpan.org/Public/&quot;&gt;http://rt.cpan.org/Public/上&lt;/a&gt;提交错误报告。</target>
        </trans-unit>
        <trans-unit id="f43e61e618bcd86d5e8194fe59eff43dd8c761f1" translate="yes" xml:space="preserve">
          <source>If the above does not work, or is not adequate for your application, then file a bug report on &lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;https://rt.cpan.org/Public/&lt;/a&gt; against the problematic module.</source>
          <target state="translated">如果以上方法不起作用，或不足以适合您的应用程序，&lt;a href=&quot;https://rt.cpan.org/Public/&quot;&gt;请&lt;/a&gt;针对有问题的模块，在https://rt.cpan.org/Public/上提交错误报告。</target>
        </trans-unit>
        <trans-unit id="77f8b1f2470978bb7eb295cba54688c501c99623" translate="yes" xml:space="preserve">
          <source>If the above evaluates as true, the following methods will be available on the &lt;code&gt;$result&lt;/code&gt; object.</source>
          <target state="translated">如果以上评估为真，则 &lt;code&gt;$result&lt;/code&gt; 对象上将提供以下方法。</target>
        </trans-unit>
        <trans-unit id="3626e8a47b75cd9814f9aabb6f3226e20a12cd72" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt; . Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">如果您unimporting模块（通过的法案 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ）应该引起源代码过滤停止，创建一个 &lt;code&gt;unimport&lt;/code&gt; 子程序，并将它称之为 &lt;code&gt;filter_del&lt;/code&gt; 。确保在第5步中对 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 的调用不会意外读取到 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 之后。有效地，这将源代码过滤器限制为逐行操作，除非 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程对要过滤的源代码进行了一些预想的预准备。</target>
        </trans-unit>
        <trans-unit id="03a3b15e2a6cd5a22375d6379cdf2984cfbb61b0" translate="yes" xml:space="preserve">
          <source>If the act of unimporting your module (via a &lt;code&gt;no&lt;/code&gt;) should cause source code filtering to cease, create an &lt;code&gt;unimport&lt;/code&gt; subroutine, and have it call &lt;code&gt;filter_del&lt;/code&gt;. Make sure that the call to &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; in step 5 will not accidentally read past the &lt;code&gt;no&lt;/code&gt;. Effectively this limits source code filters to line-by-line operation, unless the &lt;code&gt;import&lt;/code&gt; subroutine does some fancy pre-pre-parsing of the source code it's filtering.</source>
          <target state="translated">如果您unimporting模块（通过的法案 &lt;code&gt;no&lt;/code&gt; ）应该引起源代码过滤停止，创建一个 &lt;code&gt;unimport&lt;/code&gt; 子程序，并将它称之为 &lt;code&gt;filter_del&lt;/code&gt; 。确保在第5步中对 &lt;code&gt;filter_read&lt;/code&gt; 或 &lt;code&gt;filter_read_exact&lt;/code&gt; 的调用不会意外地读取到 &lt;code&gt;no&lt;/code&gt; 之后。有效地，这将源代码筛选器限制为逐行操作，除非 &lt;code&gt;import&lt;/code&gt; 子例程对要过滤的源代码进行了一些预想的预准备。</target>
        </trans-unit>
        <trans-unit id="f14d384ae54d7fd6956617c902dc52b4f7c913e2" translate="yes" xml:space="preserve">
          <source>If the archive creation fails for any reason, &lt;code&gt;create_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">如果归档创建由于任何原因而失败，则 &lt;code&gt;create_archive&lt;/code&gt; 将返回false。请使用 &lt;code&gt;error&lt;/code&gt; 方法查找失败原因。</target>
        </trans-unit>
        <trans-unit id="bdb2a47c2b4d923874ce10a47d541cda074eec3d" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">如果参数中有比其它匹配的任何字符 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;:&lt;/code&gt; 或者 &lt;code&gt;'&lt;/code&gt; ，它必须是一个文件</target>
        </trans-unit>
        <trans-unit id="78aee964b82335874ff16d75333783914537914b" translate="yes" xml:space="preserve">
          <source>If the argument has any characters in it other than those matching &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, it must be a file</source>
          <target state="translated">如果参数中有比其它匹配的任何字符 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;:&lt;/code&gt; 或者 &lt;code&gt;'&lt;/code&gt; ，它必须是一个文件</target>
        </trans-unit>
        <trans-unit id="6ad412a6b0ecba8c1d6ad813bdece11aeaddeb49" translate="yes" xml:space="preserve">
          <source>If the argument is &quot;/cygdrive&quot;, then just the volume mount settings, and the cygdrive mount prefix are returned.</source>
          <target state="translated">如果参数是&quot;/cygdrive&quot;,则只返回卷挂载设置和cygdrive挂载前缀。</target>
        </trans-unit>
        <trans-unit id="b2f2982f0afdcf62760763525865c85306c36f4e" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 返回的已编译正则表达式，则此函数返回模式。</target>
        </trans-unit>
        <trans-unit id="7b654339779464179184dbeba32e40251c7e2e80" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 返回的已编译正则表达式，则此函数返回优化器认为是模式中最长的固定固定字符串和最长的浮动固定字符串的内容。</target>
        </trans-unit>
        <trans-unit id="81692e2cadc8efc40c200d83e4422a4728d67dbc" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;qr//&lt;/code&gt; 返回的已编译正则表达式，则此函数返回模式。</target>
        </trans-unit>
        <trans-unit id="f5c12c2dc9e5c6145a6b58c7acda0a55ed2d46c4" translate="yes" xml:space="preserve">
          <source>If the argument is a compiled regular expression as returned by &lt;code&gt;qr//&lt;/code&gt;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.</source>
          <target state="translated">如果参数是 &lt;code&gt;qr//&lt;/code&gt; 返回的已编译正则表达式，则此函数返回优化器认为是模式中最长的固定固定字符串和最长的浮动固定字符串的内容。</target>
        </trans-unit>
        <trans-unit id="5788205c6ad8a4a8ebfb81bffe26f845a9b7bbcb" translate="yes" xml:space="preserve">
          <source>If the argument is a distribution file name (recognized by embedded slashes), it is processed. If it is a module, CPAN determines the distribution file in which this module is included and processes that, following any dependencies named in the module's META.yml or Makefile.PL (this behavior is controlled by the configuration parameter &lt;code&gt;prerequisites_policy&lt;/code&gt; ). If an argument is enclosed in slashes it is treated as a regular expression: it is expanded and if the result is a single object (distribution, bundle or module), this object is processed.</source>
          <target state="translated">如果参数是分发文件名（由嵌入式斜杠识别），则将对其进行处理。如果是模块，则CPAN将确定包含此模块的分发文件，并根据模块的META.yml或Makefile.PL中命名的任何依赖项来处理该分发文件（此行为由配置参数 &lt;code&gt;prerequisites_policy&lt;/code&gt; 控制）。如果参数用斜杠括起来，则将其视为正则表达式：将对其进行扩展，并且如果结果是单个对象（分布，分发包或模块），则将处理该对象。</target>
        </trans-unit>
        <trans-unit id="b117f48b026da0b0825304f95daf71b17bbf61f6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;[\w:']&lt;/code&gt;, it must be a module</source>
          <target state="translated">如果参数仅匹配 &lt;code&gt;[\w:']&lt;/code&gt; ，则它必须是一个模块</target>
        </trans-unit>
        <trans-unit id="0af3cf093a2df4958131449dc2e48cabc581ef28" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt; , it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">如果参数仅匹配 &lt;code&gt;\w&lt;/code&gt; ，则它可以是模块或文件。我们将尝试首先在 &lt;code&gt;@INC&lt;/code&gt; 中找到 &lt;code&gt;file.pm&lt;/code&gt; ，如果失败，我们将尝试在@INC中找到 &lt;code&gt;file&lt;/code&gt; 。如果两者均失败，我们将死于各自的错误消息。</target>
        </trans-unit>
        <trans-unit id="a134e7d8148a5bb9fcca57ef03ba8d4ffbcb83b6" translate="yes" xml:space="preserve">
          <source>If the argument matches only &lt;code&gt;\w&lt;/code&gt;, it could either be a module or a file. We will try to find &lt;code&gt;file.pm&lt;/code&gt; first in &lt;code&gt;@INC&lt;/code&gt; and if that fails, we will try to find &lt;code&gt;file&lt;/code&gt; in @INC. If both fail, we die with the respective error messages.</source>
          <target state="translated">如果参数仅匹配 &lt;code&gt;\w&lt;/code&gt; ，则可以是模块或文件。我们将尝试首先在 &lt;code&gt;@INC&lt;/code&gt; 中找到 &lt;code&gt;file.pm&lt;/code&gt; ，如果失败，我们将尝试在@INC中找到 &lt;code&gt;file&lt;/code&gt; 。如果两者均失败，我们将因相应的错误消息而死亡。</target>
        </trans-unit>
        <trans-unit id="950fc5f071c3850318ce53caaa9abf5b8d7e4b09" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the</source>
          <target state="translated">如果参数操作与原型不一致,比如说参数数量不可接受,那么无论如何都会返回一个有效的操作树。该错误反映在解析器状态中,通常会在解析的最高层产生一个异常,它涵盖了所有发生的编译错误。在错误信息中,callee被引用的名称是由</target>
        </trans-unit>
        <trans-unit id="83ab7b8277b9fed6236e40a3daaed85d393da0e1" translate="yes" xml:space="preserve">
          <source>If the argument ops disagree with the prototype, for example by having an unacceptable number of arguments, a valid op tree is returned anyway. The error is reflected in the parser state, normally resulting in a single exception at the top level of parsing which covers all the compilation errors that occurred. In the error message, the callee is referred to by the name defined by the &lt;code&gt;namegv&lt;/code&gt; parameter.</source>
          <target state="translated">如果参数ops与原型不符（例如，参数数量不可接受），则无论如何都会返回有效的op树。该错误反映在解析器状态中，通常会在解析的最高级别导致单个异常，该异常涵盖发生的所有编译错误。在错误消息中，被调用者由 &lt;code&gt;namegv&lt;/code&gt; 参数定义的名称引用。</target>
        </trans-unit>
        <trans-unit id="0d4e5120bb33dd7cd87d33b762323635453284d3" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charblock()&lt;/code&gt; 的参数不是已知的块，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cddc796120fb296cf9c181c113316137b8a64880" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;code&gt;charblock()&lt;/code&gt; is not a known block, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;charblock()&lt;/code&gt; 的参数不是已知的块，则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7830cf54412f961c402c681fff76496d227d2f2" translate="yes" xml:space="preserve">
          <source>If the attribute name is unqualified, the attribute is installed in the current package. Otherwise it is installed in the qualifier's package:</source>
          <target state="translated">如果属性名是非限定的,则该属性被安装在当前的包中。否则,它将被安装在限定者的包中。</target>
        </trans-unit>
        <trans-unit id="c1735572aa151643b864cff0b5bfb1e1bb6554fd" translate="yes" xml:space="preserve">
          <source>If the author's vision of the future of their module is sufficiently different from the vision of the pumpkin holder and perl5-porters as a whole so as to cause serious problems for Perl, the pumpkin holder may choose to formally fork the version of the module in the Perl core from the one maintained by the author. This should not be done lightly and should &lt;b&gt;always&lt;/b&gt; if at all possible be done only after direct input from Larry. If this is done, it must then be made explicit in the module as distributed with the Perl core that it is a forked version and that while it is based on the original author's work, it is no longer maintained by them. This must be noted in both the documentation and in the comments in the source of the module.</source>
          <target state="translated">如果作者对模块未来的看法与整个南瓜支架和perl5-porters的看法有很大不同，从而给Perl带来了严重的问题，那么南瓜支架可以选择正式将模块的版本分叉到作者维护的Perl核心。这不应该随便做，应&lt;b&gt;始终&lt;/b&gt;如果可能的话后，才从拉里直接输入来完成。如果这样做，则必须在与Perl核心一起分发的模块中将其明确表示为分叉版本，并且它基于原始作者的作品，但不再由他们维护。必须在文档中以及模块源代码中的注释中对此进行说明。</target>
        </trans-unit>
        <trans-unit id="955f45edead883f952974a52b2340b4943a3c2b2" translate="yes" xml:space="preserve">
          <source>If the av argument is a tied array then will call the &lt;code&gt;EXTEND&lt;/code&gt; tied array method with an argument of &lt;code&gt;(key+1)&lt;/code&gt;.</source>
          <target state="translated">如果av参数是绑定数组，则将使用 &lt;code&gt;(key+1)&lt;/code&gt; 参数调用 &lt;code&gt;EXTEND&lt;/code&gt; 绑定数组方法。</target>
        </trans-unit>
        <trans-unit id="1ff96c964c43432c71bf023f75aff4edc100165c" translate="yes" xml:space="preserve">
          <source>If the backslash is followed by a single digit, it's a backreference.</source>
          <target state="translated">如果反斜杠后面是一个数字,那就是一个反向参考。</target>
        </trans-unit>
        <trans-unit id="a1567cb832ddb83a0b923a12411e03c46deba90f" translate="yes" xml:space="preserve">
          <source>If the beginning of some prebuilt path matches</source>
          <target state="translated">如果某个预建路径的开头符合</target>
        </trans-unit>
        <trans-unit id="e7f4bb43b4cedf6c41cad2b5a8c09df968a788f0" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;&quot;pairmap&quot;&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">如果提供给&lt;a href=&quot;#pairmap&quot;&gt;&amp;ldquo; pairmap&amp;rdquo;&lt;/a&gt;的代码块包含由返回的闭包捕获的词法变量，并且在将该块重新用于下一次迭代后执行该闭包，则这些词法将看不到正确的值。例如：</target>
        </trans-unit>
        <trans-unit id="10167b28b5bd2cad97967630ae689888c6716c8a" translate="yes" xml:space="preserve">
          <source>If the block of code given to &lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt; contains lexical variables that are captured by a returned closure, and the closure is executed after the block has been re-used for the next iteration, these lexicals will not see the correct values. For example:</source>
          <target state="translated">如果提供给&lt;a href=&quot;#pairmap&quot;&gt;pairmap&lt;/a&gt;的代码块包含由返回的闭包捕获的词法变量，并且在将该块重新用于下一次迭代后执行该闭包，则这些词法将看不到正确的值。例如：</target>
        </trans-unit>
        <trans-unit id="4767b1747b48c85b5657695ae3a62c62eedbd7cb" translate="yes" xml:space="preserve">
          <source>If the bunzip2 program encounters a file containing multiple bzip2 files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="translated">如果bunzip2程序遇到一个包含多个bzip2文件的文件,它会自动将它们全部解压。下面的例子说明了这种行为</target>
        </trans-unit>
        <trans-unit id="440a5d8f345e7d80a2856dd0eeb83f250fbc92a1" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt; +&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt; .</source>
          <target state="translated">如果字节长度 &lt;code&gt;l1&lt;/code&gt; 不为零，则表示要检查 &lt;code&gt;s1&lt;/code&gt; 是否等于倍数。换句话说， &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 将用作达成目标。除非达到目标，否则扫描不会被视为匹配，并且扫描不会继续超过该目标。相对于 &lt;code&gt;s2&lt;/code&gt; 为 &lt;code&gt;l2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2fca1e4d1004f5ffcdaa83a7b896a3cca0e13fe" translate="yes" xml:space="preserve">
          <source>If the byte length &lt;code&gt;l1&lt;/code&gt; is non-zero, it says how far into &lt;code&gt;s1&lt;/code&gt; to check for fold equality. In other words, &lt;code&gt;s1&lt;/code&gt;+&lt;code&gt;l1&lt;/code&gt; will be used as a goal to reach. The scan will not be considered to be a match unless the goal is reached, and scanning won't continue past that goal. Correspondingly for &lt;code&gt;l2&lt;/code&gt; with respect to &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">如果字节长度 &lt;code&gt;l1&lt;/code&gt; 不为零，则表示要检查 &lt;code&gt;s1&lt;/code&gt; 是否等于倍数。换句话说， &lt;code&gt;s1&lt;/code&gt; + &lt;code&gt;l1&lt;/code&gt; 将用作达成目标。除非达到目标，否则扫描不会被视为匹配，并且扫描不会继续超过该目标。相对于 &lt;code&gt;s2&lt;/code&gt; 对应于 &lt;code&gt;l2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b7b55adcf46426f8905247d52b7cd465b36f52b" translate="yes" xml:space="preserve">
          <source>If the c89 compiler complains of syntax errors during the build of the Socket extension then be sure to fix the syntax error in the system header /usr/include/sys/socket.h.</source>
          <target state="translated">如果c89编译器在构建Socket扩展时抱怨语法错误,那么一定要修复系统头/usr/include/sys/socket.h中的语法错误。</target>
        </trans-unit>
        <trans-unit id="440bf862cd2a86e099efb047265c5fac0693c286" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; (</source>
          <target state="translated">如果调用是一个左值子例程，并且 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; 被定义为 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="679d082044403152b577fab1a0ed8a9174ec8af7" translate="yes" xml:space="preserve">
          <source>If the call is to an lvalue subroutine, and &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; is defined &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt;(</source>
          <target state="translated">如果调用是一个左值子例程，并且 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; 被定义为 &lt;code&gt;&amp;amp;DB::lsub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="3e23c7323ae1871ee025af31121766b37b8d3a26" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;load&lt;/code&gt; is from &lt;code&gt;YourPackage&lt;/code&gt; , then that can be further simplified to</source>
          <target state="translated">如果 &lt;code&gt;load&lt;/code&gt; 调用来自 &lt;code&gt;YourPackage&lt;/code&gt; ，则可以进一步简化为</target>
        </trans-unit>
        <trans-unit id="5682bd082d01ef4bbac6126150d3b6f81612d0af" translate="yes" xml:space="preserve">
          <source>If the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it's listed below. A few letters have not been used yet, so escaping them with a backslash doesn't change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].</source>
          <target state="translated">如果反斜线后面的字符是ASCII字母或ASCII数字,那么这个序列可能是特殊的;如果是,就在下面列出。有几个字母还没有被使用,所以用反斜线转义并不能改变它们的特殊性。未来的Perl版本可能会给它们赋予特殊的含义,所以如果你开启了警告,如果你使用这样的序列,Perl会发出警告。[1].</target>
        </trans-unit>
        <trans-unit id="da17f25e114b45ba4ef865a9786c813cdbdd1421" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果角色是可正则分解的（包括韩文音节），它将以字符串形式返回（完整）正则分解。否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49a5873bb2356b7ed86679de87b264a15f6d0e92" translate="yes" xml:space="preserve">
          <source>If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果角色是可正则分解的（包括韩文音节），它将以字符串形式返回（完整）正则分解。否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a39c4975b03ffeafb0215bb69dbcb4fdb18e47" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果字符是可分解兼容性的（包括韩文音节），则它将（完整）兼容性分解作为字符串返回。否则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5de2fa7cb97ef2dd5b4c83623de57ebc81f1d7c6" translate="yes" xml:space="preserve">
          <source>If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果该字符是可分解兼容性的（包括韩文音节），则它将（完整）兼容性分解作为字符串返回。否则返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e1499119842240cb994c8553e174c966c0608a" translate="yes" xml:space="preserve">
          <source>If the characters delimiting</source>
          <target state="translated">如果划线的字符</target>
        </trans-unit>
        <trans-unit id="65221cae28ebb56c2b7e384de16ed70d718d62d1" translate="yes" xml:space="preserve">
          <source>If the child falls out of scope before &lt;code&gt;finalize&lt;/code&gt; is called, a failure diagnostic will be issued and the child is considered to have failed.</source>
          <target state="translated">如果子项在调用 &lt;code&gt;finalize&lt;/code&gt; 之前超出范围，则将发出故障诊断，并认为该子项已失败。</target>
        </trans-unit>
        <trans-unit id="ac2316f205b2709d84d9e07b732224a9e1bdef17" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to $chld_in is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">如果子进程由于任何原因死亡,下一次向$chld_in的写入很可能会在父进程中产生一个SIGPIPE信号,默认情况下这是致命的。所以你可能希望处理这个信号。</target>
        </trans-unit>
        <trans-unit id="ddc80dbef3fa7a98447bcda86b6b6a922737dbbf" translate="yes" xml:space="preserve">
          <source>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</source>
          <target state="translated">如果子进程由于任何原因死亡,下一次向CHLD_IN的写入很可能会在父进程中产生一个SIGPIPE,默认情况下这是致命的。所以你可能希望处理这个信号。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
