<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d47de889df56d979834e9722ebde0c0a6a0fae68" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;split&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc52a9bce5d37da72e4313c9442e3059934389e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; operation, which &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="translated">甲&lt;b&gt;字符&lt;/b&gt;或&lt;b&gt;字符串&lt;/b&gt;的是马克另一个字符串的结尾。的 &lt;code&gt;$/&lt;/code&gt; 变量包含终止字符串 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 操作，这 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 从末端删除。不要与&lt;b&gt;分隔符&lt;/b&gt;或&lt;b&gt;分隔&lt;/b&gt;&lt;b&gt;符&lt;/b&gt;混淆。该句末的句号是终止符。</target>
        </trans-unit>
        <trans-unit id="d839106acdc670985a28069f0c98ef61f88fbf3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that marks the end of another string. The &lt;code&gt;$/&lt;/code&gt; variable contains the string that terminates a &lt;code&gt;readline&lt;/code&gt; operation, which &lt;code&gt;chomp&lt;/code&gt; deletes from the end. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;separators&lt;/b&gt;. The period at the end of this sentence is a terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ccb7e4dc3cd3bdbacbf8b76f79619db792d436" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that sets bounds to an arbitrarily sized textual object, not to be confused with a &lt;b&gt;separator&lt;/b&gt; or &lt;b&gt;terminator&lt;/b&gt;. &amp;ldquo;To delimit&amp;rdquo; really just means &amp;ldquo;to surround&amp;rdquo; or &amp;ldquo;to enclose&amp;rdquo; (like these parentheses are doing).</source>
          <target state="translated">设置边界到任意大小的文本对象的&lt;b&gt;字符&lt;/b&gt;或&lt;b&gt;字符串&lt;/b&gt;，不要与&lt;b&gt;分隔符&lt;/b&gt;或&lt;b&gt;终止&lt;/b&gt;&lt;b&gt;符&lt;/b&gt;混淆。&amp;ldquo;定界&amp;rdquo;实际上只是意味着&amp;ldquo;包围&amp;rdquo;或&amp;ldquo;包围&amp;rdquo;（就像这些括号一样）。</target>
        </trans-unit>
        <trans-unit id="ea08291e93224eb22a8479c3ec9c014b05bce7f2" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that is</source>
          <target state="translated">一个&lt;b&gt;字符&lt;/b&gt;是</target>
        </trans-unit>
        <trans-unit id="5cba1f2a968bf42f9b6478a5e49fa1b60b1a7141" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; that moves your cursor but doesn&amp;rsquo;t otherwise put anything on your screen. Typically refers to any of: space, tab, line feed, carriage return, or form feed. In Unicode, matches many other characters that Unicode considers whitespace, including the ɴ-ʙʀ .</source>
          <target state="translated">一个可以移动光标但不会在屏幕上放置任何内容的&lt;b&gt;字符&lt;/b&gt;。通常指以下任何一种：空格，制表符，换行符，回车符或换页符。在Unicode中，匹配Unicode认为空格的许多其他字符，包括ɴ-ʙʀ。</target>
        </trans-unit>
        <trans-unit id="2aa2a649bec9b1fd1ac1866bab10ba2afe8f796b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; defines the behavior of a category of objects. A class is a name for a category (like &quot;File&quot;), and a class also defines the behavior of objects in that category.</source>
          <target state="translated">一个&lt;b&gt;类&lt;/b&gt;定义对象的类别的行为。类是类别（如&amp;ldquo;文件&amp;rdquo;）的名称，并且类别还定义该类别中对象的行为。</target>
        </trans-unit>
        <trans-unit id="1a75079cb5fa51afe9c7f949ddf0f69d6f477b63" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;class&lt;/b&gt; that defines some of its &lt;b&gt;methods&lt;/b&gt; in terms of a more generic class, called a &lt;b&gt;base class&lt;/b&gt;. Note that classes aren&amp;rsquo;t classified exclusively into base classes or derived classes: a class can function as both a derived class and a base class simultaneously, which is kind of classy.</source>
          <target state="translated">一个&lt;b&gt;类&lt;/b&gt;定义了它的一些&lt;b&gt;方法&lt;/b&gt;更泛型类的术语，叫做&lt;b&gt;基类&lt;/b&gt;。请注意，类并非仅分类为基类或派生类：类可以同时充当派生类和基类，这是一种类。</target>
        </trans-unit>
        <trans-unit id="99d0667db3792046333bf54560031cc7b2ecf43e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt; to the computer about what to do next, like a step in a recipe: &amp;ldquo;Add marmalade to batter and mix until mixed.&amp;rdquo; A statement is distinguished from a &lt;b&gt;declaration&lt;/b&gt;, which doesn&amp;rsquo;t tell the computer to do anything, but just to learn something.</source>
          <target state="translated">一个&lt;b&gt;命令&lt;/b&gt;约下一步该怎么做，例如食谱中的一个步骤的计算机：&amp;ldquo;添加果酱面糊拌匀，直到混合。&amp;rdquo; 声明和声明是有区别的，&lt;b&gt;声明&lt;/b&gt;不告诉计算机要做任何事情，而只是学习一些东西。</target>
        </trans-unit>
        <trans-unit id="0c8b51997be5611d837a8ab6c5cb1982a471c7f6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;command&lt;/b&gt;-line &lt;b&gt;interpreter&lt;/b&gt;. The program that interactively gives you a prompt, accepts one or more &lt;b&gt;lines&lt;/b&gt; of input, and executes the programs you mentioned, feeding each of them their proper &lt;b&gt;arguments&lt;/b&gt; and input data. Shells can also execute scripts containing such commands. Under Unix, typical shells include the Bourne shell (</source>
          <target state="translated">甲&lt;b&gt;命令&lt;/b&gt; -line &lt;b&gt;解释&lt;/b&gt;。该程序以交互方式为您提供提示，接受一行或多&lt;b&gt;行&lt;/b&gt;输入，并执行您提到的程序，并为它们中的每一个提供适当的&lt;b&gt;参数&lt;/b&gt;和输入数据。Shell也可以执行包含此类命令的脚本。在Unix下，典型的shell包括Bourne shell（</target>
        </trans-unit>
        <trans-unit id="52e02137a3f5dfcbaf26aaed0daa92b24d1f6a82" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;conditional&lt;/b&gt; or &lt;b&gt;loop&lt;/b&gt; that you put after the &lt;b&gt;statement&lt;/b&gt; instead of before, if you know what we mean.</source>
          <target state="translated">一个&lt;b&gt;条件&lt;/b&gt;或&lt;b&gt;循环&lt;/b&gt;，你的后摆&lt;b&gt;声明&lt;/b&gt;，而不是之前，如果你知道我们的意思。</target>
        </trans-unit>
        <trans-unit id="8b7c0791290fe9b8909bf7acee3f40cc62fd3b4d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;constructor&lt;/b&gt; creates a new object. In Perl, a class's constructor is just another method, unlike some other languages, which provide syntax for constructors. Most Perl classes use &lt;code&gt;new&lt;/code&gt; as the name for their constructor:</source>
          <target state="translated">一个&lt;b&gt;构造函数&lt;/b&gt;创建一个新对象。在Perl中，类的构造函数只是另一种方法，与其他一些为构造函数提供语法的语言不同。大多数Perl类使用 &lt;code&gt;new&lt;/code&gt; 作为其构造函数的名称：</target>
        </trans-unit>
        <trans-unit id="7959cb1d43e022aebe37e1efd0d8727ca1bc0118" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;cracker&lt;/b&gt; who is not a &lt;b&gt;hacker&lt;/b&gt; but knows just enough to run canned scripts. A &lt;b&gt;cargo-cult&lt;/b&gt; programmer.</source>
          <target state="translated">一个&lt;b&gt;黑客&lt;/b&gt;谁不是&lt;b&gt;黑客&lt;/b&gt;，但知道刚够运行罐头脚本。一个&lt;b&gt;狂热的&lt;/b&gt;程序员。</target>
        </trans-unit>
        <trans-unit id="eb0c56375aec608f2fe483b5d49fe200437f6d13" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;data paragraph&lt;/b&gt;. This is a paragraph that</source>
          <target state="translated">一个&lt;b&gt;数据段&lt;/b&gt;。这是一段</target>
        </trans-unit>
        <trans-unit id="f4407d7bf8b4e86a5ab3d8b6cfe6f792d1bff9b9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that defines a &lt;b&gt;package&lt;/b&gt; of (almost) the same name, which can either &lt;b&gt;export&lt;/b&gt; symbols or function as an &lt;b&gt;object&lt;/b&gt; class. (A module&amp;rsquo;s main</source>
          <target state="translated">甲&lt;b&gt;文件&lt;/b&gt;定义了&lt;b&gt;包&lt;/b&gt;（几乎）相同的名称，其中的既可以&lt;b&gt;导出&lt;/b&gt;符号或功能作为一个&lt;b&gt;对象&lt;/b&gt;类。（一个模块的主要</target>
        </trans-unit>
        <trans-unit id="560dff37fc95faf8528a7887fa6dc08d1b06155b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that is specially marked to tell the &lt;b&gt;operating system&lt;/b&gt; that it&amp;rsquo;s okay to run this file as a program. Usually shortened to &amp;ldquo;executable&amp;rdquo;.</source>
          <target state="translated">一个&lt;b&gt;文件&lt;/b&gt;被特殊标记来告诉&lt;b&gt;操作系统&lt;/b&gt;，它的好来运行这个文件的程序。通常缩写为&amp;ldquo;可执行&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="832195e4157a51d08607c1f931cf313eaae32121" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;file&lt;/b&gt; that&amp;rsquo;s not a &lt;b&gt;directory&lt;/b&gt;, a &lt;b&gt;device&lt;/b&gt;, a named &lt;b&gt;pipe&lt;/b&gt; or &lt;b&gt;socket&lt;/b&gt;, or a &lt;b&gt;symbolic link&lt;/b&gt;. Perl uses the &lt;code&gt;&amp;ndash;f&lt;/code&gt; file test operator to identify regular files. Sometimes called a &amp;ldquo;plain&amp;rdquo; file.</source>
          <target state="translated">一个&lt;b&gt;文件&lt;/b&gt;，这不是一个&lt;b&gt;目录&lt;/b&gt;，一个&lt;b&gt;设备&lt;/b&gt;，一个命名&lt;b&gt;管道&lt;/b&gt;或&lt;b&gt;插座&lt;/b&gt;，或&lt;b&gt;符号链接&lt;/b&gt;。Perl使用 &lt;code&gt;&amp;ndash;f&lt;/code&gt; 文件测试操作符来识别常规文件。有时称为&amp;ldquo;普通&amp;rdquo;文件。</target>
        </trans-unit>
        <trans-unit id="ed2a6a7fae032e7b7f63170d07ec12a9d190796a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">一个&lt;b&gt;函数&lt;/b&gt;直接调用&lt;b&gt;操作系统&lt;/b&gt;。您使用的许多重要子例程和函数不是直接的系统调用，而是建立在系统调用级别之上的一层或多层中。通常，Perl程序员无需担心这种区别。但是，如果您确实知道哪些Perl函数确实是系统调用，则可以预测其中的哪一个会设置 &lt;code&gt;$!&lt;/code&gt; （ &lt;code&gt;$ERRNO&lt;/code&gt; ）变量失败。不幸的是，初学者经常混淆使用&amp;ldquo;系统调用&amp;rdquo;一词来表示当您调用Perl &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 时发生的情况函数，实际上涉及许多系统调用。为了避免混淆，我们几乎总是说的东西&amp;ldquo;系统调用&amp;rdquo;，你可以通过Perl的间接调用 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 的功能，永不的东西，你会用Perl的调用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="dcd5ec0f720736e7e329b0a32b061d1c915a3b97" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; call directly to the &lt;b&gt;operating system&lt;/b&gt;. Many of the important subroutines and functions you use aren&amp;rsquo;t direct system calls, but are built up in one or more layers above the system call level. In general, Perl programmers don&amp;rsquo;t need to worry about the distinction. However, if you do happen to know which Perl functions are really syscalls, you can predict which of these will set the &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) variable on failure. Unfortunately, beginning programmers often confusingly employ the term &amp;ldquo;system call&amp;rdquo; to mean what happens when you call the Perl &lt;code&gt;system&lt;/code&gt; function, which actually involves many syscalls. To avoid any confusion, we nearly always say &amp;ldquo;syscall&amp;rdquo; for something you could call indirectly via Perl&amp;rsquo;s &lt;code&gt;syscall&lt;/code&gt; function, and never for something you would call with Perl&amp;rsquo;s &lt;code&gt;system&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9dedded5626e20b474bf02bc245fb0066d03ede" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;function&lt;/b&gt; that is predefined in the language. Even when hidden by &lt;b&gt;overriding&lt;/b&gt;, you can always get at a built- in function by &lt;b&gt;qualifying&lt;/b&gt; its name with the &lt;code&gt;CORE::&lt;/code&gt; pseudopackage.</source>
          <target state="translated">用该语言预定义的&lt;b&gt;功能&lt;/b&gt;。即使被&lt;b&gt;覆盖&lt;/b&gt;隐藏，也可以通过使用 &lt;code&gt;CORE::&lt;/code&gt; 伪包&lt;b&gt;限定&lt;/b&gt;其名称来始终获得内置函数。</target>
        </trans-unit>
        <trans-unit id="017327ec6f67ab86c897b578939f74863c44350b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;grapheme&lt;/b&gt; consisting of either a carriage return followed by a line feed or any character with the Unicode Vertical Space &lt;b&gt;character property&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;字形，&lt;/b&gt;由回车，换行符或具有Unicode Vertical Space &lt;b&gt;字符属性的&lt;/b&gt;任何字符组成。</target>
        </trans-unit>
        <trans-unit id="8ef4c16c3e84bcc76d6d7f8f70086c0645d39a22" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;handler&lt;/b&gt; that you register with some other part of your program in the hope that the other part of your program will &lt;b&gt;trigger&lt;/b&gt; your handler when some event of interest transpires.</source>
          <target state="translated">您向程序的其他部分注册的&lt;b&gt;处理&lt;/b&gt;程序，希望当出现某些感兴趣的事件时，程序的另一部分将&lt;b&gt;触发&lt;/b&gt;您的处理程序。</target>
        </trans-unit>
        <trans-unit id="9a3af3525966bde47d8478ba5aa28630e345cb9d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; .</source>
          <target state="translated">一个&lt;b&gt;词法变量&lt;/b&gt;即声明了一个词汇&amp;gt; &lt;b&gt;类&lt;/b&gt;型： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Pony $bill&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0039cc9cd8e39570b8877a1785674415311675e9" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;lexical variable&lt;/b&gt; lexical&amp;gt;that is declared with a &lt;b&gt;class&lt;/b&gt; type: &lt;code&gt;my Pony $bill&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3163207648959163d9c84cb3f038389746ed27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;line&lt;/b&gt; in a file consists of zero or more non-newline characters, terminated by either a newline or the end of the file.</source>
          <target state="translated">文件中的&lt;b&gt;一行&lt;/b&gt;由零个或多个非换行符组成，以换行符或文件末尾结尾。</target>
        </trans-unit>
        <trans-unit id="e216248dbe62e4deb5d290410cf6cba07540c708" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">甲&lt;b&gt;列表值&lt;/b&gt;为零的元素，通过在Perl表示 &lt;code&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ab4abc50479b714a6d10020d55e78dc7b1940fd" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;list value&lt;/b&gt; with zero elements, represented in Perl by &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45d256991d914c75f7b2e344bf10f0577b5147db" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;, as opposed to a &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">甲&lt;b&gt;方法&lt;/b&gt;一个的&lt;b&gt;对象&lt;/b&gt;，相对于一个&lt;b&gt;类的方法&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cd9f719db48a7ef2cd4cdce77f9516eff0561abe" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; used to indirectly inspect or update an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state (its &lt;b&gt;instance variables&lt;/b&gt;).</source>
          <target state="translated">甲&lt;b&gt;方法&lt;/b&gt;用于间接检查或更新&lt;b&gt;对象&lt;/b&gt;的状态（它的&lt;b&gt;实例变量&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="3f76f67b831d3545d647111a95485f14adb897eb" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is a &lt;b&gt;package&lt;/b&gt; name, not an &lt;b&gt;object&lt;/b&gt; reference. A method associated with the class as a whole. Also see &lt;b&gt;instance method&lt;/b&gt;.</source>
          <target state="translated">一种&lt;b&gt;方法，&lt;/b&gt;其&lt;b&gt;调用方&lt;/b&gt;是&lt;b&gt;程序包&lt;/b&gt;名称，而不是&lt;b&gt;对象&lt;/b&gt;引用。与整个类关联的方法。另请参见&lt;b&gt;实例方法&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="67eb1a20651dea215f187f74f8fc385e50d58eac" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;method&lt;/b&gt; whose &lt;b&gt;invocant&lt;/b&gt; is an &lt;b&gt;object&lt;/b&gt;, not a &lt;b&gt;package&lt;/b&gt; name. Every object of a class shares all the methods of that class, so an instance method applies to all instances of the class, rather than applying to a particular instance. Also see &lt;b&gt;class method&lt;/b&gt;.</source>
          <target state="translated">甲&lt;b&gt;方法&lt;/b&gt;，其&lt;b&gt;调用者&lt;/b&gt;为&lt;b&gt;对象&lt;/b&gt;，而不是一个&lt;b&gt;包&lt;/b&gt;的名称。类的每个对象都共享该类的所有方法，因此实例方法适用于该类的所有实例，而不是适用于特定实例。另请参见&lt;b&gt;类方法&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9a608f9301d7c9b44868aa9a54155b51fc141a42" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;mortal&lt;/b&gt; SV.</source>
          <target state="translated">一个&lt;b&gt;凡人&lt;/b&gt; SV。</target>
        </trans-unit>
        <trans-unit id="53f7bde55489a9151bd15ee3f737a362e089a682" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;namespace&lt;/b&gt; for global &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;subroutines&lt;/b&gt;, and the like, such that they can be kept separate from like-named &lt;b&gt;symbols&lt;/b&gt; in other namespaces. In a sense, only the package is global, since the symbols in the package&amp;rsquo;s symbol table are only accessible from code &lt;b&gt;compiled&lt;/b&gt; outside the package by naming the package. But in another sense, all package symbols are also globals&amp;mdash;they&amp;rsquo;re just well-organized globals.</source>
          <target state="translated">一个&lt;b&gt;命名空间&lt;/b&gt;为全局&lt;b&gt;变量&lt;/b&gt;，&lt;b&gt;子程序&lt;/b&gt;，等等，使得它们可以分开存放名称相似的&lt;b&gt;符号&lt;/b&gt;在其他命名空间。从某种意义上说，只有程序包是全局的，因为只能通过命名程序包才能从程序包外部&lt;b&gt;编译&lt;/b&gt;的代码访问程序包的符号表中的符号。但是从另一种意义上说，所有包装符号也是全局变量，它们只是组织良好的全局变量。</target>
        </trans-unit>
        <trans-unit id="28abc12d5fd2eda36e36f614d582aeb865b478e3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;newline sequence&lt;/b&gt; is usually a platform-dependent concept, but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to any other system-specific meaning. The first CR/CRLF/LF sequence in the file may be used as the basis for identifying the newline sequence for parsing the rest of the file.</source>
          <target state="translated">甲&lt;b&gt;行序列&lt;/b&gt;通常是依赖于平台的概念，但波德解析器应该理解为是指任何CR（ASCII 13），LF（ASCII 10），或一个CRLF的（ASCII 13立即通过ASCII 10随后），除了任何其他系统特定的含义。文件中的第一个CR / CRLF / LF序列可以用作标识换行序列的基础，以解析文件的其余部分。</target>
        </trans-unit>
        <trans-unit id="28a5d8434506c4b65f1bc6f82e7222a2e44f2923" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pipe&lt;/b&gt; with a name embedded in the &lt;b&gt;filesystem&lt;/b&gt; so that it can be accessed by two unrelated &lt;b&gt;processes&lt;/b&gt;.</source>
          <target state="translated">在&lt;b&gt;文件系统中&lt;/b&gt;嵌入名称的&lt;b&gt;管道&lt;/b&gt;，以便两个不相关的&lt;b&gt;进程&lt;/b&gt;可以访问它。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b07ce80ba704512a4daf926d6423f21ae6d581f7" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pod&lt;/b&gt; directive. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">一个&lt;b&gt;pod&lt;/b&gt;指令。请参见骆驼第23章，&amp;ldquo;普通旧文档&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a7bb769998e6fdfcf3ee0c66d7f29c1ed39a8790" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;pumpkin&lt;/b&gt; holder, the person in charge of pumping the pump, or at least priming it. Must be willing to play the part of the Great Pumpkin now and then.</source>
          <target state="translated">一个&lt;b&gt;南瓜&lt;/b&gt;持有人，该负责人抽泵，或至少吸它的。必须不时地愿意扮演大南瓜的角色。</target>
        </trans-unit>
        <trans-unit id="e6f9796d5e8ba560b9616a39b17ea2e32ae9ff4b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; component potentially matching a &lt;b&gt;substring&lt;/b&gt; containing one or more characters and treated as an indivisible syntactic unit by any following &lt;b&gt;quantifier&lt;/b&gt;. (Contrast with an &lt;b&gt;assertion&lt;/b&gt; that matches something of &lt;b&gt;zero width&lt;/b&gt; and may not be quantified.)</source>
          <target state="translated">甲&lt;b&gt;正则表达式&lt;/b&gt;成分潜在匹配一个&lt;b&gt;子串&lt;/b&gt;包含一个或多个字符，并且作为一个不可分割的句法单元通过任何以下处理&lt;b&gt;量词&lt;/b&gt;。（与一个&lt;b&gt;断言&lt;/b&gt;匹配，该&lt;b&gt;断言&lt;/b&gt;匹配&lt;b&gt;零宽度的&lt;/b&gt;东西，可能无法量化。）</target>
        </trans-unit>
        <trans-unit id="a4efc9f0f784617b2ff5677e0ce1302bbda5d4d6" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;regular expression&lt;/b&gt; subpattern whose real purpose is to execute some Perl code&amp;mdash;for example, the &lt;code&gt;(?{...})&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; subpatterns.</source>
          <target state="translated">甲&lt;b&gt;正则表达式&lt;/b&gt;的子模式，其真正目的是为了执行一些Perl代码，例如，所述 &lt;code&gt;(?{...})&lt;/code&gt; 和 &lt;code&gt;(??{...})&lt;/code&gt; 的子模式。</target>
        </trans-unit>
        <trans-unit id="b7ffd563f4456054759e7694e65ebb89f76facae" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;scalar&lt;/b&gt;&lt;b&gt;value&lt;/b&gt; containing the actual address of a &lt;b&gt;referent&lt;/b&gt;, such that the referent&amp;rsquo;s &lt;b&gt;reference&lt;/b&gt; count accounts for it. (Some hard references are held internally, such as the implicit reference from one of a &lt;b&gt;typeglob&lt;/b&gt;&amp;rsquo;s variable slots to its corresponding referent.) A hard reference is different from a &lt;b&gt;symbolic reference&lt;/b&gt;.</source>
          <target state="translated">甲&lt;b&gt;标&lt;/b&gt;&lt;b&gt;值&lt;/b&gt;包含的实际地址&lt;b&gt;所指&lt;/b&gt;，使得所指的&lt;b&gt;参考&lt;/b&gt;计数占它。（某些内部硬引用是内部保留的，例如从&lt;b&gt;typeglob&lt;/b&gt;的可变插槽之一到其对应引用的隐式引用。）硬引用不同于&lt;b&gt;符号引用&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="5022eeaf3b922dfb2c6df5364e9c4781dc19e0ff" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;stash&lt;/b&gt; is a hash that contains all variables that are defined within a package. Each key of the stash is a symbol name (shared by all the different types of objects that have the same name), and each value in the hash table is a GV (Glob Value). This GV in turn contains references to the various objects of that name, including (but not limited to) the following:</source>
          <target state="translated">一个&lt;b&gt;藏匿处&lt;/b&gt;是包含在一个包中定义的所有变量的哈希值。存储区的每个键都是符号名称（由具有相同名称的所有不同类型的对象共享），哈希表中的每个值都是GV（全局值）。该GV依次包含对该名称各个对象的引用，包括（但不限于）以下内容：</target>
        </trans-unit>
        <trans-unit id="92b538532d72576aaeda7a7cef805a1cba7aaa2a" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; containing no characters, not to be confused with a string containing a &lt;b&gt;null character&lt;/b&gt;, which has a positive length and is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">一个不包含任何字符的&lt;b&gt;字符串&lt;/b&gt;，请勿与包含一个正长度且为&lt;b&gt;true&lt;/b&gt;的&lt;b&gt;空字符&lt;/b&gt;的字符串混淆。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f0d02500198bfb1874e50da33c4e532a6d834d3e" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;string&lt;/b&gt; or &lt;b&gt;file&lt;/b&gt; containing primarily printable characters.</source>
          <target state="translated">一个主要包含可打印字符的&lt;b&gt;字符串&lt;/b&gt;或&lt;b&gt;文件&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="963346bf337afa73872e46c5b7ebdcda13950ed0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subpattern&lt;/b&gt; whose &lt;b&gt;quantifier&lt;/b&gt; wants to match as many things as possible.</source>
          <target state="translated">一种&lt;b&gt;子模式，&lt;/b&gt;其&lt;b&gt;量词&lt;/b&gt;希望匹配尽可能多的内容。</target>
        </trans-unit>
        <trans-unit id="b40a047ee9609abd7c464a0e25538925a09e0994" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;method&lt;/b&gt; that Perl calls when your program needs to respond to some internal event, such as a &lt;b&gt;signal&lt;/b&gt;, or an encounter with an operator subject to &lt;b&gt;operator overloading&lt;/b&gt;. See also &lt;b&gt;callback&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;子程序&lt;/b&gt;或&lt;b&gt;方法&lt;/b&gt;是Perl调用当程序需要以应对一些内部事件，如&lt;b&gt;信号&lt;/b&gt;，或与运营商受到的遭遇&lt;b&gt;运算符重载&lt;/b&gt;。另请参阅&lt;b&gt;callback&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b88557bd91c6ee2c1cde6ebbe7211914850d4976" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="translated">一个&lt;b&gt;子例程&lt;/b&gt;，而不是满足于通常的&lt;b&gt;调用&lt;/b&gt;方式，而是围着等待一个螺栓，然后&lt;b&gt;执行&lt;/b&gt;。在Perl下，突然出现的信号称为信号，您可以使用内置的 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; 命令发送信号。请参见骆驼第25章&amp;ldquo;特殊名称&amp;rdquo;中的 &lt;code&gt;%SIG&lt;/code&gt; 哈希值和骆驼第15章&amp;ldquo;进程间通信&amp;rdquo;中的&amp;ldquo;信号&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="6eb90f749c779c72ed00584c8a37ccf80a60ff84" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt; that, instead of being content to be called in the normal fashion, sits around waiting for a bolt out of the blue before it will deign to &lt;b&gt;execute&lt;/b&gt;. Under Perl, bolts out of the blue are called signals, and you send them with the &lt;code&gt;kill&lt;/code&gt; built-in. See the &lt;code&gt;%SIG&lt;/code&gt; hash in Camel chapter 25, &amp;ldquo;Special Names&amp;rdquo; and the section &amp;ldquo;Signals&amp;rdquo; in Camel chapter 15, &amp;ldquo;Interprocess Communication&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322f029b3b0fb52a6b3d088717d1bec9ab25e434" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;子程序&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="76724a25473397cad776a8c2a824ea6f3262e159" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;symbol&lt;/b&gt; such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt; that tells Perl to do the arithmetic you were supposed to learn in grade school.</source>
          <target state="translated">一个&lt;b&gt;符号&lt;/b&gt;，如 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;/&lt;/code&gt; 这告诉Perl做你应该在小学学习算术。</target>
        </trans-unit>
        <trans-unit id="d32877203298997d4e4d665fab49d7f32caf1082" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; chosen for you if you don&amp;rsquo;t supply a value of your own.</source>
          <target state="translated">一个&lt;b&gt;价值&lt;/b&gt;选择你，如果你不提供自己的值。</target>
        </trans-unit>
        <trans-unit id="87af2986b4851cce0bdd68d60a1169a1374d676b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that indicates the position of a particular &lt;b&gt;array&lt;/b&gt;&lt;b&gt;element&lt;/b&gt; in an array.</source>
          <target state="translated">一个&lt;b&gt;值&lt;/b&gt;，指示特定&lt;b&gt;数组&lt;/b&gt;&lt;b&gt;元素&lt;/b&gt;在数组中的位置。</target>
        </trans-unit>
        <trans-unit id="56587e718c7ecb23875006ffccf7c7d756c6fa62" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;value&lt;/b&gt; that you might find on the right side of an &lt;b&gt;assignment&lt;/b&gt;. See also &lt;b&gt;lvalue&lt;/b&gt;.</source>
          <target state="translated">一个&lt;b&gt;值&lt;/b&gt;，你可能会发现上右侧的&lt;b&gt;分配&lt;/b&gt;。另请参见&lt;b&gt;左值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="99b9fdd9de86d1d00f397b16abef1b9cafbc97c4" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; in a language like C that contains the exact memory location of some other item. Perl handles pointers internally so you don&amp;rsquo;t have to worry about them. Instead, you just use symbolic pointers in the form of &lt;b&gt;keys&lt;/b&gt; and &lt;b&gt;variable&lt;/b&gt; names, or &lt;b&gt;hard references&lt;/b&gt;, which aren&amp;rsquo;t pointers (but act like pointers and do in fact contain pointers).</source>
          <target state="translated">像C这样的语言中的&lt;b&gt;变量&lt;/b&gt;，它包含某些其他项的确切存储位置。Perl在内部处理指针，因此您不必担心它们。取而代之的是，您仅使用&lt;b&gt;键&lt;/b&gt;和&lt;b&gt;变量&lt;/b&gt;名形式的符号指针，或&lt;b&gt;硬引用&lt;/b&gt;（不是指针）（而是像指针一样工作，实际上包含指针）。</target>
        </trans-unit>
        <trans-unit id="51c90d619538801ef4598602775b97c77a42912f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; prefixed with &lt;code&gt;$&lt;/code&gt; that holds a single value.</source>
          <target state="translated">以 &lt;code&gt;$&lt;/code&gt; 开头的&lt;b&gt;变量&lt;/b&gt;包含单个值。</target>
        </trans-unit>
        <trans-unit id="a036ff35f0b4159168ba2281ee65e4b238ac5692" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="translated">一个&lt;b&gt;变量&lt;/b&gt;服从&lt;b&gt;词汇范围&lt;/b&gt;，宣布 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。通常被称为&amp;ldquo;词汇&amp;rdquo;。（ &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明为全局变量声明了一个词法范围的名称，它本身并不是词法变量。）</target>
        </trans-unit>
        <trans-unit id="06985481b8abaac45139622f2df52c61b1d4a275" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;variable&lt;/b&gt; subject to &lt;b&gt;lexical scoping&lt;/b&gt;, declared by &lt;code&gt;my&lt;/code&gt;. Often just called a &amp;ldquo;lexical&amp;rdquo;. (The &lt;code&gt;our&lt;/code&gt; declaration declares a lexically scoped name for a global variable, which is not itself a lexical variable.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d364f02d6990848dc623c28306b3b67cfe16a460" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;verbatim paragraph&lt;/b&gt;. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin</source>
          <target state="translated">一个&lt;b&gt;逐字段落&lt;/b&gt;。该段的第一行必须是文字空间或制表符，并且该段不得位于&amp;ldquo; = begin&amp;rdquo;之内</target>
        </trans-unit>
        <trans-unit id="42c5695455abfd814bba117ac56b83739b6fccd8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2475be186a7213d2a980a851a800269b2e5a86" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;()&lt;/code&gt; group is a sub-TEMPLATE enclosed in parentheses. A group may take a repeat count either as postfix, or for unpack(), also via the &lt;code&gt;/&lt;/code&gt; template character. Within each repetition of a group, positioning with &lt;code&gt;@&lt;/code&gt; starts over at 0. Therefore, the result of</source>
          <target state="translated">甲 &lt;code&gt;()&lt;/code&gt; 基团是子模板括号括起来。组也可以通过 &lt;code&gt;/&lt;/code&gt; 模板字符作为后缀或对于unpack（）进行重复计数。在一个组的每个重复中，用 &lt;code&gt;@&lt;/code&gt; 定位从0开始。因此，</target>
        </trans-unit>
        <trans-unit id="a287ce1841efe5bc899e4207e715388b0c45e263" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</source>
          <target state="translated">甲 &lt;code&gt;*&lt;/code&gt; 允许子程序接受裸词，常量，标量表达式，类型团，或在该时隙到一个类型团的引用。该值可以作为简单标量或（对于后两种情况）作为对typeglob的引用提供给子例程。如果希望始终将此类参数转换为typeglob引用，请按如下方式使用Symbol :: qualify_to_ref（）：</target>
        </trans-unit>
        <trans-unit id="175dabd836c19199f903fe2faf157b003fcf09ec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, nybbles are converted to a string of hexadecimal digits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61da191aeee246a70549905e1a2b4d958c2fd1c9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. For unpack(), nybbles are converted to a string of hexadecimal digits.</source>
          <target state="translated">一 &lt;code&gt;*&lt;/code&gt; 为重复计数使用输入字段的所有字符。对于unpack（），将四位字节转换为十六进制数字字符串。</target>
        </trans-unit>
        <trans-unit id="815c847c3d1b9e3c91a01ec8d23807326737a6a0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt; s and &lt;code&gt;1&lt;/code&gt; s.</source>
          <target state="translated">一 &lt;code&gt;*&lt;/code&gt; 为重复计数使用输入字段的所有字符。拆包时，位将转换为 &lt;code&gt;0&lt;/code&gt; s和 &lt;code&gt;1&lt;/code&gt; s 的字符串。</target>
        </trans-unit>
        <trans-unit id="f9e01e48d826d5a43209d5317fe5971b7609b128" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;*&lt;/code&gt; for the repeat count uses all characters of the input field. On unpacking, bits are converted to a string of &lt;code&gt;0&lt;/code&gt;s and &lt;code&gt;1&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c65ec9d77b183c5b39e5d9c73a8c71422dfc22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;--&lt;/code&gt; signals the end of options and disables further option processing. Any arguments after the &lt;code&gt;--&lt;/code&gt; are treated as filenames and arguments.</source>
          <target state="translated">甲 &lt;code&gt;--&lt;/code&gt; 信号的选项和禁止进一步的选择处理结束。 &lt;code&gt;--&lt;/code&gt; 后面的任何参数均被视为文件名和参数。</target>
        </trans-unit>
        <trans-unit id="bde6ae184752daa5e5b6a5c7417008782a0b714a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 失败可能会导致下面的测试失败的：</target>
        </trans-unit>
        <trans-unit id="290859ef4b0199eb4b067a5c07f38a6730cc7301" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized variable, the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是简单地在左值表达式的改性剂。当你分配给 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 化的变量，在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 并没有改变它的列表是否被视为一个标量或数组。所以</target>
        </trans-unit>
        <trans-unit id="1ac670f70b9818c1a06875d85552011a54fbdd94" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and to</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 修改其上市的变量是&amp;ldquo;本地&amp;rdquo;的封闭块， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; --and到</target>
        </trans-unit>
        <trans-unit id="5e64f0ec46a4ae84b19fc32e43ef29768338a5a4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明列出的变量是本地（词汇）给封闭块，文件或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 。如果列出了多个变量，则该列表必须放在括号中。</target>
        </trans-unit>
        <trans-unit id="f1479b4bde8f3dbb0c16d564288196fd25f56ff5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 既具有编译时和运行时的效果。在编译时，编译器会注意到它。这样做的主要用途是安静 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; ，但对于生成闭包也很重要，如&lt;a href=&quot;perlref&quot;&gt;perlref所述&lt;/a&gt;。但是，实际的初始化会延迟到运行时，因此它会在适当的时间执行，例如每次通过循环执行一次。</target>
        </trans-unit>
        <trans-unit id="31962f6029a8a1eb17179745d335b5ef4fc0067e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="translated">甲 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 语句可用于退出子程序，任选指定取决于子程序调用的上下文返回值，这将在适当的上下文（列表中，标量，或空隙）进行评估。如果不指定返回值，则子例程在列表上下文中返回一个空列表，在标量上下文中返回未定义的值，或者在void上下文中不返回任何值。如果返回一个或多个聚合（数组和散列），则这些聚合将被平整为一个无法区分的大列表。</target>
        </trans-unit>
        <trans-unit id="0e88bf889822c4c5cba2a75e272c3a1e9aeaadd3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明列出的变量是本地（词汇）给封闭块，文件或 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 。如果列出了多个变量，则该列表必须放在括号中。</target>
        </trans-unit>
        <trans-unit id="7218467ff9ee5b0a5da705bdf5367f50f9fd934e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that has no matching =end command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e47480cd5deac560f9564740a3fdd3588ea30d3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=begin&lt;/code&gt; command was found that is not followed by the formatter specification.</source>
          <target state="translated">甲 &lt;code&gt;=begin&lt;/code&gt; 命令被发现没有随后由格式化规范。</target>
        </trans-unit>
        <trans-unit id="5a9827f3a3a35194fce6eb84ce82e990f6ef9b53" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=cut&lt;/code&gt; command was found without a preceding POD paragraph.</source>
          <target state="translated">甲 &lt;code&gt;=cut&lt;/code&gt; 命令被发现没有前述POD段落。</target>
        </trans-unit>
        <trans-unit id="4af95277282f9dbbdb980c39fe078720a20bab01" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;=pod&lt;/code&gt; command was found after a preceding POD paragraph.</source>
          <target state="translated">甲 &lt;code&gt;=pod&lt;/code&gt; 命令前一段落POD后发现。</target>
        </trans-unit>
        <trans-unit id="31f4edd1c949bdbda291e425d6bef6044643ffd6" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;BEGIN&lt;/code&gt; code block is executed as soon as possible, that is, the moment it is completely defined, even before the rest of the containing file (or string) is parsed. You may have multiple &lt;code&gt;BEGIN&lt;/code&gt; blocks within a file (or eval'ed string); they will execute in order of definition. Because a &lt;code&gt;BEGIN&lt;/code&gt; code block executes immediately, it can pull in definitions of subroutines and such from other files in time to be visible to the rest of the compile and run time. Once a &lt;code&gt;BEGIN&lt;/code&gt; has run, it is immediately undefined and any code it used is returned to Perl's memory pool.</source>
          <target state="translated">一个 &lt;code&gt;BEGIN&lt;/code&gt; 代码块将尽快执行，即在完全定义它的那一刻开始执行，甚至在解析包含文件的其余部分（或字符串）之前也是如此。一个文件（或评估字符串）中可能有多个 &lt;code&gt;BEGIN&lt;/code&gt; 块；它们将按定义顺序执行。因为 &lt;code&gt;BEGIN&lt;/code&gt; 代码块可以立即执行，所以它可以及时从其他文件中提取子例程等的定义，以使其余的编译和运行时可见。 &lt;code&gt;BEGIN&lt;/code&gt; 一旦运行，便立即被取消定义，并将其使用的任何代码返回到Perl的内存池。</target>
        </trans-unit>
        <trans-unit id="3948c72682ed13a39df444bd90a131ad77b87fa0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;File::Fetch&lt;/code&gt; object has the following accessors</source>
          <target state="translated">一个 &lt;code&gt;File::Fetch&lt;/code&gt; 对象有下列访问</target>
        </trans-unit>
        <trans-unit id="a0df5f12010c9e2a341950853965986995045017" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;MAYBE&lt;/code&gt; string should contain at least one combining character or the like. For example, &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; has the MAYBE_NFC/MAYBE_NFKC property.</source>
          <target state="translated">一个 &lt;code&gt;MAYBE&lt;/code&gt; 字符串应该至少包含一个组合字符等。例如， &lt;code&gt;COMBINING ACUTE ACCENT&lt;/code&gt; ACUTE ACCENT具有MAYBE_NFC / MAYBE_NFKC属性。</target>
        </trans-unit>
        <trans-unit id="d9aa930129748b8e7f36983538600e4ef3003dd2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;NUL&lt;/code&gt; character will be written after the end of the string.</source>
          <target state="translated">字符串末尾将写入一个 &lt;code&gt;NUL&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="14e49abd4463a2df704c3d0c251781f20f08e519" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PerlIOl *&lt;/code&gt; is a pointer to the struct, and the</source>
          <target state="translated">甲 &lt;code&gt;PerlIOl *&lt;/code&gt; 是一个指向该结构，并且</target>
        </trans-unit>
        <trans-unit id="e73ed792e4d7284609d9e1372b30eccc321faca0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SelectSaver&lt;/code&gt; object contains a reference to the file handle that was selected when it was created. If its &lt;code&gt;new&lt;/code&gt; method gets an extra parameter, then that parameter is selected; otherwise, the selected file handle remains unchanged.</source>
          <target state="translated">甲 &lt;code&gt;SelectSaver&lt;/code&gt; 对象包含到它被创建时所选择的文件句柄的引用。如果其 &lt;code&gt;new&lt;/code&gt; 方法获得一个额外的参数，则选择该参数；否则，所选文件句柄将保持不变。</target>
        </trans-unit>
        <trans-unit id="8fe48706c46ddab56d87823274b5a44ca94ef7e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;TAP::Parser::SourceHandler&lt;/code&gt; does whatever is necessary to produce &amp;amp; capture a stream of TAP from the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a99f3f0858c303c1b78e0bc06e71d69f8940558" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c30b7d6b5dae1d9e52bc3dfa57d215caf5d862" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;[&lt;/code&gt; is not special inside a character class, unless it's the start of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below). It normally does not need escaping.</source>
          <target state="translated">一 &lt;code&gt;[&lt;/code&gt; 是不是一个字符类中特殊的，除非它是一个POSIX字符类的开始（见&lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX字符类&lt;/a&gt;下文）。通常不需要转义。</target>
        </trans-unit>
        <trans-unit id="6776cbbe11f1658efaaee2f3dd38010bf8c93b32" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt; :</source>
          <target state="translated">甲 &lt;code&gt;\L&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 表示箱子持久转换，直到通过终止 &lt;code&gt;\E&lt;/code&gt; 或通过另一扔过 &lt;code&gt;\U&lt;/code&gt; 或 &lt;code&gt;\L&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a24307b632bac4af20bd3048bef792d9059be490" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\L&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; indicates a lasting conversion of case, until terminated by &lt;code&gt;\E&lt;/code&gt; or thrown over by another &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\L&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb525767ec147f71507ec3fe5c0bbfd43e23622a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt; . This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="translated">甲 &lt;code&gt;\w&lt;/code&gt; 匹配的单个字母数字字符（字母字符，或一个十进制数）; 或连接的标点字符，例如下划线（&amp;ldquo; _&amp;rdquo;）；或附加在其中一个字符上的&amp;ldquo;标记&amp;rdquo;字符（如某种重音符号）。它与整个单词不匹配。要匹配整个单词，请使用 &lt;code&gt;\w+&lt;/code&gt; 。这与匹配英语单词不同，但是在ASCII范围内，它与一串Perl标识符字符相同。</target>
        </trans-unit>
        <trans-unit id="3bd4c66560dca0578d3070157d991dfce3ac854e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;\w&lt;/code&gt; matches a single alphanumeric character (an alphabetic character, or a decimal digit); or a connecting punctuation character, such as an underscore (&quot;_&quot;); or a &quot;mark&quot; character (like some sort of accent) that attaches to one of those. It does not match a whole word. To match a whole word, use &lt;code&gt;\w+&lt;/code&gt;. This isn't the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46827aa6986ffad2428550f266417b4a216e73cc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot;&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387f0590ce374c162a12f59ad2a352b45a0b6a2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;]&lt;/code&gt; is normally either the end of a POSIX character class (see &lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX Character Classes&lt;/a&gt; below), or it signals the end of the bracketed character class. If you want to include a &lt;code&gt;]&lt;/code&gt; in the set of characters, you must generally escape it.</source>
          <target state="translated">甲 &lt;code&gt;]&lt;/code&gt; 通常是要么一个POSIX字符类的端部（参见&lt;a href=&quot;#POSIX-Character-Classes&quot;&gt;POSIX字符类&lt;/a&gt;下文），或它标志着方括号内的字符类的末尾。如果要在字符集中包含 &lt;code&gt;]&lt;/code&gt; ，则通常必须对其进行转义。</target>
        </trans-unit>
        <trans-unit id="1193d9cb8f306d664b7ff329f363fa64604ab25b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;bgzip&lt;/code&gt; file consists of a series of valid gzip-compliant data streams concatenated together. To read a file created by &lt;code&gt;bgzip&lt;/code&gt; with &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; use the &lt;code&gt;MultiStream&lt;/code&gt; option as shown in the previous section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a086836899301702e84e6ebfd5a64e6e1514ec1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;clean&lt;/code&gt; command results in a</source>
          <target state="translated">一个 &lt;code&gt;clean&lt;/code&gt; 命令导致</target>
        </trans-unit>
        <trans-unit id="30a979776a12ffbd2ccae1dfa8877b7ee9e2e1ac" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fork()&lt;/code&gt; failure may result in the following tests failing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2260ddde35cc7bc21b5b592a2612689aeec99e22" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; is simply a modifier on an lvalue expression. When you assign to a &lt;code&gt;local&lt;/code&gt;ized variable, the &lt;code&gt;local&lt;/code&gt; doesn't change whether its list is viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa451e4004dc04e11969a902e7778f3071f1b2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;local&lt;/code&gt; modifies its listed variables to be &quot;local&quot; to the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do FILE&lt;/code&gt;--and to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d318e0e7d10811cf9d04b1c9ec7142e2b390f3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;my&lt;/code&gt; has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet &lt;code&gt;use strict 'vars'&lt;/code&gt;, but it is also essential for generation of closures as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f82e2956ae874578dae0b862a6205fc9ad9a10d8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; commands before executing them:</source>
          <target state="translated">一个 &lt;code&gt;quiet&lt;/code&gt; 参数告诉 &lt;code&gt;CBuilder&lt;/code&gt; 在执行命令之前不打印其 &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="7e6166d094ef7a8c9acbf1912950fe415bf80619" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;quiet&lt;/code&gt; parameter tells &lt;code&gt;CBuilder&lt;/code&gt; to not print its &lt;code&gt;system()&lt;/code&gt; commands before executing them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537fa0e7c3fc8f4f2ff13df46f07e5efa8b0d873" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="translated">甲 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 其限定的偏移到串结构相匹配，其对应于 &lt;code&gt;$&amp;amp;&lt;/code&gt; 及 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等捕获，所述 &lt;code&gt;regexp_paren_pair&lt;/code&gt; 结构定义如下：</target>
        </trans-unit>
        <trans-unit id="88f343e9050a80a8547d07e80fa1abe57f501fdb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;regexp_paren_pair&lt;/code&gt; structure which defines offsets into the string being matched which correspond to the &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; etc. captures, the &lt;code&gt;regexp_paren_pair&lt;/code&gt; struct is defined as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c85a606418ea2141ddded1f2ff2c1a9dc2e0148" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c401b707420030372d274c701dc85d8905c95ac7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;select()&lt;/code&gt; wrapper that compensates for platform peculiarities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9187cecc86ed031f1a1d91cbbf85586329ad9482" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt; . The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="translated">将为 &lt;code&gt;struct netconfig&lt;/code&gt; 创建一个 &lt;code&gt;typedef&lt;/code&gt; 。 Perl对象将在与C类型名称匹配的类中得到祝福，并附加标签 &lt;code&gt;Ptr&lt;/code&gt; ，并且如果该名称是Perl包名称，则该名称不应包含嵌入式空格。析构函数将放置在与对象的类相对应的类中，并且正如Perl期望的那样，将使用PREFIX关键字将名称修剪为DESTROY。</target>
        </trans-unit>
        <trans-unit id="303080e3bc4b5d987f533b7d3f189bfcd0ce0dec" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typedef&lt;/code&gt; will be created for &lt;code&gt;struct netconfig&lt;/code&gt;. The Perl object will be blessed in a class matching the name of the C type, with the tag &lt;code&gt;Ptr&lt;/code&gt; appended, and the name should not have embedded spaces if it will be a Perl package name. The destructor will be placed in a class corresponding to the class of the object and the PREFIX keyword will be used to trim the name to the word DESTROY as Perl will expect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a29e0934f06be58e8f45f6ccaf516ef19ec003" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for 'our' variables.</source>
          <target state="translated">一个 B::HV 对象,代表 &quot;我们 &quot;变量的储藏库。</target>
        </trans-unit>
        <trans-unit id="f45e12c8a06cbfbc829397737665446dbd9373fc" translate="yes" xml:space="preserve">
          <source>A B::HV object representing the stash for a typed lexical.</source>
          <target state="translated">一个B::HV对象,表示一个类型化词汇的储藏库。</target>
        </trans-unit>
        <trans-unit id="42fcd5050adf426bbdb7192c3683fb606974ed22" translate="yes" xml:space="preserve">
          <source>A BLOCK by itself (labeled or not) is semantically equivalent to a loop that executes once. Thus you can use any of the loop control statements in it to leave or restart the block. (Note that this is</source>
          <target state="translated">一个BLOCK本身(无论是否有标签)在语义上等同于一个执行一次的循环。因此,你可以使用其中的任何一个循环控制语句来离开或重新启动该块。(注意,这是</target>
        </trans-unit>
        <trans-unit id="d2fb8a4ed8386e8349fe099520462ea5055d627c" translate="yes" xml:space="preserve">
          <source>A Buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3fa7a6472c1947a3e3fb9a265bfaa097653d2a" translate="yes" xml:space="preserve">
          <source>A Build.PL is run by perl in a separate process. Likewise we run './Build' and './Build install' in separate processes. If you have any parameters you want to pass to the calls, please specify them here.</source>
          <target state="translated">Build.PL是由perl在一个单独的进程中运行的。同样的,我们也在单独的进程中运行'./Build'和'./Build install'。如果你有任何你想传递给调用的参数,请在这里指定它们。</target>
        </trans-unit>
        <trans-unit id="2b8f77588c05a56fb0aa83c01416be422180616b" translate="yes" xml:space="preserve">
          <source>A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the</source>
          <target state="translated">常量值的C表达式,如果类型为集合,则为C表达式的列表。默认情况下,该表达式为</target>
        </trans-unit>
        <trans-unit id="e9567baf2c716fe48fcad56160dbe55dcf6fe52e" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3A-Keyword&quot;&gt;&quot;The ALIAS: Keyword&quot;&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;&quot;Variable-length Parameter Lists&quot;&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt;. When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt;, but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9bca895b6521acf14049f748fb255c795b1e71c" translate="yes" xml:space="preserve">
          <source>A CASE: might switch via a parameter of the XSUB, via the &lt;code&gt;ix&lt;/code&gt; ALIAS: variable (see &lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;The ALIAS: Keyword&lt;/a&gt;), or maybe via the &lt;code&gt;items&lt;/code&gt; variable (see &lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;Variable-length Parameter Lists&lt;/a&gt;). The last CASE: becomes the &lt;b&gt;default&lt;/b&gt; case if it is not associated with a conditional. The following example shows CASE switched via &lt;code&gt;ix&lt;/code&gt; with a function &lt;code&gt;rpcb_gettime()&lt;/code&gt; having an alias &lt;code&gt;x_gettime()&lt;/code&gt; . When the function is called as &lt;code&gt;rpcb_gettime()&lt;/code&gt; its parameters are the usual &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; , but when the function is called as &lt;code&gt;x_gettime()&lt;/code&gt; its parameters are reversed, &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; .</source>
          <target state="translated">一个CASE：可能通过XSUB的参数，通过 &lt;code&gt;ix&lt;/code&gt; ALIAS：变量（请参阅&lt;a href=&quot;#The-ALIAS%3a-Keyword&quot;&gt;ALIAS：Keyword&lt;/a&gt;）或通过 &lt;code&gt;items&lt;/code&gt; 变量（请参见&lt;a href=&quot;#Variable-length-Parameter-Lists&quot;&gt;可变长度参数列表&lt;/a&gt;）进行切换。如果不与条件关联，则最后一个CASE：成为&lt;b&gt;默认&lt;/b&gt;情况。下面的示例示出了通过CASE切换 &lt;code&gt;ix&lt;/code&gt; 与函数 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 具有一个别名 &lt;code&gt;x_gettime()&lt;/code&gt; 。当函数被称为 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 时,其参数是通常的 &lt;code&gt;(char *host, time_t *timep)&lt;/code&gt; ，但是当函数被称为 &lt;code&gt;x_gettime()&lt;/code&gt; 时,其参数被反转， &lt;code&gt;(time_t *timep, char *host)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="428a171aa5c95cac510361d11fc204293b5e9395" translate="yes" xml:space="preserve">
          <source>A CD-ROM drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14cb1f44ba3d5ff6c6389f7f3c7c6da1d1bedbef" translate="yes" xml:space="preserve">
          <source>A CES that was carefully designed to coexist with ASCII. There are a 7 bit version and an 8 bit version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c55f978db59708209a54d8bfb17d98c3ae019b46" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt; . See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="translated">一个CPAN镜像，其中仅包括每个发行版的最新版本，可能是使用 &lt;code&gt;CPAN::Mini&lt;/code&gt; 创建的。请参阅骆驼第19章&amp;ldquo; CPAN&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="27d5797833bb46c5943f83ed90ba2705b5e06f66" translate="yes" xml:space="preserve">
          <source>A CPAN mirror that includes just the latest versions for each distribution, probably created with &lt;code&gt;CPAN::Mini&lt;/code&gt;. See Camel chapter 19, &amp;ldquo;CPAN&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a412a9c43c3b078621b984e4d63b01678d573c0" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Feature object describes an optional feature offered by a CPAN distribution and specified in the distribution's</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9014220da96470ddba467afeca088e6c77df7b" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Prereqs object represents the prerequisites for a CPAN distribution or one of its optional features. Each set of prereqs is organized by phase and type, as described in &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN::Meta::Prereqs&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee116ec6b595415c9ecd2e7f6b24967dd7bd2c41" translate="yes" xml:space="preserve">
          <source>A CPAN::Meta::Requirements object models a set of version constraints like those specified in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79fea87c96ec94013ff8e4540cf4e641c3aa0b8" translate="yes" xml:space="preserve">
          <source>A Class is Simply a Package</source>
          <target state="translated">一个班级只是一个套餐</target>
        </trans-unit>
        <trans-unit id="6fbb257e39c68ad3d78df4ebee2ad99fbc20665b" translate="yes" xml:space="preserve">
          <source>A Comparison between various tar implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">一个完整的例子</target>
        </trans-unit>
        <trans-unit id="9f22eaf2aa717bb5924e306e9ab40bd24eefc92a" translate="yes" xml:space="preserve">
          <source>A DBM Filter allows the keys and/or values in a tied hash to be modified by some user-defined code just before it is written to the DBM file and just after it is read back from the DBM file. For example, this snippet of code</source>
          <target state="translated">一个DBM过滤器允许在一个绑定哈希中的键和/或值在写入DBM文件之前和从DBM文件读回之后被一些用户定义的代码修改。例如,这段代码</target>
        </trans-unit>
        <trans-unit id="a3dd10dc1183e2df3ed7ea791b7d9b7560ba9d95" translate="yes" xml:space="preserve">
          <source>A DBM Filter is a piece of code that is be used when you</source>
          <target state="translated">DBM过滤器是一段代码,它在你的</target>
        </trans-unit>
        <trans-unit id="5fea2d2439b0d67404b2ac6ae1e3bd78930fdef9" translate="yes" xml:space="preserve">
          <source>A Filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c2104df6e4f42e9c4248a2a9dcd9a50f8cd70b" translate="yes" xml:space="preserve">
          <source>A Filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74127e4dc0844d9e1d0d37669c77b5e1d7d7dc1c" translate="yes" xml:space="preserve">
          <source>A GV is a structure which corresponds to to a Perl typeglob, ie *foo. It is a structure that holds a pointer to a scalar, an array, a hash etc, corresponding to $foo, @foo, %foo.</source>
          <target state="translated">GV 是一个对应于 Perl typeglob 的结构,即 *foo。它是一个持有指向标量、数组、哈希等的指针的结构,对应于 $foo、@foo、%foo。</target>
        </trans-unit>
        <trans-unit id="13db893228041bbd750755e5ceeab1edf73eb3b3" translate="yes" xml:space="preserve">
          <source>A Graeco-Roman word meaning &amp;ldquo;to bring oneself to life&amp;rdquo;. In Perl, storage locations (&lt;b&gt;lvalues&lt;/b&gt;) spontaneously generate themselves as needed, including the creation of any &lt;b&gt;hard reference&lt;/b&gt; values to point to the next level of storage. The assignment &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; potentially creates five scalar storage locations, plus four references (in the first four scalar locations) pointing to four new anonymous arrays (to hold the last four scalar locations). But the point of autovivification is that you don&amp;rsquo;t have to worry about it.</source>
          <target state="translated">Graeco-Roman（希腊罗马字母）一词，意思是&amp;ldquo;使自己栩栩如生&amp;rdquo;。在Perl中，存储位置（&lt;b&gt;lvalues&lt;/b&gt;）会根据需要自动生成自身，包括创建任何&lt;b&gt;硬参考&lt;/b&gt;值以指向下一个存储级别。赋值 &lt;code&gt;$a[5][5][5][5][5] = &quot;quintet&quot;&lt;/code&gt; 可能会创建五个标量存储位置，外加指向四个新匿名数组（以保留）的四个引用（在前四个标量位置）最后四个标量位置）。但是，自动生存的关键是您不必为此担心。</target>
        </trans-unit>
        <trans-unit id="644fba68887f0f6c83a3c9ad6b03efeafe64485f" translate="yes" xml:space="preserve">
          <source>A HV structure represents a Perl hash. It consists mainly of an array of pointers, each of which points to a linked list of HE structures. The array is indexed by the hash function of the key, so each linked list represents all the hash entries with the same hash value. Each HE contains a pointer to the actual value, plus a pointer to a HEK structure which holds the key and hash value.</source>
          <target state="translated">一个HV结构表示一个Perl哈希。它主要由一个指针数组组成,每个指针指向一个HE结构的链接列表。数组以键的哈希函数为索引,因此每个链接列表代表所有具有相同哈希值的哈希条目。每个HE都包含一个指向实际值的指针,加上一个指向HEK结构的指针,HEK结构持有密钥和哈希值。</target>
        </trans-unit>
        <trans-unit id="bee561e494291ea6e45d02ab405b622a25e73320" translate="yes" xml:space="preserve">
          <source>A JSON array becomes a reference to an array in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b24830f56f4ce8a9945d4c6990fbf400347674" translate="yes" xml:space="preserve">
          <source>A JSON null atom becomes &lt;code&gt;undef&lt;/code&gt; in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67ff79ae5f44199fcff8b98322b150333800977d" translate="yes" xml:space="preserve">
          <source>A JSON number becomes either an integer, numeric (floating point) or string scalar in perl, depending on its range and any fractional parts. On the Perl level, there is no difference between those as Perl handles all the conversion details, but an integer may take slightly less memory and might represent more values exactly than floating point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d89eab13bda50b0d87fbbc9b957fca297e5455" translate="yes" xml:space="preserve">
          <source>A JSON object becomes a reference to a hash in Perl. No ordering of object keys is preserved (JSON does not preserve object key ordering itself).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d71ce97eec8dd4e08afea15be12b4484ab4838" translate="yes" xml:space="preserve">
          <source>A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON are represented by the same codepoints in the Perl string, so no manual decoding is necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec06e557b7618ed05ba8c87c2bab1b53c6df4c84" translate="yes" xml:space="preserve">
          <source>A List of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0ae4d993cdecbfc0080ff736e7e6c054fcca9fe" translate="yes" xml:space="preserve">
          <source>A List of keywords that describe this distribution. Keywords &lt;b&gt;must not&lt;/b&gt; include whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85434ba02f21ca07aa9cc6c2aef0afe50dbbf404" translate="yes" xml:space="preserve">
          <source>A Localization Horror Story: It Could Happen To You</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01232ff6c4ca9ea380827b743047b1207b0966c9" translate="yes" xml:space="preserve">
          <source>A Method is Simply a Subroutine</source>
          <target state="translated">方法只是一个子程序</target>
        </trans-unit>
        <trans-unit id="4fc1e89e0ebaf9800ac39a369b83b7a80fc77ec4" translate="yes" xml:space="preserve">
          <source>A Note about the Examples</source>
          <target state="translated">关于例子的说明</target>
        </trans-unit>
        <trans-unit id="0d72d9979807c702328842043bb2529c640d1c5d" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'DELAY' &quot;indicates the sender's willingness to receive delayed DSNs. Delayed DSNs may be issued if delivery of a message has been delayed for an unusual amount of time (as determined by the Message Transfer Agent (MTA) at which the message is delayed), but the final delivery status (whether successful or failure) cannot be determined. The absence of the DELAY keyword in a NOTIFY parameter requests that a &quot;delayed&quot; DSN NOT be issued under any conditions.&quot;</source>
          <target state="translated">通知参数'DELAY'&quot;表示发送方愿意接收延迟的DSN。如果消息的传递被延迟了不寻常的时间(由消息传输代理(MTA)决定),但最终的传递状态(是成功还是失败)无法确定,则可以发出延迟DSN。NOTIFY参数中如果没有DELAY关键字,则要求在任何条件下都不发出 &quot;延迟 &quot;的DSN。&quot;</target>
        </trans-unit>
        <trans-unit id="9dbcef065eab9753a6c0d2e89dd406c9f007951b" translate="yes" xml:space="preserve">
          <source>A Notify parameter of 'SUCCESS' or 'FAILURE' &quot;requests that a DSN be issued on successful delivery or delivery failure, respectively.&quot;</source>
          <target state="translated">'SUCCESS'或'FAILURE'的Notify参数 &quot;分别请求在成功交付或交付失败时发出DSN&quot;。</target>
        </trans-unit>
        <trans-unit id="7d978821811172b896c82b24fc810ad3863e3b13" translate="yes" xml:space="preserve">
          <source>A PID of &lt;code&gt;0&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to that of the current process. A PID of less than &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process whose process group ID is equal to -PID. A PID of &lt;code&gt;-1&lt;/code&gt; indicates to wait for any child process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f40c0f83e1e526b0b0b6c66a8b36e802555138" translate="yes" xml:space="preserve">
          <source>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (&lt;code&gt;^&lt;/code&gt;). Some examples:</source>
          <target state="translated">对POSIX字符类的Perl扩展是否定它的能力。这是通过在类名前面加上插入符号（ &lt;code&gt;^&lt;/code&gt; ）来完成的。一些例子：</target>
        </trans-unit>
        <trans-unit id="0d2d7129fe49ff692643bf989abc3c8db9550c7a" translate="yes" xml:space="preserve">
          <source>A Perl floating point number. Similar to T_IV and T_UV in that the return type is cast to the requested numeric type rather than to a specific type.</source>
          <target state="translated">一个Perl浮点数。类似于T_IV和T_UV,返回类型是投向所要求的数值类型,而不是投向特定的类型。</target>
        </trans-unit>
        <trans-unit id="baf019a8a8ab4371dcf7bafbfc9ccbe01c8c24c2" translate="yes" xml:space="preserve">
          <source>A Perl module that also pulls in &lt;b&gt;compiled&lt;/b&gt; C or C++ code. More generally, any experimental option that can be &lt;b&gt;compiled&lt;/b&gt; into Perl, such as multithreading.</source>
          <target state="translated">一个Perl模块，也引入已&lt;b&gt;编译的&lt;/b&gt; C或C ++代码。更一般而言，可以&lt;b&gt;编译&lt;/b&gt;到Perl中的任何实验性选项，例如多线程。</target>
        </trans-unit>
        <trans-unit id="d50862820d3a8aab33b93133b7d33cb935834ef5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">一种Perl模式，可以消除长前缀和短前缀的歧义。默认值为 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0493d06ff5354c921727ebe3abf0dda51d197688" translate="yes" xml:space="preserve">
          <source>A Perl pattern that allows the disambiguation of long and short prefixes. Default is &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e904ead9b94d6204fd6b39a939871c992e738f5" translate="yes" xml:space="preserve">
          <source>A Perl pattern that identifies the strings that introduce options. Default is &lt;code&gt;--|-|\+&lt;/code&gt; unless environment variable POSIXLY_CORRECT has been set, in which case it is &lt;code&gt;--|-&lt;/code&gt;.</source>
          <target state="translated">一个Perl模式，标识引入选项的字符串。除非设置了环境变量POSIXLY_CORRECT，否则默认值为 &lt;code&gt;--|-|\+&lt;/code&gt; ，在这种情况下为 &lt;code&gt;--|-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45c72c917209e7e654e9e53f35f4bca27fd858cf" translate="yes" xml:space="preserve">
          <source>A Perl program consists of a sequence of declarations and statements which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code.</source>
          <target state="translated">一个Perl程序由一连串的声明和语句组成,这些声明和语句从上到下运行。循环、子程序和其他控制结构允许你在代码中跳转。</target>
        </trans-unit>
        <trans-unit id="8f1d991ccec8e09953b3e8579dace5ef70ea0563" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; .</source>
          <target state="translated">Perl程序仅执行一次，而不是对每个输入行执行一次。您可以使用 &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;-p&lt;/code&gt; 进行隐式循环。</target>
        </trans-unit>
        <trans-unit id="719dc6b149ed9df2e9b30d38b9f401996838ec54" translate="yes" xml:space="preserve">
          <source>A Perl program executes only once, not once for each input line. You can do an implicit loop with &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05351cbee8badd4677882f72f83a69a3c04e972" translate="yes" xml:space="preserve">
          <source>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</source>
          <target state="translated">一个Perl程序来完成这些任务的基本形式是打开一个文件,打印它的行,然后关闭文件。</target>
        </trans-unit>
        <trans-unit id="9f85dbe5a418fb4bcdecb47b2f0b2cac2a377668" translate="yes" xml:space="preserve">
          <source>A Perl script or program consists of one or more statements. These statements are simply written in the script in a straightforward fashion. There is no need to have a &lt;code&gt;main()&lt;/code&gt; function or anything of that kind.</source>
          <target state="translated">Perl脚本或程序由一个或多个语句组成。这些语句以简单的方式简单地写在脚本中。不需要 &lt;code&gt;main()&lt;/code&gt; 函数或任何此类函数。</target>
        </trans-unit>
        <trans-unit id="ab689318c03ebde720ae51176a11effea3a569dc" translate="yes" xml:space="preserve">
          <source>A Perl user group, taking the form of its name from the New York Perl mongers, the first Perl user group. Find one near you at &lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org&lt;/a&gt;.</source>
          <target state="translated">一个Perl用户组，其名称形式来自第一个Perl用户组New York Perl商人。在&lt;a href=&quot;http://www.pm.org&quot;&gt;http://www.pm.org上&lt;/a&gt;找到您附近的人。</target>
        </trans-unit>
        <trans-unit id="eefc3e21c06e6017f8c10a8bb69ea540ab281b02" translate="yes" xml:space="preserve">
          <source>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</source>
          <target state="translated">Pod格式化器还可以在注释或警告中注明遇到了哪些不可渲染的字符。</target>
        </trans-unit>
        <trans-unit id="90bcd0d55b890352044335ec7ff338d09cd4b9d1" translate="yes" xml:space="preserve">
          <source>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should</source>
          <target state="translated">花苞处理器可能会发出信号,说明上述(特别是&quot;=head1 &quot;段)是一个错误。但请注意,以下内容应该是</target>
        </trans-unit>
        <trans-unit id="185a19a7a82d49a0358676fb031bca8138fc5f0d" translate="yes" xml:space="preserve">
          <source>A Rename script</source>
          <target state="translated">重命名脚本</target>
        </trans-unit>
        <trans-unit id="bb0e1d56b4fab0cf7a60aa29b48524e0458e7730" translate="yes" xml:space="preserve">
          <source>A Simple Client</source>
          <target state="translated">一个简单的客户端</target>
        </trans-unit>
        <trans-unit id="b671ac0d028246c423146116e7e15964cde16b69" translate="yes" xml:space="preserve">
          <source>A Simple Example</source>
          <target state="translated">一个简单的例子</target>
        </trans-unit>
        <trans-unit id="35d2688dd60f4771865d489a975386b1e2e85efc" translate="yes" xml:space="preserve">
          <source>A Social Contract about Artistic Control</source>
          <target state="translated">关于艺术控制的社会契约</target>
        </trans-unit>
        <trans-unit id="ce9f49f53bf8557e68c16a6cb0cab50ed319c852" translate="yes" xml:space="preserve">
          <source>A Solution</source>
          <target state="translated">解决方案</target>
        </trans-unit>
        <trans-unit id="33b832366f848ffdd1c9a8efe9f8d3f20e39c539" translate="yes" xml:space="preserve">
          <source>A TAP</source>
          <target state="translated">A TAP</target>
        </trans-unit>
        <trans-unit id="f5889f236a4188d2629daf331b9d72acfd600c43" translate="yes" xml:space="preserve">
          <source>A TAP parser consumes input from a single</source>
          <target state="translated">TAP解析器消耗来自单一的</target>
        </trans-unit>
        <trans-unit id="ebf6d3df00e862a08b0d79e0b9d4a2527d73a290" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7010880f6ae20816985e9d146f66cebdc5b3456f" translate="yes" xml:space="preserve">
          <source>A TAP parser creates &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;s as it iterates through the input</source>
          <target state="translated">TAP解析器在遍历输入时创建&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbc0d3fb42afd0ba8dd15a85a63c440071f45982" translate="yes" xml:space="preserve">
          <source>A TAP parser uses</source>
          <target state="translated">TAP解析器使用</target>
        </trans-unit>
        <trans-unit id="c7adba530805a495085a55a74870dea40f6e16bc" translate="yes" xml:space="preserve">
          <source>A TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP源和有关它的元数据</target>
        </trans-unit>
        <trans-unit id="92ce2bc3533d042b851a960d43bdd7c40fb70ee1" translate="yes" xml:space="preserve">
          <source>A TERM has the highest precedence in Perl. They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized. Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments. These are all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">TERM在Perl中具有最高优先级。它们包括变量，加引号和类似引号的运算符，括号中的任何表达式以及带括号的参数的任何函数。实际上，从这个意义上说，并没有真正的函数，只是列表运算符和一元运算符表现为函数，因为您在参数周围加上了括号。这些都记录在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b1a6a3b8076da1517275a693db5de38381afda3" translate="yes" xml:space="preserve">
          <source>A TRUE return means that at least one code point represented by the sequence either is a wide character not representable as a single byte, or the representation differs depending on whether the sequence is encoded in UTF-8 or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c2c3a67955f622ae2a621c93e51552fb8bf822" translate="yes" xml:space="preserve">
          <source>A Thread Pitfall: Deadlocks</source>
          <target state="translated">一个线程陷阱。僵局</target>
        </trans-unit>
        <trans-unit id="54dda450dbc946f563a52bcd0e2371c672a57c0d" translate="yes" xml:space="preserve">
          <source>A UCM file looks like this.</source>
          <target state="translated">UCM文件是这样的。</target>
        </trans-unit>
        <trans-unit id="43f36bb558eea29df73dc728bcd3a54abd7ec2ae" translate="yes" xml:space="preserve">
          <source>A UTF in 16-bit encoding. Can either be in big endian or little endian. The big endian version is called UTF-16BE (equal to UCS-2 + surrogate support) and the little endian version is called UTF-16LE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="311a8f73aa0632dde20a979ee931fae45488ea90" translate="yes" xml:space="preserve">
          <source>A Unicode</source>
          <target state="translated">一个Unicode</target>
        </trans-unit>
        <trans-unit id="636617240302996a8f020159cb2e15c959a81dd5" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt; ), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\b{}, \b, \B{}, \B in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="translated">从v5.22开始可用的Unicode边界（ &lt;code&gt;\b{}&lt;/code&gt; ）是两个字符之间，字符串中第一个字符之前，字符串中最后一个字符之后，满足Unicode定义的某些条件的位置。见&lt;a href=&quot;perlrebackslash#%5cb%7b%7d%2c-%5cb%2c-%5cB%7b%7d%2c-%5cB&quot;&gt;\ B {}，\ B，\ B {}，\乙在perlrebackslash&lt;/a&gt;的详细信息。</target>
        </trans-unit>
        <trans-unit id="76eb73f0015e13b24af055123c49d9a38b6acaf0" translate="yes" xml:space="preserve">
          <source>A Unicode boundary (&lt;code&gt;\b{}&lt;/code&gt;), available starting in v5.22, is a spot between two characters, or before the first character in the string, or after the final character in the string where certain criteria defined by Unicode are met. See &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6ccb5c3173a4892e5e2944faba0f70f7b55ac3" translate="yes" xml:space="preserve">
          <source>A Unicode linebreak matches the two-character CRLF grapheme or any of seven vertical whitespace characters. Good for dealing with textfiles coming from different operating systems.</source>
          <target state="translated">Unicode换行符与两个字符的CRLF字符或七个垂直空白字符中的任何一个相匹配。适用于处理来自不同操作系统的文本文件。</target>
        </trans-unit>
        <trans-unit id="d796a3e99a29b5e8798e5ee8787d53dec284ccde" translate="yes" xml:space="preserve">
          <source>A Webget Client</source>
          <target state="translated">一个Webget客户端</target>
        </trans-unit>
        <trans-unit id="50dd095330e040b6a4649d187065a771e5fe7217" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules required for building and/or testing of this distribution. These dependencies are not required after the module is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155290232ccec43841ef670c256ec20f15263b43" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules that cannot be installed while this distribution is installed. This is a pretty uncommon situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23933c4c7f89ad6b6468098ec568e0891d00fbb" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution recommends for enhanced operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcc493f623faaa5166c4233037cd1025c6b0ae1" translate="yes" xml:space="preserve">
          <source>A YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt; indicating the Perl modules this distribution requires for proper operation. The keys are the module names, and the values are version specifications as described in the &lt;a href=&quot;Module::Build::API#requires&quot;&gt;documentation for Module::Build's &quot;requires&quot; parameter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625ef9e7e1c1fa35b033333425cc32cf0c3ed6bf" translate="yes" xml:space="preserve">
          <source>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</source>
          <target state="translated">反斜线序列是一个字符序列,其中第一个是反斜线。Perl 给许多这样的序列赋予了特殊的含义,其中有些序列是字符类。也就是说,它们各自匹配一个字符,只要该字符属于序列所定义的特定字符集。</target>
        </trans-unit>
        <trans-unit id="0a7351fee5999f66ec79553b15a43f5d86c41d6e" translate="yes" xml:space="preserve">
          <source>A backward-compatibility alias for TYPE.</source>
          <target state="translated">TYPE的一个向后兼容的别名。</target>
        </trans-unit>
        <trans-unit id="f7fb814e1c2c79d0e734419e57ea9495c267d50e" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt; ; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt; . Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;GIMME_V&lt;/code&gt; 的向后兼容版本，只能返回 &lt;code&gt;G_SCALAR&lt;/code&gt; 或 &lt;code&gt;G_ARRAY&lt;/code&gt; ；在无效上下文中，它返回 &lt;code&gt;G_SCALAR&lt;/code&gt; 。不推荐使用。请改用 &lt;code&gt;GIMME_V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea63daaa7584ad162122c04feefcccd273238637" translate="yes" xml:space="preserve">
          <source>A backward-compatible version of &lt;code&gt;GIMME_V&lt;/code&gt; which can only return &lt;code&gt;G_SCALAR&lt;/code&gt; or &lt;code&gt;G_ARRAY&lt;/code&gt;; in a void context, it returns &lt;code&gt;G_SCALAR&lt;/code&gt;. Deprecated. Use &lt;code&gt;GIMME_V&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825d3b4cdbdd793ff6bcae81fea3eedc9476aefd" translate="yes" xml:space="preserve">
          <source>A bare declaration like that declares the function to be a list operator, not a unary operator, so you have to be careful to use parentheses (or &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;.) The &lt;code&gt;||&lt;/code&gt; operator binds too tightly to use after list operators; it becomes part of the last element. You can always use parentheses around the list operators arguments to turn the list operator back into something that behaves more like a function call. Alternatively, you can use the prototype &lt;code&gt;($)&lt;/code&gt; to turn the subroutine into a unary operator:</source>
          <target state="translated">像那样的裸声明声明函数是一个列表操作符，而不是一元运算符，所以你必须要小心使用括号（或 &lt;code&gt;or&lt;/code&gt; 代替 &lt;code&gt;||&lt;/code&gt; ）的 &lt;code&gt;||&lt;/code&gt; 操作符绑定太紧，无法在列表操作符之后使用；它成为最后一个元素的一部分。您始终可以在列表运算符参数周围使用括号，以将列表运算符重新转换为更类似于函数调用的行为。另外，您可以使用原型 &lt;code&gt;($)&lt;/code&gt; 将子例程转换为一元运算符：</target>
        </trans-unit>
        <trans-unit id="79d7fc67720af71225bb992fc841089461a260dd" translate="yes" xml:space="preserve">
          <source>A bare, single &lt;b&gt;statement&lt;/b&gt;, without any braces, hanging off an &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;while&lt;/code&gt; conditional. C allows them. Perl doesn&amp;rsquo;t.</source>
          <target state="translated">裸露的，单一的&lt;b&gt;声明&lt;/b&gt;，没有任何括号，挂了一个 &lt;code&gt;if&lt;/code&gt; 或 &lt;code&gt;while&lt;/code&gt; 条件。C允许他们。Perl没有。</target>
        </trans-unit>
        <trans-unit id="7c021cbe956d43771e93a19ff22791f5da1edc86" translate="yes" xml:space="preserve">
          <source>A basic building block. When you&amp;rsquo;re talking about an &lt;b&gt;array&lt;/b&gt;, it&amp;rsquo;s one of the items that make up the array.</source>
          <target state="translated">一个基本的构建块。当您谈论&lt;b&gt;数组时&lt;/b&gt;，它是构成&lt;b&gt;数组&lt;/b&gt;的项目之一。</target>
        </trans-unit>
        <trans-unit id="dc24770c94125e3eea533d29f62a33f6fca11b44" translate="yes" xml:space="preserve">
          <source>A basic example</source>
          <target state="translated">一个基本的例子</target>
        </trans-unit>
        <trans-unit id="f7282a24ce95eed40d8f1f24671950459bbf71d8" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="translated">一个基本的非缓冲层，它调用Unix / POSIX &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;lseek()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 。没有缓冲。即使在区分O_TEXT和O_BINARY的平台上，该层也始终是O_BINARY。</target>
        </trans-unit>
        <trans-unit id="96f31fcb471e12245ded4f9a6d4759ba999aaaaa" translate="yes" xml:space="preserve">
          <source>A basic non-buffered layer which calls Unix/POSIX &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;lseek()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;. No buffering. Even on platforms that distinguish between O_TEXT and O_BINARY this layer is always O_BINARY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3269aa1ef3bfcd123309b115096aa27b3b0a0aa8" translate="yes" xml:space="preserve">
          <source>A bigger, fancier sort of &lt;b&gt;program&lt;/b&gt; with a fancier name so people don&amp;rsquo;t realize they are using a program.</source>
          <target state="translated">一个更大，更高级的&lt;b&gt;程序&lt;/b&gt;，名称更高级，所以人们不会意识到自己正在使用程序。</target>
        </trans-unit>
        <trans-unit id="3fc8298d557ca48e82c9d8c77d3a4da35fed0d13" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1395a44d1527cd51acf9f72e88e221dc5e7a43dc" translate="yes" xml:space="preserve">
          <source>A binary search such as that provided by &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt;, can be used to quickly find a code point in the inversion list, and hence its corresponding mapping.</source>
          <target state="translated">诸如&lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist（）&lt;/a&gt;提供的二进制搜索之类的二进制搜索可用于快速在反演列表中找到一个代码点，从而找到其对应的映射。</target>
        </trans-unit>
        <trans-unit id="a3982f0643b548a46d27f9bb45d706ffed3877fd" translate="yes" xml:space="preserve">
          <source>A bit of magic: executing Perl code in a regular expression</source>
          <target state="translated">有点神奇:用正则表达式执行Perl代码</target>
        </trans-unit>
        <trans-unit id="a21b7a38b7737dbecfe5abeb569d1f5e67680088" translate="yes" xml:space="preserve">
          <source>A bitfield containing &lt;code&gt;AI_*&lt;/code&gt; constants; see below.</source>
          <target state="translated">包含 &lt;code&gt;AI_*&lt;/code&gt; 常量的位域；见下文。</target>
        </trans-unit>
        <trans-unit id="5315c3bf863fe0d813794db09004e209616806a3" translate="yes" xml:space="preserve">
          <source>A bolt out of the blue; that is, an event triggered by the &lt;b&gt;operating system&lt;/b&gt;, probably when you&amp;rsquo;re least expecting it.</source>
          <target state="translated">螺栓掉了出来；也就是说，由&lt;b&gt;操作系统&lt;/b&gt;触发的事件，可能是您最不期望的事件。</target>
        </trans-unit>
        <trans-unit id="37f6985b23fa2a35e2960a3080f908d1bc2f10c9" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; . The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , and &lt;code&gt;!=&lt;/code&gt; ), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , and &lt;code&gt;ne&lt;/code&gt; ).</source>
          <target state="translated">布尔比较运算符，例如 &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; 或 &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt; 。适用于此的关系运算符是六个数字比较（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; ）和六个字符串比较（ &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;eq&lt;/code&gt; 和 &lt;code&gt;ne&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="f872d192d60363c8ec38811eaa9cd396b2186576" translate="yes" xml:space="preserve">
          <source>A boolean comparison operator such as &lt;code&gt;$_ &amp;lt; 10&lt;/code&gt; or &lt;code&gt;$x eq &quot;abc&quot;&lt;/code&gt;. The relational operators that this applies to are the six numeric comparisons (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, and &lt;code&gt;!=&lt;/code&gt;), and the six string comparisons (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, and &lt;code&gt;ne&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16e0ea8efa85160b2ce98c496eca41e4f3f0abe" translate="yes" xml:space="preserve">
          <source>A boolean flag indicating whether a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5784bf453d1712122e0236fafc88e209e3c6adfe" translate="yes" xml:space="preserve">
          <source>A boolean flag that indicates if this argument was a required argument. If marked as required and not provided, check() will fail.</source>
          <target state="translated">一个布尔标志,表示这个参数是否为必填参数。如果标记为必填参数而没有提供,check()将失败。</target>
        </trans-unit>
        <trans-unit id="e6fe446e073ed79c5385621f6ed10de019fdcb46" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not the test suite passed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26eff46626719c9961598f48502b4f5bf7c8df23" translate="yes" xml:space="preserve">
          <source>A boolean indicating whether or not this call is for a subtest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5d923e23cbfcf9ddbcab23430ab0d60567d207" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is a decimal or dotted-decimal version. See &lt;a href=&quot;version#is_qv%28%29&quot;&gt;&quot;is_qv()&quot; in version&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f45f2fd37a08c482eccef8f9a0e056c9088589f" translate="yes" xml:space="preserve">
          <source>A boolean that denotes whether this is an alpha version. NOTE: that the underscore can only appear in the last position. See &lt;a href=&quot;version#is_alpha%28%29&quot;&gt;&quot;is_alpha()&quot; in version&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806d4e84607ce29c56416e6b774c66e8a0e936b0" translate="yes" xml:space="preserve">
          <source>A boolean to indicate whether &lt;code&gt;check&lt;/code&gt; should be verbose and warn about what went wrong in a check or not.</source>
          <target state="translated">一个布尔值，指示 &lt;code&gt;check&lt;/code&gt; 是否应冗长，并警告支票出了什么问题。</target>
        </trans-unit>
        <trans-unit id="75de768f80b992cf9735e1b55771968cbd72780f" translate="yes" xml:space="preserve">
          <source>A boolean type. This can be used to pass true and false values to and from C.</source>
          <target state="translated">一个布尔类型。它可以用来向C语言传递真值和假值。</target>
        </trans-unit>
        <trans-unit id="aaea9ae3f33d9df07a73532337b752e2bd4004dd" translate="yes" xml:space="preserve">
          <source>A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &lt;code&gt;check_install&lt;/code&gt; had no way to verify clearly.</source>
          <target state="translated">一个布尔值，指示是否发现该模块至少是您指定的版本。如果未指定版本，则在找到模块时uptodate始终为true。如果在模块中未找到可解析的版本，则 &lt;code&gt;check_install&lt;/code&gt; 也将为true，因为check_install无法清楚地进行验证。</target>
        </trans-unit>
        <trans-unit id="cf5fbd766ee0c61b894a2e6590881532089d7fdc" translate="yes" xml:space="preserve">
          <source>A brief description for most of the mentioned CJK encodings is contained in &lt;a href=&quot;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&quot;&gt;http://www.debian.org/doc/manuals/intro-i18n/ch-codes.en.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4da841a146cb38a789f449f32f4b854b9d0c640" translate="yes" xml:space="preserve">
          <source>A built-in unary operator that you use to determine whether something is &lt;b&gt;true&lt;/b&gt; about a file, such as &lt;code&gt;&amp;ndash;o
$filename&lt;/code&gt; to test whether you&amp;rsquo;re the owner of the file.</source>
          <target state="translated">一个内置的一元运算符，用于确定某个文件是否&lt;b&gt;正确&lt;/b&gt;，例如 &lt;code&gt;&amp;ndash;o $filename&lt;/code&gt; 以测试您是否是该文件的所有者。</target>
        </trans-unit>
        <trans-unit id="7359d066cd43a6821cadbf98e46de3780a2f14da" translate="yes" xml:space="preserve">
          <source>A bundle is just a perl module in the namespace Bundle:: that does not define any functions or methods. It usually only contains documentation.</source>
          <target state="translated">bundle只是命名空间Bundle::中的一个perl模块,它不定义任何函数或方法。它通常只包含文档。</target>
        </trans-unit>
        <trans-unit id="dcc2eb86ccf8cc61d11e939a89cf35406fa7d7cc" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8e1c29a7f993180d6961dbd822ca7a9b81fdce" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;&quot;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcefaccadd4fc0b82966dd6fe0502b4a54a13075" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro and the two &lt;code&gt;STORE&lt;/code&gt; ones. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">必须对&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION进行&lt;/a&gt;调用，以在编译时声明此宏和两个 &lt;code&gt;STORE&lt;/code&gt; 所使用的私有变量。该宏应作为单个语句而不是表达式来调用，但应具有一个空的参数列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="85dcd887c15b971af653f15a54e47c2790e7a16c" translate="yes" xml:space="preserve">
          <source>A call to &lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt; must have been made to declare at compile time a private variable used by this macro. This macro should be called as a single statement, not an expression, but with an empty argument list, like this:</source>
          <target state="translated">必须已调用&lt;a href=&quot;#DECLARATION_FOR_LC_NUMERIC_MANIPULATION&quot;&gt;DECLARATION_FOR_LC_NUMERIC_MANIPULATION&lt;/a&gt;，以在编译时声明此宏使用的私有变量。该宏应作为单个语句而不是表达式来调用，但应具有一个空的参数列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="6d081cdfc1719628de161b242cc46c6122417557" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt; . If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 将导致Perl退出，并通过 &lt;code&gt;lib$do_command&lt;/code&gt; 调用作为 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 参数提供的命令。如果参数以'@'或'$'开头（不是作为文件规范的一部分），则它将作为DCL命令执行。否则，将命令行上的第一个标记视为要运行的图像的文件规范，并尝试调用它（使用</target>
        </trans-unit>
        <trans-unit id="85638aa0428bad6b05c5801235d5757932516e51" translate="yes" xml:space="preserve">
          <source>A call to &lt;code&gt;exec&lt;/code&gt; will cause Perl to exit, and to invoke the command given as an argument to &lt;code&gt;exec&lt;/code&gt; via &lt;code&gt;lib$do_command&lt;/code&gt;. If the argument begins with '@' or '$' (other than as part of a filespec), then it is executed as a DCL command. Otherwise, the first token on the command line is treated as the filespec of an image to run, and an attempt is made to invoke it (using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1310b4d6c00ffc23a2f0bae5e7870ed9e6ede4" translate="yes" xml:space="preserve">
          <source>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It's important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</source>
          <target state="translated">字符类是一种表示字符集的方式,以匹配该字符集的一个字符。重要的是要记住:匹配一个字符类正好消耗源字符串中的一个字符。源字符串就是正则表达式所匹配的字符串)。</target>
        </trans-unit>
        <trans-unit id="2d7e4b0e3a328dba3c81ba02d01a3c0f782c72a5" translate="yes" xml:space="preserve">
          <source>A character encoding form plus byte serialization. There are Seven character encoding schemes in Unicode: UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32 (UCS-4), UTF-32BE (UCS-4BE) and UTF-32LE (UCS-4LE), and UTF-7.</source>
          <target state="translated">一种字符编码形式加上字节序列化。在Unicode中,有七种字符编码方案。UTF-8、UTF-16、UTF-16BE、UTF-16LE、UTF-32(UCS-4)、UTF-32BE(UCS-4BE)和UTF-32LE(UCS-4LE),以及UTF-7。</target>
        </trans-unit>
        <trans-unit id="e2b2859306209b5e788c7205519699be5962c3a1" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt; .</source>
          <target state="translated">发现一个字符实体，该字符实体不属于标准ISO集合或POD特殊 &lt;code&gt;verbar&lt;/code&gt; 和 &lt;code&gt;sol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3efbfb7c6f5b656c49fa17f73fcaa9b6dc991658" translate="yes" xml:space="preserve">
          <source>A character entity was found that does not belong to the standard ISO set or the POD specials &lt;code&gt;verbar&lt;/code&gt; and &lt;code&gt;sol&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3facef3525988e61e4c03673d831959bbb24fc" translate="yes" xml:space="preserve">
          <source>A character in the range 0 .. 2**32-1 (or more); what Perl's strings are made of.</source>
          <target state="translated">0 ...2**32-1 (或更多)范围内的字符;Perl的字符串就是由这些字符组成的。</target>
        </trans-unit>
        <trans-unit id="4c66dbdd31c41ff8290d5b9e5b84c42f44091393" translate="yes" xml:space="preserve">
          <source>A character in the range 0..255; a special case of a Perl character.</source>
          <target state="translated">范围为0...255的字符;Perl字符的一种特殊情况。</target>
        </trans-unit>
        <trans-unit id="deb99f697e889e229888732646e1d9a4b2cd77a6" translate="yes" xml:space="preserve">
          <source>A character range may be specified with a hyphen, so &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; does the same replacement as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt;. For &lt;b&gt;sed&lt;/b&gt; devotees, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; is provided as a synonym for &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;. If the</source>
          <target state="translated">字符范围可以用连字符指定，因此 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/A-J/0-9/&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr/ACEGIBDFHJ/0246813579/&lt;/a&gt;&lt;/code&gt; 了相同的替换。对于&lt;b&gt;sed的&lt;/b&gt;奉献者， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 的同义词。如果</target>
        </trans-unit>
        <trans-unit id="62e5445beeff56a35c0dc5ca65bde86d53c27ebb" translate="yes" xml:space="preserve">
          <source>A character set comprising all the major character sets of the world, more or less. See &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;.</source>
          <target state="translated">一个或多或少包含世界上所有主要字符集的字符集。参见&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e5a861e5d79ec9801dc0afc379f1516aa190f92" translate="yes" xml:space="preserve">
          <source>A character set that aims to include all character repertoires of the world. Many character sets in various national as well as industrial standards have become, in a way, just subsets of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd6e4ff71c892f21b92e2e5137c07d6d2cc0f6c" translate="yes" xml:space="preserve">
          <source>A character set that is mapped in a way computers can use directly. Many character encodings, including EUC, fall in this category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c07be0779b2376c619d1a65316d136daa5c26ab" translate="yes" xml:space="preserve">
          <source>A character symbolizing the type of IO Handle.</source>
          <target state="translated">一个象征IO手柄类型的字符。</target>
        </trans-unit>
        <trans-unit id="ad2f4627442f7e9e5cdd45c11902cca0d8325c3b" translate="yes" xml:space="preserve">
          <source>A character with the numeric value of zero. It&amp;rsquo;s used by C to terminate strings, but Perl allows strings to contain a null.</source>
          <target state="translated">数值为零的字符。C使用它终止字符串，但是Perl允许字符串包含null。</target>
        </trans-unit>
        <trans-unit id="a98fe200a320861843965673193461dc42788194" translate="yes" xml:space="preserve">
          <source>A check is made to make sure that the file that is found does contain some pod documentation.</source>
          <target state="translated">会进行检查,以确保找到的文件确实包含一些 pod 文档。</target>
        </trans-unit>
        <trans-unit id="dff052af6a3279311d539bddc8b2f4ffb4c3bccf" translate="yes" xml:space="preserve">
          <source>A check routine is called when the node is fully constructed except for the execution-order thread. Since at this time there are no back-links to the currently constructed node, one can do most any operation to the top-level node, including freeing it and/or creating new nodes above/below it.</source>
          <target state="translated">当节点除执行顺序线程外全部构造完成时,会调用一个检查例程。由于此时没有与当前构造的节点的反向链接,所以可以对顶层节点进行大部分的操作,包括释放它和/或在它上面/下面创建新的节点。</target>
        </trans-unit>
        <trans-unit id="ffb83db9b043670ff139e922da8f6f1ecd3cdb22" translate="yes" xml:space="preserve">
          <source>A class implementing a filehandle should have the following methods:</source>
          <target state="translated">一个实现filehandle的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="78efc3f39c8e446fbaac2a63562d8cf90bbe3489" translate="yes" xml:space="preserve">
          <source>A class implementing a hash should have the following methods:</source>
          <target state="translated">一个实现哈希的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="c29da3bd78457adcea44e08fd7ad308e312eac90" translate="yes" xml:space="preserve">
          <source>A class implementing a scalar should have the following methods:</source>
          <target state="translated">一个实现标量的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="63533b67267a9fe7a63e719b4e79f437e64bb6e7" translate="yes" xml:space="preserve">
          <source>A class implementing a tied filehandle should define the following methods: TIEHANDLE, at least one of PRINT, PRINTF, WRITE, READLINE, GETC, READ, and possibly CLOSE, UNTIE and DESTROY. The class can also provide: BINMODE, OPEN, EOF, FILENO, SEEK, TELL - if the corresponding perl operators are used on the handle.</source>
          <target state="translated">一个实现绑定文件柄的类应该定义以下方法。TIEHANDLE、PRINT、PRINTF、WRITE、READLINE、GETC、READ中的至少一个方法,可能还有CLOSE、UNTIE和DESTROY。该类还可以提供。BINMODE,OPEN,EOF,FILENO,SEEK,TELL --如果在句柄上使用了相应的perl运算符。</target>
        </trans-unit>
        <trans-unit id="860765a0ff8cee1341ccc04233da280b71701cf8" translate="yes" xml:space="preserve">
          <source>A class implementing a tied ordinary array should define the following methods: TIEARRAY, FETCH, STORE, FETCHSIZE, STORESIZE, CLEAR and perhaps UNTIE and/or DESTROY.</source>
          <target state="translated">一个实现绑定普通数组的类应该定义以下方法。TIEARRAY、FETCH、STORE、FETCHSIZE、STORESIZE、CLEAR以及可能的UNTIE和/或DESTROY。</target>
        </trans-unit>
        <trans-unit id="bf2fe5249c3fde4bdfb3247a51b433da9021cc26" translate="yes" xml:space="preserve">
          <source>A class implementing a tied scalar should define the following methods: TIESCALAR, FETCH, STORE, and possibly UNTIE and/or DESTROY.</source>
          <target state="translated">一个实现绑定标量的类应该定义以下方法:TIESCALAR,FETCH,STORE,以及可能的UNTIE和/或DESTROY。TIESCALAR,FETCH,STORE,可能还有UNTIE和/或DESTROY。</target>
        </trans-unit>
        <trans-unit id="172ef2f1ff718aa5d74e2eddddd8780306842005" translate="yes" xml:space="preserve">
          <source>A class implementing an ordinary array should have the following methods:</source>
          <target state="translated">一个实现普通数组的类应该有以下方法。</target>
        </trans-unit>
        <trans-unit id="7a3aaef4b6bdc65044d6cee8905b655c826b75aa" translate="yes" xml:space="preserve">
          <source>A class is simply a package. A class provides methods that expect to operate on objects.</source>
          <target state="translated">一个类就是一个简单的包。一个类提供了期望对对象进行操作的方法。</target>
        </trans-unit>
        <trans-unit id="db991666cef49d40c1a8876d8e678d10cc5c5920" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC message queues.</source>
          <target state="translated">一个为SysV IPC消息队列提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="4b371730a083c396c011c1644f5fee33b2fe22c7" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC semaphores.</source>
          <target state="translated">一个为SysV IPC semaphores提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="937b26fb80fdcafceefce4e180073ce7c0d23781" translate="yes" xml:space="preserve">
          <source>A class providing an object based interface to SysV IPC shared memory.</source>
          <target state="translated">一个为SysV IPC共享内存提供基于对象的接口的类。</target>
        </trans-unit>
        <trans-unit id="bd175d0ab34111d2e7b8c50a111622dec0708ca3" translate="yes" xml:space="preserve">
          <source>A class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2558ecb874a35a0f9b83568f215824db4e665c" translate="yes" xml:space="preserve">
          <source>A cleaner interface.</source>
          <target state="translated">一个更简洁的界面。</target>
        </trans-unit>
        <trans-unit id="243557da44bd0a5796f8364017fe91e379f3fd89" translate="yes" xml:space="preserve">
          <source>A client for such a server could be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="057ca0c3c407c4a073d1e7a556976d6dc49abacf" translate="yes" xml:space="preserve">
          <source>A code for the type of media. See the &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; export class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38d53db5215d12738985d5f40428b967eb33230" translate="yes" xml:space="preserve">
          <source>A collection of unique characters. A</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac161b3e973b3214fa6c5dba36e6bf752d3c13d" translate="yes" xml:space="preserve">
          <source>A comma-separated list of mirrors to use for just this run. The &lt;code&gt;-P&lt;/code&gt; option can find them for you automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551df32d5b94297e0a676020a161e26c925fb485" translate="yes" xml:space="preserve">
          <source>A command &quot;=begin</source>
          <target state="translated">命令&quot;=begin</target>
        </trans-unit>
        <trans-unit id="4b51cb486fb82b1f8836c9909ccc915ba4671256" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="translated">命令段落（也称为&amp;ldquo;指令&amp;rdquo;）。本段的第一行必须与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; 相匹配。命令段落通常为一行，如下所示：</target>
        </trans-unit>
        <trans-unit id="a57f5a78e79b4e4e45aef57f5fe85eaf31a249f1" translate="yes" xml:space="preserve">
          <source>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt;. Command paragraphs are typically one line, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63e70d9d65f24f45184b420c514e63650be0655" translate="yes" xml:space="preserve">
          <source>A command paragraph is used for special treatment of whole chunks of text, usually as headings or parts of lists.</source>
          <target state="translated">命令段用于对整块文字进行特殊处理,通常作为标题或列表的一部分。</target>
        </trans-unit>
        <trans-unit id="d9ff878c605ee9fd388f0b2eb88f5ce5a0c8f433" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="translated">这样的命令首先可以大大减少实际要分拣的物料的数量，并且不应纯粹出于其简单性而过分忽略它。该 &lt;code&gt;KISS&lt;/code&gt; 原则是常常被忽视-在下面的例子中使用了简单的系统 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 效用来证明。让我们看一个实际的示例，该示例对一个大文件的内容进行排序，而apache日志文件可以做到。该行有四分之一的行，超过一百万行，大小为5000万，其摘要如下所示：</target>
        </trans-unit>
        <trans-unit id="0aea28bdea157023aa3d7cd5bd7e48a433c74487" translate="yes" xml:space="preserve">
          <source>A command such as this can vastly reduce the volume of material to actually sort through in the first place, and should not be too lightly disregarded purely on the basis of its simplicity. The &lt;code&gt;KISS&lt;/code&gt; principle is too often overlooked - the next example uses the simple system &lt;code&gt;time&lt;/code&gt; utility to demonstrate. Let's take a look at an actual example of sorting the contents of a large file, an apache logfile would do. This one has over a quarter of a million lines, is 50M in size, and a snippet of it looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="950be6f2b3fd35cd65faf61436fcb9557d03c11d" translate="yes" xml:space="preserve">
          <source>A command which has ended up in the middle of a paragraph or other command, such as</source>
          <target state="translated">在一段话或其他命令中结束的命令,如</target>
        </trans-unit>
        <trans-unit id="dfc138f19fcb5bcbc53f0752d4f1867a8fa0e913" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt; , to query what modules were shipped with given versions of perl.</source>
          <target state="translated">在 &lt;code&gt;Module::CoreList&lt;/code&gt; 的命令行前端，用于查询给定版本的perl附带了哪些模块。</target>
        </trans-unit>
        <trans-unit id="03a5eed393d50b8ebdff34b45b799ace9b9158b6" translate="yes" xml:space="preserve">
          <source>A command-line front-end to &lt;code&gt;Module::CoreList&lt;/code&gt;, to query what modules were shipped with given versions of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbae24479d2e6391e2d1be21dd08d1626f00360" translate="yes" xml:space="preserve">
          <source>A comment</source>
          <target state="translated">一条评论</target>
        </trans-unit>
        <trans-unit id="79414afc2393f5f2f467ceef02de3748e14d7a7a" translate="yes" xml:space="preserve">
          <source>A comment, indicated by putting a '#' in the first column.</source>
          <target state="translated">一条评论,在第一栏加个 &quot;#&quot;表示。</target>
        </trans-unit>
        <trans-unit id="b093d0d89cc94439fab7e6d11818a74b1c71812b" translate="yes" xml:space="preserve">
          <source>A comment. The</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee091682ad4b542f16ac50d991bfff2ba6d1e9a6" translate="yes" xml:space="preserve">
          <source>A comment. The text is ignored. Note that Perl closes the comment as soon as it sees a &lt;code&gt;)&lt;/code&gt;, so there is no way to put a literal &lt;code&gt;)&lt;/code&gt; in the comment. The pattern's closing delimiter must be escaped by a backslash if it appears in the comment.</source>
          <target state="translated">一条评论。文本将被忽略。请注意，Perl看到 &lt;code&gt;)&lt;/code&gt; 就会立即关闭注释，因此无法在注释中添加文字 &lt;code&gt;)&lt;/code&gt; 。如果模式的结束定界符出现在注释中，则必须使用反斜杠对其进行转义。</target>
        </trans-unit>
        <trans-unit id="1efe142409d27cde9607bba9f906e0c889b26956" translate="yes" xml:space="preserve">
          <source>A commit message isn't intended to take the place of comments in your code. Commit messages should describe the change you made, while code comments should describe the current state of the code.</source>
          <target state="translated">提交信息并不是要取代代码中的注释,提交信息应该描述你所做的修改,而代码注释应该描述代码的当前状态。提交信息应该描述你所做的修改,而代码注释应该描述代码的当前状态。</target>
        </trans-unit>
        <trans-unit id="bf7ad1fec29a3549dc58ded16ba4af5fb14c45da" translate="yes" xml:space="preserve">
          <source>A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:</source>
          <target state="translated">对这一能力的常见滥用源于使用正则表达式进行无限循环的能力,比如一些无害的东西。</target>
        </trans-unit>
        <trans-unit id="80ff7af3da26f57aaa8f224ec06b92247a2ede78" translate="yes" xml:space="preserve">
          <source>A common bit of code &lt;b&gt;NOT TO USE&lt;/b&gt; is this:</source>
          <target state="translated">&lt;b&gt;不使用的&lt;/b&gt;常见代码是：</target>
        </trans-unit>
        <trans-unit id="bcd3e6faa389885dcad88118cf027340603a19e2" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="translated">套接字编程中一个常见的误解是，到处都是 &lt;code&gt;\n &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; \012&lt;/code&gt; 。当使用诸如通用Internet协议之类的协议时，将特别要求 &lt;code&gt;\012&lt;/code&gt; 和 &lt;code&gt;\015&lt;/code&gt; ，并且逻辑 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\r&lt;/code&gt; （回车）的值不可靠。</target>
        </trans-unit>
        <trans-unit id="547a6fcaad39d8d2e51072980c79106e4d8f2797" translate="yes" xml:space="preserve">
          <source>A common misconception in socket programming is that &lt;code&gt;\n eq \012&lt;/code&gt; everywhere. When using protocols such as common Internet protocols, &lt;code&gt;\012&lt;/code&gt; and &lt;code&gt;\015&lt;/code&gt; are called for specifically, and the values of the logical &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; (carriage return) are not reliable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9e9593af1f1c680a3827d8f5e0edca15a66c226" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;-string. For this reason, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="translated">一个常见的错误是尝试用逗号分隔单词或将注释放入多行 &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; -string中。由于这个原因，如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，则使用警告编译指示和&lt;b&gt;-w&lt;/b&gt;开关（即 &lt;code&gt;$^W&lt;/code&gt; 变量）会产生警告。</target>
        </trans-unit>
        <trans-unit id="7281583226716ee344a88588c1f30e8169fcc770" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to separate the words with commas or to put comments into a multi-line &lt;code&gt;qw&lt;/code&gt;-string. For this reason, the &lt;code&gt;use warnings&lt;/code&gt; pragma and the &lt;b&gt;-w&lt;/b&gt; switch (that is, the &lt;code&gt;$^W&lt;/code&gt; variable) produces warnings if the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad5d9b3c5a0d882bf3ecc970194923dc4421054" translate="yes" xml:space="preserve">
          <source>A common mistake is to write:</source>
          <target state="translated">一个常见的错误是写。</target>
        </trans-unit>
        <trans-unit id="7892054117b48e6a3618b7ba1c611a106354c30a" translate="yes" xml:space="preserve">
          <source>A common pitfall is to forget that &lt;code&gt;&quot;#&quot;&lt;/code&gt; characters begin a comment under &lt;code&gt;/x&lt;/code&gt; and are not matched literally. Just keep that in mind when trying to puzzle out why a particular &lt;code&gt;/x&lt;/code&gt; pattern isn't working as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053544785eaa005951fc7923348a6ed5ac918733" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a1998491c1e38cb900464f10bbb2d155c01472d" translate="yes" xml:space="preserve">
          <source>A common pitfall is to use &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; when you want to round a result to a certain number of digits:</source>
          <target state="translated">一个常见的陷阱是，当您想将结果四舍五入到一定位数时，使用&lt;a href=&quot;#precision()&quot;&gt;precision（）&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="008944edbc996e59046c342b9a5abf856d868927" translate="yes" xml:space="preserve">
          <source>A common sight is code which looks something like this:</source>
          <target state="translated">一个常见的景象是,代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="7a1613d252216a78f3f6c4f13b80070f584c7ea5" translate="yes" xml:space="preserve">
          <source>A common value you might want would be just &quot;.&quot; for the current directory:</source>
          <target state="translated">你可能想要的一个常见的值就是当前目录的&quot;.&quot;。</target>
        </trans-unit>
        <trans-unit id="fe5d8a965ad75566e7f17ed9a970119fdb9dbef8" translate="yes" xml:space="preserve">
          <source>A comparison of GNU and POSIX tar standards; &lt;code&gt;http://www.delorie.com/gnu/docs/tar/tar_114.html&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c241c23e5c55b1df65f14fa3926fd6466b90d17" translate="yes" xml:space="preserve">
          <source>A complete list of Perl's error messages and warnings with explanatory text can be found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. You can also use the splain program (distributed with Perl) to explain the error messages:</source>
          <target state="translated">在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;可以找到Perl错误消息和警告的完整列表以及说明性文字。您还可以使用splain程序（与Perl一起分发）来解释错误消息：</target>
        </trans-unit>
        <trans-unit id="2766232819d1e10808eb2c0fa9745fbc9935b0e0" translate="yes" xml:space="preserve">
          <source>A complete list of blocks and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">块及其快捷方式的完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cbbc7ef27b343f02ecb00286ffab06c25627261" translate="yes" xml:space="preserve">
          <source>A complete list of blocks is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9c8e1e2ba56e67cb98e64490d656c0331322db" translate="yes" xml:space="preserve">
          <source>A complete list of models at the time the OS was built is in the file /usr/sam/lib/mo/sched.models. The first column corresponds to the last part of the output of the &quot;model&quot; command. The second column is the PA-RISC version and the third column is the exact chip type used. (Start browsing at the bottom to prevent confusion ;-)</source>
          <target state="translated">操作系统建立时的完整模型列表在文件/usr/sam/lib/mo/sched.models中。第一列对应于 &quot;model &quot;命令输出的最后一部分。第二列是PA-RISC版本,第三列是所使用的准确芯片类型。(从底部开始浏览,防止混淆;-)</target>
        </trans-unit>
        <trans-unit id="57f247bd806924e603c825d46c359f392e5225bb" translate="yes" xml:space="preserve">
          <source>A complete list of scripts and their shortcuts is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">脚本及其快捷方式的完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="352eea5d492543a075b98638f01aabee71fa53f5" translate="yes" xml:space="preserve">
          <source>A complete thread tutorial could fill a book (and has, many times), but with what we've covered in this introduction, you should be well on your way to becoming a threaded Perl expert.</source>
          <target state="translated">一个完整的线程教程可以写满一本书(而且已经写了很多次),但是有了我们在本篇介绍中所涉及的内容,你应该可以顺利地成为一个线程的Perl专家。</target>
        </trans-unit>
        <trans-unit id="018d8cf23f3e4a65b253a6e3de9afa4ba28bc385" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; pattern.</source>
          <target state="translated">&lt;b&gt;正则表达式&lt;/b&gt;模式的组成部分。</target>
        </trans-unit>
        <trans-unit id="f5c9d218e3a29ce718317121d0020d3ccf6b9e88" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; specifying how many times the foregoing &lt;b&gt;atom&lt;/b&gt; may occur.</source>
          <target state="translated">&lt;b&gt;正则表达式的&lt;/b&gt;组成部分，指定上述&lt;b&gt;原子&lt;/b&gt;可能出现多少次。</target>
        </trans-unit>
        <trans-unit id="ca17448c2b0615d183e89c2b8af18e1466ef0123" translate="yes" xml:space="preserve">
          <source>A component of a &lt;b&gt;regular expression&lt;/b&gt; that must be true for the pattern to match but does not necessarily match any characters itself. Often used specifically to mean a &lt;b&gt;zero-width&lt;/b&gt; assertion.</source>
          <target state="translated">&lt;b&gt;正则表达式的&lt;/b&gt;组成部分，必须为true才能使模式匹配，但不一定与任何字符本身匹配。通常专门用于表示&lt;b&gt;零宽度&lt;/b&gt;断言。</target>
        </trans-unit>
        <trans-unit id="e4b110fd2e9cb16d7f0633f61d623ac063cd7727" translate="yes" xml:space="preserve">
          <source>A comprehensive list of Perl-related mailing lists can be found at &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;</source>
          <target state="translated">可以在&lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;找到与Perl相关的邮件列表的完整列表。</target>
        </trans-unit>
        <trans-unit id="93cab815f48685f272ec4cd3a106ebc83fa3cbb8" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of the Korean (&lt;code&gt;KS *&lt;/code&gt;) standards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b95e9b387684f580231ace97a79e9e9349d1ddf" translate="yes" xml:space="preserve">
          <source>A consequence of the &lt;code&gt;split&lt;/code&gt; formulation is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffdc43a299a7177f53314c9b7e876aeb0c84ac8" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=number&lt;/b&gt; never does a version check, unless &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; itself is set up to do a version check, which could happen for example if</source>
          <target state="translated">其结果是，&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = number&lt;/b&gt;永远不会进行版本检查，除非将 &lt;code&gt;&lt;i&gt;MODULE&lt;/i&gt;::import()&lt;/code&gt; 本身设置为进行版本检查，例如</target>
        </trans-unit>
        <trans-unit id="350e3e899dba4b57e7486366f0fbf9264f9b61f7" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt; , for technical reasons.</source>
          <target state="translated">出于技术原因，除了包 &lt;code&gt;main::&lt;/code&gt; ，任何地方都不允许使用名称在 &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; 列表中的常量。</target>
        </trans-unit>
        <trans-unit id="33082690d5a42fa2c8743ad22c40a6af2321de88" translate="yes" xml:space="preserve">
          <source>A constant with a name in the list &lt;code&gt;STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG&lt;/code&gt; is not allowed anywhere but in package &lt;code&gt;main::&lt;/code&gt;, for technical reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f90a10d8180ed5dc542d1b277136194356a682" translate="yes" xml:space="preserve">
          <source>A construct that performs something repeatedly, like a roller coaster.</source>
          <target state="translated">一种重复执行某事的构造,就像过山车一样。</target>
        </trans-unit>
        <trans-unit id="98c376c5464a7cbd0f7597422425141a29b3dc1e" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有时看起来像函数但实际上不是的构造。通常保留给像 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 这样的&lt;b&gt;左值&lt;/b&gt;修饰符，像 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 这样的&lt;b&gt;上下文&lt;/b&gt;修饰符以及 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 的pick-your-own-quotes构造。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="806f6b00b71ddb7f8c4ade43c00b3953a355f7bd" translate="yes" xml:space="preserve">
          <source>A construct that sometimes looks like a function but really isn&amp;rsquo;t. Usually reserved for &lt;b&gt;lvalue&lt;/b&gt; modifiers like &lt;code&gt;my&lt;/code&gt;, for &lt;b&gt;context&lt;/b&gt; modifiers like &lt;code&gt;scalar&lt;/code&gt;, and for the pick-your-own-quotes constructs, &lt;code&gt;q//&lt;/code&gt;, &lt;code&gt;qq//&lt;/code&gt;, &lt;code&gt;qx//&lt;/code&gt;, &lt;code&gt;qw//&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt;, &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;, and &lt;code&gt;tr///&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8552f673941f3d1978946011be4253061336584" translate="yes" xml:space="preserve">
          <source>A contact email address for the author/maintainer</source>
          <target state="translated">作者/维护者的联系电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="1e9afcf85fc0132156a56c6d8cb4ffccff6b369d" translate="yes" xml:space="preserve">
          <source>A convenience function which combines creating an object and calling &lt;code&gt;isa_ok()&lt;/code&gt; on that object.</source>
          <target state="translated">一个便捷函数，将创建对象和 &lt;code&gt;isa_ok()&lt;/code&gt; 对象调用isa_ok（）结合在一起。</target>
        </trans-unit>
        <trans-unit id="53128330b7badc08928ea23290fdacf578eb391d" translate="yes" xml:space="preserve">
          <source>A convenience variable which is typically used with &lt;code&gt;SvPV&lt;/code&gt; when one doesn't care about the length of the string. It is usually more efficient to either declare a local variable and use that instead or to use the &lt;code&gt;SvPV_nolen&lt;/code&gt; macro.</source>
          <target state="translated">一个方便变量，通常在不关心字符串长度的情况下与 &lt;code&gt;SvPV&lt;/code&gt; 一起使用。通常，声明局部变量并使用它或使用 &lt;code&gt;SvPV_nolen&lt;/code&gt; 宏通常更为有效。</target>
        </trans-unit>
        <trans-unit id="df5714f0f92eb562b41f83c46ccd5b057e98cc38" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of &lt;code&gt;ARRAY&lt;/code&gt; references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638f854b99669da73bce286ea189e697af8d4b5f" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of ARRAY references, each containing two items from the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数大小的对列表进行操作的便捷捷径,它返回一个ARRAY引用的列表,每个列表包含给定列表中的两个项目。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="1166e931ea27a942799d52c7c1f3e445e7d6efa2" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the first values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数对列表进行操作的一个便捷的捷径,它返回给定列表中每个对的首值列表。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="0dbcf107b79ffefab41fba2fbb5cf9a734cd1746" translate="yes" xml:space="preserve">
          <source>A convenient shortcut to operating on even-sized lists of pairs, this function returns a list of the the second values of each of the pairs in the given list. It is a more efficient version of</source>
          <target state="translated">这个函数是对偶数对列表进行操作的一个便捷的捷径,它返回给定列表中每个对的第二个值的列表。它是一个更有效的版本</target>
        </trans-unit>
        <trans-unit id="77f68a02d61a77d7eed2d175da1b876e8aceace1" translate="yes" xml:space="preserve">
          <source>A convenient way to set up your tests. Call this and Test::Builder will print the appropriate headers and take the appropriate actions.</source>
          <target state="translated">一个设置测试的便捷方法。调用它,Test::Builder将打印适当的标题并采取适当的行动。</target>
        </trans-unit>
        <trans-unit id="d87e8f492879ce02bf236daf94692483d0fd4b5c" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . This implementation doesn't allow arbitrary inheritance.</source>
          <target state="translated">一种常规（不是由内而外）的实现，其中对象是存储字段值的 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; ，而不受Hash :: Util :: FieldHash的支持。此实现不允许任意继承。</target>
        </trans-unit>
        <trans-unit id="e03c6ee9246ced2486b144fcb4c37588f21f6f7f" translate="yes" xml:space="preserve">
          <source>A conventional (not inside-out) implementation where an object is a hash that stores the field values, without support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt;. This implementation doesn't allow arbitrary inheritance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646b8162acfbdd090f426555f4c9a32ee73eeb01" translate="yes" xml:space="preserve">
          <source>A copy of IO::Scalar for Test::Builder</source>
          <target state="translated">Test::Builder的IO::Scalar副本。</target>
        </trans-unit>
        <trans-unit id="5a070156d8ac581b1ec13fda608b6d3f5d95a087" translate="yes" xml:space="preserve">
          <source>A copy of a Win* viewer is contained in the &quot;Just add OS/2 Warp&quot; package</source>
          <target state="translated">在 &quot;只需添加OS/2 Warp &quot;软件包中包含一个Win*查看器的副本。</target>
        </trans-unit>
        <trans-unit id="6e407ab7758af4150015ce0b8baf63576cf02a27" translate="yes" xml:space="preserve">
          <source>A copyright notice - see below.</source>
          <target state="translated">版权声明 ----见下文。</target>
        </trans-unit>
        <trans-unit id="d687cc7b81ffa630de399555f3a224dda7b56cfa" translate="yes" xml:space="preserve">
          <source>A correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using</source>
          <target state="translated">正确的CPAN版本号是一个小数点后至少有2位的浮点数。您可以通过以下方法测试它是否符合CPAN</target>
        </trans-unit>
        <trans-unit id="8295d6831975ca50ed9530db07dca19a25c715be" translate="yes" xml:space="preserve">
          <source>A count passed to Tpad to modify the padding applied to the output string. If $cnt is zero or one then the resulting string will be cached.</source>
          <target state="translated">传递给Tpad的一个计数,用于修改应用于输出字符串的padding。如果$cnt为0或1,那么输出的字符串将被缓存。</target>
        </trans-unit>
        <trans-unit id="3ca2814f3e720b9b1b346f0c76354ef75ff06f2d" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc中&lt;/a&gt;可以找到Perl联机帮助集的原始目录。</target>
        </trans-unit>
        <trans-unit id="2162bc552d862ed6307a58382e17717e6d290a61" translate="yes" xml:space="preserve">
          <source>A crude table of contents for the Perl manpage set is found in &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03adc2f14ebb3d0a7a9ba21528d13d42030133f9" translate="yes" xml:space="preserve">
          <source>A data debugging tool for the XS programmer</source>
          <target state="translated">XS程序员的数据调试工具。</target>
        </trans-unit>
        <trans-unit id="07e1664c3b50241d29a1670852c2daa101e50db7" translate="yes" xml:space="preserve">
          <source>A data repository. Instead of computing expensive answers several times, compute it once and save the result.</source>
          <target state="translated">一个数据仓库。与其多次计算昂贵的答案,不如计算一次并保存结果。</target>
        </trans-unit>
        <trans-unit id="40b9a92df275c1cef5fb6a4e3d00cf2b3d4203b3" translate="yes" xml:space="preserve">
          <source>A data structure used internally by Perl for implementing associative arrays (hashes) efficiently. See also &lt;b&gt;bucket&lt;/b&gt;.</source>
          <target state="translated">Perl内部使用的一种数据结构，用于有效地实现关联数组（哈希）。另请参见&lt;b&gt;bucket&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b6431d472e1b30028a75ba55229126e2e191ae3c" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="translated">声明可以放在语句可以放置的任何位置，但对语句的主要顺序的执行没有影响：声明全部在编译时生效。通常将所有声明放在脚本的开头或结尾。但是，如果您使用的是用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; 创建的词法范围私有变量，则必须确保格式或子例程定义与my处于同一块范围内，如果您希望能够访问那些私有变量。</target>
        </trans-unit>
        <trans-unit id="07181764640c06f85b9c3b200709c9c9e50a1f77" translate="yes" xml:space="preserve">
          <source>A declaration can be put anywhere a statement can, but has no effect on the execution of the primary sequence of statements: declarations all take effect at compile time. All declarations are typically put at the beginning or the end of the script. However, if you're using lexically-scoped private variables created with &lt;code&gt;my()&lt;/code&gt;, &lt;code&gt;state()&lt;/code&gt;, or &lt;code&gt;our()&lt;/code&gt;, you'll have to make sure your format or subroutine definition is within the same block scope as the my if you expect to be able to access those private variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753d1d91d799e4e070ffae305c67c5e3d698281a" translate="yes" xml:space="preserve">
          <source>A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have &lt;b&gt;DB_File&lt;/b&gt; use it instead.</source>
          <target state="translated">Berkeley DB中内置了适用于大多数应用程序的默认哈希算法。如果确实需要使用自己的哈希算法，则可以在Perl中编写自己的哈希算法，并使用&lt;b&gt;DB_File&lt;/b&gt;代替。</target>
        </trans-unit>
        <trans-unit id="b9828da4e803d376a194bd30931557a328ae046c" translate="yes" xml:space="preserve">
          <source>A default site INSTALL.SKIP may be provided by setting then environment variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a distribution specific INSTALL.SKIP. If the environment variable EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be performed.</source>
          <target state="translated">可以通过设置环境变量EU_INSTALL_SITE_SKIPFILE来提供一个默认的INSTALL.SKIP站点,这只有在没有特定的INSTALL.SKIP发行版时才会被使用,如果环境变量EU_INSTALL_IGNORE_SKIP为true,那么就不会进行安装文件过滤。如果环境变量EU_INSTALL_IGNORE_SKIP为true,那么将不执行安装文件过滤。</target>
        </trans-unit>
        <trans-unit id="0e649d4a2c7d23eccbd6705217dd0baed80106ea" translate="yes" xml:space="preserve">
          <source>A deferred action like this:</source>
          <target state="translated">这样的推迟行动。</target>
        </trans-unit>
        <trans-unit id="3f6d365313b0491e7a9d65439f28a847ca8b2399" translate="yes" xml:space="preserve">
          <source>A deprecated property may also be stabilized, but this fact is not shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb6a6e39c30f33cc261f9965991eae25b915199" translate="yes" xml:space="preserve">
          <source>A deprecated property may be made unavailable in a future Perl version, so it is best to move away from them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b7b32d1f43857ac978062d5529fcaa75b008c1" translate="yes" xml:space="preserve">
          <source>A description of how C types may be transformed to and from Perl types within an &lt;b&gt;extension&lt;/b&gt; module written in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">在&lt;b&gt;XS&lt;/b&gt;编写的&lt;b&gt;扩展&lt;/b&gt;模块中，如何将C类型转换为Perl类型以及从Perl类型转换为C的描述。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="152e62c7af6a3030011c43a7ed3a060f156647cc" translate="yes" xml:space="preserve">
          <source>A description of the callable function in each module</source>
          <target state="translated">每个模块中可调用函数的说明。</target>
        </trans-unit>
        <trans-unit id="a361777f63c2dac8a5f187498445ea69ff2e5fd2" translate="yes" xml:space="preserve">
          <source>A description of the module/package/extension etc.</source>
          <target state="translated">模块/包件/扩展等的说明;</target>
        </trans-unit>
        <trans-unit id="2d3ff2a56a13511ba72ba40a6fa6a2c401a75cdb" translate="yes" xml:space="preserve">
          <source>A detailed document on Encode and PerlIO</source>
          <target state="translated">关于Encode和PerlIO的详细文档</target>
        </trans-unit>
        <trans-unit id="6acb6151fda2f69cbd4a7ea5c8537d8c57875e5a" translate="yes" xml:space="preserve">
          <source>A device you can put things on the top of, and later take them back off in the opposite order in which you put them on. See &lt;b&gt;LIFO&lt;/b&gt;.</source>
          <target state="translated">您可以将设备放在上面的设备，然后以相反的顺序将它们取下。参见&lt;b&gt;LIFO&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ce6d3879a0b885e4f02b96959f6d870d8f5b1fa8" translate="yes" xml:space="preserve">
          <source>A different approach is to autoload seldom-used Perl code. See the AutoSplit and AutoLoader modules in the standard distribution for that. Or you could locate the bottleneck and think about writing just that part in C, the way we used to take bottlenecks in C code and write them in assembler. Similar to rewriting in C, modules that have critical sections can be written in C (for instance, the PDL module from CPAN).</source>
          <target state="translated">另一种方法是自动加载很少使用的Perl代码。参见标准发行版中的 AutoSplit 和 AutoLoader 模块。或者你可以找到瓶颈,然后考虑只用C语言写那部分,就像我们以前把C代码中的瓶颈用汇编器写出来一样。与用C语言重写类似,有关键部分的模块也可以用C语言写(比如CPAN的PDL模块)。</target>
        </trans-unit>
        <trans-unit id="fd02787c52da0901c066d4ccff09232fd888e22e" translate="yes" xml:space="preserve">
          <source>A different type of portability issue arises when writing XS code: availability of a C compiler on the end-user's system. C brings with it its own portability issues, and writing XS code will expose you to some of those. Writing purely in Perl is an easier way to achieve portability.</source>
          <target state="translated">在编写XS代码时,会出现另一种类型的可移植性问题:终端用户系统上是否有C编译器。C语言会带来它自己的可移植性问题,而编写XS代码会让你面临其中的一些问题。纯粹用Perl编写是实现可移植性的一个比较简单的方法。</target>
        </trans-unit>
        <trans-unit id="7549e9114a09a619af3acd4b50c3c4a53ce35871" translate="yes" xml:space="preserve">
          <source>A direct &lt;b&gt;connection&lt;/b&gt; that carries the output of one &lt;b&gt;process&lt;/b&gt; to the input of another without an intermediate temporary file. Once the pipe is set up, the two processes in question can read and write as if they were talking to a normal file, with some caveats.</source>
          <target state="translated">直接&lt;b&gt;连接&lt;/b&gt;，将一个&lt;b&gt;过程&lt;/b&gt;的输出传递到另一个&lt;b&gt;过程&lt;/b&gt;的输入，而无需中间临时文件。设置好管道之后，有两个注意事项，有问题的两个进程可以像对待普通文件一样进行读写。</target>
        </trans-unit>
        <trans-unit id="4b845b5f598804539b9d3429d1e0dde292769ef5" translate="yes" xml:space="preserve">
          <source>A distribution of modules to handle locale codes</source>
          <target state="translated">处理区域代码的模块分布</target>
        </trans-unit>
        <trans-unit id="36dbba4844dbb20711f751da227a18044b073c86" translate="yes" xml:space="preserve">
          <source>A distribution's original author is usually the contact listed within this field. Co-maintainers, successor maintainers or mailing lists devoted to the distribution may also be listed in addition to or instead of the original author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e6b7ccc64e5147f1acc2484c6d3b919c5bc2282" translate="yes" xml:space="preserve">
          <source>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there's a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</source>
          <target state="translated">一个文档有一个以上的&quot;=encoding &quot;行应被视为一个错误。如果不是第一行的&quot;=encoding &quot;只是第一行的重复,Pod处理器可能会默默地容忍这一点(例如,如果有一个&quot;=encoding utf8 &quot;行,后来又有一个&quot;=encoding utf8 &quot;行)。但是,如果在同一个文档中出现了矛盾的&quot;=编码 &quot;行,Pod处理器应该抱怨(例如,如果在文档的早期有一个&quot;=编码utf8&quot;,而后面有一个&quot;=编码big5&quot;)。识别BOM的花苞处理器如果看到与BOM相矛盾的&quot;=编码 &quot;行,也可能会抱怨(例如,如果一个UTF-16LE BOM的文档有&quot;=编码shiftjis &quot;行)。</target>
        </trans-unit>
        <trans-unit id="4df78e410296e2b3f4b712de1ae484fe7cd130b2" translate="yes" xml:space="preserve">
          <source>A document type tag for the file. This option is not set by default.</source>
          <target state="translated">文件的文件类型标签。默认情况下不设置此选项。</target>
        </trans-unit>
        <trans-unit id="d80c6e485dc27886043d9d72950290e87158018b" translate="yes" xml:space="preserve">
          <source>A domain of names. You needn&amp;rsquo;t worry about whether the names in one such domain have been used in another. See &lt;b&gt;package&lt;/b&gt;.</source>
          <target state="translated">名称域。您不必担心一个域中的名称是否已在另一个域中使用。参见&lt;b&gt;package&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7598f11ff5b1103678a9d5639c3dfc75e6d4a5e6" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt; .</source>
          <target state="translated">双精度浮点数。此类型映射保证将变量强制转换为 &lt;code&gt;double&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f284c3eb8e2f99c285a6237d4bc92dc027b78cd" translate="yes" xml:space="preserve">
          <source>A double precision floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102050331265d60ae1056cdc3a0d24fd9e06376e" translate="yes" xml:space="preserve">
          <source>A double-quoted, interpolated string.</source>
          <target state="translated">一个双引号、插值的字符串。</target>
        </trans-unit>
        <trans-unit id="faeb399a5d08eaa739b873af03a2a402dd907834" translate="yes" xml:space="preserve">
          <source>A dummy layer which never exists on the layer stack. Instead when &quot;pushed&quot; it actually pops the stack removing itself, it then calls Binmode function table entry on all the layers in the stack - normally this (via PerlIOBase_binmode) removes any layers which do not have &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; bit set. Layers can modify that behaviour by defining their own Binmode entry.</source>
          <target state="translated">在层堆栈上永远不存在的虚拟层。取而代之的是，当&amp;ldquo;推&amp;rdquo;它实际上弹出堆栈时，它会自己删除，然后在堆栈中的所有层上调用Binmode函数表条目-通常，这（通过PerlIOBase_binmode）会删除任何未设置 &lt;code&gt;PERLIO_K_RAW&lt;/code&gt; 位的层。图层可以通过定义自己的Binmode条目来修改该行为。</target>
        </trans-unit>
        <trans-unit id="f90a52847d42c09984d572f3b595cda347017f00" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regex/gc&lt;/code&gt; .</source>
          <target state="translated">匹配失败或更改目标字符串将重置位置。如果您不希望在匹配失败后重置位置，请添加 &lt;code&gt;//c&lt;/code&gt; ，如 &lt;code&gt;/regex/gc&lt;/code&gt; 所示。</target>
        </trans-unit>
        <trans-unit id="d5efee2d4f79d8ba35cf758e77756920ee770903" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;//c&lt;/code&gt; , as in &lt;code&gt;/regexp/gc&lt;/code&gt; . The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="translated">匹配失败或更改目标字符串将重置位置。如果您不希望在匹配失败后重置位置，请添加 &lt;code&gt;//c&lt;/code&gt; ，如 &lt;code&gt;/regexp/gc&lt;/code&gt; 所示。字符串中的当前位置与字符串关联，而不与regexp关联。这意味着不同的字符串具有不同的位置，并且它们各自的位置可以独立设置或读取。</target>
        </trans-unit>
        <trans-unit id="7f27a18129c02d053ab6f802e18b05e35c62f037" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regex/gc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67a945b29a3d1fe6def81e71ffaffd29e4c4803" translate="yes" xml:space="preserve">
          <source>A failed match or changing the target string resets the position. If you don't want the position reset after failure to match, add the &lt;code&gt;/c&lt;/code&gt;, as in &lt;code&gt;/regexp/gc&lt;/code&gt;. The current position in the string is associated with the string, not the regexp. This means that different strings have different positions and their respective positions can be set or read independently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656a7d55b2753fa751b87d85db4a4654a61963c4" translate="yes" xml:space="preserve">
          <source>A fairly common feature in applications is to allow you to define a C function that will be called whenever something nasty occurs. What we would like is to be able to specify a Perl subroutine that will be called instead.</source>
          <target state="translated">在应用程序中,一个相当常见的功能是允许你定义一个C函数,每当发生一些令人讨厌的事情时就会被调用。我们希望能够指定一个Perl子程序来代替调用。</target>
        </trans-unit>
        <trans-unit id="4373b47dc81d066ae69b5e362fdbfdc644e26aed" translate="yes" xml:space="preserve">
          <source>A fairly common use-case is where compressed data is embedded in a larger file/buffer and you want to read both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e23193c87a7c196063bf7501e9b39457a40a9ece" translate="yes" xml:space="preserve">
          <source>A faithful representation of the value used to initialize this version object. The only time this will not be precisely the same characters that exist in the source file is if a short dotted-decimal version like v1.2 was used (in which case it will contain 'v1.2'). This form is &lt;b&gt;STRONGLY&lt;/b&gt; discouraged, in that it will confuse you and your users.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145432bffd79619206143de90cf2e154ae94a2c3" translate="yes" xml:space="preserve">
          <source>A false value, in scalar context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27669facce8e75680a82515ceb4a7dde4554488" translate="yes" xml:space="preserve">
          <source>A fancy computer science term meaning &amp;ldquo;to follow a &lt;b&gt;reference&lt;/b&gt; to what it points to&amp;rdquo;. The &amp;ldquo;de&amp;rdquo; part of it refers to the fact that you&amp;rsquo;re taking away one level of &lt;b&gt;indirection&lt;/b&gt;.</source>
          <target state="translated">奇特的计算机科学术语，意为&amp;ldquo;遵循对其所指内容的&lt;b&gt;引用&lt;/b&gt; &amp;rdquo;。它的&amp;ldquo; de&amp;rdquo;部分是指您正在剥夺一个&lt;b&gt;间接&lt;/b&gt;层的事实。</target>
        </trans-unit>
        <trans-unit id="8f4dde098cc45c330d3e8fa85a502fc0eae6cde3" translate="yes" xml:space="preserve">
          <source>A fancy kind of interlock that prevents multiple &lt;b&gt;threads&lt;/b&gt; or &lt;b&gt;processes&lt;/b&gt; from using up the same resources simultaneously.</source>
          <target state="translated">一种奇特的互锁，可防止多个&lt;b&gt;线程&lt;/b&gt;或&lt;b&gt;进程&lt;/b&gt;同时用完相同的资源。</target>
        </trans-unit>
        <trans-unit id="2f52178a4e9cc243237404e962bb98cf1d11d03e" translate="yes" xml:space="preserve">
          <source>A fancy term for an error. See &lt;b&gt;fatal error&lt;/b&gt;.</source>
          <target state="translated">一个错误的花哨术语。看到&lt;b&gt;致命错误&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d130552cd3247973054cf88d786bc01b68b3a6e5" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if the Compress::Zlib module is not available.</source>
          <target state="translated">如果 Compress::Zlib 模块不可用,将会产生一个致命的错误。</target>
        </trans-unit>
        <trans-unit id="c1f172aa731045204a1719d56bb2cc8625060274" translate="yes" xml:space="preserve">
          <source>A fatal error will be thrown if:</source>
          <target state="translated">如果出现以下情况,将引发一个致命的错误:</target>
        </trans-unit>
        <trans-unit id="206dcfa56d21a53d3ca90835f2da1335f0ce9141" translate="yes" xml:space="preserve">
          <source>A feature of &lt;b&gt;operator overloading&lt;/b&gt; of &lt;b&gt;objects&lt;/b&gt;, whereby the behavior of certain &lt;b&gt;operators&lt;/b&gt; can be reasonably deduced using more fundamental operators. This assumes that the overloaded operators will often have the same relationships as the regular operators. See Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;对象&lt;/b&gt;的&lt;b&gt;运算符重载&lt;/b&gt;的特征，从而可以使用更基本的运算符来合理地推导出某些&lt;b&gt;运算符&lt;/b&gt;的行为。假设重载运算符通常与常规运算符具有相同的关系。请参见骆驼第13章，&amp;ldquo;过载&amp;rdquo;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="96f7456dc10c0f5e5c69de568de641b9d361467e" translate="yes" xml:space="preserve">
          <source>A few dir-vs-file optimizations result in glob importation being 10 times faster than using perlglob.exe, and using perlglob.bat is only twice as slow as perlglob.exe (GSAR 28-MAY-97)</source>
          <target state="translated">通过对dir-vs-file的优化,glob导入比使用perlglob.exe快10倍,而使用perlglob.bat只比perlglob.exe慢两倍(GSAR 28-MAY-97)</target>
        </trans-unit>
        <trans-unit id="29b977997a9e174d5b0509df5c6aa92021e1d1e4" translate="yes" xml:space="preserve">
          <source>A few example globmaps</source>
          <target state="translated">一些示例性的globmaps</target>
        </trans-unit>
        <trans-unit id="4079515a56f3376aa599af18d3ce02d4fa762708" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &quot;.</source>
          <target state="translated">由于它们是C特定的，因此未实现某些功能。如果您尝试调用它们，它们将打印一条消息，告诉您它们尚未实现，并建议使用等效的Perl。例如，尝试访问 &lt;code&gt;setjmp()&lt;/code&gt; 调用将引发消息&amp;ldquo; &lt;code&gt;setjmp() is C-specific: &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {} instead&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a9aa66452d6cc33fe8925436987e0f746352b862" translate="yes" xml:space="preserve">
          <source>A few functions are not implemented because they are C specific. If you attempt to call these, they will print a message telling you that they aren't implemented, and suggest using the Perl equivalent, should one exist. For example, trying to access the &lt;code&gt;setjmp()&lt;/code&gt; call will elicit the message &quot;&lt;code&gt;setjmp() is C-specific: use eval {} instead&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0bccac60c0333be23e859b75e6846e6cbff2f2" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;a href=&quot;#time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#endpwent&quot;&gt;&lt;code&gt;endpwent&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;time+86_400&lt;/code&gt; always means &lt;code&gt;time() + 86_400&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd9feea0227978a722652bf64b2da3e239d9119" translate="yes" xml:space="preserve">
          <source>A few functions take no arguments at all, and therefore work as neither unary nor list operators. These include such functions as &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt;. For example, &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; always means &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; .</source>
          <target state="translated">一些函数根本不带参数，因此既不是一元运算符也不是列表运算符。这些功能包括 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/endpwent&quot;&gt;endpwent&lt;/a&gt;&lt;/code&gt; 时间。例如， &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time+86_400&lt;/a&gt;&lt;/code&gt; 始终表示 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;() + 86_400&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d4ec4509605bbb34d201f389b34f426f595148" translate="yes" xml:space="preserve">
          <source>A few general-purpose tools are shipped with perl, mostly because they came along modules included in the perl distribution.</source>
          <target state="translated">一些通用的工具是随perl一起发布的,主要是因为它们在perl发行版中附带了模块。</target>
        </trans-unit>
        <trans-unit id="6c69ec260ad056301204f0c643b8c2696665eb7e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="translated">提供了一些方法来帮助 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; Your::Module tests =&amp;gt; 23&lt;/code&gt; &lt;a href=&quot;../../functions/use&quot;&gt;使用&lt;/a&gt; Your :: Module tests =&amp;gt; 23部分。</target>
        </trans-unit>
        <trans-unit id="8472b15b35050b2df3090f934f689efe2217997e" translate="yes" xml:space="preserve">
          <source>A few methods are provided to do the &lt;code&gt;use Your::Module tests =&amp;gt; 23&lt;/code&gt; part for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6d4c905f963b3015f8686516337be08979225b" translate="yes" xml:space="preserve">
          <source>A few more:</source>
          <target state="translated">还有一些。</target>
        </trans-unit>
        <trans-unit id="f6dd53866881999d8a6a377532c2c8626c21bab7" translate="yes" xml:space="preserve">
          <source>A few of the entries in the list below are marked as DEPRECATED. You should not use these for new code, and should be converting existing uses to use something better.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb9b3626d6aeb9e84350d1131ed3080f1617e37" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="translated">这里有一些选项需要额外讨论。使用时，键H的C等效项 &lt;code&gt;hash&lt;/code&gt; ， &lt;code&gt;compare&lt;/code&gt; 和 &lt;code&gt;prefix&lt;/code&gt; 存储指向C函数的指针。在&lt;b&gt;DB_File中，&lt;/b&gt;这些键用于存储对Perl子对象的引用。以下是每个子模块的模板：</target>
        </trans-unit>
        <trans-unit id="492f5e2fcdceaa8c5ab146c091e30572e3a68f3d" translate="yes" xml:space="preserve">
          <source>A few of the options need extra discussion here. When used, the C equivalent of the keys &lt;code&gt;hash&lt;/code&gt;, &lt;code&gt;compare&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; store pointers to C functions. In &lt;b&gt;DB_File&lt;/b&gt; these keys are used to store references to Perl subs. Below are templates for each of the subs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c283830e9199de7049f4c9e9b8481f0f4f024e4c" translate="yes" xml:space="preserve">
          <source>A few of these variables are considered &quot;read-only&quot;. This means that if you try to assign to this variable, either directly or indirectly through a reference, you'll raise a run-time exception.</source>
          <target state="translated">其中有几个变量被认为是 &quot;只读 &quot;变量。这意味着,如果你试图直接或通过引用间接地分配给这个变量,你会引发一个运行时异常。</target>
        </trans-unit>
        <trans-unit id="8090aa705fafbfcbe40caa6a39d4969f2ffa75f0" translate="yes" xml:space="preserve">
          <source>A few points to note about this example:</source>
          <target state="translated">关于这个例子,有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="5940abb3e966e0e3ab0e5074976963a86d9bf337" translate="yes" xml:space="preserve">
          <source>A few special SV heads are not allocated from an arena, but are instead directly created in the interpreter structure, eg PL_sv_undef. The size of arenas can be changed from the default by setting PERL_ARENA_SIZE appropriately at compile time.</source>
          <target state="translated">一些特殊的SV头不是从竞技场中分配的,而是直接在解释器结构中创建的,例如PL_sv_undef。竞技场的大小可以通过在编译时适当地设置PERL_ARENA_SIZE来改变默认值。</target>
        </trans-unit>
        <trans-unit id="99bc1dc13c67f6154f44d88464d4083e5ca5c87d" translate="yes" xml:space="preserve">
          <source>A fifo is convenient when you want to connect a process to an unrelated one. When you open a fifo, the program will block until there's something on the other end.</source>
          <target state="translated">当你想把一个进程和一个不相关的进程连接起来的时候,一个fifo是很方便的。当你打开一个fifo时,程序会阻塞,直到另一端有东西。</target>
        </trans-unit>
        <trans-unit id="0034cae2f50c204559522cfff1ceebd6deb989fa" translate="yes" xml:space="preserve">
          <source>A file containing certain required definitions that you must include &amp;ldquo;ahead&amp;rdquo; of the rest of your program to do certain obscure operations. A C header file has a</source>
          <target state="translated">包含某些必需定义的文件，您必须在程序的其余部分之前&amp;ldquo;包含&amp;rdquo;某些特定的定义才能进行某些晦涩的操作。AC标头文件有一个</target>
        </trans-unit>
        <trans-unit id="731000aad647991373ca7dfb79bf96ee23280bc2" translate="yes" xml:space="preserve">
          <source>A file full of regular expressions to exclude when using 'make manifest' to generate the MANIFEST. These regular expressions are checked against each file path found in the distribution (so you're matching against &quot;t/foo.t&quot; not &quot;foo.t&quot;).</source>
          <target state="translated">当使用'make manifest'生成manifest时,需要排除的正则表达式的文件。这些正则表达式会根据发行版中找到的每个文件路径进行检查(所以你要匹配的是 &quot;t/foo.t &quot;而不是 &quot;foo.t&quot;)。</target>
        </trans-unit>
        <trans-unit id="a17865a45ecaf1ad63bbdbb5dd8742ba69a071dc" translate="yes" xml:space="preserve">
          <source>A file in XS format starts with a C language section which goes until the first &lt;code&gt;MODULE =&lt;/code&gt; directive. Other XS directives and XSUB definitions may follow this line. The &quot;language&quot; used in this part of the file is usually referred to as the XS language. &lt;b&gt;xsubpp&lt;/b&gt; recognizes and skips POD (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) in both the C and XS language sections, which allows the XS file to contain embedded documentation.</source>
          <target state="translated">XS格式的文件以C语言部分开头，直到第一个 &lt;code&gt;MODULE =&lt;/code&gt; 指令为止。其他XS指令和XSUB定义可能会遵循此行。在文件的此部分中使用的&amp;ldquo;语言&amp;rdquo;通常称为XS语言。&lt;b&gt;xsubpp可以&lt;/b&gt;识别和跳过C和XS语言部分中的POD（请参阅&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;），这允许XS文件包含嵌入式文档。</target>
        </trans-unit>
        <trans-unit id="ef34906ac9f2871761f209af13c79ffbe88cb8f1" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;, except for &lt;code&gt;-t&lt;/code&gt;, which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno). With the exception of the &lt;code&gt;-l&lt;/code&gt; test they all follow symbolic links because they use &lt;code&gt;stat()&lt;/code&gt; and not &lt;code&gt;lstat()&lt;/code&gt; (so dangling symlinks can't be examined and will therefore report failure).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51841b4270c479a7cdbc29c3d5f66446edf393a3" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">文件测试，其中X是下面列出的字母之一。此一元运算符采用一个参数（文件名，文件句柄或目录句柄），并测试关联的文件以查看其是否正确。如果省略该参数，则测试 &lt;code&gt;$_&lt;/code&gt; ，但 &lt;code&gt;-t&lt;/code&gt; 除外，后者测试STDIN。除非另有说明，否则它返回 &lt;code&gt;1&lt;/code&gt; 表示true，返回 &lt;code&gt;''&lt;/code&gt; 表示false。如果该文件不存在或无法检查，它将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。尽管名称很有趣，但优先级与任何其他命名的一元运算符相同。运营商可以是以下任何一家：</target>
        </trans-unit>
        <trans-unit id="1c04b0088e704fdeb38d1fecd8838e16e9a29f09" translate="yes" xml:space="preserve">
          <source>A file test, where X is one of the letters listed below. This unary operator takes one argument, either a filename, a filehandle, or a dirhandle, and tests the associated file to see if something is true about it. If the argument is omitted, tests &lt;code&gt;$_&lt;/code&gt; , except for &lt;code&gt;-t&lt;/code&gt; , which tests STDIN. Unless otherwise documented, it returns &lt;code&gt;1&lt;/code&gt; for true and &lt;code&gt;''&lt;/code&gt; for false. If the file doesn't exist or can't be examined, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Despite the funny names, precedence is the same as any other named unary operator. The operator may be any of:</source>
          <target state="translated">文件测试，其中X是下面列出的字母之一。此一元运算符采用一个参数（文件名，文件句柄或目录句柄），并测试关联的文件以查看其是否正确。如果省略该参数，则测试 &lt;code&gt;$_&lt;/code&gt; ，但 &lt;code&gt;-t&lt;/code&gt; 除外，后者测试STDIN。除非另有说明，否则它返回 &lt;code&gt;1&lt;/code&gt; 表示true，返回 &lt;code&gt;''&lt;/code&gt; 表示false。如果该文件不存在或无法检查，它将返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。尽管名称很有趣，但优先级与任何其他命名的一元运算符相同。运营商可以是以下任何一家：</target>
        </trans-unit>
        <trans-unit id="85304934df21007f1e6dacead79952e515167d3e" translate="yes" xml:space="preserve">
          <source>A file that controls the compilation of a program. Perl programs don&amp;rsquo;t usually need a &lt;b&gt;Makefile&lt;/b&gt; because the Perl compiler has plenty of self-control.</source>
          <target state="translated">控制程序编译的文件。Perl程序通常不需要&lt;b&gt;Makefile，&lt;/b&gt;因为Perl编译器具有很多自我控制功能。</target>
        </trans-unit>
        <trans-unit id="9c91c447fc7873fa1590ab524304262f61375872" translate="yes" xml:space="preserve">
          <source>A filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ef0646f1946010fd71391d670cdd7f3f2cde9ba" translate="yes" xml:space="preserve">
          <source>A filehandle for catching standard output.</source>
          <target state="translated">一个用于捕获标准输出的文件柄。</target>
        </trans-unit>
        <trans-unit id="dddbea875ae221e63e546196812256d3f13f54a9" translate="yes" xml:space="preserve">
          <source>A filehandle is opened but the file operations are performed &quot;in-memory&quot; on a scalar variable. All the normal file operations can be performed on the handle. The scalar is considered a stream of bytes. Currently fileno($fh) returns -1.</source>
          <target state="translated">一个文件柄被打开,但文件操作是在一个标量变量上 &quot;在内存中 &quot;进行的。所有正常的文件操作都可以在句柄上进行。标量被认为是一个字节流,目前fileno($fh)返回-1。目前fileno($fh)返回-1。</target>
        </trans-unit>
        <trans-unit id="2ead9b8d6ddfb62275b7ebf2bc90be0c9e8b9ced" translate="yes" xml:space="preserve">
          <source>A filehandle that should read or write UTF-8</source>
          <target state="translated">一个应读或写UTF-8的文件柄。</target>
        </trans-unit>
        <trans-unit id="c2227149e71cd22222d8c43a50c19d04660c6c2c" translate="yes" xml:space="preserve">
          <source>A filehandle to write the C code to. If not given, then</source>
          <target state="translated">一个要写入C代码的文件柄。如果没有给定,那么</target>
        </trans-unit>
        <trans-unit id="51118efef78727e7eccbadc9f314bd7f4afcf597" translate="yes" xml:space="preserve">
          <source>A filehandle to write the XS code to. If not given, then</source>
          <target state="translated">一个要写入XS代码的文件柄。如果没有给定,那么</target>
        </trans-unit>
        <trans-unit id="94e7ed7be4ff1750888b6ea45dc5effd2b37d94d" translate="yes" xml:space="preserve">
          <source>A filehandle, from which the file will be read.</source>
          <target state="translated">一个文件柄,从这里读取文件。</target>
        </trans-unit>
        <trans-unit id="7c79e2e3cdb811630721119bd1fda8fa5ffcd8fa" translate="yes" xml:space="preserve">
          <source>A filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c34303a3b313a718df7cf274a0efcf1c25994c0c" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-A&lt;/code&gt; , and &lt;code&gt;-C&lt;/code&gt; , as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="translated">一个filetest运算符，有4个例外： &lt;code&gt;-s&lt;/code&gt; ， &lt;code&gt;-M&lt;/code&gt; ， &lt;code&gt;-A&lt;/code&gt; 和 &lt;code&gt;-C&lt;/code&gt; ，因为它们返回数值，而不是布尔值。该 &lt;code&gt;-z&lt;/code&gt; filetest操作不包含在例外列表中。</target>
        </trans-unit>
        <trans-unit id="f4fe6298165162f938688f8a2c671c5d42d80d9b" translate="yes" xml:space="preserve">
          <source>A filetest operator, with exactly 4 exceptions: &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-A&lt;/code&gt;, and &lt;code&gt;-C&lt;/code&gt;, as these return numerical values, not boolean ones. The &lt;code&gt;-z&lt;/code&gt; filetest operator is not included in the exception list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571b7a68e22aaaa36cb39947748347ab43ae89aa" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done.</source>
          <target state="translated">一个传统Unix意义上的过滤程序 (输入来自stdin,输出到stdout),在构建过程中(在pm_to_blib()阶段)传递给每个.pm文件。默认情况下它是空的,这意味着没有进行过滤。</target>
        </trans-unit>
        <trans-unit id="f1bffd13ce3099184de722f73a1304bb3285fcc2" translate="yes" xml:space="preserve">
          <source>A filter program, in the traditional Unix sense (input from stdin, output to stdout) that is passed on each .pm file during the build (in the pm_to_blib() phase). It is empty by default, meaning no filtering is done. You could use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb35ae131a8a2012ab4bde2210fbfdcbd7023aa3" translate="yes" xml:space="preserve">
          <source>A fix for Proc::ProcessTable is to edit Makefile to explicitly remove the largefile flags from the ones MakeMaker picks up from Config.pm. This will result in Proc::ProcessTable being built under the correct environment. Everything should then be OK as long as Proc::ProcessTable doesn't try to share off_t's with the rest of perl, or if it does they should be explicitly specified as off64_t.</source>
          <target state="translated">对Proc::ProcessTable的修正是编辑Makefile,明确地从MakeMaker从Config.pm中获取的大文件标志中删除。这将导致 Proc::ProcessTable 在正确的环境下构建。只要 Proc::ProcessTable 不试图与 perl 的其它部分共享 off_t,一切都应该是正常的,如果要共享 off_t,则应该将其明确指定为 off64_t。</target>
        </trans-unit>
        <trans-unit id="a9d22545c3578b64eb5fa290d40cfb8cd3124e35" translate="yes" xml:space="preserve">
          <source>A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:</source>
          <target state="translated">该问题的修复计划在以下级别的AIX中发布,所有这些版本都将在2009年第四季度推出。</target>
        </trans-unit>
        <trans-unit id="42701417421c1ef72d52e9b7e2d8ce1f61f1f95a" translate="yes" xml:space="preserve">
          <source>A fixed hard disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcd311c30c802b9eee4a011f2523c74bbb4eeb7" translate="yes" xml:space="preserve">
          <source>A fixed length thing, given as a [pointer, length] pair. If you know the length of a string at compile time you may use this instead of</source>
          <target state="translated">一个固定长度的东西,以[指针,长度]对的形式给出。如果你在编译时知道一个字符串的长度,你可以用这个来代替</target>
        </trans-unit>
        <trans-unit id="2dd9070969808d13493b31f8533aee2df5f82471" translate="yes" xml:space="preserve">
          <source>A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &amp;lt; 0, when the digits after the decimal point are zero.</source>
          <target state="translated">小数点前（正）或后（负）的固定位数。例如，123.45的精度为-2。0表示整数，例如123（或120）。精度2表示小数点左边的两位数字为零，因此P = 1的123变为120。请注意，小数点前带有零的数字可能具有不同的精度，因为1200可以具有p = 0、1或2（取决于初始值）。当小数点后的数字为零时，它也可能具有p &amp;lt;0。</target>
        </trans-unit>
        <trans-unit id="27aa36567c7de687c1256c668f8713e83fe0a789" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;&lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt;&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="translated">一个标志，指示第3项（如果存在）是否是URL（例如&amp;ldquo; &lt;a href=&quot;http://lists.perl.org&quot;&gt;http://lists.perl.org&lt;/a&gt; &amp;rdquo;），在这种情况下，应该没有section属性；Pod名称（例如&amp;ldquo; perldoc&amp;rdquo;和&amp;ldquo; Getopt :: Std&amp;rdquo;）；或手册页名称（例如&amp;ldquo; crontab（5）&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="106d15351f4a75ec3f2797be6646ec091bf455c8" translate="yes" xml:space="preserve">
          <source>A flag for whether item 3 (if present) is a URL (like &quot;http://lists.perl.org&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa81fd53ffda939e60f21a6a48bc3fd1ecb33421" translate="yes" xml:space="preserve">
          <source>A floating point number potentially has a sign, an integral part, a decimal point, a fractional part, and an exponent. One or more of these parts is optional, so we need to check out the different possibilities. Floating point numbers which are in proper form include 123., 0.345, .34, -1e6, and 25.4E-72. As with integers, the sign out front is completely optional and can be matched by &lt;code&gt;[+-]?&lt;/code&gt;. We can see that if there is no exponent, floating point numbers must have a decimal point, otherwise they are integers. We might be tempted to model these with &lt;code&gt;\d*\.\d*&lt;/code&gt;, but this would also match just a single decimal point, which is not a number. So the three cases of floating point number without exponent are</source>
          <target state="translated">浮点数可能具有符号，整数部分，小数点，小数部分和指数。这些部分中的一个或多个是可选的，因此我们需要检查各种可能性。正确形式的浮点数包括123.，0.345，.34，-1e6和25.4E-72。与整数一样，签出前面完全是可选的，可以由 &lt;code&gt;[+-]?&lt;/code&gt; 匹配吗？。我们可以看到，如果没有指数，则浮点数必须带有小数点，否则为整数。我们可能会想用 &lt;code&gt;\d*\.\d*&lt;/code&gt; 为它们建模，但这也只会匹配一个小数点，而不是数字。因此，没有指数的浮点数的三种情况是</target>
        </trans-unit>
        <trans-unit id="ff8a1f9e295a3b368fdb0bcb2f6682d3f1a7706d" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt; .</source>
          <target state="translated">浮点数。此类型映射保证将变量强制类型转换为 &lt;code&gt;float&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="989e51ade0bc6499f4e6912c535b030573178b2b" translate="yes" xml:space="preserve">
          <source>A floating point number. This typemap guarantees to return a variable cast to a &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032a7b56b1da4c1e8613c276b9cfb6d58696eaf8" translate="yes" xml:space="preserve">
          <source>A floppy diskette drive or other removable media drive, but not a CD-ROM drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb62089bcb14b38f0a60a1ce278c6aa2cfaf6aec" translate="yes" xml:space="preserve">
          <source>A flow of data into or out of a process as a steady sequence of bytes or characters, without the appearance of being broken up into packets. This is a kind of &lt;b&gt;interface&lt;/b&gt;&amp;mdash;the underlying &lt;b&gt;implementation&lt;/b&gt; may well break your data up into separate packets for delivery, but this is hidden from you.</source>
          <target state="translated">数据以稳定的字节或字符序列序列流入或流出进程，而不会被分解为数据包。这是一种&lt;b&gt;接口&lt;/b&gt; -基础&lt;b&gt;实现&lt;/b&gt;可能会将您的数据分解为单独的数据包进行传递，但这对您而言是隐藏的。</target>
        </trans-unit>
        <trans-unit id="e81e65da76994db0744db8c12c18f7cc1632c8c6" translate="yes" xml:space="preserve">
          <source>A fork of &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; that provides version checking in parent class modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f93ab55d0cd5dedac331be7a34ca8ef2c56a43" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt; . Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt; , &lt;code&gt;'NFC'&lt;/code&gt; , &lt;code&gt;'NFKD'&lt;/code&gt; , and &lt;code&gt;'NFKC'&lt;/code&gt; . See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="translated">接受的格式名称 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 将用作 &lt;code&gt;$normalization_form&lt;/code&gt; 。可接受的名称包括 &lt;code&gt;'NFD'&lt;/code&gt; ， &lt;code&gt;'NFC'&lt;/code&gt; ， &lt;code&gt;'NFKD'&lt;/code&gt; 和 &lt;code&gt;'NFKC'&lt;/code&gt; 。有关详细信息，请参见 &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; 。如果省略，则使用 &lt;code&gt;'NFD'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="561ab06d7f47c467c676cc1068bd4564e1083a7b" translate="yes" xml:space="preserve">
          <source>A form name &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; accepts will be applied as &lt;code&gt;$normalization_form&lt;/code&gt;. Acceptable names include &lt;code&gt;'NFD'&lt;/code&gt;, &lt;code&gt;'NFC'&lt;/code&gt;, &lt;code&gt;'NFKD'&lt;/code&gt;, and &lt;code&gt;'NFKC'&lt;/code&gt;. See &lt;code&gt;Unicode::Normalize::normalize()&lt;/code&gt; for detail. If omitted, &lt;code&gt;'NFD'&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49b8a933b39ce175d6f4d01ed275b88dda586c3" translate="yes" xml:space="preserve">
          <source>A form of &lt;b&gt;scalar context&lt;/b&gt; in which an &lt;b&gt;expression&lt;/b&gt; is not expected to return any &lt;b&gt;value&lt;/b&gt; at all and is evaluated for its &lt;b&gt;side effects&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;标量上下文的&lt;/b&gt;一种形式，在该形式中，&lt;b&gt;表达式&lt;/b&gt;完全不希望返回任何&lt;b&gt;值&lt;/b&gt;，并且仅对其&lt;b&gt;副作用&lt;/b&gt;进行评估。</target>
        </trans-unit>
        <trans-unit id="95b8b92c738006a6a5118bef738de47b796e9ea2" translate="yes" xml:space="preserve">
          <source>A formal grammar would look similar to the following:</source>
          <target state="translated">一个正式的语法将类似于以下内容:</target>
        </trans-unit>
        <trans-unit id="721d8611bd61e5ecdf8561b50e0139065e69ec6d" translate="yes" xml:space="preserve">
          <source>A formalized definition of the legal forms for version strings is included in the &lt;code&gt;version::regex&lt;/code&gt; class. Primitives are included for common elements, although they are scoped to the file so they are useful for reference purposes only. There are two publicly accessible scalars that can be used in other code (not exported):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f6424f6bb5e3764fd5434bcd18cd75bdd7582fd" translate="yes" xml:space="preserve">
          <source>A format name of &quot;comment&quot; is common for just making notes (presumably to yourself) that won't appear in any formatted version of the Pod document:</source>
          <target state="translated">&quot;评论 &quot;的格式名称很常见,只是做笔记(大概是给自己的),不会出现在任何格式化的Pod文档版本中。</target>
        </trans-unit>
        <trans-unit id="2446a10134816c33cde7e4a21588ee8f42d4b1d2" translate="yes" xml:space="preserve">
          <source>A formatter can specify by implementing the &lt;code&gt;hide_buffered()&lt;/code&gt; method. If this method returns true then events generated inside a buffered subtest will not be sent independently of the final subtest event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76335714c7e25f79355585f9f9381d9b64c34cd" translate="yes" xml:space="preserve">
          <source>A formatter is any package or object with a &lt;code&gt;write($event, $num)&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26b5fa96c287794c375f977fd86d1fe4bad1833" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&amp;lt;&quot;, any number of characters, and ending with the first matching &quot;&amp;gt;&quot;. Examples:</source>
          <target state="translated">格式代码以大写字母（仅是US-ASCII [AZ]）开头，后跟&amp;ldquo; &amp;lt;&amp;rdquo;，任意数量的字符，并以第一个匹配的&amp;ldquo;&amp;gt;&amp;rdquo;结尾。例子：</target>
        </trans-unit>
        <trans-unit id="e1ebaf29b6e50a9147fa41854529f9f91464bbca" translate="yes" xml:space="preserve">
          <source>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&amp;lt;&quot;'s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&amp;gt;&quot;'s, where the number of &quot;&amp;gt;&quot;'s equals the number of &quot;&amp;lt;&quot;'s in the opening of this formatting code. Examples:</source>
          <target state="translated">格式代码以大写字母（仅US-ASCII [AZ]）开头，后跟两个或多个&amp;ldquo; &amp;lt;&amp;rdquo;，一个或多个空格字符，任意数量的字符，一个或多个空格字符，并以第一个结尾两个或多个&amp;ldquo;&amp;gt;&amp;rdquo;的匹配序列，其中&amp;ldquo;&amp;gt;&amp;rdquo;的数量等于此格式代码开头的&amp;ldquo; &amp;lt;&amp;rdquo;的数量。例子：</target>
        </trans-unit>
        <trans-unit id="ee13838be926e942481224190d1b48d665a53c86" translate="yes" xml:space="preserve">
          <source>A free perl5-based PERL.NLM for Novell Netware is available in precompiled binary and source code form from &lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt; as well as from CPAN.</source>
          <target state="translated">可从&lt;a href=&quot;http://www.novell.com/&quot;&gt;http://www.novell.com/&lt;/a&gt;以及CPAN 以预编译的二进制和源代码形式获得针对Novell Netware的免费的基于Perl5的PERL.NLM 。</target>
        </trans-unit>
        <trans-unit id="3b03ecae28b894e59a1c00c717f1b1e736c5b6b6" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements Perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="601ccb979c895092a89a9db855c8bb290abdfbb7" translate="yes" xml:space="preserve">
          <source>A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &lt;code&gt;sv_gets&lt;/code&gt; which implements perl's readline/&amp;lt;&amp;gt; and in general attempts to minimize data copying.</source>
          <target state="translated">从头开始的PerlIO缓冲实现。提供对 &lt;code&gt;sv_gets&lt;/code&gt; 缓冲区的快速访问，该缓冲区实现了perl的readline / &amp;lt;&amp;gt;，并且通常会尝试最大程度地减少数据复制。</target>
        </trans-unit>
        <trans-unit id="0f062561102eb36fb52de67c711e92bb30c79c71" translate="yes" xml:space="preserve">
          <source>A full commandline to run via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;. During execution, the environment variable PERL is set to $^X (but with an absolute path). If &lt;code&gt;commandline&lt;/code&gt; is specified, &lt;code&gt;args&lt;/code&gt; is not used.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 运行的完整命令行。在执行期间，环境变量PERL设置为$ ^ X（但具有绝对路径）。如果指定了 &lt;code&gt;commandline&lt;/code&gt; ，则不使用 &lt;code&gt;args&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14cec31abd2e629547d353d78977abf26c0ffa5f" translate="yes" xml:space="preserve">
          <source>A full set of HTML documentation is installed, so you should be able to use it if you have a web browser installed on your system.</source>
          <target state="translated">安装了一套完整的HTML文档,所以如果你的系统中安装了Web浏览器,应该可以使用它。</target>
        </trans-unit>
        <trans-unit id="6a2c1a54fe4430e99127181c7879f97150ac83b4" translate="yes" xml:space="preserve">
          <source>A fully qualified filename such as</source>
          <target state="translated">一个完全合格的文件名,如</target>
        </trans-unit>
        <trans-unit id="66350a7ced5e0598bbaa01d95aa21c1aa8b64d66" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt; .</source>
          <target state="translated">不能在 &lt;code&gt;struct&lt;/code&gt; 创建的类中显式定义名为 &lt;code&gt;new&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="cbfff922711d57d226b2688d07195e70805b9750" translate="yes" xml:space="preserve">
          <source>A function named &lt;code&gt;new&lt;/code&gt; must not be explicitly defined in a class created by &lt;code&gt;struct&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2945149f02dd35ba51bde27d2145bb414391b9dd" translate="yes" xml:space="preserve">
          <source>A function returning a single scalar with &lt;code&gt;#define&lt;/code&gt; definitions for the constants used internally between the generated C and XS functions.</source>
          <target state="translated">一个函数，返回一个带有 &lt;code&gt;#define&lt;/code&gt; 定义的标量，用于在生成的C和XS函数之间内部使用的常量。</target>
        </trans-unit>
        <trans-unit id="b69855856bd43ed93ca10429f84d959193788fea" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="translated">需要自己的文件句柄的函数必须在完整的typeglob上使用 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 。这可以用来创建新的符号表条目：</target>
        </trans-unit>
        <trans-unit id="60bce2f6faa5df9b0e4a3b944a64f25b88cc7ae4" translate="yes" xml:space="preserve">
          <source>A function that needs a filehandle of its own must use &lt;code&gt;local()&lt;/code&gt; on a complete typeglob. This can be used to create new symbol table entries:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="074e275ec83817fc8f7919a77c7d1bc574268f70" translate="yes" xml:space="preserve">
          <source>A function that returns a &lt;b&gt;list&lt;/b&gt; of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.</source>
          <target state="translated">该函数返回C子例程定义的&lt;b&gt;列表&lt;/b&gt;，当XS包装器传递名称时，该子例程定义返回常量的值和类型。</target>
        </trans-unit>
        <trans-unit id="16f5ca42729ef594d519db59b85f9698b43a3153" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt; , with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="translated">生成用于Makefile.PL的perl代码的函数，该代码将重新生成常量子例程。参数被命名为传递给 &lt;code&gt;WriteConstants&lt;/code&gt; ，并加上 &lt;code&gt;INDENT&lt;/code&gt; 来指定前导空格的数量（默认为2）。</target>
        </trans-unit>
        <trans-unit id="d909b3c9635ad08512fcce3363f9ca841d9148f8" translate="yes" xml:space="preserve">
          <source>A function to generate perl code for Makefile.PL that will regenerate the constant subroutines. Parameters are named as passed to &lt;code&gt;WriteConstants&lt;/code&gt;, with the addition of &lt;code&gt;INDENT&lt;/code&gt; to specify the number of leading spaces (default 2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1112f59bf733c8ebebfbb190c9c3efe0aeac9b" translate="yes" xml:space="preserve">
          <source>A function to generate the AUTOLOAD subroutine for the module</source>
          <target state="translated">为模块生成AUTOLOAD子程序的函数。</target>
        </trans-unit>
        <trans-unit id="b0a02614782733bf06479ea297bf790f7927505f" translate="yes" xml:space="preserve">
          <source>A function to generate the XS code to implement the perl subroutine</source>
          <target state="translated">生成XS代码以实现perl子程序的函数。</target>
        </trans-unit>
        <trans-unit id="94d15a8aa6cbd7f8b0a2a414f5a5f7d2b35f7284" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for C's &quot;&quot; or ''. It will die if passed Unicode characters.</source>
          <target state="translated">一个函数,它返回一个7位ASCII码的正确转义版本,适用于C的&quot;&quot;或''。如果传入Unicode字符,它将死亡。</target>
        </trans-unit>
        <trans-unit id="c45b17fcb375003bf4d5bd87967dc1245beb7fd4" translate="yes" xml:space="preserve">
          <source>A function which returns a 7 bit ASCII correctly \ escaped version of the string passed suitable for a perl &quot;&quot; string.</source>
          <target state="translated">一个函数,它返回一个7位ASCII码的正确转义版本,适合perl&quot;&quot;字符串。</target>
        </trans-unit>
        <trans-unit id="5e16a22c3d8b0f460cffd4d274f2db99a8a3ae51" translate="yes" xml:space="preserve">
          <source>A fundamental feature of regular expression matching involves the notion called</source>
          <target state="translated">正则表达式匹配的一个基本特征涉及到一个叫做</target>
        </trans-unit>
        <trans-unit id="f32db861d817164e66eceb71b5a4c52967492203" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level &lt;code&gt;splice()&lt;/code&gt; function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2100c9b6a5bc83c2e9c2b9fd7c9dc09b08c1aad2" translate="yes" xml:space="preserve">
          <source>A general function for editing the structure of an existing chain of op_sibling nodes. By analogy with the perl-level splice() function, allows you to delete zero or more sequential nodes, replacing them with zero or more different nodes. Performs the necessary op_first/op_last housekeeping on the parent node and op_sibling manipulation on the children. The last deleted node will be marked as as the last node by updating the op_sibling/op_sibparent or op_moresib field as appropriate.</source>
          <target state="translated">一个编辑现有的 op_sibling 节点链结构的通用函数,与 perl 级别的 splice()函数类似,允许你删除零个或多个连续节点,替换成零个或多个不同的节点。类似于perl级别的splice()函数,允许你删除0个或更多的顺序节点,用0个或更多不同的节点替换。在父节点上执行必要的 op_first/op_last 内务管理,在子节点上执行 op_sibling 操作。通过更新op_sibling/op_sibparent或op_moresib字段,最后删除的节点将被标记为最后一个节点。</target>
        </trans-unit>
        <trans-unit id="16b0d3e317f9f7b5ddb72b16cb53e05b583e9133" translate="yes" xml:space="preserve">
          <source>A general solution to the serialization problem would require another level of registry, one that associates</source>
          <target state="translated">序列化问题的一般解决方案将需要另一个层次的登记处,一个将以下内容关联起来的登记处。</target>
        </trans-unit>
        <trans-unit id="ed526677b5c541991128da9f35ea30909114035f" translate="yes" xml:space="preserve">
          <source>A generic &lt;b&gt;object&lt;/b&gt; type; that is, a &lt;b&gt;class&lt;/b&gt; from which other, more specific classes are derived genetically by &lt;b&gt;inheritance&lt;/b&gt;. Also called a &amp;ldquo;superclass&amp;rdquo; by people who respect their ancestors.</source>
          <target state="translated">通用&lt;b&gt;对象&lt;/b&gt;类型；即，&lt;b&gt;类&lt;/b&gt;从其它更特定的类是通过遗传衍生&lt;b&gt;继承&lt;/b&gt;。尊敬祖先的人也称其为&amp;ldquo;超阶级&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a9918e5dda4793cf3ecc366ce8266f117c17195" translate="yes" xml:space="preserve">
          <source>A generic file fetching mechanism</source>
          <target state="translated">一个通用的文件获取机制</target>
        </trans-unit>
        <trans-unit id="a625d1d6246943bf40d50608e758f2319151f17b" translate="yes" xml:space="preserve">
          <source>A generic input parsing/checking mechanism.</source>
          <target state="translated">一个通用的输入解析/检查机制。</target>
        </trans-unit>
        <trans-unit id="af15d07731a55a9ecedf87f6009285e2acc4ef80" translate="yes" xml:space="preserve">
          <source>A git GUI shell extension for Windows such as TortoiseGit will cause the build and later &lt;code&gt;make test&lt;/code&gt; to run much slower since every file is checked for its git status as soon as it is created and/or modified. TortoiseGit doesn't cause any test failures or build problems unlike the antivirus software described above, but it does cause similar slowness. It is suggested to use Task Manager to look for background processes which use high CPU amounts during the building process.</source>
          <target state="translated">Windows的git GUI shell扩展（例如TortoiseGit）将导致构建和以后的 &lt;code&gt;make test&lt;/code&gt; 运行缓慢得多，因为每个文件在创建和/或修改后都会立即检查其git状态。与上述防病毒软件不同，TortoiseGit不会导致任何测试失败或构建问题，但确实会导致类似的缓慢情况。建议使用任务管理器查找在构建过程中占用大量CPU的后台进程。</target>
        </trans-unit>
        <trans-unit id="ca6613321ff6c370136985bf48b668224b2f6734" translate="yes" xml:space="preserve">
          <source>A gizmo that transforms some number of input values to some number of output values, often built into a language with a special syntax or symbol. A given operator may have specific expectations about what &lt;b&gt;types&lt;/b&gt; of data you give as its arguments (&lt;b&gt;operands&lt;/b&gt;) and what type of data you want back from it.</source>
          <target state="translated">将小数目的输入值转换为小数目的输出值的小控件，通常将其内置到具有特殊语法或符号的语言中。给定的运算符可能对您将其作为参数（&lt;b&gt;操作数&lt;/b&gt;）给出的数据类型以及要从中返回的数据&lt;b&gt;类型&lt;/b&gt;有特定的期望。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0da5e61aa8557d6b28694e8c5217513361c3a66" translate="yes" xml:space="preserve">
          <source>A glossary of terms (technical and otherwise) used in the Perl documentation, derived from the Glossary of</source>
          <target state="translated">Perl文档中使用的术语(技术和其他方面)的词汇表,来源于《Perl术语表》。</target>
        </trans-unit>
        <trans-unit id="b29b7f7af6cfd5aa471dc4da158609e558212777" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , and &lt;code&gt;%&lt;/code&gt; .</source>
          <target state="translated">魔术中使用的字形。或者，对于Perl，在变量名前面的符号，例如 &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; 和 &lt;code&gt;%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d989c44f106d0ab2b9ca7513c2727428f0d1bd66" translate="yes" xml:space="preserve">
          <source>A glyph used in magic. Or, for Perl, the symbol in front of a variable name, such as &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010767009a82e3c3f2315997ed16da6d8fa110ca" translate="yes" xml:space="preserve">
          <source>A good book on OO on Perl is the &quot;Object-Oriented Perl&quot; by Damian Conway from Manning Publications, or &quot;Intermediate Perl&quot; by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.</source>
          <target state="translated">关于Perl的OO的好书是Manning Publications的Damian Conway的 &quot;Object-Oriented Perl&quot;,或者是O'Reilly Media的Randal Schwartz、brian d foy和Tom Phoenix的 &quot;Intermediate Perl&quot;。</target>
        </trans-unit>
        <trans-unit id="b82c3e9cadf17adecf1d24dc6cb64a89ca8103d6" translate="yes" xml:space="preserve">
          <source>A good place to start is &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;, and you can use &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for reference.</source>
          <target state="translated">&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;是一个很好的起点，您可以使用&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;作为参考。</target>
        </trans-unit>
        <trans-unit id="96ba2b7e6fee57191ec1137ef371aff044df9901" translate="yes" xml:space="preserve">
          <source>A good resource on the predefined macros for various operating systems, compilers, and so forth is &lt;a href=&quot;http://sourceforge.net/p/predef/wiki/Home/&quot;&gt;http://sourceforge.net/p/predef/wiki/Home/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878d4536576dbff5139c196eb475074b04b81dfd" translate="yes" xml:space="preserve">
          <source>A good test case has most of these attributes: short, simple code; few dependencies on external commands, modules, or libraries; no platform-dependent code (unless it's a platform-specific bug); clear, simple documentation.</source>
          <target state="translated">一个好的测试用例具有这些属性中的大部分:短小、简单的代码;对外部命令、模块或库的依赖性小;没有平台依赖性的代码(除非是平台特有的错误);清晰、简单的文档。</target>
        </trans-unit>
        <trans-unit id="819fe6a0aff125bab30e82da5634d29a9188e255" translate="yes" xml:space="preserve">
          <source>A good test case is almost always a good candidate to be included in Perl's test suite. If you have the time, consider writing your test case so that it can be easily included into the standard test suite.</source>
          <target state="translated">一个好的测试用例几乎总是可以被包含在Perl的测试套件中。如果你有时间,可以考虑编写你的测试用例,使它可以很容易地被包含在标准测试套件中。</target>
        </trans-unit>
        <trans-unit id="6800c5039fcfc25d3805f20efcfc998a8922a07e" translate="yes" xml:space="preserve">
          <source>A grab bag of methods to generate specific macros and commands.</source>
          <target state="translated">生成特定宏和命令的方法的抓包。</target>
        </trans-unit>
        <trans-unit id="52f74d52da3fd8ec9d4b9513d833d3c381a80abc" translate="yes" xml:space="preserve">
          <source>A grammar for the Test Anything Protocol.</source>
          <target state="translated">测试任何东西协议的语法。</target>
        </trans-unit>
        <trans-unit id="4068f0366f48575a0048eca3205a24ad39495e7b" translate="yes" xml:space="preserve">
          <source>A grammar form might be something like this:</source>
          <target state="translated">语法形式可能是这样的。</target>
        </trans-unit>
        <trans-unit id="856ecf1b456990ad6225d8774e68fb8a4307706a" translate="yes" xml:space="preserve">
          <source>A grapheme is what appears to a native-speaker of a language to be a character. In Unicode (and hence Perl) a grapheme may actually be several adjacent characters that together form a complete grapheme. For example, there can be a base character, like &quot;R&quot; and an accent, like a circumflex &quot;^&quot;, that appear to be a single character when displayed, with the circumflex hovering over the &quot;R&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19193405de37cb91769fc940baebbd6ae904906a" translate="yes" xml:space="preserve">
          <source>A graphene is an allotrope of carbon arranged in a hexagonal crystal lattice one atom thick. A &lt;b&gt;grapheme&lt;/b&gt;, or more fully, a</source>
          <target state="translated">石墨烯是一种碳的同素异形体，它排列在一个原子厚的六边形晶格中。一&lt;b&gt;字形&lt;/b&gt;，或更充分，一</target>
        </trans-unit>
        <trans-unit id="07663ed8c039244f1bbba8bbd0f2248a550eeeb7" translate="yes" xml:space="preserve">
          <source>A graphical representation of complex numbers is possible in a plane (also called the</source>
          <target state="translated">在平面上可以用图形来表示复数(也叫作</target>
        </trans-unit>
        <trans-unit id="b2a17fedc722e35cf530893f218ec96ab466a1ef" translate="yes" xml:space="preserve">
          <source>A great circle is section of a circle that contains the circle diameter: the shortest distance between two (non-antipodal) points on the spherical surface goes along the great circle connecting those two points.</source>
          <target state="translated">大圆是包含圆直径的圆的截面:球面上两点(非对角)之间的最短距离沿连接这两点的大圆走。</target>
        </trans-unit>
        <trans-unit id="cf830d0f970841c8b5873e5f5dc448f292f1330c" translate="yes" xml:space="preserve">
          <source>A group of related modules on &lt;b&gt;CPAN&lt;/b&gt;. (Also sometimes refers to a group of command-line switches grouped into one &lt;b&gt;switch cluster&lt;/b&gt;.)</source>
          <target state="translated">&lt;b&gt;CPAN&lt;/b&gt;上的一组相关模块。 （有时也指将一组命令行开关分组为一个&lt;b&gt;开关集群&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="d92a635a2c1e502bba680458b972125c4a0be466" translate="yes" xml:space="preserve">
          <source>A group that is required to bundle a set of alternatives may or may not be useful as a capturing group. If it isn't, it just creates a superfluous addition to the set of available capture group values, inside as well as outside the regexp. Non-capturing groupings, denoted by &lt;code&gt;(?:regexp)&lt;/code&gt;, still allow the regexp to be treated as a single unit, but don't establish a capturing group at the same time. Both capturing and non-capturing groupings are allowed to co-exist in the same regexp. Because there is no extraction, non-capturing groupings are faster than capturing groupings. Non-capturing groupings are also handy for choosing exactly which parts of a regexp are to be extracted to matching variables:</source>
          <target state="translated">捆绑一组备选方案所必需的组作为捕获组可能有用也可能没有用。如果不是这样，它只会在正则表达式的内部和外部为可用捕获组值的集合创建多余的内容。以 &lt;code&gt;(?:regexp)&lt;/code&gt; 表示的非捕获组仍然可以将正则表达式视为一个单元，但不能同时建立捕获组。捕获组和非捕获组都可以共存于同一正则表达式中。因为没有提取，所以非捕获分组比捕获分组要快。非捕获分组对于准确选择正则表达式的哪些部分要提取到匹配变量也很方便：</target>
        </trans-unit>
        <trans-unit id="e98254b9797c79a405fb849ceb15e69b1be1e9de" translate="yes" xml:space="preserve">
          <source>A handful of characters have a dedicated</source>
          <target state="translated">少数角色有专门的</target>
        </trans-unit>
        <trans-unit id="f93caa5208bfa6818a90d520fb7ad0e15665c128" translate="yes" xml:space="preserve">
          <source>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don't yet. Use a mixed-case attribute name, instead.</source>
          <target state="translated">声明了一个全小写的属性的处理程序。一个全小写的属性名也许有一天会对 Perl 本身有意义,尽管大多数属性名还没有。请使用混合大写的属性名。</target>
        </trans-unit>
        <trans-unit id="c3e6d55f9badd1667902eb5523efa20bcbd3e70c" translate="yes" xml:space="preserve">
          <source>A handler for attributes of the specified name</source>
          <target state="translated">对指定名称的属性进行处理</target>
        </trans-unit>
        <trans-unit id="49edbe08e4bfabb8ba065c602451240e8c0f2a33" translate="yes" xml:space="preserve">
          <source>A handy tag name for a</source>
          <target state="translated">一个方便的标签名称,用于</target>
        </trans-unit>
        <trans-unit id="3aa757aa90e3b991f02cc566dd247ec484d84771" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt; . &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">保留哈希 &lt;code&gt;%DB::sub&lt;/code&gt; ，其键为子例程名称，其值的格式为 &lt;code&gt;filename:startline-endline&lt;/code&gt; 。 &lt;code&gt;filename&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; s中定义的子例程的格式为 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c68c21cffb386f2efa2b6778aa32c6a355b62cff" translate="yes" xml:space="preserve">
          <source>A hash &lt;code&gt;%DB::sub&lt;/code&gt; is maintained, whose keys are subroutine names and whose values have the form &lt;code&gt;filename:startline-endline&lt;/code&gt;. &lt;code&gt;filename&lt;/code&gt; has the form &lt;code&gt;(eval 34)&lt;/code&gt; for subroutines defined inside &lt;code&gt;eval&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b55c7f5cfe4830cdb1fa796511bc1073b11348" translate="yes" xml:space="preserve">
          <source>A hash can be initialized using a literal list holding pairs of items to be interpreted as a key and a value:</source>
          <target state="translated">哈希可以使用一个字面列表来初始化,该列表中的项目对被解释为一个键和一个值。</target>
        </trans-unit>
        <trans-unit id="8a814541e8cdf1052da6ce7b4056b3b5847f1f69" translate="yes" xml:space="preserve">
          <source>A hash is an ideal mechanism to store the mapping between C and Perl.</source>
          <target state="translated">哈希是存储C和Perl之间映射的理想机制。</target>
        </trans-unit>
        <trans-unit id="70381f72f3a7fd8e9863739e409cd4fabcba3c1e" translate="yes" xml:space="preserve">
          <source>A hash of array references in list context. Each entry of the hash has the fully qualified method name as its key and a reference to an array containing the method's list-context return values as its value.</source>
          <target state="translated">列表上下文中数组引用的哈希。哈希的每个条目都以完全限定的方法名作为键,并以包含该方法的列表上下文返回值的数组引用作为值。</target>
        </trans-unit>
        <trans-unit id="5ea60218a99582e9bc2b801ff2d5e8c50e9c5afa" translate="yes" xml:space="preserve">
          <source>A hash of hashes keyed on perl version and on module name. If a module is defined it indicates that that module is deprecated in that perl version and is scheduled for removal from core at some future point.</source>
          <target state="translated">一个以perl版本和模块名称为关键字的哈希值。如果定义了一个模块,则表示该模块在该perl版本中已被废弃,并计划在未来某个时间从核心中移除。</target>
        </trans-unit>
        <trans-unit id="3ce60ae7ced566f5220eb260ad49e428425ac3a8" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is module =&amp;gt; version pairs.</source>
          <target state="translated">散列的哈希值，按$]中的说明在perl版本上键入。第二层哈希是模块=&amp;gt;版本对。</target>
        </trans-unit>
        <trans-unit id="2c10d53a97cb7fcb7d7054e473e3b77644c85cb9" translate="yes" xml:space="preserve">
          <source>A hash of hashes that is keyed on perl version as indicated in $]. The second level hash is utility / defined pairs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c605211961bb9e43df625e92f911448dae2ef07" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to build your module but not run it.</source>
          <target state="translated">构建模块所需的模块的散列,但不能运行它。</target>
        </trans-unit>
        <trans-unit id="e6392db0e8aa8a4e0a54f37942aac32926d2e82c" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do.</source>
          <target state="translated">运行你的模块所需模块的哈希值。键是模块的名称,例如:Test::More,最小版本是模块的值。如果所需的版本号是0,那么任何版本都可以。</target>
        </trans-unit>
        <trans-unit id="1e045c2b4c33d3a322a7c93d405ec1e436652383" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to run your module. The keys are the module names ie. Test::More, and the minimum version is the value. If the required version number is 0 any version will do. The versions given may be a Perl v-string (see &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt;) or a range (see &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN::Meta::Requirements&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922e915de9e8740eca506cd44d1ed8c10a9b1671" translate="yes" xml:space="preserve">
          <source>A hash of modules that are needed to test your module but not run or build it.</source>
          <target state="translated">需要测试你的模块,但不需要运行或构建它的模块的哈希。</target>
        </trans-unit>
        <trans-unit id="cd4d1c09ebac99b02cf9a7c9fa8cd90d4f94f599" translate="yes" xml:space="preserve">
          <source>A hash of modules that are required to run Makefile.PL itself, but not to run your distribution.</source>
          <target state="translated">运行Makefile.PL本身所需的模块的散列,但不是运行你的发行版。</target>
        </trans-unit>
        <trans-unit id="f704787fb624926417400f97106f18daa25dcf15" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt; , the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; , but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt; .</source>
          <target state="translated">POSIX实时信号处理程序的哈希。它是标准 &lt;code&gt;%SIG&lt;/code&gt; 的扩展， &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; 大致等同于 &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt; ，但是正确的POSIX移动（见下文）是由 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 和 &lt;code&gt;POSIX::sigaction&lt;/code&gt; 而不是访问 &lt;code&gt;%SIG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28dd39596f5df333ab0f97240c1b59801abaec4f" translate="yes" xml:space="preserve">
          <source>A hash of the POSIX realtime signal handlers. It is an extension of the standard &lt;code&gt;%SIG&lt;/code&gt;, the &lt;code&gt;$POSIX::SIGRT{SIGRTMIN}&lt;/code&gt; is roughly equivalent to &lt;code&gt;$SIG{SIGRTMIN}&lt;/code&gt;, but the right POSIX moves (see below) are made with the &lt;code&gt;POSIX::SigSet&lt;/code&gt; and &lt;code&gt;POSIX::sigaction&lt;/code&gt; instead of accessing the &lt;code&gt;%SIG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60ab26088a220041ec5c97911d9e6f565f5cbd7a" translate="yes" xml:space="preserve">
          <source>A hash or array element can be true only if it's defined and defined only if it exists, but the reverse doesn't necessarily hold true.</source>
          <target state="translated">一个哈希或数组元素只有在它被定义的情况下才能为真,只有在它存在的情况下才能被定义,但反之则不一定成立。</target>
        </trans-unit>
        <trans-unit id="0bf79c7c035d7be8a20888854f2234466da28ff7" translate="yes" xml:space="preserve">
          <source>A hash reference containing various parsing options (see below)</source>
          <target state="translated">一个包含各种解析选项的哈希引用(见下文)。</target>
        </trans-unit>
        <trans-unit id="71468d46c3d10b4d4aab17a5abca352e48601869" translate="yes" xml:space="preserve">
          <source>A hash represents a set of key/value pairs:</source>
          <target state="translated">哈希表示一组键/值对。</target>
        </trans-unit>
        <trans-unit id="10f78a1f223b35e25505609f4916f6f91875834d" translate="yes" xml:space="preserve">
          <source>A hash that contains information on the appropriate bug tracker for each core module.</source>
          <target state="translated">一个包含每个核心模块的相应错误跟踪器信息的哈希值。</target>
        </trans-unit>
        <trans-unit id="567327a8b7280b6715ced030a81d31782682314b" translate="yes" xml:space="preserve">
          <source>A hash that contains information on where patches should be directed for each core module.</source>
          <target state="translated">一个哈希值,包含每个核心模块的补丁应指向何处的信息。</target>
        </trans-unit>
        <trans-unit id="9f6e2604d963e87b1664555e25f241bb06bae1e9" translate="yes" xml:space="preserve">
          <source>A hash that maps from each Pod filespec to its pod-name (like &quot;/whatever/plib/Stuff/Thing.pm&quot; =&amp;gt; &quot;Stuff::Thing&quot;)</source>
          <target state="translated">从每个Pod文件规范映射到其pod名称的哈希（例如&amp;ldquo; /whatever/plib/Stuff/Thing.pm&amp;rdquo; =&amp;gt;&amp;ldquo; Stuff :: Thing&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="215fe982a4e5c65f0b82e82b7b97c0bfc5c0deef" translate="yes" xml:space="preserve">
          <source>A hash that maps from each pod-name to the filespec (like &quot;Stuff::Thing&quot; =&amp;gt; &quot;/whatever/plib/Stuff/Thing.pm&quot;)</source>
          <target state="translated">从每个容器名称映射到文件规范的哈希（例如&amp;ldquo; Stuff :: Thing&amp;rdquo; =&amp;gt;&amp;ldquo; /whatever/plib/Stuff/Thing.pm&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="bb3108415359d307ae0dd29af4dd93824067960c" translate="yes" xml:space="preserve">
          <source>A hashref of items to add to the CPAN Meta file (</source>
          <target state="translated">要添加到CPAN元文件中的项目的哈希福德(</target>
        </trans-unit>
        <trans-unit id="b8c62243e4644d3b1d9b849dccb04e48b7d5ff46" translate="yes" xml:space="preserve">
          <source>A hashref of options may be appended to modify the request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039b44468fab1aa4f939b768b655c31c005e5690" translate="yes" xml:space="preserve">
          <source>A hashref with one or more of the keys &lt;code&gt;distribution&lt;/code&gt; , &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;perl&lt;/code&gt; , &lt;code&gt;perlconfig&lt;/code&gt; , and &lt;code&gt;env&lt;/code&gt; that specify whether a document is targeted at a specific CPAN distribution or installation. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">具有一个或多个键 &lt;code&gt;distribution&lt;/code&gt; ， &lt;code&gt;module&lt;/code&gt; ， &lt;code&gt;perl&lt;/code&gt; ， &lt;code&gt;perlconfig&lt;/code&gt; 和 &lt;code&gt;env&lt;/code&gt; 的hashref，它们指定文档是针对特定的CPAN发行版还是安装。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="8c60ca8fe75e29a9dfda50be5b6bb79ab9c86c02" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) without any text? That ain't no heading!</source>
          <target state="translated">没有任何文本的标题（ &lt;code&gt;=head1&lt;/code&gt; &lt;code&gt;=head2&lt;/code&gt; 或= head2）？那不是标题！</target>
        </trans-unit>
        <trans-unit id="e61f2f28c623b8bf615200619cdf69dae431768b" translate="yes" xml:space="preserve">
          <source>A heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) without any text? That ain't no heading!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9832f7772423825e7be09c103f042abd3956ccc" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt; , with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; knows where to stop.</source>
          <target state="translated">&lt;code&gt;$berbuf&lt;/code&gt; 十六进制转储（在正确的位置插入空格）显示01 8100 8101 81807F。由于最后一个字节始终小于128，因此 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 知道在哪里停止。</target>
        </trans-unit>
        <trans-unit id="e25c820f972869adef22f733ce82d7969564bd8d" translate="yes" xml:space="preserve">
          <source>A hex dump of &lt;code&gt;$berbuf&lt;/code&gt;, with spaces inserted at the right places, shows 01 8100 8101 81807F. Since the last byte is always less than 128, &lt;code&gt;unpack&lt;/code&gt; knows where to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2983a66dc1728b3d6b6e5a9cf2faed1865191ff" translate="yes" xml:space="preserve">
          <source>A hex dump of the bytes in field in the order they are stored in the zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40a76a5eb1fbe1d4b01f9b8fcd76ad6df4acf92" translate="yes" xml:space="preserve">
          <source>A hex string consists of hex digits and an optional &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt; prefix. Each hex digit may be preceded by a single underscore, which will be ignored. Any other character triggers a warning and causes the rest of the string to be ignored (even leading whitespace, unlike &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt;). Only integers can be represented, and integer overflow triggers a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38e7070b1f249f379f9a778af2f10d3b11497505" translate="yes" xml:space="preserve">
          <source>A hierarchy of &quot;categories&quot; have been defined to allow groups of warnings to be enabled/disabled in isolation.</source>
          <target state="translated">定义了一个 &quot;类别 &quot;的层次结构,以允许单独启用/禁用一组警告。</target>
        </trans-unit>
        <trans-unit id="536684f67238bfdb66acbda52de51ea79291a12f" translate="yes" xml:space="preserve">
          <source>A is the root class, B is a subclass of A, C is a subclass of B, and D is another subclass of A.</source>
          <target state="translated">A是根类,B是A的一个子类,C是B的一个子类,D是A的另一个子类。</target>
        </trans-unit>
        <trans-unit id="8f3e40034aa0308d28f4dfc54288a8825f6cfd1e" translate="yes" xml:space="preserve">
          <source>A kind of &lt;b&gt;overloading&lt;/b&gt; that you can do on built-in &lt;b&gt;operators&lt;/b&gt; to make them work on &lt;b&gt;objects&lt;/b&gt; as if the objects were ordinary scalar values, but with the actual semantics supplied by the object class. This is set up with the overload &lt;b&gt;pragma&lt;/b&gt;&amp;mdash;see Camel chapter 13, &amp;ldquo;Overloading&amp;rdquo;.</source>
          <target state="translated">A类&lt;b&gt;超载&lt;/b&gt;，你可以内置在做&lt;b&gt;运营商&lt;/b&gt;，使他们的工作&lt;b&gt;对象&lt;/b&gt;，如同对象是普通的标值，但该对象类提供的实际语义。这是通过过载&lt;b&gt;编译指令设置的&lt;/b&gt; &amp;mdash;请参见Camel第13章&amp;ldquo;过载&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e9cfe5685ea0ecd4847a06232a077cb874b35be7" translate="yes" xml:space="preserve">
          <source>A kind of action that an &lt;b&gt;object&lt;/b&gt; can take if you tell it to. See Camel chapter 12, &amp;ldquo;Objects&amp;rdquo;.</source>
          <target state="translated">如果您告诉&lt;b&gt;对象&lt;/b&gt;，则该&lt;b&gt;对象&lt;/b&gt;可以执行的一种操作。请参见骆驼第12章&amp;ldquo;对象&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="dfe222b0c92a8225eafa0e0da38f08258e2a6e75" translate="yes" xml:space="preserve">
          <source>A kind of key or name attached to a loop (or roller coaster) so that loop control statements can talk about which loop they want to control.</source>
          <target state="translated">一种附加在循环(或过山车)上的键或名称,以便循环控制语句可以谈论他们想要控制的循环。</target>
        </trans-unit>
        <trans-unit id="e7d72d06babc67750c6b28a2b28bed949fa33a88" translate="yes" xml:space="preserve">
          <source>A kinder, gentler tutorial on object-oriented programming in Perl can be found in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;. You should also check out &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for some style guides on constructing both modules and classes.</source>
          <target state="translated">在&lt;a href=&quot;perlootut&quot;&gt;perlootut中&lt;/a&gt;可以找到有关Perl中面向对象编程的更友好，更柔和的教程。您还应该查看&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;以获取有关构造模块和类的一些样式指南。</target>
        </trans-unit>
        <trans-unit id="b68c5f288b44308b58cb523d3e60b493b484f9c4" translate="yes" xml:space="preserve">
          <source>A language beloved by many for its inside-out &lt;b&gt;type&lt;/b&gt; definitions, inscrutable &lt;b&gt;precedence&lt;/b&gt; rules, and heavy &lt;b&gt;overloading&lt;/b&gt; of the function-call mechanism. (Well, actually, people first switched to C because they found lowercase identifiers easier to read than upper.) Perl is written in C, so it&amp;rsquo;s not surprising that Perl borrowed a few ideas from it.</source>
          <target state="translated">一种由内而外的&lt;b&gt;类型&lt;/b&gt;定义，难以理解的&lt;b&gt;优先级&lt;/b&gt;规则以及函数调用机制的大量&lt;b&gt;重载&lt;/b&gt;而受到许多人喜爱的语言。（实际上，人们首先使用C是因为他们发现小写标识符比大写字母更容易阅读。）Perl是用C编写的，因此Perl借鉴了一些想法也就不足为奇了。</target>
        </trans-unit>
        <trans-unit id="7a70c2d1db9e3781c948c3f568d555da43db83b2" translate="yes" xml:space="preserve">
          <source>A language class is a class containing a lexicon of phrases as class data, and possibly also some methods that are of use in interpreting phrases in the lexicon, or otherwise dealing with text in that language.</source>
          <target state="translated">一个语言类是一个包含一个短语词典作为类数据的类,还可能包含一些方法,这些方法在解释词典中的短语,或以其他方式处理该语言的文本时使用。</target>
        </trans-unit>
        <trans-unit id="c64c47113f6df7e33ad198a5fed1bb8f3af6d13f" translate="yes" xml:space="preserve">
          <source>A language handle is a flyweight object -- i.e., it doesn't (necessarily) carry any data of interest, other than just being a member of whatever class it belongs to.</source>
          <target state="translated">语言句柄是一个轻量级对象--也就是说,它除了是它所属的任何类的成员之外,并不(一定)携带任何感兴趣的数据。</target>
        </trans-unit>
        <trans-unit id="c3a083f1f9c38b9c0d77465662a942c4c5d48d8d" translate="yes" xml:space="preserve">
          <source>A language handle is implemented as a blessed hash. Subclasses of yours can store whatever data you want in the hash. Currently the only hash entry used by any crucial Maketext method is &quot;fail&quot;, so feel free to use anything else as you like.</source>
          <target state="translated">一个语言句柄是以祝福哈希的形式实现的。你的子类可以在哈希中存储任何你想要的数据。目前,任何关键的Maketext方法使用的唯一的哈希条目是 &quot;fail&quot;,所以你可以随意使用其他任何你喜欢的东西。</target>
        </trans-unit>
        <trans-unit id="9fb1cb589c473c75eb212d9b744da125c770bad8" translate="yes" xml:space="preserve">
          <source>A language such as Perl that is good at hooking things together that weren&amp;rsquo;t intended to be hooked together.</source>
          <target state="translated">像Perl这样的语言，擅长将不希望被钩在一起的东西钩在一起。</target>
        </trans-unit>
        <trans-unit id="7ea3dfebe2530a429cde54a5f0bc78f862792455" translate="yes" xml:space="preserve">
          <source>A large scalar that you know can only contain ASCII</source>
          <target state="translated">一个大标量,你知道它只能包含ASCII码。</target>
        </trans-unit>
        <trans-unit id="8078fbdb7cd614c0fbe18240c94f727ccdf4ed5e" translate="yes" xml:space="preserve">
          <source>A layer can be added that does &quot;\n&quot; to CRLF translation. This layer can be used on any platform, not just those that normally do such things.</source>
          <target state="translated">可以添加一个层,进行&quot;/n &quot;到CRLF的翻译。这个层可以在任何平台上使用,而不仅仅是那些通常做这种事情的平台。</target>
        </trans-unit>
        <trans-unit id="c418f05188c75b7cf5ccc4221979555d292c85f1" translate="yes" xml:space="preserve">
          <source>A layer contains a &quot;vtable&quot;, the table of I/O operations (at C level a table of function pointers), and status flags. The functions in the vtable implement operations like &quot;open&quot;, &quot;read&quot;, and &quot;write&quot;.</source>
          <target state="translated">一个层包含一个 &quot;vtable&quot;,I/O操作表(在C层是一个函数指针表),以及状态标志。vtable中的函数实现了 &quot;打开&quot;、&quot;读取 &quot;和 &quot;写入 &quot;等操作。</target>
        </trans-unit>
        <trans-unit id="4f0330995dfa2fce16816cd443c9581a48699cf3" translate="yes" xml:space="preserve">
          <source>A layer derived using &quot;perlio&quot; as a base class. It provides Win32-like &quot;\n&quot; to CR,LF translation. Can either be applied above &quot;perlio&quot; or serve as the buffer layer itself. &quot;crlf&quot; over &quot;unix&quot; is the default if system distinguishes between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; opens. (At some point &quot;unix&quot; will be replaced by a &quot;native&quot; Win32 IO layer on that platform, as Win32's read/write layer has various drawbacks.) The &quot;crlf&quot; layer is a reasonable model for a layer which transforms data in some way.</source>
          <target state="translated">使用&amp;ldquo; perlio&amp;rdquo;作为基类派生的图层。它提供了类似于Win32的&amp;ldquo; \ n&amp;rdquo;来进行CR，LF转换。可以应用在&amp;ldquo; perlio&amp;rdquo;上方，也可以用作缓冲层本身。如果系统区分 &lt;code&gt;O_TEXT&lt;/code&gt; 和 &lt;code&gt;O_BINARY&lt;/code&gt; 打开，则&amp;ldquo; unif &amp;rdquo;上的&amp;ldquo; crlf &amp;rdquo;是默认设置。（在某些时候，&amp;ldquo; unix&amp;rdquo;将被该平台上的&amp;ldquo;本机&amp;rdquo; Win32 IO层替换，因为Win32的读/写层具有各种缺点。）&amp;ldquo; crlf&amp;rdquo;层是在某些情况下转换数据的层的合理模型。方式。</target>
        </trans-unit>
        <trans-unit id="c575f3b4bff37dcf26ab538523523b73298b17f9" translate="yes" xml:space="preserve">
          <source>A layer does not have to implement all the functions, but the whole table has to be present. Unimplemented slots can be NULL (which will result in an error when called) or can be filled in with stubs to &quot;inherit&quot; behaviour from a &quot;base class&quot;. This &quot;inheritance&quot; is fixed for all instances of the layer, but as the layer chooses which stubs to populate the table, limited &quot;multiple inheritance&quot; is possible.</source>
          <target state="translated">一个层不一定要实现所有的功能,但整个表必须存在。未实现的槽可以是NULL(当调用时将导致错误),也可以用存根来填充,以 &quot;继承 &quot;一个 &quot;基类 &quot;的行为。这种 &quot;继承 &quot;对于层的所有实例来说是固定的,但由于层选择哪些存根来填充表,有限的 &quot;多重继承 &quot;是可能的。</target>
        </trans-unit>
        <trans-unit id="f3c275bcbbeb5e10eabf8b5098a80ac8ed647d3b" translate="yes" xml:space="preserve">
          <source>A layer implementing &quot;in memory&quot; files using scalar variables, automatically used in place of the platform defaults for IO when opening such a handle. As such, the scalar is expected to act like a file, only containing or storing bytes. See &lt;a href=&quot;PerlIO::scalar&quot;&gt;PerlIO::scalar&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f64a4152a5af0c9ac4baa66afb914d700fb3ea6" translate="yes" xml:space="preserve">
          <source>A layer that implements &quot;reading&quot; of files by using</source>
          <target state="translated">实现 &quot;读取 &quot;文件的层,通过使用</target>
        </trans-unit>
        <trans-unit id="29bee167ef354a3d46f2326d367f6d5e9ab52d50" translate="yes" xml:space="preserve">
          <source>A layer that implements DOS/Windows like CRLF line endings. On read converts pairs of CR,LF to a single &quot;\n&quot; newline character. On write converts each &quot;\n&quot; to a CR,LF pair. Note that this layer will silently refuse to be pushed on top of itself.</source>
          <target state="translated">一个实现DOS/Windows类似CRLF行尾的层。读取时将CR,LF对转换为一个&quot;/n &quot;新行字符。写入时将每个&quot;/n &quot;转换为一对CR,LF。请注意,这一层会默默地拒绝被推到自己的上面。</target>
        </trans-unit>
        <trans-unit id="49890359753a7b7c09475de22e069c5121e36bd2" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems, and also provides buffering similar to &lt;code&gt;:perlio&lt;/code&gt; on these architectures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b39500363434cc0ff0f52b520ce130f3b3a554" translate="yes" xml:space="preserve">
          <source>A layer which does CRLF to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; translation distinguishing &quot;text&quot; and &quot;binary&quot; files in the manner of MS-DOS and similar operating systems. (It currently does</source>
          <target state="translated">以MS-DOS和类似操作系统的方式执行CRLF到 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 转换以区分&amp;ldquo;文本&amp;rdquo;和&amp;ldquo;二进制&amp;rdquo;文件的层。（目前</target>
        </trans-unit>
        <trans-unit id="d99ca2d73d6bc9954c1f5d38358ae63b3448d053" translate="yes" xml:space="preserve">
          <source>A layer which implements &quot;reading&quot; of files by using &lt;code&gt;mmap()&lt;/code&gt; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This</source>
          <target state="translated">通过使用 &lt;code&gt;mmap()&lt;/code&gt; 使（整个）文件出现在进程的地址空间中，然后将其用作PerlIO的&amp;ldquo;缓冲区&amp;rdquo; ，来实现文件的&amp;ldquo;读取&amp;rdquo;层。这个</target>
        </trans-unit>
        <trans-unit id="fd687d324576d9173f6d5752bc85ac325e3d235f" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt; .</source>
          <target state="translated">通过层方案提供PerlIO API的层，但是通过调用系统的stdio来实现它。（当前）如果系统的stdio提供足够的访问权限以允许perl的&amp;ldquo;快速获取&amp;rdquo;访问并且不区分 &lt;code&gt;O_TEXT&lt;/code&gt; 和 &lt;code&gt;O_BINARY&lt;/code&gt; ，则这是默认设置。</target>
        </trans-unit>
        <trans-unit id="05d6c08e7d4d9ce599909cfee99a9592e335ccd5" translate="yes" xml:space="preserve">
          <source>A layer which provides the PerlIO API via the layer scheme, but implements it by calling system's stdio. This is (currently) the default if system's stdio provides sufficient access to allow perl's &quot;fast gets&quot; access and which do not distinguish between &lt;code&gt;O_TEXT&lt;/code&gt; and &lt;code&gt;O_BINARY&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841e889a880ebb77b0a2697210c6744f8df031b" translate="yes" xml:space="preserve">
          <source>A leading ! indicates that matching names should be deleted from the list of names to import. If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.</source>
          <target state="translated">前面的 !表示应该从要导入的名称列表中删除匹配的名称。如果第一个规范是删除,则会被视为前面有 :DEFAULT。如果您只是想在默认设置之外导入额外的名称,您仍然需要明确包含 :DEFAULT。</target>
        </trans-unit>
        <trans-unit id="f747bcc2647296135613b88a3e62cca47b6c1dc6" translate="yes" xml:space="preserve">
          <source>A leading colon removes the &quot;name=&quot; part of the response, this allows you to map to the name you need. (mnemonic: empty label)</source>
          <target state="translated">前面的冒号去掉了响应中的 &quot;name=&quot;部分,这样就可以映射到你需要的名称。(提示语:空标签)</target>
        </trans-unit>
        <trans-unit id="96fa00367bcfdb4784c34a4a3babbe9475afc22d" translate="yes" xml:space="preserve">
          <source>A legally formed name for most anything in which a computer program might be interested. Many languages (including Perl) allow identifiers to start with an alphabetic character, and then contain alphabetics and digits. Perl also allows connector punctuation like the underscore character wherever it allows alphabetics. (Perl also has more complicated names, like &lt;b&gt;qualified&lt;/b&gt; names.)</source>
          <target state="translated">电脑程序可能感兴趣的大多数事物的合法名称。许多语言（包括Perl）都允许标识符以字母字符开头，然后包含字母和数字。Perl允许在允许字母的任何地方使用连接符标点，例如下划线字符。（Perl还具有更复杂的名称，如&lt;b&gt;限定&lt;/b&gt;名称。）</target>
        </trans-unit>
        <trans-unit id="69d4d84a09fc968a07bdda5a53812534fa74783b" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt; ) nor about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; ) or similar cases.</source>
          <target state="translated">一个库只需要处理无符号的大整数。输入参数有效性的测试是由主叫方完成的，所以没有必要对溢忧（例如，在 &lt;code&gt;_sub()&lt;/code&gt; 和 &lt;code&gt;_dec()&lt;/code&gt; ），也没有关于除零（例如，在 &lt;code&gt;_div()&lt;/code&gt; ）或类似的情况。</target>
        </trans-unit>
        <trans-unit id="d63d0720eeb53645d19249b7b0b30c1e9040b91f" translate="yes" xml:space="preserve">
          <source>A library only needs to deal with unsigned big integers. Testing of input parameter validity is done by the caller, so there is no need to worry about underflow (e.g., in &lt;code&gt;_sub()&lt;/code&gt; and &lt;code&gt;_dec()&lt;/code&gt;) or about division by zero (e.g., in &lt;code&gt;_div()&lt;/code&gt; and &lt;code&gt;_mod()&lt;/code&gt;)) or similar cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf7193a51535e24fe6d6e597b0723102b292f35" translate="yes" xml:space="preserve">
          <source>A line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b89fa4e541f30b4e921956619e05676831d4d1c" translate="yes" xml:space="preserve">
          <source>A line number may be prefixed by a single letter:</source>
          <target state="translated">行号前可加一个字母。</target>
        </trans-unit>
        <trans-unit id="2d89336c3df3636aebec0ee20d5e9be98d7da075" translate="yes" xml:space="preserve">
          <source>A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax. Following a &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.</source>
          <target state="translated">面向行的引用形式基于外壳程序&amp;ldquo; here-document&amp;rdquo;语法。在 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 之后,您可以指定一个字符串来终止引用的材料，当前行之后直到终止字符串的所有行都是该项的值。</target>
        </trans-unit>
        <trans-unit id="ba737ca3db1e413142acc2b22e379ceb469071d3" translate="yes" xml:space="preserve">
          <source>A list containing a single undef, in list context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e8b52d2267761231a600214a302dc93a9097e4" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt; s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; 引入的列表以文本或逐字段落开头，但以 &lt;code&gt;=item&lt;/code&gt; 开头。将非项目段落移出 &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="1e132d5a818c0fde195a981571859eee6be87b1c" translate="yes" xml:space="preserve">
          <source>A list introduced by &lt;code&gt;=over&lt;/code&gt; starts with a text or verbatim paragraph, but continues with &lt;code&gt;=item&lt;/code&gt;s. Move the non-item paragraph out of the &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aee76ae2469acd57d2557387480876b03411474" translate="yes" xml:space="preserve">
          <source>A list is a fixed collection of scalars. An array is a variable that holds a variable collection of scalars. An array can supply its collection for list operations, so list operations also work on arrays:</source>
          <target state="translated">列表是一个固定的标量集合。数组是一个变量,它容纳了一个可变的标量集合。数组可以为列表操作提供它的集合,所以列表操作也可以在数组上进行。</target>
        </trans-unit>
        <trans-unit id="b201394353dbcc6ef2561ba6cd863dea90b88222" translate="yes" xml:space="preserve">
          <source>A list of additional libraries or other shared objects which can be used to resolve any undefined symbols that might be generated by a later call to load_file().</source>
          <target state="translated">附加库或其他共享对象的列表,可以用来解决任何未定义的符号,这些符号可能会在以后调用load_file()时产生。</target>
        </trans-unit>
        <trans-unit id="e216fd26bc604e567680be656aeb4002407fb587" translate="yes" xml:space="preserve">
          <source>A list of all the INSTALL* variables without the INSTALL prefix. Useful for iteration or building related variable sets.</source>
          <target state="translated">所有不带INSTALL前缀的INSTALL*变量的列表。用于迭代或建立相关的变量集。</target>
        </trans-unit>
        <trans-unit id="e85ab034c5cddfa0ece70fbf99712ce6eb1bc6c8" translate="yes" xml:space="preserve">
          <source>A list of custom keys are available from the &lt;code&gt;custom_keys&lt;/code&gt; method and particular keys may be retrieved with the &lt;code&gt;custom&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94957d0f7514017339244da4cc1607583b5fc84e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. Any architecture-specific and version-specific directories, such as</source>
          <target state="translated">在查找标准库和当前目录之前,要在其中查找Perl库文件的目录列表。任何特定架构和特定版本的目录,如</target>
        </trans-unit>
        <trans-unit id="7103902d7143d091cfd2b7d907958a451f56b4e9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library and the current directory. If PERL5LIB is defined, PERLLIB is not used.</source>
          <target state="translated">在查找标准库和当前目录之前,寻找Perl库文件的目录列表。如果定义了PERL5LIB,则不使用PERLLIB。</target>
        </trans-unit>
        <trans-unit id="74c3a8ebaa1190b475b719545a9be33666f3621e" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. Any architecture-specific and version-specific directories, such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b17875309177ed716e25c72207fa65946c2db9" translate="yes" xml:space="preserve">
          <source>A list of directories in which to look for Perl library files before looking in the standard library. If &lt;a href=&quot;#PERL5LIB&quot;&gt;&quot;PERL5LIB&quot;&lt;/a&gt; is defined, PERLLIB is not used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3cc07c6f57898b2ef6aaadd57be04cf61845061" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt; . The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="translated">目录路径列表。如果输入文件不存在，则将在给定目录列表中搜索该文件（目录在列表中的显示顺序）。它默认为 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 隐含的目录列表。该列表可以通过对数组的引用来指定，也可以通过目录路径字符串来指定，这些目录路径使用与系统上 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 相同的路径分隔符（例如 &lt;code&gt;:&lt;/code&gt; 对于Unix ， &lt;code&gt;;&lt;/code&gt; 对于MSWin32和DOS）。</target>
        </trans-unit>
        <trans-unit id="f2a928fe21ff1b5f7955724187f967a836701c95" translate="yes" xml:space="preserve">
          <source>A list of directory paths. If the input file does not exist, then it will be searched for in the given directory list (in the order the directories appear in the list). It defaults to the list of directories implied by &lt;code&gt;$ENV{PATH}&lt;/code&gt;. The list may be specified either by a reference to an array, or by a string of directory paths which use the same path separator as &lt;code&gt;$ENV{PATH}&lt;/code&gt; on your system (e.g., &lt;code&gt;:&lt;/code&gt; for Unix, &lt;code&gt;;&lt;/code&gt; for MSWin32 and DOS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337601b93965c28568bbedd0632699f2eefded6b" translate="yes" xml:space="preserve">
          <source>A list of files in the distribution, one file per line. The MANIFEST always uses Unix filepath conventions even if you're not on Unix. This means</source>
          <target state="translated">发行版中的文件列表,每行一个文件。MANIFEST 总是使用 Unix 文件路径约定,即使你不是在 Unix 上。这意味着</target>
        </trans-unit>
        <trans-unit id="0555d0b38c03024b415a75a77593c5880fa79206" translate="yes" xml:space="preserve">
          <source>A list of one or more symbol names that are in the library/object file to be dynamically loaded. This is only required on some platforms.</source>
          <target state="translated">动态加载库/对象文件中的一个或多个符号名称的列表。只有在某些平台上才需要。</target>
        </trans-unit>
        <trans-unit id="681b6abf464391de8dd3a7916ae06f2d521a9817" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one contains the names.</source>
          <target state="translated">垫子的列表。第一个包含名字。</target>
        </trans-unit>
        <trans-unit id="da9e40582037de588b1af66d3e9b3a340700ef73" translate="yes" xml:space="preserve">
          <source>A list of pads. The first one is a B::PADNAMELIST containing the names. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f9cb55d32eb52f68051c89a619f41d785a1129" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt; .</source>
          <target state="translated">可能选择的列表，您只能从中选择一个，例如&amp;ldquo;您要门A，B还是C？&amp;rdquo;。在正则表达式替代分离与单个竖线： &lt;code&gt;|&lt;/code&gt; 。常规Perl表达式中的替代项用双竖线分隔： &lt;code&gt;||&lt;/code&gt; 。&lt;b&gt;布尔&lt;/b&gt;表达式中的逻辑替代项用 &lt;code&gt;||&lt;/code&gt; 分隔 或 &lt;code&gt;or&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2d1159bd9f6222036057dab76c68aab36c4921c" translate="yes" xml:space="preserve">
          <source>A list of possible choices from which you may select only one, as in, &amp;ldquo;Would you like door A, B, or C?&amp;rdquo; Alternatives in regular expressions are separated with a single vertical bar: &lt;code&gt;|&lt;/code&gt;. Alternatives in normal Perl expressions are separated with a double vertical bar: &lt;code&gt;||&lt;/code&gt;. Logical alternatives in &lt;b&gt;Boolean&lt;/b&gt; expressions are separated with either &lt;code&gt;||&lt;/code&gt; or &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346e1107e8ac97822d23a43881fe3f608701a635" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;../config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">当前平台支持的信号名称列表可在 &lt;code&gt;Config&lt;/code&gt; 模块提供的 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 找到。有关更多详细信息，请参见&lt;a href=&quot;../config&quot;&gt;配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9eb54a7b38bb34c8e5e028a36e767398adf41e8" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt; , which is provided by the &lt;code&gt;Config&lt;/code&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="translated">当前平台支持的信号名称列表可在 &lt;code&gt;Config&lt;/code&gt; 模块提供的 &lt;code&gt;$Config{sig_name}&lt;/code&gt; 找到。有关更多详细信息，请参见&lt;a href=&quot;config&quot;&gt;配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc0773d86c1f156c02879741dc6d62b20714e966" translate="yes" xml:space="preserve">
          <source>A list of signal names supported by the current platform can be found in &lt;code&gt;$Config{sig_name}&lt;/code&gt;, which is provided by the &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eccc6f087795a7e9086a2d2fafcbe724d6efe6cc" translate="yes" xml:space="preserve">
          <source>A list of tailorable locales</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a6ca6e50a55d219bc744f957b355e8b7592c8a" translate="yes" xml:space="preserve">
          <source>A list of the built-in functions in Perl can be found in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;可以找到Perl中内置函数的列表。</target>
        </trans-unit>
        <trans-unit id="372e15c083e652a86b064f2068748142c2ada459" translate="yes" xml:space="preserve">
          <source>A list of variant codes and their aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35384fe66627b2cc2fb84aa2b93b3f9464bdd2e5" translate="yes" xml:space="preserve">
          <source>A list started with e.g. a bullet-like &lt;code&gt;=item&lt;/code&gt; and continued with a numbered one. This is obviously inconsistent. For most translators the type of the</source>
          <target state="translated">列表以类似 &lt;code&gt;=item&lt;/code&gt; 符号的= item开头，并以编号1 开头。这显然是不一致的。对于大多数翻译人员而言，</target>
        </trans-unit>
        <trans-unit id="aa018bd7e5de867ce0e0e74c715e38d76832212f" translate="yes" xml:space="preserve">
          <source>A list value may also be subscripted like a normal array. You must put the list in parentheses to avoid ambiguity. For example:</source>
          <target state="translated">列表值也可以像普通数组一样进行下标。你必须把列表放在括号里,以避免歧义。例如</target>
        </trans-unit>
        <trans-unit id="6d0412d7581939fe7cd594904f6d1f6283358f69" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt; , &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt; . Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="translated">通常通过 &lt;code&gt;newLISTOP&lt;/code&gt; ， &lt;code&gt;op_prepend_elem&lt;/code&gt; 和 &lt;code&gt;op_append_elem&lt;/code&gt; 一次构造一个列表类型的op 。然后，最后将其传递给 &lt;code&gt;op_convert_list&lt;/code&gt; 以使其成为正确的类型。</target>
        </trans-unit>
        <trans-unit id="14189fe432e4560d9641abb356065b320734ccfd" translate="yes" xml:space="preserve">
          <source>A list-type op is usually constructed one kid at a time via &lt;code&gt;newLISTOP&lt;/code&gt;, &lt;code&gt;op_prepend_elem&lt;/code&gt; and &lt;code&gt;op_append_elem&lt;/code&gt;. Then finally it is passed to &lt;code&gt;op_convert_list&lt;/code&gt; to make it the right type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f682c29d99c6edee87a4e2c8b480a19c081d9f4" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; . This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="translated">&lt;code&gt;v1.20.300.4000&lt;/code&gt; 形式的文字被解析为由具有指定序数的字符组成的字符串。这种称为v-strings的形式提供了一种替代的，更易读的方式来构造字符串，而不是使用可读性较差的内插形式 &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt; 。这对于表示Unicode字符串以及使用字符串比较运算符 &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; 等比较版本&amp;ldquo;数字&amp;rdquo;很有用。如果文字中有两个或多个点，则可以省略前导 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2818d2fc350cf7ade47132bea5c3b21871e52fea" translate="yes" xml:space="preserve">
          <source>A literal of the form &lt;code&gt;v1.20.300.4000&lt;/code&gt; is parsed as a string composed of characters with the specified ordinals. This form, known as v-strings, provides an alternative, more readable way to construct strings, rather than use the somewhat less readable interpolation form &lt;code&gt;&quot;\x{1}\x{14}\x{12c}\x{fa0}&quot;&lt;/code&gt;. This is useful for representing Unicode strings, and for comparing version &quot;numbers&quot; using the string comparison operators, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; etc. If there are two or more dots in the literal, the leading &lt;code&gt;v&lt;/code&gt; may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f7e21c905ecc7463ec1c2d73cca6ccc870ec21" translate="yes" xml:space="preserve">
          <source>A little bit less simple options</source>
          <target state="translated">简单一点的选择</target>
        </trans-unit>
        <trans-unit id="6b6e0528ee125aa344dac0cd2afd7b5168d26910" translate="yes" xml:space="preserve">
          <source>A little bit of magic happens here. When running on anything but MacOS, all the tests run normally. But when on MacOS, &lt;code&gt;skip()&lt;/code&gt; causes the entire contents of the SKIP block to be jumped over. It never runs. Instead, &lt;code&gt;skip()&lt;/code&gt; prints special output that tells &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; that the tests have been skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cd2ad667ca8cebc07144e83ae02050c5a406af0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; . Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="translated">一点点内置语法糖意味着您还可以说&lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;或&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;作为&lt;b&gt;'-M &lt;i&gt;MODULE&lt;/i&gt; qw（foo bar）'&lt;/b&gt;的快捷方式。这样可以避免在导入符号时使用引号。&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;生成的实际代码是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; module &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(/,/,q{foo,bar})&lt;/code&gt; 。注意， &lt;code&gt;=&lt;/code&gt; 形式消除了&lt;b&gt;-m&lt;/b&gt;和&lt;b&gt;-M&lt;/b&gt;之间的区别；即&lt;b&gt;-m &lt;i&gt;MODULE&lt;/i&gt; = foo，bar&lt;/b&gt;与&lt;b&gt;-M &lt;i&gt;MODULE&lt;/i&gt; = foo，bar相同&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7fd937dfbc8cdfcbf7f8d9bddf92ad4d9bacfca0" translate="yes" xml:space="preserve">
          <source>A little builtin syntactic sugar means you can also say &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; or &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; as a shortcut for &lt;b&gt;'-M&lt;i&gt;MODULE&lt;/i&gt; qw(foo bar)'&lt;/b&gt;. This avoids the need to use quotes when importing symbols. The actual code generated by &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is &lt;code&gt;use module split(/,/,q{foo,bar})&lt;/code&gt;. Note that the &lt;code&gt;=&lt;/code&gt; form removes the distinction between &lt;b&gt;-m&lt;/b&gt; and &lt;b&gt;-M&lt;/b&gt;; that is, &lt;b&gt;-m&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt; is the same as &lt;b&gt;-M&lt;i&gt;MODULE&lt;/i&gt;=foo,bar&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b161330532dd0ec0afc3fa6fafbca99d0e5e09ac" translate="yes" xml:space="preserve">
          <source>A little funky, because VOS's notion of ownership is a little funky (VOS).</source>
          <target state="translated">有点时髦,因为VOS的所有权概念有点时髦(VOS)。</target>
        </trans-unit>
        <trans-unit id="fe38aea6f56711cc8a09262301b75b1d00f515d0" translate="yes" xml:space="preserve">
          <source>A little interface to ExtUtils::Installed to examine installed modules, validate your packlists and even create a tarball from an installed module.</source>
          <target state="translated">一个ExtUtils::Installed的小接口,用于检查已安装的模块,验证你的打包列表,甚至从已安装的模块中创建一个tarball。</target>
        </trans-unit>
        <trans-unit id="fab5a9063d3279beff24f900f22a1e9be454b440" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;../test/harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="translated">&lt;a href=&quot;../test/harness&quot;&gt;Test :: Harness的&lt;/a&gt;一个鲜为人知的功能是它支持计划中的TODO列表：</target>
        </trans-unit>
        <trans-unit id="e09dee149111fbdc75066a3a4b04ff33ac64fdce" translate="yes" xml:space="preserve">
          <source>A little-known feature of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; is that it supported TODO lists in the plan:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18dd594cfef1216511213db962d79c422701e3a6" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">局部变量将列出的变量修改为对于封闭块，文件或评估变量而言是局部的。如果列出了多个值，则该列表必须放在括号中。有关详细信息，包括绑定数组和哈希的问题，请参见&lt;a href=&quot;../perlsub#Temporary-Values-via-local()&quot;&gt;perlsub中通过local（）的临时值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4f458b856b0a12ad8d1fe86f374dff1cb18e135" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot; in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9869654ca036fa59fd44e2a08b434b738df4df1" translate="yes" xml:space="preserve">
          <source>A local modifies the listed variables to be local to the enclosing block, file, or eval. If more than one value is listed, the list must be placed in parentheses. See &lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;Temporary Values via local() in perlsub&lt;/a&gt; for details, including issues with tied arrays and hashes.</source>
          <target state="translated">局部变量将列出的变量修改为对于封闭块，文件或评估变量而言是局部的。如果列出了多个值，则该列表必须放在括号中。有关详细信息，包括绑定数组和哈希的问题，请参见&lt;a href=&quot;perlsub#Temporary-Values-via-local()&quot;&gt;perlsub中通过local（）的临时值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="851216238693688504d3297975d3a9648a0c15ac" translate="yes" xml:space="preserve">
          <source>A locale is a set of data that describes various aspects of how various communities in the world categorize their world. These categories are broken down into the following types (some of which include a brief note here):</source>
          <target state="translated">地域是一组数据,它描述了世界上各种社区如何对其世界进行分类的各个方面。这些分类可分为以下几种类型(其中一些包括这里的简要说明)。</target>
        </trans-unit>
        <trans-unit id="13e5d1d67a5e143b58f5105851151e51a7ee96cb" translate="yes" xml:space="preserve">
          <source>A location in a &lt;b&gt;hash table&lt;/b&gt; containing (potentially) multiple entries whose keys &amp;ldquo;hash&amp;rdquo; to the same hash value according to its hash function. (As internal policy, you don&amp;rsquo;t have to worry about it unless you&amp;rsquo;re into internals, or policy.)</source>
          <target state="translated">&lt;b&gt;哈希表&lt;/b&gt;中的一个位置，包含（可能）多个条目，这些条目的键根据其哈希函数&amp;ldquo;哈希&amp;rdquo;到相同的哈希值。（作为内部政策，除非您了解内部政策或政策，否则不必担心。）</target>
        </trans-unit>
        <trans-unit id="62c12399ed6b551ce7f2dd44832d843392fa0233" translate="yes" xml:space="preserve">
          <source>A lock can either be used to guard the data contained within the variable being locked, or it can be used to guard something else, like a section of code. In this latter case, the variable in question does not hold any useful data, and exists only for the purpose of being locked. In this respect, the variable behaves like the mutexes and basic semaphores of traditional thread libraries.</source>
          <target state="translated">鎖可以用來保護被鎖定的變數中包含的數據,也可以用來保護其他東西,比如一段代碼。在后一种情况下,相关的变量并不持有任何有用的数据,只是为了被锁定而存在。在这方面,变量的行为就像传统线程库中的mutexes和基本semaphores。</target>
        </trans-unit>
        <trans-unit id="e53273bd96405d6a9351857fe0d8e6743bfe42f3" translate="yes" xml:space="preserve">
          <source>A log of changes you've made to this module. The layout is free-form. Here's an example:</source>
          <target state="translated">你对这个模块所做的修改的日志。布局是自由式的。下面是一个例子。</target>
        </trans-unit>
        <trans-unit id="e77a6f13193bcd6e24d605469f11ccf9737a2eb7" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt; .</source>
          <target state="translated">命令行上的破折号现在将是合法选项，使用它将设置变量 &lt;code&gt;$stdio&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82708ef5882db99166c7c8cd03934807e0af6cda" translate="yes" xml:space="preserve">
          <source>A lone dash on the command line will now be a legal option, and using it will set variable &lt;code&gt;$stdio&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="518574ccfd2af3125f764f2199d90530c80ca8ba" translate="yes" xml:space="preserve">
          <source>A longer sequence is a script run if and only if &lt;b&gt;all&lt;/b&gt; of the following conditions are met:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e09920138d7232024aa812a56f04053ae3c9db" translate="yes" xml:space="preserve">
          <source>A longer, more complete description of the purpose or intended use of the distribution than the one provided by the &lt;code&gt;abstract&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb4c7413d2efeeaac13a33033548176fe547847" translate="yes" xml:space="preserve">
          <source>A lot of &lt;code&gt;bad free&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebb7eb8448d50869adcfaf8c37d6e3e449e059f" translate="yes" xml:space="preserve">
          <source>A lot of Git tools (Gitweb, GitHub, git log --pretty=oneline, ...) will only display the first line (cut off at 50 characters) when presenting commit summaries.</source>
          <target state="translated">很多 Git 工具(Gitweb、GitHub、git log --pretty=oneline,......)在显示提交摘要时,只会显示第一行(以 50 个字符为限)。</target>
        </trans-unit>
        <trans-unit id="02a8d66dfb847fc32e205ee4aa1e54636c91fd8e" translate="yes" xml:space="preserve">
          <source>A lot of opcodes (this is an elementary operation in the internal perl stack machine) put an SV* on the stack. However, as an optimization the corresponding SV is (usually) not recreated each time. The opcodes reuse specially assigned SVs (</source>
          <target state="translated">很多操作码(这是perl内部堆栈机的一个基本操作)在堆栈上放一个SV*。然而,作为一种优化,对应的SV并不是每次都重新创建。操作码会重复使用专门分配的SVs (</target>
        </trans-unit>
        <trans-unit id="afe9679193e46dcbc5b397149b0a40382533461a" translate="yes" xml:space="preserve">
          <source>A lot of the behaviour of &lt;code&gt;check()&lt;/code&gt; can be altered by setting package variables. See the section on &lt;code&gt;Global Variables&lt;/code&gt; for details on this.</source>
          <target state="translated">可以通过设置包变量来更改 &lt;code&gt;check()&lt;/code&gt; 的许多行为。有关详细信息，请参见&amp;ldquo; &lt;code&gt;Global Variables&lt;/code&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="fc40634e762614784aeafebfe726c582b35ad008" translate="yes" xml:space="preserve">
          <source>A lot of the methods in this package are accessors to the various fields in the tar header:</source>
          <target state="translated">这个包中的很多方法都是对 tar 头中各种字段的访问器。</target>
        </trans-unit>
        <trans-unit id="fdb88e271e5277826500f05676e2c0be0095eb4c" translate="yes" xml:space="preserve">
          <source>A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565ddf2f41fdaae2f6c398d4a9fce10061d3fdb0" translate="yes" xml:space="preserve">
          <source>A map to the empty string means that there is no alias defined for the code point.</source>
          <target state="translated">映射到空字符串意味着没有为代码点定义别名。</target>
        </trans-unit>
        <trans-unit id="962035547fe5a8c87c148cca16aad0a4071407ed" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">这些&lt;b&gt;权限位的&lt;/b&gt;掩码，在创建文件或目录时应将其强制关闭，以建立通常拒绝访问谁的策略。请参见 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c1942e2dc4da6fcab23b5c63e120680f59662794" translate="yes" xml:space="preserve">
          <source>A mask of those &lt;b&gt;permission bits&lt;/b&gt; that should be forced off when creating files or directories, in order to establish a policy of whom you&amp;rsquo;ll ordinarily deny access to. See the &lt;code&gt;umask&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb92546e7ee6f466e3b9ad9b8c6c91db11b1f74" translate="yes" xml:space="preserve">
          <source>A meaningless value will currently be returned if the input is not an unsigned integer.</source>
          <target state="translated">如果输入不是无符号整数,当前将返回一个无意义的值。</target>
        </trans-unit>
        <trans-unit id="46b7f4ae99fce16ec6771e2703c08b126f8c5237" translate="yes" xml:space="preserve">
          <source>A mechanism by which some high-level agent such as a user can pass its preferences down to its future offspring (child &lt;b&gt;processes&lt;/b&gt;, grandchild processes, great-grandchild processes, and so on). Each environment variable is a &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pair, like one entry in a &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">一种机制，通过该机制，诸如用户之类的某些高级代理可以将其偏好传递给其未来的后代（子&lt;b&gt;进程&lt;/b&gt;，孙进程，曾孙进程等）。每个环境变量都是一个&lt;b&gt;键&lt;/b&gt; / &lt;b&gt;值&lt;/b&gt;对，就像&lt;b&gt;hash中的&lt;/b&gt;一个条目一样。</target>
        </trans-unit>
        <trans-unit id="2a69447aeea5209e44940fc7462f35a5d6ac88b2" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="translated">Perl中的一种机制，使您可以存储每个Perl &lt;b&gt;命令&lt;/b&gt;的输出，然后将其作为单个请求刷新到&lt;b&gt;操作系统&lt;/b&gt;。通过设置 &lt;code&gt;$|&lt;/code&gt; 启用 （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）变量为真实值。当您不希望数据乱七八糟，不去预期的位置时使用它，因为&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;管道&lt;/b&gt;的默认设置是使用&lt;b&gt;块缓冲&lt;/b&gt;，因此可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="73a790a34f989c156e242df378ee398a811d0fa6" translate="yes" xml:space="preserve">
          <source>A mechanism in Perl that lets you store up the output of each Perl &lt;b&gt;command&lt;/b&gt; and then flush it out as a single request to the &lt;b&gt;operating system&lt;/b&gt;. It&amp;rsquo;s enabled by setting the &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) variable to a true value. It&amp;rsquo;s used when you don&amp;rsquo;t want data sitting around, not going where it&amp;rsquo;s supposed to, which may happen because the default on a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;pipe&lt;/b&gt; is to use &lt;b&gt;block buffering&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51120e7f8481f25cf88f8c7a272aee4be9724200" translate="yes" xml:space="preserve">
          <source>A memory address (pointer). Typically associated with a &lt;code&gt;void *&lt;/code&gt; type.</source>
          <target state="translated">内存地址（指针）。通常与 &lt;code&gt;void *&lt;/code&gt; 类型关联。</target>
        </trans-unit>
        <trans-unit id="3a89278430a1f2647d19e07faa6dcd5ce49e8cc5" translate="yes" xml:space="preserve">
          <source>A message of the form:</source>
          <target state="translated">一种形式的信息。</target>
        </trans-unit>
        <trans-unit id="f4fff5e041e8ffd1750d8230d717d49c7140db99" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="translated">一条消息打印到 &lt;code&gt;STDERR&lt;/code&gt; 流上，表示可能有问题，但不值得吹嘘。见 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 骆驼第27章，&amp;ldquo;功能&amp;rdquo;和 &lt;code&gt;warnings&lt;/code&gt; 骆驼28章编译&amp;ldquo; Pragmantic模块&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="698adb24081e5dd75873b482d129bef5c7d6f56b" translate="yes" xml:space="preserve">
          <source>A message printed to the &lt;code&gt;STDERR&lt;/code&gt; stream to the effect that something might be wrong but isn&amp;rsquo;t worth blowing up over. See &lt;code&gt;warn&lt;/code&gt; in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo; and the &lt;code&gt;warnings&lt;/code&gt; pragma in Camel chapter 28, &amp;ldquo;Pragmantic Modules&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6e29399630661da9d8d4454f316b8b579ac7c9" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;@args&lt;/code&gt; 之前打印的消息。</target>
        </trans-unit>
        <trans-unit id="f32f46fd3a16d86d6b29b7249d408acc0fd9dade" translate="yes" xml:space="preserve">
          <source>A message to print prior to &lt;code&gt;@args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd1e82245324d77d7c4b1f38686539fbc87f4207" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">一个元字符可以通过在它前面加上反斜杠来匹配。</target>
        </trans-unit>
        <trans-unit id="22cc73f771c76a642b402e7e0f9c578239ac498b" translate="yes" xml:space="preserve">
          <source>A metacharacter can be matched literally by putting a backslash before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb23d39b57fee733dc53600af45c98c9b288bdde" translate="yes" xml:space="preserve">
          <source>A method is simply a subroutine that expects a reference to an object (or a package name, for class methods) as the first argument.</source>
          <target state="translated">方法是一个简单的子程序,它期望一个对象的引用(或者一个包名,对于类方法)作为第一个参数。</target>
        </trans-unit>
        <trans-unit id="8b793382672991d71fa4d5891acf893cacd7e306" translate="yes" xml:space="preserve">
          <source>A method of making input and output efficient by passing one &lt;b&gt;block&lt;/b&gt; at a time. By default, Perl does block buffering to disk files. See &lt;b&gt;buffer&lt;/b&gt; and &lt;b&gt;command buffering&lt;/b&gt;.</source>
          <target state="translated">一种通过一次传递一个&lt;b&gt;块&lt;/b&gt;来提高输入和输出效率的方法。默认情况下，Perl会阻止对磁盘文件的缓冲。请参阅&lt;b&gt;缓冲区&lt;/b&gt;和&lt;b&gt;命令缓冲&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="caf2b56be7a3ef3288ab77eb65ba11acb464aa6d" translate="yes" xml:space="preserve">
          <source>A method of storing numbers in &amp;ldquo;scientific notation&amp;rdquo;, such that the precision of the number is independent of its magnitude (the decimal point &amp;ldquo;floats&amp;rdquo;). Perl does its numeric work with floating-point numbers (sometimes called &amp;ldquo;floats&amp;rdquo;) when it can&amp;rsquo;t get away with using &lt;b&gt;integers&lt;/b&gt;. Floating-point numbers are mere approximations of real numbers.</source>
          <target state="translated">一种以&amp;ldquo;科学计数法&amp;rdquo;存储数字的方法，以使数字的精度独立于其大小（小数点&amp;ldquo;浮点数&amp;rdquo;）。当无法使用&lt;b&gt;整数&lt;/b&gt;时，Perl会使用浮点数（有时称为&amp;ldquo;浮点数&amp;rdquo;）进行数字运算。浮点数仅是实数的近似值。</target>
        </trans-unit>
        <trans-unit id="944278d690e3fc7e64864c32faa75a96c4fa698a" translate="yes" xml:space="preserve">
          <source>A method returning a scalar containing definitions needed, typically for a C header file.</source>
          <target state="translated">返回一个包含所需定义的标量的方法,通常用于C头文件。</target>
        </trans-unit>
        <trans-unit id="b261259b0ea34efe663b89fa4a355d967119ff59" translate="yes" xml:space="preserve">
          <source>A method to return a suitable &lt;code&gt;#ifdef&lt;/code&gt; clause.</source>
          <target state="translated">返回合适的 &lt;code&gt;#ifdef&lt;/code&gt; 子句的方法。</target>
        </trans-unit>
        <trans-unit id="e298259952faa9b6dc589a73a54938eb75e8b9ca" translate="yes" xml:space="preserve">
          <source>A method to return a suitable C &lt;code&gt;if&lt;/code&gt; statement to check whether</source>
          <target state="translated">一种返回合适的C &lt;code&gt;if&lt;/code&gt; 语句以检查是否存在的方法</target>
        </trans-unit>
        <trans-unit id="b8d289dec370b10085acc876037d4a80d75d741c" translate="yes" xml:space="preserve">
          <source>A method to return a suitable assignment clause. If</source>
          <target state="translated">返回一个合适的赋值条款的方法。如果</target>
        </trans-unit>
        <trans-unit id="0c03f6a0b53898fc9e24cba2362fd5fb8fa53375" translate="yes" xml:space="preserve">
          <source>A miniature type system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7330449bff2c39517a4e897b762ab9507a795d4" translate="yes" xml:space="preserve">
          <source>A minimal required perl version, if present, will look like this:</source>
          <target state="translated">如果存在的话,一个最小的所需的perl版本会是这样的。</target>
        </trans-unit>
        <trans-unit id="e9a3539678256349db8d3cedb932d5bd4be41d3e" translate="yes" xml:space="preserve">
          <source>A misnamed feature&amp;mdash;it should be called, &amp;ldquo;expecting your mother to pick up after you&amp;rdquo;. Strictly speaking, Perl doesn&amp;rsquo;t do this, but it relies on a reference-counting mechanism to keep things tidy. However, we rarely speak strictly and will often refer to the reference-counting scheme as a form of garbage collection. (If it&amp;rsquo;s any comfort, when your interpreter exits, a &amp;ldquo;real&amp;rdquo; garbage collector runs to make sure everything is cleaned up if you&amp;rsquo;ve been messy with circular references and such.)</source>
          <target state="translated">一个名称不正确的功能-应该称为&amp;ldquo;希望您的母亲在您之后接送&amp;rdquo;。严格来说，Perl不会这样做，但是它依靠引用计数机制来使事情保持整洁。但是，我们很少严格讲，经常将引用计数方案称为垃圾收集的一种形式。 （如果可以的话，当您的解释器退出时，运行&amp;ldquo;真正的&amp;rdquo;垃圾收集器，以确保如果您对循环引用等杂乱无章的话，可以清除所有内容。）</target>
        </trans-unit>
        <trans-unit id="b76b41563e694ef10941bc1da1406e4e19d640cf" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; evaluation modifier. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="translated">专门用于搜索和替换的修饰符是 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 评估修饰符。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 将替换文本视为Perl代码，而不是双引号字符串。代码返回的值替换为匹配的子字符串。如果在替换文本的过程中需要进行一些计算，则 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; 很有用。本示例计算一行中的字符频率：</target>
        </trans-unit>
        <trans-unit id="978f8f9b8df9741b30748f830e018b2a20eda4a7" translate="yes" xml:space="preserve">
          <source>A modifier available specifically to search and replace is the &lt;code&gt;s///e&lt;/code&gt; evaluation modifier. &lt;code&gt;s///e&lt;/code&gt; treats the replacement text as Perl code, rather than a double-quoted string. The value that the code returns is substituted for the matched substring. &lt;code&gt;s///e&lt;/code&gt; is useful if you need to do a bit of computation in the process of replacing text. This example counts character frequencies in a line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f750d1b2bf1dcd617bfb9b0ddbb157dd528256" translate="yes" xml:space="preserve">
          <source>A modifier is overridden by later occurrences of this construct in the same scope containing the same modifier, so that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d67d7e195f6e0fb6e2bd79bf9224c3c8d1e2fd" translate="yes" xml:space="preserve">
          <source>A module for loading must be quoted.</source>
          <target state="translated">必须引用一个加载模块。</target>
        </trans-unit>
        <trans-unit id="8d98e6118bd0f23607596b779080678b5a48db1b" translate="yes" xml:space="preserve">
          <source>A module is a file that (by convention) provides a class of the same name (sans the .pm), plus an import method in that class that can be called to fetch exported symbols. This module may implement some of its methods by loading dynamic C or C++ objects, but that should be totally transparent to the user of the module. Likewise, the module might set up an AUTOLOAD function to slurp in subroutine definitions on demand, but this is also transparent. Only the</source>
          <target state="translated">一个模块是一个文件,它(按照惯例)提供了一个同名的类(去掉.pm),再加上该类中的一个导入方法,该方法可以被调用来获取导出的符号。这个模块可能会通过加载动态的C或C++对象来实现它的一些方法,但这对模块的用户来说应该是完全透明的。同样,该模块可能会设置一个AUTOLOAD函数,以根据需求吞吐子程序定义,但这也是透明的。只有</target>
        </trans-unit>
        <trans-unit id="22a73f9dccbade36d652d965f87a8dc414d1002a" translate="yes" xml:space="preserve">
          <source>A module is just a set of related functions in a library file, i.e., a Perl package with the same name as the file. It is specifically designed to be reusable by other modules or programs. It may do this by providing a mechanism for exporting some of its symbols into the symbol table of any package using it, or it may function as a class definition and make its semantics available implicitly through method calls on the class and its objects, without explicitly exporting anything. Or it can do a little of both.</source>
          <target state="translated">模块只是一个库文件中的一组相关函数,即与文件同名的Perl包。它被专门设计成可以被其他模块或程序重复使用。它可以通过提供一种机制来将它的一些符号导出到任何使用它的包的符号表中,或者它可以作为一个类定义,通过对类及其对象的方法调用来隐式地提供它的语义,而不显式地导出任何东西。或者它可以两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="e2c608d01740d058ca105f502acc61136af2e317" translate="yes" xml:space="preserve">
          <source>A module that breaks a program text into a sequence of &lt;b&gt;tokens&lt;/b&gt; for later analysis by a parser.</source>
          <target state="translated">将程序文本分解为&lt;b&gt;令牌&lt;/b&gt;序列以供解析器稍后分析的模块。</target>
        </trans-unit>
        <trans-unit id="a247d01be7fadaf27f2b9413690f6e9d188b0db4" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">一个模块，可以帮助您测试使用&lt;a href=&quot;../builder&quot;&gt;Test :: Builder构建的&lt;/a&gt;测试模块。</target>
        </trans-unit>
        <trans-unit id="5af87f8a65e9ecb41934ff3d4e29f132cd6922de" translate="yes" xml:space="preserve">
          <source>A module that helps you test testing modules that are built with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3605e1a22b2192fa5aa9baada403491f3d035bb2" translate="yes" xml:space="preserve">
          <source>A module that implements DOS-like globbing with a few enhancements. It is largely compatible with perlglob.exe (the M$ setargv.obj version) in all but one respect--it understands wildcards in directory components.</source>
          <target state="translated">一个实现类似于DOS的globbing的模块,并做了一些改进。除了一个方面之外,它在很大程度上与perlglob.exe(M$ setargv.obj版本)兼容--它能理解目录组件中的通配符。</target>
        </trans-unit>
        <trans-unit id="28b02d8f461ab26400c63c168a94b3b2407585a9" translate="yes" xml:space="preserve">
          <source>A module's code has to be warning and strict-clean, since you can't guarantee the conditions that it'll be used under. Besides, you wouldn't want to distribute code that wasn't warning or strict-clean anyway, right?</source>
          <target state="translated">一个模块的代码必须是警告和严格清洁的,因为你不能保证它在什么条件下被使用。此外,你也不会想发布不是警告或严格清洁的代码,对吧?</target>
        </trans-unit>
        <trans-unit id="c91f5a59bb26aa2af0fbaed73706b37f93fe9a63" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt; . See &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;IO-Compress-Zlib&lt;/code&gt; 模块包含用于读取/写入gzip文件/缓冲区的更完整，更灵活的界面。有关更多详细信息，请参见&lt;a href=&quot;../io/compress/gzip&quot;&gt;IO :: Compress :: Gzip&lt;/a&gt;和&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzip&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d54d0f134a7e139701b0fa7cb70f024a89595497" translate="yes" xml:space="preserve">
          <source>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &lt;code&gt;IO-Compress-Zlib&lt;/code&gt;. See &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; and &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47893a0d4c8d8763c8f1003ea95b492858375e4" translate="yes" xml:space="preserve">
          <source>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</source>
          <target state="translated">比较完整的例子是CPAN上的Shell模块,它可以把未定义的子程序调用当作对外部程序的调用。</target>
        </trans-unit>
        <trans-unit id="548a58ac3a8a4f644d16e2322da948be053c0188" translate="yes" xml:space="preserve">
          <source>A more dangerous version of getcwd(), but potentially faster.</source>
          <target state="translated">getcwd()的一个更危险的版本,但可能更快。</target>
        </trans-unit>
        <trans-unit id="9c501a7097bf538c4d236187aed836b438d78d12" translate="yes" xml:space="preserve">
          <source>A more dangerous, but potentially faster version of abs_path.</source>
          <target state="translated">一个更危险,但可能更快的abs_path版本。</target>
        </trans-unit>
        <trans-unit id="2fcc75b6685bd19dcf8c164fa65f41da165a633c" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7a13ddb80b2e7ad5a52fa1664ac4bd3c5aef4e" translate="yes" xml:space="preserve">
          <source>A more direct work around is to change the filehandles used by &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt;.</source>
          <target state="translated">更直接的解决方法是更改&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;使用的文件句柄。</target>
        </trans-unit>
        <trans-unit id="3f085d06d504bc04c8c1f364c54e3b2d32d488c0" translate="yes" xml:space="preserve">
          <source>A more elegant (and safer) interface is needed.</source>
          <target state="translated">需要一个更优雅(更安全)的界面。</target>
        </trans-unit>
        <trans-unit id="d906501834bb08ebb1263e2b0973fc289f4c913f" translate="yes" xml:space="preserve">
          <source>A more general approach is to intervene manually, as with an example for the DB_File module, which requires SleepyCat's libdb.sl:</source>
          <target state="translated">比较通用的方法是手动干预,比如DB_File模块的例子,需要SleepyCat的libdb.sl。</target>
        </trans-unit>
        <trans-unit id="a0a3703fe588fb0e60a0c01fcfb0d140fe8770a1" translate="yes" xml:space="preserve">
          <source>A more readable, and perhaps more &quot;plain&quot; way is to use an alternate set of delimiters that doesn't require a single &quot;&amp;gt;&quot; to be escaped. Doubled angle brackets (&quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;) may be used</source>
          <target state="translated">更具可读性，也许更简单的方法是使用另一组定界符，不需要转义单个&amp;ldquo;&amp;gt;&amp;rdquo;。可以使用双尖括号（&amp;ldquo; &amp;lt;&amp;lt;&amp;rdquo;和&amp;ldquo; &amp;gt;&amp;gt;&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="4f3108171bdddd798db1e9b26d8d770fd7116c20" translate="yes" xml:space="preserve">
          <source>A morpheme in a programming language, the smallest unit of text with semantic significance.</source>
          <target state="translated">编程语言中的一个语素,是具有语义意义的最小文本单位。</target>
        </trans-unit>
        <trans-unit id="2790cfc68a916af917f3cc04e172e9586561a9c1" translate="yes" xml:space="preserve">
          <source>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD</source>
          <target state="translated">在ASCII平台上,为了测试一个无BOM文件中的第一个高位字节序列(无论是代码还是Pod!),以确定该序列是否是有效的UTF-8(RFC 2279),一个天真的,但通常是充分的启发式方法是检查序列中的第一个字节是否在0xC2-0xFD的范围内。</target>
        </trans-unit>
        <trans-unit id="826c2733de66381609264a147718bd8a6dee2df5" translate="yes" xml:space="preserve">
          <source>A name for a concrete set of behaviors. A role is a way to add behavior to a class without inheritance.</source>
          <target state="translated">一组具体行为的名称。角色是将行为添加到类中而不需要继承的一种方式。</target>
        </trans-unit>
        <trans-unit id="6cc90f6ad3d71e4b26203e2d58a28aac467dba0f" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">代表打开目录以读取它直到关闭它的特定实例的名称。请参见 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f6c6fe92e40ceff3ff69d97ca9dd71043580f61d" translate="yes" xml:space="preserve">
          <source>A name that represents a particular instance of opening a directory to read it, until you close it. See the &lt;code&gt;opendir&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d4f638a5f1b060674c6232dbb757e9b9e2d99e" translate="yes" xml:space="preserve">
          <source>A name you give to a &lt;b&gt;statement&lt;/b&gt; so that you can talk about that statement elsewhere in the program.</source>
          <target state="translated">您为&lt;b&gt;语句指定的&lt;/b&gt;名称，以便您可以在程序的其他地方讨论该语句。</target>
        </trans-unit>
        <trans-unit id="c7a5f11c051d5e99d07f67bdaab9eaa5cf1c7964" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list concatenation version of the comma. That means it was never a list to start with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e963f1a0b66c9a6c01f8278ff2607d7847c7265" translate="yes" xml:space="preserve">
          <source>A named array in scalar context is quite different from what would at first glance appear to be a list in scalar context. You can't get a list like &lt;code&gt;(1,2,3)&lt;/code&gt; into being in scalar context, because the compiler knows the context at compile time. It would generate the scalar comma operator there, not the list construction version of the comma. That means it was never a list to start with.</source>
          <target state="translated">标量上下文中的命名数组与乍看之下似乎是标量上下文中的列表有很大不同。您不能将像 &lt;code&gt;(1,2,3)&lt;/code&gt; 这样的列表放入标量上下文中，因为编译器在编译时就知道该上下文。它将在此处生成标量逗号运算符，而不是逗号的列表构造版本。这意味着它从来都不是一个列表。</target>
        </trans-unit>
        <trans-unit id="ccb2fe3157763e6463fb7171376abf423c75879f" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt;. See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75daf7108ed110da5eff87e476f0ddf2290f10b8" translate="yes" xml:space="preserve">
          <source>A named capture group. Identical in every respect to normal capturing parentheses &lt;code&gt;()&lt;/code&gt; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &lt;code&gt;\g{NAME}&lt;/code&gt; ) and can be accessed by name after a successful match via &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; . See &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more details on the &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; hashes.</source>
          <target state="translated">命名捕获组。在各个方面与常规捕获括号 &lt;code&gt;()&lt;/code&gt; 相同，但另外一个事实是，该组可以在各种正则表达式构造中按名称引用（例如 &lt;code&gt;\g{NAME}&lt;/code&gt; ），并且可以通过 &lt;code&gt;%+&lt;/code&gt; 成功匹配后按名称进行访问或 &lt;code&gt;%-&lt;/code&gt; 。有关 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 哈希的更多详细信息，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="184923b65ef8ae0c8a3e87da3ade2989c9cad4ca" translate="yes" xml:space="preserve">
          <source>A named collection of data, usually stored on disk in a &lt;b&gt;directory&lt;/b&gt; in a &lt;b&gt;filesystem&lt;/b&gt;. Roughly like a document, if you&amp;rsquo;re into office metaphors. In modern filesystems, you can actually give a file more than one name. Some files have special properties, like directories and devices.</source>
          <target state="translated">命名数据集合，通常存储在磁盘上&lt;b&gt;文件系统&lt;/b&gt;&lt;b&gt;目录&lt;/b&gt;中。如果您喜欢办公室的隐喻，则大致像文档。在现代文件系统中，您实际上可以为一个文件指定多个名称。一些文件具有特殊的属性，例如目录和设备。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6a9ab3c01eb064a3661e1bb7b921e5b073d19ecd" translate="yes" xml:space="preserve">
          <source>A named or otherwise accessible piece of program that can be invoked from elsewhere in the program in order to accomplish some subgoal of the program. A subroutine is often parameterized to accomplish different but related things depending on its input &lt;b&gt;arguments&lt;/b&gt;. If the subroutine returns a meaningful &lt;b&gt;value&lt;/b&gt;, it is also called a &lt;b&gt;function&lt;/b&gt;.</source>
          <target state="translated">可以从程序中的其他地方调用的已命名或可访问的一段程序，以完成程序的某些子目标。子例程通常根据其输入&lt;b&gt;参数&lt;/b&gt;被参数化以完成不同但相关的事情。如果子例程返回有意义的&lt;b&gt;值&lt;/b&gt;，则它也称为&lt;b&gt;函数&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fd84ea80f8d7433a1aa60b125a9e6b4dc8885ca9" translate="yes" xml:space="preserve">
          <source>A named pipe (often referred to as a FIFO) is an old Unix IPC mechanism for processes communicating on the same machine. It works just like regular anonymous pipes, except that the processes rendezvous using a filename and need not be related.</source>
          <target state="translated">命名管道(通常被称为FIFO)是一种古老的Unix IPC机制,用于在同一台机器上进行通信的进程。它的工作原理和普通的匿名管道一样,只是进程之间使用一个文件名进行会合,而且不需要相关。</target>
        </trans-unit>
        <trans-unit id="1bcf4b5c3266b1cc1c63363a98c94938d5445b2f" translate="yes" xml:space="preserve">
          <source>A named pipe, created via &lt;code&gt;CreateNamedPipe&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0d06a3ea39fd5acfb66f824c51baebd59e34891" translate="yes" xml:space="preserve">
          <source>A named storage location that can hold any of various kinds of &lt;b&gt;value&lt;/b&gt;, as your program sees fit.</source>
          <target state="translated">程序认为合适的名称存储位置，可以保存各种&lt;b&gt;值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="092b494909d87658298161632e734b7420bfadba" translate="yes" xml:space="preserve">
          <source>A negatable option is specified with an exclamation mark &lt;code&gt;!&lt;/code&gt; after the option name:</source>
          <target state="translated">可否指定的选项带有感叹号 &lt;code&gt;!&lt;/code&gt; 选项名称后：</target>
        </trans-unit>
        <trans-unit id="99e2aec2990f88ba3867f8f52b0dfe7ccc80feb8" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; . The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="translated">甲否定表达，是否 &lt;code&gt;!(EXPR)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/not&quot;&gt;not(EXPR)&lt;/a&gt;&lt;/code&gt; ，或逻辑异或， &lt;code&gt;(EXPR1) &lt;a href=&quot;functions/xor&quot;&gt;xor&lt;/a&gt; (EXPR2)&lt;/code&gt; 。不包括按位版本（ &lt;code&gt;~&lt;/code&gt; 和 &lt;code&gt;^&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9d1e74169dd288f80b0a507b493221feacddf276" translate="yes" xml:space="preserve">
          <source>A negated expression, whether &lt;code&gt;!(EXPR)&lt;/code&gt; or &lt;code&gt;not(EXPR)&lt;/code&gt;, or a logical exclusive-or, &lt;code&gt;(EXPR1) xor (EXPR2)&lt;/code&gt;. The bitwise versions (&lt;code&gt;~&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;) are not included.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854efffaefa787b0da74283032eac82589c1370b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">负信号名称与负信号号相同，杀死进程组而不是进程。例如， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 会将 &lt;code&gt;SIGKILL&lt;/code&gt; 发送到指定的整个进程组。这意味着您通常要使用正信号而不是负信号。</target>
        </trans-unit>
        <trans-unit id="489423251916154fc8d55b14cad49fcf24beefc2" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="translated">负信号名称与负信号号相同，杀死进程组而不是进程。例如， &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; '-KILL', $pgrp&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;kill&quot;&gt;kill&lt;/a&gt; -9, $pgrp&lt;/code&gt; 会将 &lt;code&gt;SIGKILL&lt;/code&gt; 发送到指定的整个进程组。这意味着您通常要使用正信号而不是负信号。</target>
        </trans-unit>
        <trans-unit id="5839d6eebd6bf96dcf15322f2ba95d945cb0ed5b" translate="yes" xml:space="preserve">
          <source>A negative signal name is the same as a negative signal number, killing process groups instead of processes. For example, &lt;code&gt;kill '-KILL', $pgrp&lt;/code&gt; and &lt;code&gt;kill -9, $pgrp&lt;/code&gt; will send &lt;code&gt;SIGKILL&lt;/code&gt; to the entire process group specified. That means you usually want to use positive not negative signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7af62eb6dd0992f67ddc428ca2b71250ece618" translate="yes" xml:space="preserve">
          <source>A nested code block was found that started with a delimiter that was specified as being only to be used as an outermost bracket.</source>
          <target state="translated">发现了一个嵌套的代码块,该代码块以一个定界符开始,该定界符被指定为只能用作最外层的括号。</target>
        </trans-unit>
        <trans-unit id="ef68acbebe6cbfeffd4c2199fc642b8e08d6c12d" translate="yes" xml:space="preserve">
          <source>A network share.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adfb1c2f0e03b3f5c0a88fd5a3243fdba91d6307" translate="yes" xml:space="preserve">
          <source>A new Net::POP3 object must be created with the</source>
          <target state="translated">一个新的Net::POP3对象必须通过使用</target>
        </trans-unit>
        <trans-unit id="a6942aa9b1458599174d5fd62309534ead314562" translate="yes" xml:space="preserve">
          <source>A new Net::SMTP object must be created with the</source>
          <target state="translated">新的 Net::SMTP 对象必须用</target>
        </trans-unit>
        <trans-unit id="a156df59890d9311b601d33944f7c60f5c525f91" translate="yes" xml:space="preserve">
          <source>A new dumper is created by a call</source>
          <target state="translated">通过调用</target>
        </trans-unit>
        <trans-unit id="ce307d445764b039e813c87b536bf4d7ae071734" translate="yes" xml:space="preserve">
          <source>A new executable loads an extension compiled for the old executable when an old perl executable is running. In this case the extension will not pick up the forwarder - with fatal results.</source>
          <target state="translated">当一个旧的perl可执行文件运行时,新的可执行文件会加载为旧的可执行文件编译的扩展。在这种情况下,扩展将无法拾取转发器--结果是致命的。</target>
        </trans-unit>
        <trans-unit id="ebbd18c3575dd80f81d435a80fe2d3c8ed42ba76" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked
method&lt;/code&gt; . Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="translated">一种新功能，允许使用修饰符声明&lt;b&gt;变量&lt;/b&gt;和&lt;b&gt;子例程&lt;/b&gt;，如 &lt;code&gt;sub foo : locked method&lt;/code&gt; 。也是&lt;b&gt;对象&lt;/b&gt;的&lt;b&gt;实例变量&lt;/b&gt;的另一个名称。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c0543491269b3103c51b9af9cf33ea5cb5bbeafd" translate="yes" xml:space="preserve">
          <source>A new feature that allows the declaration of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; with modifiers, as in &lt;code&gt;sub foo : locked method&lt;/code&gt;. Also another name for an &lt;b&gt;instance variable&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc0af11825c345bf1ba555a00fc78d3675a49bab" translate="yes" xml:space="preserve">
          <source>A new version object can be created as a copy of an existing version object, either as a class method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e164afa95fb2ed837b476e0b8fef0b485a678f9f" translate="yes" xml:space="preserve">
          <source>A new version of the output file is always created, which inherits the structure and RMS attributes of the input file, except for owner and protections (and possibly timestamps; see below). All data from the input file is copied to the output file; if either of the first two parameters to &lt;code&gt;rmscopy&lt;/code&gt; is a file handle, its position is unchanged. (Note that this means a file handle pointing to the output file will be associated with an old version of that file after &lt;code&gt;rmscopy&lt;/code&gt; returns, not the newly created version.)</source>
          <target state="translated">始终创建一个新版本的输出文件，该文件继承了输入文件的结构和RMS属性，但所有者和保护（以及可能的时间戳；请参阅下文）除外。输入文件中的所有数据都将复制到输出文件中；如果 &lt;code&gt;rmscopy&lt;/code&gt; 的前两个参数之一是文件句柄，则其位置不变。 （请注意，这意味着指向输出文件的文件句柄将在 &lt;code&gt;rmscopy&lt;/code&gt; 返回后与该文件的旧版本相关联，而不是与新创建的版本相关联。）</target>
        </trans-unit>
        <trans-unit id="c0eacc7ea97ca14f2375b6edf715d33122368ca7" translate="yes" xml:space="preserve">
          <source>A nice general-purpose fixer-upper function for indented here documents follows. It expects to be called with a here document as its argument. It looks to see whether each line begins with a common substring, and if so, strips that substring off. Otherwise, it takes the amount of leading whitespace found on the first line and removes that much off each subsequent line.</source>
          <target state="translated">下面是一个很好的针对缩进 here 文档的通用固定器上位函数。它期望以一个 here 文档作为参数被调用。它查看每行是否以一个共同的子串开始,如果是,则将该子串剥离。否则,它将取第一行中的前导空格的数量,并从后面的每一行中删除该数量。</target>
        </trans-unit>
        <trans-unit id="0198bb3fbec60180f4c0bac09f0a4bb94105a46c" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration.</source>
          <target state="translated">某事物的昵称，其行为在所有方面都好像您使用的是原始名称而不是昵称一样。临时别名为循环变量隐式创建 &lt;code&gt;foreach&lt;/code&gt; 循环，在 &lt;code&gt;$_&lt;/code&gt; 变量 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 的运营商，在 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 期间 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 的比较函数，并且在各元件 &lt;code&gt;@_&lt;/code&gt; 用于&lt;b&gt;实际参数&lt;/b&gt; a的子程序调用。永久别名是通过&lt;b&gt;导入&lt;/b&gt;符号或通过分配给&lt;b&gt;typeglob&lt;/b&gt;在&lt;b&gt;包&lt;/b&gt;中显式创建的&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;。包变量的词法范围别名由 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 明显式创建。</target>
        </trans-unit>
        <trans-unit id="91ae023a14ec4220bee3363a586d5172c30ca7a4" translate="yes" xml:space="preserve">
          <source>A nickname for something, which behaves in all ways as though you&amp;rsquo;d used the original name instead of the nickname. Temporary aliases are implicitly created in the loop variable for &lt;code&gt;foreach&lt;/code&gt; loops, in the &lt;code&gt;$_&lt;/code&gt; variable for &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt; operators, in &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; during &lt;code&gt;sort&lt;/code&gt;&amp;rsquo;s comparison function, and in each element of &lt;code&gt;@_&lt;/code&gt; for the &lt;b&gt;actual arguments&lt;/b&gt; of a subroutine call. Permanent aliases are explicitly created in &lt;b&gt;packages&lt;/b&gt; by &lt;b&gt;importing&lt;/b&gt; symbols or by assignment to &lt;b&gt;typeglobs&lt;/b&gt;. Lexically scoped aliases for package variables are explicitly created by the &lt;code&gt;our&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1173dc0bd47411653c3329572e8d27b49fadacc" translate="yes" xml:space="preserve">
          <source>A no-op job.</source>
          <target state="translated">一个不靠谱的工作。</target>
        </trans-unit>
        <trans-unit id="fb1ec4028a0ac13b58d2706d78d6f0e42a16b590" translate="yes" xml:space="preserve">
          <source>A no-op job. Returned by &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; as an instruction to the harness to spin (keep executing tests) while the scheduler can't return a real job.</source>
          <target state="translated">没工作 由 &lt;code&gt;TAP::Parser::Scheduler&lt;/code&gt; 返回，作为在调度程序无法返回实际作业时旋转（保持执行测试）的线束的指令。</target>
        </trans-unit>
        <trans-unit id="7309346a0851b1fe75cb3e5cdad78936072ace5d" translate="yes" xml:space="preserve">
          <source>A non-empty Z&amp;lt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3187ac42757f3c2b53340569d4306b0db3207981" translate="yes" xml:space="preserve">
          <source>A non-optional prefix was specified but wasn't found at the start of the text.</source>
          <target state="translated">指定了一个非可选的前缀,但在文本的开头没有找到。</target>
        </trans-unit>
        <trans-unit id="f9ce11826e25a9f2a78731b7ee2ed1865f372e1a" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt; , not &lt;code&gt;79908&lt;/code&gt; :</source>
          <target state="translated">一个不太明显的警告（请参见[RT＃79908]）是该变量将立即内联，并且将停止像普通词法变量那样运行，例如，它将输出 &lt;code&gt;79907&lt;/code&gt; 而不是 &lt;code&gt;79908&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f08995644089d73bded5c431bbdb0a14a2ba0c4e" translate="yes" xml:space="preserve">
          <source>A not so obvious caveat with this (see [RT #79908]) is that the variable will be immediately inlined, and will stop behaving like a normal lexical variable, e.g. this will print &lt;code&gt;79907&lt;/code&gt;, not &lt;code&gt;79908&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33aa5e0c48db29d1cb8a94c57d888257eb0656f5" translate="yes" xml:space="preserve">
          <source>A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered. But this module has no way of knowing that. (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)</source>
          <target state="translated">这个方法有一个显著的、不可避免的问题。&quot;x-mingo-tom &quot;有一个 &quot;x&quot;,因为整个标签不是IANA注册的标签 --但super_languages('x-mingo-tom')是('x-mingo')--这其实并不正确,因为'i-mingo'已经注册了。但这个模块没有办法知道。(但请注意,same_language_tag('x-mingo','i-mingo')是TRUE。)</target>
        </trans-unit>
        <trans-unit id="11f822ddf21914cec4db6b8a6e4ef4d83bd0921c" translate="yes" xml:space="preserve">
          <source>A note about prefixes</source>
          <target state="translated">关于前缀的说明</target>
        </trans-unit>
        <trans-unit id="76a89e2dcaf10bf4c615af7db34f35d8d2e129e8" translate="yes" xml:space="preserve">
          <source>A note on derived files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c02a71990e114ae348bdc123412980dc80cfc" translate="yes" xml:space="preserve">
          <source>A note on freshness</source>
          <target state="translated">关于新鲜度的说明</target>
        </trans-unit>
        <trans-unit id="fabcf1ad8a30bffca7d5c34f9a41567038863f1c" translate="yes" xml:space="preserve">
          <source>A note: to save time, &quot;regular expression&quot; is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e5798976260679942afb564efdac5fe47bc36f" translate="yes" xml:space="preserve">
          <source>A note: to save time, 'regular expression' is often abbreviated as regexp or regex. Regexp is a more natural abbreviation than regex, but is harder to pronounce. The Perl pod documentation is evenly split on regexp vs regex; in Perl, there is more than one way to abbreviate it. We'll use regexp in this tutorial.</source>
          <target state="translated">注意:为了节省时间,&quot;正则表达式 &quot;通常被缩写为regexp或regex。Regexp是比regex更自然的缩写,但比较难发音。Perl pod 文档中对 regexp 与 regex 是平分秋色的,在 Perl 中,有不止一种缩写方式。在本教程中,我们将使用 regexp。</target>
        </trans-unit>
        <trans-unit id="7a28dfd2dad981af662c7cb062386ed614bc87a3" translate="yes" xml:space="preserve">
          <source>A notional &amp;ldquo;baton&amp;rdquo; handed around the Perl community indicating who is the lead integrator in some arena of development.</source>
          <target state="translated">在Perl社区周围有一个概念性的&amp;ldquo;警棍&amp;rdquo;，指示谁是某些开发领域的主要集成商。</target>
        </trans-unit>
        <trans-unit id="ab0d25629a9f27d8e2343a6d3ae7ea4be0af2ea6" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt; . Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt; . See also the &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">以16为底的数字，简称&amp;ldquo;十六进制&amp;rdquo;。10至15的数字通常由字母 &lt;code&gt;a&lt;/code&gt; 至 &lt;code&gt;f&lt;/code&gt; 表示。Perl中的十六进制常量以 &lt;code&gt;0x&lt;/code&gt; 开头。另请参见Camel第27章&amp;ldquo;函数&amp;rdquo;中的 &lt;code&gt;&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="f9e8cabeba10a3bcb61dba08b487b1b09e68f5dd" translate="yes" xml:space="preserve">
          <source>A number in base 16, &amp;ldquo;hex&amp;rdquo; for short. The digits for 10 through 15 are customarily represented by the letters &lt;code&gt;a&lt;/code&gt; through &lt;code&gt;f&lt;/code&gt;. Hexadecimal constants in Perl start with &lt;code&gt;0x&lt;/code&gt;. See also the &lt;code&gt;hex&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e5df9d465cc20aefe1124101a063a27122315b" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">以8为底​​的数字。仅允许使用数字0到7。Perl中的八进制常量从0开始，如013中所示。另请参见 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="8fa37e6f196e06e72c5f214ea85cb6255f2f8ebd" translate="yes" xml:space="preserve">
          <source>A number in base 8. Only the digits 0 through 7 are allowed. Octal constants in Perl start with 0, as in 013. See also the &lt;code&gt;oct&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69cd7220ef5a1c647fe095901d92bd9cd440d40" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">许多反斜杠序列与更改字符或跟随其后的字符有关。 &lt;code&gt;\l&lt;/code&gt; 将其后的字符小写，而 &lt;code&gt;\u&lt;/code&gt; 将其后的字符大写（或更准确地说，标题大写）。它们提供的功能类似于 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 的功能。</target>
        </trans-unit>
        <trans-unit id="93a2720acec49cfe060d50c7a0a7fff2508e38b0" translate="yes" xml:space="preserve">
          <source>A number of backslash sequences have to do with changing the character, or characters following them. &lt;code&gt;\l&lt;/code&gt; will lowercase the character following it, while &lt;code&gt;\u&lt;/code&gt; will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions &lt;code&gt;lcfirst&lt;/code&gt; and &lt;code&gt;ucfirst&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459b7ae43dc0118e5f951dff6050b593d0645ae4" translate="yes" xml:space="preserve">
          <source>A number of canned filers are provided with this module. They cover a number of the main areas that filters are needed when interfacing with DBM files. They also act as templates for your own filters.</source>
          <target state="translated">本模块提供了一些预制的过滤程序,它们涵盖了与DBM文件接口时需要过滤的一些主要领域。它们涵盖了与DBM文件接口时需要过滤器的一些主要领域。它们还可以作为您自己的过滤器的模板。</target>
        </trans-unit>
        <trans-unit id="f165970578836ece242fb56057dfca4b475f795a" translate="yes" xml:space="preserve">
          <source>A number of functions are supplied in</source>
          <target state="translated">中提供了一些函数。</target>
        </trans-unit>
        <trans-unit id="6be56084a39af168e51355bee3d9a2b6a1443404" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="4deb3640bfb1ba76e4eb91a284fff22ce6cde951" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f171c4c952b5198d03d74dd09582818a3af3ac23" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="3c0835dba02f363011b0b421bc52d49d766ce416" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8444a37c81d8d0b0573487ab107c561cc0dcc2fd" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="625cd39bbda422f4927006460178ed47c79bf138" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b8207ded75c4eb74b9b2506733acf10f3db4dee" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . None are imported by default.</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; 某些方法需要许多符号常量。默认情况下不会导入任何内容。</target>
        </trans-unit>
        <trans-unit id="81a3e04f06d43cad2f607ec957e7b72dedcb4f99" translate="yes" xml:space="preserve">
          <source>A number of symbolic constants are required by some methods in &lt;code&gt;IO::Compress::Zip&lt;/code&gt;. None are imported by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13520cd60b01e1d5b0a654b3de30cd8d691bfd72" translate="yes" xml:space="preserve">
          <source>A number of the perl self-tests fails for various reasons; generally these are minor and due to subtle differences between common POSIX-based environments and the OpenVOS POSIX environment. Ensure that you conduct sufficient testing of your code to guarantee that it works properly in the OpenVOS environment.</source>
          <target state="translated">一些perl自检失败的原因有很多,一般来说这些都是小问题,是由于常见的基于POSIX的环境和OpenVOS POSIX环境之间的微妙差异。确保你对你的代码进行充分的测试,以保证它在OpenVOS环境下正常工作。</target>
        </trans-unit>
        <trans-unit id="6938035226ed22bf21a82d2591890e65b71e1814" translate="yes" xml:space="preserve">
          <source>A number or quoted &lt;b&gt;string&lt;/b&gt;&amp;mdash;an actual &lt;b&gt;value&lt;/b&gt; in the text of your program, as opposed to a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">数字或带引号的&lt;b&gt;字符串&lt;/b&gt; - 程序文本中的实际&lt;b&gt;值&lt;/b&gt;，而不是&lt;b&gt;变量&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="817e0a226397234bf07db9517946a4f73aedf564" translate="yes" xml:space="preserve">
          <source>A number with no fractional (decimal) part. A counting number, like 1, 2, 3, and so on, but including 0 and the negatives.</source>
          <target state="translated">一个没有小数(十进制)的数字。一个数数,如1、2、3等,但包括0和负数。</target>
        </trans-unit>
        <trans-unit id="c7326b507f702c91b1651bab340f7fd9d1233ba7" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status</source>
          <target state="translated">与期望的退出状态相对应的数值。</target>
        </trans-unit>
        <trans-unit id="516dd9f40fab20fab164bbcf97c01e41beccb620" translate="yes" xml:space="preserve">
          <source>A numeric value corresponding to the desired exit status.</source>
          <target state="translated">与期望的退出状态相对应的数值。</target>
        </trans-unit>
        <trans-unit id="f65805b27975bd2ea9ebc728a7ffd9aba1dc2684" translate="yes" xml:space="preserve">
          <source>A one- or two-character abbreviation for the OP's name.</source>
          <target state="translated">上位者姓名的一个或两个字符的缩写。</target>
        </trans-unit>
        <trans-unit id="3834679d6aeef19dae7b1ac9263711aa538649cc" translate="yes" xml:space="preserve">
          <source>A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &lt;code&gt;get_content()&lt;/code&gt; on the &lt;code&gt;Archive::Tar::File&lt;/code&gt; object will return its content as a bytestring, not as a Unicode string.</source>
          <target state="translated">如果从压缩包中提取UTF8编码的文件，则会出现相反的问题。在 &lt;code&gt;Archive::Tar::File&lt;/code&gt; 对象上使用 &lt;code&gt;get_content()&lt;/code&gt; 会将其内容作为字节字符串而不是Unicode字符串返回。</target>
        </trans-unit>
        <trans-unit id="d534bb490c9aaec5af5d234ddc4047716ba79bca" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; on, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d591c8e0c3b224f857fbffdd8e1cd395cd343c4" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package语句仅影响动态变量，包括您在 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 使用的变量，但是</target>
        </trans-unit>
        <trans-unit id="fb0a21b3a9fa52dc9e4b76474cd2a329094bf2cb" translate="yes" xml:space="preserve">
          <source>A package statement affects dynamic variables only, including those you've used &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on, but</source>
          <target state="translated">package语句仅影响动态变量，包括您在 &lt;code&gt;&lt;a href=&quot;local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 使用的变量，但是</target>
        </trans-unit>
        <trans-unit id="17811bc7788393455d0445378861485836290fe5" translate="yes" xml:space="preserve">
          <source>A packet of data, such as a &lt;b&gt;UDP&lt;/b&gt; message, that (from the viewpoint of the programs involved) can be sent independently over the network. (In fact, all packets are sent independently at the &lt;b&gt;IP&lt;/b&gt; level, but &lt;b&gt;stream&lt;/b&gt; protocols such as &lt;b&gt;TCP&lt;/b&gt; hide this from your program.)</source>
          <target state="translated">数据包，例如&lt;b&gt;UDP&lt;/b&gt;消息，可以从网络上独立发送（从所涉及程序的角度来看）。（实际上，所有数据包都是在&lt;b&gt;IP&lt;/b&gt;级别上独立发送的，但是&lt;b&gt;TCP&lt;/b&gt;等&lt;b&gt;流&lt;/b&gt;协议&lt;b&gt;会将其&lt;/b&gt;隐藏在程序中。）</target>
        </trans-unit>
        <trans-unit id="41fc1fe8da73d2058878cb04079cedd356502e52" translate="yes" xml:space="preserve">
          <source>A parameter list for the constructor is a hash, which can include a special key &lt;code&gt;locale&lt;/code&gt; and its value (case-insensitive) standing for a Unicode base language code (two or three-letter). For example, &lt;code&gt;Unicode::Collate::Locale-&amp;gt;new(locale =&amp;gt; 'ES')&lt;/code&gt; returns a collator tailored for Spanish.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8fade7e7e6957062a1ff55f1cde07bb98b07451" translate="yes" xml:space="preserve">
          <source>A parenthesized &lt;b&gt;subpattern&lt;/b&gt; used to group parts of a &lt;b&gt;regular expression&lt;/b&gt; into a single &lt;b&gt;atom&lt;/b&gt;.</source>
          <target state="translated">括号内的&lt;b&gt;子模式，&lt;/b&gt;用于将&lt;b&gt;正则表达式的&lt;/b&gt;部分分组为一个&lt;b&gt;原子&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d31a105759b488881233b964b8bc299b268f919f" translate="yes" xml:space="preserve">
          <source>A particular 8-bit extension to ASCII that includes grave and acute accented Latin characters. Languages that can employ ISO 8859-1 include all the languages covered by ASCII as well as Afrikaans, Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, Portuguese, Spanish, and Swedish. Dutch is covered albeit without the ij ligature. French is covered too but without the oe ligature. German can use ISO 8859-1 but must do so without German-style quotation marks. This set is based on Western European extensions to ASCII and is commonly encountered in world wide web work. In IBM character code set identification terminology, ISO 8859-1 is also known as CCSID 819 (or sometimes 0819 or even 00819).</source>
          <target state="translated">ASCII码的一种特殊的8位扩展,包括重音和锐音拉丁字符。可以使用ISO 8859-1的语言包括ASCII所涵盖的所有语言,以及南非荷兰语、阿尔巴尼亚语、巴斯克语、加泰罗尼亚语、丹麦语、法罗语、芬兰语、挪威语、葡萄牙语、西班牙语和瑞典语。荷兰语也被覆盖了,尽管没有ij连接符。法文也包括在内,但没有oe连接符。德语可以使用ISO 8859-1,但必须不使用德式引号。这套字符集是基于西欧对ASCII的扩展,在世界范围内的网络工作中经常遇到。在IBM字符码集识别术语中,ISO 8859-1也被称为CCSID 819(有时也称为0819甚至00819)。</target>
        </trans-unit>
        <trans-unit id="e0e8dc4da39b64602467413f10af7327c1334e77" translate="yes" xml:space="preserve">
          <source>A past developer of this module once said that it was no longer being actively developed. However, rumors of its demise were greatly exaggerated. Feedback and suggestions are quite welcome.</source>
          <target state="translated">该模块过去的一位开发者曾经说过,它已经不再积极开发了。然而,关于它消亡的传言被大大夸大了。我们相当欢迎反馈和建议。</target>
        </trans-unit>
        <trans-unit id="8c54ff10ac1e2c9e724650394df49761e14faa10" translate="yes" xml:space="preserve">
          <source>A patch is likely to be rejected if it closes off future avenues of development. For instance, a patch that placed a true and final interpretation on prototypes is likely to be rejected because there are still options for the future of prototypes that haven't been addressed.</source>
          <target state="translated">如果一个补丁关闭了未来的发展途径,那么它很可能会被拒绝。例如,一个对原型进行真实和最终解释的补丁很可能被拒绝,因为仍有关于原型的未来选择没有得到解决。</target>
        </trans-unit>
        <trans-unit id="8b84380ed4a63c4a53b35f4fed5c94c1acb30451" translate="yes" xml:space="preserve">
          <source>A pattern that contains one or more variables to be interpolated before parsing the pattern as a &lt;b&gt;regular expression&lt;/b&gt;, and that therefore cannot be analyzed at compile time, but must be reanalyzed each time the pattern match operator is evaluated. Runtime patterns are useful but expensive.</source>
          <target state="translated">一种模式，该模式包含一个或多个要在将模式解析为&lt;b&gt;正则表达式&lt;/b&gt;之前要进行插值的变量，因此无法在编译时进行分析，但是每次对模式匹配运算符进行求值时都必须重新分析。运行时模式有用但很昂贵。</target>
        </trans-unit>
        <trans-unit id="e54b749fa56abf529dd225e42a12bbcecb4cb20e" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt; ). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;/u&lt;/code&gt; 或 &lt;code&gt;/a&lt;/code&gt; 修饰符编译的模式被视为Unicode（尽管 &lt;code&gt;/a&lt;/code&gt; 有所限制）。在 &lt;code&gt;/d&lt;/code&gt; 和 &lt;code&gt;/l&lt;/code&gt; 修饰符下，还有其他几种Unicode指示：请参见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;perlre中的字符集修饰符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c44383cd9d72dfa1b63f63e5ddbda12ce021d43c" translate="yes" xml:space="preserve">
          <source>A pattern that is compiled with the &lt;code&gt;/u&lt;/code&gt; or &lt;code&gt;/a&lt;/code&gt; modifiers is treated as Unicode (though there are some restrictions with &lt;code&gt;/a&lt;/code&gt;). Under the &lt;code&gt;/d&lt;/code&gt; and &lt;code&gt;/l&lt;/code&gt; modifiers, there are several other indications for Unicode; see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;&quot;Character set modifiers&quot; in perlre&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac81362ffb97f570e29dfbe7c502b0eb97a9aae0" translate="yes" xml:space="preserve">
          <source>A person with permissions to index a &lt;b&gt;namespace&lt;/b&gt; in &lt;b&gt;PAUSE&lt;/b&gt;. Anyone can upload any namespace, but only primary and co-maintainers get their contributions indexed.</source>
          <target state="translated">有权在&lt;b&gt;PAUSE中&lt;/b&gt;索引&lt;b&gt;名称空间&lt;/b&gt;的人。任何人都可以上载任何名称空间，但只有主要和共同维护者才能对其贡献进行索引。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9102b11ae3e872fd1d8e80bc53ef699d92261f27" translate="yes" xml:space="preserve">
          <source>A phrase is a function; a phrasebook is a bunch of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf584f5364a06bf31c21ab092ad59923872f304" translate="yes" xml:space="preserve">
          <source>A pidgin-like lingo spoken among &amp;rsquo;droids when they don&amp;rsquo;t wish to reveal their orientation (see &lt;b&gt;endian&lt;/b&gt;). Named after some similar languages spoken (for similar reasons) between compilers and interpreters in the late 20ᵗʰ century. These languages are characterized by representing everything as a nonarchitecture-dependent sequence of bytes.</source>
          <target state="translated">当机器人不希望透露自己的方位时，它们会在&amp;ldquo;机器人&amp;rdquo;中说出一种类似pidgin的术语（请参见&lt;b&gt;endian&lt;/b&gt;）。以20世纪末期在编译器和解释器之间（出于类似原因）使用的一些类似语言命名。这些语言的特征是将所有内容都表示为与体系结构无关的字节序列。</target>
        </trans-unit>
        <trans-unit id="d44cad0ebf83404ba135e65877b0a7348740b15c" translate="yes" xml:space="preserve">
          <source>A piece of &lt;b&gt;memory&lt;/b&gt; accessible by two different &lt;b&gt;processes&lt;/b&gt; who otherwise would not see each other&amp;rsquo;s memory.</source>
          <target state="translated">由两个不同&lt;b&gt;进程&lt;/b&gt;访问的一块&lt;b&gt;内存&lt;/b&gt;，否则它们将不会看到彼此的内存。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ae75b42221a978d2300d9bbb31da21cdb6583f30" translate="yes" xml:space="preserve">
          <source>A piece of data supplied to a &lt;b&gt;program&lt;/b&gt;, &lt;b&gt;subroutine&lt;/b&gt;, &lt;b&gt;function&lt;/b&gt;, or &lt;b&gt;method&lt;/b&gt; to tell it what it&amp;rsquo;s supposed to do. Also called a &amp;ldquo;parameter&amp;rdquo;.</source>
          <target state="translated">提供给&lt;b&gt;program&lt;/b&gt;，&lt;b&gt;subroutine&lt;/b&gt;，&lt;b&gt;function&lt;/b&gt;或&lt;b&gt;method&lt;/b&gt;的一段数据，告诉它应该做什么。也称为&amp;ldquo;参数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="94f70c32cf9b02415f8a7273bc9818046dbf12f7" translate="yes" xml:space="preserve">
          <source>A piece of data worth eight &lt;b&gt;bits&lt;/b&gt; in most places.</source>
          <target state="translated">一个数据值得八个&lt;b&gt;位&lt;/b&gt;最多的地方。</target>
        </trans-unit>
        <trans-unit id="b577f26c3053457a977acc838db8d07639cc6ac7" translate="yes" xml:space="preserve">
          <source>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example &lt;code&gt;|&lt;/code&gt;:</source>
          <target state="translated">当fallback为TRUE并且Perl求助于运算符的内置实现时，一个陷阱是某些运算符具有多个语义，例如 &lt;code&gt;|&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d50a84892f70340bd3a9931b241841288e99df2a" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; implies &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; . Note that &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are not enabled by default. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; requires the optional &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt; below for more details.</source>
          <target state="translated">普通 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie&lt;/code&gt; 意味着 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; autodie qw(:default)&lt;/code&gt; 。请注意，默认情况下未启用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 需要安装可选的&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;模块，并且启用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 将使它们的奇特形式无效。见&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;以下更多的细节。</target>
        </trans-unit>
        <trans-unit id="784586eba74e7681571d441503dffdaa38283f14" translate="yes" xml:space="preserve">
          <source>A plain &lt;code&gt;use autodie&lt;/code&gt; implies &lt;code&gt;use autodie qw(:default)&lt;/code&gt;. Note that &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are not enabled by default. &lt;code&gt;system&lt;/code&gt; requires the optional &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to be installed, and enabling &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; will invalidate their exotic forms. See &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt; below for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5112ffa79f8fbea8b85cd379c0dac6621cfbb1b" translate="yes" xml:space="preserve">
          <source>A port of SysV IPC is available for Cygwin.</source>
          <target state="translated">SysV IPC的移植版可用于Cygwin。</target>
        </trans-unit>
        <trans-unit id="608e0fee3c4504f82197f6257599cc064afc0c33" translate="yes" xml:space="preserve">
          <source>A port of dmake for Windows is available from:</source>
          <target state="translated">Windows 的 dmake 移植版可以从以下地方获得。</target>
        </trans-unit>
        <trans-unit id="107ead699a34a6b92016575e257f6bfde51b2d06" translate="yes" xml:space="preserve">
          <source>A portion of a &lt;b&gt;string&lt;/b&gt;, starting at a certain &lt;b&gt;character&lt;/b&gt; position (&lt;b&gt;offset&lt;/b&gt;) and proceeding for a certain number of characters.</source>
          <target state="translated">&lt;b&gt;字符串&lt;/b&gt;的一部分，从某个&lt;b&gt;字符&lt;/b&gt;位置（&lt;b&gt;offset&lt;/b&gt;）开始并进行一定数量的字符。</target>
        </trans-unit>
        <trans-unit id="2df08b2dab9ca8b1fdefb915b96c623e0200cba0" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt; :</source>
          <target state="translated">通过提供默认值使位置参数成为可选参数，该默认值与参数名称之间用 &lt;code&gt;=&lt;/code&gt; 分隔：</target>
        </trans-unit>
        <trans-unit id="0b4ce78434f00859636eea671cd22aebe6d9b1f5" translate="yes" xml:space="preserve">
          <source>A positional parameter is made optional by giving a default value, separated from the parameter name by &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b85d6bf4f6c4fdd5d60e077f21d5dcceb61dc47f" translate="yes" xml:space="preserve">
          <source>A possibly-threaded program using a possibly-threaded module might have code like this:</source>
          <target state="translated">一个使用可能线程模块的可能线程程序可能有这样的代码。</target>
        </trans-unit>
        <trans-unit id="d97df54b4f20c3925188511860c47d716ece4831" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#%28%3F%3Epattern%29&quot;&gt;&quot;&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt;&quot;&lt;/a&gt;). Note also that zero-length lookahead/lookbehind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of lookahead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3a72b5c10540ed557a8982bdee312dd7a07842" translate="yes" xml:space="preserve">
          <source>A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &lt;a href=&quot;#(%3f%3epattern)&quot;&gt;(?&amp;gt;pattern)&lt;/a&gt;). Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant. For an example where side-effects of look-ahead</source>
          <target state="translated">用于优化此类野兽的强大工具是所谓的&amp;ldquo;独立组&amp;rdquo;，它不会回溯（请参阅&lt;a href=&quot;#(%3f%3epattern)&quot;&gt;（？&amp;gt; pattern）&lt;/a&gt;）。还要注意，零长度的超前/后向断言不会回溯以使尾部匹配，因为它们处于&amp;ldquo;逻辑&amp;rdquo;上下文中：仅认为它们是否匹配才有意义。例如，前瞻的副作用</target>
        </trans-unit>
        <trans-unit id="f8090f10d3e078e45a1b56ad19ca0993e67735bf" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt; . With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="translated">编译指示是一个模块，它会影响Perl的编译时或运行时行为的某些方面，例如 &lt;code&gt;strict&lt;/code&gt; 或 &lt;code&gt;warnings&lt;/code&gt; 。使用Perl 5.10，您将不再局限于内置的编译指示。您现在可以创建用户语用表，以在词法范围内修改用户功能的行为。</target>
        </trans-unit>
        <trans-unit id="49eb60196e1bcc3fb82f50394c222a091a65381b" translate="yes" xml:space="preserve">
          <source>A pragma is a module which influences some aspect of the compile time or run time behaviour of Perl, such as &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;warnings&lt;/code&gt;. With Perl 5.10 you are no longer limited to the built in pragmata; you can now create user pragmata that modify the behaviour of user functions within a lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3adf63746ff6644ce7bf5f35f924e0b644796838" translate="yes" xml:space="preserve">
          <source>A precomputed hash value for the MRO's name, or 0.</source>
          <target state="translated">MRO名称的预计算哈希值,或0。</target>
        </trans-unit>
        <trans-unit id="fef186fd41bd258794b7d0075ad4e261c2b3c05f" translate="yes" xml:space="preserve">
          <source>A predefined &lt;b&gt;character class&lt;/b&gt; matchable by the &lt;code&gt;\p&lt;/code&gt; or &lt;code&gt;\P&lt;/code&gt;&lt;b&gt;metasymbol&lt;/b&gt;. &lt;b&gt;Unicode&lt;/b&gt; defines hundreds of standard properties for every possible codepoint, and Perl defines a few of its own, too.</source>
          <target state="translated">可通过 &lt;code&gt;\p&lt;/code&gt; 或 &lt;code&gt;\P&lt;/code&gt; &lt;b&gt;元符号&lt;/b&gt;匹配的预定义&lt;b&gt;字符类&lt;/b&gt;。&lt;b&gt;Unicode&lt;/b&gt;为每个可能的代码点定义了数百个标准属性，而Perl也定义了一些它自己的属性。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a831506546d580a7eadbcde59099e4315b6e4d7c" translate="yes" xml:space="preserve">
          <source>A prerequisite for any of the SDKs is to install ActivePerl from ActiveState, &lt;a href=&quot;http://www.activestate.com/Products/ActivePerl/&quot;&gt;http://www.activestate.com/Products/ActivePerl/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="753111eab29b1d3a3d48d9bfe5c8e1db8a75f990" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvIVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvIVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="194c1f16db6963ad188c9a67ab4a97692452c7d0" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvNVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvNVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="45f81efd0665fe345ae1ff71f7dc78b1d8a8b9cf" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPV&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPV&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="28ff9ef13649ddfcf7cbf759240331fcc05c09ec" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVbyte&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVbyte&lt;/code&gt; 宏的私有实现，用于无法应对复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="4c48a8487b346d5dd9b069a77af5f464c4aaa911" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvPVutf8&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvPVutf8&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="ccefc2a8adb4ddac3b369c74930a6dbb95e32f5b" translate="yes" xml:space="preserve">
          <source>A private implementation of the &lt;code&gt;SvUVx&lt;/code&gt; macro for compilers which can't cope with complex macro expressions. Always use the macro instead.</source>
          <target state="translated">&lt;code&gt;SvUVx&lt;/code&gt; 宏的私有实现，用于无法应付复杂的宏表达式的编译器。始终改用宏。</target>
        </trans-unit>
        <trans-unit id="daa3f361ccd92e0c8c69a72e7a450ec455f808bd" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="translated">已死（退出）但其父进程尚未通过调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 来接收其死亡的适当通知的进程。如果 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; ，则必须在子进程退出后清理。否则，进程表将填满，您的系统管理员将对您不满意。</target>
        </trans-unit>
        <trans-unit id="10a925aa1992fe1dac52557b4ea82e693d886104" translate="yes" xml:space="preserve">
          <source>A process that has died (exited) but whose parent has not yet received proper notification of its demise by virtue of having called &lt;code&gt;wait&lt;/code&gt; or &lt;code&gt;waitpid&lt;/code&gt;. If you &lt;code&gt;fork&lt;/code&gt;, you must clean up after your child processes when they exit; otherwise, the process table will fill up and your system administrator will Not Be Happy with you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efafe66eae216a82a4ad38f05565ca385de1f6b" translate="yes" xml:space="preserve">
          <source>A process that usually starts when the system boots and shuts down when the system is shut down is called a daemon (Disk And Execution MONitor). If a daemon process has a configuration file which is modified after the process has been started, there should be a way to tell that process to reread its configuration file without stopping the process. Many daemons provide this mechanism using a &lt;code&gt;SIGHUP&lt;/code&gt; signal handler. When you want to tell the daemon to reread the file, simply send it the &lt;code&gt;SIGHUP&lt;/code&gt; signal.</source>
          <target state="translated">通常在系统启动时启动，而在系统关闭时关闭的进程称为守护程序（磁盘和执行监视器）。如果守护进程具有在启动进程后被修改的配置文件，则应该有一种方法告诉该进程在不停止该进程的情况下重新读取其配置文件。许多守护程序使用 &lt;code&gt;SIGHUP&lt;/code&gt; 信号处理程序提供此机制。当您要告诉守护程序重新读取文件时，只需发送 &lt;code&gt;SIGHUP&lt;/code&gt; 信号即可。</target>
        </trans-unit>
        <trans-unit id="2cb736d823d351c183302791cfaf0e9b2bb8195b" translate="yes" xml:space="preserve">
          <source>A program designed to take a &lt;b&gt;stream&lt;/b&gt; of input and transform it into a stream of output.</source>
          <target state="translated">一种旨在获取输入&lt;b&gt;流&lt;/b&gt;并将其转换为输出流的程序。</target>
        </trans-unit>
        <trans-unit id="0e57854f673e33842a3f502762fb9daa3a8e1f70" translate="yes" xml:space="preserve">
          <source>A program or subroutine that runs some other program or subroutine for you, modifying some of its input or output to better suit your purposes.</source>
          <target state="translated">一个为你运行其他程序或子程序的程序或子程序,修改它的一些输入或输出以更好地满足你的目的。</target>
        </trans-unit>
        <trans-unit id="d4949b399696681050e02e3aa6d195b375c7c318" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt; . See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">一种编程技术，可让您评估&lt;b&gt;表达式&lt;/b&gt;，然后根据&lt;b&gt;表达式&lt;/b&gt;的值对该值执行适当的代码多路跳转。也称为&amp;ldquo;案例结构&amp;rdquo;，以类似的Pascal构造命名。Perl中的大多数switch语句都是拼写 &lt;code&gt;given&lt;/code&gt; 。请参见骆驼第4章&amp;ldquo;声明和声明&amp;rdquo;中的&amp;ldquo; &lt;code&gt;given&lt;/code&gt; 声明&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="226a5640a6bc542b475e6c67b50cca7825517b1f" translate="yes" xml:space="preserve">
          <source>A program technique that lets you evaluate an &lt;b&gt;expression&lt;/b&gt; and then, based on the value of the expression, do a multiway branch to the appropriate piece of code for that value. Also called a &amp;ldquo;case structure&amp;rdquo;, named after the similar Pascal construct. Most switch statements in Perl are spelled &lt;code&gt;given&lt;/code&gt;. See &amp;ldquo;The &lt;code&gt;given&lt;/code&gt; statement&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5911c3911da879ac96181b5190227b6bb058fcf1" translate="yes" xml:space="preserve">
          <source>A program that lets you step through the &lt;b&gt;execution&lt;/b&gt; of your program, stopping or printing things out here and there to see whether anything has gone wrong, and, if so, what. The &amp;ldquo;symbolic&amp;rdquo; part just means that you can talk to the debugger using the same symbols with which your program is written.</source>
          <target state="translated">一个程序，可让您逐步&lt;b&gt;执行&lt;/b&gt;程序，在此处或此处停止或打印内容，以查看是否出了什么问题，如果出了错，怎么办。&amp;ldquo;符号&amp;rdquo;部分仅表示您可以使用与编写程序时相同的符号与调试器对话。</target>
        </trans-unit>
        <trans-unit id="e0a439842f796bec28d81800d0c2072dc425e000" translate="yes" xml:space="preserve">
          <source>A property may be deprecated, perhaps because its original intent has been replaced by another property, or because its specification was somehow defective. This means that its use is strongly discouraged, so much so that a warning will be issued if used, unless the regular expression is in the scope of a &lt;code&gt;no warnings 'deprecated'&lt;/code&gt; statement. A '&lt;b&gt;D&lt;/b&gt;' flags each such entry in the table, and the entry there for the longest, most descriptive version of the property will give the reason it is deprecated, and perhaps advice. Perl may issue such a warning, even for properties that aren't officially deprecated by Unicode, when there used to be characters or code points that were matched by them, but no longer. This is to warn you that your program may not work like it did on earlier Unicode releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ccfd6a1d722c44d4bb4f0ae8561be32c66dd88" translate="yes" xml:space="preserve">
          <source>A property may be stabilized. Such a determination does not indicate that the property should or should not be used; instead it is a declaration that the property will not be maintained nor extended for newly encoded characters. Such properties are marked with an '&lt;b&gt;S&lt;/b&gt;' in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8959e21bc141d47a80e97a7ffb793dfa86254ad0" translate="yes" xml:space="preserve">
          <source>A property named 'var' is assumed to exist for the opcodes, and is interpolated into the rendering.</source>
          <target state="translated">一个名为'var'的属性被假定为存在于操作码中,并被内插到渲染中。</target>
        </trans-unit>
        <trans-unit id="7afee4b0974cba3382e7bb4183222667ce915680" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt; ), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt; ), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt; ). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="translated">某些字符的属性。最初，排字员在两种情况的上部存储大写字母，在下部的情况下存储小写字母。 Unicode的识别三种情况：&lt;b&gt;小写&lt;/b&gt;（&lt;b&gt;字符属性&lt;/b&gt; &lt;code&gt;\p{lower}&lt;/code&gt; ），&lt;b&gt;首字母大写&lt;/b&gt;（ &lt;code&gt;\p{title}&lt;/code&gt; ），和&lt;b&gt;大写&lt;/b&gt;（ &lt;code&gt;\p{upper}&lt;/code&gt; ）。第四种名为&lt;b&gt;foldcase的casemapping&lt;/b&gt;本身并不是一个不同的情况，但是在内部用于实现&lt;b&gt;casefolding&lt;/b&gt;。并非所有字母都有大小写，有些非字母也有大小写。</target>
        </trans-unit>
        <trans-unit id="33b899d68b6367eee5e01ad07784bbb907d587b3" translate="yes" xml:space="preserve">
          <source>A property of certain characters. Originally, typesetter stored capital letters in the upper of two cases and small letters in the lower one. Unicode recognizes three cases: &lt;b&gt;lowercase&lt;/b&gt; (&lt;b&gt;character property&lt;/b&gt;&lt;code&gt;\p{lower}&lt;/code&gt;), &lt;b&gt;titlecase&lt;/b&gt; (&lt;code&gt;\p{title}&lt;/code&gt;), and &lt;b&gt;uppercase&lt;/b&gt; (&lt;code&gt;\p{upper}&lt;/code&gt;). A fourth casemapping called &lt;b&gt;foldcase&lt;/b&gt; is not itself a distinct case, but it is used internally to implement &lt;b&gt;casefolding&lt;/b&gt;. Not all letters have case, and some nonletters have case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="992dca0adb9b646b76591cb61fee4cdfffebc9ec" translate="yes" xml:space="preserve">
          <source>A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Note that &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; only works on real layers and will not undo the effects of pseudo layers like &lt;code&gt;:utf8&lt;/code&gt; . An example of a possible use might be:</source>
          <target state="translated">删除最顶层的伪层。为perl代码提供一种操纵层堆栈的方法。请注意 &lt;code&gt;:&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 仅在真实图层上起作用，并且不会撤消伪图层如 &lt;code&gt;:utf8&lt;/code&gt; 的影响。可能的用法示例如下：</target>
        </trans-unit>
        <trans-unit id="e9e574b20ec44e2ea9a82161cd9d396ddf6c16be" translate="yes" xml:space="preserve">
          <source>A pseudo-layer that removes the top-most layer. Gives Perl code a way to manipulate the layer stack. Note that &lt;code&gt;:pop&lt;/code&gt; only works on real layers and will not undo the effects of pseudo-layers or flags like &lt;code&gt;:utf8&lt;/code&gt;. An example of a possible use might be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff419cc31e5dd99b3e00b537155bcea526bbe610" translate="yes" xml:space="preserve">
          <source>A pseudolayer that enables a flag in the layer below to tell Perl that output should be in utf8 and that input should be regarded as already in valid utf8 form. &lt;b&gt;WARNING: It does not check for validity and as such should be handled with extreme caution for input, because security violations can occur with non-shortest UTF-8 encodings, etc.&lt;/b&gt; Generally &lt;code&gt;:encoding(utf8)&lt;/code&gt; is the best option when reading UTF-8 encoded data.</source>
          <target state="translated">一个伪层，它使下面一层中的标记能够告诉Perl输出应该在utf8中，并且应该认为输入已经是有效的utf8形式。&lt;b&gt;警告：它不会检查有效性，因此输入时应格外谨慎，因为使用非最短的UTF-8编码等可能会发生安全违规。&lt;/b&gt;通常 &lt;code&gt;:encoding(utf8)&lt;/code&gt; 是读取UTF-时的最佳选择8个编码数据。</target>
        </trans-unit>
        <trans-unit id="c46a1417af942e441ec740293a77160106782547" translate="yes" xml:space="preserve">
          <source>A pseudolayer that manipulates other layers. Applying the &lt;code&gt;:raw&lt;/code&gt; layer is equivalent to calling &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt;. It makes the stream pass each byte as-is without translation. In particular, both CRLF translation and intuiting &lt;code&gt;:utf8&lt;/code&gt; from the locale are disabled.</source>
          <target state="translated">操纵其他层的伪层。应用 &lt;code&gt;:raw&lt;/code&gt; 层等效于调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode($fh)&lt;/a&gt;&lt;/code&gt; 。它使流按原样传递每个字节而无需转换。特别是，CRLF转换和从区域设置intuiting &lt;code&gt;:utf8&lt;/code&gt; 均被禁用。</target>
        </trans-unit>
        <trans-unit id="fefe2bbba2d7bf83c98ed3d05237098307bf7f4b" translate="yes" xml:space="preserve">
          <source>A pseudolayer that turns the &lt;code&gt;:utf8&lt;/code&gt; flag</source>
          <target state="translated">伪造的 &lt;code&gt;:utf8&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="ecc09e716a2c2d18e2be806f7183c30c2f3b51c2" translate="yes" xml:space="preserve">
          <source>A psychoactive drug, popular in the &amp;rsquo;80s, probably developed at UC Berkeley or thereabouts. Similar in many ways to the prescription-only medication called &amp;ldquo;System V&amp;rdquo;, but infinitely more useful. (Or, at least, more fun.) The full chemical name is &amp;ldquo;Berkeley Standard Distribution&amp;rdquo;.</source>
          <target state="translated">一种在80年代流行的精神活性药物，很可能是在加州大学伯克利分校或其附近开发的。在许多方面与称为&amp;ldquo;系统V&amp;rdquo;的仅处方药相似，但无限有用。（或者至少更有趣。）化学名称的全称是&amp;ldquo;伯克利标准分布&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b62f9f104139d9b8c4e453ea5b9cd7a8ac0140f4" translate="yes" xml:space="preserve">
          <source>A public function (i.e. part of the internal API, but not necessarily sanctioned for use in extensions) begins like this:</source>
          <target state="translated">一个公共函数(即内部API的一部分,但不一定允许在扩展中使用)像这样开始。</target>
        </trans-unit>
        <trans-unit id="1fcfaef1b89a51f30ffb896e8c738cde9ef6077c" translate="yes" xml:space="preserve">
          <source>A pull-parser interface to parsing Pod</source>
          <target state="translated">一个用于解析Pod的拉式解析器接口。</target>
        </trans-unit>
        <trans-unit id="ce01020c3704b898a0c0774b915a9978c7a43b90" translate="yes" xml:space="preserve">
          <source>A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on. That's psychology....</source>
          <target state="translated">之所以选择问号和最小匹配构造,是因为:1)问号在旧的正则表达式中很少见,2)每当看到问号,你就应该停下来,&quot;质疑 &quot;到底发生了什么。这就是心理学....</target>
        </trans-unit>
        <trans-unit id="7af52ef72c21fce506c2fc73241d0f35d841b4ef" translate="yes" xml:space="preserve">
          <source>A queue is a special thread-safe object that lets you put data in one end and take it out the other without having to worry about synchronization issues. They're pretty straightforward, and look like this:</source>
          <target state="translated">队列是一个特殊的线程安全对象,它可以让你把数据放在一端,然后从另一端取出,而不必担心同步问题。它们很直接,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="ce5a6f66f06330588b1d9e78cc960a0c4ce6fd02" translate="yes" xml:space="preserve">
          <source>A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the problem.</source>
          <target state="translated">一个快速和肮脏的修复涉及到一点代码,但这可能是你需要找出问题的全部。</target>
        </trans-unit>
        <trans-unit id="6e5b863f1eff6fa26a4e90b6efd2628e9a8b1279" translate="yes" xml:space="preserve">
          <source>A quick bit of zip file terminology -- A zip archive consists of one or more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f4c66121a13dbcd4a35fcb46d7559bf401584e" translate="yes" xml:space="preserve">
          <source>A quick fix to the offending line (insert the missing parentheses) in the actual program and we're finished.</source>
          <target state="translated">在实际程序中快速修复违规行(插入缺失的括号),我们就完成了。</target>
        </trans-unit>
        <trans-unit id="ee22003c9d3f871e01a3bbc57135bc551a023e8c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an &lt;code&gt;sv&lt;/code&gt; should be passed to &lt;code&gt;sv_force_normal&lt;/code&gt; to be &quot;downgraded&quot; before &lt;code&gt;SvIVX&lt;/code&gt; or &lt;code&gt;SvPVX&lt;/code&gt; can be modified directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf25dde2a598596295bb7a94644c4b4622cf06c" translate="yes" xml:space="preserve">
          <source>A quick flag check to see whether an sv should be passed to sv_force_normal to be &quot;downgraded&quot; before SvIVX or SvPVX can be modified directly.</source>
          <target state="translated">一个快速的标志检查,以查看是否应该在直接修改 SvIVX 或 SvPVX 之前将 sv 传给 sv_force_normal 进行 &quot;降级&quot;。</target>
        </trans-unit>
        <trans-unit id="5714e693202d7afa5eda5b56d0aae30074e97131" translate="yes" xml:space="preserve">
          <source>A quick note on terms</source>
          <target state="translated">关于术语的简要说明</target>
        </trans-unit>
        <trans-unit id="1d94544d51208195a231709cf1963af0c4de7162" translate="yes" xml:space="preserve">
          <source>A race condition exists when the result of several interrelated events depends on the ordering of those events, but that order cannot be guaranteed due to nondeterministic timing effects. If two or more programs, or parts of the same program, try to go through the same series of events, one might interrupt the work of the other. This is a good way to find an &lt;b&gt;exploit&lt;/b&gt;.</source>
          <target state="translated">当几个相互关联的事件的结果取决于这些事件的顺序时，便存在竞争条件，但由于不确定的时序影响，无法保证该顺序。如果两个或多个程序或同一程序的一部分尝试经历相同的一系列事件，则一个事件可能会中断另一个事件的工作。这是发现&lt;b&gt;漏洞&lt;/b&gt;的好方法。</target>
        </trans-unit>
        <trans-unit id="b4fd04892bbded81531e522d3212286340ec1840" translate="yes" xml:space="preserve">
          <source>A read-write accessor will allow the caller to set the value as well as get it:</source>
          <target state="translated">读写访问器将允许调用者设置值以及获取值。</target>
        </trans-unit>
        <trans-unit id="caaace35cefc12e27812e75c68a502f8caf0f7cf" translate="yes" xml:space="preserve">
          <source>A recent net or commercial release of Cygwin is required.</source>
          <target state="translated">需要一个最近的Cygwin的网络或商业版本。</target>
        </trans-unit>
        <trans-unit id="279e88205b97d17edeab01fe3aebcdc1b843db2f" translate="yes" xml:space="preserve">
          <source>A recent version of perl for the Amiga can be found at the Geek Gadgets section of the Aminet:</source>
          <target state="translated">在Aminet的Geek Gadgets部分,可以找到一个最新版本的perl for the Amiga。</target>
        </trans-unit>
        <trans-unit id="091b3fb1a508c2d701cd7e6f7c6e6e5c3add3716" translate="yes" xml:space="preserve">
          <source>A recipe book for programming with CPAN.pm</source>
          <target state="translated">使用CPAN.pm进行编程的秘诀书</target>
        </trans-unit>
        <trans-unit id="2d7c582850510d1397c7e76f17b16cc5d91e6066" translate="yes" xml:space="preserve">
          <source>A recreational vehicle, not to be confused with vehicular recreation. RV also means an internal Reference Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold. See also &lt;b&gt;IV&lt;/b&gt; and &lt;b&gt;NV&lt;/b&gt; if you&amp;rsquo;re not confused yet.</source>
          <target state="translated">一种休闲车，不要与车辆休闲相混淆。RV也表示&lt;b&gt;标量&lt;/b&gt;可以容纳的内部参考值。如果尚未感到困惑，另请参阅&lt;b&gt;IV&lt;/b&gt;和&lt;b&gt;NV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="ad0a627886d7457b4c1bf3b7879c79721531858f" translate="yes" xml:space="preserve">
          <source>A reference can be blessed into a package with the following function:</source>
          <target state="translated">可以通过以下函数将一个引用祝福到一个包中。</target>
        </trans-unit>
        <trans-unit id="b9d8f8326d44e724663f7d05cf4610dd9fa3fff9" translate="yes" xml:space="preserve">
          <source>A reference can be created by using a special syntax, lovingly known as the *foo{THING} syntax. *foo{THING} returns a reference to the THING slot in *foo (which is the symbol table entry which holds everything known as foo).</source>
          <target state="translated">可以通过使用一种特殊的语法来创建一个引用,这种语法被爱称为*foo{THING}语法。*foo{THING}返回对*foo中THING槽的引用(这是符号表的条目,其中包含了所有已知的foo)。</target>
        </trans-unit>
        <trans-unit id="aa895f94ce4272825894257bb4b5f46a12e2a648" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as the value of an array or hash element, you can easily create lists and hashes within lists and hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.</source>
          <target state="translated">引用是一个标量值,可以引用任何其他Perl数据类型。因此,通过存储一个引用作为数组或哈希元素的值,你可以轻松地在列表和哈希中创建列表和哈希。下面的例子显示了一个使用匿名哈希引用的2层哈希结构。</target>
        </trans-unit>
        <trans-unit id="31756567f0b0edb207ae4b6d556e511492c04f15" translate="yes" xml:space="preserve">
          <source>A reference is a scalar value that</source>
          <target state="translated">引用是一个标量值,它</target>
        </trans-unit>
        <trans-unit id="9246f92f3034b3a452a0afe45331277281745beb" translate="yes" xml:space="preserve">
          <source>A reference that doesn&amp;rsquo;t get counted normally. When all the normal references to data disappear, the data disappears. These are useful for circular references that would never disappear otherwise.</source>
          <target state="translated">引用不正常计数。当所有对数据的普通引用都消失时，数据也消失了。这些对于循环引用很有用，否则将永远不会消失。</target>
        </trans-unit>
        <trans-unit id="5bbf68c2e549802b044298b09b378b5fd28092c9" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file from which the invoking script's pod documentation should be read. It defaults to the file indicated by &lt;code&gt;$0&lt;/code&gt; (&lt;code&gt;$PROGRAM_NAME&lt;/code&gt; for users of</source>
          <target state="translated">对文件句柄的引用，或应从中读取调用脚本的pod文档的文件的路径名。默认使用 &lt;code&gt;$0&lt;/code&gt; 指示的文件（ &lt;code&gt;$PROGRAM_NAME&lt;/code&gt; 对于以下用户</target>
        </trans-unit>
        <trans-unit id="f5b22d93dc114d0a0d964dd5bfa61e077311cb6a" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt; ).</source>
          <target state="translated">对文件句柄的引用，或应该向其中写入使用消息的文件的路径名。除非出口值小于2，否则默认值为 &lt;code&gt;\*STDERR&lt;/code&gt; （在这种情况下，默认值为 &lt;code&gt;\*STDOUT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="980006b576a2cc0a15260aa4e5fea4bbf14c9495" translate="yes" xml:space="preserve">
          <source>A reference to a filehandle, or the pathname of a file to which the usage message should be written. The default is &lt;code&gt;\*STDERR&lt;/code&gt; unless the exit value is less than 2 (in which case the default is &lt;code&gt;\*STDOUT&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be21fde0d5a369b6626dd71f37562d95b7a892a" translate="yes" xml:space="preserve">
          <source>A reference to a hash</source>
          <target state="translated">对哈希值的引用</target>
        </trans-unit>
        <trans-unit id="caf281724b21daca5b76b0ce26ffdceb6ed5b592" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="translated">对控制可以并行执行哪些测试的规则的哈希的引用。如果未声明任何规则且&lt;a href=&quot;../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt;可用，则 &lt;code&gt;TAP::Harness&lt;/code&gt; 尝试从 &lt;code&gt;rulesfile&lt;/code&gt; 参数指定的YAML文件中加载规则。如果不存在任何规则文件，则默认为所有测试都可以并行运行。</target>
        </trans-unit>
        <trans-unit id="a706802a8a2475d51bc83970dc392f76564c5864" translate="yes" xml:space="preserve">
          <source>A reference to a hash of rules that control which tests may be executed in parallel. If no rules are declared and &lt;a href=&quot;CPAN::Meta::YAML&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; is available, &lt;code&gt;TAP::Harness&lt;/code&gt; attempts to load rules from a YAML file specified by the &lt;code&gt;rulesfile&lt;/code&gt; parameter. If no rules file exists, the default is for all tests to be eligible to be run in parallel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd42c7f4f6784f49153b357722a869874cd7cab5" translate="yes" xml:space="preserve">
          <source>A reference to a hash of scalar values in scalar context. Each entry of the hash has the fully qualified method name as its key and the method's scalar-context return values as its value.</source>
          <target state="translated">一个对标量上下文中标量值的哈希的引用。该哈希的每个条目都以完全限定的方法名称作为其键,并以该方法的标量上下文返回值作为其值。</target>
        </trans-unit>
        <trans-unit id="c3a87c12004d018bcf7a69155be997af1914286c" translate="yes" xml:space="preserve">
          <source>A reference to a hash.</source>
          <target state="translated">对哈希的引用。</target>
        </trans-unit>
        <trans-unit id="9c7f4017cfb229c284c5327072ab9da27410d7df" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; . These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="translated">对形式为 &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt; 的网络掩码字符串列表的引用。这些由 &lt;code&gt;requires_firewall&lt;/code&gt; 函数用于确定给定主机是在防火墙内部还是外部。</target>
        </trans-unit>
        <trans-unit id="55220c7cc22e62cddb006a6a8bf77ab5a2807bb5" translate="yes" xml:space="preserve">
          <source>A reference to a list of netmask strings in the form &lt;code&gt;&quot;134.99.4.0/24&quot;&lt;/code&gt;. These are used by the &lt;code&gt;requires_firewall&lt;/code&gt; function to determine if a given host is inside or outside your firewall.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ea49a873c1ff374f329e97efef0ff346dccc25" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) the list:</source>
          <target state="translated">对子例程引用和/或qr //对象和/或文字字符串和/或散列引用的列表的引用，指定要用于拆分字符串的提取器。如果省略此参数（或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），则列表：</target>
        </trans-unit>
        <trans-unit id="dd1cf33c811e37d20a0f1536729842fe8b28cf07" translate="yes" xml:space="preserve">
          <source>A reference to a list of subroutine references and/or qr// objects and/or literal strings and/or hash references, specifying the extractors to be used to split the string. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;) the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2512ecb6dd2165eaa0de868a807f9b3c24936be1" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;&quot;TODO TESTS&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f47fcb868f1bdb2ed44c13b2967f53238fb92e" translate="yes" xml:space="preserve">
          <source>A reference to a list of tests which are allowed to fail. See &lt;a href=&quot;#TODO-TESTS&quot;&gt;TODO TESTS&lt;/a&gt;.</source>
          <target state="translated">对允许失败的测试列表的引用。请参阅&lt;a href=&quot;#TODO-TESTS&quot;&gt;待办事项&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a16beaf14f9ebf81709ac7687142e7324bffbcbc" translate="yes" xml:space="preserve">
          <source>A reference to a scalar, containing any initial source code to prepend to the file or generator output.</source>
          <target state="translated">一个对标量的引用,包含任何初始的源代码,以预置到文件或生成器输出。</target>
        </trans-unit>
        <trans-unit id="ca57032a4acbb0f04dd265f2403ba03843451cb5" translate="yes" xml:space="preserve">
          <source>A reference to a simple scalar</source>
          <target state="translated">参考一个简单的标量</target>
        </trans-unit>
        <trans-unit id="2f7717bc46f8882825267f8fb5ae31ad534d8604" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine</source>
          <target state="translated">对子程序的引用</target>
        </trans-unit>
        <trans-unit id="13ea76e1a2a772c23eb3e3af45f4e6c39d604a09" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;. Again, return 1 for each valid line, and 0 after all lines have been returned. For historical reasons the subroutine will receive a meaningless argument (in fact always the numeric value zero) as &lt;code&gt;$_[0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60540604d1e514c1059c3b516595d77c9c95f5f" translate="yes" xml:space="preserve">
          <source>A reference to a subroutine. If there is no filehandle (previous item), then this subroutine is expected to generate one line of source code per call, writing the line into &lt;code&gt;$_&lt;/code&gt; and returning 1, then finally at end of file returning 0. If there is a filehandle, then the subroutine will be called to act as a simple source filter, with the line as read in &lt;code&gt;$_&lt;/code&gt; . Again, return 1 for each valid line, and 0 after all lines have been returned.</source>
          <target state="translated">对子例程的引用。如果没有文件句柄（上一个项目），则该子例程将为每次调用生成一行源代码，将该行写入 &lt;code&gt;$_&lt;/code&gt; 并返回1，最后在文件末尾返回0。如果存在文件句柄，然后将调用该子例程以充当简单的源过滤器，其行如 &lt;code&gt;$_&lt;/code&gt; 。再次，为每条有效行返回1，在所有行返回后返回0。</target>
        </trans-unit>
        <trans-unit id="69d2c7af1b1feb58183b6cd3ab9665d62ba3318e" translate="yes" xml:space="preserve">
          <source>A reference to an &lt;code&gt;@INC&lt;/code&gt; style array of arguments to be passed to each test program.</source>
          <target state="translated">对要传递给每个测试程序的 &lt;code&gt;@INC&lt;/code&gt; 样式参数数组的引用。</target>
        </trans-unit>
        <trans-unit id="c036eaf04cdd3c79b7e1454ebb2a945c2a1cd7fe" translate="yes" xml:space="preserve">
          <source>A reference to an SV which holds a C pointer</source>
          <target state="translated">对持有C指针的SV的引用。</target>
        </trans-unit>
        <trans-unit id="23549f2151bb51628d2f58bbcf1156a64c3296ce" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous array can be created using square brackets:</source>
          <target state="translated">可以使用方括号创建对匿名数组的引用。</target>
        </trans-unit>
        <trans-unit id="227fa37704dcf65c895f6b48accf114132dd71b4" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous hash can be created using curly brackets:</source>
          <target state="translated">可以使用大括号创建对匿名哈希的引用。</target>
        </trans-unit>
        <trans-unit id="75f71bb1e5a64ddcdb9e050cbea388199a1108b3" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; without a subname:</source>
          <target state="translated">可以使用不带子名称的 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 来创建对匿名子例程的引用：</target>
        </trans-unit>
        <trans-unit id="c2b28a0f04f7d25df0ba15127b6c78099a8d8001" translate="yes" xml:space="preserve">
          <source>A reference to an anonymous subroutine can be created by using &lt;code&gt;sub&lt;/code&gt; without a subname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b1d9fe90cb9aed401ad78a9cb46511d34021ee8" translate="yes" xml:space="preserve">
          <source>A reference to an array</source>
          <target state="translated">对数组的引用</target>
        </trans-unit>
        <trans-unit id="e31779df8d209b3542cc04e2be4c9b32f5d08f2c" translate="yes" xml:space="preserve">
          <source>A reference to an array of sections specifications (as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;) which indicate the desired set of POD sections and subsections to be selected from input. If no section specifications are given, then all sections of the PODs are used.</source>
          <target state="translated">对部分规范的数组的引用（如&lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS中所述&lt;/a&gt;），指示要从输入中选择的POD部分和子部分的所需集合。如果未提供任何部分规范，则将使用POD的所有部分。</target>
        </trans-unit>
        <trans-unit id="c89226f4c3258d3bce7e696eba292fd5daa132bc" translate="yes" xml:space="preserve">
          <source>A reference to the object for a virtual method or the name of the class for a static method</source>
          <target state="translated">对虚拟方法的对象的引用,或者对静态方法的类名的引用。</target>
        </trans-unit>
        <trans-unit id="21f30d908543711c9f728d7de0ea1261250a9055" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; . This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="translated">在夏时制期间，AIX 7中的回归会导致Time :: Piece中的make测试失败。APAR IV16514为此提供了修复程序。假设当前是美国东部时间的夏令时，进行一次快速测试（如果需要），将运行 &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt; 。正常情况下，这将与 &lt;code&gt;EST&lt;/code&gt; 一起返回，但如果有问题，则什么也不会。</target>
        </trans-unit>
        <trans-unit id="f9c19d164e4eea1cf98cc917d39776c748efd08d" translate="yes" xml:space="preserve">
          <source>A regression in AIX 7 causes a failure in make test in Time::Piece during daylight savings time. APAR IV16514 provides the fix for this. A quick test to see if it's required, assuming it is currently daylight savings in Eastern Time, would be to run &lt;code&gt; TZ=EST5 date +%Z &lt;/code&gt;. This will come back with &lt;code&gt;EST&lt;/code&gt; normally, but nothing if you have the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fc4dbf2e586369f7ce889ec848c85dffcc1c599" translate="yes" xml:space="preserve">
          <source>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; for a full definition of the language.</source>
          <target state="translated">正则表达式引擎是一个程序，该程序采用一组以迷你语言指定的约束，然后将这些约束应用于目标字符串，并确定字符串是否满足约束。有关&lt;a href=&quot;perlre&quot;&gt;语言&lt;/a&gt;的完整定义，请参见perlre。</target>
        </trans-unit>
        <trans-unit id="898d96d1a86448c10c01fff6d7c680ca19e7f093" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt; , &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo =~ EXPR&lt;/code&gt; . Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt; , &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; , or &lt;code&gt;$foo !~ EXPR&lt;/code&gt; .</source>
          <target state="translated">以 &lt;code&gt;/REGEX/&lt;/code&gt; ， &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt; 或 &lt;code&gt;$foo =~ EXPR&lt;/code&gt; 〜EXPR形式的正则表达式匹配。而且，否定的正则表达式匹配形式为 &lt;code&gt;!/REGEX/&lt;/code&gt; ， &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt; 或 &lt;code&gt;$foo !~ EXPR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01f7272df9cfce47663749712543393fb8ccb06b" translate="yes" xml:space="preserve">
          <source>A regular expression match in the form of &lt;code&gt;/REGEX/&lt;/code&gt;, &lt;code&gt;$foo =~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo =~ EXPR&lt;/code&gt;. Also, a negated regular expression match in the form &lt;code&gt;!/REGEX/&lt;/code&gt;, &lt;code&gt;$foo !~ /REGEX/&lt;/code&gt;, or &lt;code&gt;$foo !~ EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b61a0c27a77da1e69f8478b8fd9175ff4c338f9" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt; . Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="translated">否则将使用 &lt;code&gt;/d&lt;/code&gt; 规则进行编译并使用此构造的正则表达式将改用 &lt;code&gt;/u&lt;/code&gt; 。因此，此结构告诉Perl您不希望 &lt;code&gt;/d&lt;/code&gt; 规则包含整个正则表达式。</target>
        </trans-unit>
        <trans-unit id="3b6937e0ce314d5ad6696b2c87b4dd9e05cd8786" translate="yes" xml:space="preserve">
          <source>A regular expression that otherwise would compile using &lt;code&gt;/d&lt;/code&gt; rules, and which uses this construct will instead use &lt;code&gt;/u&lt;/code&gt;. Thus this construct tells Perl that you don't want &lt;code&gt;/d&lt;/code&gt; rules for the entire regular expression containing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8052f2558ed14ca1695f0756ea843781532061f7" translate="yes" xml:space="preserve">
          <source>A related issue is thread-safety. When a new thread is created, the Perl interpreter is cloned, which implies that all reference addresses in use will be replaced with new ones. Thus, if a class tries to access a field of a cloned object its (cloned) data will still be stored under the now invalid reference address of the original in the parent thread. A general &lt;code&gt;CLONE&lt;/code&gt; method must be provided to re-establish the association.</source>
          <target state="translated">一个相关的问题是线程安全。创建新线程时，将克隆Perl解释器，这意味着所有使用中的引用地址都将被新的引用地址替换。因此，如果类试图访问克隆对象的字段，则其（克隆）数据仍将存储在父线程中原始对象的现在无效的引用地址下。必须提供通用的 &lt;code&gt;CLONE&lt;/code&gt; 方法来重新建立关联。</target>
        </trans-unit>
        <trans-unit id="c5a4d830992a6346407400c2bf4e88b4a6e3e575" translate="yes" xml:space="preserve">
          <source>A related issue is use with perl's malloc. Perl's malloc uses &lt;code&gt;sbrk()&lt;/code&gt; to get memory, and &lt;code&gt;sbrk()&lt;/code&gt; is limited to the first allocation so in this case something like:</source>
          <target state="translated">一个相关的问题是与perl的malloc一起使用。Perl的malloc使用 &lt;code&gt;sbrk()&lt;/code&gt; 来获取内存，而 &lt;code&gt;sbrk()&lt;/code&gt; 限于第一次分配，因此在这种情况下，类似于：</target>
        </trans-unit>
        <trans-unit id="773c247356b687b3912aff9a0cf7c1a25f2fade5" translate="yes" xml:space="preserve">
          <source>A related strategy that's less open to forgery is to give them a PIN (personal ID number). Record the address and PIN (best that it be a random one) for later processing. In the mail you send, include a link to your site with the PIN included. If the mail bounces, you know it's not valid. If they don't click on the link, either they forged the address or (assuming they got the message) following through wasn't important so you don't need to worry about it.</source>
          <target state="translated">一个相关的不易伪造的策略是给他们一个PIN码(个人身份号码)。记录地址和PIN码(最好是随机的),以便以后处理。在你发送的邮件中,包括一个指向你网站的链接,并附上PIN码。如果邮件跳转,你就知道它无效。如果他们没有点击链接,要么是他们伪造了地址,要么是(假设他们收到了信息)跟进并不重要,所以你不需要担心这个问题。</target>
        </trans-unit>
        <trans-unit id="1b0e6d749250f42dda0dbf4bdf376cdb3adb5626" translate="yes" xml:space="preserve">
          <source>A relationship between two &lt;b&gt;objects&lt;/b&gt; in which one object is considered to be a more specific version of the other, generic object: &amp;ldquo;A camel is a mammal.&amp;rdquo; Since the generic object really only exists in a Platonic sense, we usually add a little abstraction to the notion of objects and think of the relationship as being between a generic &lt;b&gt;base class&lt;/b&gt; and a specific &lt;b&gt;derived class&lt;/b&gt;. Oddly enough, Platonic classes don&amp;rsquo;t always have Platonic relationships&amp;mdash;see &lt;b&gt;inheritance&lt;/b&gt;.</source>
          <target state="translated">两个&lt;b&gt;对象&lt;/b&gt;之间的关系，其中一个对象被视为另一个通用对象的更特定版本：&amp;ldquo;骆驼是哺乳动物。&amp;rdquo;由于泛型对象实际上仅在柏拉图意义上存在，因此我们通常在对象的概念上添加一些抽象，并将关系视为泛型&lt;b&gt;基类&lt;/b&gt;与特定&lt;b&gt;派生类&lt;/b&gt;之间的关系。奇怪的是，柏拉图类并不总是具有柏拉图关系-请参见&lt;b&gt;继承&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9cc57b74bcbf78eacbd6b02d09950f83d1e82c98" translate="yes" xml:space="preserve">
          <source>A relatively new conference franchise with a large Perl portion is the Open Source Developers Conference or OSDC. First held in Australia it has recently also spread to Israel and France. More information can be found at: &lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt; for Australia, &lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt; for Israel, and &lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt; for France.</source>
          <target state="translated">Open Source Developers Conference或OSDC是一个相对较新的，具有很大Perl份额的会议专营权。首次在澳大利亚举行，最近也传播到以色列和法国。更多信息可以在这里找到：&lt;a href=&quot;http://www.osdc.com.au/&quot;&gt;http://www.osdc.com.au/&lt;/a&gt;澳大利亚，&lt;a href=&quot;http://www.osdc.org.il&quot;&gt;http://www.osdc.org.il&lt;/a&gt;以色列和&lt;a href=&quot;http://www.osdc.fr/&quot;&gt;http://www.osdc.fr/&lt;/a&gt;法国。</target>
        </trans-unit>
        <trans-unit id="125bb83bd0e2557d465d8cae2a201d255865cfc8" translate="yes" xml:space="preserve">
          <source>A relatively recent addition to socket functions, may not be implemented even in Unix platforms.</source>
          <target state="translated">一个相对较新的套接字函数,即使在Unix平台上也可能无法实现。</target>
        </trans-unit>
        <trans-unit id="0fb2c7925dc01622384910beb32c259581a32e6c" translate="yes" xml:space="preserve">
          <source>A remark that doesn&amp;rsquo;t affect the meaning of the program. In Perl, a comment is introduced by a &lt;code&gt;#&lt;/code&gt; character and continues to the end of the line.</source>
          <target state="translated">备注不影响程序的含义。在Perl中，注释由 &lt;code&gt;#&lt;/code&gt; 字符引起，并一直持续到行尾。</target>
        </trans-unit>
        <trans-unit id="05ceaec7b64c7ce9cdeec60b39e51b96ddb09fbd" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 设置了要放入uuencoded行中的字节数后的重复计数，默认情况下最大为45，但可以将其设置为3的某个（较小的）整数倍。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 只会忽略重复计数。</target>
        </trans-unit>
        <trans-unit id="39e5a93524da5ebc880d6f2d48ae7f4158fdf997" translate="yes" xml:space="preserve">
          <source>A repeat count after &lt;code&gt;u&lt;/code&gt; sets the number of bytes to put into an uuencoded line, which is the maximum of 45 by default, but could be set to some (smaller) integer multiple of three. &lt;code&gt;unpack&lt;/code&gt; simply ignores the repeat count.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a53eb20270176512fa5bd8bf4b4f1be0776d385" translate="yes" xml:space="preserve">
          <source>A return code of 1 means that the requested key was not in the database.</source>
          <target state="translated">返回码为1表示请求的键不在数据库中。</target>
        </trans-unit>
        <trans-unit id="ed4d8a6dc7b98d70bce7c0cb5069c17fe03ce939" translate="yes" xml:space="preserve">
          <source>A rudimentary command-line completion is also available, including lexical variables in the current scope if the &lt;code&gt;PadWalker&lt;/code&gt; module is installed.</source>
          <target state="translated">如果安装了 &lt;code&gt;PadWalker&lt;/code&gt; 模块，还可以使用基本的命令行完成功能，包括当前作用域中的词法变量。</target>
        </trans-unit>
        <trans-unit id="195465d41845715cc8feeb944d84d82eca7db90c" translate="yes" xml:space="preserve">
          <source>A safe filename for the package.</source>
          <target state="translated">包的安全文件名。</target>
        </trans-unit>
        <trans-unit id="e965283a692e93e5f3c352fa50ba572d5ad94533" translate="yes" xml:space="preserve">
          <source>A sample Configure invocation looks something like this:</source>
          <target state="translated">配置调用的示例看起来像这样。</target>
        </trans-unit>
        <trans-unit id="c38c9f9afa364c973ff5615c1cc8f4fc08593cdb" translate="yes" xml:space="preserve">
          <source>A sanitized VERSION with . replaced by _. For places where . has special meaning (some filesystems, RCS labels, etc...)</source>
          <target state="translated">一个用_代替.的消毒后的VERSION。对于那些有特殊含义的地方(一些文件系统,RCS标签,等等...)。</target>
        </trans-unit>
        <trans-unit id="854d2d0c342e6a9cd9c52af8350f79c5b69ee115" translate="yes" xml:space="preserve">
          <source>A sanity check is done to ensure that the versions of the</source>
          <target state="translated">进行安全检查,以确保各版本的</target>
        </trans-unit>
        <trans-unit id="52b0650d241bfe8b8773b0c925166a2b232578a5" translate="yes" xml:space="preserve">
          <source>A sanity check that what Perl thinks the architecture is and what Config thinks the architecture is are the same. If they're not it will return false and show a diagnostic message.</source>
          <target state="translated">检验Perl认为的架构和Config认为的架构是否相同。如果它们不一样,它将返回 false 并显示诊断信息。</target>
        </trans-unit>
        <trans-unit id="a5df5a5c29d978bd67d46cf69079761e359c23a8" translate="yes" xml:space="preserve">
          <source>A scalar reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13eb257f5c15cd87da91e7109e5621a0b92dd55a" translate="yes" xml:space="preserve">
          <source>A scalar represents a single value:</source>
          <target state="translated">一个标量代表一个单值。</target>
        </trans-unit>
        <trans-unit id="63bf2744d770c46d6894e17a03796eb6868d8317" translate="yes" xml:space="preserve">
          <source>A scalar that is going to be passed to some extension</source>
          <target state="translated">一个将被传递给某个扩展的标量。</target>
        </trans-unit>
        <trans-unit id="b892a705ca325c138b52905f099e8858ffbdfac0" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed.</source>
          <target state="translated">一个标量值如果是未定义、空字符串或数字0(或其字符串等价物 &quot;0&quot;),在布尔语境中被解释为FALSE,如果是其他任何东西,则解释为TRUE。布尔语境只是一种特殊的标量语境,在这种语境中,从来没有进行过向字符串或数字的转换。</target>
        </trans-unit>
        <trans-unit id="751493f8cb7ec6843259111a93c03239b2cd2168" translate="yes" xml:space="preserve">
          <source>A scalar value is interpreted as FALSE in the Boolean sense if it is undefined, the null string or the number 0 (or its string equivalent, &quot;0&quot;), and TRUE if it is anything else. The Boolean context is just a special kind of scalar context where no conversion to a string or a number is ever performed. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt;, but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf273fc6dfd9742bd76d45138d207f0b0c7c11c" translate="yes" xml:space="preserve">
          <source>A scalar we got back from an extension</source>
          <target state="translated">我们从扩展中得到的一个标量</target>
        </trans-unit>
        <trans-unit id="7153eab5e3c20636ca530d5dc26c52e39ac43559" translate="yes" xml:space="preserve">
          <source>A scratchpad keeps SVs which are lexicals for the current unit and are targets for opcodes. A previous version of this document stated that one can deduce that an SV lives on a scratchpad by looking on its flags: lexicals have &lt;code&gt;SVs_PADMY&lt;/code&gt; set, and</source>
          <target state="translated">暂存器保留SV，这些SV是当前单元的词汇，并且是操作码的目标。该文档的先前版本指出，可以通过查看其标志来推断SV &lt;code&gt;SVs_PADMY&lt;/code&gt; 在暂存器上：词汇已设置SVs_PADMY，并且</target>
        </trans-unit>
        <trans-unit id="9b4b51a187f878ac1e93c009ee393256c5f3fed7" translate="yes" xml:space="preserve">
          <source>A script called &quot;runperl.bat&quot; is available that can be copied to any filename (along with the .bat suffix). For example, if you call it &quot;foo.bat&quot;, it will run the file &quot;foo&quot; when it is executed. Since you can run batch files on Windows platforms simply by typing the name (without the extension), this effectively runs the file &quot;foo&quot;, when you type either &quot;foo&quot; or &quot;foo.bat&quot;. With this method, &quot;foo.bat&quot; can even be in a different location than the file &quot;foo&quot;, as long as &quot;foo&quot; is available somewhere on the PATH. If your scripts are on a filesystem that allows symbolic links, you can even avoid copying &quot;runperl.bat&quot;.</source>
          <target state="translated">有一个名为 &quot;runperl.bat &quot;的脚本,可以复制到任何文件名中(连同.bat后缀)。例如,如果你把它称为 &quot;foo.bat&quot;,它将在执行时运行文件 &quot;foo&quot;。由于在Windows平台上只需键入名称(不含扩展名)就可以运行批处理文件,所以当你键入 &quot;foo &quot;或 &quot;foo.bat &quot;时,这就有效地运行了 &quot;foo &quot;文件。使用这种方法,&quot;foo.bat &quot;甚至可以在与 &quot;foo &quot;不同的位置,只要 &quot;foo &quot;在PATH的某个地方可用。如果你的脚本是在一个允许符号链接的文件系统上,你甚至可以避免复制 &quot;runperl.bat&quot;。</target>
        </trans-unit>
        <trans-unit id="8a0dd42d0c5f72d1648c67ceada410b1cd803819" translate="yes" xml:space="preserve">
          <source>A script run is basically a sequence of characters, all from the same Unicode script (see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;), such as Latin or Greek. In most places a single word would never be written in multiple scripts, unless it is a spoofing attack. An infamous example, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e410531e148f9094643156d14e90843980c3dfe" translate="yes" xml:space="preserve">
          <source>A script that emulates the standard unix archive (aka library) utility. Under Watcom 10.6, ar is linked to wlib and provides the expected interface. With Watcom 9.5, a cover function is required. This one is fairly crude but has proved adequate for compiling perl.</source>
          <target state="translated">一个模拟标准 unix 存档(又称库)工具的脚本。在Watcom 10.6下,ar与wlib相连,并提供预期的接口。在Watcom 9.5下,需要一个封面函数。这个函数相当粗糙,但已被证明足以编译perl。</target>
        </trans-unit>
        <trans-unit id="e8eda0c28ba2fe483ef84daa3f54b909c119dec0" translate="yes" xml:space="preserve">
          <source>A script that provides C preprocessing functionality. Configure can generate a similar cover, but it doesn't handle all the command-line options that perl throws at it. This might be reasonably placed in /usr/local/bin.</source>
          <target state="translated">一个提供C语言预处理功能的脚本。Configure可以生成一个类似的封面,但它并没有处理perl抛出的所有命令行选项。可以把它放在/usr/local/bin中。</target>
        </trans-unit>
        <trans-unit id="f63efe767441f9b6cae7b2dee9e50e81364ad873" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="translated">可从&lt;a href=&quot;http://markmail.org/search/?q=perl5-porters&quot;&gt;http://markmail.org/search/?q=perl5-porters&lt;/a&gt;获得该列表的可搜索存档。在&lt;a href=&quot;http://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;http://archive.develooper.com/perl5-porters@perl.org/上&lt;/a&gt;也有一个档案。</target>
        </trans-unit>
        <trans-unit id="752d32391bfcd52e9f67370c3e3b59a46e33094d" translate="yes" xml:space="preserve">
          <source>A searchable archive of the list is available at &lt;a href=&quot;https://markmail.org/search/?q=perl5-porters&quot;&gt;https://markmail.org/search/?q=perl5-porters&lt;/a&gt;. There is also an archive at &lt;a href=&quot;https://archive.develooper.com/perl5-porters@perl.org/&quot;&gt;https://archive.develooper.com/perl5-porters@perl.org/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1598e0f0cd8f36f911067e3fef88a3cdc16b3aed" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt; &quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt; &quot; in perlsyn.</source>
          <target state="translated">一个节由命名的标题或项目开始。例如， &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; 都链接到perlvar中以&amp;ldquo; &lt;code&gt;=item $.&lt;/code&gt; &amp;rdquo; 开头的部分。和 &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; 两个链路被启动&amp;ldquo;的一节 &lt;code&gt;=head2 For Loops&lt;/code&gt; 中perlsyn&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="50daaeb1a2fab8aef823f07b1ef237ef7fd7c501" translate="yes" xml:space="preserve">
          <source>A section is started by the named heading or item. For example, &lt;code&gt;L&amp;lt;perlvar/$.&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlvar/&quot;$.&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=item $.&lt;/code&gt;&quot; in perlvar. And &lt;code&gt;L&amp;lt;perlsyn/For Loops&amp;gt;&lt;/code&gt; or &lt;code&gt;L&amp;lt;perlsyn/&quot;For Loops&quot;&amp;gt;&lt;/code&gt; both link to the section started by &quot;&lt;code&gt;=head2 For Loops&lt;/code&gt;&quot; in perlsyn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd968f32a9ca757550679bcb38ba91ae56c38c6" translate="yes" xml:space="preserve">
          <source>A selection of any number of &lt;b&gt;elements&lt;/b&gt; from a &lt;b&gt;list&lt;/b&gt;, &lt;b&gt;array&lt;/b&gt;, or &lt;b&gt;hash&lt;/b&gt;.</source>
          <target state="translated">从&lt;b&gt;列表&lt;/b&gt;，&lt;b&gt;数组&lt;/b&gt;或&lt;b&gt;哈希中&lt;/b&gt;选择任意数量的&lt;b&gt;元素&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c8bb7e9a293c6c000ed25150f0f4d86b8b09ae48" translate="yes" xml:space="preserve">
          <source>A selection of general-utility hash subroutines</source>
          <target state="translated">通用哈希子程序的选择。</target>
        </trans-unit>
        <trans-unit id="7f015133979033409d91eedccc2323e573bc6368" translate="yes" xml:space="preserve">
          <source>A selection of general-utility list subroutines</source>
          <target state="translated">一般实用性列表子程序的选择。</target>
        </trans-unit>
        <trans-unit id="28d3d211918b04ba8766082d56a39fef4fdf3700" translate="yes" xml:space="preserve">
          <source>A selection of general-utility scalar subroutines</source>
          <target state="translated">通用标量子程序的选择。</target>
        </trans-unit>
        <trans-unit id="6c2a22b80753e149c4a3e936da6e37252cc4db3f" translate="yes" xml:space="preserve">
          <source>A selection of utility subroutines for subs and CODE references</source>
          <target state="translated">用于子程序和CODE参考的实用子程序的选择。</target>
        </trans-unit>
        <trans-unit id="047fc7c9d2dc1ac28d49429eb7bc7a3322abc4af" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt; ) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt; , which gobble up everything else.</source>
          <target state="translated">分号（ &lt;code&gt;;&lt;/code&gt; ）将强制参数与可选参数分开。 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之前是多余的，它将吞噬其他所有内容。</target>
        </trans-unit>
        <trans-unit id="fcc144c5cd365b46474f5e986e9bf1d79c5d34db" translate="yes" xml:space="preserve">
          <source>A semicolon (&lt;code&gt;;&lt;/code&gt;) separates mandatory arguments from optional arguments. It is redundant before &lt;code&gt;@&lt;/code&gt; or &lt;code&gt;%&lt;/code&gt;, which gobble up everything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f511bb1ccbd67c6c6ca9d2e6f48560176d03c2b5" translate="yes" xml:space="preserve">
          <source>A sequence of &lt;b&gt;bits&lt;/b&gt; that is actually being thought of as a sequence of bits, for once.</source>
          <target state="translated">的序列&lt;b&gt;位&lt;/b&gt;，实际上是被认为是比特序列，对一次。</target>
        </trans-unit>
        <trans-unit id="cae9f6dde987a755ec3121175496d8328940bd06" translate="yes" xml:space="preserve">
          <source>A sequence of characters such as &amp;ldquo;He said !@#*&amp;amp;%@#*?!&amp;rdquo;. A string does not have to be entirely printable.</source>
          <target state="translated">一系列字符，例如&amp;ldquo;他说！@＃*＆％@＃* ?!&amp;rdquo;。字符串不必完全可打印。</target>
        </trans-unit>
        <trans-unit id="2d1e5cc5993ad4e16630359feaa4c2a48e6f7df3" translate="yes" xml:space="preserve">
          <source>A sequence of digits is an unsigned decimal literal number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c0733fdb6bad90c8e5cff763f33aac838dc3a41" translate="yes" xml:space="preserve">
          <source>A sequence of relational operators, such as &lt;code&gt;&quot;$x &amp;lt; $y &amp;lt;= $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with equality operators, which have lower precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8a71fa4ea97586fb33bedb544c35984db92bc7" translate="yes" xml:space="preserve">
          <source>A sequence of the above equality operators, such as &lt;code&gt;&quot;$x == $y == $z&quot;&lt;/code&gt;, performs chained comparisons, in the manner described above in the section &lt;a href=&quot;#Operator-Precedence-and-Associativity&quot;&gt;&quot;Operator Precedence and Associativity&quot;&lt;/a&gt;. Beware that they do not chain with relational operators, which have higher precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec7ee11f629dd8914f5fb3939fa45a8d0ac8f26" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt; , that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="translated">一个序列，例如 &lt;code&gt;=head1&lt;/code&gt; ，它指示&lt;b&gt;吊舱&lt;/b&gt;节的开始。</target>
        </trans-unit>
        <trans-unit id="b626bb1acba7e95f123c1e8cb0f3ca8665a27861" translate="yes" xml:space="preserve">
          <source>A sequence, such as &lt;code&gt;=head1&lt;/code&gt;, that denotes the start of a &lt;b&gt;pod&lt;/b&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="615050343b7872b60001479c7e1e5357ce76b3e7" translate="yes" xml:space="preserve">
          <source>A series of &lt;b&gt;processes&lt;/b&gt; all in a row, linked by &lt;b&gt;pipes&lt;/b&gt;, where each passes its output stream to the next.</source>
          <target state="translated">一连串由&lt;b&gt;管道&lt;/b&gt;连接的一系列&lt;b&gt;过程&lt;/b&gt;，每个过程将其输出流传递到下一个。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5e7b6708245b79eaeed5d38bcac016afddbd6e09" translate="yes" xml:space="preserve">
          <source>A series of characters matches that series of characters in the target string, so the pattern &lt;code&gt;blurfl&lt;/code&gt; would match &quot;blurfl&quot; in the target string.</source>
          <target state="translated">一系列字符与目标字符串中的那一系列字符匹配，因此模式 &lt;code&gt;blurfl&lt;/code&gt; 将与目标字符串中的&amp;ldquo; blurfl&amp;rdquo;匹配。</target>
        </trans-unit>
        <trans-unit id="cb6d59d3792163250639b9090bf480c17ab2f55e" translate="yes" xml:space="preserve">
          <source>A set of &lt;b&gt;directories&lt;/b&gt; and &lt;b&gt;files&lt;/b&gt; residing on a partition of the disk. Sometimes known as a &amp;ldquo;partition&amp;rdquo;. You can change the file&amp;rsquo;s name or even move a file around from directory to directory within a filesystem without actually moving the file itself, at least under Unix.</source>
          <target state="translated">磁盘分区上的一组&lt;b&gt;目录&lt;/b&gt;和&lt;b&gt;文件&lt;/b&gt;。有时称为&amp;ldquo;分区&amp;rdquo;。您可以更改文件名，甚至可以在文件系统内的目录之间移动文件，而不必实际移动文件本身（至少在Unix下）。</target>
        </trans-unit>
        <trans-unit id="a5ce6ae6f62d942a0f2702d5475445785e80396f" translate="yes" xml:space="preserve">
          <source>A set of criteria used to validate a particular piece of data if it has to adhere to particular rules.</source>
          <target state="translated">用于验证某项数据是否必须遵守特定规则的一套标准。</target>
        </trans-unit>
        <trans-unit id="abcc0ff1d11111cc38f19c5047e331b6ce4f3ede" translate="yes" xml:space="preserve">
          <source>A set of distribution prerequisites by phase and type</source>
          <target state="translated">按阶段和类型分列的一套分配先决条件;</target>
        </trans-unit>
        <trans-unit id="2054435ebeb82c104e8cc6baf030893f06d8bca6" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt; , which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt; -like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt; , which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt; , &lt;code&gt;ARG1()&lt;/code&gt; , &lt;code&gt;ARG2()&lt;/code&gt; , &lt;code&gt;ARG_SET()&lt;/code&gt; , and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt; , &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="translated">一组宏使访问字段更容易且更一致。其中包括 &lt;code&gt;OP()&lt;/code&gt; ，用于确定 &lt;code&gt;regnode&lt;/code&gt; 的结构的类型； &lt;code&gt;NEXT_OFF()&lt;/code&gt; ，它是到下一个节点的偏移量（稍后会详细介绍）； &lt;code&gt;ARG()&lt;/code&gt; ， &lt;code&gt;ARG1()&lt;/code&gt; ， &lt;code&gt;ARG2()&lt;/code&gt; ， &lt;code&gt;ARG_SET()&lt;/code&gt; 以及用于读取和设置参数的等效项；和 &lt;code&gt;STR_LEN()&lt;/code&gt; ， &lt;code&gt;STRING()&lt;/code&gt; 和 &lt;code&gt;OPERAND()&lt;/code&gt; 来操纵字符串和重载轴承类型。</target>
        </trans-unit>
        <trans-unit id="405ee0a4d5617474f5f68f2671ed8caabd78eb2a" translate="yes" xml:space="preserve">
          <source>A set of macros makes accessing the fields easier and more consistent. These include &lt;code&gt;OP()&lt;/code&gt;, which is used to determine the type of a &lt;code&gt;regnode&lt;/code&gt;-like structure; &lt;code&gt;NEXT_OFF()&lt;/code&gt;, which is the offset to the next node (more on this later); &lt;code&gt;ARG()&lt;/code&gt;, &lt;code&gt;ARG1()&lt;/code&gt;, &lt;code&gt;ARG2()&lt;/code&gt;, &lt;code&gt;ARG_SET()&lt;/code&gt;, and equivalents for reading and setting the arguments; and &lt;code&gt;STR_LEN()&lt;/code&gt;, &lt;code&gt;STRING()&lt;/code&gt; and &lt;code&gt;OPERAND()&lt;/code&gt; for manipulating strings and regop bearing types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b89ed012267a41a30013b79a6117c49ce7fdacf" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; . Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="translated">一组可能的值，以及所有知道如何处理这些值的操作。例如，数字数据类型具有可以使用的一组特定数字，以及可以对数字进行的各种数学运算，但是对于诸如 &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt; 类的字符串却毫无意义。字符串具有自己的操作，例如&lt;b&gt;concatenation&lt;/b&gt;。由许多较小的片段组成的复合类型通常具有组成和分解它们，甚至可能重新排列它们的操作。在现实世界中对事物建模的&lt;b&gt;对象&lt;/b&gt;通常具有与真实活动相对应的操作。例如，如果您对电梯建模，则您的电梯对象可能具有 &lt;code&gt;open_door&lt;/code&gt; &lt;b&gt;方法&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="46aa5c9b6882b1651ea253eff267521cde51f269" translate="yes" xml:space="preserve">
          <source>A set of possible values, together with all the operations that know how to deal with those values. For example, a numeric data type has a certain set of numbers that you can work with, as well as various mathematical operations that you can do on the numbers, but would make little sense on, say, a string such as &lt;code&gt;&quot;Kilroy&quot;&lt;/code&gt;. Strings have their own operations, such as &lt;b&gt;concatenation&lt;/b&gt;. Compound types made of a number of smaller pieces generally have operations to compose and decompose them, and perhaps to rearrange them. &lt;b&gt;Objects&lt;/b&gt; that model things in the real world often have operations that correspond to real activities. For instance, if you model an elevator, your elevator object might have an &lt;code&gt;open_door&lt;/code&gt;&lt;b&gt;method&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af57cf3203f1cd3e2de0a1965dff9d274c21ca2b" translate="yes" xml:space="preserve">
          <source>A set of related data values in a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;stream&lt;/b&gt;, often associated with a unique &lt;b&gt;key&lt;/b&gt; field. In Unix, often commensurate with a &lt;b&gt;line&lt;/b&gt;, or a blank-line&amp;ndash;terminated set of lines (a &amp;ldquo;paragraph&amp;rdquo;). Each line of the</source>
          <target state="translated">&lt;b&gt;文件&lt;/b&gt;或&lt;b&gt;流&lt;/b&gt;中的一组相关数据值，通常与唯一&lt;b&gt;键&lt;/b&gt;字段关联。在Unix中，通常与&lt;b&gt;一行&lt;/b&gt;或一组以空行终止的行（&amp;ldquo;段落&amp;rdquo;）相对应。每行</target>
        </trans-unit>
        <trans-unit id="1e3ce769bdcb624305623c0e39fad86b6550d415" translate="yes" xml:space="preserve">
          <source>A set of users of which you are a member. In some operating systems (like Unix), you can give certain file access permissions to other members of your group.</source>
          <target state="translated">你是其中一员的一组用户。在某些操作系统中(如Unix),你可以给你的组的其他成员一定的文件访问权限。</target>
        </trans-unit>
        <trans-unit id="a3f080c404572d6a66e864a2fec8d37666d88fa5" translate="yes" xml:space="preserve">
          <source>A set of version requirements for a CPAN dist</source>
          <target state="translated">一套CPAN dist的版本要求。</target>
        </trans-unit>
        <trans-unit id="a023ae4922155fc45ad5e15036082f2112e5376d" translate="yes" xml:space="preserve">
          <source>A seven-bit safe (non-eight-bit) encoding, which is useful if the transport or storage is not eight-bit safe. Defined by RFC 2152.</source>
          <target state="translated">七位安全(非八位)编码,在传输或存储不是八位安全的情况下很有用。由RFC 2152定义。</target>
        </trans-unit>
        <trans-unit id="a600cb53b0fe3c2106640728c33066b8be46fd29" translate="yes" xml:space="preserve">
          <source>A short description of the function of the op.</source>
          <target state="translated">简要说明行动纲领的功能;</target>
        </trans-unit>
        <trans-unit id="d96648e3b3628e3e472e306b3dd3028622349739" translate="yes" xml:space="preserve">
          <source>A short description of your module, what it does, why someone would use it and its limitations. CPAN automatically pulls your README file out of the archive and makes it available to CPAN users, it is the first thing they will read to decide if your module is right for them.</source>
          <target state="translated">简短的描述你的模块,它的作用,为什么有人会使用它,以及它的限制。CPAN会自动从档案中提取您的README文件,并将其提供给CPAN用户,这是他们决定您的模块是否适合他们的第一件事。</target>
        </trans-unit>
        <trans-unit id="3eb927617c6b6dee09c1f05661af50c2789df3ce" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7054451d8531a19f5986333d608566f0e421b059" translate="yes" xml:space="preserve">
          <source>A short name for your op. This will be included in some error messages, and will also be returned as &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; by the &lt;a href=&quot;b&quot;&gt;B&lt;/a&gt; module, so it will appear in the output of module like &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">您的操作的简称。这将包含在某些错误消息中，并且还将由&lt;a href=&quot;b&quot;&gt;B&lt;/a&gt;模块作为 &lt;code&gt;$op-&amp;gt;name&lt;/code&gt; 返回，因此它将出现在模块&lt;a href=&quot;b/concise&quot;&gt;B :: Concise之&lt;/a&gt;类的输出中。</target>
        </trans-unit>
        <trans-unit id="659172f97956f35000461e8175c3ae20d404aec4" translate="yes" xml:space="preserve">
          <source>A short usage summary for programs and functions. This section is mandatory for section 3 pages. For Perl module documentation, it's usually convenient to have the contents of this section be a verbatim block showing some (brief) examples of typical ways the module is used.</source>
          <target state="translated">程序和功能的简短使用总结。在第3节的页面中,本节是必须的。对于Perl模块文档来说,通常方便的做法是将本节的内容作为一个逐字块,展示一些(简要的)模块的典型使用方法的例子。</target>
        </trans-unit>
        <trans-unit id="ecd576fa5b368299ace3b5dd153caef33335850b" translate="yes" xml:space="preserve">
          <source>A shortcut for $token-&amp;gt;tagname(...)</source>
          <target state="translated">$ token-&amp;gt; tagname（...）的快捷方式</target>
        </trans-unit>
        <trans-unit id="889d9060f1528398717f26dcafe44f09ac88a287" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;binf(). Useful because Perl does not always handle bareword &lt;code&gt;inf&lt;/code&gt; properly.</source>
          <target state="translated">返回Math :: BigInt-&amp;gt; binf（）的快捷方式。很有用，因为Perl并不总是正确地处理裸字 &lt;code&gt;inf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c597d44b686300cfd664e15765135328081ac79a" translate="yes" xml:space="preserve">
          <source>A shortcut to return Math::BigInt-&amp;gt;bnan(). Useful because Perl does not always handle bareword &lt;code&gt;NaN&lt;/code&gt; properly.</source>
          <target state="translated">返回Math :: BigInt-&amp;gt; bnan（）的快捷方式。很有用，因为Perl并不总是正确处理准字 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="588514bdb3ad44f23f4111f5dfe923f166cc27ed" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;eq&lt;/code&gt;&lt;/a&gt; to see if two references refer to the same thing. (But you should usually use &lt;a href=&quot;perlop#Equality-Operators&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; instead because it's much faster.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2bf7bb028dd860429a797ea74f61d6f6006cc5" translate="yes" xml:space="preserve">
          <source>A side effect of this representation is that you can use &lt;code&gt;eq&lt;/code&gt; to see if two references refer to the same thing. (But you should usually use &lt;code&gt;==&lt;/code&gt; instead because it's much faster.)</source>
          <target state="translated">这种表示的副作用是您可以使用 &lt;code&gt;eq&lt;/code&gt; 来查看两个引用是否引用同一事物。 （但是您通常应该使用 &lt;code&gt;==&lt;/code&gt; 代替，因为它快得多。）</target>
        </trans-unit>
        <trans-unit id="521c212b6a17d7bb672fae4188d350c73713a7f4" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="translated">印记，后跟与 &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; 属性匹配的单个字符，例如 &lt;code&gt;$!&lt;/code&gt; 或 &lt;code&gt;%+&lt;/code&gt; ，但字符 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 不起作用。</target>
        </trans-unit>
        <trans-unit id="78b33a149b8ec79d1db1e7ff3c6da388ca1d2f6f" translate="yes" xml:space="preserve">
          <source>A sigil followed by a single character matching the &lt;code&gt;\p{POSIX_Punct}&lt;/code&gt; property, like &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, except the character &lt;code&gt;&quot;{&quot;&lt;/code&gt; doesn't work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ab0e2e7434b80376db123861053e1dd6f58146" translate="yes" xml:space="preserve">
          <source>A sigil, followed by a caret and any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96dcc4bc70d20a77f933afc7e767e66a7d6afd1e" translate="yes" xml:space="preserve">
          <source>A sigil, followed by any single character in the range &lt;code&gt;[\xA1-\xAC\xAE-\xFF]&lt;/code&gt; when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;. (Under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, the normal identifier rules given earlier in this section apply.) Use of non-graphic characters (the C1 controls, the NO-BREAK SPACE, and the SOFT HYPHEN) has been disallowed since v5.26.0. The use of the other characters is unwise, as these are all reserved to have special meaning to Perl, and none of them currently do have special meaning, though this could change without notice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cc8d7ea546cfbfc32e7048bc99953161b5c5af3" translate="yes" xml:space="preserve">
          <source>A sigil, followed by either a caret and a single POSIX uppercase letter, like &lt;code&gt;$^V&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; , or a sigil followed by a literal non-space, non-&lt;code&gt;NUL&lt;/code&gt; control character matching the &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; property. Due to a historical oddity, if not running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the 128 characters in the &lt;code&gt;[0x80-0xff]&lt;/code&gt; range are considered to be controls, and may also be used in length-one variables. However, the use of non-graphical characters is deprecated as of v5.22, and support for them will be removed in a future version of perl. ASCII space characters and &lt;code&gt;NUL&lt;/code&gt; already aren't allowed, so this means that a single-character variable name with that name being any other C0 control &lt;code&gt;[0x01-0x1F]&lt;/code&gt; , or &lt;code&gt;DEL&lt;/code&gt; will generate a deprecated warning. Already, under &lt;code&gt;&quot;use
utf8&quot;&lt;/code&gt; , non-ASCII characters must match &lt;code&gt;Perl_XIDS&lt;/code&gt; . As of v5.22, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1 controls &lt;code&gt;[0x80-0x9F]&lt;/code&gt; , NO BREAK SPACE, and SOFT HYPHEN (&lt;code&gt;SHY&lt;/code&gt; )) generate a deprecated warning.</source>
          <target state="translated">标记，后跟插入符号和单个POSIX大写字母（例如 &lt;code&gt;$^V&lt;/code&gt; 或 &lt;code&gt;$^W&lt;/code&gt; ，或 &lt;code&gt;\p{POSIX_Cntrl}&lt;/code&gt; 与\ p {POSIX_Cntrl}属性匹配的文字非空格，非 &lt;code&gt;NUL&lt;/code&gt; 字符。由于历史原因，如果未在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; utf8的情况下运行，则 &lt;code&gt;[0x80-0xff]&lt;/code&gt; 范围内的128个字符将被视为控件，并且也可以在长度为1的变量中使用。但是，从v5.22开始，不再使用非图形字符，并且在以后的perl版本中将不再支持它们。 ASCII空格字符和 &lt;code&gt;NUL&lt;/code&gt; 已经不允许使用，因此这意味着一个单字符变量名称（该名称是任何其他C0控件 &lt;code&gt;[0x01-0x1F]&lt;/code&gt; 或 &lt;code&gt;DEL&lt;/code&gt; )将生成已弃用的警告。在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; ，非ASCII字符必须已经与 &lt;code&gt;Perl_XIDS&lt;/code&gt; 匹配。从v5.22开始，当不在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; C1控件 &lt;code&gt;[0x80-0x9F]&lt;/code&gt; ，NO BREAK SPACE和SOFT HYPHEN（ &lt;code&gt;SHY&lt;/code&gt; ））会生成不建议使用的警告。</target>
        </trans-unit>
        <trans-unit id="25c7b41e2f3083fca5663c24cdf9d0f7721da4bb" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; , like &lt;code&gt;$0&lt;/code&gt; , &lt;code&gt;$1&lt;/code&gt; , or &lt;code&gt;$10000&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\p{POSIX_Digit}&lt;/code&gt; ，仅跟\ p {POSIX_Digit}匹配的数字，例如 &lt;code&gt;$0&lt;/code&gt; ， &lt;code&gt;$1&lt;/code&gt; 或 &lt;code&gt;$10000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a882085b42cb0bab19f2ed527e7af342a0ee517" translate="yes" xml:space="preserve">
          <source>A sigil, followed solely by digits matching &lt;code&gt;\p{POSIX_Digit}&lt;/code&gt;, like &lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, or &lt;code&gt;$10000&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3df970159f7cc9815aae935a27c2abc1cbc161b" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c803de64703554f9c3355b0bb0b711df0025cdae" translate="yes" xml:space="preserve">
          <source>A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</source>
          <target state="translated">当输入的参数不是数字或结果是0/0时,用'NaN'符号来表示结果。当一个正数除以0时,你将得到'+inf',而当任何负数除以0时,将得到'-inf'。</target>
        </trans-unit>
        <trans-unit id="acfa2fff17c2c760f059166beff68ca97cf27024" translate="yes" xml:space="preserve">
          <source>A signature may be entirely empty, in which case all it does is check that the caller passed no arguments:</source>
          <target state="translated">一个签名可能是完全空的,在这种情况下,它所做的就是检查调用者没有传递任何参数。</target>
        </trans-unit>
        <trans-unit id="31a0e78fd112747fd282a616f307965e9e97ecc5" translate="yes" xml:space="preserve">
          <source>A signature parameter must start with '$', '@' or '%'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b7bfaadf566cb42bb060b59ab39877bdce37fb" translate="yes" xml:space="preserve">
          <source>A signed integer. This is cast to the required integer type when passed to C and converted to an IV when passed back to Perl.</source>
          <target state="translated">一个有符号的整数。当传递到C语言时,会被转换为所需的整数类型,当传递回Perl时,会被转换为IV。</target>
        </trans-unit>
        <trans-unit id="1575087c19c9eb3e9ca21e23f5fecff11363ecdb" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="translated">有符号整数。此类型映射将Perl值转换为本地整数类型（当前平台上的 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 类型）。当将值返回给perl时，其处理方式与T_IV相同。</target>
        </trans-unit>
        <trans-unit id="f69f9b6922b305d309dd50acaf19b40451a94ff0" translate="yes" xml:space="preserve">
          <source>A signed integer. This typemap converts the Perl value to a native integer type (the &lt;code&gt;int&lt;/code&gt; type on the current platform). When returning the value to perl it is processed in the same way as for T_IV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a6e260265e056207c62a15cda251b7b04ab7de2" translate="yes" xml:space="preserve">
          <source>A significant number of the bug reports we get turn out to be documented features in Perl. Make sure the issue you've run into isn't intentional by glancing through the documentation that comes with the Perl distribution.</source>
          <target state="translated">我们收到的大量错误报告都是Perl中的文档功能。通过浏览一下Perl发行版附带的文档,确保你遇到的问题不是故意的。</target>
        </trans-unit>
        <trans-unit id="80837079263cda7d0c48b62c5a2b8e0aa29ed989" translate="yes" xml:space="preserve">
          <source>A similar but more subtle problem is illustrated with this code:</source>
          <target state="translated">一个类似但更微妙的问题用这段代码来说明。</target>
        </trans-unit>
        <trans-unit id="81ab11bae0fce0f2612a231d95d1eecf127ccce2" translate="yes" xml:space="preserve">
          <source>A similar effect applies to</source>
          <target state="translated">类似的效果也适用于</target>
        </trans-unit>
        <trans-unit id="a23425aa80f51fe5db313d5664fb7ac8f4d286d0" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, although you can use &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">尽管可以使用 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 代替，但是类似的策略也可以通过 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 进行通配符扩展。</target>
        </trans-unit>
        <trans-unit id="676cee5371668926c1dabdcd2aa4d10e661b2ca7" translate="yes" xml:space="preserve">
          <source>A similar strategy would work for wildcard expansion via &lt;code&gt;glob&lt;/code&gt;, although you can use &lt;code&gt;readdir&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1349e3e7bc2ad99052d135eb76b4bea7da2dc2" translate="yes" xml:space="preserve">
          <source>A similar task is to find words consisting of two identical parts:</source>
          <target state="translated">一个类似的任务是找到由两个相同部分组成的单词。</target>
        </trans-unit>
        <trans-unit id="ee2213ceffd8c1f2a6f17c3aee8ab7cdf3d4092c" translate="yes" xml:space="preserve">
          <source>A similar trick involves the</source>
          <target state="translated">类似的技巧还包括</target>
        </trans-unit>
        <trans-unit id="8848997a2920d88084bbf780cebe39466ec879ee" translate="yes" xml:space="preserve">
          <source>A simple API to convert seconds to other date values</source>
          <target state="translated">一个简单的API,将秒数转换为其他日期值。</target>
        </trans-unit>
        <trans-unit id="c123404763bd10d42cf8e7c2eaf59ecc97ce202f" translate="yes" xml:space="preserve">
          <source>A simple boolean indicating if the command executed without errors or not.</source>
          <target state="translated">一个简单的布尔值,表示命令是否无误执行。</target>
        </trans-unit>
        <trans-unit id="5bd4089058361e948e8b28ab1128c297a0f82d9e" translate="yes" xml:space="preserve">
          <source>A simple call to &lt;code&gt;isnt()&lt;/code&gt; usually does not provide a strong test but there are cases when you cannot say much more about a value than that it is different from some other value:</source>
          <target state="translated">对 &lt;code&gt;isnt()&lt;/code&gt; 的简单调用通常不会提供强大的测试，但是在某些情况下，您不能说出太多关于某个值与该值与其他值的不同之处：</target>
        </trans-unit>
        <trans-unit id="4fbcc760723f31ac561f9cef482138111eb6931b" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt; and &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or false if not both are installed.</source>
          <target state="translated">一个简单的检查例程，如果 &lt;code&gt;Archive::Tar&lt;/code&gt; 能够使用 &lt;code&gt;IO::Zlib&lt;/code&gt; 和 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 快速解压缩压缩的存档，则返回true；如果未同时安装两个，则返回false。</target>
        </trans-unit>
        <trans-unit id="10951c632f33a4f0fc994717dc96bab5fd305add" translate="yes" xml:space="preserve">
          <source>A simple checking routine, which will return true if &lt;code&gt;Archive::Tar&lt;/code&gt; is able to uncompress compressed archives on the fly with &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Xz&lt;/code&gt; or false if not both are installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc5b3faec4a3f9f01b28a9e7d12132d66ab6e1d" translate="yes" xml:space="preserve">
          <source>A simple listing of all the files in your distribution.</source>
          <target state="translated">一个简单的列表,列出你的发行版中的所有文件。</target>
        </trans-unit>
        <trans-unit id="372959c464065982896bbbe2c2818eb6cad5f8a5" translate="yes" xml:space="preserve">
          <source>A simple mapping of the op type number to its type (like 'COP' or 'BINOP').</source>
          <target state="translated">一个简单的操作类型号到其类型的映射(如'COP'或'BINOP')。</target>
        </trans-unit>
        <trans-unit id="d472680931a17874166dba160d7f69e6352eb56b" translate="yes" xml:space="preserve">
          <source>A simple read-only accessor simply gets the value of a single attribute:</source>
          <target state="translated">一个简单的只读访问器只是简单地获取一个单一属性的值。</target>
        </trans-unit>
        <trans-unit id="681ff201b3498a43f7a62245e78650fd37d86b77" translate="yes" xml:space="preserve">
          <source>A simple scalar number</source>
          <target state="translated">一个简单的标量数</target>
        </trans-unit>
        <trans-unit id="1b93dcb8f21d326777ddc52bfa4bdd011dd04c4a" translate="yes" xml:space="preserve">
          <source>A simple scalar string</source>
          <target state="translated">一个简单的标量字符串</target>
        </trans-unit>
        <trans-unit id="5776d9f23e070178afac4296b05b65fd1f748404" translate="yes" xml:space="preserve">
          <source>A simple scalar with an extra reference</source>
          <target state="translated">一个带有额外参考的简单标量</target>
        </trans-unit>
        <trans-unit id="f593aa1a652c40c9b2c700bcf9bdc1dacfbe433a" translate="yes" xml:space="preserve">
          <source>A simple summary of the tests so far. True for pass, false for fail. This is a logical pass/fail, so todos are passes.</source>
          <target state="translated">简单总结一下目前的测试情况。True代表通过,false代表失败。这是一个逻辑上的通过/失败,所以todos是通过。</target>
        </trans-unit>
        <trans-unit id="e9ed86741cb6e707485ef431b1b242bee25c8fe1" translate="yes" xml:space="preserve">
          <source>A simple, singular value; a number, &lt;b&gt;string&lt;/b&gt;, or &lt;b&gt;reference&lt;/b&gt;.</source>
          <target state="translated">一个简单的奇异值；数字，&lt;b&gt;字符串&lt;/b&gt;或&lt;b&gt;参考&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="41fbe0f5dde0b71cac36adde6b1e65c7f6388dac" translate="yes" xml:space="preserve">
          <source>A single &lt;code&gt;/x&lt;/code&gt; tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a bracketed character class. You can use this to break up your regular expression into more readable parts. Also, the &lt;code&gt;&quot;#&quot;&lt;/code&gt; character is treated as a metacharacter introducing a comment that runs up to the pattern's closing delimiter, or to the end of the current line if the pattern extends onto the next line. Hence, this is very much like an ordinary Perl code comment. (You can include the closing delimiter within the comment only if you precede it with a backslash, so be careful!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7d12449647b7d47425008bd7d9de56b3bffa22" translate="yes" xml:space="preserve">
          <source>A single character that represents the end of a line, with the ASCII value of 012 octal under Unix (but 015 on a Mac), and represented by &lt;code&gt;\n&lt;/code&gt; in Perl strings. For Windows machines writing text files, and for certain physical devices like terminals, the single newline gets automatically translated by your C library into a line feed and a carriage return, but normally, no translation is done.</source>
          <target state="translated">一个代表行尾的单个字符，Unix下为ASCII八进制012值（在Mac上为015），在Perl字符串中用 &lt;code&gt;\n&lt;/code&gt; 表示。对于编写文本文件的Windows计算机以及某些物理设备（如终端机），单个换行符将由C库自动转换为换行符和回车符，但通常不进行任何转换。</target>
        </trans-unit>
        <trans-unit id="2a1618c928b45217b1ecfab89b72e2f9c62e981a" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt; . This will match strings like &amp;ldquo;&lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">具有多种解释的单个实体，例如大象。对于计算机科学家来说，这是一种小语言的语法，其中有些字符串合法，而有些则不合法。对于普通人来说，这是一种模式，您可以使用它来找到所要查找的内容，具体情况视情况而定。 Perl的正则表达式在理论上远非正则，但在正则使用中它们工作得很好。这是一个正则表达式： &lt;code&gt;/Oh s.*t./&lt;/code&gt; 。这将匹配诸如&amp;ldquo; &lt;code&gt;Oh &lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt; can you see by the dawn's early light&lt;/code&gt; &amp;rdquo;之类的字符串，以及&amp;ldquo; &lt;code&gt;Oh sit!&lt;/code&gt; &amp;rdquo;。请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bd9d52f50401e07be14bc39be94bfc90b5fed1b7" translate="yes" xml:space="preserve">
          <source>A single entity with various interpretations, like an elephant. To a computer scientist, it&amp;rsquo;s a grammar for a little language in which some strings are legal and others aren&amp;rsquo;t. To normal people, it&amp;rsquo;s a pattern you can use to find what you&amp;rsquo;re looking for when it varies from case to case. Perl&amp;rsquo;s regular expressions are far from regular in the theoretical sense, but in regular use they work quite well. Here&amp;rsquo;s a regular expression: &lt;code&gt;/Oh s.*t./&lt;/code&gt;. This will match strings like &amp;ldquo;&lt;code&gt;Oh say can you see by the dawn's early light&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;Oh sit!&lt;/code&gt;&amp;rdquo;. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c7b2b0b88a0fcb03de95938de74348bdc84aea" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UNICODE_GOT_SURROGATE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823574b7a9a841c68fa3382fefc5234c4a20c603" translate="yes" xml:space="preserve">
          <source>A single flag bit associated with this message, in a &lt;code&gt;SVuv&lt;/code&gt;. The bit corresponds to some bit in the &lt;code&gt;*errors&lt;/code&gt; return value, such as &lt;code&gt;UTF8_GOT_LONG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="829152f3dcb1ed16bfc3e8ca36bfa63ebf05d7eb" translate="yes" xml:space="preserve">
          <source>A single hexadecimal number denoting a code point to include.</source>
          <target state="translated">一个单一的十六进制数字,表示要包括的代码点。</target>
        </trans-unit>
        <trans-unit id="27a4bf6aaf65d7e6150de844a569f0f9a5f667a4" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="translated">单个数字或字符串数​​据，是较长的&lt;b&gt;字符串&lt;/b&gt;，&lt;b&gt;记录&lt;/b&gt;或&lt;b&gt;行的一部分&lt;/b&gt;。宽度可变的字段通常由&lt;b&gt;分隔符&lt;/b&gt;分开（因此请使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 提取字段），而宽度固定的字段通常位于固定位置（因此请使用 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ）。&lt;b&gt;实例变量&lt;/b&gt;也称为&amp;ldquo;字段&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9c9a04c7fe7162d287f0a6bf5101410d1b801612" translate="yes" xml:space="preserve">
          <source>A single piece of numeric or string data that is part of a longer &lt;b&gt;string&lt;/b&gt;, &lt;b&gt;record&lt;/b&gt;, or &lt;b&gt;line&lt;/b&gt;. Variable-width fields are usually split up by &lt;b&gt;separators&lt;/b&gt; (so use &lt;code&gt;split&lt;/code&gt; to extract the fields), while fixed-width fields are usually at fixed positions (so use &lt;code&gt;unpack&lt;/code&gt;). &lt;b&gt;Instance variables&lt;/b&gt; are also known as &amp;ldquo;fields&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff4db73bde7c1d7cfd3e2062dd1951912b9e366" translate="yes" xml:space="preserve">
          <source>A single symbol abbreviating the class of the OP.</source>
          <target state="translated">单一符号缩写的上位机类。</target>
        </trans-unit>
        <trans-unit id="ed641668fea177eedad336e7089851d18b828e16" translate="yes" xml:space="preserve">
          <source>A single testing job.</source>
          <target state="translated">单项测试工作。</target>
        </trans-unit>
        <trans-unit id="41bf4051bfbbef3d6c2986f2065087b05c2359b5" translate="yes" xml:space="preserve">
          <source>A single-quoted, literal string. A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.</source>
          <target state="translated">一个单引号的字符串。反斜杠代表反斜杠,除非后面有定界符或另一个反斜杠,在这种情况下,定界符或反斜杠将被插入。</target>
        </trans-unit>
        <trans-unit id="8add36465a616cf6d47e4a5aef01fb690927c1f3" translate="yes" xml:space="preserve">
          <source>A slice accesses several elements of a list, an array, or a hash simultaneously using a list of subscripts. It's more convenient than writing out the individual elements as a list of separate scalar values.</source>
          <target state="translated">分片使用一个下标列表同时访问一个列表、一个数组或一个哈希中的多个元素。这比将单个元素写成一个独立的标量值列表要方便得多。</target>
        </trans-unit>
        <trans-unit id="7f8a4967d94ac75566470d147a5f123047048bbb" translate="yes" xml:space="preserve">
          <source>A slight modification also removes C++ comments, possibly spanning multiple lines using a continuation character:</source>
          <target state="translated">稍微修改一下,还可以删除C++注释,可能使用延续字符跨越多行。</target>
        </trans-unit>
        <trans-unit id="e99cb7094afcbc76a76c4efa1f4eefdffe5bff51" translate="yes" xml:space="preserve">
          <source>A slightly larger piece of code will provide something on which a profiler can produce more extensive reporting statistics. This example uses the simplistic &lt;code&gt;wordmatch&lt;/code&gt; program which parses a given input file and spews out a short report on the contents.</source>
          <target state="translated">稍大一些的代码将提供一些信息，探查器可以在这些信息上生成更广泛的报告统计信息。本示例使用简单的 &lt;code&gt;wordmatch&lt;/code&gt; 程序，该程序解析给定的输入文件，并针对内容弹出简短的报告。</target>
        </trans-unit>
        <trans-unit id="03934c7f98da92e385e9ea42d12c3ed3bec3632f" translate="yes" xml:space="preserve">
          <source>A slurpy hash parameter may be nameless just like other kinds of parameter. It still insists that the number of arguments available to it be even, even though they're not being put into a variable.</source>
          <target state="translated">稀疏的哈希参数可以像其他种类的参数一样是无名的。它仍然坚持它可用的参数数量是偶数,即使它们没有被放入一个变量中。</target>
        </trans-unit>
        <trans-unit id="30988eefa9eacb81270153c8608fad35b31b7f98" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may instead be a hash, in which case the arguments available to it are interpreted as alternating keys and values. There must be as many keys as values: if there is an odd argument then an exception will be thrown. Keys will be stringified, and if there are duplicates then the later instance takes precedence over the earlier, as with standard hash construction.</source>
          <target state="translated">稀疏参数可以是一个哈希值,在这种情况下,它的可用参数被解释为交替的键和值。键和值的数量必须一样多:如果有一个奇数参数,那么将抛出一个异常。键将被串联,如果有重复,那么后面的实例将优先于前面的,就像标准的哈希结构一样。</target>
        </trans-unit>
        <trans-unit id="7ae153b0845a4f9cd82e184d9134e9263fb0358d" translate="yes" xml:space="preserve">
          <source>A slurpy parameter may not have a default value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d8ab783e8ae2210ac2fb7506feb3637ad91b4b" translate="yes" xml:space="preserve">
          <source>A slurpy parameter, either array or hash, must be the last thing in the signature. It may follow mandatory and optional positional parameters; it may also be the only thing in the signature. Slurpy parameters cannot have default values: if no arguments are supplied for them then you get an empty array or empty hash.</source>
          <target state="translated">一个模糊参数,无论是数组还是散列,必须是签名中的最后一件东西。它可以跟在强制参数和可选的位置参数后面;它也可以是签名中唯一的东西。稀疏参数不能有默认值:如果没有提供任何参数,那么你会得到一个空数组或空哈希。</target>
        </trans-unit>
        <trans-unit id="c7ed55a78ba712132c2ae6c86e583e8efc503821" translate="yes" xml:space="preserve">
          <source>A small example demonstrating SysV message queues:</source>
          <target state="translated">一个演示SysV消息队列的小例子。</target>
        </trans-unit>
        <trans-unit id="15bb640f66c323688300cc265de617018ed0c375" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&amp;gt; 1&lt;/code&gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0014acccc6b5556fca51e530830260283cc77d0" translate="yes" xml:space="preserve">
          <source>A small script which yields the problem will probably be of help. It would also be useful if this script was run with the extra options &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt; passed to the constructor, and the output sent with the bug report. If you cannot include a small script then please include a Debug trace from a run of your program which does yield the problem.</source>
          <target state="translated">产生问题的小脚本可能会有所帮助。如果在运行此脚本时将额外的选项 &lt;code&gt;Debug =&lt;/code&gt; 1&amp;gt;传递给构造函数，并且将输出与错误报告一起发送，则将很有用。如果您不能包含小的脚本，则请包含程序运行中的调试跟踪，这确实会产生问题。</target>
        </trans-unit>
        <trans-unit id="c165dd6d48bb6848a9c96904378fd915f9518c69" translate="yes" xml:space="preserve">
          <source>A small, simple, correct HTTP/1.1 client</source>
          <target state="translated">一个小巧、简单、正确的HTTP/1.1客户端。</target>
        </trans-unit>
        <trans-unit id="27545b929364aeeb83be800c720a5090d4d35630" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; .</source>
          <target state="translated">使用显式 &lt;code&gt;~~&lt;/code&gt; 运算符（例如 &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt; )的智能匹配。</target>
        </trans-unit>
        <trans-unit id="0b57b94fbdb028a48b1bf7791227cc60c86bb4ce" translate="yes" xml:space="preserve">
          <source>A smart match that uses an explicit &lt;code&gt;~~&lt;/code&gt; operator, such as &lt;code&gt;EXPR ~~ EXPR&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee7049b5826d72a2f103072d053d50784d7d0da" translate="yes" xml:space="preserve">
          <source>A sneaky &lt;code&gt;LC_COLLATE&lt;/code&gt; locale could result in the names of students with &quot;D&quot; grades appearing ahead of those with &quot;A&quot;s.</source>
          <target state="translated">偷偷摸摸的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境可能会导致&amp;ldquo; D&amp;rdquo;级学生的名字出现在&amp;ldquo; A&amp;rdquo;级学生的名字之前。</target>
        </trans-unit>
        <trans-unit id="3fa57a01d182c489f4440aa3ceec23094b8bdecb" translate="yes" xml:space="preserve">
          <source>A solution to this and many similar issues is to use the &lt;code&gt;mem&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd3117b0bc435a9ddefeeeda5fe0b0754edfcc4" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt; . It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="translated">解决方案是使用使用伪脚本的库，使程序的行为更合理。这样，您不必控制正在使用的程序的源代码。CPAN 的 &lt;code&gt;Expect&lt;/code&gt; 模块也解决了这类问题。该模块需要来自CPAN的其他两个模块： &lt;code&gt;IO::Pty&lt;/code&gt; 和 &lt;code&gt;IO::Stty&lt;/code&gt; 。它设置了一个伪终端，以与坚持与终端设备驱动程序对话的程序进行交互。如果您的系统受支持，那么这也许是最好的选择。</target>
        </trans-unit>
        <trans-unit id="8b65901bcbb4cd6d842da55cf32921b07fcc8591" translate="yes" xml:space="preserve">
          <source>A solution to this is to use a library which uses pseudottys to make your program behave more reasonably. This way you don't have to have control over the source code of the program you're using. The &lt;code&gt;Expect&lt;/code&gt; module from CPAN also addresses this kind of thing. This module requires two other modules from CPAN, &lt;code&gt;IO::Pty&lt;/code&gt; and &lt;code&gt;IO::Stty&lt;/code&gt;. It sets up a pseudo terminal to interact with programs that insist on talking to the terminal device driver. If your system is supported, this may be your best bet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d33fafbade920ec9b14eb3241088b584cc3390" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UNICODE_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UNICODE_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because on EBCDIC platforms,these flags can apply to code points that actually do fit in 31 bits. The new names accurately describe the situation in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b41ba2a5e34ef24872cc78663b3c8e0fdb24a9d8" translate="yes" xml:space="preserve">
          <source>A somewhat misleadingly named synonym for &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; is retained for backward compatibility: &lt;code&gt;UTF8_WARN_ABOVE_31_BIT&lt;/code&gt;. Similarly, &lt;code&gt;UTF8_DISALLOW_ABOVE_31_BIT&lt;/code&gt; is usable instead of the more accurately named &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt;. The names are misleading because these flags can apply to code points that actually do fit in 31 bits. This happens on EBCDIC platforms, and sometimes when the &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;overlong malformation&lt;/a&gt; is also present. The new names accurately describe the situation in all cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b80c1598a0b057abd1403fd2b9a7dc757cff1ce" translate="yes" xml:space="preserve">
          <source>A source filter is a special kind of Perl module that intercepts and modifies a source stream before it reaches the parser. A source filter changes our diagram like this:</source>
          <target state="translated">源过滤器是一种特殊的Perl模块,它可以在源流到达解析器之前对其进行拦截和修改。源过滤器改变了我们的图表,就像这样。</target>
        </trans-unit>
        <trans-unit id="8b0be58db42e648ec049b8d1ddee43ac5d107082" translate="yes" xml:space="preserve">
          <source>A space (or colon) separated list of PerlIO layers. If perl is built to use PerlIO system for IO (the default) these layers affect Perl's IO.</source>
          <target state="translated">用空格(或冒号)分隔的PerlIO层列表。如果perl是为了使用PerlIO系统进行IO而构建的(默认情况下),这些层会影响Perl的IO。</target>
        </trans-unit>
        <trans-unit id="0badf9ed68d3af0c4f3cd1c0a7af9f9020afc01b" translate="yes" xml:space="preserve">
          <source>A special &lt;b&gt;method&lt;/b&gt; that is called when an &lt;b&gt;object&lt;/b&gt; is thinking about &lt;b&gt;destroying&lt;/b&gt; itself. A Perl program&amp;rsquo;s &lt;code&gt;DESTROY&lt;/code&gt; method doesn&amp;rsquo;t do the actual destruction; Perl just &lt;b&gt;triggers&lt;/b&gt; the method in case the &lt;b&gt;class&lt;/b&gt; wants to do any associated cleanup.</source>
          <target state="translated">当&lt;b&gt;对象&lt;/b&gt;考虑&lt;b&gt;销毁&lt;/b&gt;自身时调用的一种特殊&lt;b&gt;方法&lt;/b&gt;。Perl程序的 &lt;code&gt;DESTROY&lt;/code&gt; 方法不会进行实际的销毁。如果&lt;b&gt;类&lt;/b&gt;想要进行任何关联的清理，Perl只会&lt;b&gt;触发&lt;/b&gt;该方法。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ef35c437c5c84fa1b46b5dc38d46f6fde11ec243" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="translated">特殊情况是表达式是子例程引用（使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; 语法或 &lt;code&gt;\&amp;amp;foo&lt;/code&gt; 语法）。在这种情况下，它会被执行，其值（真或假）确定测试是否通过。例如，</target>
        </trans-unit>
        <trans-unit id="9916746eced8e5680d9be3db4c1b0f01137572d1" translate="yes" xml:space="preserve">
          <source>A special case is if the expression is a subroutine reference (in either &lt;code&gt;sub {...}&lt;/code&gt; syntax or &lt;code&gt;\&amp;amp;foo&lt;/code&gt; syntax). In that case, it is executed and its value (true or false) determines if the test passes or fails. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d4bdb3b56feee845f988c80b59a2de393b4d25c" translate="yes" xml:space="preserve">
          <source>A special entry &lt;code&gt;GetOptionsFromString&lt;/code&gt; can be used to parse options from an arbitrary string.</source>
          <target state="translated">特殊条目 &lt;code&gt;GetOptionsFromString&lt;/code&gt; 可用于解析任意字符串中的选项。</target>
        </trans-unit>
        <trans-unit id="f5f25c2de52c4c00b53b25ba03c614f087fa031c" translate="yes" xml:space="preserve">
          <source>A special file that contains other files. Some &lt;b&gt;operating systems&lt;/b&gt; call these &amp;ldquo;folders&amp;rdquo;, &amp;ldquo;drawers&amp;rdquo;, &amp;ldquo;catalogues&amp;rdquo;, or &amp;ldquo;catalogs&amp;rdquo;.</source>
          <target state="translated">包含其他文件的特殊文件。一些&lt;b&gt;操作系统将其&lt;/b&gt;称为&amp;ldquo;文件夹&amp;rdquo;，&amp;ldquo;抽屉&amp;rdquo;，&amp;ldquo;目录&amp;rdquo;或&amp;ldquo;目录&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9d4dee1bf51d9988b7b651c7e34b5ae56c3d23f3" translate="yes" xml:space="preserve">
          <source>A special form is the &lt;code&gt;(DEFINE)&lt;/code&gt; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.</source>
          <target state="translated">&lt;code&gt;(DEFINE)&lt;/code&gt; 谓词是一种特殊形式，它从不直接执行其yes-pattern，并且不允许使用no-pattern。这样就可以定义只能由递归机制执行的子模式。这样，您可以定义一组正则表达式规则，这些规则规则可以捆绑到您选择的任何模式中。</target>
        </trans-unit>
        <trans-unit id="098ae82dbb47389fd0f04911d56700422f9e1bbd" translate="yes" xml:space="preserve">
          <source>A special internal spot in which Perl keeps the information about the last &lt;b&gt;file&lt;/b&gt; on which you requested information.</source>
          <target state="translated">一个特殊的内部位置，Perl在其中保留有关您请求信息的最后一个&lt;b&gt;文件的&lt;/b&gt;信息。</target>
        </trans-unit>
        <trans-unit id="79eddc4100fb4306d07fc838a90fb71a102a9485" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;module&lt;/b&gt; that does &lt;b&gt;preprocessing&lt;/b&gt; on your script just before it gets to the &lt;b&gt;tokener&lt;/b&gt;.</source>
          <target state="translated">一种特殊的&lt;b&gt;模块&lt;/b&gt;，它&lt;b&gt;预处理&lt;/b&gt;对你的脚本它到达之前&lt;b&gt;tokener&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0c845e10d2c5e7d853c713ce339e272a56f03f5c" translate="yes" xml:space="preserve">
          <source>A special kind of &lt;b&gt;scalar context&lt;/b&gt; used in conditionals to decide whether the &lt;b&gt;scalar value&lt;/b&gt; returned by an expression is &lt;b&gt;true&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;. Does not evaluate as either a string or a number. See &lt;b&gt;context&lt;/b&gt;.</source>
          <target state="translated">一种条件条件&lt;b&gt;中&lt;/b&gt;使用的特殊类型的&lt;b&gt;标量上下文，&lt;/b&gt;用于确定表达式返回的&lt;b&gt;标量值&lt;/b&gt;是&lt;b&gt;true&lt;/b&gt;还是&lt;b&gt;false&lt;/b&gt;。既不算字符串也不算数字。参见&lt;b&gt;上下文&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="89b7b57b006b340679bccefff3860259f11cee5d" translate="yes" xml:space="preserve">
          <source>A special note about fetching files from an ftp uri:</source>
          <target state="translated">关于从ftp uri中获取文件的特别说明。</target>
        </trans-unit>
        <trans-unit id="daa44f44af6529c7f53a78e2c82f295d89b6e71e" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a568b09a052a4fda0da31a9dd45e8de43daae28" translate="yes" xml:space="preserve">
          <source>A special option 'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; can be used to designate a subroutine to handle non-option arguments. When GetOptions() encounters an argument that does not look like an option, it will immediately call this subroutine and passes it one parameter: the argument name. Well, actually it is an object that stringifies to the argument name.</source>
          <target state="translated">特殊选项'name' &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 可用于指定子例程来处理非选项参数。当GetOptions（）遇到一个看起来不像选项的参数时，它将立即调用此子例程并将一个参数传递给它：参数名称。好吧，实际上这是一个字符串化为参数名称的对象。</target>
        </trans-unit>
        <trans-unit id="9bb864d2ebf5f6403ee2f29fbe30d0ca7cb3bbfc" translate="yes" xml:space="preserve">
          <source>A special program that runs on the bare machine and hides the gory details of managing &lt;b&gt;processes&lt;/b&gt; and &lt;b&gt;devices&lt;/b&gt;. Usually used in a looser sense to indicate a particular culture of programming. The loose sense can be used at varying levels of specificity. At one extreme, you might say that all versions of Unix and Unix-lookalikes are the same operating system (upsetting many people, especially lawyers and other advocates). At the other extreme, you could say this particular version of this particular vendor&amp;rsquo;s operating system is different from any other version of this or any other vendor&amp;rsquo;s operating system. Perl is much more portable across operating systems than many other languages. See also &lt;b&gt;architecture&lt;/b&gt; and &lt;b&gt;platform&lt;/b&gt;.</source>
          <target state="translated">一个在裸机上运行的特殊程序，隐藏了管理&lt;b&gt;进程&lt;/b&gt;和&lt;b&gt;设备的&lt;/b&gt;细节。通常以较宽松的含义使用，表示特定的编程文化。松散感可以用于不同的特异性水平。在一个极端情况下，您可能会说所有版本的Unix和类似Unix的东西都是相同的操作系统（使很多人感到不适，尤其是律师和其他提倡者）。在另一个极端，您可以说此特定供应商的操作系统的特定版本不同于该特定供应商的操作系统的任何其他版本。与许多其他语言相比，Perl在操作系统之间的可移植性要强得多。另请参阅&lt;b&gt;体系结构&lt;/b&gt;和&lt;b&gt;平台&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b03867324ba36517f3a9d0e823f68ebcc5db216b" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; through it.</source>
          <target state="translated">一个特殊的编程小控件，它可以跟踪您要迭代的内容的位置。该 &lt;code&gt;foreach&lt;/code&gt; 在Perl环路含有迭代器; 所以做了哈希，让你 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 穿过。</target>
        </trans-unit>
        <trans-unit id="ee10f3c342b9f05f366b2abdcd5237c7367d7d5d" translate="yes" xml:space="preserve">
          <source>A special programming gizmo that keeps track of where you are in something that you&amp;rsquo;re trying to iterate over. The &lt;code&gt;foreach&lt;/code&gt; loop in Perl contains an iterator; so does a hash, allowing you to &lt;code&gt;each&lt;/code&gt; through it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb2ae230ab87141b90e09da012ca49eb173d1f62" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Perl 6 version to show that Perl will stay Perl.</source>
          <target state="translated">特别感谢Damian Conway,他不仅提出了重要的修改建议,还花时间统计了列出的功能数量,并做了一个Perl 6版本,以表明Perl将继续保持Perl。</target>
        </trans-unit>
        <trans-unit id="ba47d8229178e976b4e17fac8c50f7480fa0cd1c" translate="yes" xml:space="preserve">
          <source>A special thanks to Damian Conway, who didn't only suggest important changes, but also took the time to count the number of listed features and make a Raku version to show that Perl will stay Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd3a98639e4de23b8ab5b1ce7e392825e327157" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number.</source>
          <target state="translated">编译成当前行号的特殊标记。</target>
        </trans-unit>
        <trans-unit id="44f4cd0691d6b1f249950031c94d5eba6a8b7ab3" translate="yes" xml:space="preserve">
          <source>A special token that compiles to the current line number. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a5128be0078d880657071bac7267720f138c1c" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; outside of a subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8db7e23c364c11a426f9d30c1e28cd4da6326e7" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">一个特殊的令牌，它返回对当前子例程的引用，或者在子例程之外返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6eea162b97cdf5937cc80c12d97f68b73850c69" translate="yes" xml:space="preserve">
          <source>A special token that returns a reference to the current subroutine, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">一个特殊的令牌，它返回对当前子例程的引用，或者在子例程之外返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c26f3ebdbb02dd6bf3cbae9d5ef0c2e36ca2b14" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs.</source>
          <target state="translated">一个特殊的令牌,返回其所在文件的名称。</target>
        </trans-unit>
        <trans-unit id="4d534cc3d24e8095df0fd43eb483a4f531a852ee" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the file in which it occurs. It can be altered by the mechanism described at &lt;a href=&quot;perlsyn#Plain-Old-Comments-%28Not%21%29&quot;&gt;&quot;Plain Old Comments (Not!)&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48496bf275cb62c80b11546a66125c1e011d6e73" translate="yes" xml:space="preserve">
          <source>A special token that returns the name of the package in which it occurs.</source>
          <target state="translated">一个特殊的令牌,返回它出现的包的名称。</target>
        </trans-unit>
        <trans-unit id="07395fd97ce6a28d8015ab2eaad3eae19ab86b6e" translate="yes" xml:space="preserve">
          <source>A specialised variant of &lt;code&gt;croak()&lt;/code&gt; for emitting the usage message for xsubs</source>
          <target state="translated">&lt;code&gt;croak()&lt;/code&gt; 的一个特殊变体，用于发出xsubs的使用情况消息</target>
        </trans-unit>
        <trans-unit id="bc379211e591381ed14a5306c8c0734c9a94f69f" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;&quot;newHVhv&quot;&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt;. &lt;code&gt;ohv&lt;/code&gt; must be a pointer to a hash (which may have &lt;code&gt;%^H&lt;/code&gt; magic, but should be generally non-magical), or &lt;code&gt;NULL&lt;/code&gt; (interpreted as an empty hash). The content of &lt;code&gt;ohv&lt;/code&gt; is copied to a new hash, which has the &lt;code&gt;%^H&lt;/code&gt;-specific magic added to it. A pointer to the new hash is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a1130f5dbd32f8addbfbf8cc52dc9647058465" translate="yes" xml:space="preserve">
          <source>A specialised version of &lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt; for copying &lt;code&gt;%^H&lt;/code&gt; .</source>
          <target state="translated">的专用版本&lt;a href=&quot;#newHVhv&quot;&gt;newHVhv&lt;/a&gt;复印 &lt;code&gt;%^H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e58efa1c2b3f0ec95f611bcd359aa9037253ccf" translate="yes" xml:space="preserve">
          <source>A specification of how many spaces and digits and things to put somewhere so that whatever you&amp;rsquo;re printing comes out nice and pretty.</source>
          <target state="translated">一个关于在某处放置多少空格和数字以及事物的规范，以便您要打印的内容都变得漂亮。</target>
        </trans-unit>
        <trans-unit id="ece2ff0c58aaa5372289e45e695e7991badd8557" translate="yes" xml:space="preserve">
          <source>A spoonerism of &amp;ldquo;creeping featurism&amp;rdquo;, noting the biological urge to add just one more feature to a program.</source>
          <target state="translated">&amp;ldquo;爬行的特征主义&amp;rdquo;的尖锐主义，指出生物学的冲动，希望在程序中再增加一个功能。</target>
        </trans-unit>
        <trans-unit id="d575cbf3544d0e35868eb03520f7ba9dff410b04" translate="yes" xml:space="preserve">
          <source>A spot in your program where you&amp;rsquo;ve told the debugger to stop &lt;b&gt;execution&lt;/b&gt; so you can poke around and see whether anything is wrong yet.</source>
          <target state="translated">程序中的一个地方，您已告知调试器停止&lt;b&gt;执行，&lt;/b&gt;以便您可以四处查看并查看是否有任何问题。</target>
        </trans-unit>
        <trans-unit id="c8d0045954f55c0ef11ccdf21fdc1fefc0f23ff1" translate="yes" xml:space="preserve">
          <source>A square-bracketed list of characters used in a &lt;b&gt;regular expression&lt;/b&gt; to indicate that any character of the set may occur at a given point. Loosely, any predefined set of characters so used.</source>
          <target state="translated">&lt;b&gt;正则表达式中&lt;/b&gt;使用的方括号字符列表，用于指示集合中的任何字符都可以在给定点出现。松散地使用任何预定义的字符集。</target>
        </trans-unit>
        <trans-unit id="a4537030d9c45923983b601a7f64bbae6c4af141" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Mergesort is stable, quicksort is not. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="translated">稳定的排序是指对于比较相等的记录,会保留原来的输入排序。Mergesort是稳定的,quicksort不是。只有当比较相等的元素可以用其他方式区分时,稳定性才会重要。这意味着简单的数字和词法排序不能从稳定性中获益,因为相等的元素是无法区分的。然而,对于像这样的比较</target>
        </trans-unit>
        <trans-unit id="aaebd4ab6e5cf8a78012927baac4719189a65694" translate="yes" xml:space="preserve">
          <source>A stable sort means that for records that compare equal, the original input ordering is preserved. Stability will matter only if elements that compare equal can be distinguished in some other way. That means that simple numerical and lexical sorts do not profit from stability, since equal elements are indistinguishable. However, with a comparison such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc56d9c1394b0fa0321168c0b37750c90b88391" translate="yes" xml:space="preserve">
          <source>A standalone &lt;code&gt;=end&lt;/code&gt; command was found.</source>
          <target state="translated">找到一个独立的 &lt;code&gt;=end&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="90d81dc6a3e1d8ac5702b6911f4d25957cbc4616" translate="yes" xml:space="preserve">
          <source>A standard C library for doing &lt;b&gt;buffered&lt;/b&gt; input and output to the &lt;b&gt;operating system&lt;/b&gt;. (The &amp;ldquo;standard&amp;rdquo; of standard I/O is at most marginally related to the &amp;ldquo;standard&amp;rdquo; of standard input and output.) In general, Perl relies on whatever implementation of standard I/O a given operating system supplies, so the buffering characteristics of a Perl program on one machine may not exactly match those on another machine. Normally this only influences efficiency, not semantics. If your standard I/O package is doing block buffering and you want it to &lt;b&gt;flush&lt;/b&gt; the buffer more often, just set the &lt;code&gt;$|&lt;/code&gt; variable to a true value.</source>
          <target state="translated">一个标准的C库，用于对&lt;b&gt;操作系统&lt;/b&gt;进行&lt;b&gt;缓冲的&lt;/b&gt;输入和输出。 （标准I / O的&amp;ldquo;标准&amp;rdquo;最多与标准输入和输出的&amp;ldquo;标准&amp;rdquo;相关。）通常，Perl依赖于给定操作系统提供的标准I / O的任何实现，因此缓冲特性一台机器上的Perl程序的代码可能与另一台机器上的不完全匹配。通常，这仅影响效率，而不影响语义。如果您的标准I / O包正在执行块缓冲，并且您希望它更频繁地&lt;b&gt;刷新&lt;/b&gt;缓冲区，则只需设置 &lt;code&gt;$|&lt;/code&gt; 可变为真实值。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ffe116dcbea9e5d21815e3d329637659dd6eec04" translate="yes" xml:space="preserve">
          <source>A standard module whose practical hints and suggestions are received (and possibly ignored) at compile time. Pragmas are named in all lowercase.</source>
          <target state="translated">一个标准模块,在编译时,它的实用提示和建议被接收(可能被忽略)。Pragmas的名字都是小写的。</target>
        </trans-unit>
        <trans-unit id="3042ccfccce8001b84bc5b8d8019cf025a6017d9" translate="yes" xml:space="preserve">
          <source>A standard, bundled release of a system of software. The default usage implies source code is included. If that is not the case, it will be called a &amp;ldquo;binary-only&amp;rdquo; distribution.</source>
          <target state="translated">软件系统的标准捆绑发行版。默认用法表示包含源代码。如果不是这种情况，则将其称为&amp;ldquo;仅二进制&amp;rdquo;分发。</target>
        </trans-unit>
        <trans-unit id="c6647b8f10e57534f902ddf1aa4bccf61236fd6c" translate="yes" xml:space="preserve">
          <source>A statement sequence may contain declarations of lexically-scoped variables, but apart from declaring a variable name, the declaration acts like an ordinary statement, and is elaborated within the sequence of statements as if it were an ordinary statement. That means it actually has both compile-time and run-time effects.</source>
          <target state="translated">一个语句序列可能包含词法范围变量的声明,但除了声明一个变量名外,声明的作用就像一个普通的语句,在语句序列中就像普通的语句一样被阐述。也就是说,它实际上同时具有编译时和运行时的效果。</target>
        </trans-unit>
        <trans-unit id="fa46e467d8cdc232f6a66d28e35057665324ee9f" translate="yes" xml:space="preserve">
          <source>A string (char *).</source>
          <target state="translated">一个字符串(char *)。</target>
        </trans-unit>
        <trans-unit id="75e5df3441233543315a78a7205a2debb8ad739c" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="translated">字符串&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;将其表达式解析为标准Perl。因此，期望小数点是点。如果将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为逗号，则解析将被混淆，可能是无声的。</target>
        </trans-unit>
        <trans-unit id="e32ce4794e8e4c22eb37cafd0ff465a6583267c2" translate="yes" xml:space="preserve">
          <source>A string &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; parses its expression as standard Perl. It is therefore expecting the decimal point to be a dot. If &lt;code&gt;LC_NUMERIC&lt;/code&gt; is set to have this be a comma instead, the parsing will be confused, perhaps silently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9568afdc53a4a7f1711d767a18a8d9f968593e6" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt; tells Perl to consult the CLI's symbol tables, using</source>
          <target state="translated">以 &lt;code&gt;CLISYM_&lt;/code&gt; 开头的字符串告诉Perl使用以下命令查询CLI的符号表</target>
        </trans-unit>
        <trans-unit id="f111ed51d2b3bdc540d8eea8f3e95bb03014421d" translate="yes" xml:space="preserve">
          <source>A string beginning with &lt;code&gt;CLISYM_&lt;/code&gt;tells Perl to consult the CLI's symbol tables, using</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73539349cf3164d1f6eed3ab55aa660f24e3b757" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt;&quot;'&amp;gt; will be encoded numerically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb88c9d62f1cca49157633840f22b59a116a8ab" translate="yes" xml:space="preserve">
          <source>A string containing all characters that should be encoded as HTML entities, specified using the regular expression character class syntax (what you find within brackets in regular expressions). This value will be passed as the second argument to the &lt;code&gt;encode_entities&lt;/code&gt; function of &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt;. If &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML::Entities&lt;/a&gt; is not installed, then any characters other than &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &quot;'&amp;gt; will be encoded numerically.</source>
          <target state="translated">一个字符串，其中包含所有应编码为HTML实体的字符，使用正则表达式字符类语法（在正则表达式的方括号中找到的内容）指定。该值将作为第二个参数传递给&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;的 &lt;code&gt;encode_entities&lt;/code&gt; 函数。如果未安装&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::Entities&quot;&gt;HTML :: Entities&lt;/a&gt;，则 &lt;code&gt;&amp;amp;&amp;lt;&lt;/code&gt; &amp;ldquo;'&amp;gt; 以外的任何其他字符都将以数字方式编码。</target>
        </trans-unit>
        <trans-unit id="2c6988b512688bb605e69e65500198db5054baa8" translate="yes" xml:space="preserve">
          <source>A string containing the text of a message to print</source>
          <target state="translated">包含要打印的信息文本的字符串。</target>
        </trans-unit>
        <trans-unit id="bf5bf16fd07f45d581debfd5241308f05f5b876d" translate="yes" xml:space="preserve">
          <source>A string corresponding to the desired output file (or &quot;&amp;gt;&amp;amp;STDOUT&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot;), or a filehandle to write on. The default is to use standard output.</source>
          <target state="translated">与所需的输出文件（或&amp;ldquo;&amp;gt;＆STDOUT&amp;rdquo;或&amp;ldquo;&amp;gt;＆STDERR&amp;rdquo;）相对应的字符串，或要写入的文件句柄。默认为使用标准输出。</target>
        </trans-unit>
        <trans-unit id="e81c48705eb13d4df1f22c2acd8523f46384c993" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt; ). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="translated">先用反引号（重音符号）括起来的字符串进行双引号内插。然后将其解释为外部命令，并且该命令的输出是反引号字符串的值，就像在shell中一样。在标量上下文中，返回包含所有输出的单个字符串。在列表上下文中，返回值列表，每行输出一个。 （可以将 &lt;code&gt;$/&lt;/code&gt; 设置为使用不同的行终止符。）每次评估伪文字时，都会执行该命令。命令的状态值以 &lt;code&gt;$?&lt;/code&gt; 返回。（有关 &lt;code&gt;$?&lt;/code&gt; 的解释，请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）。与&lt;b&gt;csh&lt;/b&gt;不同&lt;b&gt;&lt;/b&gt;，则不会对返回数据进行转换-换行符仍然是换行符。与在任何shell中不同，单引号不会从解释中隐藏命令中的变量名称。要将字面的美元符号传递到外壳，您需要使用反斜杠将其隐藏。反引号的一般形式是 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 。（由于反引号也总是经历shell扩展，因此出于安全方面的考虑，请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="6a59c28b10f1e469c8f302761a4c4403491075e7" translate="yes" xml:space="preserve">
          <source>A string enclosed by backticks (grave accents) first undergoes double-quote interpolation. It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell. In scalar context, a single string consisting of all output is returned. In list context, a list of values is returned, one per line of output. (You can set &lt;code&gt;$/&lt;/code&gt; to use a different line terminator.) The command is executed each time the pseudo-literal is evaluated. The status value of the command is returned in &lt;code&gt;$?&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for the interpretation of &lt;code&gt;$?&lt;/code&gt;). Unlike in &lt;b&gt;csh&lt;/b&gt;, no translation is done on the return data--newlines remain newlines. Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation. To pass a literal dollar-sign through to the shell you need to hide it with a backslash. The generalized form of backticks is &lt;code&gt;qx//&lt;/code&gt;, or you can call the &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt; function. (Because backticks always undergo shell expansion as well, see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for security concerns.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8188c86cb7ff03c08e73a3bf26c2466b54d74c0a" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (but never shorter) than one encoded in UTF-8. Perl extends UTF-8 so that it can encode code points above the Unicode maximum of U+10FFFF. It extends UTF-EBCDIC as well, but due to the inherent limitations in UTF-EBCDIC, the maximum code point expressible is U+7FFF_FFFF, even if the word size is more than 32 bits.</source>
          <target state="translated">用UTF-EBCDIC编码的字符串可能比用UTF-8编码的字符串长(但绝不会短)。Perl 对 UTF-8 进行了扩展,因此它可以对超过 Unicode 最大值 U+10FFFF 的码点进行编码。它也扩展了UTF-EBCDIC,但由于UTF-EBCDIC的固有限制,即使字的大小超过32位,可表达的最大码点也是U+7FFF_FFFFFFFF。</target>
        </trans-unit>
        <trans-unit id="914a74b444d9ba99a9fe1b62c1ecf5a7f252527d" translate="yes" xml:space="preserve">
          <source>A string encoded in UTF-EBCDIC may be longer (very rarely shorter) than one encoded in UTF-8. Perl extends both UTF-8 and UTF-EBCDIC so that they can encode code points above the Unicode maximum of U+10FFFF. Both extensions are constructed to allow encoding of any code point that fits in a 64-bit word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4917965ca44eb0c4faae94a841c4f89027d6938" translate="yes" xml:space="preserve">
          <source>A string of alternative option starter characters may be passed as the first argument (or the first argument after a leading hash reference argument).</source>
          <target state="translated">可以传递一串备选选项起始字符作为第一个参数(或前导哈希引用参数后的第一个参数)。</target>
        </trans-unit>
        <trans-unit id="88c258b6d0e7c9ac246c86ffd1bb6de9b44ef38f" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46c47b9481cf147721b670360f462acc06f6b68e" translate="yes" xml:space="preserve">
          <source>A string of portable printable characters. This is the base64 encoded representation of the digest with any trailing padding removed. The string will be about 30% longer than the binary version. &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; tells you more about this encoding.</source>
          <target state="translated">一串可移植的可打印字符。这是摘要的base64编码表示形式，其中删除了所有尾随填充。该字符串将比二进制版本长30％左右。&lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt;告诉您有关此编码的更多信息。</target>
        </trans-unit>
        <trans-unit id="1b085cd0478f87c6aa68ec36d4064dfac1577470" translate="yes" xml:space="preserve">
          <source>A string of zero or more characters from &lt;code&gt;&quot;achorst&quot;&lt;/code&gt; [see &lt;code&gt;attrLetsToBits&lt;/code&gt; for more information] which are converted to &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; bits to be set in the &lt;code&gt;$uFlags&lt;/code&gt; argument passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
