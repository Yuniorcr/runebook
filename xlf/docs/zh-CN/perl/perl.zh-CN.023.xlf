<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="df751a148221e657237a264ca9bfcbc240163953" translate="yes" xml:space="preserve">
          <source>Defined if we're dealing with the &lt;code&gt;GNU&lt;/code&gt; C Library.</source>
          <target state="translated">定义是否要处理 &lt;code&gt;GNU&lt;/code&gt; C库。</target>
        </trans-unit>
        <trans-unit id="487af9998b90c5fd5fb9d7386051e0f2dc3d4e56" translate="yes" xml:space="preserve">
          <source>Defined in RFC 2277, this is for tagging text (which must include English text, and might/should include text in other appropriate languages) that is emitted in a context where language-negotiation wasn't possible -- in SMTP mail failure messages, for example.</source>
          <target state="translated">这在RFC 2277中定义,用于标记在不可能进行语言协商的情况下发出的文本(必须包括英文文本,也可能/应该包括其他适当语言的文本),例如在SMTP邮件失败消息中。</target>
        </trans-unit>
        <trans-unit id="d0094836cd417237e53e36d38b6bb157c23bb8dd" translate="yes" xml:space="preserve">
          <source>Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">定义EXTRALIBS，LDLOADLIBS，BSLOADLIBS，LD_RUN_PATH。有关详细信息，请参见&lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54d5e1ace8616b0824e4e69deda9fb5d35c9ab98" translate="yes" xml:space="preserve">
          <source>Defines a check in target for RCS.</source>
          <target state="translated">定义RCS的签入目标。</target>
        </trans-unit>
        <trans-unit id="fe64ed45d43654228ab2f263b3250cb6d237ffdb" translate="yes" xml:space="preserve">
          <source>Defines a couple of constants in the Makefile that are imported from %Config.</source>
          <target state="translated">在 Makefile 中定义了几个从 %Config 导入的常量。</target>
        </trans-unit>
        <trans-unit id="45640d4e061562862c8b269f9919db4c555b95a5" translate="yes" xml:space="preserve">
          <source>Defines a lot of macros for distribution support.</source>
          <target state="translated">定义了很多宏,用于支持分发。</target>
        </trans-unit>
        <trans-unit id="8f2c384608aa9da85fcd183aa27b7be131f7d130" translate="yes" xml:space="preserve">
          <source>Defines a simple perl call that runs autosplit. May be deprecated by pm_to_blib soon.</source>
          <target state="translated">定义了一个简单的perl调用来运行自动分割。可能很快就会被pm_to_blib废弃。</target>
        </trans-unit>
        <trans-unit id="7f1b350e0e67e0413f358f35911f68c6865314e4" translate="yes" xml:space="preserve">
          <source>Defines a target that produces the distribution in the scratch directory, and runs 'perl Makefile.PL; make ;make test' in that subdirectory.</source>
          <target state="translated">定义一个目标,在scratch目录下生成发行版,并在该子目录下运行'perl Makefile.PL;make ;make test'。</target>
        </trans-unit>
        <trans-unit id="302537770d292c74e66370b599a3b03ffe01a51a" translate="yes" xml:space="preserve">
          <source>Defines at least these macros.</source>
          <target state="translated">至少定义了这些宏。</target>
        </trans-unit>
        <trans-unit id="6b99cfd58fae6b3dae8c7123af0773072b8fe5e5" translate="yes" xml:space="preserve">
          <source>Defines how to produce the *.a (or equivalent) files.</source>
          <target state="translated">定义如何生成*.a(或等效)文件。</target>
        </trans-unit>
        <trans-unit id="dc26efd3c32adf7d1de84003c339188a38e358f8" translate="yes" xml:space="preserve">
          <source>Defines how to produce the *.so (or equivalent) files.</source>
          <target state="translated">定义如何生成*.so(或同等的)文件。</target>
        </trans-unit>
        <trans-unit id="8695ac2968551bde31876b3d67b9ced4a12a9549" translate="yes" xml:space="preserve">
          <source>Defines how to rewrite the Makefile.</source>
          <target state="translated">定义如何重写Makefile。</target>
        </trans-unit>
        <trans-unit id="22c6065d98e3206f28470f013ce533e0e15ea743" translate="yes" xml:space="preserve">
          <source>Defines suffix rules to go from XS to object files directly. This is only intended for broken make implementations.</source>
          <target state="translated">定义后缀规则,直接从XS到对象文件。这只是为了破除make的实现。</target>
        </trans-unit>
        <trans-unit id="b3b41acc6b49a6388409ba10f2258e522cda4bba" translate="yes" xml:space="preserve">
          <source>Defines target that copies all files in the hash PM to their destination and autosplits them. See &lt;a href=&quot;install#DESCRIPTION&quot;&gt;DESCRIPTION in ExtUtils::Install&lt;/a&gt;</source>
          <target state="translated">定义将哈希PM中的所有文件复制到目标并自动拆分的目标。参见&lt;a href=&quot;install#DESCRIPTION&quot;&gt;ExtUtils中的DESCRIPTION ::安装&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4adac1897b3589686f6012b335a376dba9440a99" translate="yes" xml:space="preserve">
          <source>Defines target that creates a PPD (Perl Package Description) file for a binary distribution.</source>
          <target state="translated">定义了为二进制发行版创建PPD(Perl Package Description)文件的目标。</target>
        </trans-unit>
        <trans-unit id="81215a51ffc47aa71de599db8f3ad3d93520e3be" translate="yes" xml:space="preserve">
          <source>Defines targets and routines to translate the pods into manpages and put them into the INST_* directories.</source>
          <target state="translated">定义了目标和例程,用于将 pods 翻译成 manpages,并将其放入 INST_*目录中。</target>
        </trans-unit>
        <trans-unit id="a27612024b8b930142c07dfc2a483eb40f35b6c8" translate="yes" xml:space="preserve">
          <source>Defines targets for bootstrap files.</source>
          <target state="translated">定义bootstrap文件的目标。</target>
        </trans-unit>
        <trans-unit id="d67b6bc334f7365a22e55924832c3099c1799069" translate="yes" xml:space="preserve">
          <source>Defines targets to make and to install EXE_FILES.</source>
          <target state="translated">定义要制作和安装EXE_FILES的目标。</target>
        </trans-unit>
        <trans-unit id="a39e083fd927c6ae8fb97333fcad3f2b452cafcb" translate="yes" xml:space="preserve">
          <source>Defines targets to process subdirectories.</source>
          <target state="translated">定义要处理子目录的目标。</target>
        </trans-unit>
        <trans-unit id="4b99ef7da9945c228db1380016cfa3962ddce9f3" translate="yes" xml:space="preserve">
          <source>Defines targets to run *.PL files.</source>
          <target state="translated">定义运行*.PL文件的目标。</target>
        </trans-unit>
        <trans-unit id="d9ad31fa070099a4fc5216a15ac2552cb8720903" translate="yes" xml:space="preserve">
          <source>Defines the DESTDIR and DEST* variables paralleling the INSTALL*.</source>
          <target state="translated">定义与INSTALL*平行的DESTDIR和DEST*变量。</target>
        </trans-unit>
        <trans-unit id="ba94224c3086851c054895958309c5f4d0716300" translate="yes" xml:space="preserve">
          <source>Defines the PERLDLL symbol if we are configured for static building since all code destined for the perl5xx.dll must be compiled with the PERLDLL symbol defined.</source>
          <target state="translated">如果我们被配置为静态构建,则定义PERLDLL符号,因为所有指向perl5xx.dll的代码都必须使用定义的PERLDLL符号进行编译。</target>
        </trans-unit>
        <trans-unit id="e8fef87bd74d9d4f90d787908362dc30b0d77629" translate="yes" xml:space="preserve">
          <source>Defines the clean target.</source>
          <target state="translated">定义清洁目标。</target>
        </trans-unit>
        <trans-unit id="44c298f8aa784474d919a3c44fea66470e8f2e7f" translate="yes" xml:space="preserve">
          <source>Defines the compression level used by zlib. The value should either be a number between 0 and 9 (0 means no compression and 9 is maximum compression), or one of the symbolic constants defined below.</source>
          <target state="translated">定义zlib使用的压缩级别。该值应该是一个介于0和9之间的数字(0表示不压缩,9表示最大压缩),或者是下面定义的一个符号常数。</target>
        </trans-unit>
        <trans-unit id="f42bdaa318d7d2b3aed95081e60d514ae57c0a40" translate="yes" xml:space="preserve">
          <source>Defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</source>
          <target state="translated">定义压缩级别。有效值为0到9， &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; ， &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; ， &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; 和 &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40143f5226bb902295ca1dda0de7dc4d4309dfae" translate="yes" xml:space="preserve">
          <source>Defines the compression method. The only valid value at present (and the default) is &lt;code&gt;Z_DEFLATED&lt;/code&gt; .</source>
          <target state="translated">定义压缩方法。当前唯一有效的值（和默认值）是 &lt;code&gt;Z_DEFLATED&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="deaa8bcc66f1718ba796d4871baf848aff3c710f" translate="yes" xml:space="preserve">
          <source>Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.</source>
          <target state="translated">定义压缩方式。目前唯一有效的值(默认值)是Z_DEFLATED。</target>
        </trans-unit>
        <trans-unit id="e5f8cd0a2961419147b82d106eae039801beefea" translate="yes" xml:space="preserve">
          <source>Defines the dependency from all *.h files that come with the perl distribution.</source>
          <target state="translated">定义了所有perl发行版中的*.h文件的依赖关系。</target>
        </trans-unit>
        <trans-unit id="740df2004d6262227a64962e7679f8e429418ecc" translate="yes" xml:space="preserve">
          <source>Defines the dynamic target.</source>
          <target state="translated">定义动态目标。</target>
        </trans-unit>
        <trans-unit id="5f6aea77294d02ec6fd46c657ab20cc6e5da28ce" translate="yes" xml:space="preserve">
          <source>Defines the install target.</source>
          <target state="translated">定义安装目标。</target>
        </trans-unit>
        <trans-unit id="476771d611b7ad6cde3ad6c65766d9fa62c6985b" translate="yes" xml:space="preserve">
          <source>Defines the linkext target which in turn defines the LINKTYPE.</source>
          <target state="translated">定义linkext目标,进而定义LINKTYPE。</target>
        </trans-unit>
        <trans-unit id="28bca9ceee2fa0c0c2202b5cce5e6315839954c5" translate="yes" xml:space="preserve">
          <source>Defines the realclean target.</source>
          <target state="translated">定义realclean目标。</target>
        </trans-unit>
        <trans-unit id="187b77c07dcdb58c6c97c87717ccce9d654bf4c9" translate="yes" xml:space="preserve">
          <source>Defines the scratch directory target that will hold the distribution before tar-ing (or shar-ing).</source>
          <target state="translated">定义在tar-ing (或shar-ing)之前存放发行版的scratch目录目标。</target>
        </trans-unit>
        <trans-unit id="7111ead71f2d3431a6510a936ce620bc4b1e5ad4" translate="yes" xml:space="preserve">
          <source>Defines the static target.</source>
          <target state="translated">定义静态目标。</target>
        </trans-unit>
        <trans-unit id="c63068c7e0232b8f723215365b2896a0e197617e" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. The valid values are &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; , &lt;code&gt;Z_RLE&lt;/code&gt; , &lt;code&gt;Z_FIXED&lt;/code&gt; and &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; .</source>
          <target state="translated">定义用于调整压缩的策略。有效值为 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; ， &lt;code&gt;Z_FILTERED&lt;/code&gt; ， &lt;code&gt;Z_RLE&lt;/code&gt; ， &lt;code&gt;Z_FIXED&lt;/code&gt; 和 &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f3b8848d647f32e943342a5efdd76d9b487a63a" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. The valid values are &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; , &lt;code&gt;Z_FILTERED&lt;/code&gt; and &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; .</source>
          <target state="translated">定义用于调整压缩的策略。有效值为 &lt;code&gt;Z_DEFAULT_STRATEGY&lt;/code&gt; ， &lt;code&gt;Z_FILTERED&lt;/code&gt; 和 &lt;code&gt;Z_HUFFMAN_ONLY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eee1848a08d0972c7c4402500e5de73ab130c5a" translate="yes" xml:space="preserve">
          <source>Defines the strategy used to tune the compression. Use one of the symbolic constants defined below.</source>
          <target state="translated">定义用于调整压缩的策略。使用下面定义的符号常数之一。</target>
        </trans-unit>
        <trans-unit id="0140c569a167a40b758a74ad75bbfa4a322932c6" translate="yes" xml:space="preserve">
          <source>Defines the string that is passed to recursive make calls in subdirectories.</source>
          <target state="translated">定义传递给子目录中递归调用的字符串。</target>
        </trans-unit>
        <trans-unit id="3da735f442360be74e54c58a85701764b3e96022" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile XS files to C++.</source>
          <target state="translated">定义了编译XS文件到C++的后缀规则。</target>
        </trans-unit>
        <trans-unit id="74b9893fa91b825a1d680e0f69f616b612a76cb5" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile XS files to C.</source>
          <target state="translated">定义了将XS文件编译成C语言的后缀规则。</target>
        </trans-unit>
        <trans-unit id="e0d8ee251994cc513f249a8caeb41a2880a20ae6" translate="yes" xml:space="preserve">
          <source>Defines the suffix rules to compile different flavors of C files to object files.</source>
          <target state="translated">定义了后缀规则,用于将不同风味的C文件编译成对象文件。</target>
        </trans-unit>
        <trans-unit id="32546d4aee39d7ecd97ee598cccfec080ea2b2fa" translate="yes" xml:space="preserve">
          <source>Defines the targets all, subdirs, config, and O_FILES</source>
          <target state="translated">定义目标all、subdirs、config和O_FILES。</target>
        </trans-unit>
        <trans-unit id="8d94db57a25050ea2e12e70aa07a67bf9e408e8b" translate="yes" xml:space="preserve">
          <source>Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.</source>
          <target state="translated">定义目标 distclean、distcheck、 skipcheck、manifest、veryclean。</target>
        </trans-unit>
        <trans-unit id="195a11e1aaa7fa1de51a9767e72b1109922bd69b" translate="yes" xml:space="preserve">
          <source>Defines the test targets.</source>
          <target state="translated">定义测试目标。</target>
        </trans-unit>
        <trans-unit id="e470b7139fcd28a3e03c5dc98122c30f121e0ce7" translate="yes" xml:space="preserve">
          <source>Defining Aliases</source>
          <target state="translated">定义别名</target>
        </trans-unit>
        <trans-unit id="a6a4f129ca4af3f95655180a4ab4518f538d8368" translate="yes" xml:space="preserve">
          <source>Defining Encodings</source>
          <target state="translated">定义编码</target>
        </trans-unit>
        <trans-unit id="8953e978a34af3aa771b28b8a0aeb5a5a9299394" translate="yes" xml:space="preserve">
          <source>Defining multiple constants at once</source>
          <target state="translated">同时定义多个常量</target>
        </trans-unit>
        <trans-unit id="0b4d4a2cad4c2c9d7a21a4f7eee774dd37c837d6" translate="yes" xml:space="preserve">
          <source>Defining named patterns</source>
          <target state="translated">定义命名模式</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="dc49f81973bcb0957f67dbcb79a0c07904072495" translate="yes" xml:space="preserve">
          <source>Deflate Interface</source>
          <target state="translated">放气接口</target>
        </trans-unit>
        <trans-unit id="261df28b51f1e3a727f3a451d8b97dc502d494f7" translate="yes" xml:space="preserve">
          <source>Deflates the contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference. When finished, &lt;code&gt;$buffer&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it returns the deflated output, &lt;code&gt;$out&lt;/code&gt; , and a status value, &lt;code&gt;$status&lt;/code&gt; , of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">压缩 &lt;code&gt;$buffer&lt;/code&gt; 的内容。缓冲区可以是标量或标量引用。完成后， &lt;code&gt;$buffer&lt;/code&gt; 将被完全处理（假设没有错误）。如果通货紧缩成功则返回瘪输出， &lt;code&gt;$out&lt;/code&gt; ，和状态值， &lt;code&gt;$status&lt;/code&gt; 的 &lt;code&gt;Z_OK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ca554d5d7745bfb195b4e7b44d607bd478a74b" translate="yes" xml:space="preserve">
          <source>Deflates the contents of &lt;code&gt;$input&lt;/code&gt; and writes the compressed data to &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">压缩 &lt;code&gt;$input&lt;/code&gt; 的内容，并将压缩后的数据写入 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3ea81ef7609f7aa5b727599becc6a143ff111a6" translate="yes" xml:space="preserve">
          <source>Delete a breakpoint from the specified</source>
          <target state="translated">删除指定的断点。</target>
        </trans-unit>
        <trans-unit id="5a0073b863c5340c8970662e0be69970f5dfeba8" translate="yes" xml:space="preserve">
          <source>Delete a key and its associated value from the cop hints hash</source>
          <target state="translated">从 cop hints hash 中删除一个键和相关的值。</target>
        </trans-unit>
        <trans-unit id="b15c91a025daa3148a7fab7d1733f7a172457b7b" translate="yes" xml:space="preserve">
          <source>Delete all installed actions.</source>
          <target state="translated">删除所有已安装的动作。</target>
        </trans-unit>
        <trans-unit id="bb17fd76f6f5ca7598134cd78f73beaa67a2e6d2" translate="yes" xml:space="preserve">
          <source>Delete all installed breakpoints.</source>
          <target state="translated">删除所有已安装的断点。</target>
        </trans-unit>
        <trans-unit id="beaf4b4da8da8ff385c29b6d645eaa115a38d395" translate="yes" xml:space="preserve">
          <source>Delete all post-prompt Perl command actions.</source>
          <target state="translated">删除所有Perl命令后的动作。</target>
        </trans-unit>
        <trans-unit id="e03ec6135ed6958ecae2c1ff175c05d512e28238" translate="yes" xml:space="preserve">
          <source>Delete all pre-prompt Perl command actions.</source>
          <target state="translated">删除所有Perl命令前的动作。</target>
        </trans-unit>
        <trans-unit id="73a7816e302077539cac697491b47392c1d85bee" translate="yes" xml:space="preserve">
          <source>Delete all pre-prompt debugger commands.</source>
          <target state="translated">删除所有预提示调试器命令。</target>
        </trans-unit>
        <trans-unit id="2dad01021d565585d1f2142d895d1f8890c02ab1" translate="yes" xml:space="preserve">
          <source>Delete all watch-expressions.</source>
          <target state="translated">删除所有观察表达式。</target>
        </trans-unit>
        <trans-unit id="b6f7cb935ade65e12cb5c25c937b996479fb8adb" translate="yes" xml:space="preserve">
          <source>Delete an action from the specified line.</source>
          <target state="translated">删除指定行的操作。</target>
        </trans-unit>
        <trans-unit id="1226b496f4d499ec434c444cfe660a3f53b36ae9" translate="yes" xml:space="preserve">
          <source>Delete and return the spool.</source>
          <target state="translated">删除并退回线轴。</target>
        </trans-unit>
        <trans-unit id="ec90a00fac0b965cebb8d69254af765943de97b7" translate="yes" xml:space="preserve">
          <source>Delete it. :-) Seriously, there are a number of (mostly unsatisfactory) solutions with varying levels of &quot;security&quot;.</source>
          <target state="translated">删掉它。 :-)说真的,有很多(大多不满意)解决方案,其 &quot;安全性 &quot;程度不一。</target>
        </trans-unit>
        <trans-unit id="b819cf6faf3c2dff6669793abe1aba00c76a28d9" translate="yes" xml:space="preserve">
          <source>Delete the element at index</source>
          <target state="translated">删除索引处的元素</target>
        </trans-unit>
        <trans-unit id="c0d51f2b9680b0830421d95140e113f970d690d9" translate="yes" xml:space="preserve">
          <source>Delete the key</source>
          <target state="translated">删除钥匙</target>
        </trans-unit>
        <trans-unit id="91cc99f3a5b10598f0cfe04276ac8b00d48c8cb4" translate="yes" xml:space="preserve">
          <source>Delete watch-expression</source>
          <target state="translated">删除观察表情</target>
        </trans-unit>
        <trans-unit id="9ca1c676523afd3f5ee253a9b6c4f5e0ad74e44b" translate="yes" xml:space="preserve">
          <source>Deletes a key/value pair in the hash. The value SV is removed from the hash, made mortal, and returned to the caller. The &lt;code&gt;flags&lt;/code&gt; value will normally be zero; if set to G_DISCARD then NULL will be returned. NULL will also be returned if the key is not found. &lt;code&gt;hash&lt;/code&gt; can be a valid precomputed hash value, or 0 to ask for it to be computed.</source>
          <target state="translated">删除哈希中的键/值对。值SV从散列中删除，变为凡人，然后返回给调用方。该 &lt;code&gt;flags&lt;/code&gt; 的值通常是零; 如果设置为G_DISCARD，则将返回NULL。如果找不到该密钥，还将返回NULL。 &lt;code&gt;hash&lt;/code&gt; 可以是有效的预先计算的hash值，也可以是0以要求对其进行计算。</target>
        </trans-unit>
        <trans-unit id="f3c1663e85e551a1c50322e1c209520d893a7af7" translate="yes" xml:space="preserve">
          <source>Deletes a key/value pair in the hash. The value's SV is removed from the hash, made mortal, and returned to the caller. The absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;flags&lt;/code&gt; value will normally be zero; if set to G_DISCARD then NULL will be returned. NULL will also be returned if the key is not found.</source>
          <target state="translated">删除哈希中的键/值对。从哈希中删除该值的SV，使其变为凡人，然后返回给调用方。 &lt;code&gt;klen&lt;/code&gt; 的绝对值是密钥的长度。如果 &lt;code&gt;klen&lt;/code&gt; 为负，则假定密钥为UTF-8编码的Unicode。该 &lt;code&gt;flags&lt;/code&gt; 的值通常是零; 如果设置为G_DISCARD，则将返回NULL。如果找不到该密钥，还将返回NULL。</target>
        </trans-unit>
        <trans-unit id="b5dd5212aa7a8bc97116e79a014cced26a493225" translate="yes" xml:space="preserve">
          <source>Deletes a list of files. On success, it returns the number of files it successfully deleted. On failure, it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno):</source>
          <target state="translated">删除文件列表。成功后，它将返回成功删除的文件数。失败时，它返回false并设置 &lt;code&gt;$!&lt;/code&gt; （errno）：</target>
        </trans-unit>
        <trans-unit id="4e992fa1a5f580cdba4aa3e9584f6ceab958d933" translate="yes" xml:space="preserve">
          <source>Deletes the directory specified by FILENAME if that directory is empty. If it succeeds it returns true; otherwise it returns false and sets &lt;code&gt;$!&lt;/code&gt; (errno). If FILENAME is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">如果该目录为空，则删除FILENAME指定的目录。如果成功，则返回true；否则，返回true。否则返回false并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。如果省略FILENAME，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ab8b05f803f178aa62996ab1540a40bcd2f3aad" translate="yes" xml:space="preserve">
          <source>Deletes the element indexed by &lt;code&gt;key&lt;/code&gt; from the array, makes the element mortal, and returns it. If &lt;code&gt;flags&lt;/code&gt; equals &lt;code&gt;G_DISCARD&lt;/code&gt; , the element is freed and null is returned. Perl equivalent: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $elem = &lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;($myarray[$idx]);&lt;/code&gt; for the non-&lt;code&gt;G_DISCARD&lt;/code&gt; version and a void-context &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete($myarray[$idx]);&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;G_DISCARD&lt;/code&gt; version.</source>
          <target state="translated">从数组中删除由 &lt;code&gt;key&lt;/code&gt; 索引的元素，使该元素成为凡人，然后将其返回。如果 &lt;code&gt;flags&lt;/code&gt; 等于 &lt;code&gt;G_DISCARD&lt;/code&gt; ，则释放元素，并返回null。等价于Perl： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $elem = &lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;($myarray[$idx]);&lt;/code&gt; 对于非 &lt;code&gt;G_DISCARD&lt;/code&gt; 版本和无效上下文 &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete($myarray[$idx]);&lt;/a&gt;&lt;/code&gt; 适用于 &lt;code&gt;G_DISCARD&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="eb406e5c9566f12490e972a4db2c13a7645fccc7" translate="yes" xml:space="preserve">
          <source>Deleting directories from @INC</source>
          <target state="translated">从@INC中删除目录</target>
        </trans-unit>
        <trans-unit id="59739df4503a81fc7a23e026605cac8564b8e7df" translate="yes" xml:space="preserve">
          <source>Deleting from &lt;code&gt;%ENV&lt;/code&gt; modifies the environment. Deleting from a hash tied to a DBM file deletes the entry from the DBM file. Deleting from a &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; hash or array may not necessarily return anything; it depends on the implementation of the &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; package's DELETE method, which may do whatever it pleases.</source>
          <target state="translated">从 &lt;code&gt;%ENV&lt;/code&gt; 删除会修改环境。从绑定到DBM文件的哈希中删除会从DBM文件中删除该条目。从 &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 哈希或数组中删除可能不一定会返回任何内容。它取决于 &lt;code&gt;&lt;a href=&quot;functions/tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 程序包的DELETE方法的实现，该方法可以随心所欲地做。</target>
        </trans-unit>
        <trans-unit id="b2e4bc535959687d920ab6af5070c36f9ba7c865" translate="yes" xml:space="preserve">
          <source>Deleting from &lt;code&gt;%ENV&lt;/code&gt; modifies the environment. Deleting from a hash tied to a DBM file deletes the entry from the DBM file. Deleting from a &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; hash or array may not necessarily return anything; it depends on the implementation of the &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; package's DELETE method, which may do whatever it pleases.</source>
          <target state="translated">从 &lt;code&gt;%ENV&lt;/code&gt; 删除会修改环境。从绑定到DBM文件的哈希中删除会从DBM文件中删除该条目。从 &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 哈希或数组中删除可能不一定会返回任何内容。它取决于 &lt;code&gt;&lt;a href=&quot;tied&quot;&gt;tied&lt;/a&gt;&lt;/code&gt; 程序包的DELETE方法的实现，该方法可以随心所欲地做。</target>
        </trans-unit>
        <trans-unit id="a29354be8f01aa714635d9e114de856834c56b93" translate="yes" xml:space="preserve">
          <source>Delivers gcc toolchain targeting 32-bit Windows platform.</source>
          <target state="translated">提供针对32位Windows平台的gcc工具链。</target>
        </trans-unit>
        <trans-unit id="0b514393b132ed57d195ef9cf7c8664bedd5ba2f" translate="yes" xml:space="preserve">
          <source>Delivers gcc toolchain targeting both 64-bit Windows and 32-bit Windows platforms (despite the project name &quot;mingw-w64&quot; they are not only 64-bit oriented). They deliver the native gcc compilers and cross-compilers that are also supported by perl's makefile.</source>
          <target state="translated">提供针对64位Windows和32位Windows平台的gcc工具链(尽管项目名称为 &quot;mingw-w64&quot;,但他们不仅仅是面向64位的)。他们提供了本地的gcc编译器和交叉编译器,这些编译器也被perl的makefile所支持。</target>
        </trans-unit>
        <trans-unit id="84cba83c5edbd4207cb47e793a734e0fe0e36673" translate="yes" xml:space="preserve">
          <source>Demands a version of Perl specified by VERSION, or demands some semantics specified by EXPR or by &lt;code&gt;$_&lt;/code&gt; if EXPR is not supplied.</source>
          <target state="translated">需要由VERSION指定的Perl版本，或者需要由EXPR或 &lt;code&gt;$_&lt;/code&gt; 指定的某些语义（如果未提供EXPR）。</target>
        </trans-unit>
        <trans-unit id="562e8903063ed8770f6527d563bca3ab2868b0d9" translate="yes" xml:space="preserve">
          <source>Denial of Service</source>
          <target state="translated">拒绝服务</target>
        </trans-unit>
        <trans-unit id="53577bb5df0ee9b6376e87f4896b6957a25d7a43" translate="yes" xml:space="preserve">
          <source>Deny</source>
          <target state="translated">Deny</target>
        </trans-unit>
        <trans-unit id="2e10904ffd9eaf7871845f0b81c542592ff1e8bd" translate="yes" xml:space="preserve">
          <source>Deny the listed operators from being used when compiling code in the compartment (other operators may still be permitted).</source>
          <target state="translated">拒绝在车厢内编译代码时使用列出的操作符(其他操作符仍可使用)。</target>
        </trans-unit>
        <trans-unit id="f3c0cd1438a845e8a503457cb11b112c6a17abfb" translate="yes" xml:space="preserve">
          <source>Dependency on</source>
          <target state="translated">依赖性</target>
        </trans-unit>
        <trans-unit id="77dc35303fc487108331e0e6d31fd83790816ff8" translate="yes" xml:space="preserve">
          <source>Dependent libraries can be linked in one of three ways:</source>
          <target state="translated">依赖的库可以通过三种方式之一进行链接。</target>
        </trans-unit>
        <trans-unit id="b591a22d82312f2906d4cd0cd73a4a0cc311c02d" translate="yes" xml:space="preserve">
          <source>Depending on how you built/installed perl you may have (otherwise identical) Perl documentation in the following formats:</source>
          <target state="translated">根据你是如何构建/安装perl的,你可能有以下格式的Perl文档(其他方面相同)。</target>
        </trans-unit>
        <trans-unit id="e46450a9c23e87326a0c62cc3a40e3b23e08ee53" translate="yes" xml:space="preserve">
          <source>Depending on implementation &lt;code&gt;errno&lt;/code&gt; may be &lt;code&gt;EINTR&lt;/code&gt; if operation was interrupted by a signal.</source>
          <target state="translated">如果操作被信号中断，根据实现的不同， &lt;code&gt;errno&lt;/code&gt; 可能是 &lt;code&gt;EINTR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0be77db14ba94fc033fd30c3cfe8822eacafb87" translate="yes" xml:space="preserve">
          <source>Depending on the current floating point rounding mode, rounds the argument either toward nearest (like &lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;), toward zero (like &lt;a href=&quot;#trunc&quot;&gt;trunc&lt;/a&gt;), downward (toward negative infinity), or upward (toward positive infinity) [C99].</source>
          <target state="translated">根据当前的浮点舍入模式，将参数四舍五入为最接近（如&lt;a href=&quot;#round&quot;&gt;round&lt;/a&gt;），朝零（如&lt;a href=&quot;#trunc&quot;&gt;trunc&lt;/a&gt;），向下（向负无穷大）或向上（向正无穷大）[C99]。</target>
        </trans-unit>
        <trans-unit id="5294c397495f76892ffea877bf2a43e2c328f0cb" translate="yes" xml:space="preserve">
          <source>Depending on the host operating system, the value of &lt;code&gt;$^X&lt;/code&gt; may be a relative or absolute pathname of the perl program file, or may be the string used to invoke perl but not the pathname of the perl program file. Also, most operating systems permit invoking programs that are not in the PATH environment variable, so there is no guarantee that the value of &lt;code&gt;$^X&lt;/code&gt; is in PATH. For VMS, the value may or may not include a version number.</source>
          <target state="translated">取决于主机操作系统， &lt;code&gt;$^X&lt;/code&gt; 的值可以是perl程序文件的相对或绝对路径名，也可以是用于调用perl的字符串，而不是perl程序文件的路径名。而且，大多数操作系统都允许调用不在PATH环境变量中的程序，因此不能保证 &lt;code&gt;$^X&lt;/code&gt; 值在PATH中。对于VMS，该值可以包含或不包含版本号。</target>
        </trans-unit>
        <trans-unit id="08084da944037c3c23ff2e2b90762c637e7da38d" translate="yes" xml:space="preserve">
          <source>Depending on the transformation, you will find that one or more of the following will happen</source>
          <target state="translated">根据不同的转变,你会发现会发生以下一种或多种情况。</target>
        </trans-unit>
        <trans-unit id="085d0b5e01dcc02f48f2fd13a4f2ed9ebb9054cb" translate="yes" xml:space="preserve">
          <source>Depending on your platform there are various ways of profiling Perl.</source>
          <target state="translated">根据你的平台,有各种方法来剖析Perl。</target>
        </trans-unit>
        <trans-unit id="a3431b52e6f55419aab8d54a55029192f48ff550" translate="yes" xml:space="preserve">
          <source>Deprecated and removed variables</source>
          <target state="translated">废弃和删除的变量</target>
        </trans-unit>
        <trans-unit id="300ce95b61785c757e93c6783917abef0bc4ae26" translate="yes" xml:space="preserve">
          <source>Deprecated by Unicode. These are characters that expand to more than one character in the specified normalization form, but whether they actually take up more bytes or not depends on the encoding being used. For example, a UTF-8 encoded character may expand to a different number of bytes than a UTF-32 encoded character.</source>
          <target state="translated">已被Unicode废弃。这些字符在指定的规范化形式下可以扩展为多个字符,但它们是否实际占用更多的字节取决于所使用的编码。例如,一个UTF-8编码的字符与一个UTF-32编码的字符可能会扩展到不同的字节数。</target>
        </trans-unit>
        <trans-unit id="09e9afac06c928ecd4bc9dc03a49132c263cf3c1" translate="yes" xml:space="preserve">
          <source>Deprecated by Unicode: Duplicates ccc=vr (Canonical_Combining_Class=Virama)</source>
          <target state="translated">已被Unicode废弃。复制ccc=vr (Canonical_Combining_Class=Virama)</target>
        </trans-unit>
        <trans-unit id="2c6d79954aa926c28b34d07c6c1b52cea0a4f179" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不推荐使用的功能，使用该功能会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:alnum:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。不推荐使用此函数，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。该函数返回总是基于当前的区域，而使用的语言环境的规则是可选的正则表达式的基础上，在效果和图案修饰编译指示（见&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;在perlre字符集修饰符&lt;/a&gt;和&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;的字符集修改生效？在perlre&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="56ed58a2ae79c6af374b506410f3fa9662b418b6" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:alpha:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="48807b7130a48604da6050bef16bf05c1f34509f" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与针对 &lt;code&gt;qr/ ^ [[:cntrl:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e30506988830cd213720be74f34746c5a398ce09" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不推荐使用的功能，使用该功能会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:digit:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。不推荐使用此函数，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="869432009229b46aa164c28a7cd2745d9ba962ec" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:graph:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cdc2b565b6e1d8ec1258567850985d57eddc8117" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不推荐使用的功能，使用该功能会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:lower:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5b86512fb27d707d0e0edc2d4faed1f32e8d3ffd" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:print:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9b872da650d016a5781f8333cf85bdb130b7bcc7" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:punct:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4dfc61b4c0045c69830c72d4c8a9f14a2de7cb42" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。这与对 &lt;code&gt;qr/ ^ [[:space:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9eae66c65e71bd3522a0efba8a80f39c5e45c530" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:upper:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串； 2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d712a49c6b2099faded0c3c79a409ab8379a0967" translate="yes" xml:space="preserve">
          <source>Deprecated function whose use raises a warning, and which is slated to be removed in a future Perl version. It is very similar to matching against &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt; , which you should convert to use instead. The function is deprecated because 1) it doesn't handle UTF-8 encoded strings properly; and 2) it returns &lt;code&gt;TRUE&lt;/code&gt; even if the input is the empty string. The function return is always based on the current locale, whereas using locale rules is optional with the regular expression, based on pragmas in effect and pattern modifiers (see &lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;Character set modifiers in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;).</source>
          <target state="translated">不建议使用的函数，使用该函数会发出警告，并且预定在将来的Perl版本中将其删除。它与对 &lt;code&gt;qr/ ^ [[:xdigit:]]+ $ /x&lt;/code&gt; 匹配非常相似，您应该将其转换为使用。该函数已被弃用，因为1）它不能正确处理UTF-8编码的字符串；2）即使输入为空字符串，它也会返回 &lt;code&gt;TRUE&lt;/code&gt; 。函数返回始终基于当前语言环境，而对正则表达式使用语言环境规则是可选的，基于效果中的编译&lt;a href=&quot;perlre#Character-set-modifiers&quot;&gt;指示符&lt;/a&gt;和模式修饰符（请参见perlre中的字符集修饰符和perlre中的&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="77e5e77915f87f5eba641b256db1ec0d6448e365" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl 5.</source>
          <target state="translated">在Perl 5中已不适用。</target>
        </trans-unit>
        <trans-unit id="0447c363038e418e07f3246f8ca43e5cfd53e211" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl 5.10.0</source>
          <target state="translated">在Perl 5.10.0中被取消。</target>
        </trans-unit>
        <trans-unit id="42f0ac3a73aa4ea8f831dc4a897f203beaf75865" translate="yes" xml:space="preserve">
          <source>Deprecated in Perl v5.12.0.</source>
          <target state="translated">在Perl v5.12.0中已不适用。</target>
        </trans-unit>
        <trans-unit id="c719d3d031098df68eeee6d64494f02905ae30e2" translate="yes" xml:space="preserve">
          <source>Deprecated method, but does the same as service_check() method.</source>
          <target state="translated">废弃的方法,但与service_check()方法的作用相同。</target>
        </trans-unit>
        <trans-unit id="f82cf002f6b4c932fb0a62e044c473c42a57f99c" translate="yes" xml:space="preserve">
          <source>Deprecated method. Use libscan instead.</source>
          <target state="translated">废弃的方法。使用libscan代替。</target>
        </trans-unit>
        <trans-unit id="296aaa10f5a1032a3fc94ecfb0996dab5a0c7b1f" translate="yes" xml:space="preserve">
          <source>Deprecated module to load Locale::Maketext utf8 code</source>
          <target state="translated">加载Locale::Maketext utf8代码的过时模块。</target>
        </trans-unit>
        <trans-unit id="b5972c72225aadd112c116405b2c9a8c61f8be67" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;code&gt;is_actual_ok&lt;/code&gt; instead.</source>
          <target state="translated">不推荐使用。请改用 &lt;code&gt;is_actual_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f480918eabb96e1b569421fef2e3056b6e5a48a3" translate="yes" xml:space="preserve">
          <source>Deprecated. Please use &lt;code&gt;is_ok&lt;/code&gt; instead.</source>
          <target state="translated">不推荐使用。请改用 &lt;code&gt;is_ok&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8bab31dacd225be342dc45946fc045df33a2d1c4" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;code&gt;is_good_plan&lt;/code&gt; instead.</source>
          <target state="translated">不推荐使用。请使用 &lt;code&gt;is_good_plan&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4880df7da732b64649d73fa94f900ec9f18233e3" translate="yes" xml:space="preserve">
          <source>Deprecating a variable announces the intent of the perl maintainers to eventually remove the variable from the language. It may still be available despite its status. Using a deprecated variable triggers a warning.</source>
          <target state="translated">废弃一个变量,意味着perl维护者打算最终从语言中删除这个变量。尽管它的状态是这样的,但它仍然可以使用。使用一个废弃的变量会触发一个警告。</target>
        </trans-unit>
        <trans-unit id="be163eb89f0ec6f8bfe369849331f8a896683818" translate="yes" xml:space="preserve">
          <source>Dereference-address operator. (Perl's prefix dereferencing operators are typed: &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , and &lt;code&gt;&amp;amp;&lt;/code&gt; .)</source>
          <target state="translated">解引用地址运算符。（输入Perl的前缀解引用运算符： &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ， &lt;code&gt;%&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a13dba076abe09205f4d6530500f95233f3d8b89" translate="yes" xml:space="preserve">
          <source>Dereferences an RV to return the SV.</source>
          <target state="translated">Dereferences an RV to return the SV.</target>
        </trans-unit>
        <trans-unit id="1482ff3cb39b2ab2879a6e8a1d98292788d82730" translate="yes" xml:space="preserve">
          <source>Deregistration is done in this case by calling event_loop with &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as its parameter:</source>
          <target state="translated">在这种情况下，可以通过使用 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为参数调用event_loop来完成注销：</target>
        </trans-unit>
        <trans-unit id="0ece715d7bfa3a1e4b4b7c2716133b08b5012fe3" translate="yes" xml:space="preserve">
          <source>Derived Normalization Properties</source>
          <target state="translated">衍生的归一化属性</target>
        </trans-unit>
        <trans-unit id="46565153346c49e93798bd916a2902e7376b3a49" translate="yes" xml:space="preserve">
          <source>Derived from FileHandle.pm by Graham Barr &amp;lt;</source>
          <target state="translated">源自Graham Barr的FileHandle.pm &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bc5d76c2188dda3e644ef5539acfe2ee659fc494" translate="yes" xml:space="preserve">
          <source>Derived from FileHandle.pm by Graham Barr &amp;lt;gbarr@pobox.com&amp;gt;</source>
          <target state="translated">由Graham Barr从FileHandle.pm衍生而来&amp;lt;gbarr@pobox.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f61cc4cb53719b61daa460c7f629eaad048da52" translate="yes" xml:space="preserve">
          <source>Derived from many sources. Some would say</source>
          <target state="translated">衍生的来源很多。有人会说</target>
        </trans-unit>
        <trans-unit id="f27ae512bfe1f4a041a1bece8dc33e39ce992aa0" translate="yes" xml:space="preserve">
          <source>DerivedNormalizationProps.txt</source>
          <target state="translated">DerivedNormalizationProps.txt</target>
        </trans-unit>
        <trans-unit id="c4477abcc61a8e8691692bd5b2f94edfbc46fd9d" translate="yes" xml:space="preserve">
          <source>Describe what you're doing and how you're doing it, using normal Perl comments.</source>
          <target state="translated">用普通的Perl注释来描述你正在做的事情和你是如何做的。</target>
        </trans-unit>
        <trans-unit id="34b3e166e1301e0606954d6a55611015e6cbfc1c" translate="yes" xml:space="preserve">
          <source>Describes the format and contents of</source>
          <target state="translated">描述了以下文件的格式和内容</target>
        </trans-unit>
        <trans-unit id="96a98270561c02f5c77d9be37f677cf453421b77" translate="yes" xml:space="preserve">
          <source>Descrip.MMS</source>
          <target state="translated">Descrip.MMS</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="19d71724ac39d6a9fdd91c9d7584648481c9ba90" translate="yes" xml:space="preserve">
          <source>Descriptive editing term&amp;mdash;short for &amp;ldquo;awkward&amp;rdquo;. Also coincidentally refers to a venerable text-processing language from which Perl derived some of its high-level ideas.</source>
          <target state="translated">描述性编辑术语-&amp;ldquo;尴尬&amp;rdquo;的缩写。巧合的是，Perl引用了一种古老的文本处理语言，由此衍生出了一些高级思想。</target>
        </trans-unit>
        <trans-unit id="092d175f31c309d86e54ac4890791b68f8011efb" translate="yes" xml:space="preserve">
          <source>Designed to be a method call, and to be overridden by a derived class (i.e. a class which has DynaLoader in its @ISA). The definition in DynaLoader itself returns 0, which produces standard behavior from dl_load_file().</source>
          <target state="translated">设计为一个方法调用,并被派生类(即一个在@ISA中包含DynaLoader的类)重写。DynaLoader中的定义本身就返回0,从而产生dl_load_file()的标准行为。</target>
        </trans-unit>
        <trans-unit id="59aac4a2c7e327e45b17c4aed3092d9662863e7d" translate="yes" xml:space="preserve">
          <source>Designing your API</source>
          <target state="translated">设计您的API</target>
        </trans-unit>
        <trans-unit id="2304f50cca1805cd55f5d31750b7fa633b66fe80" translate="yes" xml:space="preserve">
          <source>Desired permission for directories. Defaults to &lt;code&gt;755&lt;/code&gt; .</source>
          <target state="translated">所需的目录权限。默认为 &lt;code&gt;755&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533cafeb3aa07a126f4d3b8498ce1b5a7bd7a9da" translate="yes" xml:space="preserve">
          <source>Desired permission for executable files. Defaults to &lt;code&gt;755&lt;/code&gt; .</source>
          <target state="translated">所需的可执行文件权限。默认为 &lt;code&gt;755&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a3e68ecf77d35df71a723c0bb9b9d6b0bcf091b" translate="yes" xml:space="preserve">
          <source>Desired permission for read/writable files. Defaults to &lt;code&gt;644&lt;/code&gt; .</source>
          <target state="translated">所需的读/写文件权限。默认为 &lt;code&gt;644&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="369c7a7ce11a967333493247a17fefcaf8782924" translate="yes" xml:space="preserve">
          <source>Despite its name, this calls your system's default documentation viewer on the given page, or on the viewer itself if</source>
          <target state="translated">虽说是名字,但它在给定的页面上调用系统的默认文档查看器,如果查看器本身是</target>
        </trans-unit>
        <trans-unit id="c89708df88c5d908f88da0373b3c5448a6138264" translate="yes" xml:space="preserve">
          <source>Despite the existence of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, there are still three places where the &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator still shines. In fact, in these three places, you</source>
          <target state="translated">尽管存在 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ，但是仍然有三个地方的 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 操作员仍然发光。实际上，在这三个地方，</target>
        </trans-unit>
        <trans-unit id="5907dde0a5903ebac0baff736f53c485d9ebcc11" translate="yes" xml:space="preserve">
          <source>Despite the name of the &lt;code&gt;finddepth()&lt;/code&gt; function, both &lt;code&gt;find()&lt;/code&gt; and &lt;code&gt;finddepth()&lt;/code&gt; perform a depth-first search of the directory hierarchy.</source>
          <target state="translated">尽管有 &lt;code&gt;finddepth()&lt;/code&gt; 函数的名称，但是 &lt;code&gt;find()&lt;/code&gt; 和 &lt;code&gt;finddepth()&lt;/code&gt; 都执行目录层次结构的深度优先搜索。</target>
        </trans-unit>
        <trans-unit id="2a5924278d8b7657f3aeb8649ead9475eab91d8f" translate="yes" xml:space="preserve">
          <source>Despite their suggestions in earlier versions of this document the macros &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; are</source>
          <target state="translated">尽管在本文档的早期版本中提出了建议，但宏 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 仍然是</target>
        </trans-unit>
        <trans-unit id="bcf6c17f9da73e467a073ac5e6e487e5bdc36429" translate="yes" xml:space="preserve">
          <source>Destructors</source>
          <target state="translated">Destructors</target>
        </trans-unit>
        <trans-unit id="78fbdf14ab60724c2e9f95d677204576dc399f05" translate="yes" xml:space="preserve">
          <source>Destructors may not be called on objects if those objects still exist at global destruction time. If the destructors must be called, make sure there are no circular references and that nothing is referencing the objects, before the program ends.</source>
          <target state="translated">如果对象在全局销毁时仍然存在,则不能对这些对象调用破坏函数。如果必须调用破坏函数,请在程序结束前确保没有循环引用,也没有任何东西在引用对象。</target>
        </trans-unit>
        <trans-unit id="7f13a5e8324201e8439f86f9e267530c519b5fa1" translate="yes" xml:space="preserve">
          <source>Detach from the shared memory segment that previously has been attached to. Returns true if successful, or false on error. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;.</source>
          <target state="translated">从先前已连接的共享内存段中分离。如果成功，则返回true；如果错误，则返回false。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6d104f83eda0e6841179588c742c21e25fb6240" translate="yes" xml:space="preserve">
          <source>Detach the shared memory segment located at the address specified by ADDR from the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;.</source>
          <target state="translated">从调用进程的地址空间中分离位于ADDR指定的地址处的共享内存段。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmdt&quot;&gt;shmdt&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="524606f1e7f47ed54a2dc7c2ed309c5733e4790f" translate="yes" xml:space="preserve">
          <source>Detailed description of each of the command-line options taken by the program. This should be separate from the description for the use of parsers like &lt;a href=&quot;pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. This is normally presented as a list, with each option as a separate &lt;code&gt;=item&lt;/code&gt; . The specific option string should be enclosed in B&amp;lt;&amp;gt;. Any values that the option takes should be enclosed in I&amp;lt;&amp;gt;. For example, the section for the option &lt;b&gt;--section&lt;/b&gt;=</source>
          <target state="translated">该程序采用的每个命令行选项的详细说明。对于使用诸如&lt;a href=&quot;pod/usage&quot;&gt;Pod :: Usage之&lt;/a&gt;类的解析器，应与描述分开。通常以列表的形式显示，每个选项作为单独的 &lt;code&gt;=item&lt;/code&gt; 。特定的选项字符串应包含在B &amp;lt;&amp;gt;中。该选项采用的任何值都应包含在I &amp;lt;&amp;gt;中。例如，选项&lt;b&gt;--section&lt;/b&gt; = 的section</target>
        </trans-unit>
        <trans-unit id="fe13e56081ddb095d18e9d96165e4c91a787dd78" translate="yes" xml:space="preserve">
          <source>Detailed documentation about modules can be found at: &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;, &lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt;.</source>
          <target state="translated">有关模块的详细文档，请参见：&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;，&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;，&lt;a href=&quot;perlmodstyle&quot;&gt;perlmodstyle&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48efd59016764ae34dbd4dd35254250b9ade50c2" translate="yes" xml:space="preserve">
          <source>Detailed info about trie compilation.</source>
          <target state="translated">关于Trie汇编的详细信息。</target>
        </trans-unit>
        <trans-unit id="48a5bf693bd8174668fcec90fe1c7747773cff6b" translate="yes" xml:space="preserve">
          <source>Detailed instructions on how to build and install perl extension modules, including XS-type modules, is included. See 'BUILDING AND INSTALLING MODULES'.</source>
          <target state="translated">我们提供了关于如何构建和安装perl扩展模块(包括XS型模块)的详细说明。参见 &quot;构建和安装模块&quot;。</target>
        </trans-unit>
        <trans-unit id="971ecb47b81b9e3ebb8421ed26268b0335343299" translate="yes" xml:space="preserve">
          <source>Detailed signal management. This uses &lt;code&gt;POSIX::SigAction&lt;/code&gt; objects for the &lt;code&gt;action&lt;/code&gt; and &lt;code&gt;oldaction&lt;/code&gt; arguments (the oldaction can also be just a hash reference). Consult your system's &lt;code&gt;sigaction&lt;/code&gt; manpage for details, see also &lt;code&gt;POSIX::SigRt&lt;/code&gt; .</source>
          <target state="translated">详细的信号管理。这使用 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 对象作为 &lt;code&gt;action&lt;/code&gt; 和 &lt;code&gt;oldaction&lt;/code&gt; 参数（oldaction也可以只是哈希引用）。请咨询系统的 &lt;code&gt;sigaction&lt;/code&gt; 的联机帮助页的详细信息，也可参见 &lt;code&gt;POSIX::SigRt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c9fa89519b1cc82f7ef4510c084ac4535cbb9b1" translate="yes" xml:space="preserve">
          <source>Details are in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">详细信息&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;在perlop&lt;/a&gt;中的Quote和类似Quote的运算符中。</target>
        </trans-unit>
        <trans-unit id="9ba741c6d40d9b34740b66e9f99ec546651895d0" translate="yes" xml:space="preserve">
          <source>Details changes to Locale::Codes</source>
          <target state="translated">对Locale::Codes的详细修改</target>
        </trans-unit>
        <trans-unit id="79ba379e83c3a5e1a2d0279f940c57dc6c7027f0" translate="yes" xml:space="preserve">
          <source>Detect the user's language preferences</source>
          <target state="translated">检测用户的语言偏好</target>
        </trans-unit>
        <trans-unit id="4e04b164f775f2394cd7b257c789eeab3703bf40" translate="yes" xml:space="preserve">
          <source>Determination of Perl Library and Installation Locations</source>
          <target state="translated">确定Perl库和安装位置</target>
        </trans-unit>
        <trans-unit id="428b80cb8395cadc1a038a4e4bdb2355d7bb3c54" translate="yes" xml:space="preserve">
          <source>Determination of whether $BSD_STYLE should be set is left as an exercise to the reader.</source>
          <target state="translated">是否应该设置$BSD_STYLE是由读者自己决定的。</target>
        </trans-unit>
        <trans-unit id="25d8f9f38f16f8b5a3c700d3bd4a5cd28a740860" translate="yes" xml:space="preserve">
          <source>Determine if the server supports the specified feature. The return value is a list of lines the server responded with to describe the options that it supports for the given feature. If the feature is unsupported then the empty list is returned.</source>
          <target state="translated">确定服务器是否支持指定的功能。返回值是服务器响应的行列表,用来描述它支持的给定特性的选项。如果不支持该功能,则返回空列表。</target>
        </trans-unit>
        <trans-unit id="46c27646774eae185d5079b386367766995dfee9" translate="yes" xml:space="preserve">
          <source>Determine libraries to use and how to use them</source>
          <target state="translated">确定要使用的库以及如何使用它们</target>
        </trans-unit>
        <trans-unit id="bfbb294be56602dd8d5e0f86c6b7c3dc8fd0ef0f" translate="yes" xml:space="preserve">
          <source>Determine the full paths (including file suffix) of one or more loadable files given their generic names and optionally one or more directories. Searches directories in @dl_library_path by default and returns an empty list if no files were found.</source>
          <target state="translated">确定一个或多个可加载文件的完整路径(包括文件后缀),给定这些文件的通用名称和可选的一个或多个目录。默认情况下,搜索@dl_library_path中的目录,如果没有找到文件,则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="c47d159fd2f7d84a2dc5b895afa17d3e1c470e9d" translate="yes" xml:space="preserve">
          <source>Determine whether a file is native to Cygwin by checking whether it resides inside the Cygwin installation (using Windows paths). If so, use &lt;code&gt;ExtUtils::MM_Unix&lt;/code&gt; to determine if it may be a command. Otherwise use the tests from &lt;code&gt;ExtUtils::MM_Win32&lt;/code&gt; .</source>
          <target state="translated">通过检查文件是否位于Cygwin安装程序内（使用Windows路径），确定文件是否为Cygwin本地文​​件。如果是这样，请使用 &lt;code&gt;ExtUtils::MM_Unix&lt;/code&gt; 确定它是否可能是命令。否则，请使用 &lt;code&gt;ExtUtils::MM_Win32&lt;/code&gt; 的测试。</target>
        </trans-unit>
        <trans-unit id="a35731d2a8f0fd508c5b03e1f3c340b65af8b100" translate="yes" xml:space="preserve">
          <source>Determines if man pages should be generated and initializes MAN1PODS and MAN3PODS as appropriate.</source>
          <target state="translated">确定是否应该生成单页,并酌情初始化MAN1PODS和MAN3PODS。</target>
        </trans-unit>
        <trans-unit id="32b2b5cefa4d496f2ffa711bf6d062b35a6183bc" translate="yes" xml:space="preserve">
          <source>Determines if the given &lt;code&gt;$thing&lt;/code&gt; can be used as a filehandle.</source>
          <target state="translated">确定给定的 &lt;code&gt;$thing&lt;/code&gt; 可以用作文件句柄。</target>
        </trans-unit>
        <trans-unit id="81c97d633f09f436c3551fc2f985b2dd31ceb89b" translate="yes" xml:space="preserve">
          <source>Determines if the two hashes contain the same keys and values. This is a deep check.</source>
          <target state="translated">确定两个哈希是否包含相同的键和值。这是一种深度检查。</target>
        </trans-unit>
        <trans-unit id="02bc22cbed7ebf5c21902f1d116056eb9bbd8381" translate="yes" xml:space="preserve">
          <source>Determines the &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; for the failure in case it is successful. This color defaults to &lt;code&gt;'red'&lt;/code&gt; .</source>
          <target state="translated">如果成功，则确定失败的&lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;。该颜色默认为 &lt;code&gt;'red'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46421b429d7fbec4c32a7efe5539900fa9227686" translate="yes" xml:space="preserve">
          <source>Determines the &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; for the summary in case it is successful. This color defaults to &lt;code&gt;'green'&lt;/code&gt; .</source>
          <target state="translated">如果成功，则确定摘要的&lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;。此颜色默认为 &lt;code&gt;'green'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99525db85549ac64cdd5cb889d480f43dfc76de6" translate="yes" xml:space="preserve">
          <source>Determines the accessibility of a file.</source>
          <target state="translated">确定文件的可访问性。</target>
        </trans-unit>
        <trans-unit id="0ac6e93aa78866241a9a1ea97a746deee7e73a8e" translate="yes" xml:space="preserve">
          <source>Determines typemaps, xsubpp version, prototype behaviour.</source>
          <target state="translated">确定类型图、xsubpp版本、原型行为。</target>
        </trans-unit>
        <trans-unit id="f07a1f637abae6218e8a7802badc87cffd6df457" translate="yes" xml:space="preserve">
          <source>Determines whether you do the left &lt;b&gt;operator&lt;/b&gt; first or the right &lt;b&gt;operator&lt;/b&gt; first when you have &amp;ldquo;A &lt;b&gt;operator&lt;/b&gt; B &lt;b&gt;operator&lt;/b&gt; C&amp;rdquo;, and the two operators are of the same precedence. Operators like &lt;code&gt;+&lt;/code&gt; are left associative, while operators like &lt;code&gt;**&lt;/code&gt; are right associative. See Camel chapter 3, &amp;ldquo;Unary and Binary Operators&amp;rdquo; for a list of operators and their associativity.</source>
          <target state="translated">确定当您拥有&amp;ldquo; A &lt;b&gt;运算符&lt;/b&gt; B &lt;b&gt;运算符&lt;/b&gt; C&amp;rdquo;并且两个运算符的优先级相同时，是先执行左&lt;b&gt;运算符&lt;/b&gt;还是先执行右&lt;b&gt;运算符&lt;/b&gt;。像 &lt;code&gt;+&lt;/code&gt; 这样的运算符是左联想，而像 &lt;code&gt;**&lt;/code&gt; 这样的运算符是右联想。有关运算符及其关联性的列表，请参见Camel第3章&amp;ldquo;一元和二元运算符&amp;rdquo;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d1c8bafa598045542a6e12bdae08698fa56ba1b8" translate="yes" xml:space="preserve">
          <source>Determines which of the sets of installation directories to choose: perl, site or vendor. Defaults to site.</source>
          <target state="translated">确定选择哪一组安装目录:perl、site或vendor。默认为site。</target>
        </trans-unit>
        <trans-unit id="bba5b2e65a661d27394fb8c061d3d51455420899" translate="yes" xml:space="preserve">
          <source>Determining the Context</source>
          <target state="translated">确定上下文</target>
        </trans-unit>
        <trans-unit id="3ecab9eb72cc6dfc1bcb8e4baecb3e17d8edcf33" translate="yes" xml:space="preserve">
          <source>Devel.U</source>
          <target state="translated">Devel.U</target>
        </trans-unit>
        <trans-unit id="d8c39aea2543b8523b0f33dbb117b8a3d9253fb8" translate="yes" xml:space="preserve">
          <source>Devel::DProf</source>
          <target state="translated">Devel::DProf</target>
        </trans-unit>
        <trans-unit id="ccde7e8b696b5ea06bba6178d203f16332d8acef" translate="yes" xml:space="preserve">
          <source>Devel::FastProf</source>
          <target state="translated">Devel::FastProf</target>
        </trans-unit>
        <trans-unit id="11215cfa0c659675e0e4ea40e3abc5e714feee1f" translate="yes" xml:space="preserve">
          <source>Devel::NYTProf</source>
          <target state="translated">Devel::NYTProf</target>
        </trans-unit>
        <trans-unit id="93fefc93ea4e5ce72e46483e30bdcdb72752bc35" translate="yes" xml:space="preserve">
          <source>Devel::PPPort</source>
          <target state="translated">Devel::PPPort</target>
        </trans-unit>
        <trans-unit id="7ffae19dcafff8088943ef185c49a680d59a15ac" translate="yes" xml:space="preserve">
          <source>Devel::PPPort - Perl/Pollution/Portability</source>
          <target state="translated">开发::PPPort-Perl/污染/可移植性</target>
        </trans-unit>
        <trans-unit id="3921057b50b0060084d8d65b7996993cf1ed9750" translate="yes" xml:space="preserve">
          <source>Devel::Peek</source>
          <target state="translated">Devel::Peek</target>
        </trans-unit>
        <trans-unit id="e14a96c568c781af1b5e318bd4b44427491f52d9" translate="yes" xml:space="preserve">
          <source>Devel::Peek - A data debugging tool for the XS programmer</source>
          <target state="translated">Devel::Peek-XS程序员的数据调试工具。</target>
        </trans-unit>
        <trans-unit id="591a540c3f692dc8379dc38f7e57b50c1e10292e" translate="yes" xml:space="preserve">
          <source>Devel::Peek contains functions which allows raw Perl datatypes to be manipulated from a Perl script. This is used by those who do XS programming to check that the data they are sending from C to Perl looks as they think it should look. The trick, then, is to know what the raw datatype is supposed to look like when it gets to Perl. This document offers some tips and hints to describe good and bad raw data.</source>
          <target state="translated">Devel::Peek 包含了允许从 Perl 脚本中操作原始 Perl 数据类型的函数。这被那些做XS编程的人用来检查他们从C语言发送到Perl的数据是否看起来像他们认为的那样。那么,诀窍就是要知道原始数据类型传到Perl时应该是什么样子的。本文档提供了一些技巧和提示来描述好的和坏的原始数据。</target>
        </trans-unit>
        <trans-unit id="db1f06d5f74de3011e9cc4bc49d43cef041da2cf" translate="yes" xml:space="preserve">
          <source>Devel::Peek supplies a &lt;code&gt;Dump()&lt;/code&gt; function which can dump a raw Perl datatype, and &lt;code&gt;mstat(&quot;marker&quot;)&lt;/code&gt; function to report on memory usage (if perl is compiled with corresponding option). The function DeadCode() provides statistics on the data &quot;frozen&quot; into inactive &lt;code&gt;CV&lt;/code&gt; . Devel::Peek also supplies &lt;code&gt;SvREFCNT()&lt;/code&gt; which can query reference counts on SVs. This document will take a passive, and safe, approach to data debugging and for that it will describe only the &lt;code&gt;Dump()&lt;/code&gt; function.</source>
          <target state="translated">Devel :: Peek提供了一个 &lt;code&gt;Dump()&lt;/code&gt; 函数，可以转储原始的Perl数据类型，以及 &lt;code&gt;mstat(&quot;marker&quot;)&lt;/code&gt; 函数以报告内存使用情况（如果perl是使用相应选项编译的）。DeadCode（）函数提供有关数据&amp;ldquo;冻结&amp;rdquo;为无效 &lt;code&gt;CV&lt;/code&gt; 的统计信息。Devel :: Peek还提供了 &lt;code&gt;SvREFCNT()&lt;/code&gt; ，它可以查询SV上的引用计数。本文档将采取一种被动且安全的方法来进行数据调试，为此，它仅描述 &lt;code&gt;Dump()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="dd06cacef5c6992e80eae6f0b88092dd28458a5a" translate="yes" xml:space="preserve">
          <source>Devel::Profiler</source>
          <target state="translated">Devel::Profiler</target>
        </trans-unit>
        <trans-unit id="4b6535e01c52786d4e3f3ca2b00ca3272e9f6d30" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber</source>
          <target state="translated">Devel::SelfStubber</target>
        </trans-unit>
        <trans-unit id="b5469167c418142a031a1a19dcd7b0ac06472cae" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber - generate stubs for a SelfLoading module</source>
          <target state="translated">开发::SelfStubber-为SelfLoading模块生成存根。</target>
        </trans-unit>
        <trans-unit id="c12151c156a6bb57f46bf2cfabec163c1bfc0f60" translate="yes" xml:space="preserve">
          <source>Devel::SelfStubber prints the stubs you need to put in the module before the __DATA__ token (or you can get it to print the entire module with stubs correctly placed). The stubs ensure that if a method is called, it will get loaded. They are needed specifically for inherited autoloaded methods.</source>
          <target state="translated">Devel::SelfStubber 在 __DATA__标记之前打印你需要放在模块中的存根 (或者你可以让它打印整个模块中正确放置的存根)。这些存根确保如果一个方法被调用,它将被加载。它们是继承的自动加载方法所特别需要的。</target>
        </trans-unit>
        <trans-unit id="842dcd37ebf74b06348dc557d220529763bf8eb5" translate="yes" xml:space="preserve">
          <source>Devel::SmallProf</source>
          <target state="translated">Devel::SmallProf</target>
        </trans-unit>
        <trans-unit id="4c17aadf5117487aab7bc50cbf056caf3977cc31" translate="yes" xml:space="preserve">
          <source>Development</source>
          <target state="translated">Development</target>
        </trans-unit>
        <trans-unit id="d9ffe88162ace37c72e458ee67a70fb3d18d4395" translate="yes" xml:space="preserve">
          <source>Development Support</source>
          <target state="translated">发展支持</target>
        </trans-unit>
        <trans-unit id="f0c7babf29efe97f8e794e98c4e99a03a18a4c41" translate="yes" xml:space="preserve">
          <source>Device major number in case of a special file</source>
          <target state="translated">特殊文件时的设备大号</target>
        </trans-unit>
        <trans-unit id="2c941665c705f296265e4a2b31a60000a96baced" translate="yes" xml:space="preserve">
          <source>Device minor number in case of a special file</source>
          <target state="translated">特殊文件时的设备小号</target>
        </trans-unit>
        <trans-unit id="ee7b51236ed970aee0667e1f1fe4a778ffb14074" translate="yes" xml:space="preserve">
          <source>Diagnostic messages derive from the</source>
          <target state="translated">诊断信息来自于</target>
        </trans-unit>
        <trans-unit id="3af2279f9e306acd0a4644e2b0f2f48a1e06d8d9" translate="yes" xml:space="preserve">
          <source>Diagnostics</source>
          <target state="translated">Diagnostics</target>
        </trans-unit>
        <trans-unit id="e12e989f1fa699061a1906fb84c40da51f94d183" translate="yes" xml:space="preserve">
          <source>Diagnostics: - &quot;Illegal state option: %s&quot;</source>
          <target state="translated">诊断:-&quot;非法状态选项:%s&quot;</target>
        </trans-unit>
        <trans-unit id="24aeba6cea55e3491e6f6e028d622f79e9da9608" translate="yes" xml:space="preserve">
          <source>Did we mention that you should definitely consider using the &lt;b&gt;use warnings&lt;/b&gt; pragma?</source>
          <target state="translated">我们是否提到您绝对应该考虑使用&lt;b&gt;使用警告用法&lt;/b&gt;？</target>
        </trans-unit>
        <trans-unit id="9b6cbb2dd2135deb31b16770182a2ec8c70c6f29" translate="yes" xml:space="preserve">
          <source>Did you really want to know? :-) For more gory details on getting regular expressions to work, have a look at &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;, and to decode the mysterious labels (BOL and CURLYN, etc. above), see &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">你真的想知道吗？:-)有关使正则表达式起作用的更多细节，请查看&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;，&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;并解码神秘标签（上面的BOL和CURLYN等），请参阅&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c365b19f02fa9700446bb2dfae00cddef737c1ed" translate="yes" xml:space="preserve">
          <source>Did you run your programs with &lt;code&gt;-w&lt;/code&gt; switch? See &lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;2 (and DOS) programs under Perl in Starting OS&lt;/a&gt;.</source>
          <target state="translated">您是否使用 &lt;code&gt;-w&lt;/code&gt; 开关运行程序？请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/Starting%20OS#2-(and-DOS)-programs-under-Perl&quot;&gt;启动OS中Perl下的2（和DOS）程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c44a0b6cfa2e8e8711c5a9b4665955570db35afc" translate="yes" xml:space="preserve">
          <source>Didn't anyone ever tell you web-page hit counters were useless? They don't count number of hits, they're a waste of time, and they serve only to stroke the writer's vanity. It's better to pick a random number; they're more realistic.</source>
          <target state="translated">难道没有人告诉过你网页点击率计数器是没用的吗?他们不计算点击量,他们是在浪费时间,他们只是为了抚摸作者的虚荣心。最好是随机选一个数字,它们更真实。</target>
        </trans-unit>
        <trans-unit id="de35dca213966232628ded8b499a88baf25eec19" translate="yes" xml:space="preserve">
          <source>Die on HUP, INT, PIPE or TERM, except don't change the behavior for signals which are already trapped or ignored:</source>
          <target state="translated">死于HUP、INT、PIPE或TERM,除了不改变已经被捕获或忽略的信号的行为。</target>
        </trans-unit>
        <trans-unit id="0b65dd725b89443cd082d2b1fbb5c871c07b811a" translate="yes" xml:space="preserve">
          <source>Die on HUP, INT, PIPE or TERM:</source>
          <target state="translated">模具在HUP、INT、PIPE或TERM上。</target>
        </trans-unit>
        <trans-unit id="7370d007d2f0750cfcb06f3ae1a311fa8ce10185" translate="yes" xml:space="preserve">
          <source>Die on INT or QUIT:</source>
          <target state="translated">死于INT或QUIT。</target>
        </trans-unit>
        <trans-unit id="de3e3f090fef16d61db17c82fcb979d37ca68a0d" translate="yes" xml:space="preserve">
          <source>Die on receipt one of an of the &lt;b&gt;normal-signals&lt;/b&gt; which is currently &lt;b&gt;untrapped&lt;/b&gt;, provide a stack trace on receipt of &lt;b&gt;any&lt;/b&gt; of the &lt;b&gt;error-signals&lt;/b&gt;:</source>
          <target state="translated">管芯上的一个所述的接收到一个&lt;b&gt;正常的信号&lt;/b&gt;这是目前&lt;b&gt;未捕获的&lt;/b&gt;，在接收的提供堆栈跟踪&lt;b&gt;任何&lt;/b&gt;所述的&lt;b&gt;误差信号&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="ba441dab8e607c94b508525a17abee026d45b519" translate="yes" xml:space="preserve">
          <source>Dies if something fails. Does not return anything useful.</source>
          <target state="translated">如果失败了,就会死亡。不返回任何有用的东西。</target>
        </trans-unit>
        <trans-unit id="f81677da87b912ca4cbc2adcd260fa40bc3569e4" translate="yes" xml:space="preserve">
          <source>Dies on invalid arguments.</source>
          <target state="translated">死于无效参数。</target>
        </trans-unit>
        <trans-unit id="ff49095a95255fd00fd15d75e6567dd8a12a4746" translate="yes" xml:space="preserve">
          <source>Dies with &quot;QUITing...&quot; if WM_QUIT message is obtained.</source>
          <target state="translated">如果获得WM_QUIT消息,则以 &quot;QUITing...&quot;死机。</target>
        </trans-unit>
        <trans-unit id="4df44d1ca612254d8b6146ed208bbeb09ddfe82a" translate="yes" xml:space="preserve">
          <source>Dies with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">与 &lt;code&gt;@message&lt;/code&gt; 一起死，但是消息似乎来自调用原始测试函数的位置（ &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eb0b600e20a7af68665f367d76b7faa7b80ba746" translate="yes" xml:space="preserve">
          <source>Difference between &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;autoload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 与 &lt;code&gt;autoload&lt;/code&gt; 之间的区别</target>
        </trans-unit>
        <trans-unit id="1f4478706dbd396a43de3090b3f058233138f6af" translate="yes" xml:space="preserve">
          <source>Difference between load and autoload</source>
          <target state="translated">加载和自动加载之间的区别</target>
        </trans-unit>
        <trans-unit id="af858e1241391fd569b50d644bb00507f74f4034" translate="yes" xml:space="preserve">
          <source>Differences</source>
          <target state="translated">Differences</target>
        </trans-unit>
        <trans-unit id="38024e12015fb8cbceae437a2c486569781a63ed" translate="yes" xml:space="preserve">
          <source>Differences from Perl 6</source>
          <target state="translated">与Perl 6的区别</target>
        </trans-unit>
        <trans-unit id="331cb030b664a4d11f924279069f94d488d3faa3" translate="yes" xml:space="preserve">
          <source>Different CPUs store integers and floating point numbers in different orders (called</source>
          <target state="translated">不同的CPU以不同的顺序存储整数和浮点数(称为</target>
        </trans-unit>
        <trans-unit id="2bda7000c880740a37cbf94090331ac6cabf1bab" translate="yes" xml:space="preserve">
          <source>Different definitions of Perl are given in &lt;a href=&quot;perl&quot;&gt;perl&lt;/a&gt;, &lt;a href=&quot;perlfaq1&quot;&gt;perlfaq1&lt;/a&gt; and no doubt other places. From this we can determine that Perl is different things to different people, but that lots of people think it's at least worth writing about.</source>
          <target state="translated">&lt;a href=&quot;perl&quot;&gt;Perl&lt;/a&gt;，&lt;a href=&quot;perlfaq1&quot;&gt;perlfaq1&lt;/a&gt;以及其他地方无疑给出了Perl的不同定义。由此我们可以确定Perl对于不同的人来说是不同的东西，但是很多人认为这至少值得一提。</target>
        </trans-unit>
        <trans-unit id="7dccaaf84bf4def2fd87e2d3e385599fbd55f83d" translate="yes" xml:space="preserve">
          <source>Different escape characters can be specified for different delimiters. For example, to specify that '/' is the escape for single quotes and '%' is the escape for double quotes:</source>
          <target state="translated">可以为不同的定界符指定不同的转义字符,例如,指定'/'是单引号的转义字符,'%'是双引号的转义字符。例如,指定'/'是单引号的转义符,'%'是双引号的转义符。</target>
        </trans-unit>
        <trans-unit id="f9a49cb812bf417ffcc0cc6f39c98fe84fa2ebdf" translate="yes" xml:space="preserve">
          <source>Different handles can have different buffering schemes. The &quot;top&quot; layer could be the &quot;mmap&quot; layer if reading disk files was quicker using &lt;code&gt;mmap&lt;/code&gt; than &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;. An &quot;unbuffered&quot; stream can be implemented simply by not having a buffer layer.</source>
          <target state="translated">不同的句柄可以具有不同的缓冲方案。如果使用 &lt;code&gt;mmap&lt;/code&gt; 读取磁盘文件比 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 更快，则&amp;ldquo; top&amp;rdquo;层可以是&amp;ldquo; mmap&amp;rdquo;层。可以简单地通过没有缓冲层来实现&amp;ldquo;非缓冲&amp;rdquo;流。</target>
        </trans-unit>
        <trans-unit id="ee681ba258c7b2da3e8972edb7ba868618d14b60" translate="yes" xml:space="preserve">
          <source>Different implementations of threads</source>
          <target state="translated">线程的不同实现</target>
        </trans-unit>
        <trans-unit id="e3379dfb99801372d7cddbcebddb248079f56470" translate="yes" xml:space="preserve">
          <source>Different low-level libraries use different formats to store the numbers. However, you should &lt;b&gt;NOT&lt;/b&gt; depend on the number having a specific format internally.</source>
          <target state="translated">不同的低层库使用不同的格式来存储数字。然而，你应该&lt;b&gt;不&lt;/b&gt;依赖于内部具有特定格式的数字。</target>
        </trans-unit>
        <trans-unit id="968ef79ccdd769ce74761479fe855c0adf257d6a" translate="yes" xml:space="preserve">
          <source>Different packages may implement different levels of debug but a non-zero value results in copies of all commands and responses also being sent to STDERR.</source>
          <target state="translated">不同的软件包可能会实现不同级别的调试,但一个非零值会导致所有命令和响应的副本也被发送到STDERR。</target>
        </trans-unit>
        <trans-unit id="8f55cf4436cb1eaf5bfcf390f661558255ea8243" translate="yes" xml:space="preserve">
          <source>Differing widths can cause truncation even between platforms of equal endianness. The platform of shorter width loses the upper parts of the number. There is no good solution for this problem except to avoid transferring or storing raw binary numbers.</source>
          <target state="translated">宽度不同会导致截断,即使是在等宽的平台之间。宽度较短的平台会丢失数字的上半部分。除了避免传输或存储原始二进制数外,没有很好的解决办法。</target>
        </trans-unit>
        <trans-unit id="248216e8bd5493fa776c21a71aab73557a333ad5" translate="yes" xml:space="preserve">
          <source>Dig into a bunch of modules to see how they're written. I'd suggest starting with &lt;a href=&quot;text/tabs&quot;&gt;Text::Tabs&lt;/a&gt;, since it's in the standard library and is nice and simple, and then looking at something a little more complex like &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;. For object oriented code, &lt;code&gt;WWW::Mechanize&lt;/code&gt; or the &lt;code&gt;Email::*&lt;/code&gt; modules provide some good examples.</source>
          <target state="translated">挖掘一堆模块，看看它们是如何编写的。我建议从&lt;a href=&quot;text/tabs&quot;&gt;Text :: Tabs开始&lt;/a&gt;，因为它在标准库中并且很简单，然后再看一些更复杂的东西，例如&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;。对于面向对象的代码， &lt;code&gt;WWW::Mechanize&lt;/code&gt; 或 &lt;code&gt;Email::*&lt;/code&gt; 模块提供了一些很好的示例。</target>
        </trans-unit>
        <trans-unit id="47fdd58bee4dc86df2b978107102a22b9c44345b" translate="yes" xml:space="preserve">
          <source>Digest</source>
          <target state="translated">Digest</target>
        </trans-unit>
        <trans-unit id="3bd067b7b9ba0e3842954b342b6e04b9508a77ac" translate="yes" xml:space="preserve">
          <source>Digest - Modules that calculate message digests</source>
          <target state="translated">Digest-计算信息摘要的模块。</target>
        </trans-unit>
        <trans-unit id="4c9cbdb7c115f81acd2c0edba69fb8ccce5eb45e" translate="yes" xml:space="preserve">
          <source>Digest base class</source>
          <target state="translated">文摘基类</target>
        </trans-unit>
        <trans-unit id="3cd23511cf79299d4bb6923e10fe169a355c096e" translate="yes" xml:space="preserve">
          <source>Digest implementations might want to inherit from this class to get this implementations of the alternative</source>
          <target state="translated">Digest的实现可能想要从这个类中继承,以获得这个实现的替代性的</target>
        </trans-unit>
        <trans-unit id="f2dd6f444a52ab6eb8232c6d9cf3d9b6b63eeb3b" translate="yes" xml:space="preserve">
          <source>Digest speed</source>
          <target state="translated">消化速度</target>
        </trans-unit>
        <trans-unit id="3263622a2f40559c02778432d6fee146399b6225" translate="yes" xml:space="preserve">
          <source>Digest::MD5</source>
          <target state="translated">Digest::MD5</target>
        </trans-unit>
        <trans-unit id="cc981cf57197ab4f6949f081dbfc7ac803760c7a" translate="yes" xml:space="preserve">
          <source>Digest::MD5 - Perl interface to the MD5 Algorithm</source>
          <target state="translated">Digest::MD5-MD5算法的Perl接口。</target>
        </trans-unit>
        <trans-unit id="10a5bb250c6cf1bbf42816d48c87400d9e093658" translate="yes" xml:space="preserve">
          <source>Digest::SHA</source>
          <target state="translated">Digest::SHA</target>
        </trans-unit>
        <trans-unit id="b4c92820a2ed37105ded93f12e77864cbec95f5b" translate="yes" xml:space="preserve">
          <source>Digest::SHA - Perl extension for SHA-1/224/256/384/512</source>
          <target state="translated">Digest::SHA-SHA-1/224/256/384/512的Perl扩展。</target>
        </trans-unit>
        <trans-unit id="af0465342315c6f4795df27a00078fb3582cb96c" translate="yes" xml:space="preserve">
          <source>Digest::SHA is a complete implementation of the NIST Secure Hash Standard. It gives Perl programmers a convenient way to calculate SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, and SHA-512/256 message digests. The module can handle all types of input, including partial-byte data.</source>
          <target state="translated">Digest::SHA是NIST安全散列标准的完整实现。它为Perl程序员提供了一种计算SHA-1、SHA-224、SHA-256、SHA-384、SHA-512、SHA-512/224和SHA-512/256消息摘要的便捷方法。该模块可以处理所有类型的输入,包括部分字节数据。</target>
        </trans-unit>
        <trans-unit id="bac9dbc726cb5a61beb1d19b4dd6e34bff1be212" translate="yes" xml:space="preserve">
          <source>Digest::SHA is written in C for speed. If your platform lacks a C compiler, you can install the functionally equivalent (but much slower) &lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest::SHA::PurePerl&lt;/a&gt; module.</source>
          <target state="translated">Digest :: SHA是用C编写的，以提高速度。如果您的平台缺少C编译器，则可以安装功能等效（但速度较慢）的&lt;a href=&quot;http://search.cpan.org/perldoc/Digest::SHA::PurePerl&quot;&gt;Digest :: SHA :: PurePerl&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="cfe5335cdbe39b8c32cfd3452cb43174a1ee9bb2" translate="yes" xml:space="preserve">
          <source>Digest::base</source>
          <target state="translated">Digest::base</target>
        </trans-unit>
        <trans-unit id="4bbbfedd2eb308dc398c540fc645898c082db6ea" translate="yes" xml:space="preserve">
          <source>Digest::base - Digest base class</source>
          <target state="translated">Digest::base-Digest基类。</target>
        </trans-unit>
        <trans-unit id="e1e35cd383e349a46e8ddfc8d07b7e38dc9e4a97" translate="yes" xml:space="preserve">
          <source>Digest::file</source>
          <target state="translated">Digest::file</target>
        </trans-unit>
        <trans-unit id="b818bfd43f1dc832b02e92b31d19ae9f904b4bd8" translate="yes" xml:space="preserve">
          <source>Digest::file - Calculate digests of files</source>
          <target state="translated">Digest::file-计算文件的摘要。</target>
        </trans-unit>
        <trans-unit id="2260ce49306460c8a2ef501939f29ad6ddd4e934" translate="yes" xml:space="preserve">
          <source>Digits</source>
          <target state="translated">Digits</target>
        </trans-unit>
        <trans-unit id="392f94d8c0ee92db7ab40a881f035b7ef8b3746d" translate="yes" xml:space="preserve">
          <source>DirHandle</source>
          <target state="translated">DirHandle</target>
        </trans-unit>
        <trans-unit id="aef108ac2030e9cea15c6f1ceb48f01986539dc6" translate="yes" xml:space="preserve">
          <source>DirHandle - supply object methods for directory handles</source>
          <target state="translated">DirHandle-为目录句柄提供对象方法。</target>
        </trans-unit>
        <trans-unit id="a91d0156df1ec1e83f412872b05e19d16ad2c59a" translate="yes" xml:space="preserve">
          <source>Direct pointer to the end of the chunk of text currently being lexed, the end of the lexer buffer. This is equal to &lt;code&gt;SvPVX(PL_parser-&amp;gt;linestr)
+ SvCUR(PL_parser-&amp;gt;linestr)&lt;/code&gt; . A &lt;code&gt;NUL&lt;/code&gt; character (zero octet) is always located at the end of the buffer, and does not count as part of the buffer's contents.</source>
          <target state="translated">直接指针指向当前正在被词法化的文本块的末尾，即词法分析器缓冲区的末尾。这等于 &lt;code&gt;SvPVX(PL_parser-&amp;gt;linestr) + SvCUR(PL_parser-&amp;gt;linestr)&lt;/code&gt; 。甲 &lt;code&gt;NUL&lt;/code&gt; 字符（零个八位字节）总是位于该缓冲区的末尾，并且不计入的缓冲区的内容的一部分。</target>
        </trans-unit>
        <trans-unit id="e2d9e8785d5c2cebf71e5748cc2d6f34072adbf8" translate="yes" xml:space="preserve">
          <source>Direct questions, comments, and the unlikely bug report (ahem) direct comments toward:</source>
          <target state="translated">直接提问、评论,不可能的bug报告(咳咳)直接评论向。</target>
        </trans-unit>
        <trans-unit id="8a2fa68d6fded8ba99af776dc79ad66973228a51" translate="yes" xml:space="preserve">
          <source>Direction constants for shutdown().</source>
          <target state="translated">shutdown()的方向常数。</target>
        </trans-unit>
        <trans-unit id="ffa4d14a55fc893b2ab2feb24f1bb9f16a27d9ef" translate="yes" xml:space="preserve">
          <source>Directions for building and installing Perl 5 can be found in the file</source>
          <target state="translated">构建和安装Perl 5的说明可以在文件</target>
        </trans-unit>
        <trans-unit id="51f9bdfd8404ef77fb1c128863bdee0a96774dbf" translate="yes" xml:space="preserve">
          <source>Directories are ignored, an appropriate warning message is printed.</source>
          <target state="translated">目录被忽略,会打印出相应的警告信息。</target>
        </trans-unit>
        <trans-unit id="d9839139cdba0a7db66d992a8c07d9dc5203a709" translate="yes" xml:space="preserve">
          <source>Directories specified by &lt;b&gt;-I&lt;/b&gt; are prepended to the search path for modules (&lt;code&gt;@INC&lt;/code&gt; ).</source>
          <target state="translated">&lt;b&gt;-I&lt;/b&gt;指定的目录位于模块（ &lt;code&gt;@INC&lt;/code&gt; ）的搜索路径之前。</target>
        </trans-unit>
        <trans-unit id="695ad0d98ef4334944f61b185dd4cedab03431f6" translate="yes" xml:space="preserve">
          <source>Directory containing the Perl library to use.</source>
          <target state="translated">包含要使用的Perl库的目录。</target>
        </trans-unit>
        <trans-unit id="95a5114dd29380dd2a8b633c45e0a67842ace3e1" translate="yes" xml:space="preserve">
          <source>Directory containing the Perl source code (use of this should be avoided, it may be undefined)</source>
          <target state="translated">包含Perl源代码的目录(应避免使用该目录,因为它可能未被定义)</target>
        </trans-unit>
        <trans-unit id="49814c07ff871d1c05234bf7b576b8bfa6483482" translate="yes" xml:space="preserve">
          <source>Directory handles may also support PerlIO layers in the future.</source>
          <target state="translated">目录句柄将来也可能支持PerlIO层。</target>
        </trans-unit>
        <trans-unit id="09979766f57286773702fe196a375f672c98b714" translate="yes" xml:space="preserve">
          <source>Directory must be removed by the caller.</source>
          <target state="translated">目录必须由呼叫者删除。</target>
        </trans-unit>
        <trans-unit id="e9f3ae68dab67380725d57ac9230f0a6c7e277d2" translate="yes" xml:space="preserve">
          <source>Directory removal</source>
          <target state="translated">目录删除</target>
        </trans-unit>
        <trans-unit id="446909c0385bc8ceaa4d872dd39cb651160d24b1" translate="yes" xml:space="preserve">
          <source>Directory to hold the man pages at 'make' time</source>
          <target state="translated">在 &quot;制作 &quot;时保存人页的目录。</target>
        </trans-unit>
        <trans-unit id="6951835d54be6094b23c719fecd95aa744851441" translate="yes" xml:space="preserve">
          <source>Directory to install binary files (e.g. tkperl) into if INSTALLDIRS=perl.</source>
          <target state="translated">如果INSTALLDIRS=perl,则安装二进制文件(例如tkperl)的目录。</target>
        </trans-unit>
        <trans-unit id="f55462ba8ed88c62d4efa472f0b3d16ca9cba3f9" translate="yes" xml:space="preserve">
          <source>Directory to put real binary files during 'make'. These will be copied to INSTALLBIN during 'make install'</source>
          <target state="translated">目录,以便在'make'时放置真正的二进制文件。这些文件将在'make install'时被复制到INSTALLBIN中。</target>
        </trans-unit>
        <trans-unit id="071097b28577ccaebcb95a281a66ed180c8224bf" translate="yes" xml:space="preserve">
          <source>Directory under which core modules are to be installed.</source>
          <target state="translated">安装核心模块的目录。</target>
        </trans-unit>
        <trans-unit id="a1829f4e2522a379a57e6dfeb7e4bf98545786dd" translate="yes" xml:space="preserve">
          <source>Directory where executable files should be installed during 'make'. Defaults to &quot;./blib/script&quot;, just to have a dummy location during testing. make install will copy the files in INST_SCRIPT to INSTALLSCRIPT.</source>
          <target state="translated">在'make'过程中应安装可执行文件的目录。默认为&quot;./blib/script&quot;,只是为了在测试过程中提供一个虚拟的位置。 make install 将把 INST_SCRIPT 中的文件复制到 INSTALLSCRIPT 中。</target>
        </trans-unit>
        <trans-unit id="2bd8b42725452a5bb1746b479050ce94dd36efe4" translate="yes" xml:space="preserve">
          <source>Directory where the build process takes place?</source>
          <target state="translated">构建过程发生的目录?</target>
        </trans-unit>
        <trans-unit id="78138bb545451a59f614c602f7ae3ba02571d724" translate="yes" xml:space="preserve">
          <source>Directory where to store default options/environment/dialogs for building modules that need some customization?</source>
          <target state="translated">存储默认选项/环境/对话框的目录,用于构建需要一些定制的模块?</target>
        </trans-unit>
        <trans-unit id="71663d8624a61b44d95ba8a53379fea18cf31f0c" translate="yes" xml:space="preserve">
          <source>Directory where we put library files of this extension while building it.</source>
          <target state="translated">我们在建立这个扩展名的库文件的目录。</target>
        </trans-unit>
        <trans-unit id="008aa84379adaa3dd9f1114985629c6f39ced51e" translate="yes" xml:space="preserve">
          <source>Directory, or more exact the &lt;code&gt;@INC&lt;/code&gt; entry, where the module was loaded from.</source>
          <target state="translated">目录，或更确切的说是 &lt;code&gt;@INC&lt;/code&gt; 条目，从中加载模块。</target>
        </trans-unit>
        <trans-unit id="5969fa73eaa43f73a5289188c026ff6a45c76d37" translate="yes" xml:space="preserve">
          <source>Directory.</source>
          <target state="translated">Directory.</target>
        </trans-unit>
        <trans-unit id="7b77fba35f95b8f8ec9c281444e53fe94ce4da2b" translate="yes" xml:space="preserve">
          <source>Directs output to &lt;code&gt;FILENAME&lt;/code&gt; instead of standard output.</source>
          <target state="translated">将输出定向到 &lt;code&gt;FILENAME&lt;/code&gt; 而不是标准输出。</target>
        </trans-unit>
        <trans-unit id="f9e08e65dda5f2824f9fa498ff452471e29c1363" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; , and the POSIX classes from working correctly on Unicode either in this scope, or in just one regex.</source>
          <target state="translated">在此范围内或仅在一个正则表达式中，禁止 &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\d&lt;/code&gt; 和POSIX类在Unicode上正常工作。</target>
        </trans-unit>
        <trans-unit id="817740799f0d65e523f96e31146ff1b9a88ee16c" translate="yes" xml:space="preserve">
          <source>Disable caching of timings for the null loop. This will force Benchmark to recalculate these timings for each new piece of code timed.</source>
          <target state="translated">禁用null循环的定时缓存,这将迫使Benchmark重新计算每段新代码的定时。这将迫使Benchmark重新计算每一段新代码的定时。</target>
        </trans-unit>
        <trans-unit id="c0a292f0da006ba870af4c1d4b16af058ca27ce9" translate="yes" xml:space="preserve">
          <source>Disable executing</source>
          <target state="translated">禁用执行</target>
        </trans-unit>
        <trans-unit id="0f85246ff2faf69d64165e4047fc800c58a2cc74" translate="yes" xml:space="preserve">
          <source>Disable named opcodes when compiling perl code</source>
          <target state="translated">编译perl代码时禁用命名的操作码。</target>
        </trans-unit>
        <trans-unit id="97739e76ec287fa7ebbb95b29230f3316099f8ec" translate="yes" xml:space="preserve">
          <source>Disable prototype checking. With this option, all function calls are deparsed as if no prototype was defined for them. In other words,</source>
          <target state="translated">禁用原型检查。使用这个选项,所有的函数调用都会被当作没有定义原型的情况下被deparsed。换句话说</target>
        </trans-unit>
        <trans-unit id="0756161fd02ffa6bd8c4dec248d5a916201550e6" translate="yes" xml:space="preserve">
          <source>Disable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations.</source>
          <target state="translated">禁用对 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT_LIST&lt;/code&gt; 和 &lt;code&gt;INOUT_LIST&lt;/code&gt; 声明的识别。</target>
        </trans-unit>
        <trans-unit id="ac791b2af5b20a7fb1078462c2f338c31498cb30" translate="yes" xml:space="preserve">
          <source>Disable recognition of ANSI-like descriptions of function signature.</source>
          <target state="translated">禁止识别类似ANSI的函数签名描述。</target>
        </trans-unit>
        <trans-unit id="bbc86eb1194adefaf0a1a0eedb3b0d823e6663f7" translate="yes" xml:space="preserve">
          <source>Disable the breakpoint so it won't stop the execution of the program. Breakpoints are enabled by default and can be re-enabled using the &lt;code&gt;enable&lt;/code&gt; command.</source>
          <target state="translated">禁用断点，这样它就不会停止程序的执行。断点默认为启用状态，可以使用 &lt;code&gt;enable&lt;/code&gt; 命令重新启用。</target>
        </trans-unit>
        <trans-unit id="18ee854e40ed47f3fd86995a561be7f6fe2416aa" translate="yes" xml:space="preserve">
          <source>Disables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">禁用所有警告，无论 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 或 &lt;code&gt;$^W&lt;/code&gt; 。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a78ebbaecc11dc8858ab9929654aabcca4fd0610" translate="yes" xml:space="preserve">
          <source>Disables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">禁用某些优化。目前唯一受影响的优化是使用了</target>
        </trans-unit>
        <trans-unit id="3eddfd0331ebc78a06dd4671eddadcbb2519e22b" translate="yes" xml:space="preserve">
          <source>Disables only specific overloads in the current lexical scope.</source>
          <target state="translated">仅禁用当前词法范围内的特定过载。</target>
        </trans-unit>
        <trans-unit id="27215af8e0aec9a7df486127f2e81d5c3743979c" translate="yes" xml:space="preserve">
          <source>Disables overloading entirely in the current lexical scope.</source>
          <target state="translated">在当前词法范围内完全禁用重载。</target>
        </trans-unit>
        <trans-unit id="0596b396338d526562980a39b883df16ed14f799" translate="yes" xml:space="preserve">
          <source>Disables the run time test that determines if the object file (derived from the &lt;code&gt;.xs&lt;/code&gt; file) and the &lt;code&gt;.pm&lt;/code&gt; files have the same version number.</source>
          <target state="translated">禁用运行时测试，该测试确定对象文件（从 &lt;code&gt;.xs&lt;/code&gt; 文件派生）和 &lt;code&gt;.pm&lt;/code&gt; 文件是否具有相同的版本号。</target>
        </trans-unit>
        <trans-unit id="0445bc1eebafe74da8f782bf383cb56524959c04" translate="yes" xml:space="preserve">
          <source>Disabling an extension</source>
          <target state="translated">停用分机</target>
        </trans-unit>
        <trans-unit id="3b823ca5f6c5e18ee6590dd73a0071ccec8a63ba" translate="yes" xml:space="preserve">
          <source>Disabling or changing &amp;lt;no&amp;gt; behaviour</source>
          <target state="translated">禁用或更改&amp;lt;no&amp;gt;行为</target>
        </trans-unit>
        <trans-unit id="5aad62ff519a93497721c0514d33f638c9796188" translate="yes" xml:space="preserve">
          <source>Disabling or changing &lt;no&gt; behaviour&lt;/no&gt;</source>
          <target state="translated">禁用或更改 &lt;no&gt; 行为&lt;/no&gt;</target>
        </trans-unit>
        <trans-unit id="ec79b0e24c53783c0d5b0048b7cc030c1e7e99b1" translate="yes" xml:space="preserve">
          <source>Disabling these ops is a</source>
          <target state="translated">停用这些操作是一个</target>
        </trans-unit>
        <trans-unit id="c32542195526d9e4b30393cfd896527d786a1f51" translate="yes" xml:space="preserve">
          <source>Disambiguation rules between old-style octal escapes and backreferences</source>
          <target state="translated">旧式八字形转义和回文之间的歧义规则。</target>
        </trans-unit>
        <trans-unit id="51495d55ca3fbe873cb079ee818ab001144b1050" translate="yes" xml:space="preserve">
          <source>Discard the cop hints hash</source>
          <target state="translated">丢弃警察提示哈希</target>
        </trans-unit>
        <trans-unit id="1ce92351c84d19187a09db0e7cf0340daa95578b" translate="yes" xml:space="preserve">
          <source>Discards text about to be lexed, from &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; up to</source>
          <target state="translated">从&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;一直到</target>
        </trans-unit>
        <trans-unit id="d6266f69af30213e087e1c977c0114fa6d50dbc1" translate="yes" xml:space="preserve">
          <source>Discards the buffering of the standard output and standard errors for return by run_forked(). With this option you have to use the std*_handlers to read what the command outputs. Useful for commands that send a lot of output.</source>
          <target state="translated">放弃标准输出和标准错误的缓冲,以备 run_forked()返回。使用这个选项,你必须使用std*_handlers来读取命令的输出内容。对于发送大量输出的命令很有用。</target>
        </trans-unit>
        <trans-unit id="a0327deb8b4ad4a89521ac79b1906db45d49787c" translate="yes" xml:space="preserve">
          <source>Discards the first part of the &lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt; buffer, up to</source>
          <target state="translated">丢弃&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;缓冲区的第一部分，直到</target>
        </trans-unit>
        <trans-unit id="06279c3d633238719d4311a1e19a71a158169a40" translate="yes" xml:space="preserve">
          <source>Discouraged comparison functions</source>
          <target state="translated">不鼓励的比较功能</target>
        </trans-unit>
        <trans-unit id="a1e132aa8b84b9d862e794881468080b3307770a" translate="yes" xml:space="preserve">
          <source>Discovering the usefulness of the &quot;command.com&quot; shell on Windows 9x is left as an exercise to the reader :)</source>
          <target state="translated">在Windows 9x上发现 &quot;command.com &quot;shell的有用性,就留给读者去做吧 :)</target>
        </trans-unit>
        <trans-unit id="5e5164803920ddcf3cce5890834f1bdb27f23ebc" translate="yes" xml:space="preserve">
          <source>Discussed briefly in &lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;Formatting Codes in perlpod&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlpod#Formatting-Codes&quot;&gt;在Perlpod的格式化代码中&lt;/a&gt;简要讨论。</target>
        </trans-unit>
        <trans-unit id="9b63dec48ea2c8f9c76b3edf144110430c933947" translate="yes" xml:space="preserve">
          <source>Display all (or some) lexical variables (mnemonic: &lt;code&gt;mY&lt;/code&gt; variables) in the current scope or</source>
          <target state="translated">显示当前作用域中的所有（或一些）词法变量（助记符： &lt;code&gt;mY&lt;/code&gt; 变量）或</target>
        </trans-unit>
        <trans-unit id="4d6a8893695a223720d1351409d3d6fa85617a70" translate="yes" xml:space="preserve">
          <source>Display all (or some) variables in package (defaulting to &lt;code&gt;main&lt;/code&gt; ) using a data pretty-printer (hashes show their keys and values so you see what's what, control characters are made printable, etc.). Make sure you don't put the type specifier (like &lt;code&gt;$&lt;/code&gt; ) there, just the symbol names, like this:</source>
          <target state="translated">使用数据漂亮打印机显示包中的所有（或某些）变量（默认为 &lt;code&gt;main&lt;/code&gt; ）（哈希显示其键和值，以便您查看内容，控制字符可打印等）。确保不要在其中放置类型说明符（例如 &lt;code&gt;$&lt;/code&gt; ），而只是在其中放置符号名称，如下所示：</target>
        </trans-unit>
        <trans-unit id="b044b119358695832cdfad98824f0069cebfc548" translate="yes" xml:space="preserve">
          <source>Display all loaded modules and their versions.</source>
          <target state="translated">显示所有加载的模块及其版本。</target>
        </trans-unit>
        <trans-unit id="be430952d1c69c4ef4bad908fd0595a0f079554c" translate="yes" xml:space="preserve">
          <source>Display all options.</source>
          <target state="translated">显示所有选项。</target>
        </trans-unit>
        <trans-unit id="27dde643a5c3a4ac6eac908a83f780f2958f01e6" translate="yes" xml:space="preserve">
          <source>Display and Dump functions</source>
          <target state="translated">显示和转储功能</target>
        </trans-unit>
        <trans-unit id="b1f4cfc5d23e7e9d95f619a69bc6c81069e91cc2" translate="yes" xml:space="preserve">
          <source>Display docs using plain &lt;b&gt;t&lt;/b&gt;ext converter, instead of nroff. This may be faster, but it probably won't look as nice.</source>
          <target state="translated">显示使用普通的文档&lt;b&gt;吨&lt;/b&gt;代替的nroff分机转换器。这可能更快，但看起来可能不太好。</target>
        </trans-unit>
        <trans-unit id="1261f72eada707fc4383acb7f8be5b3e61a1c948" translate="yes" xml:space="preserve">
          <source>Display last n commands. Only commands longer than one character are listed. If</source>
          <target state="translated">显示最后n条命令。只列出长于一个字符的命令。如果</target>
        </trans-unit>
        <trans-unit id="f40755e392f1a9eb6ccdf55b73455fd0fd00a49a" translate="yes" xml:space="preserve">
          <source>Display mostly harmless warning messages (default behaviour). But this is not the same as &quot;verbose&quot; mode.</source>
          <target state="translated">显示大部分无害的警告信息(默认行为)。但这与 &quot;verbose &quot;模式不同。</target>
        </trans-unit>
        <trans-unit id="7c1e20933a7ba1da896199ecdf785fc25a2b5f9c" translate="yes" xml:space="preserve">
          <source>Display on&lt;b&gt;l&lt;/b&gt;y the file name of the module found.</source>
          <target state="translated">显示上&lt;b&gt;升&lt;/b&gt; y中的模块的文件名中。</target>
        </trans-unit>
        <trans-unit id="93569833439ae0502fb8e64a1c4e865ec5d04cb7" translate="yes" xml:space="preserve">
          <source>Display only the given routine and its descendants in the profile.</source>
          <target state="translated">在配置文件中只显示给定的例程和它的子代。</target>
        </trans-unit>
        <trans-unit id="cb765f562c6dc517c9adc9d4c794809e94e26d02" translate="yes" xml:space="preserve">
          <source>Display progress messages.</source>
          <target state="translated">显示进度信息。</target>
        </trans-unit>
        <trans-unit id="465a2527c50c93058895db46b538af503815f183" translate="yes" xml:space="preserve">
          <source>Display progress messages. By default, they won't be displayed.</source>
          <target state="translated">显示进度信息。默认情况下,不显示进度信息。</target>
        </trans-unit>
        <trans-unit id="d2e6e56a1e2419c84dc382818c82354f4cd202e5" translate="yes" xml:space="preserve">
          <source>Display routines that have zero usage.</source>
          <target state="translated">显示使用率为零的例程。</target>
        </trans-unit>
        <trans-unit id="a772b3b9f6d01bc9a870a18de9715b85da4f33c7" translate="yes" xml:space="preserve">
          <source>Display the entire module: both code and unformatted pod documentation. This may be useful if the docs don't explain a function in the detail you need, and you'd like to inspect the code directly; perldoc will find the file for you and simply hand it off for display.</source>
          <target state="translated">显示整个模块:包括代码和未格式化的 pod 文档。如果文档没有详细解释你所需要的功能,而你又想直接检查代码,这可能会很有用;perldoc会帮你找到文件,然后简单地交给你来显示。</target>
        </trans-unit>
        <trans-unit id="d3972efaa9a06280feba956085fc524f4b645f44" translate="yes" xml:space="preserve">
          <source>Display the version numbers of the loaded &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and the current Perl.</source>
          <target state="translated">显示已加载的&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;和当前Perl 的版本号。</target>
        </trans-unit>
        <trans-unit id="3b39d5abe0218469782f16f6cb4d35f226bb7201" translate="yes" xml:space="preserve">
          <source>Displaying Unicode As Text</source>
          <target state="translated">将Unicode显示为文本</target>
        </trans-unit>
        <trans-unit id="a65d13adc77fe56d8d077ba085d484794c846340" translate="yes" xml:space="preserve">
          <source>Displays a short help</source>
          <target state="translated">显示简短的帮助</target>
        </trans-unit>
        <trans-unit id="6782149c8f0e6f7b18c7f34e52e8afce81669558" translate="yes" xml:space="preserve">
          <source>Displays a warning that an old packlist file was found. Reads the filename from @ARGV.</source>
          <target state="translated">显示发现旧的打包列表文件的警告。从@ARGV读取文件名。</target>
        </trans-unit>
        <trans-unit id="d1f928489a20ced31a182ea00abdcc0e1f7a238c" translate="yes" xml:space="preserve">
          <source>Displays the current value(s) for this config variable. Without KEY, displays all subcommands and config variables.</source>
          <target state="translated">显示该配置变量的当前值。不显示KEY,显示所有子命令和配置变量。</target>
        </trans-unit>
        <trans-unit id="0bcd71b641eec7cadbed7fed072672f0582b39a0" translate="yes" xml:space="preserve">
          <source>Displays the usage message.</source>
          <target state="translated">显示使用信息。</target>
        </trans-unit>
        <trans-unit id="5298b75576f02dfd7e64f80d327144afcfdb191f" translate="yes" xml:space="preserve">
          <source>Displays the version of perldoc you're running.</source>
          <target state="translated">显示你正在运行的perldoc的版本。</target>
        </trans-unit>
        <trans-unit id="dcdc8e69179a75bcf860bec40f205ba043a0369b" translate="yes" xml:space="preserve">
          <source>Distantly based on LWP::Base64 written by Martijn Koster &amp;lt;m.koster@nexor.co.uk&amp;gt; and Joerg Reichelt &amp;lt;j.reichelt@nexor.co.uk&amp;gt; and code posted to comp.lang.perl &amp;lt;3pd2lp$6gf@wsinti07.win.tue.nl&amp;gt; by Hans Mulder &amp;lt;hansm@wsinti07.win.tue.nl&amp;gt;</source>
          <target state="translated">完全基于Martijn Koster &amp;lt;m.koster@nexor.co.uk&amp;gt;和Joerg Reichelt &amp;lt;j.reichelt@nexor.co.uk&amp;gt;编写的LWP :: Base64并将代码发布到comp.lang.perl &amp;lt;3pd2lp $ 6gf @汉斯&amp;middot;穆尔德（Hans Mulder）的wsinti07.win.tue.nl&amp;gt; &amp;lt;hansm@wsinti07.win.tue.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9483453ac3c647a5e6dee71efaa493b08294daa7" translate="yes" xml:space="preserve">
          <source>Distribution Conditions</source>
          <target state="translated">分配条件</target>
        </trans-unit>
        <trans-unit id="955afbb21394efe51b98a6970c7c1927cbe40fd4" translate="yes" xml:space="preserve">
          <source>Distribution Support</source>
          <target state="translated">分销支持</target>
        </trans-unit>
        <trans-unit id="41c838f5416206dabaa8d6ac86a72e962e587d49" translate="yes" xml:space="preserve">
          <source>Distribution objects are normally distributions from the CPAN, but there is a slightly degenerate case for Distribution objects, too, of projects held on the local disk. These distribution objects have the same name as the local directory and end with a dot. A dot by itself is also allowed for the current directory at the time CPAN.pm was used. All actions such as &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , and &lt;code&gt;install&lt;/code&gt; are applied directly to that directory. This gives the command &lt;code&gt;cpan .&lt;/code&gt; an interesting touch: while the normal mantra of installing a CPAN module without CPAN.pm is one of</source>
          <target state="translated">分发对象通常是来自CPAN的分发，但是对于本地磁盘上保存的项目，分发对象也存在一些退化的情况。这些分发对象的名称与本地目录相同，并以点号结尾。在使用CPAN.pm时，当前目录本身也可以使用点。所有操作（例如 &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;test&lt;/code&gt; 和 &lt;code&gt;install&lt;/code&gt; )都直接应用于该目录。这给出命令 &lt;code&gt;cpan .&lt;/code&gt; 有趣的一面：尽管没有CPAN.pm的CPAN模块的正常安装方法是</target>
        </trans-unit>
        <trans-unit id="381764d96f9c586b529fc1b74bf3dd86052ae745" translate="yes" xml:space="preserve">
          <source>Distributions on CPAN usually behave according to what we call the CPAN mantra. Or since the advent of Module::Build we should talk about two mantras:</source>
          <target state="translated">CPAN上的发行版通常会按照我们所说的CPAN咒语行事。或者说自从Module::Build出现后,我们应该谈谈两个咒语。</target>
        </trans-unit>
        <trans-unit id="c58180206bebfb6ee0df954b757a9830a178426b" translate="yes" xml:space="preserve">
          <source>Distroprefs</source>
          <target state="translated">Distroprefs</target>
        </trans-unit>
        <trans-unit id="7f01fb80f7dde34a76219740c5d0000d7751aa19" translate="yes" xml:space="preserve">
          <source>Ditto for stringifying large arrays:</source>
          <target state="translated">同理,对大型数组进行串联。</target>
        </trans-unit>
        <trans-unit id="8cd08c454640891385c7eeea6dddbb915e9a2b00" translate="yes" xml:space="preserve">
          <source>Ditto:</source>
          <target state="translated">Ditto:</target>
        </trans-unit>
        <trans-unit id="f2faddc4fbc208e1d7b96a4fcac1f5f9f8a3944b" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (i.e., without an argument) more than once per process. The internal state of the random number generator should contain more entropy than can be provided by any seed, so calling &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; again actually</source>
          <target state="translated">难道&lt;b&gt;不&lt;/b&gt;叫 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 函数（即不带参数）超过每一次的过程。随机数生成器的内部状态应包含比任何种子都可以提供的更多的熵，因此实际上再次调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6baf1cd7e0ea413825fb96a05b09305653a8842" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; (i.e., without an argument) more than once per process. The internal state of the random number generator should contain more entropy than can be provided by any seed, so calling &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; again actually</source>
          <target state="translated">难道&lt;b&gt;不&lt;/b&gt;叫 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 函数（即不带参数）超过每一次的过程。随机数生成器的内部状态应包含比任何种子都可以提供的更多的熵，因此实际上再次调用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8508e09e1cab910629d8f92dab302c9bc18cac38" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; export anything else by default without a good reason!</source>
          <target state="translated">难道&lt;b&gt;不是&lt;/b&gt;别的默认情况下没有一个很好的理由出口任何东西！</target>
        </trans-unit>
        <trans-unit id="2a361ce7ad694ec0575786e4a58744501e47d3dd" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; export method names!</source>
          <target state="translated">千万&lt;b&gt;不能&lt;/b&gt;导出方法名！</target>
        </trans-unit>
        <trans-unit id="825725dbe42c2936cefeada5723d97075e056f4d" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; use &lt;code&gt;/[A-Z]/&lt;/code&gt; unless you don't care about the current locale.</source>
          <target state="translated">千万&lt;b&gt;不能&lt;/b&gt;使用 &lt;code&gt;/[A-Z]/&lt;/code&gt; 除非你不关心当前的语言环境。</target>
        </trans-unit>
        <trans-unit id="18fe50d08f696cfe6f092de82e112424369b684e" translate="yes" xml:space="preserve">
          <source>Do &lt;b&gt;not&lt;/b&gt; use &lt;code&gt;/[a-z]/&lt;/code&gt; unless you don't care about the current locale.</source>
          <target state="translated">千万&lt;b&gt;不能&lt;/b&gt;使用 &lt;code&gt;/[a-z]/&lt;/code&gt; 除非你不关心当前的语言环境。</target>
        </trans-unit>
        <trans-unit id="4ce4e2d8b8b0faeef7d3ea74accd64d2ba130eb9" translate="yes" xml:space="preserve">
          <source>Do I always/never have to quote my strings or use semicolons and commas?</source>
          <target state="translated">我是否总是/不需要引用我的字符串或使用分号和逗号?</target>
        </trans-unit>
        <trans-unit id="07601d161d4355e711962a451be3c55fe86fbe5c" translate="yes" xml:space="preserve">
          <source>Do I need to recompile XS modules when there is a change in the C library?</source>
          <target state="translated">当C库发生变化时,我是否需要重新编译XS模块?</target>
        </trans-unit>
        <trans-unit id="8546c498c3dd38d7f1d8d67ef0863373cb431c32" translate="yes" xml:space="preserve">
          <source>Do NOT export anything else by default without a good reason!</source>
          <target state="translated">在没有充分理由的情况下,不要默认导出其他任何东西!</target>
        </trans-unit>
        <trans-unit id="88b10d4e2bda0943ded9669f6a8c9aebc17a12e8" translate="yes" xml:space="preserve">
          <source>Do NOT export method names!</source>
          <target state="translated">不要导出方法名!</target>
        </trans-unit>
        <trans-unit id="ed2715ba8e6286e3dce7c7be35eeaefa5a5cc3c5" translate="yes" xml:space="preserve">
          <source>Do case-insensitive pattern matching.</source>
          <target state="translated">进行不区分大小写的模式匹配。</target>
        </trans-unit>
        <trans-unit id="8d3df5a42cb6127acc1472a5755378b0af34defd" translate="yes" xml:space="preserve">
          <source>Do magic after a value is assigned to the SV. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">在将值分配给SV之后执行魔术。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cee9756153198a0ee3de2adeb5f31d39d574306f" translate="yes" xml:space="preserve">
          <source>Do magic before a value is retrieved from the SV. The type of SV must be &amp;gt;= SVt_PVMG. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">在从SV检索值之前做魔术。SV的类型必须&amp;gt; = SVt_PVMG。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fef68e8141e36a039846619d70d364b0a422b18f" translate="yes" xml:space="preserve">
          <source>Do not assume an operating system indicates a certain compiler.</source>
          <target state="translated">不要以为操作系统表示某一个编译器。</target>
        </trans-unit>
        <trans-unit id="4b3370a4321afc9f66c3f426894b720b8a225d1f" translate="yes" xml:space="preserve">
          <source>Do not assume anything about the ordering of the characters. The lowercase letters may come before or after the uppercase letters; the lowercase and uppercase may be interlaced so that both &quot;a&quot; and &quot;A&quot; come before &quot;b&quot;; the accented and other international characters may be interlaced so that &amp;auml; comes before &quot;b&quot;. &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; can be used to sort this all out.</source>
          <target state="translated">不要假设任何有关字符的顺序。小写字母可以在大写字母之前或之后；小写字母和大写字母可以交错排列，以使&amp;ldquo; a&amp;rdquo;和&amp;ldquo; A&amp;rdquo;都位于&amp;ldquo; b&amp;rdquo;之前；重音符号和其他国际字符可能会交织在一起，从而使&amp;auml;出现在&amp;ldquo; b&amp;rdquo;之前。&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;可以用来解决所有问题。</target>
        </trans-unit>
        <trans-unit id="dac7429f341d431a762410206ac5527a2c13dd2f" translate="yes" xml:space="preserve">
          <source>Do not assume that the alphabetic characters are encoded contiguously (in the numeric sense). There may be gaps. Special coding in Perl, however, guarantees that all subsets of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[A-Z]/&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[a-z]/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[0-9]/&lt;/a&gt;&lt;/code&gt; behave as expected. &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; behaves the same for these ranges. In patterns, any ranges specified with end points using the &lt;code&gt;\N{...}&lt;/code&gt; notations ensures character set portability, but it is a bug in Perl v5.22, that this isn't true of &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不要假定字母字符是连续编码的（在数字意义上）。可能存在差距。但是，Perl中的特殊编码可确保 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[A-Z]/&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[a-z]/&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[0-9]/&lt;/a&gt;&lt;/code&gt; 的所有子集都能正常工作。 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 在这些范围内的行为相同。在模式中，使用 &lt;code&gt;\N{...}&lt;/code&gt; 符号用端点指定的任何范围都可以确保字符集的可移植性，但这在Perl v5.22中是一个错误， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 并非如此。</target>
        </trans-unit>
        <trans-unit id="1f01c64ee23b1bfc4362dd512948a4c4fa009da9" translate="yes" xml:space="preserve">
          <source>Do not attempt navigation using these formulas.</source>
          <target state="translated">不要试图使用这些公式进行导航。</target>
        </trans-unit>
        <trans-unit id="ffd84d731582ea7d72196f877c4d6066a632e557" translate="yes" xml:space="preserve">
          <source>Do not attempt to use this class directly. It won't make sense. It's mainly here to ensure that we will be able to have pluggable grammars when TAP is expanded at some future date (plus, this stuff was really cluttering the parser).</source>
          <target state="translated">不要试图直接使用这个类。它不会有意义。在这里主要是为了确保当TAP在未来的某一天被扩展时,我们能够拥有可插拔的语法(另外,这个东西真的很杂乱的解析器)。</target>
        </trans-unit>
        <trans-unit id="a6238adeeaec74412446adc0c315e47aa64f6eff" translate="yes" xml:space="preserve">
          <source>Do not be fooled into thinking that &lt;code&gt;(SV *) 0&lt;/code&gt; is the same as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . Take this code:</source>
          <target state="translated">不要愚蠢地认为 &lt;code&gt;(SV *) 0&lt;/code&gt; 与 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 相同。采取以下代码：</target>
        </trans-unit>
        <trans-unit id="97a265c0f5840a121cb5af7015adcf66dbf43685" translate="yes" xml:space="preserve">
          <source>Do not consider &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; for authentication: it is not as secure as &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不要考虑使用 &lt;code&gt;&lt;a href=&quot;functions/getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; 进行身份验证：它不如 &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 安全。</target>
        </trans-unit>
        <trans-unit id="954cdfa947d07289fc8fa65c61c967074b46849c" translate="yes" xml:space="preserve">
          <source>Do not consider &lt;code&gt;&lt;a href=&quot;getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; for authentication: it is not as secure as &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">不要考虑使用 &lt;code&gt;&lt;a href=&quot;getlogin&quot;&gt;getlogin&lt;/a&gt;&lt;/code&gt; 进行身份验证：它不如 &lt;code&gt;&lt;a href=&quot;getpwuid&quot;&gt;getpwuid&lt;/a&gt;&lt;/code&gt; 安全。</target>
        </trans-unit>
        <trans-unit id="2ed5342da7dbe2644918b11220f17d8dfd65b045" translate="yes" xml:space="preserve">
          <source>Do not create header and footer blocks containing the text of the &quot;NAME&quot; section (default behaviour).</source>
          <target state="translated">不要创建包含 &quot;NAME &quot;部分文本的页眉和页脚块(默认行为)。</target>
        </trans-unit>
        <trans-unit id="de14526162a79000113ce8e06bb2051044d9251f" translate="yes" xml:space="preserve">
          <source>Do not declare variables using &quot;register&quot;. It may be counterproductive with modern compilers, and is deprecated in C++, under which the Perl source is regularly compiled.</source>
          <target state="translated">不要用 &quot;register &quot;来声明变量。对于现代编译器来说,这可能会适得其反,而且在C++中也不适用,因为在C++下,Perl的源代码经常被编译。</target>
        </trans-unit>
        <trans-unit id="ba5b70f1f2a742c5a3d1b2680eb5b21ac617899b" translate="yes" xml:space="preserve">
          <source>Do not display progress messages (default behaviour).</source>
          <target state="translated">不显示进度消息(默认行为)。</target>
        </trans-unit>
        <trans-unit id="1d7af785bc11d859051058972cf4b5ed10f4c0f8" translate="yes" xml:space="preserve">
          <source>Do not expect clock_nanosleep() to be exact down to one nanosecond. Getting even accuracy of one thousand nanoseconds is good.</source>
          <target state="translated">不要指望clock_nanosleep()能精确到一纳秒。能达到1000纳秒的精度就不错了。</target>
        </trans-unit>
        <trans-unit id="80ec845571b8ce066af485fa387b9e2c22cdbd4a" translate="yes" xml:space="preserve">
          <source>Do not expect nanosleep() to be exact down to one nanosecond. Getting even accuracy of one thousand nanoseconds is good.</source>
          <target state="translated">不要指望nanosleep()能精确到一纳秒。能达到一千纳秒的精度就不错了。</target>
        </trans-unit>
        <trans-unit id="338f71d7cfd94a546bf46d57c343edb97e29ec06" translate="yes" xml:space="preserve">
          <source>Do not expect usleep() to be exact down to one microsecond.</source>
          <target state="translated">不要指望usleep()能精确到一微秒。</target>
        </trans-unit>
        <trans-unit id="44e00d89042b21b82ae04db4fd6686e52864a5db" translate="yes" xml:space="preserve">
          <source>Do not forget the space before the trailing quote.</source>
          <target state="translated">不要忘记尾部引号前的空格。</target>
        </trans-unit>
        <trans-unit id="9d53664ee8f6d26a9c8d6d37ac533d0c8503e6c4" translate="yes" xml:space="preserve">
          <source>Do not forget to edit the documentation in the generated</source>
          <target state="translated">不要忘记在生成的</target>
        </trans-unit>
        <trans-unit id="b67a0bd0d26a82b3f8dae502cde36d9a68951db6" translate="yes" xml:space="preserve">
          <source>Do not generate an index at the top of the HTML file.</source>
          <target state="translated">不要在HTML文件的顶部生成一个索引。</target>
        </trans-unit>
        <trans-unit id="38ca653276acaef35211b0a7de47674e374897b5" translate="yes" xml:space="preserve">
          <source>Do not have two files or directories of the same name with different case, like</source>
          <target state="translated">不要有两个同名不同大小写的文件或目录,如</target>
        </trans-unit>
        <trans-unit id="4798c1787e0a45ddf70984856d2f84815abcefdc" translate="yes" xml:space="preserve">
          <source>Do not include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile.</source>
          <target state="translated">如果 infile 中有任何 POD 错误,不要在 outfile 中包含 &quot;POD ERRORS&quot; 部分。</target>
        </trans-unit>
        <trans-unit id="6ca27b97c73fed9f5b2e6cce84e318595e25670f" translate="yes" xml:space="preserve">
          <source>Do not introduce any modifiable globals, truly global or file static. They are bad form and complicate multithreading and other forms of concurrency. The right way is to introduce them as new interpreter variables, see</source>
          <target state="translated">不要引入任何可修改的globals,真正的全局或文件静态。它们是不好的形式,并且使多线程和其他形式的并发变得复杂。正确的方法是将它们作为新的解释器变量引入,参见</target>
        </trans-unit>
        <trans-unit id="54f5276ef8bc6c0a7b535c715233a2e4ff4dd5a6" translate="yes" xml:space="preserve">
          <source>Do not memoize a function that returns a data structure that is modified by its caller.</source>
          <target state="translated">不要记忆一个函数,该函数返回的数据结构会被其调用者修改。</target>
        </trans-unit>
        <trans-unit id="e822f96782fa84026c016723c451c6a59923a48c" translate="yes" xml:space="preserve">
          <source>Do not memoize a function whose behavior depends on program state other than its own arguments, such as global variables, the time of day, or file input. These functions will not produce correct results when memoized. For a particularly easy example:</source>
          <target state="translated">不要记忆那些行为取决于程序状态的函数,而不是它自己的参数,例如全局变量、时间或文件输入。当这些函数被备忘录化时,将不会产生正确的结果。对于一个特别简单的例子。</target>
        </trans-unit>
        <trans-unit id="cccff3ab93f1bd49939696cce81af2a0a2097134" translate="yes" xml:space="preserve">
          <source>Do not memoize a function with side effects.</source>
          <target state="translated">不要追忆有副作用的功能。</target>
        </trans-unit>
        <trans-unit id="6f726dd9ddd72becc842f9b1d89ed1bf585b4d7a" translate="yes" xml:space="preserve">
          <source>Do not memoize a very simple function.</source>
          <target state="translated">不要记住一个非常简单的功能。</target>
        </trans-unit>
        <trans-unit id="fd85d472df120b1759d38d84f5ed138af9b0de90" translate="yes" xml:space="preserve">
          <source>Do not mix national standard encodings and the corresponding vendor encodings.</source>
          <target state="translated">不要将国家标准编码和相应的厂商编码混用。</target>
        </trans-unit>
        <trans-unit id="f1f5b43293b4ad26b77bf89ae0381b7ae81019b9" translate="yes" xml:space="preserve">
          <source>Do not pass both this and --htmldir to pod2html; they are mutually exclusive.</source>
          <target state="translated">不要把这个和--htmldir都传给pod2html,它们是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="b60ea56f9acc75f558cf56cbb9626f5aa57e337f" translate="yes" xml:space="preserve">
          <source>Do not read more than &lt;code&gt;limit&lt;/code&gt; files. This is useful if you have very big archives, and are only interested in the first few files.</source>
          <target state="translated">读取的文件不要超过 &lt;code&gt;limit&lt;/code&gt; 文件。如果您有非常大的存档，并且仅对前几个文件感兴趣，这将很有用。</target>
        </trans-unit>
        <trans-unit id="8baaf0ce4e3be10a125ad22cfd7dc50cf9094c82" translate="yes" xml:space="preserve">
          <source>Do not recurse into subdirectories specified in podpath.</source>
          <target state="translated">不要递归到podpath中指定的子目录。</target>
        </trans-unit>
        <trans-unit id="63bb032139528a610599b19949f74327a9b3d07c" translate="yes" xml:space="preserve">
          <source>Do not suspend the calling process until a child process changes state but instead return immediately.</source>
          <target state="translated">不要暂停调用进程,直到子进程改变状态,而是立即返回。</target>
        </trans-unit>
        <trans-unit id="a0d9cf144653df2138cfdb4728cb23fd840b488d" translate="yes" xml:space="preserve">
          <source>Do not try to be clever to insert some operations in between switching libraries:</source>
          <target state="translated">不要试图自作聪明地在切换库之间插入一些操作。</target>
        </trans-unit>
        <trans-unit id="f892507590fee4ad20d4412e6f8474b573affb0c" translate="yes" xml:space="preserve">
          <source>Do not try to use Perl's malloc, this will lead into very mysterious errors (especially with -Duse64bitall).</source>
          <target state="translated">不要尝试使用Perl的malloc,这会导致非常神秘的错误(尤其是在使用-Duse64bitall时)。</target>
        </trans-unit>
        <trans-unit id="481206675cc8f49efb63fbf5922ecb2459573ace" translate="yes" xml:space="preserve">
          <source>Do not turn =head1 directives into links pointing to the top of the HTML file (default behaviour).</source>
          <target state="translated">不要把=head1指令变成指向HTML文件顶部的链接(默认行为)。</target>
        </trans-unit>
        <trans-unit id="baca6e9f8deaa5a05e4ab2ba4c839ab683b10546" translate="yes" xml:space="preserve">
          <source>Do not turn on the compiler optimization flag &quot;-O&quot;. There is a bug in either the optimizer or perl that causes perl to not work correctly when the optimizer is on.</source>
          <target state="translated">不要开启编译器优化标志&quot;-O&quot;。优化器或perl中存在一个bug,当优化器开启时,会导致perl不能正常工作。</target>
        </trans-unit>
        <trans-unit id="ee94e7e413fa452436aa9dabe06f090ccc39d625" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; to obtain the address of variable that's bound to go out of scope (and thereby freeing its memory) before you are done with using the memory at that address.</source>
          <target state="translated">在使用该地址的内存之前，请不要将 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;P&lt;/code&gt; 一起使用来获取必然超出范围的变量的地址（从而释放其内存）。</target>
        </trans-unit>
        <trans-unit id="04f9b0d0e8adfb1713c31734eee9cfdb17586771" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;Devel::PPPort&lt;/code&gt; : no portability to older version.</source>
          <target state="translated">不要使用 &lt;code&gt;Devel::PPPort&lt;/code&gt; ：不能移植到旧版本。</target>
        </trans-unit>
        <trans-unit id="498daddca0a46e6c4fa2a6956b5ad47910b93411" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;Exporter&lt;/code&gt; and/or export any symbol.</source>
          <target state="translated">请勿使用 &lt;code&gt;Exporter&lt;/code&gt; 和/或导出任何符号。</target>
        </trans-unit>
        <trans-unit id="ed6a2111bf29f957b88dbf31031d37b896f3ce10" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;SvGROW&lt;/code&gt; or &lt;code&gt;sv_grow&lt;/code&gt; directly on &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ; this function updates all of the lexer's variables that point directly into the buffer.</source>
          <target state="translated">不要使用 &lt;code&gt;SvGROW&lt;/code&gt; 或 &lt;code&gt;sv_grow&lt;/code&gt; 直接 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; ; 此函数更新直接指向缓冲区的所有词法分析器变量。</target>
        </trans-unit>
        <trans-unit id="e1a5c62a2aaf2f678ca9cf51949611595cacf102" translate="yes" xml:space="preserve">
          <source>Do not use NDBM_File or ODBM_File on FAT filesystem. They can be built on a FAT filesystem, but many tests will fail:</source>
          <target state="translated">不要在FAT文件系统上使用NDBM_File或ODBM_File。它们可以建立在FAT文件系统上,但是很多测试会失败。</target>
        </trans-unit>
        <trans-unit id="ae38cf9dd649500630593bae7198d4a9f398f12d" translate="yes" xml:space="preserve">
          <source>Do not use atoi()</source>
          <target state="translated">不要使用 atoi()</target>
        </trans-unit>
        <trans-unit id="753e9d05d3a5b0152e6076319f72132b8b3a599b" translate="yes" xml:space="preserve">
          <source>Do not use either the bare result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;N&quot;, 10, 20, 30, 40)&lt;/code&gt; or bare v-strings (such as &lt;code&gt;v10.20.30.40&lt;/code&gt; ) to represent IPv4 addresses: both forms just pack the four bytes into network order. That this would be equal to the C language &lt;code&gt;in_addr&lt;/code&gt; struct (which is what the socket code internally uses) is not guaranteed. To be portable use the routines of the &lt;code&gt;Socket&lt;/code&gt; extension, such as &lt;code&gt;inet_aton()&lt;/code&gt; , &lt;code&gt;inet_ntoa()&lt;/code&gt; , and &lt;code&gt;sockaddr_in()&lt;/code&gt; .</source>
          <target state="translated">不要使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;N&quot;, 10, 20, 30, 40)&lt;/code&gt; 的裸结果（&amp;ldquo; N&amp;rdquo;，10、20、30、40）或裸v字符串（例如 &lt;code&gt;v10.20.30.40&lt;/code&gt; ）来表示IPv4地址：两种形式都只将四个字节打包到网络中订购。不能保证它等于C语言 &lt;code&gt;in_addr&lt;/code&gt; 结构（套接字代码在内部使用的结构）。为了便于移植，请使用 &lt;code&gt;Socket&lt;/code&gt; 扩展的例程，例如 &lt;code&gt;inet_aton()&lt;/code&gt; ， &lt;code&gt;inet_ntoa()&lt;/code&gt; 和 &lt;code&gt;sockaddr_in()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88c49bf9327996053a0622ba64f5585438822ebb" translate="yes" xml:space="preserve">
          <source>Do not use gets()</source>
          <target state="translated">不要使用get()</target>
        </trans-unit>
        <trans-unit id="e05df4e656db7dd388d518939d40279c56ee1258" translate="yes" xml:space="preserve">
          <source>Do not use regexes. Use a module and forget about the regular expressions. The &lt;a href=&quot;http://search.cpan.org/perldoc/XML::LibXML&quot;&gt;XML::LibXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TokeParser&quot;&gt;HTML::TokeParser&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TreeBuilder&quot;&gt;HTML::TreeBuilder&lt;/a&gt; modules are good starts, although each namespace has other parsing modules specialized for certain tasks and different ways of doing it. Start at CPAN Search ( &lt;a href=&quot;http://metacpan.org/&quot;&gt;http://metacpan.org/&lt;/a&gt; ) and wonder at all the work people have done for you already! :)</source>
          <target state="translated">不要使用正则表达式。使用模块，而忽略正则表达式。的&lt;a href=&quot;http://search.cpan.org/perldoc/XML::LibXML&quot;&gt;XML ::的libxml&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TokeParser&quot;&gt;HTML :: TokeParser&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/HTML::TreeBuilder&quot;&gt;HTML :: TreeBuilder作为&lt;/a&gt;模块是好的开始，虽然每个命名空间都有专门针对某些任务而做的不同的方法解析其他模块。从CPAN搜索（&lt;a href=&quot;http://metacpan.org/&quot;&gt;http://metacpan.org/&lt;/a&gt;）开始，想知道人们已经为您完成的所有工作！ :)</target>
        </trans-unit>
        <trans-unit id="cce861955ad84aadd4244ab8f88800ca7035ea2a" translate="yes" xml:space="preserve">
          <source>Do not use something like &lt;code&gt;\b=head\d\b&lt;/code&gt; and expect it to match the beginning of a line. It can't, because for there to be a boundary before the non-word &quot;=&quot;, there must be a word character immediately previous. All plain &lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; boundary determinations look for word characters alone, not for non-word characters nor for string ends. It may help to understand how &amp;lt;\b&amp;gt; and &amp;lt;\B&amp;gt; work by equating them as follows:</source>
          <target state="translated">不要使用 &lt;code&gt;\b=head\d\b&lt;/code&gt; 类的东西，并且不要期望它与行的开头匹配。不能，因为在非单词&amp;ldquo; =&amp;rdquo;之前必须有一个边界，因此必须在紧前面的单词字符。所有普通的 &lt;code&gt;\b&lt;/code&gt; 和 &lt;code&gt;\B&lt;/code&gt; 边界确定仅查找单词字符，而不查找非单词字符或字符串结尾。将&amp;lt;\ b&amp;gt;和&amp;lt;\ B&amp;gt;等效为以下方法可能有助于理解它们：</target>
        </trans-unit>
        <trans-unit id="f1a735190dab11e5d0be16372e2f20beebf57de6" translate="yes" xml:space="preserve">
          <source>Do not use sprintf() or vsprintf()</source>
          <target state="translated">不要使用sprintf()或vsprintf()</target>
        </trans-unit>
        <trans-unit id="bd8826a15f100149be24539f62f1590d0529bde4" translate="yes" xml:space="preserve">
          <source>Do not use strcpy() or strcat() or strncpy() or strncat()</source>
          <target state="translated">不要使用 strcpy()或 strcat()或 strncpy()或 strncat()</target>
        </trans-unit>
        <trans-unit id="e845e1c460c616232a9c91d7dbd84468956485b4" translate="yes" xml:space="preserve">
          <source>Do not use strtol() or strtoul()</source>
          <target state="translated">不要使用strtol()或strtoul()</target>
        </trans-unit>
        <trans-unit id="0c29194c83ffb8c5f50d4977f6ee065d347bf4fe" translate="yes" xml:space="preserve">
          <source>Do not use tell() (or other buffered I/O operations) on a filehandle that has been manipulated by sysread(), syswrite(), or sysseek(). Those functions ignore the buffering, while tell() does not.</source>
          <target state="translated">不要在已经被sysread()、syswrite()或sysseek()操作过的文件柄上使用tell()(或其他缓冲的I/O操作)。这些函数会忽略缓冲,而tell()不会。</target>
        </trans-unit>
        <trans-unit id="3950da255e2df8ad19b4abdbb628393b5e27d661" translate="yes" xml:space="preserve">
          <source>Do not use the module &lt;code&gt;AutoLoader&lt;/code&gt; ; but keep the constant() function and &lt;code&gt;sub AUTOLOAD&lt;/code&gt; for constants.</source>
          <target state="translated">不要使用模块 &lt;code&gt;AutoLoader&lt;/code&gt; ; 但保留constant（）函数和 &lt;code&gt;sub AUTOLOAD&lt;/code&gt; 作为常量。</target>
        </trans-unit>
        <trans-unit id="f50e07201ab25152f3dfb27ad57d827f044d1f3b" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, as they are at times requesting conflicting actions and the consequence of ignoring this advice will be undefined to allow future improvements in the POSIX exit handling.</source>
          <target state="translated">不要使用编译 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; 与 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 启用，因为它们有时相互矛盾的要求行动，采纳这个建议的后果将是不确定的，允许在POSIX退出处理今后的改进。</target>
        </trans-unit>
        <trans-unit id="a4b31e073c7486c8b49c926ffd1a1a8bd9366cae" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;strict&lt;/code&gt; .</source>
          <target state="translated">不要使用 &lt;code&gt;strict&lt;/code&gt; 的编译指示。</target>
        </trans-unit>
        <trans-unit id="d6facf91ee978da40dfe9d3ea865ab1579d25d93" translate="yes" xml:space="preserve">
          <source>Do not use the pragma &lt;code&gt;warnings&lt;/code&gt; .</source>
          <target state="translated">不要使用编译 &lt;code&gt;warnings&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dee89e95287669bbd88a11a6aea3e7aa1e7bbfb6" translate="yes" xml:space="preserve">
          <source>Do not use this and --htmlroot in the same call to pod2html; they are mutually exclusive.</source>
          <target state="translated">不要在对pod2html的同一调用中使用这个和--htmlroot,它们是相互排斥的。</target>
        </trans-unit>
        <trans-unit id="3250376779b0f67e8134deb8086f1402809e9bc8" translate="yes" xml:space="preserve">
          <source>Do not use this as a separator between directories. Some operating systems use different separators between subdirectories as between directories and filenames (for example: VOLUME:[dir1.dir2]file on VMS).</source>
          <target state="translated">不要用这个作为目录之间的分隔符。有些操作系统在子目录之间使用不同的分隔符,就像在目录和文件名之间使用不同的分隔符一样(例如:VOLUME:[dir1.dir2]文件在VMS上)。</target>
        </trans-unit>
        <trans-unit id="164086a0ac238b7870e606cc1d29ce266a3011d7" translate="yes" xml:space="preserve">
          <source>Do not use this if relative links are desired: use --htmldir instead.</source>
          <target state="translated">如果需要相对链接,请不要使用该功能:使用--htmldir。</target>
        </trans-unit>
        <trans-unit id="3c5af5b31b181ed54cc1fca5572f9386a6984c19" translate="yes" xml:space="preserve">
          <source>Do not use this to run perl: &lt;code&gt;INCLUDE: perl |&lt;/code&gt; will run the perl that happens to be the first in your path and not necessarily the same perl that is used to run &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;a href=&quot;#The-INCLUDE_COMMAND%3a-Keyword&quot;&gt;The INCLUDE_COMMAND: Keyword&lt;/a&gt;.</source>
          <target state="translated">不要使用它来运行perl： &lt;code&gt;INCLUDE: perl |&lt;/code&gt; 将运行恰好是路径中第一个的perl，而不必运行 &lt;code&gt;xsubpp&lt;/code&gt; 所使用的perl 。请参阅&lt;a href=&quot;#The-INCLUDE_COMMAND%3a-Keyword&quot;&gt;INCLUDE_COMMAND：关键字&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89f8b5ad3c1702cca1a4d40affd9cb729f0e90f7" translate="yes" xml:space="preserve">
          <source>Do not use this.</source>
          <target state="translated">不要用这个。</target>
        </trans-unit>
        <trans-unit id="82165a1e97cf695c1ce626d1d090403bda43151a" translate="yes" xml:space="preserve">
          <source>Do not use tmpfile()</source>
          <target state="translated">不要使用tmpfile()</target>
        </trans-unit>
        <trans-unit id="67066fdeeb8477f689c49a4d9d531e1c38c3d6bc" translate="yes" xml:space="preserve">
          <source>Do not use with other Perl types such as HV, AV, SV, CV, because those objects will become corrupted by the pointer copy process.</source>
          <target state="translated">不要与其他Perl类型,如HV、AV、SV、CV一起使用,因为这些对象会被指针复制过程破坏。</target>
        </trans-unit>
        <trans-unit id="97d251c82a0422b70eb970d71730acc97d0587dc" translate="yes" xml:space="preserve">
          <source>Do not, however, be tempted to do this:</source>
          <target state="translated">但是,不要受到诱惑。</target>
        </trans-unit>
        <trans-unit id="89c4560a90f4c8640ca9769656650496ad022a1f" translate="yes" xml:space="preserve">
          <source>Do note that a switch like &lt;b&gt;--help&lt;/b&gt; creates the variable &lt;code&gt;${-help}&lt;/code&gt; , which is not compliant with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; . Also, when using this option on a script with warnings enabled you may get a lot of spurious &quot;used only once&quot; warnings.</source>
          <target state="translated">请注意，类似&lt;b&gt;--help&lt;/b&gt;的开关会创建变量 &lt;code&gt;${-help}&lt;/code&gt; &lt;b&gt;-help &lt;/b&gt;}，该变量与 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict &quot;refs&quot;&lt;/code&gt; 不兼容。另外，在启用了警告的脚本上使用此选项时，您可能会收到很多虚假的&amp;ldquo;仅使用一次&amp;rdquo;警告。</target>
        </trans-unit>
        <trans-unit id="c739ef2c73416de977da1e1813d572016c0b1d06" translate="yes" xml:space="preserve">
          <source>Do note that the examples have been written by many different authors over a period of several decades. Styles and techniques will therefore differ, although some effort has been made to not vary styles too widely in the same sections. Do not consider one style to be better than others - &quot;There's More Than One Way To Do It&quot; is one of Perl's mottos. After all, in your journey as a programmer, you are likely to encounter different styles.</source>
          <target state="translated">请注意,这些例子是由许多不同的作者在数十年间撰写的。因此,风格和技术会有所不同,尽管我们已经努力避免在同一章节中出现太大差异。不要认为一种风格比其他风格好--&quot;有不止一种方法可以做 &quot;是Perl的座右铭之一。毕竟,在你作为程序员的历程中,你很可能会遇到不同的风格。</target>
        </trans-unit>
        <trans-unit id="540dbdd2eced4389045109a5d86db714850717db" translate="yes" xml:space="preserve">
          <source>Do one thing and do it well</source>
          <target state="translated">做一件事并做好它</target>
        </trans-unit>
        <trans-unit id="2495a1047a7ca571d906f155a7f581ed5618c76e" translate="yes" xml:space="preserve">
          <source>Do read the README associated with your operating system, e.g. README.aix on the IBM AIX OS. Don't hesitate to supply patches to that README if you find anything missing or changed over a new OS release.</source>
          <target state="translated">请阅读与您的操作系统相关的 README,例如 IBM AIX 操作系统的 README.aix。如果你发现在新的操作系统版本上有任何缺失或改变,请毫不犹豫地给 README 提供补丁。</target>
        </trans-unit>
        <trans-unit id="f6c0054711126ec773d898b58f49cbb4c949cab9" translate="yes" xml:space="preserve">
          <source>Do similar modules already exist in some form?</source>
          <target state="translated">类似的模块是否已经以某种形式存在?</target>
        </trans-unit>
        <trans-unit id="4d86fca77a17d198920e265fa1fed63a01551109" translate="yes" xml:space="preserve">
          <source>Do take care with &lt;code&gt;$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT&lt;/code&gt; if your Perl-in-DCL script expects to do things like &lt;code&gt;$read = &amp;lt;STDIN&amp;gt;;&lt;/code&gt; .</source>
          <target state="translated">如果您的Perl-in-DCL脚本希望执行 &lt;code&gt;$read = &amp;lt;STDIN&amp;gt;;&lt;/code&gt; 请小心 &lt;code&gt;$ ASSIGN/nolog/user SYS$COMMAND: SYS$INPUT&lt;/code&gt; ；。</target>
        </trans-unit>
        <trans-unit id="ed37eb991a7adeef41e4c420e9ad43ac12f4d7d2" translate="yes" xml:space="preserve">
          <source>Do the basic security measures to ensure the directory exists and is writable, that temporary files are opened only if they do not already exist, and that possible race conditions are avoided. Finally the L</source>
          <target state="translated">做好基本的安全措施,确保目录存在且可写,临时文件只有在不存在的情况下才会被打开,并避免可能的竞赛条件。最后是L</target>
        </trans-unit>
        <trans-unit id="a62956f5b6df99e5d8fc6b8cabce7cc42f269d70" translate="yes" xml:space="preserve">
          <source>Do the same sort of thing to delete a particular line by using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; to skip the lines you don't want to show up in the output. This example skips every fifth line:</source>
          <target state="translated">通过使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 跳过您不想在输出中显示的行，执行相同的操作以删除特定行。本示例跳过每五行：</target>
        </trans-unit>
        <trans-unit id="6bee90ebbffd3a020ccb7068ab9d7842e861b7da" translate="yes" xml:space="preserve">
          <source>Do whatever you can to find out, and if you have to: guess. (Don't forget to document your guess with a comment.)</source>
          <target state="translated">尽你所能去了解,如果你必须:猜测。(别忘了用评论记录你的猜测)。</target>
        </trans-unit>
        <trans-unit id="1287ea9cdb3e32730cc921890c861ccf51d63478" translate="yes" xml:space="preserve">
          <source>Do you try to run</source>
          <target state="translated">你试着跑</target>
        </trans-unit>
        <trans-unit id="d659723a2b8c8d2ce99667e3ef2aba7ca933d74a" translate="yes" xml:space="preserve">
          <source>Do you want the command number in the prompt (yes/no)?</source>
          <target state="translated">您是否希望在提示符中显示命令编号(是/否)?</target>
        </trans-unit>
        <trans-unit id="d7a7627a867e6bbe22a2b970c115376b82f0139b" translate="yes" xml:space="preserve">
          <source>Do you want to enable code deserialisation (yes/no)?</source>
          <target state="translated">您是否要启用代码反序列化(是/否)?</target>
        </trans-unit>
        <trans-unit id="cbd235cb0bbd92aee8e53ccbbbbc3dabc72798c9" translate="yes" xml:space="preserve">
          <source>Do you want to halt on failure (yes/no)?</source>
          <target state="translated">您是否希望在失败时停止(是/否)?</target>
        </trans-unit>
        <trans-unit id="373cd2197f990d8762c7c66b4869ae4717a2e44c" translate="yes" xml:space="preserve">
          <source>Do you want to rely on the test report history (yes/no)?</source>
          <target state="translated">您是否想依赖测试报告历史记录(是/否)?</target>
        </trans-unit>
        <trans-unit id="8a279f6363761148fb8c2b71535a1b4a155b67db" translate="yes" xml:space="preserve">
          <source>Do you want to turn on colored output?</source>
          <target state="translated">你想开启彩色输出吗?</target>
        </trans-unit>
        <trans-unit id="87a207a61ec9d6801b880d322288293793a12268" translate="yes" xml:space="preserve">
          <source>Do you want to turn ornaments on?</source>
          <target state="translated">你想打开饰品吗?</target>
        </trans-unit>
        <trans-unit id="99b869f7fe84b2b6d6d37879f90b1ce5f182c64b" translate="yes" xml:space="preserve">
          <source>Do you want to turn this message off?</source>
          <target state="translated">你想把这个消息关掉吗?</target>
        </trans-unit>
        <trans-unit id="8bf8fea239cbb1f5a4fdb80eb2b8949a38de2f2e" translate="yes" xml:space="preserve">
          <source>Do you want to use a different command for './Build install'? Sudo users will probably prefer:</source>
          <target state="translated">你想为'./Build install'使用不同的命令吗?Sudo用户可能会喜欢。</target>
        </trans-unit>
        <trans-unit id="cc8ccb8accaee9d0eecc936c06f10fdc9aba0e2f" translate="yes" xml:space="preserve">
          <source>Do you want to use a different make command for 'make install'? Cautious people will probably prefer:</source>
          <target state="translated">你想为 &quot;make install &quot;使用不同的make命令吗?谨慎的人可能会喜欢。</target>
        </trans-unit>
        <trans-unit id="4f330885ef3a3b61025e1e796b402fcd50c7b4e7" translate="yes" xml:space="preserve">
          <source>Do you want to use prompt defaults (yes/no)?</source>
          <target state="translated">您是否要使用提示默认值(是/否)?</target>
        </trans-unit>
        <trans-unit id="918ceb56671dd67483da1f39299f85748b336c0e" translate="yes" xml:space="preserve">
          <source>Do you want to:</source>
          <target state="translated">你想。</target>
        </trans-unit>
        <trans-unit id="b91e32e96ba9f37078ffe29f1ee1859d0140ecfd" translate="yes" xml:space="preserve">
          <source>Document each publically accessible method or subroutine, including params and return values</source>
          <target state="translated">记录每个可公开访问的方法或子程序,包括参数和返回值。</target>
        </trans-unit>
        <trans-unit id="6e00d0928abd84bf71ed2ace7f696bcbc6aee9e8" translate="yes" xml:space="preserve">
          <source>Document purpose, scope and target applications</source>
          <target state="translated">记录目的、范围和目标应用</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="0d4f3597552829486c9c7978225dcdc88217781f" translate="yes" xml:space="preserve">
          <source>Documentation and help texts</source>
          <target state="translated">文件和帮助文本</target>
        </trans-unit>
        <trans-unit id="1d66c2dca46aca62759ec44a5b9071376128798a" translate="yes" xml:space="preserve">
          <source>Documentation borrowed from the old Thread.pm.</source>
          <target state="translated">文档借用了旧的Thread.pm。</target>
        </trans-unit>
        <trans-unit id="8b5ab45b761259017419114ca3e9a62382663d77" translate="yes" xml:space="preserve">
          <source>Documentation has been contributed by:</source>
          <target state="translated">提供文件的有:</target>
        </trans-unit>
        <trans-unit id="4730bb4bd3211681615071a5ac81bbb7a0d87081" translate="yes" xml:space="preserve">
          <source>Documentation mostly rewritten by Ilmari Karonen, &amp;lt;</source>
          <target state="translated">主要由Ilmari Karonen重写的文档，&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5c1fa297f5d4c566fd5588f14f34ea9f8ecedf5a" translate="yes" xml:space="preserve">
          <source>Documentation of corrections already incorporated into the Unicode data base</source>
          <target state="translated">已纳入统一编码数据库的更正文件。</target>
        </trans-unit>
        <trans-unit id="cac7df688d4ef7dcaa6e39b6e0d4e8f277b2acfd" translate="yes" xml:space="preserve">
          <source>Documentation of object-oriented libraries or modules may want to use CONSTRUCTORS and METHODS sections, or CLASS METHODS and INSTANCE METHODS sections, for detailed documentation of the parts of the library and save the DESCRIPTION section for an overview. Large modules with a function interface may want to use FUNCTIONS for similar reasons. Some people use OVERVIEW to summarize the description if it's quite long.</source>
          <target state="translated">面向对象的库或模块的文档可能希望使用CONSTRUCTORS和METHODS部分,或者使用CLASS METHODS和INSTANCE METHODS部分,对库的各个部分进行详细的记录,并保存DESCRIPTION部分进行概述。带有函数接口的大型模块可能要使用functions,原因类似。如果描述相当长,有些人用OVERVIEW来总结。</target>
        </trans-unit>
        <trans-unit id="49018199d13814134468f853612e00393c5c7fd7" translate="yes" xml:space="preserve">
          <source>Documentation of status and cross reference of proposals for encoding by Unicode of Unihan characters</source>
          <target state="translated">记载统一编码系统对统一汉字的编码建议的现状和相互参照情况</target>
        </trans-unit>
        <trans-unit id="eb488db5f5b4fb936ed78cb59ddbbcefd6c8b7f6" translate="yes" xml:space="preserve">
          <source>Documentation of validation tests</source>
          <target state="translated">审定试验的文件</target>
        </trans-unit>
        <trans-unit id="b139845ddb6a01b9b23ddc81ca29bb8e6b63e194" translate="yes" xml:space="preserve">
          <source>Documentation updates that correct factual errors, explain significant bugs or deficiencies in the current implementation, or fix broken markup.</source>
          <target state="translated">纠正事实错误、解释当前实施中的重大错误或缺陷,或修复损坏的标记的文档更新。</target>
        </trans-unit>
        <trans-unit id="23cea710c088ecfa1ae744391fe173bfdf5d1acb" translate="yes" xml:space="preserve">
          <source>Documenting the patch</source>
          <target state="translated">记录补丁</target>
        </trans-unit>
        <trans-unit id="a20866ae52f8e35eaed59a179f7c48ea2d19b8fa" translate="yes" xml:space="preserve">
          <source>Documenting your Extension</source>
          <target state="translated">记录您的扩展</target>
        </trans-unit>
        <trans-unit id="2080696be6c4c31d4c892420cc245128864bdfe0" translate="yes" xml:space="preserve">
          <source>Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?</source>
          <target state="translated">Perl有2000年或2038年的问题吗?Perl是否符合Y2K标准?</target>
        </trans-unit>
        <trans-unit id="0d6d8d711a3a4cca710ca22dbfe40093bf45d857" translate="yes" xml:space="preserve">
          <source>Does Perl have a round() function? What about ceil() and floor()? Trig functions?</source>
          <target state="translated">Perl 有没有 round()函数?ceil()和 floor()呢?三角函数?</target>
        </trans-unit>
        <trans-unit id="347f03cef55a503c9fa350dbe1691433852f2738" translate="yes" xml:space="preserve">
          <source>Does a $(CI) and a $(RCS_LABEL) on all files in the MANIFEST file.</source>
          <target state="translated">对MANIFEST文件中的所有文件进行$(CI)和$(RCS_LABEL)操作。</target>
        </trans-unit>
        <trans-unit id="6ace7d9d419573301ff609d787f134b02b26193b" translate="yes" xml:space="preserve">
          <source>Does a fork(2) system call to create a new process running the same program at the same point. It returns the child pid to the parent process, &lt;code&gt;0&lt;/code&gt; to the child process, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the fork is unsuccessful. File descriptors (and sometimes locks on those descriptors) are shared, while everything else is copied. On most systems supporting fork(), great care has gone into making it extremely efficient (for example, using copy-on-write technology on data pages), making it the dominant paradigm for multitasking over the last few decades.</source>
          <target state="translated">是否进行fork（2）系统调用以创建在同一点运行相同程序的新进程。它将子pid返回到父进程，将 &lt;code&gt;0&lt;/code&gt; 返回到子进程，如果fork不成功，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。共享文件描述符（有时锁定这些描述符），同时复制其他所有文件。在大多数支持fork（）的系统上，都非常注意使其变得非常高效（例如，在数据页上使用写时复制技术），使其成为过去几十年来多任务处理的主要范例。</target>
        </trans-unit>
        <trans-unit id="94b3dcb831cc7f4b2c1f2db661fceb8975ccf8c1" translate="yes" xml:space="preserve">
          <source>Does a fork(2) system call to create a new process running the same program at the same point. It returns the child pid to the parent process, &lt;code&gt;0&lt;/code&gt; to the child process, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the fork is unsuccessful. File descriptors (and sometimes locks on those descriptors) are shared, while everything else is copied. On most systems supporting fork(), great care has gone into making it extremely efficient (for example, using copy-on-write technology on data pages), making it the dominant paradigm for multitasking over the last few decades.</source>
          <target state="translated">是否进行fork（2）系统调用以创建在同一点运行相同程序的新进程。它将子pid返回到父进程，将 &lt;code&gt;0&lt;/code&gt; 返回到子进程，如果fork不成功，则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。共享文件描述符（有时锁定这些描述符），同时复制其他所有文件。在大多数支持fork（）的系统上，都非常注意使其变得非常高效（例如，在数据页上使用写时复制技术），使其成为过去几十年来多任务处理的主要范例。</target>
        </trans-unit>
        <trans-unit id="6e7a8e9cc842e50405245756a0a1bacedfbe9c22" translate="yes" xml:space="preserve">
          <source>Does a tree-walk of the syntax tree based at OP and calls METHOD on each op it visits. Each node is visited before its children. If &lt;code&gt;walkoptree_debug&lt;/code&gt; (see below) has been called to turn debugging on then the method &lt;code&gt;walkoptree_debug&lt;/code&gt; is called on each op before METHOD is called.</source>
          <target state="translated">在OP上进行语法树的遍历，并在其访问的每个op上调用METHOD。每个节点都在其子节点之前被访问。如果已调用 &lt;code&gt;walkoptree_debug&lt;/code&gt; （请参见下文）以打开调试功能，则在调用METHOD之前，将在每个操作上调用 &lt;code&gt;walkoptree_debug&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="de4556ee919b8c9e716ff91fff53e57dd9fa041d" translate="yes" xml:space="preserve">
          <source>Does exactly the same thing as &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , except that a fork is done first and the parent process waits for the child process to exit. Note that argument processing varies depending on the number of arguments. If there is more than one argument in LIST, or if LIST is an array with more than one value, starts the program given by the first element of the list with arguments given by the rest of the list. If there is only one scalar argument, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. On Windows, only the &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 完全相同，只是先完成一个分叉，并且父进程等待子进程退出。注意，参数处理取决于参数的数量。如果LIST中有多个自变量，或者LIST是具有多个值的数组，请启动列表中第一个元素给出的程序，并使用列表中其余元素给出的参数。如果只有一个标量参数，则检查该参数是否包含shell元字符，如果有，则将整个参数传递给系统的命令shell进行解析（在Unix平台上为 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，但在其他平台）。如果参数中没有外壳元字符，则将其拆分为单词并直接传递给 &lt;code&gt;execvp&lt;/code&gt; ，效率更高。在Windows上，只有 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 语法才能可靠地避免使用Shell。如果第一个生成失败，即使有多个元素， &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; 也会退回到Shell。</target>
        </trans-unit>
        <trans-unit id="971d377ca0b94eef511ce7a5cf1fbc7ca9fc4308" translate="yes" xml:space="preserve">
          <source>Does exactly the same thing as &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , except that a fork is done first and the parent process waits for the child process to exit. Note that argument processing varies depending on the number of arguments. If there is more than one argument in LIST, or if LIST is an array with more than one value, starts the program given by the first element of the list with arguments given by the rest of the list. If there is only one scalar argument, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 完全相同，只是先完成一个分叉，并且父进程等待子进程退出。注意，参数处理取决于参数的数量。如果LIST中有多个自变量，或者LIST是具有多个值的数组，请启动列表中第一个元素给出的程序，并使用列表中其余元素给出的参数。如果只有一个标量参数，则检查该参数是否包含shell元字符，如果有，则将整个参数传递给系统的命令shell进行解析（在Unix平台上为 &lt;code&gt;/bin/sh -c&lt;/code&gt; ，但在其他平台）。如果参数中没有外壳元字符，则将其拆分为单词并直接传递给 &lt;code&gt;execvp&lt;/code&gt; ，效率更高。在Windows上，只有 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 语法才能可靠地避免使用Shell。如果第一个生成失败，即使有多个元素， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; LIST&lt;/code&gt; 也会退回到Shell。</target>
        </trans-unit>
        <trans-unit id="7ae98d71c785265ddcfeeeb07989cf58a75f2684" translate="yes" xml:space="preserve">
          <source>Does it create too much work?</source>
          <target state="translated">会不会产生太多工作?</target>
        </trans-unit>
        <trans-unit id="76c48f534cf5b51a41a2a7ce76b162535214df0a" translate="yes" xml:space="preserve">
          <source>Does it potentially introduce new bugs?</source>
          <target state="translated">它是否有可能引入新的bug?</target>
        </trans-unit>
        <trans-unit id="163b23e27c4c841d1d0111848b85d7359f51c15f" translate="yes" xml:space="preserve">
          <source>Does it preclude other desirable features?</source>
          <target state="translated">它是否排除了其他理想的功能?</target>
        </trans-unit>
        <trans-unit id="19da346c64719e8350a8cf9aeb2a31add00b3079" translate="yes" xml:space="preserve">
          <source>Does not &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; to each directory as it recurses. The &lt;code&gt;wanted()&lt;/code&gt; function will need to be aware of this, of course. In this case, &lt;code&gt;$_&lt;/code&gt; will be the same as &lt;code&gt;$File::Find::name&lt;/code&gt; .</source>
          <target state="translated">递归时，不要对每个目录使用 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 。当然， &lt;code&gt;wanted()&lt;/code&gt; 函数将需要意识到这一点。在这种情况下， &lt;code&gt;$_&lt;/code&gt; 将与 &lt;code&gt;$File::Find::name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af44a91c9e39ab0c7463bac15a45ab231dcc0a7d" translate="yes" xml:space="preserve">
          <source>Does not alter the passed in ver SV. See &quot;upg_version&quot; if you want to upgrade the SV.</source>
          <target state="translated">不改变传递的SV版本。如果您想升级SV,请参见 &quot;upg_version&quot;。</target>
        </trans-unit>
        <trans-unit id="7520223aa1c22fe71da2f2fd9fbb194fccf8f278" translate="yes" xml:space="preserve">
          <source>Does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">在某些平台上不会自动刷新输出句柄。(SunOS,Solaris,HP-UX)</target>
        </trans-unit>
        <trans-unit id="1d965ffd27f165cd1bb4e614ffc070019e6e4581" translate="yes" xml:space="preserve">
          <source>Does not support &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; on arrays. Does not support explicitly changing array lengths via $#array -- use &lt;code&gt;&lt;a href=&quot;../functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不支持在阵列上 &lt;code&gt;&lt;a href=&quot;../functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。不支持通过$＃array显式更改数组长度- 而是使用 &lt;code&gt;&lt;a href=&quot;../functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6e1e02c4c151b139fab2fca754d38a684aec2de" translate="yes" xml:space="preserve">
          <source>Does not work as</source>
          <target state="translated">无法正常工作</target>
        </trans-unit>
        <trans-unit id="a0eab3410cab5a6dc3b7523e73bfbe22cc007192" translate="yes" xml:space="preserve">
          <source>Does nothing, but won't fail. (Win32)</source>
          <target state="translated">什么也不做,但不会失败。(Win32)</target>
        </trans-unit>
        <trans-unit id="ab6714990b2e9014158db7ba9506c2e3f1eef1e8" translate="yes" xml:space="preserve">
          <source>Does the concept match the general goals of Perl?</source>
          <target state="translated">这个概念是否符合Perl的一般目标?</target>
        </trans-unit>
        <trans-unit id="dbd3ca43bd95ec8bd28a3afc7d9eb6159f4931f6" translate="yes" xml:space="preserve">
          <source>Does the equivalent of the &lt;code&gt;-c&lt;/code&gt; command-line option. Obviously, this is only useful in a BEGIN block or else the flag is set too late.</source>
          <target state="translated">是否等效于 &lt;code&gt;-c&lt;/code&gt; 命令行选项。显然，这仅在BEGIN块中有用，否则标志设置得太晚。</target>
        </trans-unit>
        <trans-unit id="5d2b8e3e1d6fb7e3c6489d878105273a9ab06c85" translate="yes" xml:space="preserve">
          <source>Does the exact opposite to the &lt;b&gt;-W&lt;/b&gt; flag, i.e. it disables all warnings.</source>
          <target state="translated">与&lt;b&gt;-W&lt;/b&gt;标志完全相反，即它禁用所有警告。</target>
        </trans-unit>
        <trans-unit id="4f6fc9d8f5b45abfab918dce456df590c87db452" translate="yes" xml:space="preserve">
          <source>Does the module require compilation (i.e. does it have files that end in .xs, .c, .h, .y, .cc, .cxx, or .C)? If it does, life is now officially tough for you, because you have to compile the module yourself (no easy feat on Windows). You'll need a compiler such as Visual C++. Alternatively, you can download a pre-built PPM package from ActiveState. &lt;a href=&quot;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&quot;&gt;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&lt;/a&gt;</source>
          <target state="translated">该模块是否需要编译（即，是否具有以.xs，.c，.h，.y，.cc，.cxx或.C结尾的文件）？如果确实如此，那么现在对您来说生活将变得很艰难，因为您必须自己编译模块（在Windows上并非易事）。您将需要诸如Visual C ++之类的编译器。或者，您可以从ActiveState下载预构建的PPM软件包。&lt;a href=&quot;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&quot;&gt;http://aspn.activestate.com/ASPN/Downloads/ActivePerl/PPM/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e8b1afa4f266e283c1e89777c89973f57e94a2c" translate="yes" xml:space="preserve">
          <source>Does the opposite of a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;. Or the opposite of a &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, depending on how you look at it. Prepends list to the front of the array and returns the new number of elements in the array.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 相反。还是 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 的反义词，取决于您如何看待它。将列表添加到数组的最前面，并返回数组中新的元素数。</target>
        </trans-unit>
        <trans-unit id="15ca4b87c1dd7484db0ece50d3e128013e8468d9" translate="yes" xml:space="preserve">
          <source>Does the opposite of a &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;. Or the opposite of a &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, depending on how you look at it. Prepends list to the front of the array and returns the new number of elements in the array.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 相反。还是 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 的反义词，取决于您如何看待它。将列表添加到数组的最前面，并返回数组中新的元素数。</target>
        </trans-unit>
        <trans-unit id="a4a01d3bbed716e476e014f93f4ca067ce1b42d2" translate="yes" xml:space="preserve">
          <source>Does the same thing as the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function (including setting the special &lt;code&gt;_&lt;/code&gt; filehandle) but stats a symbolic link instead of the file the symbolic link points to. If symbolic links are unimplemented on your system, a normal &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is done. For much more detailed information, please see the documentation for &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">执行与 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 函数相同的操作（包括设置特殊的 &lt;code&gt;_&lt;/code&gt; filehandle），但统计符号链接而不是符号链接指向的文件。如果您的系统上未实现符号链接，则 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 正常。有关更多详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="2440cc46fc6eb9876beb8fbe0150b6c618c74179" translate="yes" xml:space="preserve">
          <source>Does the same thing as the &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; function (including setting the special &lt;code&gt;_&lt;/code&gt; filehandle) but stats a symbolic link instead of the file the symbolic link points to. If symbolic links are unimplemented on your system, a normal &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is done. For much more detailed information, please see the documentation for &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">执行与 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 函数相同的操作（包括设置特殊的 &lt;code&gt;_&lt;/code&gt; filehandle），但统计符号链接而不是符号链接指向的文件。如果您的系统上未实现符号链接，则 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 正常。有关更多详细信息，请参阅 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="c26f7b80fe6be59ff00dfaaf3a9f27764a36e9e8" translate="yes" xml:space="preserve">
          <source>Does the same thing that the listen(2) system call does. Returns true if it succeeded, false otherwise. See the example in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">执行与listen（2）系统调用相同的操作。如果成功，则返回true，否则返回false。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="22db9588c396aba67c7aad2d451295dbb36db3d9" translate="yes" xml:space="preserve">
          <source>Does the same thing that the listen(2) system call does. Returns true if it succeeded, false otherwise. See the example in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">执行与listen（2）系统调用相同的操作。如果成功，则返回true，否则返回false。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="22374adba20ced760e98d0c0d73bbc827cae9cc0" translate="yes" xml:space="preserve">
          <source>Does this module need linking? Looks into subdirectory objects (see also has_link_code())</source>
          <target state="translated">这个模块是否需要链接?查看子目录对象 (参见 has_link_code())</target>
        </trans-unit>
        <trans-unit id="ec5a93789136319c08b5e5d76ea18d252f60bd6c" translate="yes" xml:space="preserve">
          <source>Does very much the same as the cflags script in the perl distribution. It doesn't return the whole compiler command line, but initializes all of its parts. The const_cccmd method then actually returns the definition of the CCCMD macro which uses these parts.</source>
          <target state="translated">和 perl 发行版中的 cflags 脚本做的非常相似。它并没有返回整个编译器命令行,而是初始化了它的所有部分,然后const_cccmd方法实际上返回了使用这些部分的CCCMD宏的定义。const_cccmd方法实际上返回了使用这些部分的CCCMD宏的定义。</target>
        </trans-unit>
        <trans-unit id="6d014ad0641a64b3a2fca948ec89b499199cfda8" translate="yes" xml:space="preserve">
          <source>Does your module pass the 'empty subclass' test? If you say &lt;code&gt;@SUBCLASS::ISA = qw(YOURCLASS);&lt;/code&gt; your applications should be able to use SUBCLASS in exactly the same way as YOURCLASS. For example, does your application still work if you change: &lt;code&gt;$obj = YOURCLASS-&amp;gt;new();&lt;/code&gt; into: &lt;code&gt;$obj = SUBCLASS-&amp;gt;new();&lt;/code&gt; ?</source>
          <target state="translated">您的模块是否通过了&amp;ldquo;空子类&amp;rdquo;测试？如果您说 &lt;code&gt;@SUBCLASS::ISA = qw(YOURCLASS);&lt;/code&gt; 您的应用程序应该能够以与YOURCLASS完全相同的方式使用SUBCLASS。例如，如果您进行更改，您的应用程序是否仍然可以工作： &lt;code&gt;$obj = YOURCLASS-&amp;gt;new();&lt;/code&gt; 到： &lt;code&gt;$obj = SUBCLASS-&amp;gt;new();&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="bdcea9fc3bdee92b160e5b96d81fb3d19af3fd30" translate="yes" xml:space="preserve">
          <source>Doesn't construct the %sizeof array for you.</source>
          <target state="translated">并没有为你构造%sizeof数组。</target>
        </trans-unit>
        <trans-unit id="cd3640eea37fa02af99e7bd48394bfa2af60bf4c" translate="yes" xml:space="preserve">
          <source>Doesn't handle complicated expressions built piecemeal, a la:</source>
          <target state="translated">不处理零散构建的复杂表达式,拉。</target>
        </trans-unit>
        <trans-unit id="5787ba7fa720ea9e3316d963760e6faa3df102b3" translate="yes" xml:space="preserve">
          <source>Doesn't necessarily locate all of your C compiler's internally-defined symbols.</source>
          <target state="translated">不一定能定位所有C编译器的内部定义符号。</target>
        </trans-unit>
        <trans-unit id="9f3f7c7d9e43e8918099efac1f5805d8811f35df" translate="yes" xml:space="preserve">
          <source>Doing Sums</source>
          <target state="translated">做算术</target>
        </trans-unit>
        <trans-unit id="c0d111463257cf715e280f2b7d3c19b013c19ffb" translate="yes" xml:space="preserve">
          <source>Doing something repeatedly.</source>
          <target state="translated">反复做某事。</target>
        </trans-unit>
        <trans-unit id="2151e066a0ffe448d6aae7739b4f7382726846a0" translate="yes" xml:space="preserve">
          <source>Doing these checks by hand can quickly become tedious. Writing a bunch of accessors by hand is also incredibly tedious. There are a lot of modules on CPAN that can help you write safer and more concise code, including the modules we recommend in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">手工进行这些检查会很快变得乏味。手工编写一堆访问器也非常繁琐。CPAN上有很多模块可以帮助您编写更安全，更简洁的代码，包括我们在&lt;a href=&quot;perlootut&quot;&gt;perlootut中&lt;/a&gt;推荐的模块。</target>
        </trans-unit>
        <trans-unit id="e1639673d423ca711b3596783b5c0a4171be6aec" translate="yes" xml:space="preserve">
          <source>Doing this:</source>
          <target state="translated">做这个。</target>
        </trans-unit>
        <trans-unit id="c70ec1bd923ff14caf24abddbe98bbe566095521" translate="yes" xml:space="preserve">
          <source>Don't assume &lt;code&gt;&amp;gt;&lt;/code&gt; won't be the first character of a filename. Always use &lt;code&gt;&amp;lt;&lt;/code&gt; explicitly to open a file for reading, or even better, use the three-arg version of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, unless you want the user to be able to specify a pipe open.</source>
          <target state="translated">不要假设 &lt;code&gt;&amp;gt;&lt;/code&gt; 不会是文件名的第一个字符。始终明确使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 来打开文件进行读取，或者甚至最好使用 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 的三参数版本，除非您希望用户能够指定管道打开。</target>
        </trans-unit>
        <trans-unit id="51fadcebe3461dfde168100ac06626ef32c5c3c4" translate="yes" xml:space="preserve">
          <source>Don't assume Unix filesystem access semantics: that read, write, and execute are all the permissions there are, and even if they exist, that their semantics (for example what do &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; , and &lt;code&gt;&quot;x&quot;&lt;/code&gt; mean on a directory) are the Unix ones. The various Unix/POSIX compatibility layers usually try to make interfaces like &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; work, but sometimes there simply is no good mapping.</source>
          <target state="translated">不要假定Unix文件系统访问语义：读，写和执行是所有权限，即使它们存在，它们的语义（例如， &lt;code&gt;&quot;r&quot;&lt;/code&gt; ， &lt;code&gt;&quot;w&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 含义是什么）在目录上）是Unix的。各种Unix / POSIX兼容性层通常会尝试使类似 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod()&lt;/a&gt;&lt;/code&gt; 的接口正常工作，但是有时根本没有良好的映射。</target>
        </trans-unit>
        <trans-unit id="4a45b9025bbd946f66021bb7d900991eb240c421" translate="yes" xml:space="preserve">
          <source>Don't assume a particular network device name.</source>
          <target state="translated">不要假设某一个网络设备名称。</target>
        </trans-unit>
        <trans-unit id="46d416e1f318922467e8a69618050fe453e3d906" translate="yes" xml:space="preserve">
          <source>Don't assume a particular set of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt;s will work.</source>
          <target state="translated">不要假设一组特定的 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 可以工作。</target>
        </trans-unit>
        <trans-unit id="f77b1e37f7f7fe660c8641daee5c495d72fc56f7" translate="yes" xml:space="preserve">
          <source>Don't assume a text file will end with a newline. They should, but people forget.</source>
          <target state="translated">不要以为文本文件会以换行结束。它们应该是这样,但人们会忘记。</target>
        </trans-unit>
        <trans-unit id="98161964580f6c72edaf8ce914f3e1d98ec3ce2f" translate="yes" xml:space="preserve">
          <source>Don't assume set-uid and set-gid semantics. (And even if you do, think twice: set-uid and set-gid are a known can of security worms.)</source>
          <target state="translated">不要假设set-uid和set-gid的语义。即使你这样做,也要三思而后行:set-uid和set-gid是一个已知的安全漏洞。</target>
        </trans-unit>
        <trans-unit id="904c69ae9ffdcafece3576aedd570251fa8bd53f" translate="yes" xml:space="preserve">
          <source>Don't assume that &lt;code&gt;Sys::Hostname&lt;/code&gt; (or any other API or command) returns either a fully qualified hostname or a non-qualified hostname: it all depends on how the system had been configured. Also remember that for things such as DHCP and NAT, the hostname you get back might not be very useful.</source>
          <target state="translated">不要假定 &lt;code&gt;Sys::Hostname&lt;/code&gt; （或任何其他API或命令）返回的是完全合格的主机名还是非合格的主机名：这完全取决于系统的配置方式。还要记住，对于诸如DHCP和NAT之类的东西，您获得的主机名可能不是很有用。</target>
        </trans-unit>
        <trans-unit id="cce6dd3c9e2a99e556dd9e7e5f6487f0ac7f77b2" translate="yes" xml:space="preserve">
          <source>Don't assume that a single &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; completely gets rid of the file: some filesystems (most notably the ones in VMS) have versioned filesystems, and &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; removes only the most recent one (it doesn't remove all the versions because by default the native tools on those platforms remove just the most recent version, too). The portable idiom to remove all the versions of a file is</source>
          <target state="translated">不要假设单个 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 完全删除该文件：某些文件系统（最著名的是VMS中的文件系统）具有版本化的文件系统，而 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink()&lt;/a&gt;&lt;/code&gt; 仅删除最新的文件系统（不会删除所有版本，因为默认情况下，这些平台上的本机工具也会删除最新版本）。删除文件所有版本的可移植习语是</target>
        </trans-unit>
        <trans-unit id="45827beb2b333818dc1ab476c3c49bc561007b4d" translate="yes" xml:space="preserve">
          <source>Don't assume that any particular port (service) will respond.</source>
          <target state="translated">不要假设任何一个特定的端口(服务)都会响应。</target>
        </trans-unit>
        <trans-unit id="6999e83ecac7276661229b08d824b9951f96931a" translate="yes" xml:space="preserve">
          <source>Don't assume that in pathnames you can collapse two leading slashes &lt;code&gt;//&lt;/code&gt; into one: some networking and clustering filesystems have special semantics for that. Let the operating system sort it out.</source>
          <target state="translated">不要以为在路径名中可以将两个前导斜杠 &lt;code&gt;//&lt;/code&gt; 折叠成一个：一些网络和集群文件系统对此具有特殊的语义。让操作系统对其进行整理。</target>
        </trans-unit>
        <trans-unit id="98d90ea04fc1672840d09560112d2b5f38aad8d8" translate="yes" xml:space="preserve">
          <source>Don't assume that the epoch starts at 00:00:00, January 1, 1970, because that is OS- and implementation-specific. It is better to store a date in an unambiguous representation. The ISO 8601 standard defines YYYY-MM-DD as the date format, or YYYY-MM-DDTHH:MM:SS (that's a literal &quot;T&quot; separating the date from the time). Please do use the ISO 8601 instead of making us guess what date 02/03/04 might be. ISO 8601 even sorts nicely as-is. A text representation (like &quot;1987-12-18&quot;) can be easily converted into an OS-specific value using a module like &lt;code&gt;Date::Parse&lt;/code&gt; . An array of values, such as those returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt;, can be converted to an OS-specific representation using &lt;code&gt;Time::Local&lt;/code&gt; .</source>
          <target state="translated">不要以为纪元是从1970年1月1日的00:00:00开始的，因为那是特定于OS和实现的。最好以明确的表示形式存储日期。 ISO 8601标准将YYYY-MM-DD定义为日期格式，或者将YYYY-MM-DDTHH：MM：SS（即从日期与时间分隔的文字&amp;ldquo; T&amp;rdquo;）定义为日期格式。请使用ISO 8601，而不要让我们猜测日期是02/03/04。 ISO 8601甚至可以很好地进行分类。使用 &lt;code&gt;Date::Parse&lt;/code&gt; 这样的模块，可以轻松地将文本表示形式（如&amp;ldquo; 1987-12-18&amp;rdquo;）转换为特定于操作系统的值。可以使用 &lt;code&gt;Time::Local&lt;/code&gt; 将值的数组（例如 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 返回的值）转换为特定于OS的表示形式。</target>
        </trans-unit>
        <trans-unit id="ae81459ffe886d165ec19458ee6907edce3977cd" translate="yes" xml:space="preserve">
          <source>Don't assume that the host has only one network card, or that it can't bind to many virtual IP addresses.</source>
          <target state="translated">不要以为主机只有一个网卡,或者不能绑定很多虚拟IP地址。</target>
        </trans-unit>
        <trans-unit id="762d289b8f69911c48e30355fa8f2ef9119426cc" translate="yes" xml:space="preserve">
          <source>Don't assume that the name used to invoke a command or program with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; can also be used to test for the existence of the file that holds the executable code for that command or program. First, many systems have &quot;internal&quot; commands that are built-in to the shell or OS and while these commands can be invoked, there is no corresponding file. Second, some operating systems (e.g., Cygwin, DJGPP, OS/2, and VOS) have required suffixes for executable files; these suffixes are generally permitted on the command name but are not required. Thus, a command like</source>
          <target state="translated">不要假设用来通过 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 调用命令或程序的名称也可以用来测试是否存在该命令或程序的可执行代码的文件。首先，许多系统具有内置于Shell或OS中的&amp;ldquo;内部&amp;rdquo;命令，尽管可以调用这些命令，但没有相应的文件。其次，某些操作系统（例如Cygwin，DJGPP，OS / 2和VOS）已为可执行文件添加了后缀。这些后缀通常在命令名称上是允许的，但不是必需的。因此，类似</target>
        </trans-unit>
        <trans-unit id="1514a854a4b008c5fba8916a7962921e2b8b3a4a" translate="yes" xml:space="preserve">
          <source>Don't assume that there is only one way to get through firewalls to the public Internet.</source>
          <target state="translated">不要以为只有一种方式可以通过防火墙进入公共互联网。</target>
        </trans-unit>
        <trans-unit id="c6a1267eacc3c912d76fd037d987680a5762ee68" translate="yes" xml:space="preserve">
          <source>Don't assume that write/modify permission on a directory gives the right to add or delete files/directories in that directory. That is filesystem specific: in some filesystems you need write/modify permission also (or even just) in the file/directory itself. In some filesystems (AFS, DFS) the permission to add/delete directory entries is a completely separate permission.</source>
          <target state="translated">不要以为在一个目录上的写/修改权限赋予了在该目录中添加或删除文件/目录的权利。这是与文件系统有关的:在一些文件系统中,你需要在文件/目录本身也有写/修改权限(甚至只是)。在一些文件系统中(AFS,DFS),添加/删除目录条目的权限是一个完全独立的权限。</target>
        </trans-unit>
        <trans-unit id="445d23235b8dff3b578e3bb5bf0fc30d1a0490ac" translate="yes" xml:space="preserve">
          <source>Don't assume that you can ping hosts and get replies.</source>
          <target state="translated">不要以为可以ping主机就能得到回复。</target>
        </trans-unit>
        <trans-unit id="b1edc420b94bcf10bf4d8c3ee5b511b8b1bd17fb" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach outside world through any other port than 80, or some web proxy. ftp is blocked by many firewalls.</source>
          <target state="translated">不要以为你可以通过80端口以上的其他端口,或者一些网络代理服务器到达外界,ftp被许多防火墙封锁。</target>
        </trans-unit>
        <trans-unit id="c31864fe8f7fd5417d78f831be7f49971ddfa830" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach the public Internet.</source>
          <target state="translated">不要以为你可以到达公共互联网。</target>
        </trans-unit>
        <trans-unit id="e3635e84ac318882496643a11d43ff013c114f31" translate="yes" xml:space="preserve">
          <source>Don't assume that you can reach yourself or any node by the name 'localhost'. The same goes for '127.0.0.1'. You will have to try both.</source>
          <target state="translated">不要以为你可以通过'localhost'这个名字到达自己或任何节点。'127.0.0.1'也是一样。你必须同时尝试这两种方法。</target>
        </trans-unit>
        <trans-unit id="94e84b069d17212c205601cb91a4bdb912d4357e" translate="yes" xml:space="preserve">
          <source>Don't assume that you can send email by connecting to the local SMTP port.</source>
          <target state="translated">不要以为连接到本地SMTP端口就可以发送邮件。</target>
        </trans-unit>
        <trans-unit id="93ae10616af2ea19ea7f8a1f9e13d6eb9fc81add" translate="yes" xml:space="preserve">
          <source>Don't assume the Unix filesystem access semantics: the operating system or the filesystem may be using some ACL systems, which are richer languages than the usual &lt;code&gt;rwx&lt;/code&gt; . Even if the &lt;code&gt;rwx&lt;/code&gt; exist, their semantics might be different.</source>
          <target state="translated">不要假定Unix文件系统具有访问语义：操作系统或文件系统可能正在使用某些ACL系统，这些系统的语言比通常的 &lt;code&gt;rwx&lt;/code&gt; 更丰富。即使 &lt;code&gt;rwx&lt;/code&gt; 存在，它们的语义也可能不同。</target>
        </trans-unit>
        <trans-unit id="f793b546a43c7fdfddcd37819e15f770633a875c" translate="yes" xml:space="preserve">
          <source>Don't assume the Unix user and group semantics: especially, don't expect &lt;code&gt;$&amp;lt;&lt;/code&gt; and &lt;code&gt;$&amp;gt;&lt;/code&gt; (or &lt;code&gt;$(&lt;/code&gt; and &lt;code&gt;$)&lt;/code&gt; ) to work for switching identities (or memberships).</source>
          <target state="translated">不要假定Unix用户和组的语义：尤其是不要期望 &lt;code&gt;$&amp;lt;&lt;/code&gt; 和 &lt;code&gt;$&amp;gt;&lt;/code&gt; （或 &lt;code&gt;$(&lt;/code&gt; 和 &lt;code&gt;$)&lt;/code&gt; ）可用于切换身份（或成员资格）。</target>
        </trans-unit>
        <trans-unit id="de83ff9adf0f76046a05e27193105138389e30d8" translate="yes" xml:space="preserve">
          <source>Don't be afraid to use loop labels--they're there to enhance readability as well as to allow multilevel loop breaks. See the previous example.</source>
          <target state="translated">不要害怕使用循环标签--这些标签的作用是提高可读性以及允许多级循环的中断。请看前面的例子。</target>
        </trans-unit>
        <trans-unit id="789665e74c277d58dbd4bc3f085faf66c237708c" translate="yes" xml:space="preserve">
          <source>Don't be fooled into thinking that it is hard to create portable Perl code. It isn't. Perl tries its level-best to bridge the gaps between what's available on different platforms, and all the means available to use those features. Thus almost all Perl code runs on any machine without modification. But there are some significant issues in writing portable code, and this document is entirely about those issues.</source>
          <target state="translated">不要被愚弄,以为创建可移植的Perl代码很难。其实不然。Perl 尽力弥合不同平台上可用的功能和所有可用的方法之间的差距。因此,几乎所有的Perl代码都可以在任何机器上运行,无需修改。但是,在编写可移植代码时存在一些重大问题,本文档完全是关于这些问题的。</target>
        </trans-unit>
        <trans-unit id="e9382c68d62f11f58c0e0116d77660fc6a3b3ba4" translate="yes" xml:space="preserve">
          <source>Don't blame Perl. It's the same as in C. IEEE says we have to do this. Perl numbers whose absolute values are integers under 2**31 (on 32-bit machines) will work pretty much like mathematical integers. Other numbers are not guaranteed.</source>
          <target state="translated">不要责怪Perl,这和C语言一样。这和C语言一样,IEEE说我们必须这样做。Perl中绝对值是2**31以下的整数的数字(在32位机器上),其工作原理和数学整数差不多。其他的数字就不能保证了。</target>
        </trans-unit>
        <trans-unit id="774b4dd48a669835b4126c2772387c78ce9c98be" translate="yes" xml:space="preserve">
          <source>Don't bother using &lt;code&gt;trailingData&lt;/code&gt; if the input is a filename.</source>
          <target state="translated">如果输入是文件名，请不要使用 &lt;code&gt;trailingData&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b0a9f3aafe7e01341dfe674e6e343efc8bbb76" translate="yes" xml:space="preserve">
          <source>Don't change this variable unless you &lt;b&gt;really&lt;/b&gt; know what you're doing.</source>
          <target state="translated">除非您&lt;b&gt;真的&lt;/b&gt;知道自己在做什么，否则不要更改此变量。</target>
        </trans-unit>
        <trans-unit id="bf3d8d6437b2fb83642a1fd7abe5420705d405dd" translate="yes" xml:space="preserve">
          <source>Don't count on a specific environment variable existing in &lt;code&gt;%ENV&lt;/code&gt; . Don't count on &lt;code&gt;%ENV&lt;/code&gt; entries being case-sensitive, or even case-preserving. Don't try to clear &lt;code&gt;%ENV&lt;/code&gt; by saying &lt;code&gt;%ENV = ();&lt;/code&gt; , or, if you really have to, make it conditional on &lt;code&gt;$^O ne 'VMS'&lt;/code&gt; since in VMS the &lt;code&gt;%ENV&lt;/code&gt; table is much more than a per-process key-value string table.</source>
          <target state="translated">不要指望 &lt;code&gt;%ENV&lt;/code&gt; 中存在的特定环境变量。不要指望 &lt;code&gt;%ENV&lt;/code&gt; 条目区分大小写，甚至不区分大小写。不要通过说 &lt;code&gt;%ENV = ();&lt;/code&gt; 来清除 &lt;code&gt;%ENV&lt;/code&gt; ；，或者，如果确实需要，请使其成为 &lt;code&gt;$^O ne 'VMS'&lt;/code&gt; 条件，因为在VMS中， &lt;code&gt;%ENV&lt;/code&gt; 表比每个进程的键值字符串表要多得多。</target>
        </trans-unit>
        <trans-unit id="037f7905f794172b9aa798cbaa7cfb0372b5498b" translate="yes" xml:space="preserve">
          <source>Don't count on filename globbing. Use &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">不要指望文件名泛滥。请改用 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8d15e2d76caf019a3701f78e8198d57683e81f9" translate="yes" xml:space="preserve">
          <source>Don't count on per-program environment variables, or per-program current directories.</source>
          <target state="translated">不要指望每个程序的环境变量,或者每个程序的当前目录。</target>
        </trans-unit>
        <trans-unit id="660cbdd54752be68a4dc2ccd79e3477dc980f960" translate="yes" xml:space="preserve">
          <source>Don't count on signals or &lt;code&gt;%SIG&lt;/code&gt; for anything.</source>
          <target state="translated">不要指望任何信号或 &lt;code&gt;%SIG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2504f73349f543cd4ab97266d28a299e9f5178ef" translate="yes" xml:space="preserve">
          <source>Don't count on specific values of &lt;code&gt;$!&lt;/code&gt; , neither numeric nor especially the string values. Users may switch their locales causing error messages to be translated into their languages. If you can trust a POSIXish environment, you can portably use the symbols defined by the &lt;code&gt;Errno&lt;/code&gt; module, like &lt;code&gt;ENOENT&lt;/code&gt; . And don't trust on the values of &lt;code&gt;$!&lt;/code&gt; at all except immediately after a failed system call.</source>
          <target state="translated">不要指望 &lt;code&gt;$!&lt;/code&gt; 特定值！，既不是数字的，也不是字符串值。用户可以切换其语言环境，从而将错误消息翻译成他们的语言。如果您可以信任POSIXish环境，则可以方便地使用 &lt;code&gt;Errno&lt;/code&gt; 模块定义的符号，例如 &lt;code&gt;ENOENT&lt;/code&gt; 。并且不要相信 &lt;code&gt;$!&lt;/code&gt; 的值！除了系统调用失败后立即执行。</target>
        </trans-unit>
        <trans-unit id="d29e3f7d07b96795819a57e76db3864389865c2f" translate="yes" xml:space="preserve">
          <source>Don't direct the users of your module to download &lt;code&gt;Devel::PPPort&lt;/code&gt; . They are most probably no XS writers. Also, don't make</source>
          <target state="translated">不要指导您模块的用户下载 &lt;code&gt;Devel::PPPort&lt;/code&gt; 。他们很可能不是XS作家。另外，不要</target>
        </trans-unit>
        <trans-unit id="4c8b6f86bbfc2b6c173c74faf597f3f3d4ca2dc7" translate="yes" xml:space="preserve">
          <source>Don't display</source>
          <target state="translated">不要显示</target>
        </trans-unit>
        <trans-unit id="c1e22de2ba66c0889226c5735ba53c5285571154" translate="yes" xml:space="preserve">
          <source>Don't display mostly harmless warning messages.</source>
          <target state="translated">不要显示大部分无害的警告信息。</target>
        </trans-unit>
        <trans-unit id="1547fa551c603cca7def3259e5b1fd45d8dbc6f8" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of using a &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; when a simple &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; would do. The &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; is more efficient and less error prone.</source>
          <target state="translated">当简单的 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 可以使用时，不要陷入使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的陷阱。在 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 效率更高，不容易出错。</target>
        </trans-unit>
        <trans-unit id="29cf7dc4de80fc368eaed82cbb02b8b6d7166fa2" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of using a &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; when a simple &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; would do. The &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; is more efficient and less error prone.</source>
          <target state="translated">当简单的 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 可以使用时，不要陷入使用 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的陷阱。在 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 效率更高，不容易出错。</target>
        </trans-unit>
        <trans-unit id="2de68b400b15f729bfc2845f7ab8c8768fb9196d" translate="yes" xml:space="preserve">
          <source>Don't fall into the trap of writing for the wrong audience. Your primary audience is a reasonably experienced developer with at least a moderate understanding of your module's application domain, who's just downloaded your module and wants to start using it as quickly as possible.</source>
          <target state="translated">不要落入为错误的受众写作的陷阱。您的主要受众是一个有合理经验的开发人员,至少对您的模块的应用领域有一定的了解,他们刚刚下载了您的模块并希望尽快开始使用它。</target>
        </trans-unit>
        <trans-unit id="f7e449fde074df52d869952df1fc18793a8a93fc" translate="yes" xml:space="preserve">
          <source>Don't forget the exceptional, pathological cases.</source>
          <target state="translated">不要忘记那些特殊的、病态的案例。</target>
        </trans-unit>
        <trans-unit id="b1e51289079b4f632343c894dc7cce8050066f98" translate="yes" xml:space="preserve">
          <source>Don't forget to</source>
          <target state="translated">不要忘了</target>
        </trans-unit>
        <trans-unit id="3e6739c8879bd9d08b76ade5df931676453f506a" translate="yes" xml:space="preserve">
          <source>Don't go through silly contortions to exit a loop at the top or the bottom, when Perl provides the &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; operator so you can exit in the middle. Just &quot;outdent&quot; it a little to make it more visible:</source>
          <target state="translated">当Perl提供 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 运算符时，不要经过愚蠢的扭曲而在顶部或底部退出循环，这样您就可以在中间退出。只是&amp;ldquo;突出&amp;rdquo;一点，使其更加可见：</target>
        </trans-unit>
        <trans-unit id="f24938e6209641248330c946317ddd16f85839df" translate="yes" xml:space="preserve">
          <source>Don't just present an example without explaining what it does. Adding a short paragraph saying what the example will do can increase the value of the example immensely.</source>
          <target state="translated">不要只介绍一个例子而不解释它的作用。加一段简短的文字,说说这个例子会有什么作用,可以大大增加例子的价值。</target>
        </trans-unit>
        <trans-unit id="af2f3b7627d5c9318a43fdf0c7ed8eb29f6f63df" translate="yes" xml:space="preserve">
          <source>Don't mix filtered &amp;amp; non-filtered data in the same database file.</source>
          <target state="translated">请勿在同一数据库文件中混用已过滤和未过滤的数据。</target>
        </trans-unit>
        <trans-unit id="9bfaee9208ed0b4080e76b49f7092be9da21317d" translate="yes" xml:space="preserve">
          <source>Don't open the same file more than once at a time for writing, as some operating systems put mandatory locks on such files.</source>
          <target state="translated">不要一次不止一次地打开同一个文件进行写入,因为有些操作系统会对这类文件进行强制锁。</target>
        </trans-unit>
        <trans-unit id="13d0e6ad295f2f5fa4a0e1c2294ab660c2ff68f2" translate="yes" xml:space="preserve">
          <source>Don't output the &quot;(definitions)&quot; sections.</source>
          <target state="translated">不要输出&quot;(定义)&quot;部分。</target>
        </trans-unit>
        <trans-unit id="8760a0137fe661818eb2724e50d3c58a224e6f3d" translate="yes" xml:space="preserve">
          <source>Don't put &quot;=head</source>
          <target state="translated">不要写&quot;=头&quot;。</target>
        </trans-unit>
        <trans-unit id="ad5ea38ded2263705342205dafdb4799d4e0a15b" translate="yes" xml:space="preserve">
          <source>Don't quote large strings unless absolutely necessary:</source>
          <target state="translated">除非绝对必要,否则不要引用大字符串。</target>
        </trans-unit>
        <trans-unit id="f5cf2886b363988134aefd1d621d74fc94b6b465" translate="yes" xml:space="preserve">
          <source>Don't re-invent the wheel</source>
          <target state="translated">不要重新发明轮子</target>
        </trans-unit>
        <trans-unit id="81177c27776c8009338c295142a35e130e198399" translate="yes" xml:space="preserve">
          <source>Don't read an entire file into memory if you can process it line by line. Or more concretely, use a loop like this:</source>
          <target state="translated">如果你能逐行处理,就不要把整个文件读到内存中。或者更具体地说,使用像这样的循环。</target>
        </trans-unit>
        <trans-unit id="a35797b1a1b72b9841ad51955b9000b5a1529ffb" translate="yes" xml:space="preserve">
          <source>Don't require every module user to jump through the same hoops to achieve a simple result. You can always include optional parameters or routines for more complex or non-standard behaviour. If most of your users have to type a few almost identical lines of code when they start using your module, it's a sign that you should have made that behaviour a default. Another good indicator that you should use defaults is if most of your users call your routines with the same arguments.</source>
          <target state="translated">不要要求每个模块用户都要跳过同样的圈子来实现一个简单的结果。你总是可以包含可选的参数或例程来实现更复杂或非标准的行为。如果你的大多数用户在开始使用你的模块时,必须输入几行几乎相同的代码,这说明你应该把这种行为作为默认值。另一个你应该使用默认值的指标是,如果你的大多数用户都用同样的参数来调用你的例程。</target>
        </trans-unit>
        <trans-unit id="c723f7c592b67ddf269e14e867541435896967e5" translate="yes" xml:space="preserve">
          <source>Don't scan for the found substrings.</source>
          <target state="translated">不要扫描找到的子串。</target>
        </trans-unit>
        <trans-unit id="d6fcbb0953d0c44b0d3d4321526cee5c66bebf52" translate="yes" xml:space="preserve">
          <source>Don't send a bug received acknowledgement to the reply address. Generally it is only a sensible to use this option if you are a perl maintainer actively watching perl porters for your message to arrive.</source>
          <target state="translated">不要向回复地址发送 bug 收到确认。一般来说,只有当您是一个积极关注 perl porters 的维护者时,使用这个选项才是明智的。</target>
        </trans-unit>
        <trans-unit id="22920608692f0a3432e5ce4c9717be87d806f116" translate="yes" xml:space="preserve">
          <source>Don't send copy to administrator.</source>
          <target state="translated">不要把副本发给管理员。</target>
        </trans-unit>
        <trans-unit id="4bc7424f428b4c2b286895e2bee1c1badf45b0f9" translate="yes" xml:space="preserve">
          <source>Don't think about it too much.</source>
          <target state="translated">不要想太多。</target>
        </trans-unit>
        <trans-unit id="e145223fc51004b2dae0ceec37468cb3be4a2528" translate="yes" xml:space="preserve">
          <source>Don't think that you can get the address of a Perl variable when it is stored as an integer or double number! &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('P', $x)&lt;/code&gt; will force the variable's internal representation to string, just as if you had written something like &lt;code&gt;$x .= ''&lt;/code&gt; .</source>
          <target state="translated">不要以为Perl变量以整数或双数形式存储就可以获得地址！ &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('P', $x)&lt;/code&gt; 将强制变量的内部表示形式为字符串，就像您编写了 &lt;code&gt;$x .= ''&lt;/code&gt; 类的东西一样。</target>
        </trans-unit>
        <trans-unit id="5c0c8af6f9c4025d7dc7e616e0715698cd40e403" translate="yes" xml:space="preserve">
          <source>Don't try to clear &lt;code&gt;%ENV&lt;/code&gt; by saying &lt;code&gt;%ENV = ();&lt;/code&gt; , it will throw a fatal error. This is equivalent to doing the following from DCL:</source>
          <target state="translated">不要通过说 &lt;code&gt;%ENV = ();&lt;/code&gt; 来清除 &lt;code&gt;%ENV&lt;/code&gt; ；，它将引发致命错误。这等效于从DCL执行以下操作：</target>
        </trans-unit>
        <trans-unit id="ed025c55f145c736fa2b816ded97f2454d7a958f" translate="yes" xml:space="preserve">
          <source>Don't try to do this:</source>
          <target state="translated">不要试图这样做。</target>
        </trans-unit>
        <trans-unit id="6dcb6f3c6b552350b94a3e90424b7771b163de66" translate="yes" xml:space="preserve">
          <source>Don't use &quot;=item&quot;s outside of an &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">不要在&quot;=over&quot;...&quot;=back &quot;区域外使用&quot;=item&quot;。&quot;=back &quot;区域外使用&quot;=item&quot;。</target>
        </trans-unit>
        <trans-unit id="a7de6cdfcbff257732efdc95079781ff79434e7b" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;:&lt;/code&gt; as a part of a filename since many systems use that for their own semantics (Mac OS Classic for separating pathname components, many networking schemes and utilities for separating the nodename and the pathname, and so on). For the same reasons, avoid &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">不要使用 &lt;code&gt;:&lt;/code&gt; 作为文件名的一部分，因为许多系统将其用于自己的语义（Mac OS Classic用于分隔路径名组件，许多联网方案和实用程序用于分隔节点名和路径名，依此类推）。出于同样的原因，避免 &lt;code&gt;@&lt;/code&gt; ， &lt;code&gt;;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd80fb1475bf587607bf23dcb48492b2994f3826" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; to abort a subroutine if there's any chance that someone might want to trap whatever error happened. Use &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead, which can be trapped by an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果有人可能想捕获发生的任何错误，请不要使用 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 终止子例程。请改用 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，它可以被 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 困住。</target>
        </trans-unit>
        <trans-unit id="4ae3e40c5aafd256eca74b7ca54a5e5fe01a8a09" translate="yes" xml:space="preserve">
          <source>Don't use &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; to abort a subroutine if there's any chance that someone might want to trap whatever error happened. Use &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead, which can be trapped by an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果有人可能想捕获发生的任何错误，请不要使用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 终止子例程。请改用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，它可以被 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 困住。</target>
        </trans-unit>
        <trans-unit id="4cae11462d2674103d0d8e77ff3c2d3bb81f328e" translate="yes" xml:space="preserve">
          <source>Don't use it. It makes no sense to deal with bytes in a text string, and it makes no sense to deal with characters in a byte string. Do the proper conversions (by decoding/encoding), and things will work out well: you get character counts for decoded data, and byte counts for encoded data.</source>
          <target state="translated">不要使用它。处理文本串中的字节没有意义,处理字节串中的字符也没有意义。做适当的转换(通过解码/编码),事情就会很好解决:你会得到解码数据的字符数,以及编码数据的字节数。</target>
        </trans-unit>
        <trans-unit id="31a008400a1239308283e11c2496113f4c495814" translate="yes" xml:space="preserve">
          <source>Don't use it. Unfortunately, it assumes that the programmer's environment and that of the user will use the same encoding. It will use the same encoding for the source code and for STDIN and STDOUT. When a program is copied to another machine, the source code does not change, but the STDIO environment might.</source>
          <target state="translated">不要使用它。不幸的是,它假设程序员的环境和用户的环境使用相同的编码。它将对源代码以及STDIN和STDOUT使用相同的编码。当一个程序被复制到另一台机器上时,源代码不会改变,但STDIO环境可能会改变。</target>
        </trans-unit>
        <trans-unit id="c9b01c21ad5ce16a7981e3294ccf4cf41b5fef04" translate="yes" xml:space="preserve">
          <source>Don't use this module directly.</source>
          <target state="translated">不要直接使用这个模块。</target>
        </trans-unit>
        <trans-unit id="71ee42da50b79ae9e6a47caf180fc6688aabc5ce" translate="yes" xml:space="preserve">
          <source>Don't use this.</source>
          <target state="translated">不要用这个。</target>
        </trans-unit>
        <trans-unit id="d8022c54cffc7dadfd83dedf1e4a2dbf6ad467e8" translate="yes" xml:space="preserve">
          <source>Don't worry about posting if you can't say when the module will be ready - just say so in the message. It might be worth inviting others to help you, they may be able to complete it for you!</source>
          <target state="translated">如果你不能说模块什么时候准备好,不用担心发帖--只要在留言中说一声就可以了。也许值得邀请其他人来帮助你,他们也许能够为你完成它。</target>
        </trans-unit>
        <trans-unit id="327df9e94148631e3c9a41cfa753d9d2769d418a" translate="yes" xml:space="preserve">
          <source>Don't worry if it says Math::BigInt::Lite, bignum and friends will use Lite if it is installed since it is faster for some operations. It will be automatically upgraded to BigInt whenever necessary:</source>
          <target state="translated">如果说Math::BigInt::Lite,不用担心,bignum和朋友们如果安装了Lite,就会使用Lite,因为它对某些操作来说更快。只要有需要,它就会自动升级到BigInt。</target>
        </trans-unit>
        <trans-unit id="83fe6a1f79295f6f6329274881574682cc33b843" translate="yes" xml:space="preserve">
          <source>Done by Archive::Tar internally when reading the tar file: validate the header against the checksum to ensure integer tar file.</source>
          <target state="translated">在读取 tar 文件时由 Archive::Tar 在内部完成:根据校验和验证头以确保 tar 文件是整数。</target>
        </trans-unit>
        <trans-unit id="9b0acdbd029a7828ca595b0d9f7618bd97d3679c" translate="yes" xml:space="preserve">
          <source>Dotfiles.pm</source>
          <target state="translated">Dotfiles.pm</target>
        </trans-unit>
        <trans-unit id="b17ae50dd8754e17c2584e6a5426d3fcdb608cdb" translate="yes" xml:space="preserve">
          <source>Double quotes indicate that the text will be interpolated using exactly the same rules as normal double quoted strings.</source>
          <target state="translated">双引号表示文本将使用与普通双引号字符串完全相同的规则进行插值。</target>
        </trans-unit>
        <trans-unit id="d8bdee99b293542316fa229d2907bcacda4feae8" translate="yes" xml:space="preserve">
          <source>Double quotes or single quotes may be used around literal strings:</source>
          <target state="translated">字符串周围可以使用双引号或单引号。</target>
        </trans-unit>
        <trans-unit id="c45e85fa2adbda8304a1994b69613855b231b88d" translate="yes" xml:space="preserve">
          <source>Double-Typed SVs</source>
          <target state="translated">双型SV</target>
        </trans-unit>
        <trans-unit id="bc0859619112e37c2df7dc4b11b4c4a86c663786" translate="yes" xml:space="preserve">
          <source>Doug MacEachern &amp;lt;&lt;code&gt;dougm@osf.org&lt;/code&gt; &amp;gt;</source>
          <target state="translated">道格&amp;middot; &lt;code&gt;dougm@osf.org&lt;/code&gt; （Doug MacEachern）&amp;lt; dougm@osf.org &amp;gt;</target>
        </trans-unit>
        <trans-unit id="ebd84c7c0c73cf64e66299d99641345c7d6ec4c9" translate="yes" xml:space="preserve">
          <source>Doug MacEachern has an article on embedding in Volume 1, Issue 4 of The Perl Journal ( &lt;a href=&quot;http://www.tpj.com/&quot;&gt;http://www.tpj.com/&lt;/a&gt; ). Doug is also the developer of the most widely-used Perl embedding: the mod_perl system (perl.apache.org), which embeds Perl in the Apache web server. Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl have used this model for Oracle, Netscape and Internet Information Server Perl plugins.</source>
          <target state="translated">Doug MacEachern在The Perl Journal（&lt;a href=&quot;http://www.tpj.com/&quot;&gt;http://www.tpj.com/&lt;/a&gt;）的第1卷第4期中嵌入了一篇文章。 Doug还是最广泛使用的Perl嵌入程序的开发者：mod_perl系统（perl.apache.org），该系统将Perl嵌入Apache Web服务器中。 Oracle，Binary Evolution，ActiveState和Ben Sugars的nsapi_perl已将此模型用于Oracle，Netscape和Internet Information Server Perl插件。</target>
        </trans-unit>
        <trans-unit id="efd9fe42018c0e9681fed6f906ad1da72ef74937" translate="yes" xml:space="preserve">
          <source>Down this road lies madness.</source>
          <target state="translated">沿着这条路,就是疯狂。</target>
        </trans-unit>
        <trans-unit id="711e55a0520f6b8eb41cd3adf5cf2f6dfb3f33d2" translate="yes" xml:space="preserve">
          <source>Downgrade existing SSL connection back to plain. This is needed to work with some FTP helpers at firewalls, which need to see the PORT and PASV commands and responses to dynamically open the necessary ports. In this case &lt;code&gt;starttls&lt;/code&gt; is usually only done to protect the authorization.</source>
          <target state="translated">将现有的SSL连接降级到普通状态。与防火墙上的某些FTP帮助程序一起使用时需要这样做，这些帮助程序需要查看PORT和PASV命令以及响应以动态打开必要的端口。在这种情况下，通常只会执行 &lt;code&gt;starttls&lt;/code&gt; 来保护授权。</target>
        </trans-unit>
        <trans-unit id="6863ad3882079de8bb32abea0819f1a0f48ff477" translate="yes" xml:space="preserve">
          <source>Download and install the Filter::Simple module. (If you have Perl 5.7.1 or later, this is already done for you.)</source>
          <target state="translated">下载并安装 Filter::Simple 模块。(如果您使用的是Perl 5.7.1或更高版本,这已经为您完成了。)</target>
        </trans-unit>
        <trans-unit id="026541fe8b438be29a9f47a4ab1e22dcb6dbc643" translate="yes" xml:space="preserve">
          <source>Download target directory?</source>
          <target state="translated">下载目标目录?</target>
        </trans-unit>
        <trans-unit id="824b6b54054ef1a9091856d053b0662e9a165ca3" translate="yes" xml:space="preserve">
          <source>Download the ExtUtils::Embed kit from CPAN and run `make test'. If the tests pass, read the pods again and again and again. If they fail, see &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; and send a bug report with the output of &lt;code&gt;make test TEST_VERBOSE=1&lt;/code&gt; along with &lt;code&gt;perl -V&lt;/code&gt; .</source>
          <target state="translated">从CPAN下载ExtUtils :: Embed套件并运行&amp;ldquo; make test&amp;rdquo;。如果测试通过，请一次又一次地读取豆荚。如果失败，请参阅&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;并发送带有 &lt;code&gt;make test TEST_VERBOSE=1&lt;/code&gt; 的输出以及 &lt;code&gt;perl -V&lt;/code&gt; 的错误报告。</target>
        </trans-unit>
        <trans-unit id="3467811ada73635cf68082c7cc090eea63c880e2" translate="yes" xml:space="preserve">
          <source>Download the files in the desired version of Unicode from the Unicode web site &lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;). These should replace the existing files in</source>
          <target state="translated">从Unicode网站&lt;a href=&quot;http://www.unicode.org&quot;&gt;http://www.unicode.org&lt;/a&gt;下载所需Unicode版本的文件。这些应该替换现有的文件</target>
        </trans-unit>
        <trans-unit id="c1b64de29b8a9bf6464d6b725c2720abd75c3426" translate="yes" xml:space="preserve">
          <source>Download the pmd-bin-X.Y.zip () from the SourceForge site, extract the pmd-X.Y.jar from it, and then run that on source code thusly:</source>
          <target state="translated">从SourceForge网站上下载pmd-bin-X.Y.zip(),从中解压pmd-X.Y.jar,然后在源码上运行,如下图所示。</target>
        </trans-unit>
        <trans-unit id="e49fb030ab1aaee57147e5e7a7127ea439db8792" translate="yes" xml:space="preserve">
          <source>Download, build, and install the Filter::Util::Call module. (If you have Perl 5.7.1 or later, this is already done for you.)</source>
          <target state="translated">下载、构建并安装Filter::Util::Call模块。(如果你有Perl 5.7.1或更高版本,这已经为你完成了。)</target>
        </trans-unit>
        <trans-unit id="08f4aa0358a86ec0353cf2d2ed049201bf17031c" translate="yes" xml:space="preserve">
          <source>Downloads report data for this distribution from www.cpantesters.org and displays a subset of them.</source>
          <target state="translated">从www.cpantesters.org 下载该分布的报告数据,并显示其中的一个子集。</target>
        </trans-unit>
        <trans-unit id="366a5eddbaecc6160b117d778c095e50de4e854c" translate="yes" xml:space="preserve">
          <source>Downloads the README file associated with a distribution and runs it through the pager specified in &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; .</source>
          <target state="translated">下载与发行版关联的README文件，并通过 &lt;code&gt;$CPAN::Config-&amp;gt;{pager}&lt;/code&gt; 指定的寻呼机运行它。</target>
        </trans-unit>
        <trans-unit id="6d9c288326280b540c25926e9df585a7d06577d9" translate="yes" xml:space="preserve">
          <source>Downloads the distribution from CPAN and unpacks it. Does nothing if the distribution has already been downloaded and unpacked within the current session.</source>
          <target state="translated">从CPAN下载发行版并解压。如果该发行版已经在当前会话中被下载和解压,则不做任何操作。</target>
        </trans-unit>
        <trans-unit id="8b9ffede701ef3f70bd821cb754750834e2eee96" translate="yes" xml:space="preserve">
          <source>Downloads the pod documentation of the file associated with a distribution (in HTML format) and runs it through the external command</source>
          <target state="translated">下载与发行版相关联的文件的 pod 文档(HTML 格式),并通过外部命令运行它</target>
        </trans-unit>
        <trans-unit id="47d8215ef4fc8a530cd9137d652dba538ecf4224" translate="yes" xml:space="preserve">
          <source>Draw the tree with standard ASCII characters like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;. These don't look as clean as the VT100 characters, but they'll work with almost any terminal (or the horizontal scrolling mode of less(1)) and are suitable for text documentation or email. This is the default.</source>
          <target state="translated">用标准ASCII字符（例如 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; )绘制树 。这些看起来不像VT100字符那么干净，但是它们几乎可以在任何终端上使用（或less（1）的水平滚动模式），并且适合于文本文档或电子邮件。这是默认值。</target>
        </trans-unit>
        <trans-unit id="435321dd1c82c18e50a09e89a625d44c2cad992d" translate="yes" xml:space="preserve">
          <source>Due to a bug in Perl, &lt;code&gt;autodie&lt;/code&gt; may &quot;lose&quot; any format which has the same name as an autodying built-in or function.</source>
          <target state="translated">由于Perl中的错误，自动 &lt;code&gt;autodie&lt;/code&gt; 可能会&amp;ldquo;丢失&amp;rdquo;与自动内置或功能名称相同的任何格式。</target>
        </trans-unit>
        <trans-unit id="6f8b083c9efdbb98335cadbb85143fc7af77ce11" translate="yes" xml:space="preserve">
          <source>Due to a popular demand the perl external program calling has been changed wrt Andreas Kaiser's port.</source>
          <target state="translated">由于普遍的需求,perl 外部程序的调用已经改变了 Andreas Kaiser 的 port。</target>
        </trans-unit>
        <trans-unit id="2fa72b6c00f9a2dd66e6782d6e7396b6679249ff" translate="yes" xml:space="preserve">
          <source>Due to an implementation glitch, the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;. Do not use this to rewrite a pending exception in &lt;code&gt;$@&lt;/code&gt; , or as a bizarre substitute for overriding &lt;code&gt;CORE::GLOBAL::die()&lt;/code&gt; . This strange action at a distance may be fixed in a future release so that &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is only called if your program is about to exit, as was the original intent. Any other use is deprecated.</source>
          <target state="translated">由于实现故障，甚至在 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 内部也调用了 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 钩子。不要用它重写 &lt;code&gt;$@&lt;/code&gt; 的未决异常，也不要用它替代 &lt;code&gt;CORE::GLOBAL::die()&lt;/code&gt; 。将来的发行版中可能会解决这一遥远的奇怪操作，因此仅当您的程序即将退出时才调用 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; ，这与原始意图相同。不建议任何其他用途。</target>
        </trans-unit>
        <trans-unit id="c65e636e9846e4e76451103ccccbb36e90580ce5" translate="yes" xml:space="preserve">
          <source>Due to an unfortunate bug in how &lt;code&gt;given&lt;/code&gt; was implemented between Perl 5.10 and 5.16, under those implementations the version of &lt;code&gt;$_&lt;/code&gt; governed by &lt;code&gt;given&lt;/code&gt; is merely a lexically scoped copy of the original, not a dynamically scoped alias to the original, as it would be if it were a &lt;code&gt;foreach&lt;/code&gt; or under both the original and the current Perl 6 language specification. This bug was fixed in Perl 5.18. If you really want a lexical &lt;code&gt;$_&lt;/code&gt; , specify that explicitly, but note that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; is now deprecated and will warn unless warnings have been disabled:</source>
          <target state="translated">由于不幸的是在Perl 5.10和5.16之间实现了 &lt;code&gt;given&lt;/code&gt; 错误，在这些实现下，由 &lt;code&gt;given&lt;/code&gt; 的 &lt;code&gt;$_&lt;/code&gt; 版本只是原始单词的词法范围副本，而不是原始对象的动态范围别名。如果是 &lt;code&gt;foreach&lt;/code&gt; 或同时符合原始和当前的Perl 6语言规范。此错误已在Perl 5.18中修复。如果您真的想要一个词法 &lt;code&gt;$_&lt;/code&gt; ，请明确指定，但是请注意， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; $ _现在已被弃用，并且会发出警告，除非禁用了警告：</target>
        </trans-unit>
        <trans-unit id="a5aff89951fd9e95c733a40d7b1bb49174fdbcb8" translate="yes" xml:space="preserve">
          <source>Due to backwards compatibility, all filehandles resemble objects of class &lt;code&gt;IO::Handle&lt;/code&gt; , or actually classes derived from that class. They actually aren't. Which means you can't derive your own class from &lt;code&gt;IO::Handle&lt;/code&gt; and inherit those methods.</source>
          <target state="translated">由于向后兼容，所有文件句柄都类似于 &lt;code&gt;IO::Handle&lt;/code&gt; 类的对象，或者实际上是从该类派生的类。他们实际上不是。这意味着您不能从 &lt;code&gt;IO::Handle&lt;/code&gt; 派生自己的类并继承那些方法。</target>
        </trans-unit>
        <trans-unit id="46599dc97579c3a9d5b0ac13818c4864629c3a1b" translate="yes" xml:space="preserve">
          <source>Due to how subtests work, you may omit a plan if you desire. This adds an implicit &lt;code&gt;done_testing()&lt;/code&gt; to the end of your subtest. The following two subtests are equivalent:</source>
          <target state="translated">由于子测试的工作方式，如果您愿意，可以省略计划。这会在子 &lt;code&gt;done_testing()&lt;/code&gt; 的末尾添加一个隐式的done_testing（）。以下两个子测试是等效的：</target>
        </trans-unit>
        <trans-unit id="bfabb840ac564314e7376483141ead0d401f2f7b" translate="yes" xml:space="preserve">
          <source>Due to issues with various CPUs, math libraries, compilers, and standards, results for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; may vary depending on any combination of the above. Perl attempts to conform to the Open Group/IEEE standards for the results returned from &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt;, but cannot force the issue if the system Perl is run on does not allow it. (Tru64, HP-UX 10.20)</source>
          <target state="translated">由于各种CPU，数学库，编译器和标准的问题， &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 的结果可能会根据上述任意组合而有所不同。对于从 &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2()&lt;/a&gt;&lt;/code&gt; 返回的结果，Perl尝试符合Open Group / IEEE标准，但是如果运行系统Perl不允许这样做，则不能强制执行此问题。（Tru64，HP-UX 10.20）</target>
        </trans-unit>
        <trans-unit id="68391d1e9af605eed85ca89bb210a2cba148458c" translate="yes" xml:space="preserve">
          <source>Due to limitations of Perl subroutine call semantics, you cannot pass an array or hash. Prepend it with a &lt;code&gt;\&lt;/code&gt; to pass its reference instead. This will be remedied in time, now that Perl has subroutine prototypes. For now, you need to use the extended usage form, and prepend the name with a &lt;code&gt;*&lt;/code&gt; to output it as a hash or array.</source>
          <target state="translated">由于Perl子例程调用语义的限制，您不能传递数组或哈希。前面加一个 &lt;code&gt;\&lt;/code&gt; 即可传递其引用。由于Perl具有子例程原型，因此这将得到及时纠正。现在，您需要使用扩展用法表格，并在名称前加上 &lt;code&gt;*&lt;/code&gt; ,以将其输出为哈希或数组。</target>
        </trans-unit>
        <trans-unit id="b463757edb0c11231cc7018f0eaae187fe6e4840" translate="yes" xml:space="preserve">
          <source>Due to popular demand, 'MIME-Header-ISO_2022_JP' was introduced by Makamaka. Thre are still too many MUAs especially cellular phone handsets which does not grok UTF-8.</source>
          <target state="translated">まかまこは、「MIME-Header-ISO_2022_JP」によることがあります。现在有太多的MUA,尤其是手机,不支持UTF-8。</target>
        </trans-unit>
        <trans-unit id="3bd045cac184874cb4ad7bcc8e71c09d97d5cddc" translate="yes" xml:space="preserve">
          <source>Due to size concerns, &lt;code&gt;EUC-TW&lt;/code&gt; (Extended Unix Character), &lt;code&gt;CCCII&lt;/code&gt; (Chinese Character Code for Information Interchange), &lt;code&gt;BIG5PLUS&lt;/code&gt; (CMEX's Big5+) and &lt;code&gt;BIG5EXT&lt;/code&gt; (CMEX's Big5e) are distributed separately on CPAN, under the name &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;. That module also contains extra China-based encodings.</source>
          <target state="translated">由于尺寸问题， &lt;code&gt;EUC-TW&lt;/code&gt; （扩展的Unix字符）， &lt;code&gt;CCCII&lt;/code&gt; （信息交换的汉字代码）， &lt;code&gt;BIG5PLUS&lt;/code&gt; （CMEX的Big5 +）和 &lt;code&gt;BIG5EXT&lt;/code&gt; （CMEX的Big5e）分别在CPAN上分发，名称为&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt;。该模块还包含其他基于中国的编码。</target>
        </trans-unit>
        <trans-unit id="5e606dfe28df13df23c0793d29104abe515f70ff" translate="yes" xml:space="preserve">
          <source>Due to size concerns, &lt;code&gt;GB 18030&lt;/code&gt; (an extension to &lt;code&gt;GBK&lt;/code&gt; ) is distributed separately on CPAN, under the name &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;. That module also contains extra Taiwan-based encodings.</source>
          <target state="translated">由于尺寸问题， &lt;code&gt;GB 18030&lt;/code&gt; （ &lt;code&gt;GBK&lt;/code&gt; 的扩展名）在CPAN上单独分发，名称为&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt;。该模块还包含其他基于台湾的编码。</target>
        </trans-unit>
        <trans-unit id="d825b88c92a7854e8e07b5fbd910a2348c547422" translate="yes" xml:space="preserve">
          <source>Due to the current implementation of &lt;code&gt;autodie&lt;/code&gt; , unexpected results may be seen when used near or with the string version of eval.</source>
          <target state="translated">由于 &lt;code&gt;autodie&lt;/code&gt; 的当前实现，当在eval的字符串版本附近或与eval的字符串版本一起使用时，可能会看到意外的结果。</target>
        </trans-unit>
        <trans-unit id="d3912f30ffb4a7edcdecb55dbe256ab47781b419" translate="yes" xml:space="preserve">
          <source>Due to the fact that AIX 4.3.3 reached end-of-service in December 31, 2003 this information is provided as is. The Perl versions prior to Perl 5.8.9 could be compiled on AIX up to 4.3.3 with the following settings (your mileage may vary):</source>
          <target state="translated">由于AIX 4.3.3在2003年12月31日就已经结束服务了,所以这个信息是按原样提供的。Perl 5.8.9之前的Perl版本可以通过以下设置在AIX上编译到4.3.3(你的情况可能有所不同)。</target>
        </trans-unit>
        <trans-unit id="0cc8eb8ed52c08d74c71e528310f912e564ee1bb" translate="yes" xml:space="preserve">
          <source>Due to the interaction between runtime and compiletime issues, and because it's probably not a very good idea anyway, you may not use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; diagnostics&lt;/code&gt; to turn them off at compiletime. However, you may control their behaviour at runtime using the disable() and enable() methods to turn them off and on respectively.</source>
          <target state="translated">由于运行时和编译时问题之间存在交互作用，并且由于无论如何这并不是一个好主意，因此您可能不使用 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; diagnostics&lt;/code&gt; 在编译时将其关闭。但是，您可以使用disable（）和enable（）方法在运行时控制它们的行为，以分别关闭和打开它们。</target>
        </trans-unit>
        <trans-unit id="5dba6a65e991b31774fba10843a79cd147209260" translate="yes" xml:space="preserve">
          <source>Due to the limitations of the implementation, you must use base</source>
          <target state="translated">由于实现的局限性,你必须使用base的</target>
        </trans-unit>
        <trans-unit id="eb744fcb352ecd1572a7e400ccb774b86e7f5bb7" translate="yes" xml:space="preserve">
          <source>Due to the restriction of the quotes, this is a fairly complex problem. Thankfully, we have Jeffrey Friedl, author of</source>
          <target state="translated">由于行情的限制,这是一个相当复杂的问题。幸运的是,我们有杰弗里-弗里德尔,他是一本书的作者。</target>
        </trans-unit>
        <trans-unit id="e3d6d3e302ca0b687c4f0b65161fa70175b1c871" translate="yes" xml:space="preserve">
          <source>Due to the rules and rigors of ANSI C, on some systems you have to do a seek whenever you switch between reading and writing. Amongst other things, this may have the effect of calling stdio's clearerr(3). A WHENCE of &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;SEEK_CUR&lt;/code&gt; ) is useful for not moving the file position:</source>
          <target state="translated">由于ANSI C的规则和严格性，在某些系统上，无论何时在读和写之间切换，都必须进行查找。除其他外，这可能具有调用stdio的clearerr（3）的效果。WHENCE为 &lt;code&gt;1&lt;/code&gt; （ &lt;code&gt;SEEK_CUR&lt;/code&gt; ）对于不移动文件位置很有用：</target>
        </trans-unit>
        <trans-unit id="791e734fb8c106991b00acd93d1da356b7e03d9b" translate="yes" xml:space="preserve">
          <source>Due to the very cryptic nature of these options, another style was developed that used long names. So instead of a cryptic &lt;code&gt;-l&lt;/code&gt; one could use the more descriptive &lt;code&gt;--long&lt;/code&gt; . To distinguish between a bundle of single-character options and a long one, two dashes are used to precede the option name. Early implementations of long options used a plus &lt;code&gt;+&lt;/code&gt; instead. Also, option values could be specified either like</source>
          <target state="translated">由于这些选项非常隐秘，因此开发了另一种使用长名称的样式。因此，可以使用更具描述性的 &lt;code&gt;--long&lt;/code&gt; 代替晦涩的 &lt;code&gt;-l&lt;/code&gt; 。为了区分一包单字符选项和一个长字符选项，在选项名称前使用两个破折号。长选项的早期实现使用加号 &lt;code&gt;+&lt;/code&gt; 代替。另外，可以指定选项值，例如</target>
        </trans-unit>
        <trans-unit id="c0e24e606681dc5af1b9b3cb9795462cb06198f7" translate="yes" xml:space="preserve">
          <source>Due to the way that Perl parses things, your parentheses and brackets may need to be balanced, even including comments. If you run into any examples, please send them to &lt;code&gt;perlbug@perl.org&lt;/code&gt; , so that we can have a concrete example for this man page.</source>
          <target state="translated">由于Perl解析事物的方式，您的括号和方括号可能需要平衡，甚至包括注释。如果遇到任何示例，请将其发送至 &lt;code&gt;perlbug@perl.org&lt;/code&gt; ，以便我们为该手册页提供一个具体示例。</target>
        </trans-unit>
        <trans-unit id="fc3fa3b419b8695e1ca79a869f79ee2bcd448351" translate="yes" xml:space="preserve">
          <source>Due to their nature, not all Unicode character properties are suitable for regular expression matches, nor &lt;code&gt;prop_invlist()&lt;/code&gt; . The remaining non-provisional, non-internal ones are accessible via &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt; (except for those that this Perl installation hasn't included; see &lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;below for which those are&lt;/a&gt;).</source>
          <target state="translated">由于其性质，并非所有Unicode字符属性都适合于正则表达式匹配，也不 &lt;code&gt;prop_invlist()&lt;/code&gt; 。其余的非临时性，非内部性可以通过&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;Unicode :: UCD中的prop_invmap（）&lt;/a&gt;访问。（除了该Perl安装中未包括的&lt;a href=&quot;#Unicode-character-properties-that-are-NOT-accepted-by-Perl&quot;&gt;那些&lt;/a&gt;；请参见下文，其中的）。</target>
        </trans-unit>
        <trans-unit id="1caad945fadff253ca62db9c999f67f3c76a14fd" translate="yes" xml:space="preserve">
          <source>Dummy module providing JSON::PP::Boolean</source>
          <target state="translated">提供JSON::PP::Boolean的虚拟模块。</target>
        </trans-unit>
        <trans-unit id="fc825db9b75c6b805dc48232f9aa43bb74e273e4" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;locks&quot; an SV when there is no locking module present. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">当没有锁定模块存在时,&quot;锁定 &quot;SV的虚例程。存在的目的是为了避免对NULL函数指针的测试,同时也因为在某种程度的严格性下,它可能会发出警告。</target>
        </trans-unit>
        <trans-unit id="bf0c1d486931f3f325ed075b19809ade73db7a85" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;shares&quot; an SV when there is no sharing module present. Or &quot;locks&quot; it. Or &quot;unlocks&quot; it. In other words, ignores its single SV argument. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">当没有共享模块存在时,&quot;共享 &quot;SV的虚函数。或 &quot;锁定 &quot;它。或者 &quot;解锁 &quot;它。换句话说,忽略它的单个SV参数。存在的目的是为了避免对NULL函数指针的测试,同时也因为在某种程度的严格性下,它可能会发出警告。</target>
        </trans-unit>
        <trans-unit id="176b35c46c4ecb91ea04e78d1a42469728759765" translate="yes" xml:space="preserve">
          <source>Dummy routine which &quot;unlocks&quot; an SV when there is no locking module present. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">当没有锁定模块时,用于 &quot;解锁 &quot;SV的虚函数。存在的目的是为了避免对NULL函数指针的测试,同时也因为在某种程度的严格性下,它可能会发出警告。</target>
        </trans-unit>
        <trans-unit id="37582a718d2cb7f89d1fea284988f5efcf14f0a7" translate="yes" xml:space="preserve">
          <source>Dummy routine which reports that object can be destroyed when there is no sharing module present. It ignores its single SV argument, and returns 'true'. Exists to avoid test for a NULL function pointer and because it could potentially warn under some level of strict-ness.</source>
          <target state="translated">当没有共享模块存在时,报告对象可以被销毁的假例程。它忽略它的单个SV参数,并返回 &quot;true&quot;。它的存在是为了避免对NULL函数指针的测试,同时也因为它在某种程度的严格性下可能会发出警告。</target>
        </trans-unit>
        <trans-unit id="1a71039f50cfa3d68327859e6e1ee38df19b6603" translate="yes" xml:space="preserve">
          <source>Dump Pod-parsing events as text</source>
          <target state="translated">将Pod-parsing事件转为文本</target>
        </trans-unit>
        <trans-unit id="f2e8d87285df2d5dabb9e7d33d3a5ccc1734224b" translate="yes" xml:space="preserve">
          <source>Dump arrays holding contents of debugged files.</source>
          <target state="translated">保存调试文件内容的转储数组。</target>
        </trans-unit>
        <trans-unit id="c3ebe589cb305dd68a2940605b6daaa7020bacf2" translate="yes" xml:space="preserve">
          <source>Dump arrays holding debugged files.</source>
          <target state="translated">存放调试文件的转储数组。</target>
        </trans-unit>
        <trans-unit id="226b4cf975bc516395af9737531a129bdd39ab93" translate="yes" xml:space="preserve">
          <source>Dump contents of &quot;reused&quot; addresses.</source>
          <target state="translated">转储 &quot;重用 &quot;地址的内容。</target>
        </trans-unit>
        <trans-unit id="259f2ccf29b6875ba051810947cb2d0facc44c4f" translate="yes" xml:space="preserve">
          <source>Dump offset information. This can be used to see how regops correlate to the pattern. Output format is</source>
          <target state="translated">转储偏移信息。这可以用来查看regops与模式的相关性。输出格式是</target>
        </trans-unit>
        <trans-unit id="0c76297cc9be5e641298778b62c24d2cf18dcd23" translate="yes" xml:space="preserve">
          <source>Dump symbol tables of packages.</source>
          <target state="translated">转储包的符号表。</target>
        </trans-unit>
        <trans-unit id="4b8420d45b35aac310c6f6a8a752e4db117364a2" translate="yes" xml:space="preserve">
          <source>Dump the contents of a padlist</source>
          <target state="translated">转储padlist的内容</target>
        </trans-unit>
        <trans-unit id="aa55ac5b7f095f269a678e79910c4c37b3152a49" translate="yes" xml:space="preserve">
          <source>Dump the contents of all SVs not yet freed (debugging aid).</source>
          <target state="translated">转储所有尚未释放的SV的内容(调试辅助)。</target>
        </trans-unit>
        <trans-unit id="d6a50535ad9de82c4339f219e99b9b784c2acae9" translate="yes" xml:space="preserve">
          <source>Dump the final program out after it is compiled and optimised.</source>
          <target state="translated">在编译优化后,将最终的程序甩出去。</target>
        </trans-unit>
        <trans-unit id="918c0daf95540cecfd55fc2c00499f5882b52cfa" translate="yes" xml:space="preserve">
          <source>Dump the flags associated with the program</source>
          <target state="translated">转储与程序相关的标志</target>
        </trans-unit>
        <trans-unit id="5e107609c2d58489d78c64df77c07976e804b91e" translate="yes" xml:space="preserve">
          <source>Dumping Perl Data Structures</source>
          <target state="translated">转储Perl数据结构</target>
        </trans-unit>
        <trans-unit id="44d1680eb49a12854ee630cd3f07447c8ef725fa" translate="yes" xml:space="preserve">
          <source>Dumping a large array or hash</source>
          <target state="translated">转储一个大数组或哈希</target>
        </trans-unit>
        <trans-unit id="416f4f5ac3093ab1714cc7418abe095efaa50a64" translate="yes" xml:space="preserve">
          <source>Dumps the C backtrace to the given fp.</source>
          <target state="translated">将C语言的回溯转储到给定的fp。</target>
        </trans-unit>
        <trans-unit id="1a8a79003d6e119f87dd05fb34533dde374be690" translate="yes" xml:space="preserve">
          <source>Dumps the contents of an SV to the &lt;code&gt;STDERR&lt;/code&gt; filehandle.</source>
          <target state="translated">将SV的内容转储到 &lt;code&gt;STDERR&lt;/code&gt; 文件句柄中。</target>
        </trans-unit>
        <trans-unit id="ec8f218a06cd2ecbe02c8bf7842f6c0f5d02c9c5" translate="yes" xml:space="preserve">
          <source>Dumps the entire optree of the current program starting at &lt;code&gt;PL_main_root&lt;/code&gt; to &lt;code&gt;STDERR&lt;/code&gt; . Also dumps the optrees for all visible subroutines in &lt;code&gt;PL_defstash&lt;/code&gt; .</source>
          <target state="translated">从 &lt;code&gt;PL_main_root&lt;/code&gt; 开始将当前程序的整个操作树转储到 &lt;code&gt;STDERR&lt;/code&gt; 。还将转储所有可见子程序的操作树 &lt;code&gt;PL_defstash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46f7f7e922a3e5c53d29eb7033810ca1c5ff1e45" translate="yes" xml:space="preserve">
          <source>Dumps the optree starting at OP &lt;code&gt;o&lt;/code&gt; to &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">从OP &lt;code&gt;o&lt;/code&gt; 开始将optree转储到 &lt;code&gt;STDERR&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="e83684d55af04a9978210506a5f3da39f6330394" translate="yes" xml:space="preserve">
          <source>Dumps the optrees for all visible subroutines in &lt;code&gt;stash&lt;/code&gt; .</source>
          <target state="translated">转储所有可见子例程中的optree &lt;code&gt;stash&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="55b069d1baf075aa441953fab4c10d5fb0c55b03" translate="yes" xml:space="preserve">
          <source>Dumps to STDOUT a two column list of op names and op descriptions. If an optional pattern is given then only lines which match the (case insensitive) pattern will be output.</source>
          <target state="translated">向STDOUT转储一个两列的操作名称和操作描述的列表。如果给定了一个可选的模式,那么将只输出与该模式相匹配的行(不区分大小写)。</target>
        </trans-unit>
        <trans-unit id="0bb1bbfb4b82018f68b759747efb8b836bc13b23" translate="yes" xml:space="preserve">
          <source>Dumpvalue</source>
          <target state="translated">Dumpvalue</target>
        </trans-unit>
        <trans-unit id="29282979e5caf58379ebe9349836f426355bbd81" translate="yes" xml:space="preserve">
          <source>Dumpvalue - provides screen dump of Perl data.</source>
          <target state="translated">Dumpvalue-提供Perl数据的屏幕转储。</target>
        </trans-unit>
        <trans-unit id="5194887c5341c823d0b499a2bddca4cdca4574a6" translate="yes" xml:space="preserve">
          <source>Duplicate keys are entirely defined by the comparison function. In the case-insensitive example above, the keys: 'KEY' and 'key' would be considered duplicates, and assigning to the second one would overwrite the first. If duplicates are allowed for (with the R_DUP flag discussed below), only a single copy of duplicate keys is stored in the database --- so (again with example above) assigning three values to the keys: 'KEY', 'Key', and 'key' would leave just the first key: 'KEY' in the database with three values. For some situations this results in information loss, so care should be taken to provide fully qualified comparison functions when necessary. For example, the above comparison routine could be modified to additionally compare case-sensitively if two keys are equal in the case insensitive comparison:</source>
          <target state="translated">重复的键完全由比较函数定义。在上面这个不区分大小写的例子中,键:'KEY'和'key'将被认为是重复的,分配给第二个键将覆盖第一个键。如果允许重复(使用下面讨论的R_DUP标志),数据库中只存储一个重复键的副本------所以(同样是上面的例子)给键:'KEY'、'Key'和'key'分配三个值,将使数据库中只有第一个键:'KEY'有三个值。对于某些情况来说,这会导致信息丢失,所以在必要的时候应该注意提供完全合格的比较函数。例如,可以修改上述比较例程,如果在大小写不敏感的比较中,两个键相等,则可以另外进行大小写敏感的比较。</target>
        </trans-unit>
        <trans-unit id="231270fe32be376e1ff61953994a1d9555ba5c57" translate="yes" xml:space="preserve">
          <source>Duplicates a pad name list.</source>
          <target state="translated">复制一个焊盘名称列表。</target>
        </trans-unit>
        <trans-unit id="9900c4228b05d518bce49d6e43830390656bb380" translate="yes" xml:space="preserve">
          <source>Duplicates a pad name.</source>
          <target state="translated">复制一个垫名。</target>
        </trans-unit>
        <trans-unit id="9c150a6a5de518050ee469f156c0d8c9991e7d83" translate="yes" xml:space="preserve">
          <source>Duplicates a pad.</source>
          <target state="translated">复制一个垫子。</target>
        </trans-unit>
        <trans-unit id="34a249fd97af29be13a351a7a3b7c31857c28f36" translate="yes" xml:space="preserve">
          <source>Duplicates the current value of &lt;code&gt;SV&lt;/code&gt; , on the exit from the current &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt;</source>
          <target state="translated">在当前 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 的出口处复制 &lt;code&gt;SV&lt;/code&gt; 的当前值</target>
        </trans-unit>
        <trans-unit id="327c7809967b34dba21cd1b07757c86e4f680971" translate="yes" xml:space="preserve">
          <source>During &quot;make test&quot; the &lt;code&gt;comp/cpp&lt;/code&gt; will be skipped because on Tru64 it cannot be tested before Perl has been installed. The test refers to the use of the &lt;code&gt;-P&lt;/code&gt; option of Perl.</source>
          <target state="translated">在&amp;ldquo; make test&amp;rdquo;期间， &lt;code&gt;comp/cpp&lt;/code&gt; 将被跳过，因为在Tru64上无法在安装Perl之前对其进行测试。该测试涉及Perl 的 &lt;code&gt;-P&lt;/code&gt; 选项的使用。</target>
        </trans-unit>
        <trans-unit id="82a46924bba9ec42c3fc1e7dbc6523da9c5a0d98" translate="yes" xml:space="preserve">
          <source>During compilation you will see this warning from toke.c:</source>
          <target state="translated">在编译过程中,你会看到toke.c的这个警告。</target>
        </trans-unit>
        <trans-unit id="1b78be5f5982368a285609a938bd717c952f6438" translate="yes" xml:space="preserve">
          <source>During compilation, this points to the array containing the names part of the pad for the currently-compiling code.</source>
          <target state="translated">在编译过程中,这将指向包含当前编译代码垫的名称部分的数组。</target>
        </trans-unit>
        <trans-unit id="8fc3623ed774bb34e7810f090f0b1728d1403063" translate="yes" xml:space="preserve">
          <source>During compilation, this points to the array containing the values part of the pad for the currently-compiling code. (At runtime a CV may have many such value arrays; at compile time just one is constructed.) At runtime, this points to the array containing the currently-relevant values for the pad for the currently-executing code.</source>
          <target state="translated">在编译过程中,它指向包含当前编译代码垫的值部分的数组。(在运行时,一个CV可能会有很多这样的值数组,在编译时只构造了一个)。在运行时,这个指向包含当前执行代码的垫子的当前相关值的数组。</target>
        </trans-unit>
        <trans-unit id="688fb3463c876328fa68fbb00f834fb161bf77e9" translate="yes" xml:space="preserve">
          <source>During extensions build phase, a script</source>
          <target state="translated">在扩展构建阶段,一个脚本</target>
        </trans-unit>
        <trans-unit id="3a8cb198eac07a20f06df8ba7dc5ed5cb604d226" translate="yes" xml:space="preserve">
          <source>During global destruction, Perl will always garbage collect objects before unblessed references. See &lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;PERL_DESTRUCT_LEVEL in perlhacktips&lt;/a&gt; for more information about global destruction.</source>
          <target state="translated">在全局销毁期间，Perl将始终在无恶意引用之前对对象进行垃圾收集。有关全局销毁的更多信息，请参见&lt;a href=&quot;perlhacktips#PERL_DESTRUCT_LEVEL&quot;&gt;perlhacktips中的PERL_DESTRUCT_LEVEL&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="63b2774e342436fdc21964665d44a1dd453eb511" translate="yes" xml:space="preserve">
          <source>During installation &lt;code&gt;$List::Util::XS::VERSION&lt;/code&gt; will be set to &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the XS was not compiled.</source>
          <target state="translated">在安装过程中，如果未编译XS，则 &lt;code&gt;$List::Util::XS::VERSION&lt;/code&gt; 将设置为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="365d0173e5c9fab16585ed58b7aee60ff977956d" translate="yes" xml:space="preserve">
          <source>During recent history, data is moved around a computer in 8-bit chunks, often called &quot;bytes&quot; but also known as &quot;octets&quot; in standards documents. Perl is widely used to manipulate data of many types: not only strings of characters representing human or computer languages, but also &quot;binary&quot; data, being the machine's representation of numbers, pixels in an image, or just about anything.</source>
          <target state="translated">在近代史上,数据是以8位的块状在计算机中移动的,通常被称为 &quot;字节&quot;,但在标准文档中也被称为 &quot;八位字节&quot;。Perl被广泛用于处理多种类型的数据:不仅有代表人类或计算机语言的字符串,还有 &quot;二进制 &quot;数据,是机器对数字、图像中的像素或任何东西的表示。</target>
        </trans-unit>
        <trans-unit id="c00b220a28d96bc682b1b18fd920cedf0efda896" translate="yes" xml:space="preserve">
          <source>During the 'r' command CPAN.pm finds modules with a version number of zero. When the command finishes, it prints a report about this. If you want this report to be very verbose, say yes to the following variable.</source>
          <target state="translated">在'r'命令期间,CPAN.pm会找到版本号为0的模块。当命令完成后,它会打印出一个关于这个问题的报告,如果你想让这个报告非常详细,请对下面的变量说 &quot;是&quot;。如果你希望这个报告非常详细,请对下面的变量说 &quot;是&quot;。</target>
        </trans-unit>
        <trans-unit id="1e8d8123a94cf9a48937762f3c4d82a2ae9cfc9c" translate="yes" xml:space="preserve">
          <source>During the 'r' command CPAN.pm finds modules without version number. When the command finishes, it prints a report about this. If you want this report to be very verbose, say yes to the following variable.</source>
          <target state="translated">在'r'命令中,CPAN.pm会发现没有版本号的模块。当命令完成后,它会打印一个关于这个问题的报告。如果你希望这个报告非常详细,请对下面的变量说 &quot;是&quot;。</target>
        </trans-unit>
        <trans-unit id="00bf1cb155480acd23b923e4a6c03a2b23cd1d39" translate="yes" xml:space="preserve">
          <source>During the build process, three Perl images are produced.</source>
          <target state="translated">在构建过程中,会产生三个Perl镜像。</target>
        </trans-unit>
        <trans-unit id="4695645d68d6dbb11815010844432810a8cc5ce6" translate="yes" xml:space="preserve">
          <source>During the matching of this sub-pattern, it has its own set of captures which are valid during the sub-match, but are discarded once control returns to the main pattern. For example, the following matches, with the inner pattern capturing &quot;B&quot; and matching &quot;BB&quot;, while the outer pattern captures &quot;A&quot;;</source>
          <target state="translated">在这个子图案的匹配过程中,它有自己的一组捕获,这些捕获在子匹配过程中是有效的,但一旦控制回到主图案,就会被丢弃。例如,下面的匹配,内层模式捕获 &quot;B&quot;,匹配 &quot;BB&quot;,而外层模式捕获 &quot;A&quot;。</target>
        </trans-unit>
        <trans-unit id="e6ec7eb737062f01f212178148567a03e6c845e4" translate="yes" xml:space="preserve">
          <source>During the normal course of events, the parent process and every pseudo-process started by it will wait for their respective pseudo-children to complete before they exit. This means that the parent and every pseudo-child created by it that is also a pseudo-parent will only exit after their pseudo-children have exited.</source>
          <target state="translated">在正常的事件过程中,父进程和由它启动的每个伪进程都会等待各自的伪子进程完成后才会退出。这意味着父进程和它所创建的每一个伪子进程,如果也是伪父进程的话,只有在它们的伪子进程退出之后,才会退出。</target>
        </trans-unit>
        <trans-unit id="26974b2880875e58f9a65545ea413592199b96d1" translate="yes" xml:space="preserve">
          <source>During the rest of this document, the shortcuts A (for accuracy), P (for precision), F (fallback) and R (rounding mode) will be used.</source>
          <target state="translated">在本文档的其余部分,将使用快捷键A(代表精度)、P(代表精度)、F(回落)和R(四舍五入模式)。</target>
        </trans-unit>
        <trans-unit id="f8d90cb30467e2a4d157edb90535bc578beea09a" translate="yes" xml:space="preserve">
          <source>During this search no attention is paid to the semantics of the construct. Thus:</source>
          <target state="translated">在这个搜索过程中,没有注意到构造的语义。因此:</target>
        </trans-unit>
        <trans-unit id="601d1570400ebbc8e652fb389057e665c3716c4a" translate="yes" xml:space="preserve">
          <source>DynaLoader</source>
          <target state="translated">DynaLoader</target>
        </trans-unit>
        <trans-unit id="9d69ce3ced252503b953a83d970f6811f3f613e6" translate="yes" xml:space="preserve">
          <source>DynaLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">DynaLoader-动态加载C库到Perl代码中。</target>
        </trans-unit>
        <trans-unit id="b801b82847d571219ed7e9cb40b5911d8c6fd1ce" translate="yes" xml:space="preserve">
          <source>DynaLoader Interface Summary</source>
          <target state="translated">DynaLoader界面概要</target>
        </trans-unit>
        <trans-unit id="44c249a4a70f6f5d86041728f18f2c1b944c09ee" translate="yes" xml:space="preserve">
          <source>DynaLoader.pm</source>
          <target state="translated">DynaLoader.pm</target>
        </trans-unit>
        <trans-unit id="7bf55f093a98122c15a38c4d1e0e12b14eb5e676" translate="yes" xml:space="preserve">
          <source>DynaLoader_pm.PL</source>
          <target state="translated">DynaLoader_pm.PL</target>
        </trans-unit>
        <trans-unit id="eafe90e80018d592f31306075f13c6355bb554de" translate="yes" xml:space="preserve">
          <source>Dynamic Loading versus Static Loading</source>
          <target state="translated">动态加载与静态加载</target>
        </trans-unit>
        <trans-unit id="e6e2a2c7c1603246902c42979e7716a6a53a2226" translate="yes" xml:space="preserve">
          <source>Dynamic Templates</source>
          <target state="translated">动态模板</target>
        </trans-unit>
        <trans-unit id="376a2d3fdb39cd734db8f5317d570d379d27e726" translate="yes" xml:space="preserve">
          <source>Dynamic scoping works over a &lt;b&gt;dynamic scope&lt;/b&gt;, making variables visible throughout the rest of the &lt;b&gt;block&lt;/b&gt; in which they are first used and in any &lt;b&gt;subroutines&lt;/b&gt; that are called by the rest of the block. Dynamically scoped variables can have their values temporarily changed (and implicitly restored later) by a &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; operator. (Compare &lt;b&gt;lexical scoping&lt;/b&gt;.) Used more loosely to mean how a subroutine that is in the middle of calling another subroutine &amp;ldquo;contains&amp;rdquo; that subroutine at &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">动态作用域的作品在&lt;b&gt;动态范围&lt;/b&gt;，使得整个其余可见的变量&lt;b&gt;块&lt;/b&gt;中，他们第一次使用，并且在任何&lt;b&gt;子程序&lt;/b&gt;由该块的其余部分调用。动态范围的变量可以由 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 运算符临时更改其值（并在以后隐式恢复）。（比较&lt;b&gt;词法作用域&lt;/b&gt;。）更宽松地用来表示在调用另一个子例程的过程中一个子例程&amp;ldquo;包含&amp;rdquo;该子例程的方式。&lt;b&gt;运行时&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="fb638018434277b4fc82279e676431d053924a22" translate="yes" xml:space="preserve">
          <source>Dynamically load $filename, which must be the path to a shared object or library. An opaque 'library reference' is returned as a handle for the loaded object. Returns undef on error.</source>
          <target state="translated">动态加载$filename,它必须是一个共享对象或库的路径。返回一个不透明的 &quot;库引用 &quot;作为加载对象的句柄。错误时返回undef。</target>
        </trans-unit>
        <trans-unit id="86d6546533b1f34d2c75903edbf95c52c4a6e87e" translate="yes" xml:space="preserve">
          <source>Dynamically load C libraries into Perl code</source>
          <target state="translated">动态地将C库加载到Perl代码中</target>
        </trans-unit>
        <trans-unit id="549c414661c7e2cd66ebf276140209d3a293c3ec" translate="yes" xml:space="preserve">
          <source>Dynamically unload $libref, which must be an opaque 'library reference' as returned from dl_load_file. Returns one on success and zero on failure. This function is optional and may not necessarily be provided on all platforms.</source>
          <target state="translated">动态卸载$libref,它必须是dl_load_file返回的不透明的 &quot;库引用&quot;。成功时返回1,失败时返回0。这个函数是可选的,不一定在所有平台上都能提供。</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="fa9bdf01ece32bc99b1e14c6937aab7757e65d12" translate="yes" xml:space="preserve">
          <source>E&amp;lt;...&amp;gt; codes are resolved.</source>
          <target state="translated">E &amp;lt;...&amp;gt;代码已解析。</target>
        </trans-unit>
        <trans-unit id="8ba6f1546de2a6de38d5975288d79871e380398d" translate="yes" xml:space="preserve">
          <source>E&amp;lt;...&amp;gt; may freely appear in any formatting code (other than in another E&amp;lt;...&amp;gt; or in an Z&amp;lt;&amp;gt;). That is, &quot;X&amp;lt;The E&amp;lt;euro&amp;gt;1,000,000 Solution&amp;gt;&quot; is valid, as is &quot;L&amp;lt;The E&amp;lt;euro&amp;gt;1,000,000 Solution|Million::Euros&amp;gt;&quot;.</source>
          <target state="translated">E &amp;lt;...&amp;gt;可以自由地以任何格式代码出现（除了在另一个E &amp;lt;...&amp;gt;或Z &amp;lt;&amp;gt;中）。也就是说，&amp;ldquo; X &amp;lt;E &amp;lt;euro&amp;gt; 1,000,000解决方案&amp;gt;&amp;rdquo;和&amp;ldquo; L &amp;lt;E &amp;lt;euro&amp;gt; 1,000,000解决方案| Million :: Euros&amp;gt;&amp;rdquo;都是有效的。</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="10c56e2f6bd010417c5d9ae6293f4b104ad1b293" translate="yes" xml:space="preserve">
          <source>E.g. when 'a' and 'e' are ignorable, 'element' is equal to 'lament' (or 'lmnt').</source>
          <target state="translated">如:当'a'和'e'可以忽略时,'元素'等于'惋惜'(或'lmnt')。</target>
        </trans-unit>
        <trans-unit id="54752205cb5bf21cf1543c1d8786b50bfa512554" translate="yes" xml:space="preserve">
          <source>E.g. when searching in</source>
          <target state="translated">例如,在搜索</target>
        </trans-unit>
        <trans-unit id="c9faf7260b3872bd0cc8c1b2903b97df4d17534d" translate="yes" xml:space="preserve">
          <source>E.g., &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'foo', 'bar', 'baz'&lt;/code&gt; may lead Perl to finding</source>
          <target state="translated">例如， &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'foo', 'bar', 'baz'&lt;/code&gt; 可能会导致Perl查找</target>
        </trans-unit>
        <trans-unit id="14202089b63db480cc56897191e80ea08ccae522" translate="yes" xml:space="preserve">
          <source>E.g., when searching in</source>
          <target state="translated">例如,当在</target>
        </trans-unit>
        <trans-unit id="cf18d56706e6a161ea7a892c730e7fc94aa42849" translate="yes" xml:space="preserve">
          <source>EBCDIC</source>
          <target state="translated">EBCDIC</target>
        </trans-unit>
        <trans-unit id="db39ab5da5fc359d74ab7f80a9662d49c8256b60" translate="yes" xml:space="preserve">
          <source>EBCDIC Encodings</source>
          <target state="translated">EBCDIC编码</target>
        </trans-unit>
        <trans-unit id="acf1dc4914532273e100530a9ab5c863dba82d84" translate="yes" xml:space="preserve">
          <source>EBCDIC Examples:</source>
          <target state="translated">EBCDIC实例。</target>
        </trans-unit>
        <trans-unit id="332c2be33ecb50e660de8a6bec931a2002f3ce8c" translate="yes" xml:space="preserve">
          <source>EBCDIC Platforms</source>
          <target state="translated">EBCDIC平台</target>
        </trans-unit>
        <trans-unit id="d5e0cb1a52c6c43ea7491f03d8cf20e2863b3020" translate="yes" xml:space="preserve">
          <source>EBCDIC checksums will differ for the same file translated into ASCII and vice versa.</source>
          <target state="translated">同一个文件翻译成ASCII码时,EBCDIC的校验和会有所不同,反之亦然。</target>
        </trans-unit>
        <trans-unit id="c4a1a6bb8b2ba023d8e2ace21595c7370a5af29a" translate="yes" xml:space="preserve">
          <source>EBCDIC code sets recognized by Perl</source>
          <target state="translated">Perl识别的EBCDIC代码集</target>
        </trans-unit>
        <trans-unit id="8917832f80dc1f23f4ce37b35b7094bce451b8d6" translate="yes" xml:space="preserve">
          <source>EBCDIC sort results may differ from ASCII sort results especially for mixed case strings. This is discussed in more detail &lt;a href=&quot;#SORTING&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">EBCDIC排序结果可能与ASCII排序结果不同，尤其是对于大小写混合的字符串。这将在&lt;a href=&quot;#SORTING&quot;&gt;下面&lt;/a&gt;更详细地讨论。</target>
        </trans-unit>
        <trans-unit id="0161b12e1086c489bcc4c4218bf647b2c2e7af38" translate="yes" xml:space="preserve">
          <source>ECMA-048 is available on-line (at least at the time of this writing) at &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-048.htm&quot;&gt;http://www.ecma-international.org/publications/standards/Ecma-048.htm&lt;/a&gt;.</source>
          <target state="translated">ECMA-048可在线获得（至少在撰写本文时），&lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-048.htm&quot;&gt;网址&lt;/a&gt;为http://www.ecma-international.org/publications/standards/Ecma-048.htm。</target>
        </trans-unit>
        <trans-unit id="0216d6b25a22e0b782349678c3b9d439ab040aa1" translate="yes" xml:space="preserve">
          <source>EFFECTIVE</source>
          <target state="translated">EFFECTIVE</target>
        </trans-unit>
        <trans-unit id="cbc724c9910501b7f3260e0af4b0be278ac0c6a0" translate="yes" xml:space="preserve">
          <source>ELEMENTS OF THE INTERPRETER</source>
          <target state="translated">口译员的要素</target>
        </trans-unit>
        <trans-unit id="775eda021e49d1db0c56510d89f1a3a5b0d3533c" translate="yes" xml:space="preserve">
          <source>ELEMENT_LIST</source>
          <target state="translated">ELEMENT_LIST</target>
        </trans-unit>
        <trans-unit id="274c18c04f053750184eb461592a3aeba38deb84" translate="yes" xml:space="preserve">
          <source>EMX runtime is required (may be substituted by RSX). Note that it is possible to make</source>
          <target state="translated">需要EMX运行时间(可以用RSX代替)。请注意,可以使</target>
        </trans-unit>
        <trans-unit id="ee406c89e6d96da9d9c9078da02dd1085c757041" translate="yes" xml:space="preserve">
          <source>ENCNAME</source>
          <target state="translated">ENCNAME</target>
        </trans-unit>
        <trans-unit id="09d70e3cb3e8ca25c8e1c040798016341acb9d34" translate="yes" xml:space="preserve">
          <source>ENCODED WORD</source>
          <target state="translated">咒语</target>
        </trans-unit>
        <trans-unit id="1e306f9d0fec9dc9a627cd5c3b6dd9bb1770a21e" translate="yes" xml:space="preserve">
          <source>ENCODING</source>
          <target state="translated">ENCODING</target>
        </trans-unit>
        <trans-unit id="d205abee3d2a71688a6b66568be289a94050031c" translate="yes" xml:space="preserve">
          <source>END</source>
          <target state="translated">END</target>
        </trans-unit>
        <trans-unit id="6d3c353157df1302b4606a2c3c31edf9ce433536" translate="yes" xml:space="preserve">
          <source>ENTRIES IN EACH LEXICON</source>
          <target state="translated">每份清单的条目数</target>
        </trans-unit>
        <trans-unit id="15d54da16fed3cc2ae89bbdaf9ad9e1b0ec1df2c" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT</source>
          <target state="translated">ENVIRONMENT</target>
        </trans-unit>
        <trans-unit id="cb8f8d1fdc31a300a149531a3ee67854b7226f82" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT VARIABLES THAT AFFECT TEST::HARNESS</source>
          <target state="translated">影响TEST::HARNESS的环境变量。</target>
        </trans-unit>
        <trans-unit id="ca7f3972a83e913d649e11c108df24283c3bc376" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT VARIABLES THAT TAP::HARNESS::COMPATIBLE SETS</source>
          <target state="translated">TAP::HARNESS::COMPATIBLE SETS的环境变量。</target>
        </trans-unit>
        <trans-unit id="f7084ac12cca76d68cdd87fe9d782e1ae84dd265" translate="yes" xml:space="preserve">
          <source>EOF.</source>
          <target state="translated">EOF.</target>
        </trans-unit>
        <trans-unit id="bc8e77d510181b5522d113b8d79cd4cb3e49542e" translate="yes" xml:space="preserve">
          <source>EOL Platforms</source>
          <target state="translated">EOL平台</target>
        </trans-unit>
        <trans-unit id="7d063d313be8f22d60adcb2e5150c0209bf36674" translate="yes" xml:space="preserve">
          <source>ERRNO</source>
          <target state="translated">ERRNO</target>
        </trans-unit>
        <trans-unit id="ebe21523a5dccd37a9fcf7ea0fd32b1eca292ad0" translate="yes" xml:space="preserve">
          <source>ERROR HANDLING</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="161833a14be7adad1a6eb962fc3f24b1791debe8" translate="yes" xml:space="preserve">
          <source>ERROR REPORTING</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="fb558b481c7703cb01a866167aa87ba7ffeeb0ce" translate="yes" xml:space="preserve">
          <source>ERRORS</source>
          <target state="translated">ERRORS</target>
        </trans-unit>
        <trans-unit id="2ef444354ee97e4dd743f7f63b3e4d0c239b4132" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO DIVISION BY ZERO</source>
          <target state="translated">因以零划分而出现的错误</target>
        </trans-unit>
        <trans-unit id="6a22654ad1bd17a1b7f8a33ebc606c6dd0499218" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO</source>
          <target state="translated">由于被零分割或零的对数而产生的错误。</target>
        </trans-unit>
        <trans-unit id="c79b986f6448f6bcfe4c395367179ab049f8d63e" translate="yes" xml:space="preserve">
          <source>ERRORS DUE TO INDIGESTIBLE ARGUMENTS</source>
          <target state="translated">愚蠢的论点导致的错误。</target>
        </trans-unit>
        <trans-unit id="6f1d7e623d1be2e3224550fb5ed680f08aba75ed" translate="yes" xml:space="preserve">
          <source>ESCAPE SEQUENCES</source>
          <target state="translated">逃生序列</target>
        </trans-unit>
        <trans-unit id="c68e9c8ffafea2d41e94c29ec6ef311a4fc01058" translate="yes" xml:space="preserve">
          <source>ESTI GSM 03.38 Encoding</source>
          <target state="translated">ESTI GSM 03.38 编码</target>
        </trans-unit>
        <trans-unit id="330d938044782725e081a62faa873e5784320980" translate="yes" xml:space="preserve">
          <source>ESTI GSM 03.38 Encoding itself.</source>
          <target state="translated">ESTI GSM 03.38 编码本身。</target>
        </trans-unit>
        <trans-unit id="e9199febdaab27118bac1b42feacb4f953051759" translate="yes" xml:space="preserve">
          <source>EXAMPLE</source>
          <target state="translated">EXAMPLE</target>
        </trans-unit>
        <trans-unit id="79e0bba4d7ab03dd3a43d89e18dc509cf2803c4f" translate="yes" xml:space="preserve">
          <source>EXAMPLE - Greekperl</source>
          <target state="translated">例子-Greekperl</target>
        </trans-unit>
        <trans-unit id="c1459caada695329b2e0c6704825c3b8e7a13c88" translate="yes" xml:space="preserve">
          <source>EXAMPLE 1</source>
          <target state="translated">例子1</target>
        </trans-unit>
        <trans-unit id="1358d71098fb89610fe1aac79c61d72cd99d3282" translate="yes" xml:space="preserve">
          <source>EXAMPLE 2</source>
          <target state="translated">例子2</target>
        </trans-unit>
        <trans-unit id="bf337e44a3f58c52533729fe2435927aca3951e1" translate="yes" xml:space="preserve">
          <source>EXAMPLE 3</source>
          <target state="translated">例子3</target>
        </trans-unit>
        <trans-unit id="6c373f3759a7e7f5ea3aa6485c89916c7bfcefb6" translate="yes" xml:space="preserve">
          <source>EXAMPLE 4</source>
          <target state="translated">例子4</target>
        </trans-unit>
        <trans-unit id="c0fcde52500282f83cc647053ccb330dab650466" translate="yes" xml:space="preserve">
          <source>EXAMPLE 5</source>
          <target state="translated">例子5</target>
        </trans-unit>
        <trans-unit id="45b9b19b0fbae586929496cd8750455d351de3e8" translate="yes" xml:space="preserve">
          <source>EXAMPLE 6</source>
          <target state="translated">例子6</target>
        </trans-unit>
        <trans-unit id="c45a24f213f8694012485c12afa309d47467f3fd" translate="yes" xml:space="preserve">
          <source>EXAMPLE 7 (Coming Soon)</source>
          <target state="translated">例子7(即将推出)</target>
        </trans-unit>
        <trans-unit id="efa7b38bfff5f32b2321e835dcdafd3692ef4121" translate="yes" xml:space="preserve">
          <source>EXAMPLE 8 (Coming Soon)</source>
          <target state="translated">例子8 (即将推出)</target>
        </trans-unit>
        <trans-unit id="62774320706bd47493c114307c201f9b0569a380" translate="yes" xml:space="preserve">
          <source>EXAMPLE 9 Passing open files to XSes</source>
          <target state="translated">例子9 将打开的文件传给XSes</target>
        </trans-unit>
        <trans-unit id="5620a0ea3c2afd67a246637da41377405c24e6fb" translate="yes" xml:space="preserve">
          <source>EXAMPLE OF A SIMPLE PATCH</source>
          <target state="translated">一个简单的补丁示例</target>
        </trans-unit>
        <trans-unit id="a8099c29efbd0420188d4a7efe08cb02085720f0" translate="yes" xml:space="preserve">
          <source>EXAMPLE: $ perl -e&quot;exit 44;&quot; Non-hushed error exit %SYSTEM-F-ABORT, abort DCL message $ show sym $STATUS $STATUS == &quot;%X0000002C&quot;</source>
          <target state="translated">示例:$ perl -e &quot;exit 44;&quot; 非推送错误退出 %SYSTEM-F-ABORT,终止 DCL 消息 $ show sym $STATUS $STATUS ==&quot;%X0000002C&quot;</target>
        </trans-unit>
        <trans-unit id="a06e781ed035862478fdb8e74e8410d0fb77a7e0" translate="yes" xml:space="preserve">
          <source>EXAMPLE: if ($quiet_exit) { vmsish::hushed(1); } print &quot;Sssshhhh...I'm hushed...\n&quot; if vmsish::hushed(); exit 44;</source>
          <target state="translated">EXAMPLE:if ($quiet_exit){vmsish::hashed(1);}print &quot;Sssshhhh...I'm hushed...\n&quot; if vmsish::hashed();exit 44;</target>
        </trans-unit>
        <trans-unit id="c8296cf24395c1237ea3d8bd4a47331705d59199" translate="yes" xml:space="preserve">
          <source>EXAMPLE: use vmsish 'hushed'; # turn on hushed flag use Carp; # Carp compiled hushed exit 44; # will be hushed croak('I die'); # will be hushed no vmsish 'hushed'; # turn off hushed flag exit 44; # will not be hushed croak('I die2'): # WILL be hushed, croak was compiled hushed</source>
          <target state="translated">示例:使用vmsish 'husthed';#开启husthed标志使用Carp;#Carp编译husthed退出44;#将被husthed croak('I die');#将被husthed no vmsish 'husthed';#关闭husthed标志退出44;#将不被husthed croak('I die2')。#将会被静音,croak被编译为hrusthed。</target>
        </trans-unit>
        <trans-unit id="9659699670b30983eb4e3c22454887e3c9c6ce39" translate="yes" xml:space="preserve">
          <source>EXAMPLES</source>
          <target state="translated">EXAMPLES</target>
        </trans-unit>
        <trans-unit id="80b0ebd5e30f42e63544199d92ca94554dccc4b9" translate="yes" xml:space="preserve">
          <source>EXCEPTIONS</source>
          <target state="translated">EXCEPTIONS</target>
        </trans-unit>
        <trans-unit id="b7510c8c453004eea60fefa1e03b9543d11c009d" translate="yes" xml:space="preserve">
          <source>EXIT CODES</source>
          <target state="translated">出口代码</target>
        </trans-unit>
        <trans-unit id="3a06c7d53de8e4207bc5b59139ccca4aa8a85a6b" translate="yes" xml:space="preserve">
          <source>EXIT STATUS</source>
          <target state="translated">退出状态</target>
        </trans-unit>
        <trans-unit id="49e2ee12a2cb5c774bfad575cb3bcba82617b335" translate="yes" xml:space="preserve">
          <source>EXITING A THREAD</source>
          <target state="translated">退出主题</target>
        </trans-unit>
        <trans-unit id="e4f2a2341e0d9e2dcbb8ca9ce37431a945288e22" translate="yes" xml:space="preserve">
          <source>EXPECTED METHODS</source>
          <target state="translated">预期的方法</target>
        </trans-unit>
        <trans-unit id="ecfb7a5ad5fc1b4f5cc510ab16d0961139e316c5" translate="yes" xml:space="preserve">
          <source>EXPIRATION SUPPORT</source>
          <target state="translated">期满支持</target>
        </trans-unit>
        <trans-unit id="c0b9641f510bdc263b1b4f8cdf15c1c068ad9fea" translate="yes" xml:space="preserve">
          <source>EXPORT</source>
          <target state="translated">EXPORT</target>
        </trans-unit>
        <trans-unit id="77df0281a5c47be5d00ae61a57ff00e23d9d5e5b" translate="yes" xml:space="preserve">
          <source>EXPORTABLE FUNCTIONS</source>
          <target state="translated">可扩展的功能</target>
        </trans-unit>
        <trans-unit id="22d0596dab83a0920d66ad899d3e61f47464b88e" translate="yes" xml:space="preserve">
          <source>EXPORTABLE VARIABLES</source>
          <target state="translated">外销品种</target>
        </trans-unit>
        <trans-unit id="43aade251566381046f1d9dd6f51422fde3c0fbd" translate="yes" xml:space="preserve">
          <source>EXPORTED FUNCTIONS</source>
          <target state="translated">导出的功能</target>
        </trans-unit>
        <trans-unit id="8b30e3050a39fae8e0c617ff76ab8d47b5f0b044" translate="yes" xml:space="preserve">
          <source>EXPORTED SYMBOLS</source>
          <target state="translated">出口符号</target>
        </trans-unit>
        <trans-unit id="e9e012170f2df7cb18fa26019e2b46cbf4a91319" translate="yes" xml:space="preserve">
          <source>EXPORTS</source>
          <target state="translated">EXPORTS</target>
        </trans-unit>
        <trans-unit id="7b479848a0ec11ad7c3ba1025f3ac20068015bb9" translate="yes" xml:space="preserve">
          <source>EXPORTS (by request only)</source>
          <target state="translated">出口(应要求)</target>
        </trans-unit>
        <trans-unit id="6b6562ec1f5d1b67f0bbd288b913382cd128ba1e" translate="yes" xml:space="preserve">
          <source>EXPORT_LIST: name of a file that is passed to linker to define symbols to be exported.</source>
          <target state="translated">EXPORT_LIST:传递给链接器的文件名,用于定义要导出的符号。</target>
        </trans-unit>
        <trans-unit id="a6fc3ffe71e48b679d9c5609def42ab3c69aa49f" translate="yes" xml:space="preserve">
          <source>EXPORT_OK</source>
          <target state="translated">EXPORT_OK</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="3499643610f3dd44dae6eb02d7fed2d648b428d9" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR作为系统命令执行。返回所收集命令的标准输出。在标量上下文中，它作为单个（可能是多行）字符串返回。在列表上下文中，返回行列表（但是您已经使用 &lt;code&gt;$/&lt;/code&gt; 或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 定义了行）。这是实现 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。的 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 操作者进行更详细讨论的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f586c420e6eaf4cfbda37e4566d4c88b6984ca54" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR作为系统命令执行。返回所收集命令的标准输出。在标量上下文中，它作为单个（可能是多行）字符串返回。在列表上下文中，返回行列表（但是您已经使用 &lt;code&gt;$/&lt;/code&gt; 或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 定义了行）。这是实现 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。的 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 操作者进行更详细讨论的&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4a4d24b33941bccd86ff7ba0c19dc15933e36a4" translate="yes" xml:space="preserve">
          <source>EXTENDED CONSTRUCTS</source>
          <target state="translated">扩建工程</target>
        </trans-unit>
        <trans-unit id="b070e356144357fb71137b31e2e89f09d2f73b53" translate="yes" xml:space="preserve">
          <source>EXTERN.h</source>
          <target state="translated">EXTERN.h</target>
        </trans-unit>
        <trans-unit id="13ae0f4e98553c4041bca1bd5b70b21a5aa6d865" translate="yes" xml:space="preserve">
          <source>EXTRALIBS</source>
          <target state="translated">EXTRALIBS</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="64713135c29a168f621e3cd6c59750f2ec3360d2" translate="yes" xml:space="preserve">
          <source>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</source>
          <target state="translated">每一个&quot;=over&quot;.&quot;=back &quot;区域应该是下列之一:&quot;=回 &quot;区域应是下列之一:</target>
        </trans-unit>
        <trans-unit id="8573b03d1dbd851733546c18897b586541b26327" translate="yes" xml:space="preserve">
          <source>Each &lt;b&gt;File&lt;/b&gt; section reports on a single file. Each &lt;b&gt;Subroutine&lt;/b&gt; section reports on a single subroutine apart from the special cases &quot;(definitions)&quot; and &quot;(main)&quot;. These report, respectively, on subroutine definitions found by the initial symbol table walk and on the main part of the program or module external to all subroutines.</source>
          <target state="translated">每个&amp;ldquo; &lt;b&gt;文件&amp;rdquo;&lt;/b&gt;部分报告一个文件。除了特殊情况&amp;ldquo;（定义）&amp;rdquo;和&amp;ldquo;（主）&amp;rdquo;以外，每个子&lt;b&gt;例程&lt;/b&gt;节均报告单个子例程。这些报告分别报告了由初始符号表walk找到的子例程定义以及所有子例程外部的程序或模块的主要部分。</target>
        </trans-unit>
        <trans-unit id="c3f67868071b09e484f931abe029f1f8f7b5dc16" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt; . If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt; , as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="translated">每个 &lt;code&gt;--$source-option&lt;/code&gt; 选项必须指定由 &lt;code&gt;=&lt;/code&gt; 分隔的键/值对。如果一个选项可以采用多个值，则只需多次指定它，就像上面的 &lt;code&gt;extensions=&lt;/code&gt; 示例一样。如果该选项应为哈希引用，则将该值指定为第二对值，并用a &lt;code&gt;=&lt;/code&gt; 分隔，如上述 &lt;code&gt;pset=&lt;/code&gt; 示例（带有反斜杠的escape &lt;code&gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="114f01b386e99faf35799463e66245b3c628986d" translate="yes" xml:space="preserve">
          <source>Each C type is represented by an entry in the typemap file that is responsible for converting perl variables (SV, AV, HV, CV, etc.) to and from that type. The following sections list all XS types that come with perl by default.</source>
          <target state="translated">每个C类型都由tyemap文件中的一个条目来表示,它负责将perl变量(SV、AV、HV、CV等)转换为该类型。下面的章节列出了默认情况下perl自带的所有XS类型。</target>
        </trans-unit>
        <trans-unit id="45fe11f5c5ad8666badf6e1b74648061569fd2e9" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt; , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="translated">每个CV都有一个指向其词汇包围的CV 的指针 &lt;code&gt;CvOUTSIDE()&lt;/code&gt; （如果有）。由于指向匿名子原型的指针存储在 &lt;code&gt;&amp;amp;&lt;/code&gt; pad插槽中，因此有可能获得循环引用，父对象指向子对象，反之亦然。为了避免随之而来的内存泄漏，我们不会增加由指着CV的引用计数 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="877f690dc448228c6c71438f034057615156195d" translate="yes" xml:space="preserve">
          <source>Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be evaluated in the presence of certain variables to get the final C code for mapping a certain C type.</source>
          <target state="translated">每个INPUT或OUTPUT类型映射条目都是一个双引号的Perl字符串,它将在某些变量的存在下被评估,以获得映射某个C类型的最终C代码。</target>
        </trans-unit>
        <trans-unit id="fb013f151204036ffe28cd6f1b7420c85313acfd" translate="yes" xml:space="preserve">
          <source>Each NAME is assumed to be in the calling package. See share_from for an alternative method (which &lt;code&gt;share&lt;/code&gt; uses).</source>
          <target state="translated">假定每个名称都在调用包中。有关替代方法（ &lt;code&gt;share&lt;/code&gt; 使用），请参见share_from 。</target>
        </trans-unit>
        <trans-unit id="5c9985ee57f0e8b2c8e51c7278e3d4c3d9b47d87" translate="yes" xml:space="preserve">
          <source>Each NAME must be the &lt;b&gt;name&lt;/b&gt; of a non-lexical variable, typically with the leading type identifier included. A bareword is treated as a function name.</source>
          <target state="translated">每个NAME必须是非词法变量的&lt;b&gt;名称&lt;/b&gt;，通常包括前导类型标识符。裸字被视为函数名称。</target>
        </trans-unit>
        <trans-unit id="2d1afe9f64b8afc5ff5d1587bde457161df361bb" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">每个数组 &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 保留由Perl编译的文件的$ filename行。对于包含子例程或当前正在执行的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f0c2f3d8605c13877f68e54dd82f6341b8fae0" translate="yes" xml:space="preserve">
          <source>Each class can define its &lt;b&gt;attributes&lt;/b&gt;. When we instantiate an object, we assign values to those attributes. For example, every &lt;code&gt;File&lt;/code&gt; object has a path. Attributes are sometimes called &lt;b&gt;properties&lt;/b&gt;.</source>
          <target state="translated">每个类都可以定义其&lt;b&gt;属性&lt;/b&gt;。当实例化一个对象时，我们将值分配给那些属性。例如，每个 &lt;code&gt;File&lt;/code&gt; 对象都有一个路径。属性有时称为&lt;b&gt;属性&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="64bf8b278b40ceb1457596f928446c91560cdf44" translate="yes" xml:space="preserve">
          <source>Each compartment has an associated &quot;operator mask&quot;. Recall that perl code is compiled into an internal format before execution. Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. Code evaluated in a compartment compiles subject to the compartment's operator mask. Attempting to evaluate code in a compartment which contains a masked operator will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">每个隔间都有一个相关的 &quot;操作者掩码&quot;。回顾一下,perl代码在执行前会被编译成内部格式。评估perl代码(例如通过 &quot;eval &quot;或 &quot;do 'file'&quot;)会导致代码被编译成内部格式,然后在编译过程中没有错误的情况下,被执行。在一个分格中评估的代码会根据分格的操作符掩码进行编译。试图评估包含掩码操作符的分格中的代码将导致编译失败,并出现错误。代码将不会被执行。</target>
        </trans-unit>
        <trans-unit id="035a2860cc641f9a6aba917e368a923359692185" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="translated">结构数据中的每个元素都有一个访问器方法，该方法用于分配给该元素并获取其值。可以通过在包中声明一个相同名称的 &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 来覆盖默认访问器。 （请参见示例2。）</target>
        </trans-unit>
        <trans-unit id="fd1373d9ec88c46f95e3a35afb96af5418baf7f3" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt; ; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). To check if a particular key is meaningful on your system, use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;
$!{the_key}&lt;/code&gt; ; for a list of legal keys, use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24!&quot;&gt;$!&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%!&lt;/code&gt; 每个元素！仅在 &lt;code&gt;$!&lt;/code&gt; 时才具有真实值！设置为该值。例如，当且仅当 &lt;code&gt;$!&lt;/code&gt; 的当前值时， &lt;code&gt;$!{ENOENT}&lt;/code&gt; 为true 。是 &lt;code&gt;ENOENT&lt;/code&gt; ; 也就是说，如果最近的错误是&amp;ldquo;没有这样的文件或目录&amp;rdquo;（或其道德上的等同：并非所有操作系统都给出该确切错误，当然也不是所有语言）。要检查特定键在您的系统上是否有意义，请使用 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{the_key}&lt;/code&gt; ；有关合法密钥的列表，请使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;，另请参见&lt;a href=&quot;#%24!&quot;&gt;$！&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06a2d451f571f682ca87c1d143e9cc5d9cc9752a" translate="yes" xml:space="preserve">
          <source>Each element of the &lt;code&gt;@tests&lt;/code&gt; array is either:</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 数组的每个元素是：</target>
        </trans-unit>
        <trans-unit id="d55ab66461652be4398995f0bc7395b92cdadc85" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="translated">右侧的每个元素都必须是对正确类型的基准的引用。直接在数组周围加上括号（可能还有 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ）将使数组的每个元素成为右侧引用的对应标量的别名：</target>
        </trans-unit>
        <trans-unit id="4684b159123c6d2eb2be5f3fb5fb6b32cbd2c836" translate="yes" xml:space="preserve">
          <source>Each element's type can be scalar, array, hash, or class.</source>
          <target state="translated">每个元素的类型可以是标量、数组、哈希或类。</target>
        </trans-unit>
        <trans-unit id="4a18db593068986b02fcc2822d10b93bd6ae4e04" translate="yes" xml:space="preserve">
          <source>Each engine is supposed to provide access to a constant structure of the following format:</source>
          <target state="translated">每个引擎都应该提供对以下格式的常量结构的访问。</target>
        </trans-unit>
        <trans-unit id="df21f7171545bb80d42912cbb46608328ace6052" translate="yes" xml:space="preserve">
          <source>Each field in a picture line starts with either &quot;@&quot; (at) or &quot;^&quot; (caret), indicating what we'll call, respectively, a &quot;regular&quot; or &quot;special&quot; field. The choice of pad characters determines whether a field is textual or numeric. The tilde operators are not part of a field. Let's look at the various possibilities in detail.</source>
          <target state="translated">图片行中的每个字段都以&quot;@&quot;(at)或&quot;^&quot;(caret)开头,分别表示我们所说的 &quot;常规 &quot;或 &quot;特殊 &quot;字段。垫字符的选择决定了一个字段是文本还是数字。符号运算符不是字段的一部分。我们来详细看看各种可能性。</target>
        </trans-unit>
        <trans-unit id="e86751063b4744e62f491d3c6500569d32c72d11" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt; , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), or when &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="translated">Perl中的每个文件句柄都会计算从其中读取的行数。（取决于 &lt;code&gt;$/&lt;/code&gt; 的值，Perl关于组成行的想法可能与您的想法不符。）当从文件句柄中读取行（通过 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）时，或者 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; 为呼吁， &lt;code&gt;$.&lt;/code&gt; 成为该文件句柄的行计数器的别名。</target>
        </trans-unit>
        <trans-unit id="31a9624b1b717a0ce3347c2a7723ee1a1d25abab" translate="yes" xml:space="preserve">
          <source>Each handle can be an &lt;code&gt;IO::Handle&lt;/code&gt; object, an integer or an array reference where the first element is an &lt;code&gt;IO::Handle&lt;/code&gt; or an integer.</source>
          <target state="translated">每个句柄可以是 &lt;code&gt;IO::Handle&lt;/code&gt; 对象，整数或数组引用，其中第一个元素是 &lt;code&gt;IO::Handle&lt;/code&gt; 或整数。</target>
        </trans-unit>
        <trans-unit id="c1d7462289e4cec1a7aa1fe4c855d903202ec597" translate="yes" xml:space="preserve">
          <source>Each hash &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains breakpoints and actions keyed by line number. Individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">每个哈希 &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 包含断点和以行号为键的操作。可以设置单个条目（而不是整个散列）。Perl在这里只关心布尔值true，尽管</target>
        </trans-unit>
        <trans-unit id="62cc45eed91752b51404de9ea925a035fb43cbad" translate="yes" xml:space="preserve">
          <source>Each id must be unique within the document.</source>
          <target state="translated">每个ID在文档中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="667975ad4758db6be064d162ec07e954e503457b" translate="yes" xml:space="preserve">
          <source>Each individual compressed data stream is read until the logical end-of-file is reached. Then &lt;code&gt;nextStream&lt;/code&gt; is called. This will skip to the start of the next compressed data stream and clear the end-of-file flag.</source>
          <target state="translated">读取每个单独的压缩数据流，直到达到逻辑文件结尾。然后 &lt;code&gt;nextStream&lt;/code&gt; 。这将跳到下一个压缩数据流的开始，并清除文件结束标志。</target>
        </trans-unit>
        <trans-unit id="18f2cec26478e04f9b7de7d10fcbddee95e58d2c" translate="yes" xml:space="preserve">
          <source>Each initializer is a pair of values:</source>
          <target state="translated">每个初始化器都是一对值。</target>
        </trans-unit>
        <trans-unit id="16164820a467e235638c757ccfe00052f4c79b5f" translate="yes" xml:space="preserve">
          <source>Each is a reference to an array of hostnames (in order of preference), which should be used for the given protocol</source>
          <target state="translated">每一个都是对主机名数组的引用(按优先级排序),这些主机名应该用于指定的协议。</target>
        </trans-unit>
        <trans-unit id="c7c5e455da6b08e4d8e8bc9f42db356fdab7233a" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; would return.</source>
          <target state="translated">每个键都是最长，最具描述性的形式的属性名称。这些值是&lt;a href=&quot;#charprop()&quot;&gt;charprop（）&lt;/a&gt;将返回的值。</target>
        </trans-unit>
        <trans-unit id="47492265b46ae806bb067e9b524f132422627a4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">每个字母后面可以有一个数字，指示重复计数。数字重复计数可以有选择地放在方括号中，如 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 。当与除 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，@以外的所有格式类型一起使用时，重复计数吞噬了LIST中的许多值 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; ，表示其他含义，如下所述。提供 &lt;code&gt;*&lt;/code&gt; 重复计数而不是数字表示要使用，但是剩下很多项目，除了：</target>
        </trans-unit>
        <trans-unit id="f1b93edbbeb731023c3dcd7b867f87661f785306" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">每个字母后面可以有一个数字，指示重复计数。数字重复计数可以有选择地放在方括号中，如 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 。当与除 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，@以外的所有格式类型一起使用时，重复计数吞噬了LIST中的许多值 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; ，表示其他含义，如下所述。提供 &lt;code&gt;*&lt;/code&gt; 重复计数而不是数字表示要使用，但是剩下很多项目，除了：</target>
        </trans-unit>
        <trans-unit id="0ca2b686ea513abcdcd81b004dc80b72da247c37" translate="yes" xml:space="preserve">
          <source>Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.</source>
          <target state="translated">每个locale键都是对上面形式的哈希的引用,并给出了该特定locale的casing规则,当在该locale中时,这些规则优先于与本地无关的规则。</target>
        </trans-unit>
        <trans-unit id="b81c66f6a67c62b4046a77844c9acd84b539087f" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt; , which will assume a 1 for you, just to be different.</source>
          <target state="translated">每个方法都返回 &lt;code&gt;IO::Handle&lt;/code&gt; 属性的旧值。每个方法都带有一个可选的EXPR，如果提供了EXPR，则为所讨论的 &lt;code&gt;IO::Handle&lt;/code&gt; 属性指定新值。如果未提供，则大多数方法对当前值不执行任何操作-除了 &lt;code&gt;autoflush()&lt;/code&gt; ，它会为您假设1，只是有所不同。</target>
        </trans-unit>
        <trans-unit id="0a408a79f13c6ec4a0cd81e57c787564393f289b" translate="yes" xml:space="preserve">
          <source>Each name-type pair declares one element of the struct. Each element name will be defined as an accessor method unless a method by that name is explicitly defined; in the latter case, a warning is issued if the warning flag (&lt;b&gt;-w&lt;/b&gt;) is set.</source>
          <target state="translated">每个名称类型对都声明该结构的一个元素。除非显式定义了使用该名称的方法，否则每个元素名称都将被定义为访问器方法。在后一种情况下，如果设置了警告标志（&lt;b&gt;-w&lt;/b&gt;），则发出警告。</target>
        </trans-unit>
        <trans-unit id="bea2fa8177204a00acbe330d65cd373309740d46" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;$section_spec&lt;/code&gt; arguments should be a section specification as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;. The section specifications are parsed by this method and the resulting regular expressions are stored in the invoking object.</source>
          <target state="translated">每个 &lt;code&gt;$section_spec&lt;/code&gt; 参数都应该是&lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS中&lt;/a&gt;所描述的节规范。通过此方法解析节规范，并将所得的正则表达式存储在调用对象中。</target>
        </trans-unit>
        <trans-unit id="9af6792ba1f44d7cb824f7440960f3ef5c01b6ba" translate="yes" xml:space="preserve">
          <source>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</source>
          <target state="translated">POSIX的每一个类都和它们的ASCII范围对应的类完全匹配。</target>
        </trans-unit>
        <trans-unit id="be167c32ebe292b1abf425a82a9d67c142fdc9a5" translate="yes" xml:space="preserve">
          <source>Each of the argument lists above comes out of the &lt;code&gt;normalize_f&lt;/code&gt; function looking exactly the same, like this:</source>
          <target state="translated">上面的每个参数列表都来自 &lt;code&gt;normalize_f&lt;/code&gt; 函数，看起来完全一样，如下所示：</target>
        </trans-unit>
        <trans-unit id="93679dc7d627c4c7a6a3897712645c4450ba1379" translate="yes" xml:space="preserve">
          <source>Each of the commands that produce listings of modules (&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) also return a list of the IDs of all modules within the list.</source>
          <target state="translated">产生模块列表的每个命令（ &lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;autobundle&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; ）也会返回列表中所有模块的ID列表。</target>
        </trans-unit>
        <trans-unit id="36a145ce6b55d2eacd4e152e8b778cb0812f1b4c" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt; ) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; etc. (in these examples &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">之前描述的每个正则表达式基本项（例如 &lt;code&gt;ab&lt;/code&gt; 或 &lt;code&gt;\Z&lt;/code&gt; ）在输入字符串的给定位置最多可以匹配一个子字符串。但是，在典型的正则表达式中，这些基本部分使用组合运算符 &lt;code&gt;ST&lt;/code&gt; ， &lt;code&gt;S|T&lt;/code&gt; ， &lt;code&gt;S*&lt;/code&gt; 等组合为更复杂的模式（在这些示例中， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 为正则子表达式）。</target>
        </trans-unit>
        <trans-unit id="bf85de30bb2350d06139ae6bc58a79af96a26e97" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt; , immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt; ) and will exit with a status of 2:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都将显示&amp;ldquo;语法错误&amp;rdquo;消息。（后跟换行符）到 &lt;code&gt;STDERR&lt;/code&gt; ，紧随其后的是&amp;ldquo; SYNOPSIS&amp;rdquo;部分（也打印到 &lt;code&gt;STDERR&lt;/code&gt; ），并且退出状态为2：</target>
        </trans-unit>
        <trans-unit id="da247936c8bb95b82240dfbb57e8459e5c728eb2" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print just the &quot;SYNOPSIS&quot; section to &lt;code&gt;STDERR&lt;/code&gt; and will exit with a status of 2:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都只会将&amp;ldquo; SYNOPSIS&amp;rdquo;部分打印到 &lt;code&gt;STDERR&lt;/code&gt; ，并以状态2退出：</target>
        </trans-unit>
        <trans-unit id="c3bf15a510b108560bc55f9dc642118c67f04409" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the &quot;SYNOPSIS&quot; section and any &quot;OPTIONS&quot; and/or &quot;ARGUMENTS&quot; sections to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都会将&amp;ldquo; SYNOPSIS&amp;rdquo;部分以及任何&amp;ldquo; OPTIONS&amp;rdquo;和/或&amp;ldquo; ARGUMENTS&amp;rdquo;部分打印到 &lt;code&gt;STDOUT&lt;/code&gt; ,并且退出状态为1：</target>
        </trans-unit>
        <trans-unit id="8a8549150e98bb7d0199412efeddf54defc2c85f" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the entire manual page to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都会将整个手册页打印到 &lt;code&gt;STDOUT&lt;/code&gt; 并以状态1退出：</target>
        </trans-unit>
        <trans-unit id="159291495d574283955b7dd83a0159a4cbe57ab7" translate="yes" xml:space="preserve">
          <source>Each of the following methods will return the total number of corresponding tests if called in scalar context. If called in list context, returns the descriptions of the parsers which contain the corresponding tests (see &lt;code&gt;add&lt;/code&gt; for an explanation of description.</source>
          <target state="translated">如果在标量上下文中调用，以下每个方法将返回相应测试的总数。如果在列表上下文中调用，则返回包含相应测试的解析器的描述（有关说明的说明，请参见 &lt;code&gt;add&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4805d0a6e23a882a6f379f5e1aaffac33d67fcd" translate="yes" xml:space="preserve">
          <source>Each of the functions will now be discussed in turn.</source>
          <target state="translated">现在将依次讨论每项职能。</target>
        </trans-unit>
        <trans-unit id="cf8ee854b23795d139b708dbd25340dc64f25e5b" translate="yes" xml:space="preserve">
          <source>Each of the functions will return</source>
          <target state="translated">每个函数都会返回</target>
        </trans-unit>
        <trans-unit id="67d949b14cef9bc96632c4a26c1317dd5c052479" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt; , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</source>
          <target state="translated">无论您在何处执行程序，每个整数包代码 &lt;code&gt;sSlLqQ&lt;/code&gt; 都会产生固定数量的字节。这对于某些应用程序可能很有用，但是它没有提供一种可移植的方式在Perl和C程序之间传递数据结构（在调用XS扩展名或Perl函数 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 时必定发生），或者在读取或写入二进制文件时会发生这种情况。。在这种情况下，您需要的是模板代码，这些模板代码取决于您在编写 &lt;code&gt;short&lt;/code&gt; 代码或 &lt;code&gt;unsigned long&lt;/code&gt; 代码时本地C编译器的编译内容， 例如。这些代码及其对应的字节长度如下表所示。由于C标准相对于这些数据类型的相对大小还有很多余地，因此实际值可能会有所不同，这就是为什么这些值在C和Perl中以表达式形式给出。 （如果要在程序中使用 &lt;code&gt;%Config&lt;/code&gt; 中的值，则必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 导入它。）</target>
        </trans-unit>
        <trans-unit id="35d0d0049982558d7e176e2f3ab3ea596bc6e428" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt; . Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for more information.</source>
          <target state="translated">下面的每个方法（config（），precision（）和precision（）除外）都接受三个附加参数。这些论点 &lt;code&gt;$A&lt;/code&gt; ， &lt;code&gt;$P&lt;/code&gt; 和 &lt;code&gt;$R&lt;/code&gt; 是 &lt;code&gt;accuracy&lt;/code&gt; ， &lt;code&gt;precision&lt;/code&gt; 和 &lt;code&gt;round_mode&lt;/code&gt; 。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;精度和精度&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="69bb55af40d1c4ccf668c4ee509cae7b3650aeb0" translate="yes" xml:space="preserve">
          <source>Each of the methods works identically, and is used to install (or uninstall) a single DBM Filter. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">每一种方法的工作原理都是一样的,都是用来安装(或卸载)一个DBM过滤器。它们之间的唯一区别是过滤器的安装位置。</target>
        </trans-unit>
        <trans-unit id="deb52f34c0e7c886d38c077a6693f8fac31c72b2" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads and recursion&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="translated">每个目标仅创建一次（但请参见下面的&lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads和递归&lt;/a&gt;），并且当操作码需要在堆栈中放置整数，双精度或字符串时，它只需设置其相应部分即可</target>
        </trans-unit>
        <trans-unit id="61645526a5f8cc5b5b38c365e573e3b9ce2a363a" translate="yes" xml:space="preserve">
          <source>Each of these areas will be discussed in the following sections.</source>
          <target state="translated">以下各节将讨论这些领域中的每一个领域。</target>
        </trans-unit>
        <trans-unit id="4a7e0927366cb3008e3cb582f1225e023afb76ec" translate="yes" xml:space="preserve">
          <source>Each of these functions are called without arguments and return the absolute path of the current working directory.</source>
          <target state="translated">这些函数的调用都没有参数,并返回当前工作目录的绝对路径。</target>
        </trans-unit>
        <trans-unit id="fb6c26bfd690fb609fa0a362b968489c94f785d7" translate="yes" xml:space="preserve">
          <source>Each of these input objects are described in further detail in the sections which follow.</source>
          <target state="translated">这些输入对象中的每一个都将在下面的章节中进一步详细描述。</target>
        </trans-unit>
        <trans-unit id="cd0ac943df3c5c0919c257e9e2ba53e934e28e43" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument, except</source>
          <target state="translated">这些方法都可以修改第一个输入参数,除了</target>
        </trans-unit>
        <trans-unit id="94636e821462a702e9dcf821156451ce10166f58" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument.</source>
          <target state="translated">这些方法都可以修改第一个输入参数。</target>
        </trans-unit>
        <trans-unit id="1fd6321d309f67bf764c8af9cff581fae0812fa5" translate="yes" xml:space="preserve">
          <source>Each of these nodes represents an op, a fundamental operation inside the Perl core. The code which implements each operation can be found in the</source>
          <target state="translated">每一个节点都代表一个 op,这是 Perl 内核的一个基本操作。实现每个操作的代码可以在</target>
        </trans-unit>
        <trans-unit id="33d6b2a3cedc47a8c8496247740303b046f066c7" translate="yes" xml:space="preserve">
          <source>Each of these options is optional; you can include some, all, or none of them.</source>
          <target state="translated">这些选项中的每一个都是可选的,你可以包含部分、全部或不包含。</target>
        </trans-unit>
        <trans-unit id="d1f0b67ca5c809a794efbf846b5f11a39a783c34" translate="yes" xml:space="preserve">
          <source>Each operand is considered in a modified scalar context, the modification being that array and hash variables are passed by reference to the operator, which implicitly dereferences them. Both elements of each pair are the same:</source>
          <target state="translated">每个操作数都是在修改后的标量上下文中考虑的,修改的地方是数组和哈希变量是通过对操作数的引用来传递的,而操作数的引用是隐含地对它们进行减引的。每个操作数对的两个元素都是一样的。</target>
        </trans-unit>
        <trans-unit id="76254c26642feac52117b7e65ad2b643499a9d47" translate="yes" xml:space="preserve">
          <source>Each operator has both a terse name (its opname) and a more verbose or recognisable descriptive name. The opdesc function can be used to return a list of descriptions for a list of operators.</source>
          <target state="translated">每个操作符都有一个简洁的名称(它的opname)和一个更简洁的或可识别的描述性名称。opdesc函数可以用来返回一个操作符列表的描述列表。</target>
        </trans-unit>
        <trans-unit id="0ffccbf8d7d785427858064bfe414c9a343b8478" translate="yes" xml:space="preserve">
          <source>Each option specifier consists of two parts: the name specification and the argument specification.</source>
          <target state="translated">每个选项指定器由两部分组成:名称规格和参数规格。</target>
        </trans-unit>
        <trans-unit id="49dbe9df44df46422e8ed79c89a972f7e0a049b6" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; . The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="translated">每个软件包都包含一个称为 &lt;code&gt;@ISA&lt;/code&gt; 的特殊数组。该 &lt;code&gt;@ISA&lt;/code&gt; 数组包含类的父类的列表，如果有的话。当Perl执行方法解析时，将检查此数组，我们将在后面讨论。</target>
        </trans-unit>
        <trans-unit id="fd56746947dceb1b1ebf83666e64df3d893f0573" translate="yes" xml:space="preserve">
          <source>Each pair is an array reference with two elements - namely the</source>
          <target state="translated">每一对都是一个有两个元素的数组引用,分别是</target>
        </trans-unit>
        <trans-unit id="79339b4554cd8ab3b93700df12bacff7c6d9a530" translate="yes" xml:space="preserve">
          <source>Each pathname that is a directory that matches the pattern has a slash appended.</source>
          <target state="translated">每个符合模式的目录的路径名都有一个斜杠。</target>
        </trans-unit>
        <trans-unit id="20b56d27482026f6b453dfe18f7f652ebd744ed0" translate="yes" xml:space="preserve">
          <source>Each plugin should register itself by providing the following structure</source>
          <target state="translated">每个插件都应该通过提供以下结构来注册自己。</target>
        </trans-unit>
        <trans-unit id="4bc675eeb53212d68aff2215974b513fa9d0ff3e" translate="yes" xml:space="preserve">
          <source>Each programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.</source>
          <target state="translated">当然,每个程序员在格式方面都有自己的偏好,但有一些通用的准则可以让你的程序更容易阅读、理解和维护。</target>
        </trans-unit>
        <trans-unit id="e2d7e5e3cbcd85e0f15e433073f3c09c16649807" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual environment. Modifications to %ENV affect the virtual environment, and are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it.</source>
          <target state="translated">每个伪进程都会维护自己的虚拟环境,对%ENV的修改会影响到虚拟环境,而且只有在该伪进程内以及从它启动的任何进程(或伪进程)中才能看到。对%ENV的修改会影响虚拟环境,并且只在该伪进程内以及从它启动的任何进程(或伪进程)中可见。</target>
        </trans-unit>
        <trans-unit id="25a97b930031adadf111787667688ded94505539" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual idea of the current directory. Modifications to the current directory using chdir() are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it. All file and directory accesses from the pseudo-process will correctly map the virtual working directory to the real working directory appropriately.</source>
          <target state="translated">每个伪进程都维护着它自己对当前目录的虚拟概念。使用chdir()对当前目录的修改仅在该伪进程内以及从它启动的任何进程(或伪进程)中可见。所有来自伪进程的文件和目录访问都会正确地将虚拟工作目录适当地映射到真实工作目录。</target>
        </trans-unit>
        <trans-unit id="8f4f1268e7fb63f76b0f62897f0f8014b138b792" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">每个结果位都基于相应输入字符的最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 生成位0和1，字符 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abf39ff7c44d3c8c17f0be2056a001c031f6f08e" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">每个结果位都基于相应输入字符的最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 生成位0和1，字符 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1801d81c7323468b4de78bc480016b6092b96d8e" translate="yes" xml:space="preserve">
          <source>Each result fetched is a result object of a different type. There are common methods to each result object and different types may have methods unique to their type. Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</source>
          <target state="translated">获取的每个结果都是一个不同类型的结果对象。每个结果对象都有共同的方法,不同类型可能有其类型特有的方法。有时一个类型的方法可能会在子类中被重写,但保证其用法是相同的。</target>
        </trans-unit>
        <trans-unit id="fca0f4c2c0d0f6d5b588e090e9018c1d20041904" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="translated">返回的每个结果都是&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;子类，称为</target>
        </trans-unit>
        <trans-unit id="d0a1f92895a8d5d3bca2a476a0ec322b95e7589a" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="translated">返回的每个结果都是&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。请参阅该模块和相关类，以获取有关如何使用它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="8f5ef808a290d77bcb78c1a52baf58c7827e311b" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">每个标量 &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 包含 &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; 。对于包含子例程或当前正在执行的已评估字符串，情况也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b759249474717644d66332dcc04eba32c6b818f" translate="yes" xml:space="preserve">
          <source>Each semaphore has a counter attached to it. By default, semaphores are created with the counter set to one, &lt;code&gt;down()&lt;/code&gt; decrements the counter by one, and &lt;code&gt;up()&lt;/code&gt; increments by one. However, we can override any or all of these defaults simply by passing in different values:</source>
          <target state="translated">每个信号量都有一个附加的计数器。默认情况下，信号量是在将计数器设置为1的情况下创建的， &lt;code&gt;down()&lt;/code&gt; 将计数器递减1，而 &lt;code&gt;up()&lt;/code&gt; 递增1。但是，我们可以简单地通过传递不同的值来覆盖任何或所有这些默认值：</target>
        </trans-unit>
        <trans-unit id="9e3598640cb6381c253bcf070a1e62dc7e9d0823" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;|  1:  STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="translated">每个步骤的形式为 &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; 匹配的字符串部分和 &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; 尚未匹配的部分。该 &lt;code&gt;| 1: STAR&lt;/code&gt; 表示Perl在上面的编译列表中位于第1行。有关更多详细信息，请参见&lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;perldebguts中的调试正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3defe21495aad5ab5041830fd4fe29198a67142" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; is called, the iterator returns one of two possible values:</source>
          <target state="translated">每次调用 &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; ，迭代器都会返回以下两个可能值之一：</target>
        </trans-unit>
        <trans-unit id="54bbe29b947a5618329ec98194ec80f8aabe46b6" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; . Blank lines are generally ignored.</source>
          <target state="translated">每种类型的节都可以出现任意次，并且根本不必出现。例如，如果类型映射仅需要将其他C类型与核心XS类型（如T_PTROBJ）相关联，则通常可能缺少 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 部分。以 &lt;code&gt;TYPEMAP&lt;/code&gt; &lt;code&gt;#&lt;/code&gt; 开头的行在TYPEMAP部分中被视为注释，并被忽略，但在 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 中被认为是重要的。空行通常被忽略。</target>
        </trans-unit>
        <trans-unit id="c99826defe1aa3e0e7dfa632ce9b50c12211fd46" translate="yes" xml:space="preserve">
          <source>Each typedef has specific routines that manipulate the various data types.</source>
          <target state="translated">每个typedef都有特定的例程来操作各种数据类型。</target>
        </trans-unit>
        <trans-unit id="a786e808038f24779f10721b5785e1d471731d02" translate="yes" xml:space="preserve">
          <source>Each value in the results list will be a hash reference containing the following fields:</source>
          <target state="translated">结果列表中的每个值将是一个包含以下字段的哈希引用:</target>
        </trans-unit>
        <trans-unit id="d6fa3b1f2df46de4d0da0473d7f7df5be8fdd538" translate="yes" xml:space="preserve">
          <source>Each version of Perl comes with the documentation that was current at the time of release. This poses a problem for content such as book lists. There are probably very nice books published after this list was included in your Perl release, and you can check the latest released version at &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</source>
          <target state="translated">每个版本的Perl都带有发行时最新的文档。这给诸如书单之类的内容带来了问题。在您的Perl版本中包含此列表之后，可能会出版非常好的书籍，您可以在&lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html上&lt;/a&gt;查看最新发行的版本。</target>
        </trans-unit>
        <trans-unit id="a017204ca793ea63195213655418d18b5e46cf36" translate="yes" xml:space="preserve">
          <source>Earlier Mac OS X releases (10.2 &quot;Jaguar&quot; and older) did not include a completely thread-safe libc, so threading is not fully supported. Also, earlier releases included a buggy libdb, so some of the DB_File tests are known to fail on those releases.</source>
          <target state="translated">早期的Mac OS X版本(10.2 &quot;Jaguar &quot;和更早的版本)没有包含一个完全线程安全的libc,所以线程没有得到完全支持。此外,早期的版本包含了一个错误的libdb,所以一些DB_File测试在这些版本上会失败。</target>
        </trans-unit>
        <trans-unit id="a252186ae05a758597f2268019d7fe33e7216333" translate="yes" xml:space="preserve">
          <source>Earlier releases caveats</source>
          <target state="translated">早期版本的注意事项</target>
        </trans-unit>
        <trans-unit id="8144bf937e246b0c3995f39e74e8340a0ff57aa1" translate="yes" xml:space="preserve">
          <source>Earlier than Perl 5.10, you have a bit of work to do. You want to avoid compiling a regular expression every time you want to match it. In this example, perl must recompile the regular expression for every iteration of the &lt;code&gt;foreach&lt;/code&gt; loop since it has no way to know what &lt;code&gt;$pattern&lt;/code&gt; will be:</source>
          <target state="translated">在Perl 5.10之前，您需要做一些工作。您希望避免每次想要匹配时都编译正则表达式。在此示例中，perl必须为 &lt;code&gt;foreach&lt;/code&gt; 循环的每次迭代重新编译正则表达式，因为它无法知道 &lt;code&gt;$pattern&lt;/code&gt; 是什么：</target>
        </trans-unit>
        <trans-unit id="2412eca1a81df7ff0f1d8fd57bf151a2e60cb6ee" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl accepted almost all the 6.1 names. These were most extensively documented in the v5.14 version of this pod: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt;.</source>
          <target state="translated">Perl的早期版本几乎接受所有6.1名称。这些内容在此pod的v5.14版本中得到了最广泛的记录：&lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http&lt;/a&gt; ://perldoc.perl.org/5.14.0/charnames.html#ALIASES 。</target>
        </trans-unit>
        <trans-unit id="041f750894a2130f024fa1d40c0e0cb8140d53b7" translate="yes" xml:space="preserve">
          <source>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</source>
          <target state="translated">早期版本的Storable如果遇到一个内部版本号高于Storable所知道的读取的文件,就会立即呱呱叫。每当新的数据类型(如限制性哈希)被添加到文件格式的词汇中时,内部版本号就会增加。这意味着,一个新的Storable模块没有办法写入一个旧的Storable可读的文件,即使写入者没有存储新的数据类型。</target>
        </trans-unit>
        <trans-unit id="641edf650debd12f3350ba77247f6ae399c9cef3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="translated">之前，我们提到 &lt;code&gt;File&lt;/code&gt; 类的 &lt;code&gt;last_mod_time&lt;/code&gt; 访问器可以返回&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;对象。这是构图的完美示例。我们可以走得更远，并使 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; 访问器也返回对象。然后， &lt;code&gt;File&lt;/code&gt; 类将由其他几个对象&lt;b&gt;组成&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="1e2d95ddabd105e29656829184c35d2859c555dc" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="translated">早期的Perl版本可以在一些EBCDIC机器上工作,但最后一个在EBCDIC上运行的已知版本是v5.8.7,直到v5.22,Perl核心又可以在z/OS上工作。理论上,它可以在OS/400或西门子的BS2000(或它们的后续产品)上工作,但这是未经测试的。在v5.22中,并不是所有在CPAN上找到的模块都能在z/OS上工作,而是随核心Perl一起提供的。</target>
        </trans-unit>
        <trans-unit id="59b164194e7edb2e85034e9b78794d560a716b37" translate="yes" xml:space="preserve">
          <source>Ease testing test modules built with Test::Builder</source>
          <target state="translated">轻松测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="7a188f6f02161d17a281a3ef192ea2346304b188" translate="yes" xml:space="preserve">
          <source>Easily interact with CPAN from the command line</source>
          <target state="translated">通过命令行轻松与CPAN互动</target>
        </trans-unit>
        <trans-unit id="995f14f2d2d8a63a7a9da7579e9e95a2acf52319" translate="yes" xml:space="preserve">
          <source>Ed Avis</source>
          <target state="translated">Ed Avis</target>
        </trans-unit>
        <trans-unit id="528c45b93e145146f93473cbaa4675f9b54b16c1" translate="yes" xml:space="preserve">
          <source>Edgar &quot;Trizor&quot; Bering &amp;lt;trizor@gmail.com&amp;gt;</source>
          <target state="translated">埃德加&amp;ldquo; Trizor&amp;rdquo;白令&amp;lt;trizor@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e76b3763dae70623eb55885995406de6279fdb6e" translate="yes" xml:space="preserve">
          <source>Edit the Makefile.PL file so that the corresponding line looks like this:</source>
          <target state="translated">编辑Makefile.PL文件,使相应的行看起来像这样。</target>
        </trans-unit>
        <trans-unit id="f7940347fff54108cd46081728a5cf85408a717b" translate="yes" xml:space="preserve">
          <source>Edit the files generated. You don't have to if you have no time AND no intention to give it to someone else. But it is a good idea to edit the pod and to add more tests.</source>
          <target state="translated">编辑生成的文件。如果你没有时间,也不打算把它给别人,你就不必这样做。但是,编辑pod和添加更多的测试是个好主意。</target>
        </trans-unit>
        <trans-unit id="954ea018e0a987091c4440d55ba64f48e0cccfe8" translate="yes" xml:space="preserve">
          <source>Edit the makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="translated">编辑makefile.mk (或者Makefile,如果你使用的是nmake),并修改INST_DRV和INST_TOP的值。你也可以启用各种构建标志。这些在 makefile 中有解释。</target>
        </trans-unit>
        <trans-unit id="b93bb818c85552f3fcd19e172c258ef9c6aad22d" translate="yes" xml:space="preserve">
          <source>Editor Support for Debugging</source>
          <target state="translated">调试的编辑器支持</target>
        </trans-unit>
        <trans-unit id="68575b9eb0c3bb98d30a72178c5ff21f9fae81f0" translate="yes" xml:space="preserve">
          <source>Editor to use.</source>
          <target state="translated">小编要用。</target>
        </trans-unit>
        <trans-unit id="77cd7c3d29d911531fb7afe572b99c8c5ba4e8b7" translate="yes" xml:space="preserve">
          <source>Editorial adjustments by Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;的编辑调整</target>
        </trans-unit>
        <trans-unit id="73be54c86084c8c273a09c1c9821e5a9131296dd" translate="yes" xml:space="preserve">
          <source>Effect:</source>
          <target state="translated">Effect:</target>
        </trans-unit>
        <trans-unit id="8b7ac9002bbe557a0e89e8f9ac76410e740b68c3" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv), or at least SvPOKp(sv), must be true and the &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. The &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &quot;OOK hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.</source>
          <target state="translated">从字符串缓冲区的开头有效删除字符。SvPOK（sv）或至少SvPOKp（sv）必须为true，并且 &lt;code&gt;ptr&lt;/code&gt; 必须为指向字符串缓冲区内部某处的指针。在 &lt;code&gt;ptr&lt;/code&gt; 成为调整字符串的第一个字符。使用&amp;ldquo; OOK hack&amp;rdquo;。返回时，只有OK标志中的SvPOK（sv）和SvPOKp（sv）为真。</target>
        </trans-unit>
        <trans-unit id="f18b25f084ce81b950168aedca18f94cb1425062" translate="yes" xml:space="preserve">
          <source>Efficiently compute time from local and GMT time</source>
          <target state="translated">高效地计算当地时间和GMT时间。</target>
        </trans-unit>
        <trans-unit id="654f6a3bdd1d9e4bdcf155781a2de9b4ed80c132" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;IO::String&lt;/code&gt; or &lt;code&gt;perlio&lt;/code&gt; support is needed to support writing stringified archives. Currently, &lt;code&gt;perlio&lt;/code&gt; is the preferred method, if available.</source>
          <target state="translated">需要 &lt;code&gt;IO::String&lt;/code&gt; 或 &lt;code&gt;perlio&lt;/code&gt; 支持来支持编写字符串化的存档。当前， &lt;code&gt;perlio&lt;/code&gt; 是首选方法（如果有）。</target>
        </trans-unit>
        <trans-unit id="85dba161f5ca6a960a7dc8fa1039724a8c09cad4" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0), or &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (old-style) where</source>
          <target state="translated">任一 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; （开始在Perl 5.10.0），或 &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; （旧式），其中</target>
        </trans-unit>
        <trans-unit id="cb02a27773229541ab59b1944bd46b1d5a6ebed2" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">可以是常规&lt;b&gt;赋值，&lt;/b&gt;也可以是由普通赋值和其他某种&lt;b&gt;运算符&lt;/b&gt;组成的复合&lt;b&gt;运算&lt;/b&gt;符，它们可以在适当位置更改变量的值；相对于其旧值。例如， &lt;code&gt;$a += 2&lt;/code&gt; 增加了 &lt;code&gt;2&lt;/code&gt; 至 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="281cd0fa078fd4c1ba948d728426cec878f64c16" translate="yes" xml:space="preserve">
          <source>Either assimilate new technologies, or build bridges to them.</source>
          <target state="translated">要么吸收新技术,要么为新技术搭桥。</target>
        </trans-unit>
        <trans-unit id="66b1d548fa9375ac8cee4b6bb3288cae52feda67" translate="yes" xml:space="preserve">
          <source>Either not implemented or a no-op. (Android)</source>
          <target state="translated">要么不执行,要么不操作。(Android)</target>
        </trans-unit>
        <trans-unit id="c47f17b2cb7b7674bb2cbd89473a3cd6f362bf48" translate="yes" xml:space="preserve">
          <source>Either of the following will work instead:</source>
          <target state="translated">以下任何一种方法都可以代替:</target>
        </trans-unit>
        <trans-unit id="e5a6a14049fff21a602c284699a2c9fbe3ca6693" translate="yes" xml:space="preserve">
          <source>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; the same in a path, you might as well use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</source>
          <target state="translated">可以单引号括住您的字符串，或者（最好）使用正斜杠。由于自MS-DOS 2.0之类以来的所有DOS和Windows版本在路径中都将 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 视为相同，因此您最好使用与Perl不冲突的版本-或POSIX shell，ANSI C和C ++，awk，Tcl，Java或Python，仅举几例。POSIX路径也更可移植。</target>
        </trans-unit>
        <trans-unit id="a48425d47cea1024da1aa0b5eb56b9a2e8f4b87c" translate="yes" xml:space="preserve">
          <source>Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper) module from CPAN and layer it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but it can be a bit slow.</source>
          <target state="translated">要么自己对结构进行字符串化 (没意思),要么从 CPAN 获取 MLDBM (它使用 Data::Dumper)模块,然后把它层叠在 DB_File 或 GDBM_File 上。你也可以试试DBM::Deep,但它可能有点慢。</target>
        </trans-unit>
        <trans-unit id="f91179ba5041e3cd11279b2a09e8c8dafe42d600" translate="yes" xml:space="preserve">
          <source>Either the 5.006001 or the 5.6.1 format is acceptable.</source>
          <target state="translated">5.006001或5.6.1格式均可接受。</target>
        </trans-unit>
        <trans-unit id="f3046bc2658fc9703b653ff4f645f1c7f4b09d3a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="translated">当使用带有单个索引的数组切片时， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;标志都会警告您。</target>
        </trans-unit>
        <trans-unit id="906b6fd14fb2f43afa53be4e9384438767144648" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;warnings::warn&lt;/code&gt; or &lt;code&gt;warnings::warnif&lt;/code&gt; function should be used to actually display the warnings message. This is because they can make use of the feature that allows warnings to be escalated into fatal errors. So in this case</source>
          <target state="translated">任一 &lt;code&gt;warnings::warn&lt;/code&gt; 或 &lt;code&gt;warnings::warnif&lt;/code&gt; 功能应当用于实际显示的警告消息。这是因为他们可以利用允许将警告升级为致命错误的功能。所以在这种情况下</target>
        </trans-unit>
        <trans-unit id="0780376e7962816fa4ff7b6a652f65ef6eadb7db" translate="yes" xml:space="preserve">
          <source>Either use parentheses or the high-precedence variant of the operator.</source>
          <target state="translated">要么使用括号,要么使用运算符的高位变体。</target>
        </trans-unit>
        <trans-unit id="a6479b4a431808cf309ed8137f781bb957df27d9" translate="yes" xml:space="preserve">
          <source>Either you don't have more than one line in the string you're looking at (probably), or else you aren't using the correct modifier(s) on your pattern (possibly).</source>
          <target state="translated">要不就是你正在查看的字符串中没有多于一行(可能),要不就是你没有在模式上使用正确的修饰符(可能)。</target>
        </trans-unit>
        <trans-unit id="e45775ed8dae80c63b3497b4ea826a44ca2dea3f" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="translated">Elapsed返回一个&lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt;对象，该对象表示聚合测试的运行时间。为了使 &lt;code&gt;elapsed&lt;/code&gt; 时间有效，您必须在运行测试之前调用 &lt;code&gt;start&lt;/code&gt; ,然后立即 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="685684a16f4001786549b1ab800e18b9d9c7dce4" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the perl5 administrator.</source>
          <target state="translated">perl5管理员的电子邮箱地址。</target>
        </trans-unit>
        <trans-unit id="0206d29187ee24de18ffe8c7060208c783959fc1" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the person who ran Configure. This can be used by units that require the user's e-mail, like</source>
          <target state="translated">运行配置的人的电子邮箱地址。需要用户电子邮箱的单位可以使用此地址,如</target>
        </trans-unit>
        <trans-unit id="fb92ce1ec6eee388978bf1476ef4da0f49ddc2f4" translate="yes" xml:space="preserve">
          <source>Element Types and Accessor Methods</source>
          <target state="translated">元素类型和存取器方法</target>
        </trans-unit>
        <trans-unit id="56be9d95047d3837a8e260ecf6fab5aa5091179f" translate="yes" xml:space="preserve">
          <source>Eliminate the macros in the output to the MMS/MMK file.</source>
          <target state="translated">消除输出到MMS/MMK文件中的宏。</target>
        </trans-unit>
        <trans-unit id="372fe5af53dfb10b96df623d9727deb1110a3dd2" translate="yes" xml:space="preserve">
          <source>Email any corrections or questions to me.</source>
          <target state="translated">如有更正或问题,请发邮件给我。</target>
        </trans-unit>
        <trans-unit id="a5bcdc422fa0c0f86b08b10ed2c448b54076951e" translate="yes" xml:space="preserve">
          <source>Embedded Code Execution Frequency</source>
          <target state="translated">嵌入式代码执行频率</target>
        </trans-unit>
        <trans-unit id="1c0d431f261d9feabca2f4bf0f5d2be5226959da" translate="yes" xml:space="preserve">
          <source>Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on output, due to an internal implementation detail.</source>
          <target state="translated">由于内部实施细节,输入中的嵌入式Ctrl-As(八进制001)将被映射到输出中的空格。</target>
        </trans-unit>
        <trans-unit id="036d707633278129886b9180244ca67da739555e" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using, e.g., &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression, e.g., &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">嵌入式修饰符还可以通过使用 &lt;code&gt;(?-i)&lt;/code&gt; 关闭所有已经存在的修饰符。修饰符也可以组合成单个表达式，例如 &lt;code&gt;(?s-i)&lt;/code&gt; 打开单行模式并关闭不区分大小写。</target>
        </trans-unit>
        <trans-unit id="7b8b1388248a7771ad7a19db052c3e57cdc37002" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers to</source>
          <target state="translated">嵌入式修改器与通常的修改器相比,有两个重要的优势。嵌入的修饰符允许一组自定义的修饰符,以</target>
        </trans-unit>
        <trans-unit id="77fff13bcd07ad216d2d3e4a9dc81f2e17688911" translate="yes" xml:space="preserve">
          <source>Embedded modifiers may also be added to a non-capturing grouping. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; is a non-capturing grouping that matches &lt;code&gt;regexp&lt;/code&gt; case insensitively and turns off multi-line mode.</source>
          <target state="translated">嵌入的修饰符也可以添加到非捕捉分组中。 &lt;code&gt;(?i-m:regexp)&lt;/code&gt; 是一个非捕获组，它不区分大小写地匹配 &lt;code&gt;regexp&lt;/code&gt; 并关闭多行模式。</target>
        </trans-unit>
        <trans-unit id="b92d8665944f4979bd50de8585ed3b0fd45dfa5f" translate="yes" xml:space="preserve">
          <source>Embedding Functions</source>
          <target state="translated">嵌入功能</target>
        </trans-unit>
        <trans-unit id="dfab320700daa38157038d3e70e9093fcfa26c1f" translate="yes" xml:space="preserve">
          <source>Embedding Perl inside a 64-bit application.</source>
          <target state="translated">在64位应用程序中嵌入Perl。</target>
        </trans-unit>
        <trans-unit id="0694b8bb0407da0c117f25cc81dd5d48908ff82d" translate="yes" xml:space="preserve">
          <source>Embedding Perl under Win32</source>
          <target state="translated">在Win32下嵌入Perl</target>
        </trans-unit>
        <trans-unit id="9cbcae97b606ebda37a4c9c0051aab393c7f7d13" translate="yes" xml:space="preserve">
          <source>Embedding Pods in Perl Modules</source>
          <target state="translated">在Perl模块中嵌入花苞</target>
        </trans-unit>
        <trans-unit id="3332088412158a65b80fc73f2172f27d8031dce4" translate="yes" xml:space="preserve">
          <source>Embedding comments and modifiers in a regular expression</source>
          <target state="translated">在正则表达式中嵌入注释和修饰符。</target>
        </trans-unit>
        <trans-unit id="abbe29d0eda029ba0d774099d16a176aaf760777" translate="yes" xml:space="preserve">
          <source>Empty parts of the file/buffer will have NULL (0x00) bytes written to them.</source>
          <target state="translated">文件/缓冲区的空部分将有NULL (0x00)字节写入其中。</target>
        </trans-unit>
        <trans-unit id="bd4ef1b6c1ef24f987c292a748ebade1052ce4dc" translate="yes" xml:space="preserve">
          <source>Empty strings as well as other illegal numbers results in 'NaN'.</source>
          <target state="translated">空字符串以及其他非法数字的结果是'NaN'。</target>
        </trans-unit>
        <trans-unit id="b78fcf2b7184ff747f91ac2d4e85304d73a66a8f" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">清空现有内容的文件，可以在打开要写入的文件时自动清空，也可以通过 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 函数明确清空。</target>
        </trans-unit>
        <trans-unit id="a3810839f51735c2952e4638769a72e1f188779e" translate="yes" xml:space="preserve">
          <source>Emulate low-level math with BigInt code</source>
          <target state="translated">用BigInt代码模拟低级数学。</target>
        </trans-unit>
        <trans-unit id="eaff5ce9fb66a8294a29b4afda7fa93b8fb7b74b" translate="yes" xml:space="preserve">
          <source>Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;. (Win32)</source>
          <target state="translated">使用多个解释器进行仿真。参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;。（Win32的）</target>
        </trans-unit>
        <trans-unit id="a7b07a2e86e21bbe02318bb5339e9e3819d02d9c" translate="yes" xml:space="preserve">
          <source>Emulated using synchronization functions such that it can be interrupted by &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days. (Win32)</source>
          <target state="translated">使用同步功能进行仿真，以使其可以被 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 中断，并且最长为4294967秒，大约49天。（Win32的）</target>
        </trans-unit>
        <trans-unit id="2fab2548b326a0aed3bd44319bab854e6c0cf455" translate="yes" xml:space="preserve">
          <source>Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls. (Win32)</source>
          <target state="translated">使用定时器进行仿真,每当Perl要调度 &quot;安全信号 &quot;时,必须对其进行显式轮询,因此不能中断阻塞系统调用。(Win32)</target>
        </trans-unit>
        <trans-unit id="9b1e45abf8f6f88976507fbf984db8d99aa517be" translate="yes" xml:space="preserve">
          <source>Emulates Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error) by mapping the &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;SS$_ABORT&lt;/code&gt; (&lt;code&gt;44&lt;/code&gt; ). This behavior may be overridden with the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . As with the CRTL's &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of &lt;code&gt;SS$_NORMAL&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt; ); this mapping cannot be overridden. Any other argument to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; is used directly as Perl's exit status. On VMS, unless the future POSIX_EXIT mode is enabled, the exit code should always be a valid VMS exit code and not a generic number. When the POSIX_EXIT mode is enabled, a generic number will be encoded in a method compatible with the C library _POSIX_EXIT macro so that it can be decoded by other programs, particularly ones written in C, like the GNV package. (VMS)</source>
          <target state="translated">通过将 &lt;code&gt;1&lt;/code&gt; 映射到 &lt;code&gt;SS$_ABORT&lt;/code&gt; （ &lt;code&gt;44&lt;/code&gt; ）来模拟Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; （认为 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 指示错误）。可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; vmsish'exit'来覆盖此行为。与CRTL的 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 函数一样， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 0也映射到 &lt;code&gt;SS$_NORMAL&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）的出口状态。此映射不能被覆盖。任何其他参数 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 直接用作Perl的退出状态。在VMS上，除非启用了将来的POSIX_EXIT模式，否则退出代码应始终是有效的VMS退出代码，而不是通用编号。启用POSIX_EXIT模式后，将使用与C库_POSIX_EXIT宏兼容的方法对通用编号进行编码，以便可以由其他程序（尤其是用C编写的程序，如GNV程序包）对其进行解码。（VMS）</target>
        </trans-unit>
        <trans-unit id="a8694061aed01e45167cf3a5722aa921d3e6ee71" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="translated">提供模拟 &lt;code&gt;runtests&lt;/code&gt; 和 &lt;code&gt;execute_tests&lt;/code&gt; 但可插拔&amp;ldquo;绳&amp;rdquo;界面，以前的版本&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;支持不转载。皮带现在可以作为独立模块使用：&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c3201c23058080f5cca7ba534770368c083d322" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all execute options. Equivalent to:</source>
          <target state="translated">启用DUMP和所有执行选项。相当于:</target>
        </trans-unit>
        <trans-unit id="7bb7295d3b950c4331c9fe377d6496cd34ea08ee" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS. (To get every single option without exception, use both ALL and EXTRA.)</source>
          <target state="translated">同时启用除OFFSETS、OFFSETSDBG和BUFFERS以外的所有选项。(要想毫无例外地获得每一个选项,请同时使用ALL和EXTRA。)</target>
        </trans-unit>
        <trans-unit id="7c54f50dbe8b1d2b9d4279a847b1af1e242ac5db" translate="yes" xml:space="preserve">
          <source>Enable caching of timings for the null loop. The time taken for COUNT rounds of the null loop will be calculated only once for each different COUNT used.</source>
          <target state="translated">启用空循环的计时缓存。每使用一个不同的COUNT,null循环的COUNT轮所需时间将只计算一次。</target>
        </trans-unit>
        <trans-unit id="af34a92294247e0324cf9cb4ab7591c0157d3cc4" translate="yes" xml:space="preserve">
          <source>Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.</source>
          <target state="translated">启用偏移量信息的调试。这将发出大量的跟踪信息,并且与其他调试选项不相匹配。</target>
        </trans-unit>
        <trans-unit id="b22eafe66ff9363c232181834545b3e27fc24dda" translate="yes" xml:space="preserve">
          <source>Enable debugging of start-point optimisations.</source>
          <target state="translated">启用启动点优化的调试。</target>
        </trans-unit>
        <trans-unit id="b1ed4094a3f33fb70b77d3ab5d3985c70cad2408" translate="yes" xml:space="preserve">
          <source>Enable debugging of states in the engine.</source>
          <target state="translated">启用引擎中的状态调试。</target>
        </trans-unit>
        <trans-unit id="6cc2f783a9f51a88860f66f38bb6654412ccd3b7" translate="yes" xml:space="preserve">
          <source>Enable debugging of the \G modifier.</source>
          <target state="translated">启用\G修改器的调试。</target>
        </trans-unit>
        <trans-unit id="8b1fc985774fbcf866da54c3c69b513cb35f440c" translate="yes" xml:space="preserve">
          <source>Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</source>
          <target state="translated">启用引擎中递归栈的调试。启用或禁用这个选项也会自动对调试状态进行同样的操作。这其中的输出可能相当大。</target>
        </trans-unit>
        <trans-unit id="ed7bfb6f5b63e62332ddfc6bbbaf1f7a2a0d576b" translate="yes" xml:space="preserve">
          <source>Enable debugging output.</source>
          <target state="translated">启用调试输出。</target>
        </trans-unit>
        <trans-unit id="139048524bc56f6e0f7692e0183c038f5bfd94d8" translate="yes" xml:space="preserve">
          <source>Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</source>
          <target state="translated">在匹配过程中启用调试捕获组存储。警告,这可能会产生非常大的输出。</target>
        </trans-unit>
        <trans-unit id="d009cb1e8dd02879690564369c53161c26ba761e" translate="yes" xml:space="preserve">
          <source>Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</source>
          <target state="translated">启用增强的TRIE调试功能。增强TRIEE和TRIEC的功能。</target>
        </trans-unit>
        <trans-unit id="ef5eb4e7b2447bf19044b39ea2e195cd6618fd76" translate="yes" xml:space="preserve">
          <source>Enable enhanced optimisation debugging and start-point optimisations. Probably not useful except when debugging the regexp engine itself.</source>
          <target state="translated">启用增强的优化调试和起始点优化。除非调试regexp引擎本身,否则可能没什么用。</target>
        </trans-unit>
        <trans-unit id="07e248f2e2b8869e02ee4bbd9a3b445fa1e02104" translate="yes" xml:space="preserve">
          <source>Enable new features</source>
          <target state="translated">启用新功能</target>
        </trans-unit>
        <trans-unit id="82441ac52d9ab4a30896d0bdffedf2a9be220d10" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="translated">启用对 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT_LIST&lt;/code&gt; 和 &lt;code&gt;INOUT_LIST&lt;/code&gt; 声明的识别。默认为true。</target>
        </trans-unit>
        <trans-unit id="a04f3ebaeb9867e3812b1e018ab387d5924f7ef6" translate="yes" xml:space="preserve">
          <source>Enable recognition of ANSI-like descriptions of function signature. Default is true.</source>
          <target state="translated">启用识别类似ANSI的函数签名描述。默认为true。</target>
        </trans-unit>
        <trans-unit id="8fa85b7034e330ca755a5c73c63b76397e087c71" translate="yes" xml:space="preserve">
          <source>Enable simple signal handling</source>
          <target state="translated">启用简单的信号处理</target>
        </trans-unit>
        <trans-unit id="3c3a9e686f47a71d2d2bd49c91054de061662284" translate="yes" xml:space="preserve">
          <source>Enable the breakpoint so it will stop the execution of the program.</source>
          <target state="translated">启用断点,使其停止程序的执行。</target>
        </trans-unit>
        <trans-unit id="dcd4f88c7522d41d4cd111539c1b1db699d331e1" translate="yes" xml:space="preserve">
          <source>Enable the options enabled by &quot;All&quot;, plus STATE, TRIEC, and TRIEM.</source>
          <target state="translated">启用 &quot;全部 &quot;启用的选项,加上STATE、TRIEC和TRIEM。</target>
        </trans-unit>
        <trans-unit id="6607ef3ad5faa3d582896ad07ab9785dae90ca8e" translate="yes" xml:space="preserve">
          <source>Enable this option if you wish all spawned processes to be killed if the initially spawned process (the parent) is killed or dies without waiting for child processes.</source>
          <target state="translated">如果您希望在初始产卵进程(父进程)被杀死或死亡时,无需等待子进程,就能杀死所有产卵进程,请启用此选项。</target>
        </trans-unit>
        <trans-unit id="b7b7c90b9b4e4815dd4d9b7ad285d70eda8ebb7d" translate="yes" xml:space="preserve">
          <source>Enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">在源代码中启用/禁用UTF-8(或UTF-EBCDIC)。</target>
        </trans-unit>
        <trans-unit id="80acee2f67ff4da70c6002b5a0e094b4d2f31c43" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">使所有的警告，无论 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 或 &lt;code&gt;$^W&lt;/code&gt; 。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1089d1ea88536805f57559da91fba3d7a2761ecb" translate="yes" xml:space="preserve">
          <source>Enables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">启用某些优化。目前唯一受影响的优化是使用了</target>
        </trans-unit>
        <trans-unit id="c2846984fdcc8df09665bcc109bb5474af315f7d" translate="yes" xml:space="preserve">
          <source>Enables or disable debugging by setting the &lt;code&gt;$Benchmark::Debug&lt;/code&gt; flag:</source>
          <target state="translated">通过设置 &lt;code&gt;$Benchmark::Debug&lt;/code&gt; 标志启用或禁用调试：</target>
        </trans-unit>
        <trans-unit id="9d480a633ce9bb7aa941c3d98a4cbb4d5ac2bf6a" translate="yes" xml:space="preserve">
          <source>Enables output related to the optimisation phase of compilation.</source>
          <target state="translated">启用与编译的优化阶段相关的输出。</target>
        </trans-unit>
        <trans-unit id="e55c00ee236233e66b2d47bad2c1ced81c03c99b" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;bundling_values&lt;/code&gt; will disable the other two styles of bundling.</source>
          <target state="translated">启用 &lt;code&gt;bundling_values&lt;/code&gt; 将禁用其他两种捆绑样式。</target>
        </trans-unit>
        <trans-unit id="b18f32d5490f57e3f4e0f875c588a069b00f5590" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;code&gt;utf8&lt;/code&gt; pragma has the following effect:</source>
          <target state="translated">启用 &lt;code&gt;utf8&lt;/code&gt; 编译指示具有以下效果：</target>
        </trans-unit>
        <trans-unit id="7fe2071dd005ed63dfae111e383f15806253aa16" translate="yes" xml:space="preserve">
          <source>Enabling this option will allow single-character options to be bundled. To distinguish bundles from long option names, long options</source>
          <target state="translated">启用此选项将允许捆绑单字符选项。为了区别于长选项名称的捆绑,长选项</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="2059232562a427f990749c23a8c8ebdde1b9014d" translate="yes" xml:space="preserve">
          <source>Encapsulation is important for several reasons. First, it allows you to separate the public API from the private implementation. This means you can change that implementation without breaking the API.</source>
          <target state="translated">封装很重要,有几个原因。首先,它允许你把公共的API和私有的实现分开。这意味着你可以在不破坏API的情况下改变该实现。</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="e276943b90499b3ae3cf8000afe6554906eb7f6a" translate="yes" xml:space="preserve">
          <source>Encode - character encodings in Perl</source>
          <target state="translated">Encode-Perl中的字符编码</target>
        </trans-unit>
        <trans-unit id="3c5a64c26d9e551da565d681ba9a9c2bc735a49c" translate="yes" xml:space="preserve">
          <source>Encode Implementation Base Class</source>
          <target state="translated">编码实现基类</target>
        </trans-unit>
        <trans-unit id="39e91613c24a80edc94f024f6bfb3382d7e896d8" translate="yes" xml:space="preserve">
          <source>Encode a scalar, hash reference or array reference as YAML.</source>
          <target state="translated">将一个标量、哈希引用或数组引用编码为YAML。</target>
        </trans-unit>
        <trans-unit id="53b3896738d8cf6b15e5278f1369de611febee2e" translate="yes" xml:space="preserve">
          <source>Encode and decode according to the base64 scheme for &quot;URL applications&quot; [1]. This is a variant of the base64 encoding which does not use padding, does not break the string into multiple lines and use the characters &quot;-&quot; and &quot;_&quot; instead of &quot;+&quot; and &quot;/&quot; to avoid using reserved URL characters.</source>
          <target state="translated">根据 &quot;URL应用&quot;[1]的base64方案进行编码和解码。这是base64编码的一个变体,它不使用padding,不将字符串分成多行,并使用字符&quot;-&quot;和&quot;_&quot;代替 &quot;+&quot;和&quot;/&quot;以避免使用保留的URL字符。</target>
        </trans-unit>
        <trans-unit id="3d01d8346257820c445f334ba81d16daa9f20915" translate="yes" xml:space="preserve">
          <source>Encode consists of a collection of modules whose details are too extensive to fit in one document. This one itself explains the top-level APIs and general topics at a glance. For other topics and more details, see the documentation for these modules:</source>
          <target state="translated">Encode由一系列模块组成,这些模块的细节太多,无法在一个文档中体现。这个模块本身就解释了顶层API和一般主题,一目了然。关于其他主题和更多细节,请看这些模块的文档。</target>
        </trans-unit>
        <trans-unit id="5888dafc03b9c4595a9ef704f5d312540bc3c184" translate="yes" xml:space="preserve">
          <source>Encode data by calling the encode_base64() function. The first argument is the byte string to encode. The second argument is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. The returned encoded string is broken into lines of no more than 76 characters each and it will end with $eol unless it is empty. Pass an empty string as second argument if you do not want the encoded string to be broken into lines.</source>
          <target state="translated">通过调用 encode_base64()函数对数据进行编码。第一个参数是要编码的字节字符串。第二个参数是要使用的行尾序列。它是可选的,默认为&quot;\n&quot;。返回的编码字符串会被分成不超过76个字符的行,除非它是空的,否则会以$eol结尾。如果你不想让编码后的字符串分成几行,可以传一个空字符串作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="ceff1e1e1923f02a7939b507f33300e3a696eaa2" translate="yes" xml:space="preserve">
          <source>Encode up to 1.86 internally used &quot;local $_&quot; to implement this older form. But consider the code below;</source>
          <target state="translated">Encode到1.86内部使用了 &quot;local $_&quot;来实现这种旧形式。但考虑到下面的代码。</target>
        </trans-unit>
        <trans-unit id="dec95d5717280ac4e0be7dcb9e6fc7bc4a47ecee" translate="yes" xml:space="preserve">
          <source>Encode uses the Unicode Character Map (UCM) format for source character mappings. This format is used by IBM's ICU package and was adopted by Nick Ing-Simmons for use with the Encode module. Since UCM is more flexible than Tcl's Encoding Map and far more user-friendly, this is the recommended format for Encode now.</source>
          <target state="translated">Encode使用Unicode字符映射(UCM)格式进行源字符映射。这种格式被IBM的ICU包使用,并被Nick Ing-Simmons采用,用于Encode模块。由于UCM比Tcl的Encoding Map更灵活,也更方便用户使用,所以现在Encode推荐使用这种格式。</target>
        </trans-unit>
        <trans-unit id="5d2cad9401edfbef92e75be01cb40c4e9ecc4cf6" translate="yes" xml:space="preserve">
          <source>Encode::Alias</source>
          <target state="translated">Encode::Alias</target>
        </trans-unit>
        <trans-unit id="552324ae1eb023be362415291b1291f3f52556a7" translate="yes" xml:space="preserve">
          <source>Encode::Alias - alias definitions to encodings</source>
          <target state="translated">Encode::Alias-编码的别名定义。</target>
        </trans-unit>
        <trans-unit id="cc91ef6d8b4186209599d785324e380db05af545" translate="yes" xml:space="preserve">
          <source>Encode::Byte</source>
          <target state="translated">Encode::Byte</target>
        </trans-unit>
        <trans-unit id="d4b97f8bcca673137fe3a8c4311fa29b1376a129" translate="yes" xml:space="preserve">
          <source>Encode::Byte - Single Byte Encodings</source>
          <target state="translated">Encode::Byte-单字节编码器</target>
        </trans-unit>
        <trans-unit id="8da29f26c3e55351d546a404e8b09b53f82affc8" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants</source>
          <target state="translated">Encode::CJKConstants</target>
        </trans-unit>
        <trans-unit id="97376755cadc9b08ac2bdcffa80b5c4759e6f7df" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode::CJKConstants.pm --Encode::?:ISO_2022_*内部使用。</target>
        </trans-unit>
        <trans-unit id="44fea5bddc6721fb4b956554b9d88900826d60c7" translate="yes" xml:space="preserve">
          <source>Encode::CN</source>
          <target state="translated">Encode::CN</target>
        </trans-unit>
        <trans-unit id="40f3392265131b672490757c292c084a525d4184" translate="yes" xml:space="preserve">
          <source>Encode::CN - China-based Chinese Encodings</source>
          <target state="translated">Encode::CN-中国的中文编码系统</target>
        </trans-unit>
        <trans-unit id="207660f321fc12762f2e79b28e35fbb26736a3e7" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ</source>
          <target state="translated">Encode::CN::HZ</target>
        </trans-unit>
        <trans-unit id="622d7b0a21ca0c1a08d6dda20da0057e0358570c" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ -- internally used by Encode::CN</source>
          <target state="translated">Encode::CN::HZ --Encode::CN内部使用。</target>
        </trans-unit>
        <trans-unit id="b24bb381f68ba02b49c4c2cd2767f183910da09e" translate="yes" xml:space="preserve">
          <source>Encode::Config</source>
          <target state="translated">Encode::Config</target>
        </trans-unit>
        <trans-unit id="0b7c024127a98fc8be2586eade5f76bc22701aab" translate="yes" xml:space="preserve">
          <source>Encode::Config -- internally used by Encode</source>
          <target state="translated">Encode::Config --Encode内部使用。</target>
        </trans-unit>
        <trans-unit id="2a8ba6ae9bd0735a827d283930aa3dc28cd2cae3" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC</source>
          <target state="translated">Encode::EBCDIC</target>
        </trans-unit>
        <trans-unit id="3b31a7154f7c03e9be274aacce1e4dc5a66d5ec6" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC - EBCDIC Encodings</source>
          <target state="translated">Encode::EBCDIC-EBCDIC编码器</target>
        </trans-unit>
        <trans-unit id="a0fb1479e2e68a75a05e36aff16d787758a1778e" translate="yes" xml:space="preserve">
          <source>Encode::Encoder</source>
          <target state="translated">Encode::Encoder</target>
        </trans-unit>
        <trans-unit id="3bfd37620385e094ff5d1811f8a5aaf8e5a7a125" translate="yes" xml:space="preserve">
          <source>Encode::Encoder -- Object Oriented Encoder</source>
          <target state="translated">Encode::Encoder --面向对象的编码器</target>
        </trans-unit>
        <trans-unit id="4551a7e4c9181d379ae1288237c1ebecccd59bb8" translate="yes" xml:space="preserve">
          <source>Encode::Encoding</source>
          <target state="translated">Encode::Encoding</target>
        </trans-unit>
        <trans-unit id="932dfcdaef25e880e85283d712d29f239746970b" translate="yes" xml:space="preserve">
          <source>Encode::Encoding - Encode Implementation Base Class</source>
          <target state="translated">Encode::Encoding-Encode实现基类</target>
        </trans-unit>
        <trans-unit id="77662ad703615bf25ca69905bb6db23d72296bb9" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338</source>
          <target state="translated">Encode::GSM0338</target>
        </trans-unit>
        <trans-unit id="ede01420f58b4c2565b3da82244d84c95da5b4af" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338 -- ESTI GSM 03.38 Encoding</source>
          <target state="translated">Encode::GSM0338 --ESTI GSM 03.38 编码。</target>
        </trans-unit>
        <trans-unit id="e93ed447e10d95864f0386c026ec121cd47c60ab" translate="yes" xml:space="preserve">
          <source>Encode::Guess</source>
          <target state="translated">Encode::Guess</target>
        </trans-unit>
        <trans-unit id="8b1b151431a67a55222cbbcf0270cd834cbd2d46" translate="yes" xml:space="preserve">
          <source>Encode::Guess -- Guesses encoding from data</source>
          <target state="translated">Encode::Guess --从数据中猜测编码。</target>
        </trans-unit>
        <trans-unit id="f460e270f104cac10b54ab28764ae1739d32a63f" translate="yes" xml:space="preserve">
          <source>Encode::Guess does not work on EBCDIC platforms.</source>
          <target state="translated">Encode::Guess不能在EBCDIC平台上工作。</target>
        </trans-unit>
        <trans-unit id="8030a57667933f97cc9c39195dbf244e622a18a0" translate="yes" xml:space="preserve">
          <source>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</source>
          <target state="translated">Encode::Guess 使您能够猜测给定数据的编码,或者至少是尝试猜测。</target>
        </trans-unit>
        <trans-unit id="e37ee0e2e550bc3634d116c838f3ba94375b8c47" translate="yes" xml:space="preserve">
          <source>Encode::JP</source>
          <target state="translated">Encode::JP</target>
        </trans-unit>
        <trans-unit id="341afac777ffb0b1e52b3a6aa26c1fcd31687ea1" translate="yes" xml:space="preserve">
          <source>Encode::JP - Japanese Encodings</source>
          <target state="translated">Encode::JP-日文编码器</target>
        </trans-unit>
        <trans-unit id="1e6a27be2a727bdf7e4a113a80bef5ed7da8c32a" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z</source>
          <target state="translated">Encode::JP::H2Z</target>
        </trans-unit>
        <trans-unit id="61c842d29f655e9a02cc88f2dfe176c79b0a7ccb" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::H2Z --Encode::JP::2022_JP*内部使用。</target>
        </trans-unit>
        <trans-unit id="57d3b7cea6d80534a4eab96981ae8b12e91a572d" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7</source>
          <target state="translated">Encode::JP::JIS7</target>
        </trans-unit>
        <trans-unit id="728d78512ef0e5fd10db6af9228f9f55491f142e" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7 -- internally used by Encode::JP</source>
          <target state="translated">Encode::JP::JIS7 --Encode::JP内部使用。</target>
        </trans-unit>
        <trans-unit id="9292d6d6d6c3d612ab88b4d0a9b44cce420ff5ea" translate="yes" xml:space="preserve">
          <source>Encode::KR</source>
          <target state="translated">Encode::KR</target>
        </trans-unit>
        <trans-unit id="32eef4f01d06c098fb548d1006c901f52a812e7e" translate="yes" xml:space="preserve">
          <source>Encode::KR - Korean Encodings</source>
          <target state="translated">Encode::KR-韩语编码。</target>
        </trans-unit>
        <trans-unit id="adea371ce7b9ff3c3566f35ac1420ac2e2ede009" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR</source>
          <target state="translated">Encode::KR::2022_KR</target>
        </trans-unit>
        <trans-unit id="3976fa623737771006bbaafdf23430529728651d" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR -- internally used by Encode::KR</source>
          <target state="translated">Encode::KR::2022_KR --Encode::KR内部使用。</target>
        </trans-unit>
        <trans-unit id="e9d431857fb2daca858cf0e24708414e6076d14b" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header</source>
          <target state="translated">Encode::MIME::Header</target>
        </trans-unit>
        <trans-unit id="f2030bc40a6a13ab85bce58de044a451e0f2022a" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME 'B' and 'Q' header encoding</source>
          <target state="translated">Encode::MIME::Header --MIME'B'和'Q'头编码。</target>
        </trans-unit>
        <trans-unit id="660e24530b4b214dbcf404910cce6c40e5661246" translate="yes" xml:space="preserve">
          <source>Encode::MIME::NAME -- internally used by Encode</source>
          <target state="translated">Encode::MIME::NAME --Encode内部使用。</target>
        </trans-unit>
        <trans-unit id="5f4e8291cc2cc181fac6cfb29c5aaebe19ffe8d7" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Name</source>
          <target state="translated">Encode::MIME::Name</target>
        </trans-unit>
        <trans-unit id="617dc5e07f69ab0016776f02fcae4aa5417d4cf3" translate="yes" xml:space="preserve">
          <source>Encode::Symbol</source>
          <target state="translated">Encode::Symbol</target>
        </trans-unit>
        <trans-unit id="305d6a4ecfbcb83575125920205199ebfad9ecbc" translate="yes" xml:space="preserve">
          <source>Encode::Symbol - Symbol Encodings</source>
          <target state="translated">Encode::Symbol-符号编码器</target>
        </trans-unit>
        <trans-unit id="7353083e24fd78826faff9ec9dd3ca1f0abfeb68" translate="yes" xml:space="preserve">
          <source>Encode::TW</source>
          <target state="translated">Encode::TW</target>
        </trans-unit>
        <trans-unit id="169a69c17f2e47c33a2090f250bc6f54465bac9c" translate="yes" xml:space="preserve">
          <source>Encode::TW - Taiwan-based Chinese Encodings</source>
          <target state="translated">Encode::TW-台湾的中文编码公司</target>
        </trans-unit>
        <trans-unit id="f419db0e193bdb95ad1bf1d32e4308acad0add9f" translate="yes" xml:space="preserve">
          <source>Encode::Unicode</source>
          <target state="translated">Encode::Unicode</target>
        </trans-unit>
        <trans-unit id="2ba2c8325c871771b84294002113cdbbccea72d4" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- Various Unicode Transformation Formats</source>
          <target state="translated">Encode::Unicode --各种Unicode转换格式</target>
        </trans-unit>
        <trans-unit id="24e91aa87151df83dcd6a084acf2bef4fbe28cca" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7</source>
          <target state="translated">Encode::Unicode::UTF7</target>
        </trans-unit>
        <trans-unit id="46189c892fa791248c9e1697ba2bd11d7d60c2a5" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7 -- UTF-7 encoding</source>
          <target state="translated">Encode::Unicode::UTF7--UTF-7编码。</target>
        </trans-unit>
        <trans-unit id="0ca2ce49b12c2ee816a410523ba091dc693a60d6" translate="yes" xml:space="preserve">
          <source>Encodes a scalar, hash reference or array reference as YAMLish.</source>
          <target state="translated">将一个标量、哈希引用或数组引用编码为YAMLish。</target>
        </trans-unit>
        <trans-unit id="f4c840f47e19e39ed11ebf36e763d836813b7799" translate="yes" xml:space="preserve">
          <source>Encodes the scalar value</source>
          <target state="translated">编码标量值</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="e649a0b553388aa0aefbd82d8b0f0d1a27873465" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of base64 strings</source>
          <target state="translated">base64字符串的编码和解码。</target>
        </trans-unit>
        <trans-unit id="6b77915998634f10773a65ebf127633caa0903b3" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of quoted-printable strings</source>
          <target state="translated">带引号的可打印字符串的编码和解码。</target>
        </trans-unit>
        <trans-unit id="a998510992fa4d69263beacea1ddcc7415077441" translate="yes" xml:space="preserve">
          <source>Encoding handling assumes that PerlIO is available and does not work properly if it isn't. The &lt;code&gt;utf8&lt;/code&gt; option is therefore not supported unless Perl is built with PerlIO support.</source>
          <target state="translated">编码处理假定PerlIO可用，如果没有，则不能正常工作。该 &lt;code&gt;utf8&lt;/code&gt; 除非Perl是用PerlIO的内置支持，因此不支持的选项。</target>
        </trans-unit>
        <trans-unit id="04cfa3e7800a4d240dc7f677c9407b294c248bcf" translate="yes" xml:space="preserve">
          <source>Encoding layer</source>
          <target state="translated">编码层</target>
        </trans-unit>
        <trans-unit id="01cbaf646f7cdfb7eb0fbb21f815c71c722e02c1" translate="yes" xml:space="preserve">
          <source>Encoding via PerlIO</source>
          <target state="translated">通过PerlIO进行编码</target>
        </trans-unit>
        <trans-unit id="bcc5b05d5a707cb27dff01159bcf1a3ca6a46e7c" translate="yes" xml:space="preserve">
          <source>Encodings supported by Encode</source>
          <target state="translated">Encode支持的编码</target>
        </trans-unit>
        <trans-unit id="2c4ae224ac38c50705eb255694dceb50337fe4c9" translate="yes" xml:space="preserve">
          <source>End of File. Sometimes used metaphorically as the terminating string of a &lt;b&gt;here document&lt;/b&gt;.</source>
          <target state="translated">文件结束。有时隐喻用作&lt;b&gt;here文档&lt;/b&gt;的终止字符串。</target>
        </trans-unit>
        <trans-unit id="e61fae84390da1a34c4b2fbd657622d5073292c7" translate="yes" xml:space="preserve">
          <source>End of file.</source>
          <target state="translated">文件结束。</target>
        </trans-unit>
        <trans-unit id="d1e4562e3c175d8468bb1a01a7952bd0d3b259e1" translate="yes" xml:space="preserve">
          <source>End the sending of data to the remote server. This is done by ensuring that the data already sent ends with CRLF then sending '.CRLF' to end the transmission. Once this data has been sent &lt;code&gt;dataend&lt;/code&gt; calls &lt;code&gt;response&lt;/code&gt; and returns true if &lt;code&gt;response&lt;/code&gt; returns CMD_OK.</source>
          <target state="translated">结束向远程服务器的数据发送。通过确保已发送的数据以CRLF结尾，然后发送&amp;ldquo; .CRLF&amp;rdquo;以结束传输来完成此操作。发送 &lt;code&gt;dataend&lt;/code&gt; 此数据后，数据端将调用 &lt;code&gt;response&lt;/code&gt; ，如果 &lt;code&gt;response&lt;/code&gt; 返回CMD_OK ，则返回true 。</target>
        </trans-unit>
        <trans-unit id="5b395d065aa5966c6da16e4b8c501ca68c3ecd37" translate="yes" xml:space="preserve">
          <source>End-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的终端标记。</target>
        </trans-unit>
        <trans-unit id="8676dbbd19637e0c1604c4bcd69f9208a03cfa1a" translate="yes" xml:space="preserve">
          <source>End.U</source>
          <target state="translated">End.U</target>
        </trans-unit>
        <trans-unit id="f4d04612cae76dda50e81f179859b4b712ba14ff" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">结束try块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ea2083617805ed93273c46ed0c4792fa3da7a0b" translate="yes" xml:space="preserve">
          <source>Enforce type integrity if required</source>
          <target state="translated">如果需要,强制执行类型完整性</target>
        </trans-unit>
        <trans-unit id="286ca1647ce3f25ee107c4a9d50837ecd6b2a964" translate="yes" xml:space="preserve">
          <source>Enforcing redispatch</source>
          <target state="translated">执行重新调度</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="256aa1d5dab6cf2100434b619aada1a930ae7c7d" translate="yes" xml:space="preserve">
          <source>English ('en') is</source>
          <target state="translated">英语('en')是</target>
        </trans-unit>
        <trans-unit id="7aa949020d6b22aac250e3885290aa830dd72a15" translate="yes" xml:space="preserve">
          <source>English - use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">英语--对丑陋的标点符号变量使用好听的英语(或awk)名称。</target>
        </trans-unit>
        <trans-unit id="34afa6db1cf569bd02a3ffe4f7e6036f1798a631" translate="yes" xml:space="preserve">
          <source>English.pm</source>
          <target state="translated">English.pm</target>
        </trans-unit>
        <trans-unit id="99343727bceed607c32f483621540aee48471580" translate="yes" xml:space="preserve">
          <source>Enough of the definition talk! Let's have a few examples.</source>
          <target state="translated">定义说得够多了! 让我们举几个例子。</target>
        </trans-unit>
        <trans-unit id="8988a13726c59d935ea79d755d1455be0fc83772" translate="yes" xml:space="preserve">
          <source>Ensure that you know what \b really does: it's the boundary between a word character, \w, and something that isn't a word character. That thing that isn't a word character might be \W, but it can also be the start or end of the string.</source>
          <target state="translated">确保你知道 &quot;b &quot;的真正作用:它是一个单词字符,即&quot;/w &quot;和一些不是单词字符的东西之间的界限。那个不是单词字符的东西可能是 \W,但它也可以是字符串的开始或结束。</target>
        </trans-unit>
        <trans-unit id="21287dbbbfc03a6ee27ae105b87e32fa291261eb" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="translated">确保您的模块在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;-w&lt;/code&gt; 下&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1279af9b58018ff33488efc0656bb62fda8db44f" translate="yes" xml:space="preserve">
          <source>Enter interactive mode by running</source>
          <target state="translated">进入互动模式,运行</target>
        </trans-unit>
        <trans-unit id="74eb99da3b9ba3df5f4be61ae4522068a9b27d10" translate="yes" xml:space="preserve">
          <source>Entire arrays (and slices of arrays and hashes) are denoted by '@', which works much as the word &quot;these&quot; or &quot;those&quot; does in English, in that it indicates multiple values are expected.</source>
          <target state="translated">整个数组(以及数组和散列的切片)用'@'表示,它的作用就像英语中的 &quot;these &quot;或 &quot;those &quot;一样,因为它表示预期有多个值。</target>
        </trans-unit>
        <trans-unit id="d245bbc8252b0b71ede0a2f949fc5b29d829fd5d" translate="yes" xml:space="preserve">
          <source>Entire hashes are denoted by '%':</source>
          <target state="translated">整个哈希值用'%'表示。</target>
        </trans-unit>
        <trans-unit id="4f918189cf78ab84f6519ba2dcb57f2ae316f72b" translate="yes" xml:space="preserve">
          <source>Entries cannot be plain object files, as many Win32 compilers will not handle object files in the place of libraries.</source>
          <target state="translated">条目不能是普通的对象文件,因为很多Win32编译器不会处理对象文件来代替库。</target>
        </trans-unit>
        <trans-unit id="673fba8e1fb3916663891e031f77ca1343408944" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;$potential_libs&lt;/code&gt; beginning with a colon and followed by alphanumeric characters are treated as flags. Unknown flags will be ignored.</source>
          <target state="translated">&lt;code&gt;$potential_libs&lt;/code&gt; 条目以冒号开头，后跟字母数字字符被视为标志。未知标志将被忽略。</target>
        </trans-unit>
        <trans-unit id="a95d99085680ef5c64c2fe5754604ba2f596d896" translate="yes" xml:space="preserve">
          <source>Entries such as:</source>
          <target state="translated">诸如:</target>
        </trans-unit>
        <trans-unit id="8d07f7a288d3779719c1509961105704b61f4cef" translate="yes" xml:space="preserve">
          <source>Entry in the INPUT section of a typemap</source>
          <target state="translated">类型图INPUT部分的条目</target>
        </trans-unit>
        <trans-unit id="237fc607826e845da2eb03390fed5a45c866b715" translate="yes" xml:space="preserve">
          <source>Entry in the OUTPUT section of a typemap</source>
          <target state="translated">类型图的OUTPUT部分的条目。</target>
        </trans-unit>
        <trans-unit id="81a846de6d38920893fe50bf678fb10abc3847e2" translate="yes" xml:space="preserve">
          <source>Entry in the TYPEMAP section of a typemap</source>
          <target state="translated">在类型图的TYPEMAP部分的条目</target>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="fbbe5fa808eea7f4c74b5ba16db47dab460bc3b9" translate="yes" xml:space="preserve">
          <source>Env - perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">Env-perl模块将环境变量作为标量或数组导入。</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="e19f8816c6f7ccbb7d40a44b81def1ffb731d4e0" translate="yes" xml:space="preserve">
          <source>Environment for Compiling perl on Solaris</source>
          <target state="translated">在Solaris上编译perl的环境</target>
        </trans-unit>
        <trans-unit id="c7e160747cc9ac3da385ca9f9c1cb6f2e6810dff" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , and &lt;code&gt;=back&lt;/code&gt; . For example:</source>
          <target state="translated">程序关心的环境变量，通常使用 &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; 和 &lt;code&gt;=back&lt;/code&gt; 表示为列表。例如：</target>
        </trans-unit>
        <trans-unit id="59ed6121898e672a267f0f15674f039aebf49694" translate="yes" xml:space="preserve">
          <source>Environment variables to be set during the command</source>
          <target state="translated">命令中要设置的环境变量</target>
        </trans-unit>
        <trans-unit id="7264243f4aeaaab7fbb98bd7afd5e953b5900f7b" translate="yes" xml:space="preserve">
          <source>Equality Operators</source>
          <target state="translated">平等操作者</target>
        </trans-unit>
        <trans-unit id="1cfd756767e68de5473421aba90c9077344def28" translate="yes" xml:space="preserve">
          <source>Equivalent examples:</source>
          <target state="translated">同等的例子。</target>
        </trans-unit>
        <trans-unit id="c61e2265d123d76133484971263eb3576ac59dd9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) UTF-8 representation, this function cannot fail.</source>
          <target state="translated">等效于 &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; 。$ string中的字符以Perl的内部格式编码，结果以八位字节序列返回。由于Perl中所有可能的字符都具有（松散，不严格）的UTF-8表示形式，因此该功能不会失败。</target>
        </trans-unit>
        <trans-unit id="a263a53c5879a617814d231b90b810689cbeec78" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Because not all sequences of octets are valid UTF-8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; 。由$ octets表示的八位字节序列从UTF-8解码为逻辑字符序列。由于并非所有八位位组序列都是有效的UTF-8，因此此功能很可能会失败。有关检查，请参阅&lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;处理格式错误的数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="032e60eb7c99d19d4d7f40467e50e02c1b3b3e31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , but more precise for small argument values [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; ，但对于较小的参数值[C99]更精确。</target>
        </trans-unit>
        <trans-unit id="48506d548803ae745c6c6681b3b6b358f76d6d1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , but more stable results for small argument values [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; ，但对于较小的参数值，结果更稳定[C99]。</target>
        </trans-unit>
        <trans-unit id="22c30bad53a9801aa2549ef28438b22b8be2db3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; ，不同之处在于未附加 &lt;code&gt;$\&lt;/code&gt; （输出记录分隔符）。实际上，FORMAT和LIST被解析为一个列表。列表的第一个参数将被解释为 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 格式。这意味着 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 将使用 &lt;code&gt;$_[0]&lt;/code&gt; 作为格式。有关format参数的说明，请参见&lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt;。如果对 &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 查找此贯穿容器有效，并且已调用POSIX :: setlocale（），则格式化的浮点数中用于十进制分隔符的字符会受到 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境设置。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="200de086c8cd5535e67b47001e5f819da8109f8f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; 除了在非常大或非常小的参数上更稳定[C99]。</target>
        </trans-unit>
        <trans-unit id="0f1d23c2683b2580eee5762a2646e2cfdbd51243" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; ，不同之处在于未附加 &lt;code&gt;$\&lt;/code&gt; （输出记录分隔符）。实际上，FORMAT和LIST被解析为一个列表。列表的第一个参数将被解释为 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 格式。这意味着 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 将使用 &lt;code&gt;$_[0]&lt;/code&gt; 作为格式。有关format参数的说明，请参见&lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt;。如果对 &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 查找此贯穿容器有效，并且已调用POSIX :: setlocale（），则格式化的浮点数中用于十进制分隔符的字符会受到 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境设置。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8d4e0dc744110e721ecf88197993cbcc2b45d001" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</source>
          <target state="translated">相当于Perl代码 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="876fc7d247587a71d98917cb3c3453fd65fea359" translate="yes" xml:space="preserve">
          <source>Equivalent to running mktemp() with $dir/$prefixXXXXXXXX (using unix file convention as an example)</source>
          <target state="translated">相当于用$dir/$prefixXXXXXX运行mktemp()(以unix文件惯例为例)</target>
        </trans-unit>
        <trans-unit id="4dba35bcd4ac839e52783da10b5058566f3e3b91" translate="yes" xml:space="preserve">
          <source>Equivalent to specifying a DIR of &quot;File::Spec-&amp;gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.</source>
          <target state="translated">等效于将DIR指定为&amp;ldquo; File :: Spec-&amp;gt; tmpdir&amp;rdquo;，将文件写入与如果完全未指定模板时将使用的相同的临时目录中。</target>
        </trans-unit>
        <trans-unit id="a667e4f94596d8444896d0c578ec8dad154ae9ae" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;b&gt;-C&lt;/b&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;b&gt;-C&lt;/b&gt; switch for more information.</source>
          <target state="translated">等效于&lt;b&gt;-C&lt;/b&gt;命令行开关。请注意，这不是布尔变量。将此设置为 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 不是&amp;ldquo;启用Unicode&amp;rdquo;的正确方法（无论这意味着什么）。不过，您可以使用 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 来&amp;ldquo;禁用Unicode&amp;rdquo;（或者在启动Perl之前在您的shell中取消设置PERL_UNICODE）。有关更多信息，请参见&lt;b&gt;-C&lt;/b&gt;开关的描述。</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="7cc25c4fa96172ec73030c6c0f3dc9c51687c491" translate="yes" xml:space="preserve">
          <source>Equivalents of</source>
          <target state="translated">等价物</target>
        </trans-unit>
        <trans-unit id="0256add701298dc7a17e42cc9eb936d630438581" translate="yes" xml:space="preserve">
          <source>Erases one character. Defined by</source>
          <target state="translated">删除一个字符。定义为</target>
        </trans-unit>
        <trans-unit id="7c24401b7c6f89af67334e697241400ad5298e5f" translate="yes" xml:space="preserve">
          <source>Erases the current input. Defined by</source>
          <target state="translated">擦除当前的输入。定义为</target>
        </trans-unit>
        <trans-unit id="a3053d2e8a81cd1d9716eddc9ced731b4c51383d" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</source>
          <target state="translated">埃里克&amp;middot;威廉（Eric Wilhelm）@ &amp;lt;cpan dot org的ewilhelm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="76cf9c662cbb85bc782a4c519361391afd6f8281" translate="yes" xml:space="preserve">
          <source>Errno - System errno constants</source>
          <target state="translated">Errno-系统Errno常数。</target>
        </trans-unit>
        <trans-unit id="6cc16f28f695995f841e32ad9be43613256395fe" translate="yes" xml:space="preserve">
          <source>Error Checking</source>
          <target state="translated">错误检查</target>
        </trans-unit>
        <trans-unit id="ecbd14ea4e6e17d8a2dc17467fb021874d4a82c9" translate="yes" xml:space="preserve">
          <source>Error Variables</source>
          <target state="translated">错误变量</target>
        </trans-unit>
        <trans-unit id="cfb1de7f5665b658bcddfda7619c881aef88520a" translate="yes" xml:space="preserve">
          <source>Error checking is, as usual, left as an exercise for the reader.</source>
          <target state="translated">错误检查一如既往地留给读者去做。</target>
        </trans-unit>
        <trans-unit id="da4e40dd69c1ef29292868ee52af685e14566b19" translate="yes" xml:space="preserve">
          <source>Error checking, as always, has been left as an exercise for the reader.</source>
          <target state="translated">错误检查,一如既往地留给读者去做。</target>
        </trans-unit>
        <trans-unit id="3e1fae3d7127b124ae1e94579e5dd51376530e7b" translate="yes" xml:space="preserve">
          <source>Error handling and messages</source>
          <target state="translated">错误处理和信息</target>
        </trans-unit>
        <trans-unit id="8bb7b0a0be7d85a55ee74f50c125415c68cb8808" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;$!&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">当前操作系统特定的错误信息。目前，这与 &lt;code&gt;$!&lt;/code&gt; 有所不同！仅在VMS，OS / 2和Win32（以及MacPerl）下。在所有其他平台上， &lt;code&gt;$^E&lt;/code&gt; 始终与 &lt;code&gt;$!&lt;/code&gt; 相同！。</target>
        </trans-unit>
        <trans-unit id="36186555ca5a85354d834f18239bd5446de015bb" translate="yes" xml:space="preserve">
          <source>Error message text from the last failed DynaLoader function. Note that, similar to errno in unix, a successful function call does not reset this message.</source>
          <target state="translated">上次DynaLoader函数失败的错误信息。请注意,与unix中的errno类似,成功的函数调用不会重置此信息。</target>
        </trans-unit>
        <trans-unit id="50134ffbfcda43f0c3168aa2876061d57b69c6ae" translate="yes" xml:space="preserve">
          <source>Error results (warning and fatal) contain:</source>
          <target state="translated">错误结果(警告和致命)包含:</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e722317f0272c736783202d0439c1a84302bd3c9" translate="yes" xml:space="preserve">
          <source>Errors in rendering (non-existent function-name, non-existent coderef) are written to the STDOUT, or wherever you've set it via walk_output().</source>
          <target state="translated">渲染中的错误(不存在的函数名,不存在的coderef)会被写入STDOUT,或者你通过walk_output()设置的任何地方。</target>
        </trans-unit>
        <trans-unit id="0934c88916cf6f7537fb99e4833669f3818f9855" translate="yes" xml:space="preserve">
          <source>Errors using the various *style* calls, and bad args to walk_output(), result in die(). Use an eval if you wish to catch these errors and continue processing.</source>
          <target state="translated">使用各种*style*调用的错误,以及walk_output()的错误参数,都会导致die()。如果你想抓住这些错误并继续处理,请使用eval。</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="afa6da9272c9b7871ca718b60455b77d2d266044" translate="yes" xml:space="preserve">
          <source>Escapes all &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">转义所有 &lt;code&gt;$&lt;/code&gt; ,以免将它们解释为make变量。</target>
        </trans-unit>
        <trans-unit id="d630054693cd8886f832682006b6bb07e97c811d" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &quot;count&quot; chars of pv and puts the results into dsv such that the size of the escaped string will not exceed &quot;max&quot; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the STRLEN *escaped parameter if it is not null. When the dsv parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="translated">最多转义pv的第一个 &quot;count &quot;chars,并将结果放入dsv中,这样转义字符串的大小不会超过 &quot;max &quot;chars,并且不会包含任何不完整的转义序列。如果参数STRLEN *escaped不是空的,那么被转义的字节数将被返回。当dsv参数为空时,实际上不会发生转义,但会计算出如果它不是空的情况下会被转义的字节数。</target>
        </trans-unit>
        <trans-unit id="b73daf05e61c2f4ceabfe0f8dc9e8bd0fe087922" translate="yes" xml:space="preserve">
          <source>Escapes stray &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">转义符是 &lt;code&gt;$&lt;/code&gt; ,因此不会被解释为make变量。</target>
        </trans-unit>
        <trans-unit id="92b417d4a5ce0ac686aeee5640af004624297a4e" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;.</source>
          <target state="translated">特别是&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51e6f8fb1216de07279b7184fe32486c4afcbbd5" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</source>
          <target state="translated">尤其&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;如 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcd99d9147aed607626e5d2c3fbf27fa8eaba872" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; as in &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</source>
          <target state="translated">尤其&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;如 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 和&lt;a href=&quot;bignum&quot;&gt;BIGNUM&lt;/a&gt;如 &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5485ef59e2abd6d9fec5641c427b8c1a89ee861e" translate="yes" xml:space="preserve">
          <source>Essentially this is the same as the &lt;code&gt;__LINE__&lt;/code&gt; macro, but the &lt;code&gt;line_num(+3)&lt;/code&gt; idiom is arguably nicer.</source>
          <target state="translated">从本质上讲，这与 &lt;code&gt;__LINE__&lt;/code&gt; 宏相同，但是 &lt;code&gt;line_num(+3)&lt;/code&gt; 惯用法可以说更好。</target>
        </trans-unit>
        <trans-unit id="0c6dff48b0f039b109420e87e1e42abbab8710f8" translate="yes" xml:space="preserve">
          <source>Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">在编译时与基类建立ISA关系。</target>
        </trans-unit>
        <trans-unit id="576347ec826f38428d8c8a6f8ec4acb2bceab911" translate="yes" xml:space="preserve">
          <source>Europe</source>
          <target state="translated">Europe</target>
        </trans-unit>
        <trans-unit id="15622021802352824cd00f0a03614ec0fdf9d50b" translate="yes" xml:space="preserve">
          <source>Evaluates EXPR and exits immediately with that value. Example:</source>
          <target state="translated">评估EXPR,并以该值立即退出。例子:</target>
        </trans-unit>
        <trans-unit id="c44b93a0add3946a941d2db7675bb524bcd7719a" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="translated">在列表上下文中评估其表达式，并以漂亮的打印方式转储结果。嵌套数据结构以递归方式打印出来，这与Perl中的实际 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能不同。在转储散列时，您可能更喜欢'x \％h'而不是'x％h'。如果您想自己执行此操作，请参见&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9eee27e1be9e7d28580a29bfa24323cac2b1efa9" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value composed of the results of each such evaluation. In scalar context, returns the total number of elements so generated. Evaluates BLOCK or EXPR in list context, so each element of LIST may produce zero, one, or more elements in the returned value.</source>
          <target state="translated">评估LIST的每个元素的BLOCK或EXPR（将 &lt;code&gt;$_&lt;/code&gt; 本地设置为每个元素），并返回由每个评估结果组成的列表值。在标量上下文中，返回如此生成的元素总数。在列表上下文中评估BLOCK或EXPR，因此LIST的每个元素可能在返回值中产生零个，一个或多个元素。</target>
        </trans-unit>
        <trans-unit id="e159565a978e2dbd25deef6d431807eb47abbd14" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="translated">计算LIST的每个元素的BLOCK或EXPR（将 &lt;code&gt;$_&lt;/code&gt; 局部设置为每个元素），并返回由表达式评估为true的那些元素组成的列表值。在标量上下文中，返回表达式为真的次数。</target>
        </trans-unit>
        <trans-unit id="adb27bcd152d36bb6aa40c050f7aa6bc064a148c" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.</source>
          <target state="translated">在标量上下文中评估哈希值并返回结果。当哈希值被绑定时,处理魔术。</target>
        </trans-unit>
        <trans-unit id="0b7efdaaae8c2d5acf037415de9e55f35d46853a" translate="yes" xml:space="preserve">
          <source>Evaluates to a list of the words extracted out of</source>
          <target state="translated">评估到的单词列表从</target>
        </trans-unit>
        <trans-unit id="11f4958a116f001f9e79787b5473e92c45467956" translate="yes" xml:space="preserve">
          <source>Evaluating a Perl statement from your C program</source>
          <target state="translated">评估C程序中的Perl语句</target>
        </trans-unit>
        <trans-unit id="fdfaa902629988731ecf820e3310a76ecb105be5" translate="yes" xml:space="preserve">
          <source>Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. The internal format is based on many distinct</source>
          <target state="translated">评估perl代码(例如通过 &quot;eval &quot;或 &quot;do 'file'&quot;)会导致代码被编译成内部格式,然后,如果在编译中没有错误,则执行。内部格式是基于许多不同的</target>
        </trans-unit>
        <trans-unit id="e1f930d87a7c101ffac9391f41733ff5b3321f0a" translate="yes" xml:space="preserve">
          <source>Even &lt;code&gt;$x += 5&lt;/code&gt; or &lt;code&gt;$x++&lt;/code&gt; are not guaranteed to be atomic.</source>
          <target state="translated">即使 &lt;code&gt;$x += 5&lt;/code&gt; 或 &lt;code&gt;$x++&lt;/code&gt; 也不能保证是原子的。</target>
        </trans-unit>
        <trans-unit id="459a068431296abdc9a0ee020cbb72e87da92588" translate="yes" xml:space="preserve">
          <source>Even after they stabilize, some tests may fail.</source>
          <target state="translated">即使在它们稳定之后,一些测试也可能失败。</target>
        </trans-unit>
        <trans-unit id="014c0223d524d2f9046bd74912b924b926ef1dba" translate="yes" xml:space="preserve">
          <source>Even if a module is thread-safe, it doesn't mean that the module is optimized to work well with threads. A module could possibly be rewritten to utilize the new features in threaded Perl to increase performance in a threaded environment.</source>
          <target state="translated">即使一个模块是线程安全的,也并不意味着这个模块是经过优化的,可以很好地与线程一起工作。一个模块可能会被重写,以利用线程Perl的新特性来提高线程环境下的性能。</target>
        </trans-unit>
        <trans-unit id="ea9410fd8b85c13558ab2ec195f440b39ef94e1e" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt; ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="translated">即使可以在编译时使用原型，该子例程的主体也不可用（尚未进行 &lt;code&gt;AUTOLOAD&lt;/code&gt; 编程）。perl需要在编译时检查 &lt;code&gt;()&lt;/code&gt; 原型和子例程的主体，以检测其可以用常数值安全地替换对该子例程的调用。</target>
        </trans-unit>
        <trans-unit id="6e9d9a1a7409534a2957addc0cb2ac7a35e101e4" translate="yes" xml:space="preserve">
          <source>Even if no</source>
          <target state="translated">即使没有</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
