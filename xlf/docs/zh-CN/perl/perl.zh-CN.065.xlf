<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="0eb6c125a87601bb415e7dd8ac4261d5f4ccd383" translate="yes" xml:space="preserve">
          <source>This is just a shorthand for a typeglob assignment at compile time:</source>
          <target state="translated">这只是编译时typeglob赋值的一个简写。</target>
        </trans-unit>
        <trans-unit id="15b35232b5a8087ae488ff75565de5703f14864d" translate="yes" xml:space="preserve">
          <source>This is just a tutorial. For the full story on Perl regular expressions, see the &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; regular expressions reference page.</source>
          <target state="translated">这只是一个教程。有关Perl正则表达式的完整信息，请参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;正则表达式参考页。</target>
        </trans-unit>
        <trans-unit id="9456d5890fbed572d26379cc56324c8cfe828e36" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">这只是Perl正常 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 函数的包装。提供它是为了使您可以在括号表示法中使用&amp;ldquo; sprintf&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="b4ff27b6bada60e402e6197635d038979041e1aa" translate="yes" xml:space="preserve">
          <source>This is just a wrapper around Perl's normal &lt;code&gt;sprintf&lt;/code&gt; function. It's provided so that you can use &quot;sprintf&quot; in Bracket Notation:</source>
          <target state="translated">这只是Perl正常 &lt;code&gt;sprintf&lt;/code&gt; 函数的包装。提供它是为了使您可以在括号表示法中使用&amp;ldquo; sprintf&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="77266324e65b81993bcee36043a748db86e77bf5" translate="yes" xml:space="preserve">
          <source>This is just an alias for $ctx-&amp;gt;new.</source>
          <target state="translated">这只是$ ctx-&amp;gt; new的别名。</target>
        </trans-unit>
        <trans-unit id="4341fe03623ad4301c3243c214057adf6cd69228" translate="yes" xml:space="preserve">
          <source>This is just an alias for $md5-&amp;gt;new.</source>
          <target state="translated">这只是$ md5-&amp;gt; new的别名。</target>
        </trans-unit>
        <trans-unit id="99b8f0dcbd7ef8ebc2a3383d96beb914e7c2ab77" translate="yes" xml:space="preserve">
          <source>This is just an alias for &lt;code&gt;to_bytes()&lt;/code&gt;.</source>
          <target state="translated">这只是 &lt;code&gt;to_bytes()&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="abb98ec9f418273dc2ca6cd9acdcab91a8675d3b" translate="yes" xml:space="preserve">
          <source>This is just like get_title, except that it returns just the modulename, if the title seems to be of the form &quot;SomeModuleName -- description&quot;.</source>
          <target state="translated">这和get_title一样,只是如果标题的形式是 &quot;SomeModuleName --description&quot;,那么它只返回modulename。</target>
        </trans-unit>
        <trans-unit id="3efe951774b37c8f5ed5c70b61d80e43335a5d14" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">就像 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search一样，只不过它在对 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 运算符的调用之间仅匹配一次。例如，当您只想查看某组文件的每个文件中某事物的首次出现时，这是有用的优化。只有 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m??&lt;/a&gt;&lt;/code&gt; 重置当前程序包本地的模式。</target>
        </trans-unit>
        <trans-unit id="d73aff15bc3ff484da433da10ce9913b15e17a51" translate="yes" xml:space="preserve">
          <source>This is just like the &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search, except that it matches only once between calls to the &lt;code&gt;reset()&lt;/code&gt; operator. This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance. Only &lt;code&gt;m??&lt;/code&gt; patterns local to the current package are reset.</source>
          <target state="translated">就像 &lt;code&gt;m/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;/code&gt; search一样，只不过它在对 &lt;code&gt;reset()&lt;/code&gt; 运算符的调用之间仅匹配一次。例如，当您只想查看某组文件中每个文件中某事物的首次出现时，这是一个有用的优化。只有 &lt;code&gt;m??&lt;/code&gt; 重置当前程序包本地的模式。</target>
        </trans-unit>
        <trans-unit id="380457e35227699cc7301b94acae78bea6e5c126" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for &quot;=cut&quot; lines, not code lines. The same caveats apply. &quot;=cut&quot; lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">这就像code_handler属性一样,只不过它是针对&quot;=cut &quot;行,而不是代码行。同样的注意事项也适用。&quot;=cut &quot;行不太可能是有趣的,但为了完整起见,还是包含了这个属性。</target>
        </trans-unit>
        <trans-unit id="0695e20ad7060a9368dde02cbfce95268dbd1b5b" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for &quot;=pod&quot; lines, not code lines. The same caveats apply. &quot;=pod&quot; lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">这就像code_handler属性一样,只不过它是针对&quot;=pod &quot;行,而不是代码行。同样的注意事项也适用。&quot;=pod &quot;行不太可能是有趣的,但为了完整起见,还是包含了这个属性。</target>
        </trans-unit>
        <trans-unit id="2022f30d9b2a5b27c04280f1ebd50a51bbc345d3" translate="yes" xml:space="preserve">
          <source>This is just like the code_handler attribute, except that it's for lines that are seemingly blank but have whitespace (&quot; &quot; and/or &quot;\t&quot;) on them, not code lines. The same caveats apply. These lines are unlikely to be interesting, but this is included for completeness.</source>
          <target state="translated">这就像code_handler属性一样,除了它是针对那些看似空白但有空格(&quot; &quot;和/或&quot;/t&quot;)的行,而不是代码行。同样的注意事项也适用。这些行不太可能是有趣的,但为了完整起见,我们将其包含在内。</target>
        </trans-unit>
        <trans-unit id="d1f273b15a0cb3300a978b7939f344dd1d08639d" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt; , but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">就像 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，但是某些元素是空字符串，因此不应进行调整。 &lt;code&gt;prop_invmap&lt;/code&gt; 可访问的一个内部Perl属性是这种类型：&amp;ldquo; Perl_Decimal_Digit&amp;rdquo;返回一个反转映射，该映射给出了用Unicode十进制数字字符表示的数值。不代表十进制数字的字符映射到空字符串，如下所示：</target>
        </trans-unit>
        <trans-unit id="0c85507fc9c8edf048dedc4d8b1c473489d69c9b" translate="yes" xml:space="preserve">
          <source>This is like &lt;code&gt;&quot;a&quot;&lt;/code&gt;, but some elements are the empty string, and should not be adjusted. The one internal Perl property accessible by &lt;code&gt;prop_invmap&lt;/code&gt; is of this type: &quot;Perl_Decimal_Digit&quot; returns an inversion map which gives the numeric values that are represented by the Unicode decimal digit characters. Characters that don't represent decimal digits map to the empty string, like so:</source>
          <target state="translated">就像 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ，但是某些元素是空字符串，因此不应进行调整。可通过 &lt;code&gt;prop_invmap&lt;/code&gt; 访问的一个内部Perl属性是这种类型：&amp;ldquo; Perl_Decimal_Digit&amp;rdquo;返回一个反转映射，该映射给出由Unicode十进制数字字符表示的数字值。不代表十进制数字的字符映射到空字符串，如下所示：</target>
        </trans-unit>
        <trans-unit id="8d1dd5dc0a1e329de530690bfade7652c51e667a" translate="yes" xml:space="preserve">
          <source>This is like accept_targets, except that it specifies also that the content of sections for this target should be treated as Pod text even if the target name in &quot;=for</source>
          <target state="translated">这就像accept_targets一样,只是它也指定了这个目标的部分内容应该被视为Pod文本,即使&quot;=for &quot;中的目标名称。</target>
        </trans-unit>
        <trans-unit id="ed31723489424c54355ea43ef7bfdd64197f0ef8" translate="yes" xml:space="preserve">
          <source>This is like the &quot;over-bullet&quot; event structure; but note that the contents are &quot;item-number&quot; instead of &quot;item-bullet&quot;, and note that they will have a &quot;number&quot; attribute, which some formatters/processors may ignore (since, for example, there's no need for it in HTML when producing an &quot;&amp;lt;UL&amp;gt;&amp;lt;LI&amp;gt;...&amp;lt;/LI&amp;gt;...&amp;lt;/UL&amp;gt;&quot; structure), but which any processor may use.</source>
          <target state="translated">这就像&amp;ldquo;子弹过多&amp;rdquo;事件的结构；但请注意，内容是&amp;ldquo; item-number&amp;rdquo;而不是&amp;ldquo; item-bullet&amp;rdquo;，并请注意，它们将具有&amp;ldquo; number&amp;rdquo;属性，某些格式化程序/处理器可能会忽略（例如，因为在其中不需要生成&amp;ldquo; &amp;lt;UL&amp;gt; &amp;lt;LI&amp;gt; ... &amp;lt;/ LI&amp;gt; ... &amp;lt;/ UL&amp;gt;&amp;rdquo;结构的HTML），但任何处理器都可以使用。</target>
        </trans-unit>
        <trans-unit id="4c2c127a4acabd567283fc3055323b13e8a32015" translate="yes" xml:space="preserve">
          <source>This is like the SMTP transport, but uses TLS security. You can authenticate with this module as well, using any mechanisms your server supports after STARTTLS.</source>
          <target state="translated">这就像SMTP传输一样,但使用TLS安全。你也可以使用这个模块进行验证,使用你的服务器在STARTTLS之后支持的任何机制。</target>
        </trans-unit>
        <trans-unit id="5a91727b3a107b517a647724e9523d6e1a6aa45f" translate="yes" xml:space="preserve">
          <source>This is mainly used by legacy &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; tests which set the plan to &lt;code&gt;no plan&lt;/code&gt;, a construct that predates the much better &lt;code&gt;done_testing()&lt;/code&gt;.</source>
          <target state="translated">这主要由遗留的&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;测试使用，该测试将计划设置为 &lt;code&gt;no plan&lt;/code&gt; ，该构造早于更好的 &lt;code&gt;done_testing()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9bbc2d6ed341b1ef3ce37675e465b3be11154914" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">这对于构造用于&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;和低级POSIX tty处理操作的位图非常有用。如果FILEHANDLE是一个表达式，则将该值作为间接文件句柄，通常是其名称。</target>
        </trans-unit>
        <trans-unit id="ee19061e56d9213c77400710440b7c20343ebe03" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">这对于为 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 和低级POSIX tty处理操作构造位图非常有用。如果FILEHANDLE是一个表达式，则该值将作为间接文件句柄，通常是其名称。</target>
        </trans-unit>
        <trans-unit id="4451800d0e0114802550054b61665e033a2b00a5" translate="yes" xml:space="preserve">
          <source>This is mainly useful for constructing bitmaps for &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; and low-level POSIX tty-handling operations. If FILEHANDLE is an expression, the value is taken as an indirect filehandle, generally its name.</source>
          <target state="translated">这对于为 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 和低级POSIX tty处理操作构造位图非常有用。如果FILEHANDLE是一个表达式，则该值将作为间接文件句柄，通常是其名称。</target>
        </trans-unit>
        <trans-unit id="37ce9a12e2723922e8bd944d2d5d67e411bc7f1f" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt; .</source>
          <target state="translated">这只是 &lt;code&gt;as_string&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="2ff1814bfd6950f7490c26d111f974fff43e1eff" translate="yes" xml:space="preserve">
          <source>This is merely a synonym for &lt;code&gt;as_string&lt;/code&gt;.</source>
          <target state="translated">这只是 &lt;code&gt;as_string&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="4dab1c8c1fba88ee26cb0159afceae84eeab9c5c" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">这比原始的 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; 更可移植，但不作为说明：</target>
        </trans-unit>
        <trans-unit id="358b6febc6a20347552685e4650bab012743d763" translate="yes" xml:space="preserve">
          <source>This is more portable than the raw &lt;code&gt;ioctl&lt;/code&gt;, but not as illustrative:</source>
          <target state="translated">这比原始的 &lt;code&gt;ioctl&lt;/code&gt; 更可移植，但不具有说明性：</target>
        </trans-unit>
        <trans-unit id="a905466f9a6fe7fba1c2ba03bc5e341bea7a9afa" translate="yes" xml:space="preserve">
          <source>This is most likely the same as &lt;code&gt;$Config{osname}&lt;/code&gt;, and was the name known when perl was built. It might be different if perl was cross-compiled.</source>
          <target state="translated">这很可能与 &lt;code&gt;$Config{osname}&lt;/code&gt; ，并且是构建perl时已知的名称。如果对perl进行交叉编译，则可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="e4ef392975ecd504b3ac95743d2709331ec1fc38" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">这既不是简单性的样本，也不是可移植性的典范，但它说明了这一点：我们能够在后台偷偷摸摸，并访问Perl受到良好保护的内存！（重要说明：Perl的 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 确实</target>
        </trans-unit>
        <trans-unit id="3f30d05de7dd225aaab947f0992ea2b7121ca260" translate="yes" xml:space="preserve">
          <source>This is neither a specimen of simplicity nor a paragon of portability but it illustrates the point: We are able to sneak behind the scenes and access Perl's otherwise well-guarded memory! (Important note: Perl's &lt;code&gt;syscall&lt;/code&gt; does</source>
          <target state="translated">这既不是简单性的样本，也不是可移植性的典范，但它说明了这一点：我们能够在后台偷偷摸摸，并访问Perl受到良好保护的内存！（重要说明：Perl的 &lt;code&gt;syscall&lt;/code&gt; 确实</target>
        </trans-unit>
        <trans-unit id="10ebf1cbe04784f38db52da63b8ec5a60455457d" translate="yes" xml:space="preserve">
          <source>This is normally all you need to know. However, many options are available:</source>
          <target state="translated">通常这就是你需要知道的全部内容。不过,还有很多选择。</target>
        </trans-unit>
        <trans-unit id="d00bfe25391751730fea233731dd8b0f5f6ab569" translate="yes" xml:space="preserve">
          <source>This is not &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;, which tells you how to use the debugger. This manpage describes low-level details concerning the debugger's internals, which range from difficult to impossible to understand for anyone who isn't incredibly intimate with Perl's guts. Caveat lector.</source>
          <target state="translated">这不是&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;，它告诉您如何使用调试器。该手册页描述了有关调试器内部的低级详细信息，对于不熟悉Perl胆量的人，范围从难以理解到难以理解。注意警告。</target>
        </trans-unit>
        <trans-unit id="33bd7c44464b83d74ae2002b960a112388650681" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the &lt;code&gt;Encode&lt;/code&gt; extension for that.</source>
          <target state="translated">这不是通用的Unicode到字节编码的Unicode接口：为此使用 &lt;code&gt;Encode&lt;/code&gt; 扩展名。</target>
        </trans-unit>
        <trans-unit id="f404a9e2e0db79bb4f43c8d7bbb05496d430ba62" translate="yes" xml:space="preserve">
          <source>This is not a general purpose Unicode to byte encoding interface: use the Encode extension for that.</source>
          <target state="translated">这不是一个通用的Unicode到字节的编码接口:使用Encode扩展。</target>
        </trans-unit>
        <trans-unit id="7457d8ee09385437d0b615e7e131b4e9c0b973a9" translate="yes" xml:space="preserve">
          <source>This is not a general purpose byte encoding to Unicode interface: use the Encode extension for that.</source>
          <target state="translated">这不是一个通用的字节编码到Unicode接口:使用Encode扩展。</target>
        </trans-unit>
        <trans-unit id="4bba8250f7720ad535561da71f3cfe66f5ce3b19" translate="yes" xml:space="preserve">
          <source>This is not actually a Unicode-specified obsolescence, but applies to certain Perl extensions that are present for backwards compatibility, but are discouraged from being used. These are not obsolete, but their meanings are not stable. Future Unicode versions could force any of these extensions to be removed without warning, replaced by another property with the same name that means something different. An '&lt;b&gt;X&lt;/b&gt;' flags each such entry in the table. Use the equivalent shown instead.</source>
          <target state="translated">这实际上不是Unicode指定的过时，但适用于某些向后兼容的Perl扩展，但不建议使用。这些不是过时的，但是它们的含义并不稳定。将来的Unicode版本可能会强制删除所有扩展名，而不会发出警告，而将其替换为另一个具有相同名称的属性，这意味着有所不同。&amp;ldquo; &lt;b&gt;X&lt;/b&gt; &amp;rdquo;标记表中的每个此类条目。请使用所示的等效项。</target>
        </trans-unit>
        <trans-unit id="d116bb6d0c3c84c2243b689bc93fe4a6155eb5cb" translate="yes" xml:space="preserve">
          <source>This is not as short as before, but it makes it more obvious that we intend to have little-endian byte-order for a whole group, not only for individual template codes. It can also be more readable and easier to maintain.</source>
          <target state="translated">这虽然没有以前那么短,但它使我们更清楚地表明,我们打算对整个组采用小字节顺序,而不是只对单个模板代码采用小字节顺序。也可以更易读,更易维护。</target>
        </trans-unit>
        <trans-unit id="21c82389f9ec1dc190c296dba01242b89223a846" translate="yes" xml:space="preserve">
          <source>This is not ideal, but it seems to be the best compromise. If it doesn't work for you, please let me know the details of how it broke.</source>
          <target state="translated">这并不理想,但这似乎是最好的折中办法。如果它对你不起作用,请告诉我它是如何坏掉的细节。</target>
        </trans-unit>
        <trans-unit id="a8f2331f9105fa67d4e126b8930145be58fae503" translate="yes" xml:space="preserve">
          <source>This is not ok:</source>
          <target state="translated">这是不可以的。</target>
        </trans-unit>
        <trans-unit id="909f3f0de148a4f0a784930ff89af77cea3c7576" translate="yes" xml:space="preserve">
          <source>This is not really a &quot;severe&quot; error, but it is supposed to be raised by default even if warnings are not enabled, and currently the only way to do that in Perl is to mark it as serious.</source>
          <target state="translated">这并不是一个真正的 &quot;严重 &quot;错误,但它应该是在默认情况下引发的,即使没有启用警告,目前在Perl中唯一的方法是将其标记为严重错误。</target>
        </trans-unit>
        <trans-unit id="2b98cc8fd878d4e526c57ff147de3c4320ff2bb7" translate="yes" xml:space="preserve">
          <source>This is not required, but is recommended in case any code is called which may reset or alter &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">这不是必需的，但是在调用任何可能重置或更改 &lt;code&gt;$@&lt;/code&gt; 代码的情况下建议使用。</target>
        </trans-unit>
        <trans-unit id="99cb1cc350f7652ef06061348fb3eea6152592f9" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;&quot;lex_read_to&quot;&lt;/a&gt;.</source>
          <target state="translated">这不是使用词汇化文本的正常方法。为此，请使用&lt;a href=&quot;#lex_read_to&quot;&gt;&amp;ldquo; lex_read_to&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="197111743c19bce55304223ee2f18830ead89426" translate="yes" xml:space="preserve">
          <source>This is not the normal way to consume lexed text. For that, use &lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;.</source>
          <target state="translated">这不是使用词汇化文本的正常方法。为此，请使用&lt;a href=&quot;#lex_read_to&quot;&gt;lex_read_to&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3f9e6c0b666a1af0815bd174af9f121c2162997f" translate="yes" xml:space="preserve">
          <source>This is not the right answer at all, but the sum looks correct. I wonder if it's anything to do with operator precedence? We'll try a couple of other possibilities with our sum:</source>
          <target state="translated">这根本不是正确的答案,但和看起来是正确的。我想这是不是和运算符的优先性有关?我们用我们的和来试试其他几种可能性。</target>
        </trans-unit>
        <trans-unit id="8a04fbe62aa8087e67610ad69a72c7364e385eaa" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt; . That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">这不是在数组名称前使用的符号，以获取最后的索引，例如 &lt;code&gt;$#array&lt;/code&gt; 。这仍然是您在Perl中获得数组的最后一个索引的方式。两者彼此无关。</target>
        </trans-unit>
        <trans-unit id="0152b6d921fb917b16faa5b33711753db7914ad7" translate="yes" xml:space="preserve">
          <source>This is not the sigil you use in front of an array name to get the last index, like &lt;code&gt;$#array&lt;/code&gt;. That's still how you get the last index of an array in Perl. The two have nothing to do with each other.</source>
          <target state="translated">这不是在数组名称前使用的符号，以获取最后的索引，例如 &lt;code&gt;$#array&lt;/code&gt; 。这仍然是您在Perl中获取数组的最后一个索引的方式。两者彼此无关。</target>
        </trans-unit>
        <trans-unit id="a71eefb6bc615d22ea75cd4d866e05c590f48f94" translate="yes" xml:space="preserve">
          <source>This is not to say that Perl threads are completely different from everything that's ever come before. They're not. Perl's threading model owes a lot to other thread models, especially POSIX. Just as Perl is not C, though, Perl threads are not POSIX threads. So if you find yourself looking for mutexes, or thread priorities, it's time to step back a bit and think about what you want to do and how Perl can do it.</source>
          <target state="translated">这并不是说Perl线程与之前的一切完全不同。其实不然。Perl的线程模型欠其他线程模型很多,尤其是POSIX。不过就像Perl不是C一样,Perl线程也不是POSIX线程。所以,如果你发现自己在寻找mutexes,或者线程优先级,那么你就应该退后一步,想想你想做什么,以及Perl如何做到这一点。</target>
        </trans-unit>
        <trans-unit id="1490fa72c1eafb91d46399cb68efda52398b105d" translate="yes" xml:space="preserve">
          <source>This is not very useful, and perl currently optimizes this away.</source>
          <target state="translated">这不是很有用,目前perl把这个优化掉了。</target>
        </trans-unit>
        <trans-unit id="719ad110f9ecd2d06449f518fe559ae60b466e21" translate="yes" xml:space="preserve">
          <source>This is now the recommended interface to install().</source>
          <target state="translated">这就是现在推荐的安装()接口。</target>
        </trans-unit>
        <trans-unit id="8dd3c5aefc65986cd4924a120675ce7dc9b1881f" translate="yes" xml:space="preserve">
          <source>This is of paramount importance, since it's the documentation of what goes where in the Perl source. Read it over a couple of times and it might start to make sense - don't worry if it doesn't yet, because the best way to study it is to read it in conjunction with poking at Perl source, and we'll do that later on.</source>
          <target state="translated">这一点是最重要的,因为它是Perl源码中哪些内容在哪里的文档。把它读上几遍,可能就会开始明白了--如果还不明白也不要担心,因为研究它的最好方法是结合戳穿Perl源码来读,我们稍后再做。</target>
        </trans-unit>
        <trans-unit id="5903d2508c471509c3a8871c1121aaa61b5835b7" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">如果您需要在&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;不兼容旧版本Perl的库模块之前检查当前Perl版本，这通常很有用。（我们尽量不要做比我们要做的更多的事情。）</target>
        </trans-unit>
        <trans-unit id="fadd54f30e37dbf502c0a6893df00ea6b04ab979" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">如果您需要在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 不兼容旧版本Perl的库模块之前检查当前Perl版本，这通常很有用。（我们尽量不要做比我们要做的更多的事情。）</target>
        </trans-unit>
        <trans-unit id="96345383ecfecda78d417eea671d77452c1d163e" translate="yes" xml:space="preserve">
          <source>This is often useful if you need to check the current Perl version before &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;ing library modules that won't work with older versions of Perl. (We try not to do this more than we have to.)</source>
          <target state="translated">如果您需要在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 不兼容旧版本Perl的库模块之前检查当前Perl版本，这通常很有用。（我们尽量不要做比我们要做的更多的事情。）</target>
        </trans-unit>
        <trans-unit id="b7065d0815c75fb916f5ccef644a97fc5f9a5ab5" translate="yes" xml:space="preserve">
          <source>This is one of the cases we mentioned earlier in which references could spring into existence when in an lvalue context. Before this statement, &lt;code&gt;$array[$x]&lt;/code&gt; may have been undefined. If so, it's automatically defined with a hash reference so that we can look up &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; in it. Likewise &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; will automatically get defined with an array reference so that we can look up &lt;code&gt;[0]&lt;/code&gt; in it. This process is called</source>
          <target state="translated">这是我们前面提到的情况之一，在左值上下文中，引用可能会出现。在此语句之前，可能未定义 &lt;code&gt;$array[$x]&lt;/code&gt; 。如果是这样，它将自动使用哈希引用进行定义，以便我们可以在其中查找 &lt;code&gt;{&quot;foo&quot;}&lt;/code&gt; 。同样， &lt;code&gt;$array[$x]-&amp;gt;{&quot;foo&quot;}&lt;/code&gt; 将自动使用数组引用进行定义，以便我们可以在其中查找 &lt;code&gt;[0]&lt;/code&gt; 。这个过程叫做</target>
        </trans-unit>
        <trans-unit id="6a3344e74e174252dc0aef67360fb712feea83d3" translate="yes" xml:space="preserve">
          <source>This is one of the only places where giving a prototype to a closure makes much sense. If you wanted to impose scalar context on the arguments of these functions (probably not a wise idea for this particular example), you could have written it this way instead:</source>
          <target state="translated">这是唯一一个给一个闭包提供原型的地方,是很有意义的。如果你想把标量上下文强加在这些函数的参数上(对于这个特殊的例子来说,这可能不是一个明智的想法),你可以这样写。</target>
        </trans-unit>
        <trans-unit id="36e82904f13aaec8c8bc429b12fde4bbb0fe088f" translate="yes" xml:space="preserve">
          <source>This is only needed when converting a metadata fragment that does not include a &lt;code&gt;meta-spec&lt;/code&gt; field.</source>
          <target state="translated">仅当转换不包含 &lt;code&gt;meta-spec&lt;/code&gt; 字段的元数据片段时才需要这样做。</target>
        </trans-unit>
        <trans-unit id="8815273ee560d0448d9c01c105592b19a9f70fd8" translate="yes" xml:space="preserve">
          <source>This is only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. It is the $Config{byteorder} string of the perl that created this image. It is a string like &quot;1234&quot; (32 bit little endian) or &quot;87654321&quot; (64 bit big endian). This must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">仅在 &lt;code&gt;netorder&lt;/code&gt; 为FALSE 时才存在。是创建该映像的perl的$ Config {byteorder}字符串。它是一个字符串，例如&amp;ldquo; 1234&amp;rdquo;（32位小端）或&amp;ldquo; 87654321&amp;rdquo;（64位大端）。这必须与当前perl匹配才能使Storable读取图像。</target>
        </trans-unit>
        <trans-unit id="84ff724c95d2598efdb8d7d443f2851d8e9c24b5" translate="yes" xml:space="preserve">
          <source>This is only required on some platforms which do not handle dependent libraries automatically. For example the Socket Perl extension library (</source>
          <target state="translated">只有在一些不会自动处理依赖库的平台上才需要这样做。例如Socket Perl扩展库(</target>
        </trans-unit>
        <trans-unit id="3167fd37c36e8874785bfe9f3f3013cce7f288bd" translate="yes" xml:space="preserve">
          <source>This is open source software. The code repository is available for public review and contribution under the terms of the license.</source>
          <target state="translated">这是一个开放源码软件。根据许可证的条款,代码库可供公众审查和贡献。</target>
        </trans-unit>
        <trans-unit id="bcfe5a91a20366b07a20b45c08c83d2cb3335747" translate="yes" xml:space="preserve">
          <source>This is our final regexp. To recap, we built a regexp by</source>
          <target state="translated">这是我们最后的regexp。概括地说,我们通过以下方法建立了一个regexp。</target>
        </trans-unit>
        <trans-unit id="55cbe19c15cda5405c9b99032930566aa6e4cd4b" translate="yes" xml:space="preserve">
          <source>This is parsed as:</source>
          <target state="translated">这被解析为:</target>
        </trans-unit>
        <trans-unit id="4f7853da7a16df56ba94a3f89eeeb6c41db7cabc" translate="yes" xml:space="preserve">
          <source>This is partially implemented now.</source>
          <target state="translated">现在已经部分实施。</target>
        </trans-unit>
        <trans-unit id="2a6f22dd0203804895067e4cd94d48784411f916" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">这对于动态模式特别有用，例如从配置文件读入，从参数获取或在某个地方的表中指定的动态模式。考虑以下情况：有些模式要区分大小写，而有些则不想：不区分大小写的模式只需要在模式的前面包含 &lt;code&gt;(?i)&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="a9a8ef21b0f21974a251d0cd49767a5e49f56bc4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for dynamically-generated patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere. Consider the case where some patterns want to be case-sensitive and some do not: The case-insensitive ones merely need to include &lt;code&gt;(?i)&lt;/code&gt; at the front of the pattern. For example:</source>
          <target state="translated">这对于动态生成的模式特别有用，例如从配置文件读入，从参数获取或在某个地方的表中指定的模式。考虑以下情况：有些模式要区分大小写而有些则不要：不区分大小写的模式只需要在模式的前面包含 &lt;code&gt;(?i)&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="aaa59114ea7716b61a1b0ecf212fbfdac38cd5ec" translate="yes" xml:space="preserve">
          <source>This is particularly useful if you have More Than One Way (tm) to solve a problem in a program, and only wish to continue down a path if all modules could be loaded, and not load them if they couldn't.</source>
          <target state="translated">如果你在一个程序中有多个方法(tm)来解决一个问题,并且只希望在所有模块都能加载的情况下继续往下走,如果不能加载就不加载,这一点特别有用。</target>
        </trans-unit>
        <trans-unit id="7f5141125aa28c42d6dec636c32fcbaa85fe78c3" translate="yes" xml:space="preserve">
          <source>This is particularly useful when applied to code references returned from reval().</source>
          <target state="translated">当应用于从reval()返回的代码引用时,这一点特别有用。</target>
        </trans-unit>
        <trans-unit id="3afdcef939cf6d1f8b0ef2be038cdb0c7d7984fa" translate="yes" xml:space="preserve">
          <source>This is powerful, and slightly dangerous, in that it's possible to intend (with the utmost sincerity) to use a hard reference, and accidentally use a symbolic reference instead. To protect against that, you can say</source>
          <target state="translated">这是强大的,也是稍微危险的,因为它有可能打算(以最大的诚意)使用一个硬引用,而不小心使用一个符号引用。为了防止这种情况,你可以说</target>
        </trans-unit>
        <trans-unit id="1d61b3fe5532441244041a6185a4d7b90b80ec48" translate="yes" xml:space="preserve">
          <source>This is primarily meant for the use of modules such as FTP where passwords are sent, but we do not want to display them in the debugging information.</source>
          <target state="translated">这主要是针对FTP等发送密码的模块的使用,但我们不希望在调试信息中显示密码。</target>
        </trans-unit>
        <trans-unit id="01c91853268ed50e9d0a33c6896652af44de4d99" translate="yes" xml:space="preserve">
          <source>This is primarily of use for people who repackage Perl modules.</source>
          <target state="translated">这主要是给重新打包Perl模块的人用的。</target>
        </trans-unit>
        <trans-unit id="831dab0bf255edc5ba7e605462344bdbe78142e8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">这主要用于 &lt;code&gt;(?{...})&lt;/code&gt; 块内部，以检查最近匹配的文本。例如，要有效地将文本捕获到变量中（除了 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等），请将 &lt;code&gt;(...)&lt;/code&gt; 替换为</target>
        </trans-unit>
        <trans-unit id="785aba462ddf893b4d7d212c5fc066f6e4b29bd8" translate="yes" xml:space="preserve">
          <source>This is primarily used inside &lt;code&gt;(?{...})&lt;/code&gt; blocks for examining text recently matched. For example, to effectively capture text to a variable (in addition to &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc.), replace &lt;code&gt;(...)&lt;/code&gt; with</source>
          <target state="translated">这主要用于 &lt;code&gt;(?{...})&lt;/code&gt; 块中，用于检查最近匹配的文本。例如，要有效地将文本捕获到变量中（除了 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等），请将 &lt;code&gt;(...)&lt;/code&gt; 替换为</target>
        </trans-unit>
        <trans-unit id="471731e21edc337b491a7b40340da72650201ff9" translate="yes" xml:space="preserve">
          <source>This is primarily used when you need to make several actions atomic (against some signals anyway).</source>
          <target state="translated">这主要用于当你需要使几个动作原子化的时候(反正是针对某些信号)。</target>
        </trans-unit>
        <trans-unit id="43405231d7a3fc726c046090388674dddde66ec5" translate="yes" xml:space="preserve">
          <source>This is primarily useful for install scripts.</source>
          <target state="translated">这主要是对安装脚本有用。</target>
        </trans-unit>
        <trans-unit id="71555351eedbd86160cbba934f94d326494c3535" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; in perl sources.</source>
          <target state="translated">这等效于printf（）。printf是为此函数定义的＃，因此（当前 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(fmt,...)&lt;/a&gt;&lt;/code&gt; 在perl源代码中使用printf（fmt，...）是合法的。</target>
        </trans-unit>
        <trans-unit id="5a921444f0499fb36eee87f18490349a0c0c08e2" translate="yes" xml:space="preserve">
          <source>This is printf() equivalent. printf is #defined to this function, so it is (currently) legal to use &lt;code&gt;printf(fmt,...)&lt;/code&gt; in perl sources.</source>
          <target state="translated">这等效于printf（）。printf是为此函数定义的＃，因此（当前 &lt;code&gt;printf(fmt,...)&lt;/code&gt; 在perl源中使用printf（fmt，...）是合法的。</target>
        </trans-unit>
        <trans-unit id="4ea35349c6ed8d6a98b7de634d09f57721480861" translate="yes" xml:space="preserve">
          <source>This is private to the Perl core and subject to change. Should be left null.</source>
          <target state="translated">这是Perl核心的隐私,可能会有变化。应该保持为空。</target>
        </trans-unit>
        <trans-unit id="a42a74dee5bfb28b5a2d265ff8a638902c0a2d41" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&quot;sv_usepvn_flags&quot;&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;&quot;sv_setpvn&quot;&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;&quot;sv_setpvs&quot;&lt;/a&gt;.</source>
          <target state="translated">这可能不是您要使用的，您可能想要&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;&amp;ldquo; sv_usepvn_flags&amp;rdquo;&lt;/a&gt;或&lt;a href=&quot;#sv_setpvn&quot;&gt;&amp;ldquo; sv_setpvn&amp;rdquo;&lt;/a&gt;或&lt;a href=&quot;#sv_setpvs&quot;&gt;&amp;ldquo; sv_setpvs&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98fa02440d9fac9b73c470e7ca881854b6795009" translate="yes" xml:space="preserve">
          <source>This is probably not what you want to use, you probably wanted &lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt; or &lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt; or &lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;.</source>
          <target state="translated">这可能不是您要使用的，您可能想要&lt;a href=&quot;#sv_usepvn_flags&quot;&gt;sv_usepvn_flags&lt;/a&gt;或&lt;a href=&quot;#sv_setpvn&quot;&gt;sv_setpvn&lt;/a&gt;或&lt;a href=&quot;#sv_setpvs&quot;&gt;sv_setpvs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="697287005f5cb5ed6d011d9e5061126f21f55b05" translate="yes" xml:space="preserve">
          <source>This is provided as a more readable version of &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">它以 &lt;code&gt;if (!&lt;i&gt;condition&lt;/i&gt;)&lt;/code&gt; 可读性更高的形式提供。</target>
        </trans-unit>
        <trans-unit id="4cabb9b2376d3134de9c8bd807fc2548baba2fca" translate="yes" xml:space="preserve">
          <source>This is quite different, however, from not even trusting the writer of the code not to try to do something evil. That's the kind of trust needed when someone hands you a program you've never seen before and says, &quot;Here, run this.&quot; For that kind of safety, you might want to check out the Safe module, included standard in the Perl distribution. This module allows the programmer to set up special compartments in which all system operations are trapped and namespace access is carefully controlled. Safe should not be considered bullet-proof, though: it will not prevent the foreign code to set up infinite loops, allocate gigabytes of memory, or even abusing perl bugs to make the host interpreter crash or behave in unpredictable ways. In any case it's better avoided completely if you're really concerned about security.</source>
          <target state="translated">然而,这与不相信代码的作者不会试图做一些邪恶的事情是完全不同的。当有人递给你一个你从未见过的程序,并说 &quot;给你,运行这个 &quot;时,你需要的就是这种信任。为了这种安全,你可能会想看看安全模块,它包含在Perl发行版的标准配置中。这个模块允许程序员设置特殊的隔间,所有的系统操作都会在其中被捕获,命名空间的访问也会被仔细控制。不过Safe不应该被认为是万无一失的:它不能防止外来代码建立无限循环,分配千兆字节的内存,甚至滥用perl bug使主机解释器崩溃或以不可预测的方式行事。总之,如果你真的担心安全问题,最好完全避免。</target>
        </trans-unit>
        <trans-unit id="50d419167936516f6bf9a1f029bd288bcc5eb141" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">对于.xs文件，这是非常典型的：通常.xs文件提供了到现有C函数的接口。然后，在某个地方（在外部库中或.xs文件的第一部分中）定义此C函数，并在.xs文件的第二部分中描述此函数的Perl接口（即&amp;ldquo; Perl胶&amp;rdquo;）。当所有工作都在&amp;ldquo; Perl胶水&amp;rdquo;中完成时，&lt;a href=&quot;#EXAMPLE-1&quot;&gt;&amp;ldquo;示例1&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;&amp;ldquo;示例2&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;&amp;ldquo;示例3&amp;rdquo;&lt;/a&gt;中的情况在某种程度上是例外，而不是规则。</target>
        </trans-unit>
        <trans-unit id="fc844a09760bd8a2dc9b577b36da09548b575605" translate="yes" xml:space="preserve">
          <source>This is quite typical for .xs files: usually the .xs file provides an interface to an existing C function. Then this C function is defined somewhere (either in an external library, or in the first part of .xs file), and a Perl interface to this function (i.e. &quot;Perl glue&quot;) is described in the second part of .xs file. The situation in &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt;, and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, when all the work is done inside the &quot;Perl glue&quot;, is somewhat of an exception rather than the rule.</source>
          <target state="translated">这对于.xs文件是非常典型的：通常.xs文件为现有C函数提供接口。然后，在某处（在外部库中或.xs文件的第一部分中）定义此C函数，并在.xs文件的第二部分中描述此函数的Perl接口（即&amp;ldquo; Perl胶&amp;rdquo;）。当所有工作都在&amp;ldquo; Perl胶水&amp;rdquo;中完成时，&lt;a href=&quot;#EXAMPLE-1&quot;&gt;示例1&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;示例2&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;示例3中&lt;/a&gt;的情况在某种程度上是一种例外，而非常规。</target>
        </trans-unit>
        <trans-unit id="c3a982ed6685f74bf9f57db540f3caed5035dcd6" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt; , it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">这非常有用，因为它通常可以提高可读性。尽管这对于 &lt;code&gt;SV *&lt;/code&gt; 可以正常工作，但不幸的是，将 &lt;code&gt;AV *&lt;/code&gt; 或 &lt;code&gt;HV *&lt;/code&gt; 作为返回值并不容易。您</target>
        </trans-unit>
        <trans-unit id="02c1d462530bf64748def6c496de1d6240bfa91b" translate="yes" xml:space="preserve">
          <source>This is quite useful as it usually improves readability. While this works fine for an &lt;code&gt;SV *&lt;/code&gt;, it's unfortunately not as easy to have &lt;code&gt;AV *&lt;/code&gt; or &lt;code&gt;HV *&lt;/code&gt; as a return value. You</source>
          <target state="translated">这非常有用，因为它通常可以提高可读性。尽管这对于 &lt;code&gt;SV *&lt;/code&gt; 可以正常工作，但是不幸的是，将 &lt;code&gt;AV *&lt;/code&gt; 或 &lt;code&gt;HV *&lt;/code&gt; 作为返回值并不容易。你</target>
        </trans-unit>
        <trans-unit id="df9aa2c2c409f58ba99139ca42f157f4afdf7a29" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">这很少使用。有时是使用E &amp;lt;...&amp;gt;代码的一种解决方法。例如，代替&amp;ldquo; &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; &amp;rdquo;（对于&amp;ldquo; N &amp;lt;3&amp;rdquo;），您可以编写&amp;ldquo; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &amp;rdquo;（&amp;ldquo; Z &amp;lt;&amp;gt;&amp;rdquo;将&amp;ldquo; N&amp;rdquo;和&amp;ldquo; &amp;lt;&amp;rdquo;分开，因此它们不能被视为（虚拟）&amp;ldquo; N &amp;lt;...&amp;gt;&amp;rdquo;代码的一部分）。</target>
        </trans-unit>
        <trans-unit id="3c3972509e727368d3c5e9a50516482551fe729d" translate="yes" xml:space="preserve">
          <source>This is rarely used. It's one way to get around using an E&amp;lt;...&amp;gt; code sometimes. For example, instead of &quot;&lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt;&quot; (for &quot;N&amp;lt;3&quot;) you could write &quot;&lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt;&quot; (the &quot;Z&amp;lt;&amp;gt;&quot; breaks up the &quot;N&quot; and the &quot;&amp;lt;&quot; so they can't be considered the part of a (fictitious) &quot;N&amp;lt;...&amp;gt;&quot; code).</source>
          <target state="translated">这很少使用。这是有时使用E &amp;lt;...&amp;gt;代码的一种解决方法。例如，您可以编写&amp;ldquo; &lt;code&gt;NZ&amp;lt;&amp;gt;&amp;lt;3&lt;/code&gt; &amp;rdquo;（&amp;ldquo; Z &amp;lt;&amp;gt;&amp;rdquo;将&amp;ldquo; N&amp;rdquo;和&amp;ldquo; &amp;lt;&amp;rdquo; &lt;code&gt;NE&amp;lt;lt&amp;gt;3&lt;/code&gt; ，而不是&amp;ldquo; NE &amp;lt;lt&amp;gt; 3 &amp;rdquo;（对于&amp;ldquo; N &amp;lt;3&amp;rdquo;））不能被视为（虚拟）&amp;ldquo; N &amp;lt;...&amp;gt;&amp;rdquo;代码的一部分）。</target>
        </trans-unit>
        <trans-unit id="5c569493cb06e371332b5d2d180bdd4a7a876b1d" translate="yes" xml:space="preserve">
          <source>This is required by some servers. For example if you are connecting to an INN server and you have transfer permission your connection will be connected to the transfer daemon, not the NNTP daemon. Issuing this command will cause the transfer daemon to hand over control to the NNTP daemon.</source>
          <target state="translated">这是一些服务器所需要的。例如,如果你连接到一个 INN 服务器,并且你有传输权限,你的连接将连接到传输守护进程,而不是 NNTP 守护进程。发出这个命令将导致传输守护进程将控制权交给NNTP守护进程。</target>
        </trans-unit>
        <trans-unit id="cbdfb46249e842a142c962c6d9643c65a18e64d0" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems &lt;code&gt;/tmp&lt;/code&gt; is not owned by root.</source>
          <target state="translated">这是必需的，因为在许多UNIX系统上， &lt;code&gt;/tmp&lt;/code&gt; 不是root拥有的。</target>
        </trans-unit>
        <trans-unit id="1aba726220151e0bdd8e20f672a38f3cb853c543" translate="yes" xml:space="preserve">
          <source>This is required since on many unix systems C is not owned by root.</source>
          <target state="translated">这是必须的,因为在许多unix系统中,C不属于root。</target>
        </trans-unit>
        <trans-unit id="53e759494f9bf8d7efd9149cfc161ebbf71db524" translate="yes" xml:space="preserve">
          <source>This is safer than and replaces the &quot;no_plan&quot; plan.</source>
          <target state="translated">这比 &quot;no_plan &quot;计划更安全,并取代了它。</target>
        </trans-unit>
        <trans-unit id="ce8477bd1dd658eb92098ae32e26b04afeab44b4" translate="yes" xml:space="preserve">
          <source>This is same as &lt;code&gt;new()&lt;/code&gt;, except that &lt;code&gt;generated_by&lt;/code&gt; and &lt;code&gt;meta-spec&lt;/code&gt; fields will be generated if not provided. This means the metadata structure is assumed to otherwise follow the latest &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;.</source>
          <target state="translated">这与 &lt;code&gt;new()&lt;/code&gt; 相同，除了如果未提供则将 &lt;code&gt;generated_by&lt;/code&gt; 和 &lt;code&gt;meta-spec&lt;/code&gt; 字段。这意味着假定元数据结构遵循最新的&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7ebcb8463dd98d519e70a00c26fec5b1949c87c" translate="yes" xml:space="preserve">
          <source>This is seldom necessary, though, because this is done automatically, like when you access an array:</source>
          <target state="translated">不过这很少是必要的,因为这是自动完成的,就像你访问一个数组一样。</target>
        </trans-unit>
        <trans-unit id="5b39df7c425593c524473bd917a5316f755e7f35" translate="yes" xml:space="preserve">
          <source>This is set to &lt;code&gt;true&lt;/code&gt; in</source>
          <target state="translated">这是设置为 &lt;code&gt;true&lt;/code&gt; 的</target>
        </trans-unit>
        <trans-unit id="bda100b399c447a02432db64ae424bebb5a77bb3" translate="yes" xml:space="preserve">
          <source>This is set to a true value. It allows the tests to determine if they are being executed through the harness or by any other means.</source>
          <target state="translated">这被设置为真值。它允许测试确定它们是通过线束还是通过任何其他方式执行。</target>
        </trans-unit>
        <trans-unit id="784e1d59cc78e03dfce5c4eb5ddb5046b2ae8797" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, &lt;a href=&quot;http://man.he.net/man1/grep&quot;&gt;grep(1)&lt;/a&gt; and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">这在本质上与&lt;a href=&quot;http://man.he.net/man1/grep&quot;&gt;grep（1）&lt;/a&gt;及其亲属相似，但不相同。特别地，它不限于使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="8825b383410611d9ab88c7c6da41a37ab67b7bd2" translate="yes" xml:space="preserve">
          <source>This is similar in spirit to, but not the same as, grep(1) and its relatives. In particular, it is not limited to using regular expressions.</source>
          <target state="translated">这与grep(1)及其亲属的精神类似,但不一样。特别是,它不限于使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">这类似于</target>
        </trans-unit>
        <trans-unit id="3e6ba00cc4274369aaec7e06e964eb77cd40c12d" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这类似于 &lt;code&gt;$&amp;amp;&lt;/code&gt; （ &lt;code&gt;$MATCH&lt;/code&gt; ），只是它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="b7e216fa4594cbacfaf20854b0ab30d1c8d5c1e2" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$&amp;amp;&lt;/code&gt; (&lt;code&gt;$MATCH&lt;/code&gt;) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这类似于 &lt;code&gt;$&amp;amp;&lt;/code&gt; （ &lt;code&gt;$MATCH&lt;/code&gt; ），只是它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="95e9006abb746eec00ddbe6c7b21cfe4ec62c97b" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt; ) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这类似于 &lt;code&gt;$'&lt;/code&gt; （ &lt;code&gt;$POSTMATCH&lt;/code&gt; ），除了它不会招致与该变量相关的性能损失外。</target>
        </trans-unit>
        <trans-unit id="6fd5c8a1ee96062bbcb6f2a27266f07276bffe2f" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$'&lt;/code&gt; (&lt;code&gt;$POSTMATCH&lt;/code&gt;) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">这与 &lt;code&gt;$'&lt;/code&gt; （ &lt;code&gt;$POSTMATCH&lt;/code&gt; ）相似，除了它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="62e38c00b725c5a13563494b1438770078513b03" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;$`&lt;/code&gt; ($PREMATCH) except that it does not incur the performance penalty associated with that variable.</source>
          <target state="translated">类似于 &lt;code&gt;$`&lt;/code&gt; （$ PREMATCH），不同之处在于它不会招致与该变量相关的性能损失。</target>
        </trans-unit>
        <trans-unit id="b7b04635104076e8869c03a97df7510eda62d809" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">这类似于 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; ，但是只返回代码引用或 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 来指示不存在该名称的其他方法。</target>
        </trans-unit>
        <trans-unit id="c76a101755f29c4620b6ee3b21e4e2a7b2d96005" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;next::method&lt;/code&gt;, but just returns either a code reference or &lt;code&gt;undef&lt;/code&gt; to indicate that no further methods of this name exist.</source>
          <target state="translated">这类似于 &lt;code&gt;next::method&lt;/code&gt; ，但是仅返回代码引用或 &lt;code&gt;undef&lt;/code&gt; ,以指示不存在该名称的其他方法。</target>
        </trans-unit>
        <trans-unit id="f73fed07cf9661cd5a76d43367f7870e1dfd1e63" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt; . The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">这类似于 &lt;code&gt;string_vianame&lt;/code&gt; 。主要区别在于，在大多数情况下， &lt;code&gt;vianame&lt;/code&gt; 返回一个序号代码点，而 &lt;code&gt;string_vianame&lt;/code&gt; 返回一个字符串。例如，</target>
        </trans-unit>
        <trans-unit id="035b09da2ed8ab563a4781cdc8cd00f1a372a968" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;string_vianame&lt;/code&gt;. The main difference is that under most circumstances, &lt;code&gt;vianame&lt;/code&gt; returns an ordinal code point, whereas &lt;code&gt;string_vianame&lt;/code&gt; returns a string. For example,</source>
          <target state="translated">这类似于 &lt;code&gt;string_vianame&lt;/code&gt; 。主要区别在于，在大多数情况下， &lt;code&gt;vianame&lt;/code&gt; 返回一个序号代码点，而 &lt;code&gt;string_vianame&lt;/code&gt; 返回一个字符串。例如，</target>
        </trans-unit>
        <trans-unit id="82735301d82a0dc4313bb1d53ad031d27f023c2f" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;.</source>
          <target state="translated">这类似于Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 函数，该函数返回具有根据要求设置格式的参数的字符串，请参见&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a0b7112ac62ec6b0732258b7ebbd4369edb185a" translate="yes" xml:space="preserve">
          <source>This is similar to Perl's builtin &lt;code&gt;sprintf()&lt;/code&gt; function for returning a string that has the arguments formatted as requested, see &lt;a href=&quot;perlfunc#sprintf&quot;&gt;&quot;sprintf&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">这类似于Perl的内置 &lt;code&gt;sprintf()&lt;/code&gt; 函数，该函数返回具有按要求设置格式的参数的字符串，请参见&lt;a href=&quot;perlfunc#sprintf&quot;&gt;perlfunc中的&amp;ldquo; sprintf&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb9fc002d8f7d1fdb8d39dcb8cc96f69462055b3" translate="yes" xml:space="preserve">
          <source>This is similar to calling the &lt;code&gt;x&lt;/code&gt; command on each applicable var.</source>
          <target state="translated">这类似于在每个适用的var上调用 &lt;code&gt;x&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="c882c2e2c2f32205e6402773c4c5a8648cf274ab" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Perl 6. Like &lt;code&gt;(*PRUNE)&lt;/code&gt; , this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">这是类似于&amp;ldquo;切团&amp;rdquo;运营商 &lt;code&gt;::&lt;/code&gt; 在Perl 6赞 &lt;code&gt;(*PRUNE)&lt;/code&gt; ，这个动词总是匹配，当回溯到上失败，它会导致正则表达式引擎来尝试最内层组在接下来的交替（捕获或以其他方式）。就 &lt;code&gt;(*THEN)&lt;/code&gt; 而言 &lt;code&gt;(?(condition)yes-pattern|no-pattern)&lt;/code&gt; 的两个分支不算作交替。</target>
        </trans-unit>
        <trans-unit id="789212497ee1cf1f776a732c31bef719dc8f5cde" translate="yes" xml:space="preserve">
          <source>This is similar to the &quot;cut group&quot; operator &lt;code&gt;::&lt;/code&gt; from Raku. Like &lt;code&gt;(*PRUNE)&lt;/code&gt;, this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise) that has alternations. The two branches of a &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)&lt;i&gt;yes-pattern&lt;/i&gt;|&lt;i&gt;no-pattern&lt;/i&gt;)&lt;/code&gt; do not count as an alternation, as far as &lt;code&gt;(*THEN)&lt;/code&gt; is concerned.</source>
          <target state="translated">这类似于Raku中的&amp;ldquo;剪切组&amp;rdquo;运算符 &lt;code&gt;::&lt;/code&gt; 。像 &lt;code&gt;(*PRUNE)&lt;/code&gt; 一样，此动词始终匹配，并且在失败时回溯到失败时，它会导致正则表达式引擎尝试在最内部的具有替换关系的封闭组（捕获或其他方式）中进行下一个替换。一的两个分支 &lt;code&gt;(?(&lt;i&gt;condition&lt;/i&gt;)&lt;i&gt;yes-pattern&lt;/i&gt;|&lt;i&gt;no-pattern&lt;/i&gt;)&lt;/code&gt; 不计入的交替，据 &lt;code&gt;(*THEN)&lt;/code&gt; 而言。</target>
        </trans-unit>
        <trans-unit id="5b23340a8a44f500f9fdd2f514353aafef1f1600" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt; , for duplicating a file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup()&lt;/code&gt; ，用于复制文件描述符。</target>
        </trans-unit>
        <trans-unit id="ae6596049dbd554c0142eb69dbcbdccd65d36765" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup()&lt;/code&gt;, for duplicating a file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup()&lt;/code&gt; ，用于复制文件描述符。</target>
        </trans-unit>
        <trans-unit id="bc59e25f670eb40f71d53b45961566d88e8da8a1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt; , for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup2()&lt;/code&gt; ，用于将文件描述符复制到另一个已知的文件描述符。</target>
        </trans-unit>
        <trans-unit id="f1e6999776f77cce2c537978df0c9c5950783832" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;dup2()&lt;/code&gt;, for duplicating a file descriptor to an another known file descriptor.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;dup2()&lt;/code&gt; ，用于将文件描述符复制到另一个已知的文件描述符。</target>
        </trans-unit>
        <trans-unit id="f3ae23dd5fc0059c09ec24ea0c5ef5acb6d58fa1" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;mkfifo()&lt;/code&gt; for creating FIFO special files.</source>
          <target state="translated">这类似于用于创建FIFO特殊文件的C函数 &lt;code&gt;mkfifo()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb82e089ae466005cc0dc383a964501667069da5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt; , for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;nice()&lt;/code&gt; ，用于更改当前进程的调度首选项。积极的论点意味着更礼貌的过程，消极的价值观意味着更需要的过程。普通（非root用户）用户进程只能朝着更礼貌的方向转变。</target>
        </trans-unit>
        <trans-unit id="9a0808a5ff368707577d5e1f0e5bcb31b1f6ad15" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;nice()&lt;/code&gt;, for changing the scheduling preference of the current process. Positive arguments mean a more polite process, negative values a more needy process. Normal (non-root) user processes can only change towards being more polite.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;nice()&lt;/code&gt; ，用于更改当前进程的调度首选项。积极的论点意味着更礼貌的过程，消极的价值观则意味着更需要的过程。普通（非root用户）用户进程只能朝着更礼貌的方向转变。</target>
        </trans-unit>
        <trans-unit id="458e14f71182f02f4a806b4f96c30f94a69e2f5d" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;pause()&lt;/code&gt; , which suspends the execution of the current process until a signal is received.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;pause()&lt;/code&gt; ，该函数暂停当前进程的执行，直到接收到信号为止。</target>
        </trans-unit>
        <trans-unit id="e41f365bbfbbe805fa9664e5da8fbc5e5e99f55a" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;pause()&lt;/code&gt;, which suspends the execution of the current process until a signal is received.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;pause()&lt;/code&gt; ，该函数暂停当前进程的执行，直到接收到信号为止。</target>
        </trans-unit>
        <trans-unit id="b5c0406fc055d4e959d81bed9920f88092d08404" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;setpgid()&lt;/code&gt; for setting the process group identifier of the current process.</source>
          <target state="translated">这类似于用于设置当前进程的进程组标识符的C函数 &lt;code&gt;setpgid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b56c5c880f143b4a031f787b44269acb561de2d9" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcdrain()&lt;/code&gt; for draining the output queue of its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcdrain()&lt;/code&gt; 耗尽其参数流的输出队列。</target>
        </trans-unit>
        <trans-unit id="fba332acc7267461256bd4bbecd53d5cd07ab313" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflow()&lt;/code&gt; for controlling the flow of its argument stream.</source>
          <target state="translated">这类似于用于控制其参数流的C函数 &lt;code&gt;tcflow()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2235c85d6f3847cd44159a3753a652d29703f3f5" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcflush()&lt;/code&gt; for flushing the I/O buffers of its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcflush()&lt;/code&gt; 刷新其参数流的I / O缓冲区。</target>
        </trans-unit>
        <trans-unit id="32c5db3dfe196b930ba8a6acd29334ab37d33b0e" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsendbreak()&lt;/code&gt; for sending a break on its argument stream.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcsendbreak()&lt;/code&gt; 在其参数流上发送中断。</target>
        </trans-unit>
        <trans-unit id="d51d66ac3fd31e0526e015560112bf7a83d1d7e3" translate="yes" xml:space="preserve">
          <source>This is similar to the C function &lt;code&gt;tcsetpgrp()&lt;/code&gt; for setting the process group identifier of the foreground process group of the controlling terminal.</source>
          <target state="translated">这类似于C函数 &lt;code&gt;tcsetpgrp()&lt;/code&gt; ,用于设置控制终端的前台进程组的进程组标识符。</target>
        </trans-unit>
        <trans-unit id="66ffda00414691432da9fbf5e0758036abbf4c87" translate="yes" xml:space="preserve">
          <source>This is similar to the C function, except that it can apply to a single character or to a whole string, and currently operates as if the locale always is &quot;C&quot;. Consider using the &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; function, see &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, or the equivalent &lt;code&gt;\U&lt;/code&gt; operator inside doublequotish strings.</source>
          <target state="translated">这与C函数类似，不同之处在于它可以应用于单个字符或整个字符串，并且当前的运行方式就像语言环境始终为&amp;ldquo; C&amp;rdquo;一样。考虑使用 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 函数，请参见&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;或双引号字符串中的等效 &lt;code&gt;\U&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="8eda6f0f736dfb783b722b66835ba379ce58a17f" translate="yes" xml:space="preserve">
          <source>This is similar to using T_OPAQUEPTR but can be used to process more than one element.</source>
          <target state="translated">这与使用T_OPAQUEPTR类似,但可以用来处理多个元素。</target>
        </trans-unit>
        <trans-unit id="a28122b9a555130e7576bc2e3eaca06e448a1d61" translate="yes" xml:space="preserve">
          <source>This is similar to what &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma does.</source>
          <target state="translated">这类似于&lt;a href=&quot;open&quot;&gt;开放式&lt;/a&gt;编译指示所做的事情。</target>
        </trans-unit>
        <trans-unit id="bd2544ef4a094110db1a1743d7560cf9401d79c3" translate="yes" xml:space="preserve">
          <source>This is slightly more performant than making four separate checks in four separate &lt;code&gt;mXPUSHi()&lt;/code&gt; calls.</source>
          <target state="translated">这比在四个单独的 &lt;code&gt;mXPUSHi()&lt;/code&gt; 调用中进行四个单独的检查要好一些。</target>
        </trans-unit>
        <trans-unit id="a070e7d29b17578c9c82db6eb47bc8205a22821e" translate="yes" xml:space="preserve">
          <source>This is so that you can write loops like:</source>
          <target state="translated">这是为了让你可以写出像这样的循环。</target>
        </trans-unit>
        <trans-unit id="5bb4dbbe89d426f58f9d96c7270c7af2e03e5d56" translate="yes" xml:space="preserve">
          <source>This is something you, the programmer, has to keep track of; sorry. You could consider adopting a kind of &quot;Hungarian notation&quot; to help with this.</source>
          <target state="translated">这是你,程序员,必须跟踪的事情;抱歉。你可以考虑采用一种 &quot;匈牙利符号 &quot;来帮助解决这个问题。</target>
        </trans-unit>
        <trans-unit id="f62086875f698e88f1673ff191123d1ebe166ce0" translate="yes" xml:space="preserve">
          <source>This is somewhat equivalent to the C-style switch statement's fallthrough functionality (not to be confused with</source>
          <target state="translated">这在一定程度上等同于C式开关语句的跌穿功能(不要与</target>
        </trans-unit>
        <trans-unit id="7039ef5c59f1a390b0357d66a81e16efc5deefb4" translate="yes" xml:space="preserve">
          <source>This is somewhat like &lt;code&gt;SUPER&lt;/code&gt; , but it uses the C3 method resolution order to get better consistency in multiple inheritance situations. Note that while inheritance in general follows whichever MRO is in effect for the given class, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; only uses the C3 MRO.</source>
          <target state="translated">这有点像 &lt;code&gt;SUPER&lt;/code&gt; ，但是它使用C3方法解析顺序来在多重继承情况下获得更好的一致性。请注意，虽然继承通常遵循对给定类有效的MRO，但 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 仅使用C3 MRO。</target>
        </trans-unit>
        <trans-unit id="95132fa5d3b646da8b789212be7047604909e342" translate="yes" xml:space="preserve">
          <source>This is somewhat like &lt;code&gt;SUPER&lt;/code&gt;, but it uses the C3 method resolution order to get better consistency in multiple inheritance situations. Note that while inheritance in general follows whichever MRO is in effect for the given class, &lt;code&gt;next::method&lt;/code&gt; only uses the C3 MRO.</source>
          <target state="translated">这有点像 &lt;code&gt;SUPER&lt;/code&gt; ，但是它使用C3方法解析顺序来在多个继承情况下获得更好的一致性。注意，尽管继承通常遵循对给定类有效的MRO，但 &lt;code&gt;next::method&lt;/code&gt; 仅使用C3 MRO。</target>
        </trans-unit>
        <trans-unit id="a6e2c8909db8a95dab398add127a82ec5182c9bc" translate="yes" xml:space="preserve">
          <source>This is still a symbolic reference, and is still saddled with the problems enumerated above. It would be far better to write:</source>
          <target state="translated">这仍然是一种象征性的提法,仍然存在上述问题。如果写成:</target>
        </trans-unit>
        <trans-unit id="dc230bd2bfa305e90c52714b5b02997ea62329f3" translate="yes" xml:space="preserve">
          <source>This is subroutine definition, not a real function</source>
          <target state="translated">这是子程序的定义,不是真正的函数。</target>
        </trans-unit>
        <trans-unit id="b1e77ff60ef4ac8debe40c75ba809e724ed8905b" translate="yes" xml:space="preserve">
          <source>This is substantially different than the behavior of &lt;code&gt;SUPER&lt;/code&gt; under complex multiple inheritance. (This becomes obvious when one realizes that the common superclasses in the C3 linearizations of a given class and one of its parents will not always be ordered the same for both.)</source>
          <target state="translated">这与 &lt;code&gt;SUPER&lt;/code&gt; 在复杂的多重继承下的行为有本质的不同。（当人们意识到给定类的C3线性化中的公共超类及其父级中的一个不一定总是被定为相同时，这一点就变得显而易见。）</target>
        </trans-unit>
        <trans-unit id="23e17e01cd60708587cb31d9ff8b363ecd66c020" translate="yes" xml:space="preserve">
          <source>This is sufficient because non-XS modules install only &quot;.pm&quot; files and (sometimes) pod and/or man documentation. No re-linking of the perl binary is needed to build, install or use non-XS modules.</source>
          <target state="translated">这就足够了,因为非XS模块只安装&quot;.pm &quot;文件和(有时)pod和/或man文档。构建、安装或使用非 XS 模块不需要重新链接 perl 二进制文件。</target>
        </trans-unit>
        <trans-unit id="0a11b4a723aa89f435867b4b7aabf89fab7f0ed5" translate="yes" xml:space="preserve">
          <source>This is suitable for many purposes, but the &lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt; module is available on CPAN that provides many more features, including customization.</source>
          <target state="translated">这适用于许多目的，但是CPAN上提供了&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode :: LineBreak&lt;/a&gt;模块，该模块提供了更多功能，包括自定义。</target>
        </trans-unit>
        <trans-unit id="be5a4fb32d8ac695ed2b298f81d0f20fcb10d969" translate="yes" xml:space="preserve">
          <source>This is supported on all versions of perl.</source>
          <target state="translated">所有版本的perl都支持这个功能。</target>
        </trans-unit>
        <trans-unit id="62efbec7287d71078acc23cdfe299bffb8e3dad9" translate="yes" xml:space="preserve">
          <source>This is supported since 6.76</source>
          <target state="translated">从6.76开始支持。</target>
        </trans-unit>
        <trans-unit id="176d1979619b89ab80bba77f3ee47c56e59cc580" translate="yes" xml:space="preserve">
          <source>This is supported since 7.26</source>
          <target state="translated">从7.26开始支持</target>
        </trans-unit>
        <trans-unit id="0c58a399144492e3d85b2b92893dc4441d4f1a4b" translate="yes" xml:space="preserve">
          <source>This is synonymous with:</source>
          <target state="translated">这是同义词。</target>
        </trans-unit>
        <trans-unit id="f36d5338bbc7b7f385e72503a212aefb9d4b21f2" translate="yes" xml:space="preserve">
          <source>This is the &quot;branch reset&quot; pattern, which has the special property that the capture groups are numbered from the same starting point in each alternation branch. It is available starting from perl 5.10.0.</source>
          <target state="translated">这是 &quot;分支重置 &quot;模式,它有一个特殊的属性,即在每个交替分支中,捕获组从同一个起点开始编号。从perl 5.10.0开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="19421af57fe146a06eb56f9f30349ebe8341f96d" translate="yes" xml:space="preserve">
          <source>This is the &quot;make test&quot; result from the said combination:</source>
          <target state="translated">这就是上述组合的 &quot;使试 &quot;结果。</target>
        </trans-unit>
        <trans-unit id="62ca18cb3607997061d57b9fd320ab0f041516b6" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; SV。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96cfbbe2d84ca5bfe80092e6f9ad37226fb61e75" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;false&lt;/code&gt; SV. See &lt;code&gt;&lt;a href=&quot;#PL_sv_yes&quot;&gt;&quot;PL_sv_yes&quot;&lt;/a&gt;&lt;/code&gt;. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;false&lt;/code&gt; SV。参见 &lt;code&gt;&lt;a href=&quot;#PL_sv_yes&quot;&gt;&quot;PL_sv_yes&quot;&lt;/a&gt;&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4760f68814e5682fe3f5f10b06ed0b34903e395" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;false&lt;/code&gt; SV. See &lt;code&gt;PL_sv_yes&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;false&lt;/code&gt; SV。参见 &lt;code&gt;PL_sv_yes&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_no&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e139735f50d334d273ed9e56bd61f363d8c88b31" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;true&lt;/code&gt; SV. See &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt;. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;true&lt;/code&gt; SV。参见 &lt;code&gt;&lt;a href=&quot;#PL_sv_no&quot;&gt;&quot;PL_sv_no&quot;&lt;/a&gt;&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69477e80b4da6549c4778882346d8c2f1a054a61" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;true&lt;/code&gt; SV. See &lt;code&gt;PL_sv_no&lt;/code&gt; . Always refer to this as &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;true&lt;/code&gt; SV。参见 &lt;code&gt;PL_sv_no&lt;/code&gt; 。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_yes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81478e9ca7d8718a5ec449fbb46281e67cc22245" translate="yes" xml:space="preserve">
          <source>This is the &lt;code&gt;undef&lt;/code&gt; SV. Always refer to this as &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;undef&lt;/code&gt; SV。始终将此称为 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7194017d84a1b8d81ca4290d44c59af66198e5c2" translate="yes" xml:space="preserve">
          <source>This is the Perl 6 &quot;commit pattern&quot; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; or &lt;code&gt;:::&lt;/code&gt;. It's a zero-width pattern similar to &lt;code&gt;(*SKIP)&lt;/code&gt; , except that when backtracked into on failure it causes the match to fail outright. No further attempts to find a valid match by advancing the start pointer will occur again. For example,</source>
          <target state="translated">这是Perl 6&amp;ldquo;提交模式&amp;rdquo; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 或 &lt;code&gt;:::&lt;/code&gt; 。这是一个零宽度模式，类似于 &lt;code&gt;(*SKIP)&lt;/code&gt; ，除了在失败时回溯到失败时会导致匹配完全失败。不会再发生任何通过提前开始指针来查找有效匹配项的尝试。例如，</target>
        </trans-unit>
        <trans-unit id="6d8e4baf0d85adfeec247ab733be39725f479200" translate="yes" xml:space="preserve">
          <source>This is the Perl patch level, a numeric change identifier, as defined by whichever source code maintenance system is used to maintain the patches; currently Perforce. It does not correlate with the Perl version numbers or the maintenance versus development dichotomy except by also being increasing.</source>
          <target state="translated">这是 Perl 补丁级别,一个数字变化标识符,由任何一个用于维护补丁的源代码维护系统定义,目前是 Perforce。它与Perl版本号或维护与开发的二分法并无关联,除非它也在增加。</target>
        </trans-unit>
        <trans-unit id="c3d3b33b321b373988f93e8459b8ad217922301e" translate="yes" xml:space="preserve">
          <source>This is the Raku &quot;commit pattern&quot; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; or &lt;code&gt;:::&lt;/code&gt;. It's a zero-width pattern similar to &lt;code&gt;(*SKIP)&lt;/code&gt;, except that when backtracked into on failure it causes the match to fail outright. No further attempts to find a valid match by advancing the start pointer will occur again. For example,</source>
          <target state="translated">这是Raku的&amp;ldquo;提交模式&amp;rdquo; &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 或 &lt;code&gt;:::&lt;/code&gt; 。这是一种零宽度模式，类似于 &lt;code&gt;(*SKIP)&lt;/code&gt; ，除了在失败时回溯到失败时，它会导致匹配完全失败。不会再发生任何通过提前开始指针来查找有效匹配项的尝试。例如，</target>
        </trans-unit>
        <trans-unit id="0eaf16c26ce67bf186071a739f6615eb11610fd4" translate="yes" xml:space="preserve">
          <source>This is the SV to be matched against. Note that the actual char array to be matched against is supplied by the arguments described below; the SV is just used to determine UTF8ness, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; etc.</source>
          <target state="translated">这是要匹配的SV。注意，要匹配的实际char数组由下面描述的参数提供；SV仅用于确定UTF8ness， &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="7c286f6393bbad06af797d961790dd4c263ab5cd" translate="yes" xml:space="preserve">
          <source>This is the SV to be matched against. Note that the actual char array to be matched against is supplied by the arguments described below; the SV is just used to determine UTF8ness, &lt;code&gt;pos()&lt;/code&gt; etc.</source>
          <target state="translated">这是要匹配的SV。注意，要匹配的实际char数组由下面描述的参数提供；SV仅用于确定UTF8ness， &lt;code&gt;pos()&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="4d720b4f15a9201913736e953c720d9b63d81ea0" translate="yes" xml:space="preserve">
          <source>This is the Unicode-aware way of saying</source>
          <target state="translated">这是Unicode-aware的说法。</target>
        </trans-unit>
        <trans-unit id="455ede6174f3d5161f6c2d4aa6425c94536894ca" translate="yes" xml:space="preserve">
          <source>This is the basic function to generate temporary files. The behaviour of the file can be changed using various options:</source>
          <target state="translated">这是生成临时文件的基本功能。文件的行为可以通过各种选项来改变。</target>
        </trans-unit>
        <trans-unit id="0cdb886cc4c11fb4c044bce1657934ab85d4f9c0" translate="yes" xml:space="preserve">
          <source>This is the central parsing function. It can both append new text and extract objects from the stream accumulated so far (both of these functions are optional).</source>
          <target state="translated">这是核心的解析功能,它既可以追加新的文本,也可以从目前积累的流中提取对象(这两个功能都是可选的)。它既可以追加新的文本,也可以从迄今为止积累的流中提取对象(这两个功能都是可选的)。</target>
        </trans-unit>
        <trans-unit id="a05b57eee11f052b052017c3ff384fae39edc53f" translate="yes" xml:space="preserve">
          <source>This is the command to execute. It may be either a string or an array reference. This is a required argument.</source>
          <target state="translated">这是要执行的命令。它可以是一个字符串或数组引用。这是一个必要的参数。</target>
        </trans-unit>
        <trans-unit id="78880bb496bf709fa9881c622c08f3137e6dd8f7" translate="yes" xml:space="preserve">
          <source>This is the constructor for &lt;b&gt;Pod::Parser&lt;/b&gt; and its subclasses. You</source>
          <target state="translated">这是&lt;b&gt;Pod :: Parser&lt;/b&gt;及其子类的构造函数。您</target>
        </trans-unit>
        <trans-unit id="3d8bf5bd14f4dda830975aad7d7af3e9d034509f" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::FTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an FTP connection is required.</source>
          <target state="translated">这是一个新的Net :: FTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要与FTP连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="d79a978a5e7757a479b9fe30cd0cc290698241af" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::NNTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which a NNTP connection is required. If not given then it may be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If no host is passed then two environment variables are checked, first &lt;code&gt;NNTPSERVER&lt;/code&gt; then &lt;code&gt;NEWSHOST&lt;/code&gt; , then &lt;code&gt;Net::Config&lt;/code&gt; is checked, and if a host is not found then &lt;code&gt;news&lt;/code&gt; is used.</source>
          <target state="translated">这是新的Net :: NNTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要NNTP连接的远程主机的名称。如果未给出，则可以作为下面描述的&amp;ldquo; &lt;code&gt;Host&lt;/code&gt; 选项传递。如果未传递任何主机，则将检查两个环境变量，首先是 &lt;code&gt;NNTPSERVER&lt;/code&gt; ,然后是 &lt;code&gt;NEWSHOST&lt;/code&gt; ，然后是 &lt;code&gt;Net::Config&lt;/code&gt; ，如果没有找到主机，则使用 &lt;code&gt;news&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="269299c73d11a11158c0e7b9fe468441843c9e6e" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::NNTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which a NNTP connection is required. If not given then it may be passed as the &lt;code&gt;Host&lt;/code&gt; option described below. If no host is passed then two environment variables are checked, first &lt;code&gt;NNTPSERVER&lt;/code&gt; then &lt;code&gt;NEWSHOST&lt;/code&gt;, then &lt;code&gt;Net::Config&lt;/code&gt; is checked, and if a host is not found then &lt;code&gt;news&lt;/code&gt; is used.</source>
          <target state="translated">这是新的Net :: NNTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要NNTP连接的远程主机的名称。如果未给出，则可以将其作为下面描述的&amp;ldquo; &lt;code&gt;Host&lt;/code&gt; 选项进行传递。如果没有传递主机，则将检查两个环境变量，首先是 &lt;code&gt;NNTPSERVER&lt;/code&gt; ,然后是 &lt;code&gt;NEWSHOST&lt;/code&gt; ，然后是 &lt;code&gt;Net::Config&lt;/code&gt; ，如果没有找到主机，则使用 &lt;code&gt;news&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a1411000dcca44bd6224ab398773d981b55ca56" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::POP3 object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an POP3 connection is required.</source>
          <target state="translated">这是一个新的Net :: POP3对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要POP3连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="b5e150d75dbb5f649a71e256e018f3d6ee5d68ad" translate="yes" xml:space="preserve">
          <source>This is the constructor for a new Net::SMTP object. &lt;code&gt;HOST&lt;/code&gt; is the name of the remote host to which an SMTP connection is required.</source>
          <target state="translated">这是新的Net :: SMTP对象的构造函数。 &lt;code&gt;HOST&lt;/code&gt; 是需要SMTP连接的远程主机的名称。</target>
        </trans-unit>
        <trans-unit id="3dcdb98a1ad7340bd49db77b64b7ed1e7e6ac7fa" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference of some sort. The reference can be used to hold some internal information.</source>
          <target state="translated">这是该类的构造函数。这意味着它要返回一个某种祝福的引用。这个引用可以用来保存一些内部信息。</target>
        </trans-unit>
        <trans-unit id="7f8efcba15ad2c7fb65b185c0d87e50ef7c7af8b" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new array (probably an anonymous ARRAY ref) will be accessed.</source>
          <target state="translated">这是该类的构造函数。这意味着它将返回一个祝福的引用,通过这个引用来访问新的数组(可能是一个匿名的ARRAY ref)。</target>
        </trans-unit>
        <trans-unit id="4ddd75a12229b0af35fd3f3217e95a18f27831c9" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference through which the new object (probably but not necessarily an anonymous hash) will be accessed.</source>
          <target state="translated">这是该类的构造函数。这意味着它将返回一个受祝福的引用,通过这个引用可以访问新的对象(可能但不一定是匿名哈希)。</target>
        </trans-unit>
        <trans-unit id="c3ca80029525d0505c9c19a25619277e596ad6ff" translate="yes" xml:space="preserve">
          <source>This is the constructor for the class. That means it is expected to return a blessed reference to a new scalar (probably anonymous) that it's creating. For example:</source>
          <target state="translated">这是该类的构造函数。这意味着它要返回一个对它正在创建的新标量(可能是匿名的)的祝福引用。比如说</target>
        </trans-unit>
        <trans-unit id="bb534959b62a2349bc366cafbf3bc4c8d2378f5a" translate="yes" xml:space="preserve">
          <source>This is the current line number being parsed. But you might find the &quot;line_number&quot; event attribute more accurate, when it is present.</source>
          <target state="translated">这是当前被解析的行号。但你可能会发现 &quot;line_number &quot;事件属性更准确,如果它存在的话。</target>
        </trans-unit>
        <trans-unit id="97c7d16dbe44cbd95a833f47b94f50f6214ea17d" translate="yes" xml:space="preserve">
          <source>This is the default code set.</source>
          <target state="translated">这是默认的代码集。</target>
        </trans-unit>
        <trans-unit id="d1c927184ed34249d218ce93282cb8de28d7d8db" translate="yes" xml:space="preserve">
          <source>This is the default compression used when creating a zip file with &lt;code&gt;IO::Compress::Zip&lt;/code&gt;.</source>
          <target state="translated">这是使用 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 创建zip文件时使用的默认压缩方式。</target>
        </trans-unit>
        <trans-unit id="f42f9d3bfdedb4c34f927c70a8b84d5ca486809d" translate="yes" xml:space="preserve">
          <source>This is the default value if none was provided by the user. This is also the type &lt;code&gt;strict_type&lt;/code&gt; will look at when checking type integrity (see below).</source>
          <target state="translated">如果用户未提供默认值，则为默认值。这也是类型类型 &lt;code&gt;strict_type&lt;/code&gt; 在检查类型完整性时将查看的类型（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="3593aaa1ac379bbedb44bf7f659e106e976b3e02" translate="yes" xml:space="preserve">
          <source>This is the default, and fallback concurrency model for &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. This sends events between processes and threads using serialized files in a temporary directory. This is not particularly fast, but it works everywhere.</source>
          <target state="translated">这是&lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;的默认和后备并发模型。这使用临时目录中的序列化文件在进程和线程之间发送事件。这并不是特别快，但是可以在任何地方使用。</target>
        </trans-unit>
        <trans-unit id="60c4aeb1d9a588518e8c401cb7140416c2986e58" translate="yes" xml:space="preserve">
          <source>This is the default. If you can use the</source>
          <target state="translated">这是默认的。如果您可以使用</target>
        </trans-unit>
        <trans-unit id="9aeaae15da033ddcaa17dde6127bab085a00db8b" translate="yes" xml:space="preserve">
          <source>This is the default. If you can use the &lt;a href=&quot;http://man.he.net/man1/mail&quot;&gt;mail(1)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man1/mailx&quot;&gt;mailx(1)&lt;/a&gt; program to send mail from the machine where your code runs, you should be able to use this.</source>
          <target state="translated">这是默认值。如果可以使用&lt;a href=&quot;http://man.he.net/man1/mail&quot;&gt;mail（1）&lt;/a&gt;或&lt;a href=&quot;http://man.he.net/man1/mailx&quot;&gt;mailx（1）&lt;/a&gt;程序从运行代码的计算机上发送邮件，则应该可以使用它。</target>
        </trans-unit>
        <trans-unit id="2b115e2483ec3abaacaac1f9ae2d4e5dce2387c0" translate="yes" xml:space="preserve">
          <source>This is the directory where the .pm and .pod files you wish to have installed go. They are laid out according to namespace. So Foo::Bar is</source>
          <target state="translated">这是你希望安装的.pm和.pod文件所在的目录。它们是根据命名空间排列的。所以 Foo::Bar 是</target>
        </trans-unit>
        <trans-unit id="d930a14451f27529d05daafcbdbe065ab4700f11" translate="yes" xml:space="preserve">
          <source>This is the documentation of version 0.33</source>
          <target state="translated">这是0.33版本的文档</target>
        </trans-unit>
        <trans-unit id="63455dfd4022438ee8d0c0ec5b67774074825e03" translate="yes" xml:space="preserve">
          <source>This is the documentation of version 0.36</source>
          <target state="translated">这是0.36版本的文档</target>
        </trans-unit>
        <trans-unit id="412a728d73be865262b84817f05ddc7c35324cf4" translate="yes" xml:space="preserve">
          <source>This is the easiest way to implement threads, and the way most OSes start. The big disadvantage is that, since the OS knows nothing about threads, if one thread blocks they all do. Typical blocking activities include most system calls, most I/O, and things like &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是实现线程的最简单方法，也是大多数操作系统启动的方法。最大的缺点是，由于OS对线程一无所知，因此如果一个线程阻塞，它们都知道。典型的阻塞活动包括大多数系统调用，大多数I / O以及 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 之类的事情。</target>
        </trans-unit>
        <trans-unit id="9872ff32ffe02aae34e5fe172e65251487064e38" translate="yes" xml:space="preserve">
          <source>This is the easiest way to implement threads, and the way most OSes start. The big disadvantage is that, since the OS knows nothing about threads, if one thread blocks they all do. Typical blocking activities include most system calls, most I/O, and things like &lt;code&gt;sleep()&lt;/code&gt;.</source>
          <target state="translated">这是实现线程的最简单方法，也是大多数操作系统启动的方法。最大的缺点是，由于OS对线程一无所知，因此如果一个线程阻塞，它们都知道。典型的阻塞活动包括大多数系统调用，大多数I / O以及 &lt;code&gt;sleep()&lt;/code&gt; 之类的事情。</target>
        </trans-unit>
        <trans-unit id="9c6f35e7150b834f9f05080f6b4f16bfc1d90561" translate="yes" xml:space="preserve">
          <source>This is the email address that will be sent as your anonymous ftp password.</source>
          <target state="translated">这是将作为您的匿名ftp密码发送的电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="bcbb73b7a51f271a9c7d0f81a71c9c4c6dc5c93f" translate="yes" xml:space="preserve">
          <source>This is the event type that should be used instead of &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; or its legacy subclasses.</source>
          <target state="translated">这是应该使用的事件类型，而不是&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;或其旧式子类。</target>
        </trans-unit>
        <trans-unit id="f70dbb2dc131fafe5c25b23af1ec9a88c86f0b02" translate="yes" xml:space="preserve">
          <source>This is the existing flag. If the lexical warnings pragma is &lt;b&gt;not&lt;/b&gt; used in any of you code, or any of the modules that you use, this flag will enable warnings everywhere. See &lt;a href=&quot;#Backward-Compatibility&quot;&gt;&quot;Backward Compatibility&quot;&lt;/a&gt; for details of how this flag interacts with lexical warnings.</source>
          <target state="translated">这是现有的标志。如果您的任何代码或所用的任何模块中&lt;b&gt;均未&lt;/b&gt;使用词法警告语用说明，则此标志将在各处启用警告。有关此标志如何与词汇警告交互的详细信息，请参见&lt;a href=&quot;#Backward-Compatibility&quot;&gt;&amp;ldquo;向后兼容性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03a8ad8de2657fbb598356bba52fec61dbe4557b" translate="yes" xml:space="preserve">
          <source>This is the existing flag. If the lexical warnings pragma is &lt;b&gt;not&lt;/b&gt; used in any of you code, or any of the modules that you use, this flag will enable warnings everywhere. See &lt;a href=&quot;#Backward-Compatibility&quot;&gt;Backward Compatibility&lt;/a&gt; for details of how this flag interacts with lexical warnings.</source>
          <target state="translated">这是现有的标志。如果您的任何代码或所用的任何模块中&lt;b&gt;均未&lt;/b&gt;使用词法警告语用说明，则此标志将在各处启用警告。有关此标志如何与词汇警告交互的详细信息，请参见&lt;a href=&quot;#Backward-Compatibility&quot;&gt;向后兼容性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb41b10f4355a8511d19503b44266dfd63767081" translate="yes" xml:space="preserve">
          <source>This is the full Uppercase_Mapping property (as opposed to the Simple_Uppercase_Mapping given in the example for format &lt;code&gt;&quot;a&quot;&lt;/code&gt; ). The only difference between the two in the ranges shown is that the code point at 0x0149 (LATIN SMALL LETTER N PRECEDED BY APOSTROPHE) maps to a string of two characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN CAPITAL LETTER N).</source>
          <target state="translated">这是完整的Uppercase_Mapping属性（与示例中格式 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 给出的Simple_Uppercase_Mapping相反）。所显示的范围之间的唯一区别是0x0149的代码点（由APOSTROPHE代替的拉丁小写字母N）映射为两个字符的字符串，即0x02BC（修饰符为APOSTROPHE），后跟0x004E（拉丁文的大写字母N）。</target>
        </trans-unit>
        <trans-unit id="72f4b91716b4ac44d113d86456ec9101d5a53dbe" translate="yes" xml:space="preserve">
          <source>This is the full Uppercase_Mapping property (as opposed to the Simple_Uppercase_Mapping given in the example for format &lt;code&gt;&quot;a&quot;&lt;/code&gt;). The only difference between the two in the ranges shown is that the code point at 0x0149 (LATIN SMALL LETTER N PRECEDED BY APOSTROPHE) maps to a string of two characters, 0x02BC (MODIFIER LETTER APOSTROPHE) followed by 0x004E (LATIN CAPITAL LETTER N).</source>
          <target state="translated">这是完整的Uppercase_Mapping属性（与示例中格式 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 给出的Simple_Uppercase_Mapping相反）。所示范围内的两者之间唯一的区别是，代码点0x0149（由APOSTROPHE前缀的拉丁文小写字母N）映射为两个字符的字符串，即0x02BC（修饰符字母APOSTROPHE），后跟0x004E（拉丁文大写字母N）。</target>
        </trans-unit>
        <trans-unit id="871175ae8bd1e88a96090e3ee5d094a4a3c823c8" translate="yes" xml:space="preserve">
          <source>This is the function that does the real work. It should use the current values of @dl_require_symbols and @dl_resolve_using if required.</source>
          <target state="translated">这个函数才是真正的工作。如果需要的话,它应该使用@dl_require_symbols和@dl_resolve_using的当前值。</target>
        </trans-unit>
        <trans-unit id="9eb27a9f1b9a740c73f748bcbff1be5834650914" translate="yes" xml:space="preserve">
          <source>This is the function used to implement the behaviour of the &lt;code&gt;isa&lt;/code&gt; operator.</source>
          <target state="translated">这是用于实现 &lt;code&gt;isa&lt;/code&gt; 运算符的行为的函数。</target>
        </trans-unit>
        <trans-unit id="0f9cd536958034f18b34b73afd163424db233b70" translate="yes" xml:space="preserve">
          <source>This is the global compile-time. That includes, basically, every &lt;code&gt;BEGIN&lt;/code&gt; block executed directly or indirectly from during the compile-time of the top-level program.</source>
          <target state="translated">这是全局编译时间。基本上，这包括在顶层程序的编译期间直接或间接执行的每个 &lt;code&gt;BEGIN&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="4c737aa4875c95dda5f4201220fe6bfd2cb9c598" translate="yes" xml:space="preserve">
          <source>This is the hardest part of testing, where do you start? People often get overwhelmed at the apparent enormity of the task of testing a whole module. The best place to start is at the beginning. &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; is an object-oriented module, and that means you start by making an object. Test &lt;code&gt;new()&lt;/code&gt;.</source>
          <target state="translated">这是测试中最困难的部分，您从哪里开始？人们常常对测试整个模块的任务看似不堪重负。最好的起点是开始。&lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICal&lt;/a&gt;是一个面向对象的模块，这意味着您首先要制作一个对象。测试 &lt;code&gt;new()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58aad6bdc01b0f3b662abb61313db16d1982e4c1" translate="yes" xml:space="preserve">
          <source>This is the highest UID on the current system that refers to a root UID. This is used to make sure that the temporary directory is owned by a system UID (&lt;code&gt;root&lt;/code&gt;, &lt;code&gt;bin&lt;/code&gt;, &lt;code&gt;sys&lt;/code&gt; etc) rather than simply by root.</source>
          <target state="translated">这是当前系统上引用根UID的最高UID。这用于确保临时目录由系统UID（ &lt;code&gt;root&lt;/code&gt; ， &lt;code&gt;bin&lt;/code&gt; ， &lt;code&gt;sys&lt;/code&gt; 等）拥有，而不是仅由root拥有。</target>
        </trans-unit>
        <trans-unit id="394f7937653a5d479f930b2ee200056fdee9eaa3" translate="yes" xml:space="preserve">
          <source>This is the highest UID on the current system that refers to a root UID. This is used to make sure that the temporary directory is owned by a system UID (C</source>
          <target state="translated">这是当前系统中最高的UID,它指的是一个根UID。用来确定临时目录是由系统UID拥有的(C</target>
        </trans-unit>
        <trans-unit id="6328f4bdaf24cfea2076758e63c586a6679bf323" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">这是实现 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。所述 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e79f6ef07ad6031f8e6ffa40b941fdd24230ba02" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">这是实现 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。所述 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&amp;ldquo;I / O操作员&amp;rdquo;在perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2a5b446b2d0ba2a35085618db8046fb9068c0dc" translate="yes" xml:space="preserve">
          <source>This is the internal function implementing the &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">这是实现 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。所述 &lt;code&gt;&amp;lt;EXPR&amp;gt;&lt;/code&gt; 操作中更详细讨论的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c755425aff2265b37f84fd527f7d77c0d4f14125" translate="yes" xml:space="preserve">
          <source>This is the inverse of the &lt;code&gt;:utf8&lt;/code&gt; layer. It turns off the flag on the layer below so that data read from it is considered to be &quot;octets&quot; i.e. characters in the range 0..255 only. Likewise on output perl will warn if a &quot;wide&quot; character is written to a such a stream.</source>
          <target state="translated">这与 &lt;code&gt;:utf8&lt;/code&gt; 层相反。它关闭了下一层的标志，因此从它读取的数据被认为是&amp;ldquo;八位字节&amp;rdquo;，即仅在0..255范围内的字符。同样，在输出时，如果将&amp;ldquo;宽&amp;rdquo;字符写入这样的流，则perl将发出警告。</target>
        </trans-unit>
        <trans-unit id="c2ddc75f62fd0b93b03c10b2f264c7ad34b8bf3a" translate="yes" xml:space="preserve">
          <source>This is the inverse of the &lt;code&gt;:utf8&lt;/code&gt; pseudo-layer. It turns off the flag on the layer below so that data read from it is considered to be Perl's internal downgraded encoding, thus interpreted as the native single-byte encoding of Latin-1 or EBCDIC. Likewise on output Perl will warn if a &quot;wide&quot; character (a codepoint not in the range 0..255) is written to a such a stream.</source>
          <target state="translated">这与 &lt;code&gt;:utf8&lt;/code&gt; 伪层相反。它关闭了下一层的标志，因此从它读取的数据被认为是Perl的内部降级编码，因此被解释为Latin-1或EBCDIC的本机单字节编码。同样，在输出上，如果将&amp;ldquo;宽&amp;rdquo;字符（代码点不在0..255范围内）写入Perl，则Perl将发出警告。</target>
        </trans-unit>
        <trans-unit id="05a7690a54b93d5cbfbc43460dc86928e9ff4860" translate="yes" xml:space="preserve">
          <source>This is the least computationally expensive strategy. It may require some user education.</source>
          <target state="translated">这是计算成本最低的策略。它可能需要一些用户教育。</target>
        </trans-unit>
        <trans-unit id="6fe99eed7290a54a82a6a3a3aa2c3b4a2bb07743" translate="yes" xml:space="preserve">
          <source>This is the level of HTML &quot;Hn&quot; element to which a Pod &quot;head1&quot; corresponds. For example, if &lt;code&gt;html_h_level&lt;/code&gt; is set to 2, a head1 will produce an H2, a head2 will produce an H3, and so on.</source>
          <target state="translated">这是Pod&amp;ldquo; head1&amp;rdquo;所对应的HTML&amp;ldquo; Hn&amp;rdquo;元素的级别。例如，如果 &lt;code&gt;html_h_level&lt;/code&gt; 设置为2 ，则head1将产生一个H2，head2将产生一个H3，依此类推。</target>
        </trans-unit>
        <trans-unit id="9f1717cb968bcd00575b28e1fe7b7ef5bc2ad1dd" translate="yes" xml:space="preserve">
          <source>This is the list of default @INC.</source>
          <target state="translated">这是默认的@INC列表。</target>
        </trans-unit>
        <trans-unit id="c5030379c7068e58facfd795f2fae683110290cb" translate="yes" xml:space="preserve">
          <source>This is the list of exports that are most commonly needed. If you are simply writing a tool, then this is probably all you need. If you need something and you cannot find it here, then you can also look at &lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&quot;OTHER API EXPORTS&quot;&lt;/a&gt;.</source>
          <target state="translated">这是最需要的出口清单。如果您只是在编写工具，那么这可能就是您所需要的。如果您需要某些东西，但在这里找不到，那么您也可以查看&lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&amp;ldquo; OTHER API EXPORTS&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="230fd1ee1eb1259a3e88a90d402aac49ef4cecd5" translate="yes" xml:space="preserve">
          <source>This is the list of scenarios that break with the new internals.</source>
          <target state="translated">这是新的内部结构打破的方案清单。</target>
        </trans-unit>
        <trans-unit id="dbf2d95bd6e71bbc931d90912ac4916f4a329b66" translate="yes" xml:space="preserve">
          <source>This is the lower layer of the Perl parser, managing characters and tokens.</source>
          <target state="translated">这是Perl解析器的下层,管理字符和标记。</target>
        </trans-unit>
        <trans-unit id="fb63a92bb5be14bd99b74b3769f58dfdcd714a80" translate="yes" xml:space="preserve">
          <source>This is the mechanism that applies the lexical effects of the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma, and the main program scope effects of the &lt;code&gt;io&lt;/code&gt; or &lt;code&gt;D&lt;/code&gt; options for the &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C command-line switch&lt;/a&gt; and &lt;a href=&quot;perlrun#PERL_UNICODE&quot;&gt;PERL_UNICODE environment variable&lt;/a&gt;.</source>
          <target state="translated">这是一种机制，适用于&lt;a href=&quot;open&quot;&gt;开放式&lt;/a&gt;编译指示的词汇效果，以及&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C命令行开关&lt;/a&gt;和&lt;a href=&quot;perlrun#PERL_UNICODE&quot;&gt;PERL_UNICODE环境变量&lt;/a&gt;的 &lt;code&gt;io&lt;/code&gt; 或 &lt;code&gt;D&lt;/code&gt; 选项的主程序作用域效果。</target>
        </trans-unit>
        <trans-unit id="12044b247d0e34184da8c4d82be7f35e7cce2add" translate="yes" xml:space="preserve">
          <source>This is the module that is used as a frontend to the Perl Compiler.</source>
          <target state="translated">这是作为Perl编译器的前端模块。</target>
        </trans-unit>
        <trans-unit id="d48b3bc5add16b69ab6764e7aa4a54509b451c2e" translate="yes" xml:space="preserve">
          <source>This is the most compact form, but it is not well suited for printing or embedding in places that can't handle arbitrary data.</source>
          <target state="translated">这是最紧凑的形式,但它不太适合打印或嵌入到不能处理任意数据的地方。</target>
        </trans-unit>
        <trans-unit id="6f4b6501db089524291430841e3e59e649fd1a7f" translate="yes" xml:space="preserve">
          <source>This is the most important method in Locale::Maketext:</source>
          <target state="translated">这是Locale::Maketext中最重要的方法。</target>
        </trans-unit>
        <trans-unit id="d28b3b2c303cf9fffc3f2cf8865a24397d2fa229" translate="yes" xml:space="preserve">
          <source>This is the most serious problem in Perl 5.20 and earlier. Fixing this required internal changes in Perl 5.22.</source>
          <target state="translated">这是Perl 5.20和更早版本中最严重的问题。要解决这个问题,需要在Perl 5.22中进行内部修改。</target>
        </trans-unit>
        <trans-unit id="cb5f568d5745a8f721d4963249e63f161fe9a2ef" translate="yes" xml:space="preserve">
          <source>This is the name or Internet address of the remote host the server is running on. We could have specified a longer name like &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; , or an address like &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; . For demonstration purposes, we've used the special hostname &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; , which should always mean the current machine you're running on. The corresponding Internet address for localhost is &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; , if you'd rather use that.</source>
          <target state="translated">这是服务器正在运行的远程主机的名称或Internet地址。我们可以指定一个较长的名称，如 &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; ，或如地址 &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; 。出于演示目的，我们使用了特殊的主机名 &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; ，该主机名始终表示您正在运行的当前计算机。如果您愿意使用localhost的对应Internet地址为 &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42e5cc1bbed69994d8e44a1b803efbbc64d1c0d4" translate="yes" xml:space="preserve">
          <source>This is the name or Internet address of the remote host the server is running on. We could have specified a longer name like &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt;, or an address like &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt;. For demonstration purposes, we've used the special hostname &lt;code&gt;&quot;localhost&quot;&lt;/code&gt;, which should always mean the current machine you're running on. The corresponding Internet address for localhost is &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt;, if you'd rather use that.</source>
          <target state="translated">这是服务器在其上运行的远程主机的名称或Internet地址。我们可以指定一个较长的名称，如 &lt;code&gt;&quot;www.perl.com&quot;&lt;/code&gt; ，或如地址 &lt;code&gt;&quot;207.171.7.72&quot;&lt;/code&gt; 。出于演示目的，我们使用了特殊的主机名 &lt;code&gt;&quot;localhost&quot;&lt;/code&gt; ，该主机名始终表示您正在运行的当前计算机。如果您愿意使用localhost的对应Internet地址为 &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d714b1786acd33fab070cc7bfc211af580c75d5" translate="yes" xml:space="preserve">
          <source>This is the namespace for formatters. This is an empty package.</source>
          <target state="translated">这是formatters的命名空间。这是一个空包。</target>
        </trans-unit>
        <trans-unit id="b0d786852f1a6c1dea1d6a765cf9070b49db2732" translate="yes" xml:space="preserve">
          <source>This is the normal entry point for automatic dynamic loading in Perl.</source>
          <target state="translated">这是Perl中自动动态加载的正常切入点。</target>
        </trans-unit>
        <trans-unit id="26340ea40f200c2c1e1dfe6e82669d9feb0fd306" translate="yes" xml:space="preserve">
          <source>This is the normal operation. It translates various literals encountered in the Perl source file from the encoding</source>
          <target state="translated">这是正常的操作。它将Perl源文件中遇到的各种文字从编码中翻译出来。</target>
        </trans-unit>
        <trans-unit id="c846e2c1af2936192fe995d1b6beec9ea4c839cb" translate="yes" xml:space="preserve">
          <source>This is the old form of &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, which has no flags parameter.</source>
          <target state="translated">这是&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&amp;ldquo; gv_fetchmeth_pvn_autoload&amp;rdquo;&lt;/a&gt;的旧形式，没有标志参数。</target>
        </trans-unit>
        <trans-unit id="a889101131356644debee9dab9979e5406fc98f2" translate="yes" xml:space="preserve">
          <source>This is the old form of &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, which has no flags parameter.</source>
          <target state="translated">这是&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;的旧形式，没有flags参数。</target>
        </trans-unit>
        <trans-unit id="230f7f138d64e36f52758c07316eb9c1eee4e053" translate="yes" xml:space="preserve">
          <source>This is the only executable with does not require OS/2.</source>
          <target state="translated">这是唯一不需要OS/2的可执行文件。</target>
        </trans-unit>
        <trans-unit id="46297865ee1d382d368720a50d5f077d38b59862" translate="yes" xml:space="preserve">
          <source>This is the only form of quoting in perl where there is no need to worry about escaping content, something that code generators can and do make good use of.</source>
          <target state="translated">这是perl中唯一一种不用担心内容转义的引用形式,代码生成器可以也确实很好地利用了这一点。</target>
        </trans-unit>
        <trans-unit id="346faabc7115374b4309ef76fa20a9a155ac4597" translate="yes" xml:space="preserve">
          <source>This is the only implementation for which &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; does anything &quot;interesting&quot;.</source>
          <target state="translated">这是 &lt;code&gt;PerlIO_apply_layers()&lt;/code&gt; 进行任何&amp;ldquo;有趣&amp;rdquo;操作的唯一实现。</target>
        </trans-unit>
        <trans-unit id="60f1241a31b62b7745507b52788f2eba7d4fd0c6" translate="yes" xml:space="preserve">
          <source>This is the only way you can create a custom named sequence of code points.</source>
          <target state="translated">这是唯一可以创建一个自定义命名的代码点序列的方法。</target>
        </trans-unit>
        <trans-unit id="78dcaca387707f29d8cc3a2585a362d39b2766bf" translate="yes" xml:space="preserve">
          <source>This is the output when it is executed:</source>
          <target state="translated">这是执行时的输出。</target>
        </trans-unit>
        <trans-unit id="e716423e3a6c7217437c06867a38499b8c6c05ea" translate="yes" xml:space="preserve">
          <source>This is the preferred method of passing input to the constructor.</source>
          <target state="translated">这是向构造函数传递输入的首选方法。</target>
        </trans-unit>
        <trans-unit id="3f3e131dd809784965b27d16458f5818d1df8c11" translate="yes" xml:space="preserve">
          <source>This is the preferred way to get the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object. You should</source>
          <target state="translated">这是获取&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;对象的首选方法。你应该</target>
        </trans-unit>
        <trans-unit id="fcb65586c0c2ac8b0ca9da340eb039802998534b" translate="yes" xml:space="preserve">
          <source>This is the preferred way to get the &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; object. You should</source>
          <target state="translated">这是获取&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;对象的首选方法。你应该</target>
        </trans-unit>
        <trans-unit id="cf4eba93f23876936daa22cc2fcf49ea7ecb8e5d" translate="yes" xml:space="preserve">
          <source>This is the primary function for copying scalars, and most other copy-ish functions and macros use this underneath.</source>
          <target state="translated">这是复制标量的主要函数,其他大多数复制类函数和宏都在下面使用这个函数。</target>
        </trans-unit>
        <trans-unit id="d8fe859ac5bcdefed33ae4b1e5fa108b5fef0c8f" translate="yes" xml:space="preserve">
          <source>This is the primary interface for interacting with &lt;code&gt;File::Temp&lt;/code&gt;. Using the OO interface a temporary file can be created when the object is constructed and the file can be removed when the object is no longer required.</source>
          <target state="translated">这是与 &lt;code&gt;File::Temp&lt;/code&gt; 交互的主要接口。使用OO接口，可以在构造对象时创建一个临时文件，而在不再需要该对象时可以删除该文件。</target>
        </trans-unit>
        <trans-unit id="d281635f40f0f24e55d7183cb71173555b3719a4" translate="yes" xml:space="preserve">
          <source>This is the primary interface for interacting with C&amp;lt;:temp&amp;gt;. Using the OO interface a temporary file can be created when the object is constructed and the file can be removed when the object is no longer required.</source>
          <target state="translated">这是与C &amp;lt;：temp&amp;gt;进行交互的主要接口。使用OO接口，可以在构造对象时创建一个临时文件，而在不再需要该对象时可以删除该文件。</target>
        </trans-unit>
        <trans-unit id="e7186c8d7e458e49979629ada95eb0a97fa3037b" translate="yes" xml:space="preserve">
          <source>This is the primary object described by the</source>
          <target state="translated">这是由</target>
        </trans-unit>
        <trans-unit id="a4f779241fea71e4ea7e971c687ff2b2673775df" translate="yes" xml:space="preserve">
          <source>This is the primary object described by the metadata. In the context of this document it usually refers to a collection of modules, scripts, and/or documents that are distributed together for other developers to use. Examples of distributions are &lt;code&gt;Class-Container&lt;/code&gt;, &lt;code&gt;libwww-perl&lt;/code&gt;, or &lt;code&gt;DBI&lt;/code&gt;.</source>
          <target state="translated">这是元数据描述的主要对象。在本文档的上下文中，它通常是指模块，脚本和/或文档的集合，这些模块，脚本和/或文档一起分发给其他开发人员使用。分发的示例是 &lt;code&gt;Class-Container&lt;/code&gt; ， &lt;code&gt;libwww-perl&lt;/code&gt; 或 &lt;code&gt;DBI&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05f4f2b81da1e7eb80147e0a0e24d6cb8a7b101e" translate="yes" xml:space="preserve">
          <source>This is the purpose of</source>
          <target state="translated">这就是我们的目的。</target>
        </trans-unit>
        <trans-unit id="c0f05eba3f3af5d5e22733e34a51cbbb4cab705c" translate="yes" xml:space="preserve">
          <source>This is the recommended interface for creation of temporary directories. By default the directory will not be removed on exit (that is, it won't be temporary; this behaviour can not be changed because of issues with backwards compatibility). To enable removal either use the CLEANUP option which will trigger removal on program exit, or consider using the &quot;newdir&quot; method in the object interface which will allow the directory to be cleaned up when the object goes out of scope.</source>
          <target state="translated">这是创建临时目录的推荐界面。默认情况下,该目录不会在退出时被删除(也就是说,它不会是临时的;由于向后兼容性的问题,这种行为无法改变)。如果要启用删除,可以使用cleanup选项,它将在程序退出时触发删除,或者考虑使用对象接口中的 &quot;newdir &quot;方法,它将允许在对象超出范围时清理目录。</target>
        </trans-unit>
        <trans-unit id="bd97525cca1b83f38306d58e91365a2fad99fcd5" translate="yes" xml:space="preserve">
          <source>This is the root directory into which the code will be installed. It</source>
          <target state="translated">这是代码将被安装到的根目录。它</target>
        </trans-unit>
        <trans-unit id="ccd5a95520dab502fdf532a36ef8bc1afc084031" translate="yes" xml:space="preserve">
          <source>This is the safest way to write a test tool. The only two downsides to this are a slight performance decrease, and some extra indentation in your source. If the indentation is a problem for you then you can take a peek at the next section.</source>
          <target state="translated">这是写测试工具最安全的方法。唯一的两个缺点是性能略有下降,以及在你的源码中会有一些额外的缩进。如果缩进对你来说是个问题,那么你可以看看下一节。</target>
        </trans-unit>
        <trans-unit id="a624fea38bb2c4a19922a757fc87c2cbf4093ef7" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;'s &lt;code&gt;ok()&lt;/code&gt; routine.</source>
          <target state="translated">这与&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;的 &lt;code&gt;ok()&lt;/code&gt; 例程相同。</target>
        </trans-unit>
        <trans-unit id="bc652aaf1adcdf8a4d8dd86919935233000111ae" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;'s &lt;code&gt;ok()&lt;/code&gt; routine.</source>
          <target state="translated">这与&lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt;的 &lt;code&gt;ok()&lt;/code&gt; 例程相同。</target>
        </trans-unit>
        <trans-unit id="d5cebaac92f671384da0099c3e4a676330931c2e" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;$ipc-&amp;gt;abort($msg)&lt;/code&gt; except that it uses &lt;code&gt;Carp::longmess&lt;/code&gt; to add a stack trace to the message.</source>
          <target state="translated">这与 &lt;code&gt;$ipc-&amp;gt;abort($msg)&lt;/code&gt; 相同，除了它使用 &lt;code&gt;Carp::longmess&lt;/code&gt; 将堆栈跟踪添加到消息中。</target>
        </trans-unit>
        <trans-unit id="c649411547df265abe7a680926ab24280bdd17cc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;FB_QUIET&lt;/code&gt; above, except that instead of being silent on errors, it issues a warning. This is handy for when you are debugging.</source>
          <target state="translated">这与上面的 &lt;code&gt;FB_QUIET&lt;/code&gt; 相同，只是它发出警告而不是对错误保持沉默。这在调试时非常方便。</target>
        </trans-unit>
        <trans-unit id="0ae700aa87900b468f3878348b89397f03c7e04f" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{Blank}&lt;/code&gt; : a character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{Blank}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="eddb21086b3856150972d7a2ffd7db90bf137955" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{Blank}&lt;/code&gt;: a character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{Blank}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="fbc09138370cb171c094bfc6c30b8f2a18097f95" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; : A character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{HorizSpace}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="ebe5b4b519c44b8c20dae3a8295da82dc1226742" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt;: A character that changes the spacing horizontally.</source>
          <target state="translated">这与 &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\p{HorizSpace}&lt;/code&gt; ：一个可水平更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="7b5f883b8c3b129477e8adf6ce3d17842b4509c9" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, including beyond ASCII.</source>
          <target state="translated">这与 &lt;code&gt;\s&lt;/code&gt; 相同，包括ASCII以外的内容。</target>
        </trans-unit>
        <trans-unit id="7e9dbff8b446293a154a68b17c80ce2409d2cfe1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\s&lt;/code&gt;, restricted to ASCII, namely &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; and starting in Perl v5.18, a vertical tab.</source>
          <target state="translated">这与 &lt;code&gt;\s&lt;/code&gt; 相同，仅限于ASCII，即 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 并且从Perl v5.18（垂直标签）开始。</target>
        </trans-unit>
        <trans-unit id="6256409cd33d9cdf7337e20319de658ce6caee15" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\v&lt;/code&gt; : A character that changes the spacing vertically.</source>
          <target state="translated">这与 &lt;code&gt;\v&lt;/code&gt; 相同：垂直更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="e93db47fe41852a54b4800440e60bc3e5fb69deb" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\v&lt;/code&gt;: A character that changes the spacing vertically.</source>
          <target state="translated">这与 &lt;code&gt;\v&lt;/code&gt; 相同：垂直更改间距的字符。</target>
        </trans-unit>
        <trans-unit id="4da601bf04f15ab42ea7eb6f0e3d60619c539d79" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , including over 100_000 characters beyond ASCII.</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，包括超过ASCII的100_000个字符。</target>
        </trans-unit>
        <trans-unit id="f93b7dea9a5c9d0ac4b1d3dcf4d8d34138603086" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt; , restricted to ASCII, namely &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，仅限于ASCII，即 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7aecc4c35f5da4819cdbf90f7c987cd623295b80" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt;, including over 100_000 characters beyond ASCII.</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，包括超过ASCII的100_000个字符。</target>
        </trans-unit>
        <trans-unit id="1b373b07d064d05bea416853d852c54e573ab565" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;\w&lt;/code&gt;, restricted to ASCII, namely &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</source>
          <target state="translated">这与 &lt;code&gt;\w&lt;/code&gt; 相同，仅限于ASCII，即 &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2326d742b2e928e15382460bcb0b3e0deff06c68" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;send_ev2()&lt;/code&gt;, except it builds and returns the event without sending it.</source>
          <target state="translated">这与 &lt;code&gt;send_ev2()&lt;/code&gt; 相同，除了它生成并返回事件而不发送事件。</target>
        </trans-unit>
        <trans-unit id="c9bb59b2ee7dd2d7cbdc8604ab007944c5dcedc3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;send_event()&lt;/code&gt;, except it builds and returns the event without sending it.</source>
          <target state="translated">这与 &lt;code&gt;send_event()&lt;/code&gt; 相同，除了它生成并返回事件而不发送事件。</target>
        </trans-unit>
        <trans-unit id="8213b0c400904773c8fb4aa6534b5c57f7c89c7f" translate="yes" xml:space="preserve">
          <source>This is the same as machine name except that default matches any name. There can be only one default token, and it must be after all machine tokens. This is normally used as:</source>
          <target state="translated">这与机器名称相同,只是默认与任何名称相匹配。默认标记只能有一个,而且必须在所有机器标记之后。这通常被用来作为。</target>
        </trans-unit>
        <trans-unit id="afe36ef7b28dddedb40e25b8fa31da2bc2facf52" translate="yes" xml:space="preserve">
          <source>This is the same as the C function &lt;code&gt;mblen()&lt;/code&gt; on unthreaded perls. On threaded perls, it transparently (almost) substitutes the more thread-safe &lt;a href=&quot;mbrlen(3)&quot;&gt;&lt;code&gt;mbrlen&lt;/code&gt;(3)&lt;/a&gt;, if available, instead of &lt;code&gt;mblen&lt;/code&gt;.</source>
          <target state="translated">这与无线程Perls上的C函数 &lt;code&gt;mblen()&lt;/code&gt; 相同。在线程Perl上，它（几乎）透明地（几乎）替代了线程安全性&lt;a href=&quot;mbrlen(3)&quot;&gt; &lt;code&gt;mbrlen&lt;/code&gt; （3）（&lt;/a&gt;而不是 &lt;code&gt;mblen&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="885914858dff1476d770f30f3747b5d73ce30f3c" translate="yes" xml:space="preserve">
          <source>This is the same as the C function &lt;code&gt;mbtowc()&lt;/code&gt; on unthreaded perls. On threaded perls, it transparently (almost) substitutes the more thread-safe &lt;a href=&quot;mbrtowc(3)&quot;&gt;&lt;code&gt;mbrtowc&lt;/code&gt;(3)&lt;/a&gt;, if available, instead of &lt;code&gt;mbtowc&lt;/code&gt;.</source>
          <target state="translated">这与无线程Perls上的C函数 &lt;code&gt;mbtowc()&lt;/code&gt; 相同。在线程Perl上，它（几乎）透明地（几乎）替代了线程安全性&lt;a href=&quot;mbrtowc(3)&quot;&gt; &lt;code&gt;mbrtowc&lt;/code&gt; （3）（&lt;/a&gt;而不是 &lt;code&gt;mbtowc&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="e368c63bdf4c570ae1b4c310ff27b1113dd7b3e3" translate="yes" xml:space="preserve">
          <source>This is the same as the C function &lt;code&gt;wctomb()&lt;/code&gt; on unthreaded perls. On threaded perls, it transparently (almost) substitutes the more thread-safe &lt;a href=&quot;wcrtomb(3)&quot;&gt;&lt;code&gt;wcrtomb&lt;/code&gt;(3)&lt;/a&gt;, if available, instead of &lt;code&gt;wctomb&lt;/code&gt;.</source>
          <target state="translated">这与无线程Perl上的C函数 &lt;code&gt;wctomb()&lt;/code&gt; 相同。在线程Perl上，它（几乎）透明地（几乎）替代了线程安全性&lt;a href=&quot;wcrtomb(3)&quot;&gt; &lt;code&gt;wcrtomb&lt;/code&gt; （3）（&lt;/a&gt;而不是 &lt;code&gt;wctomb&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="941bd502236d1dea3c975471a03ebbb873d56ae1" translate="yes" xml:space="preserve">
          <source>This is the same as the bin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 bin 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="c486c8726e0003d1e95bb96e015320afb3b6dfa4" translate="yes" xml:space="preserve">
          <source>This is the same as the sitebin variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 sitebin 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="cdc9f1e5725bf6d120b1c425b6dcc03a53feac1e" translate="yes" xml:space="preserve">
          <source>This is the same as the sitescript variable, but is filename expanded at configuration time, for use in your makefiles.</source>
          <target state="translated">这与 sitescript 变量相同,但在配置时扩展了文件名,以便在 makefile 中使用。</target>
        </trans-unit>
        <trans-unit id="43bee717903e4bfa25fa311f06b4356fc3deab92" translate="yes" xml:space="preserve">
          <source>This is the same executable as</source>
          <target state="translated">这是相同的可执行文件,如</target>
        </trans-unit>
        <trans-unit id="3ed82b3d4aecee7f6fc3e2f9453c4cdce17f44ec" translate="yes" xml:space="preserve">
          <source>This is the same facility used by the ANSI_COLORS_ALIASES environment variable (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt; below) but can be used at runtime, not just when the module is loaded.</source>
          <target state="translated">这与ANSI_COLORS_ALIASES环境变量使用的功能相同（请参见下面的&lt;a href=&quot;#ENVIRONMENT&quot;&gt;&amp;ldquo;环境&amp;rdquo;&lt;/a&gt;），但可以在运行时使用，而不仅仅是在加载模块时使用。</target>
        </trans-unit>
        <trans-unit id="9b93eb63da42a6ae191e4cb65dbdf73df302acbd" translate="yes" xml:space="preserve">
          <source>This is the same facility used by the ANSI_COLORS_ALIASES environment variable (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; below) but can be used at runtime, not just when the module is loaded.</source>
          <target state="translated">这与ANSI_COLORS_ALIASES环境变量（请参见下面的&lt;a href=&quot;#ENVIRONMENT&quot;&gt;环境&lt;/a&gt;）使用的功能相同，但可以在运行时使用，而不仅是在加载模块时使用。</target>
        </trans-unit>
        <trans-unit id="08be885869480e470d72f31729368e83f4f891ce" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;P operation&quot; (the name derives from the Dutch word &quot;pak&quot;, which means &quot;capture&quot; -- the semaphore operations were named by the late Dijkstra, who was Dutch).</source>
          <target state="translated">这就是旗语 &quot;P操作&quot;(这个名字来源于荷兰语 &quot;pak&quot;,意思是 &quot;捕获&quot;--旗语操作是由已故荷兰人Dijkstra命名的)。</target>
        </trans-unit>
        <trans-unit id="2f98c90508409620ac27064f1b688373cf5874e7" translate="yes" xml:space="preserve">
          <source>This is the semaphore &quot;V operation&quot; (the name derives from the Dutch word &quot;vrij&quot;, which means &quot;release&quot;).</source>
          <target state="translated">这就是信号灯 &quot;V操作&quot;(这个名字来源于荷兰语 &quot;vrij&quot;,意思是 &quot;释放&quot;)。</target>
        </trans-unit>
        <trans-unit id="a276cc3b822e5fb68d4f30cd1b14facc89497c26" translate="yes" xml:space="preserve">
          <source>This is the service name or port number we'd like to connect to. We could have gotten away with using just &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; on systems with a well-configured system services file,[FOOTNOTE: The system services file is found in</source>
          <target state="translated">这是我们要连接的服务名称或端口号。我们本可以在带有配置良好的系统服务文件的系统上仅使用 &lt;code&gt;&quot;daytime&quot;&lt;/code&gt; ，[注意：系统服务文件位于</target>
        </trans-unit>
        <trans-unit id="55fdeec4b425af4c4fa8e9a6591ac8f8843fb073" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 3166-1, such as 064 for Bhutan. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">这是ISO 3166-1中的一套三位数数字代码,例如不丹的064。这些代码实际上是由联合国统计司定义和维护的。</target>
        </trans-unit>
        <trans-unit id="233002d6fef285c425f811c11a49106685a1ea36" translate="yes" xml:space="preserve">
          <source>This is the set of three-digit numeric codes from ISO 4217.</source>
          <target state="translated">这是一组来自ISO 4217的三位数数字代码。</target>
        </trans-unit>
        <trans-unit id="bfc22c533358da5232ffaf0870e72df120463375" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) bibliographic codes from ISO 639-2 and 639-5, such as 'heb' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">这是一套ISO 639-2和639-5中的三字母(小写)书目代码,例如希伯来文的 &quot;heb&quot;。它还包括IANA语言登记册中对这套编码的补充。</target>
        </trans-unit>
        <trans-unit id="b92c48de1f053f976481719f4f81fdeafd62c023" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) codes from ISO 3166-1, such as 'brb' for Barbados. These codes are actually defined and maintained by the U.N. Statistics division.</source>
          <target state="translated">这是ISO 3166-1中的一组三个字母(小写)的代码,例如巴巴多斯的 &quot;brb&quot;。这些代码实际上是由联合国统计司定义和维护的。</target>
        </trans-unit>
        <trans-unit id="fc3ae49739721f6f95ec3491951800d9f83ab84d" translate="yes" xml:space="preserve">
          <source>This is the set of three-letter (lowercase) terminologic codes from ISO 639.</source>
          <target state="translated">这是ISO 639中的一组三个字母(小写)的术语代码。</target>
        </trans-unit>
        <trans-unit id="e6807d4fe48e31222818be49432ee24ba40f6e11" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 3166-1, such as 'tv' for Tuvalu.</source>
          <target state="translated">这是ISO 3166-1中的一组双字母(小写)代码,如图瓦卢的 &quot;tv&quot;。</target>
        </trans-unit>
        <trans-unit id="acd74dadb16fbf234cd8906af18d327510923daf" translate="yes" xml:space="preserve">
          <source>This is the set of two-letter (lowercase) codes from ISO 639-1, such as 'he' for Hebrew. It also includes additions to this set included in the IANA language registry.</source>
          <target state="translated">这是一套ISO 639-1的双字母(小写)代码,例如希伯来语的 &quot;he&quot;。它还包括IANA语言注册表中对这套代码的补充。</target>
        </trans-unit>
        <trans-unit id="94c349798d0090117d6582dfd31da6381fa814e6" translate="yes" xml:space="preserve">
          <source>This is the standard unix library builder. We use wlib. With Watcom 10.6, when wlib is linked as &quot;ar&quot;, it behaves like ar and all is fine. Under 9.5, a cover is required. One is included in ../qnx</source>
          <target state="translated">这是标准的unix库构建器。我们使用的是wlib。在Watcom 10.6的情况下,当wlib链接为 &quot;ar &quot;时,它的行为就像ar一样,一切正常。在9.5下,需要一个封面。在./qnx中包含了一个。</target>
        </trans-unit>
        <trans-unit id="4298b5ac2d6233992a08de03f4d3419e5f21e00f" translate="yes" xml:space="preserve">
          <source>This is the time string for which the perl binary was compiled. The default value is 0.</source>
          <target state="translated">这是perl二进制文件被编译的时间字符串。默认值是0。</target>
        </trans-unit>
        <trans-unit id="c63d2ff5b62f973d0b02ad27fd22b2f4f908d588" translate="yes" xml:space="preserve">
          <source>This is the true/false value of the test after TODO and similar modifiers are taken into account.</source>
          <target state="translated">这是考虑到TODO和类似修饰词后的测试真/假值。</target>
        </trans-unit>
        <trans-unit id="e58e7a91164b2c61f4741d28ff686a23ffe5c5eb" translate="yes" xml:space="preserve">
          <source>This is the useragent as &lt;code&gt;LWP&lt;/code&gt; will report it.</source>
          <target state="translated">这是用户代理，因为 &lt;code&gt;LWP&lt;/code&gt; 将报告它。</target>
        </trans-unit>
        <trans-unit id="15261bed556ba490ce02abc9f071087b0df0d036" translate="yes" xml:space="preserve">
          <source>This is the version of &lt;code&gt;Test::Harness&lt;/code&gt; .</source>
          <target state="translated">这是 &lt;code&gt;Test::Harness&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="cdc8920fd29fd268d61dc44aa12aa06fb0110f8c" translate="yes" xml:space="preserve">
          <source>This is the version of &lt;code&gt;Test::Harness&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;Test::Harness&lt;/code&gt; 的版本。</target>
        </trans-unit>
        <trans-unit id="6a22ff202852862487c229ecb92eca4a84e51119" translate="yes" xml:space="preserve">
          <source>This is to prevent the problem of one module changing the array base out from under another module inadvertently. See &lt;a href=&quot;perlvar#%24%5b&quot;&gt;$[ in perlvar&lt;/a&gt; and &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;.</source>
          <target state="translated">这是为了防止一个模块无意中将阵列基座从另一个模块下移出的问题。请参阅&lt;a href=&quot;perlvar#%24%5b&quot;&gt;$ [在perlvar&lt;/a&gt;和&lt;a href=&quot;arybase&quot;&gt;arybase中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bd68c145924ef1010d3fbbd465d445886b4ed770" translate="yes" xml:space="preserve">
          <source>This is tremendously more efficient than reading the entire file into memory as an array of lines and then processing it one element at a time, which is often--if not almost always--the wrong approach. Whenever you see someone do this:</source>
          <target state="translated">这比把整个文件作为一个数组读到内存中,然后一次只处理一个元素要高效得多,而后者往往是--如果不是几乎总是--错误的方法。每当你看到有人这样做的时候。</target>
        </trans-unit>
        <trans-unit id="a35e6506a9b88f457b9f4a865f1ac711f7750ab3" translate="yes" xml:space="preserve">
          <source>This is true for all numeric template codes. But don't expect miracles: if the packed value exceeds the allotted byte capacity, high order bits are silently discarded, and unpack certainly won't be able to pull them back out of some magic hat. And, when you pack using a signed template code such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, an excess value may result in the sign bit getting set, and unpacking this will smartly return a negative value.</source>
          <target state="translated">对于所有数字模板代码都是如此。但是不要指望奇迹：如果压缩后的值超过了分配的字节容量，则高阶位会被静默丢弃，并且解压缩肯定无法将其从魔术帽中拉出来。并且，当您使用带符号的模板代码（例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; )打包时，过多的值可能会导致符号位被置位，而将其解压缩将聪明地返回负值。</target>
        </trans-unit>
        <trans-unit id="09f7b7fd23faf4943e83ad191dd610755470b274" translate="yes" xml:space="preserve">
          <source>This is true for all numeric template codes. But don't expect miracles: if the packed value exceeds the allotted byte capacity, high order bits are silently discarded, and unpack certainly won't be able to pull them back out of some magic hat. And, when you pack using a signed template code such as &lt;code&gt;s&lt;/code&gt;, an excess value may result in the sign bit getting set, and unpacking this will smartly return a negative value.</source>
          <target state="translated">对于所有数字模板代码都是如此。但是不要指望奇迹：如果压缩后的值超出了分配的字节容量，则高阶位会被静默丢弃，并且解压缩肯定无法将其从某些魔术帽中拉出来。并且，当您使用带符号的模板代码（例如 &lt;code&gt;s&lt;/code&gt; )打包时，过多的值可能会导致符号位被置位，并且解压缩该包将巧妙地返回负值。</target>
        </trans-unit>
        <trans-unit id="e7272df8729202c7ff033cb7fabd9d5f450b6676" translate="yes" xml:space="preserve">
          <source>This is true on Unix, where &lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; yields &quot;/a/b&quot; and &lt;code&gt;rootdir()&lt;/code&gt; is &quot;/&quot;. Note that &lt;code&gt;rootdir()&lt;/code&gt; on Mac OS is the startup volume, which is the closest in concept to Unix' &quot;/&quot;. This should help to run existing scripts originally written for Unix.</source>
          <target state="translated">在Unix上是这样，其中 &lt;code&gt;catdir(&quot;&quot;,&quot;a&quot;,&quot;b&quot;)&lt;/code&gt; 产生&amp;ldquo; / a / b&amp;rdquo;，而 &lt;code&gt;rootdir()&lt;/code&gt; 是&amp;ldquo; /&amp;rdquo;。请注意，Mac OS上的 &lt;code&gt;rootdir()&lt;/code&gt; 是启动卷，其概念上与Unix'/'最接近。这应该有助于运行最初为Unix编写的现有脚本。</target>
        </trans-unit>
        <trans-unit id="397412f4d7a6d97f2f133b4c7f78e290d9cd2f84" translate="yes" xml:space="preserve">
          <source>This is typically used when testing cannot continue such as a critical module failing to compile or a necessary external utility not being available such as a database connection failing.</source>
          <target state="translated">这通常是在测试无法继续时使用的,比如关键模块无法编译,或者必要的外部工具不可用,比如数据库连接失败。</target>
        </trans-unit>
        <trans-unit id="bb1c3b06955402418f9a1645b31426cf2675075b" translate="yes" xml:space="preserve">
          <source>This is ugly. As of Perl 5.9.2, there's a much nicer way to express your desire for a certain byte-order: the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers. &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier, while &lt;code&gt;&amp;lt;&lt;/code&gt; is the little-endian modifier. Using them, we could rewrite the above code as:</source>
          <target state="translated">这很丑。从Perl 5.9.2开始，有一种更好的方式来表达您对某个字节顺序的渴望： &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符。 &lt;code&gt;&amp;gt;&lt;/code&gt; 是大端修饰符，而 &lt;code&gt;&amp;lt;&lt;/code&gt; 是小端修饰符。使用它们，我们可以将上面的代码重写为：</target>
        </trans-unit>
        <trans-unit id="f64a4511ee072e665d5896089985a46b9305c064" translate="yes" xml:space="preserve">
          <source>This is used (optionally) by configure to list the contents of libraries. I will generate a cover function on the fly in the UU directory.</source>
          <target state="translated">这被configure用来(可选)列出库的内容。我将在UU目录下飞快地生成一个封面函数。</target>
        </trans-unit>
        <trans-unit id="84060e3f0779377a177060ca53204b2049c61bfc" translate="yes" xml:space="preserve">
          <source>This is used by &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; to exit 0 when the plan is 'skip_all'. This is also used by &lt;a href=&quot;Test2::Event:Bail&quot;&gt;Test2::Event:Bail&lt;/a&gt; to force the test to exit with a failure.</source>
          <target state="translated">当计划为'skip_all'时，&lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2 :: Event :: Plan&lt;/a&gt;使用此方法退出0。&lt;a href=&quot;Test2::Event:Bail&quot;&gt;Test2 :: Event：Bail&lt;/a&gt;也使用它来强制测试以失败退出。</target>
        </trans-unit>
        <trans-unit id="e13da45b8fdb5dfbf619cb00d77540e51b9f0de1" translate="yes" xml:space="preserve">
          <source>This is used by Perl itself only for accessing operating system error messages via &lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$!&lt;/a&gt; and &lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$^E&lt;/a&gt;.</source>
          <target state="translated">Perl本身仅将其用于通过&lt;a href=&quot;perlvar#%24ERRNO&quot;&gt;$！&lt;/a&gt;访问操作系统错误消息。和&lt;a href=&quot;perlvar#%24EXTENDED_OS_ERROR&quot;&gt;$ ^ E&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f57cc2e0a5e98dad21fe0583032325ceef3e8bcf" translate="yes" xml:space="preserve">
          <source>This is used by XS code that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware to force the locale for category &lt;code&gt;LC_NUMERIC&lt;/code&gt; to be what perl thinks is the current underlying locale. (The perl interpreter could be wrong about what the underlying locale actually is if some C or XS code has called the C library function &lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale(3)&lt;/a&gt; behind its back; calling &lt;a href=&quot;#sync_locale&quot;&gt;&quot;sync_locale&quot;&lt;/a&gt; before calling this macro will update perl's records.)</source>
          <target state="translated">可以 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境的XS代码使用它来强制将类别 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 的语言环境设为perl认为是当前基础语言环境的语言。 （如果某些C或XS代码在其背后调用了C库函数&lt;a href=&quot;http://man.he.net/man3/setlocale&quot;&gt;setlocale（3）&lt;/a&gt;，则Perl解释器可能对底层语言环境实际上是错误的；在调用此宏之前调用&lt;a href=&quot;#sync_locale&quot;&gt;&amp;ldquo; sync_locale&amp;rdquo;&lt;/a&gt;将更新perl的记录。）</target>
        </trans-unit>
        <trans-unit id="685a67efb688fb26fb65af406110717f25e2b745" translate="yes" xml:space="preserve">
          <source>This is used by XS code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware to force the locale for category &lt;code&gt;LC_NUMERIC&lt;/code&gt; to be what perl thinks is the current underlying locale. (The perl interpreter could be wrong about what the underlying locale actually is if some C or XS code has called the C library function</source>
          <target state="translated">XS代码使用此代码，它是 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境感知的，以强制类别 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 的语言环境成为perl认为是当前基础语言环境的语言。（如果某些C或XS代码调用了C库函数，则Perl解释器可能会误解基本语言环境的实际含义。</target>
        </trans-unit>
        <trans-unit id="6e065e9419827f7c0624c9591e7e2d9d64727710" translate="yes" xml:space="preserve">
          <source>This is used by perl to run external commands which explicitly require shell, like the commands using</source>
          <target state="translated">这被perl用来运行明确需要shell的外部命令,比如使用</target>
        </trans-unit>
        <trans-unit id="64698930b8cfe161fa438c57b55293be0ad5eced" translate="yes" xml:space="preserve">
          <source>This is used by the &lt;code&gt;perldoc&lt;/code&gt; program (see &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;), and may be used to generate HTML documentation usable by WWW browsers, and documentation in zillions of other formats: &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;LaTeX&lt;/code&gt; , &lt;code&gt;Acrobat&lt;/code&gt; , &lt;code&gt;FrameMaker&lt;/code&gt; and so on. [Use programs such as</source>
          <target state="translated">这由 &lt;code&gt;perldoc&lt;/code&gt; 程序使用（请参阅&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;），并且可以用于生成可供WWW浏览器使用的HTML文档以及成千上万种其他格式的文档： &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;LaTeX&lt;/code&gt; ， &lt;code&gt;Acrobat&lt;/code&gt; ， &lt;code&gt;FrameMaker&lt;/code&gt; 等。[使用诸如</target>
        </trans-unit>
        <trans-unit id="8b79fef1f877d1a8e263ce2050957470f7956ed4" translate="yes" xml:space="preserve">
          <source>This is used by the &lt;code&gt;perldoc&lt;/code&gt; program (see &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;), and may be used to generate HTML documentation usable by WWW browsers, and documentation in zillions of other formats: &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;LaTeX&lt;/code&gt;, &lt;code&gt;Acrobat&lt;/code&gt;, &lt;code&gt;FrameMaker&lt;/code&gt; and so on. [Use programs such as</source>
          <target state="translated">这由 &lt;code&gt;perldoc&lt;/code&gt; 程序使用（请参阅&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;），并且可以用于生成WWW浏览器可用的HTML文档以及成千上万种其他格式的文档： &lt;code&gt;info&lt;/code&gt; ， &lt;code&gt;LaTeX&lt;/code&gt; ， &lt;code&gt;Acrobat&lt;/code&gt; ， &lt;code&gt;FrameMaker&lt;/code&gt; 等。[使用诸如</target>
        </trans-unit>
        <trans-unit id="f691385e53ced861147f8d8eef50471ec380ca35" translate="yes" xml:space="preserve">
          <source>This is used for instance by &lt;a href=&quot;Math::BigInt::Constant&quot;&gt;Math::BigInt::Constant&lt;/a&gt;.</source>
          <target state="translated">例如，&lt;a href=&quot;Math::BigInt::Constant&quot;&gt;Math :: BigInt :: Constant使用它&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="938e99644f7869851b92cffce88c437cad0e1198" translate="yes" xml:space="preserve">
          <source>This is used for instance by &lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math::BigInt::Constant&lt;/a&gt;.</source>
          <target state="translated">例如，&lt;a href=&quot;http://search.cpan.org/perldoc/Math::BigInt::Constant&quot;&gt;Math :: BigInt :: Constant使用它&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89a92812a074e6032ec40db97f0e02dae0db9d29" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;FILE *&lt;/code&gt; structures.</source>
          <target state="translated">这用于使用 &lt;code&gt;FILE *&lt;/code&gt; 结构将perl文件句柄与C之间传递。</target>
        </trans-unit>
        <trans-unit id="e990faa3bfbeb576a41b956da185db53775fca9a" translate="yes" xml:space="preserve">
          <source>This is used for passing perl filehandles to and from C using &lt;code&gt;PerlIO *&lt;/code&gt; structures. The file handle can used for reading and writing. This corresponds to the &lt;code&gt;+&amp;lt;&lt;/code&gt; mode, see also T_IN and T_OUT.</source>
          <target state="translated">这用于使用 &lt;code&gt;PerlIO *&lt;/code&gt; 结构将perl文件句柄与C 传递。文件句柄可用于读取和写入。这对应于 &lt;code&gt;+&amp;lt;&lt;/code&gt; 模式，另请参见T_IN和T_OUT。</target>
        </trans-unit>
        <trans-unit id="45afb2cb863a986ba92ff0947755735a5e6d66a7" translate="yes" xml:space="preserve">
          <source>This is used for tests that under some conditions can be skipped. It's basically equivalent to:</source>
          <target state="translated">这个用于某些条件下可以跳过的测试。它基本等同于。</target>
        </trans-unit>
        <trans-unit id="9e0a9f53f8706ee02f00b4b66258c8d781bdebc5" translate="yes" xml:space="preserve">
          <source>This is used heavily by Configure and then by perl itself. QNX4's version is fine, but Configure will choke on the 16-bit version, so if you are running QNX 4.22, link /bin/sh to /bin32/ksh</source>
          <target state="translated">Configure 和 perl 本身都会大量使用这个功能。QNX4 的版本没问题,但配置会对 16 位版本造成阻碍,因此,如果运行 QNX 4.22,请将 /bin/sh 链接到 /bin32/ksh。</target>
        </trans-unit>
        <trans-unit id="b07dd7d6e8aff5833887dd70ddcb6745a582ec73" translate="yes" xml:space="preserve">
          <source>This is used in conjunction with one of the macros &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; and &lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt; to properly restore the &lt;code&gt;LC_NUMERIC&lt;/code&gt; state.</source>
          <target state="translated">它与宏&lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&amp;ldquo; STORE_LC_NUMERIC_SET_TO_NEEDED&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&amp;ldquo; STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&amp;rdquo;&lt;/a&gt;之一结合使用以正确恢复 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 状态。</target>
        </trans-unit>
        <trans-unit id="88552389c076b1697dd901849fcd278da90bf901" translate="yes" xml:space="preserve">
          <source>This is used in conjunction with one of the macros &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt; and &lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt;</source>
          <target state="translated">与宏&lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;STORE_LC_NUMERIC_SET_TO_NEEDED&lt;/a&gt;和&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&lt;/a&gt;之一结合使用</target>
        </trans-unit>
        <trans-unit id="a76c37bf4c1019b528db2eb84815660835ecca3f" translate="yes" xml:space="preserve">
          <source>This is used internally by various sv-modifying functions, such as &lt;code&gt;sv_setsv&lt;/code&gt;, &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_pvn_force&lt;/code&gt;.</source>
          <target state="translated">各种sv修改功能在内部使用此功能，例如 &lt;code&gt;sv_setsv&lt;/code&gt; ， &lt;code&gt;sv_setiv&lt;/code&gt; 和 &lt;code&gt;sv_pvn_force&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51b114b6070b2dbbb4c5faa25f40aadc4f1bf209" translate="yes" xml:space="preserve">
          <source>This is used internally by various sv-modifying functions, such as sv_setsv, sv_setiv and sv_pvn_force.</source>
          <target state="translated">这在内部被各种sv修改函数使用,比如sv_etssv、sv_setiv和sv_pvn_force。</target>
        </trans-unit>
        <trans-unit id="493fa4c255c75476c5de3398d669dcb7143cfa2b" translate="yes" xml:space="preserve">
          <source>This is used to alert the driver that a hub is no longer accepting events. The driver should keep track of the process and thread ids, the hub should only be dropped by the proc+thread that started it (This is the drivers responsibility to enforce).</source>
          <target state="translated">这是用来提醒驱动者某个中心不再接受事件。驱动程序应该跟踪进程和线程的id,集线器应该只被启动它的proc+线程放弃(这是驱动程序的责任)。</target>
        </trans-unit>
        <trans-unit id="7cfc92a05bf403630dcc4ad4521b54e6866a1941" translate="yes" xml:space="preserve">
          <source>This is used to alert the driver that a new hub is expecting events. The driver should keep track of the process and thread ids, the hub should only be dropped by the proc+thread that started it.</source>
          <target state="translated">这是用来提醒驱动,一个新的集线器正在期待事件的发生。驱动程序应该跟踪进程和线程id,集线器应该只被启动它的proc+线程放弃。</target>
        </trans-unit>
        <trans-unit id="2674017b922020ed58a1ae38d38243bb158c698b" translate="yes" xml:space="preserve">
          <source>This is used to convert the perl argument list to a C array and for pushing the contents of a C array onto the perl argument stack.</source>
          <target state="translated">它用于将perl参数列表转换为C数组,并将C数组的内容推送到perl参数栈中。</target>
        </trans-unit>
        <trans-unit id="d0f5557ac77d434ebd595a2a1706e59ef7b222ff" translate="yes" xml:space="preserve">
          <source>This is used to efficiently decide if the next few bytes in &lt;code&gt;s&lt;/code&gt; is legal Unicode-acceptable UTF-8 for a single character.</source>
          <target state="translated">这用于有效地确定 &lt;code&gt;s&lt;/code&gt; 中的下几个字节对于单个字符是否是合法的Unicode可接受的UTF-8。</target>
        </trans-unit>
        <trans-unit id="3d7b5e8f4a478685a6595ee53579e42a7ad93748" translate="yes" xml:space="preserve">
          <source>This is used to encapsulate diag messages created inside TODO.</source>
          <target state="translated">这用于封装在TODO内创建的diag消息。</target>
        </trans-unit>
        <trans-unit id="2b83bcfe3741aa8ea6cddc6c13968e1de17cd570" translate="yes" xml:space="preserve">
          <source>This is used to help wrap XS or C code that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware. This locale category is generally kept set to a locale where the decimal radix character is a dot, and the separator between groups of digits is empty. This is because most XS code that reads floating point numbers is expecting them to have this syntax.</source>
          <target state="translated">这用于帮助包装 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境感知的XS或C代码。通常将此语言环境类别设置为一个十进制基数字符为点且数字组之间的分隔符为空的语言环境。这是因为大多数读取浮点数的XS代码都希望它们具有此语法。</target>
        </trans-unit>
        <trans-unit id="1dfca62a32b70d4bff67e06bed578f950673ab61" translate="yes" xml:space="preserve">
          <source>This is used to help wrap XS or C code that that is &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale-aware. This locale category is generally kept set to the C locale by Perl for backwards compatibility, and because most XS code that reads floating point values can cope only with the decimal radix character being a dot.</source>
          <target state="translated">这用于帮助包装 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境感知的XS或C代码。为了向后兼容，Perl将此语言环境类别通常设置为C语言环境，因为大多数读取浮点值的XS代码只能应付十进制基数点。</target>
        </trans-unit>
        <trans-unit id="27a198e65c924e429ea7fa75dae5924d31fa6b88" translate="yes" xml:space="preserve">
          <source>This is used to prevent the use of &lt;code&gt;caller()&lt;/code&gt; in END blocks which can cause segfaults. This is only necessary in some persistent environments that may have multiple END phases.</source>
          <target state="translated">这用于防止在END块中使用 &lt;code&gt;caller()&lt;/code&gt; ，而这可能导致段错误。仅在某些可能具有多个END阶段的持久性环境中才需要这样做。</target>
        </trans-unit>
        <trans-unit id="61ffe3ce8492ad29999613fc31942e00c100ad7a" translate="yes" xml:space="preserve">
          <source>This is used to set the build type to debug or release. Change the build type only after executing SetNWBld.bat</source>
          <target state="translated">这用于将构建类型设置为调试或发布。只有在执行SetNWBld.bat后,才能更改构建类型。</target>
        </trans-unit>
        <trans-unit id="d4db27a76c75ff7fc1ed3957a4bdf992bfb4169e" translate="yes" xml:space="preserve">
          <source>This is used to toggle Test2's belief that the END phase has already started. With no arguments this will set it to true. With arguments it will set it to the first argument's value.</source>
          <target state="translated">这用于切换Test2认为END阶段已经开始的信念。在没有参数的情况下,它会将其设置为true,在有参数的情况下,它会将其设置为第一个参数的值。有参数的情况下,会将其设置为第一个参数的值。</target>
        </trans-unit>
        <trans-unit id="33295dd981a7660fbc204da5e0a0ad1772d342a0" translate="yes" xml:space="preserve">
          <source>This is used to track which tests unexpectedly succeeded.</source>
          <target state="translated">这是用来跟踪哪些测试意外成功的。</target>
        </trans-unit>
        <trans-unit id="717574ff9403ecd69bea9a30328bf1a90f831842" translate="yes" xml:space="preserve">
          <source>This is used to write code for styles of operating system. See os_flavor_is() for use.</source>
          <target state="translated">这是用来编写操作系统风格的代码。使用方法参见os_flavor_is()。</target>
        </trans-unit>
        <trans-unit id="92dd601445cafa868ebbffa5406795a7efb88b1a" translate="yes" xml:space="preserve">
          <source>This is useful for applying names to anonymous CODE references so that stack traces and similar situations, to give a useful name rather than having the default of &lt;code&gt;__ANON__&lt;/code&gt;. Note that this name is only used for this situation; the &lt;code&gt;set_subname&lt;/code&gt; will not install it into the symbol table; you will have to do that yourself if required.</source>
          <target state="translated">这对于将名称应用于匿名CODE引用非常有用，以便堆栈跟踪和类似情况给出有用的名称，而不是使用默认值 &lt;code&gt;__ANON__&lt;/code&gt; 。请注意，此名称仅用于这种情况。该 &lt;code&gt;set_subname&lt;/code&gt; 不会将它安装到符号表; 如果需要，您将必须自己执行此操作。</target>
        </trans-unit>
        <trans-unit id="a64fac67cd72a00814ab828e9c9bd92a6463973e" translate="yes" xml:space="preserve">
          <source>This is useful for code like:</source>
          <target state="translated">这对于像这样的代码很有用。</target>
        </trans-unit>
        <trans-unit id="0a2bc63942e3a80b89ce25e1ac1f8a32f3bda215" translate="yes" xml:space="preserve">
          <source>This is useful for keeping copies of references, but you don't want to prevent the object being DESTROY-ed at its usual time.</source>
          <target state="translated">这对于保存引用的副本是很有用的,但你不想阻止对象在平时被DESTROY-ed。</target>
        </trans-unit>
        <trans-unit id="68748f1b2fdfc815e31f2005d15151ad297531bd" translate="yes" xml:space="preserve">
          <source>This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">如果你不知道一组备选模式中哪一个匹配,这很有用。例如:</target>
        </trans-unit>
        <trans-unit id="24abff8fd9f42596b61820bc8c96b9b877025034" translate="yes" xml:space="preserve">
          <source>This is useful if you want to repeatedly parse JSON objects and want to ignore any trailing data, which means you have to reset the parser after each successful decode.</source>
          <target state="translated">如果你想重复解析JSON对象,并想忽略任何尾部数据,这就很有用,这意味着你必须在每次成功解码后重置解析器。</target>
        </trans-unit>
        <trans-unit id="42a4e9a54829e179cb44fc85ba544f789e1c2e15" translate="yes" xml:space="preserve">
          <source>This is useful if you want to report then some other way than &lt;code&gt;carp&lt;/code&gt; 'ing when the verbose flag is on.</source>
          <target state="translated">如果您要报告详细标志打开时的除 &lt;code&gt;carp&lt;/code&gt; 以外的其他方式，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="153de877b9bc07e9c5b4ac46607a14b4d6c4da2c" translate="yes" xml:space="preserve">
          <source>This is useful if you want to report then some other way than &lt;code&gt;carp&lt;/code&gt;'ing when the verbose flag is on.</source>
          <target state="translated">如果您要报告详细标志打开时的除 &lt;code&gt;carp&lt;/code&gt; 以外的其他方式，这将非常有用。</target>
        </trans-unit>
        <trans-unit id="c9238f80fbc3497eb44d341942c244b6a1f8c7d1" translate="yes" xml:space="preserve">
          <source>This is useful if your JSON texts are not delimited by an outer protocol and you need to know where the JSON text ends.</source>
          <target state="translated">如果你的JSON文本不以外部协议为界,而你又需要知道JSON文本的结尾,这就很有用。</target>
        </trans-unit>
        <trans-unit id="3180e175adf2fd8ff88aab37691cd4b1c546dfea" translate="yes" xml:space="preserve">
          <source>This is useful to avoid a CODE: block for a C function which takes a parameter by reference. Typically, the parameter should be not a pointer type (an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; but not an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;long*&lt;/code&gt; ).</source>
          <target state="translated">对于避免通过引用获取参数的C函数的CODE：块，这很有用。通常，该参数不应为指针类型（ &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; ,而不是 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int*&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;long*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f32da9d6ece9275a31f6ad58e26339b4aa05f9a0" translate="yes" xml:space="preserve">
          <source>This is useful to avoid a CODE: block for a C function which takes a parameter by reference. Typically, the parameter should be not a pointer type (an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; but not an &lt;code&gt;int*&lt;/code&gt; or &lt;code&gt;long*&lt;/code&gt;).</source>
          <target state="translated">对于避免通过引用获取参数的C函数的CODE：块，这很有用。通常，该参数不应为指针类型（ &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;long&lt;/code&gt; ,而不是 &lt;code&gt;int*&lt;/code&gt; 或 &lt;code&gt;long*&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="242135d43e5e5fb3cfd2e2eb4dedd974f1546560" translate="yes" xml:space="preserve">
          <source>This is useful when a fixed-length buffer is being tested for being well-formed UTF-8, but the final few bytes in it don't comprise a full character; that is, it is split somewhere in the middle of the final code point's UTF-8 representation. (Presumably when the buffer is refreshed with the next chunk of data, the new first bytes will complete the partial code point.) This function is used to verify that the final bytes in the current buffer are in fact the legal beginning of some code point, so that if they aren't, the failure can be signalled without having to wait for the next read.</source>
          <target state="translated">当一个固定长度的缓冲区被测试为UTF-8,但最后的几个字节并不包括一个完整的字符,也就是说,它在最后的码点UTF-8表示的中间某处被分割了。(大概当缓冲区用下一个数据块刷新时,新的第一个字节将完成部分码点。)这个函数用来验证当前缓冲区中的最后一个字节是否真的是某个码点的合法开头,如果不是,就可以发出失败信号,而不必等待下一次读取。</target>
        </trans-unit>
        <trans-unit id="9e13765136cecd81d6e3522084679384fb85c0ae" translate="yes" xml:space="preserve">
          <source>This is useful when calculating checksum for files:</source>
          <target state="translated">这在计算文件的校验和时很有用。</target>
        </trans-unit>
        <trans-unit id="7a8a2f33ee6a615c27a87f750d3b6d2a6919cb19" translate="yes" xml:space="preserve">
          <source>This is useful when you want to do the encoding yourself (e.g. when you want to have UTF-16 encoded JSON texts) or when some other layer does the encoding for you (for example, when printing to a terminal using a filehandle that transparently encodes to UTF-8 you certainly do NOT want to UTF-8 encode your data first and have Perl encode it another time).</source>
          <target state="translated">当你想自己进行编码时(例如,当你想对JSON文本进行UTF-16编码时),或者当其他层为你进行编码时(例如,当你使用一个透明编码为UTF-8的文件手柄打印到终端时,你肯定不想先对你的数据进行UTF-8编码,然后让Perl再进行编码),这很有用。</target>
        </trans-unit>
        <trans-unit id="e13be01e22159590b48bf995ac0b3bcde5d745a9" translate="yes" xml:space="preserve">
          <source>This is useful when you want to pass a decoded data structure directly to other serialisers like YAML, Data::MessagePack and so on.</source>
          <target state="translated">当你想把一个解码后的数据结构直接传递给其他serialis,如YAML、Data::MessagePack等时,这个功能非常有用。</target>
        </trans-unit>
        <trans-unit id="acefb224b2e9e2708aa6e9ceef7c0496a9b29d9e" translate="yes" xml:space="preserve">
          <source>This is useful with sockets when you want to tell the other side you're done writing but not done reading, or vice versa. It's also a more insistent form of &lt;code&gt;close&lt;/code&gt; because it also disables the file descriptor in any forked copies in other processes.</source>
          <target state="translated">当您想告诉另一端您已完成编写但尚未完成阅读时，这对套接字很有用，反之亦然。这也是 &lt;code&gt;close&lt;/code&gt; 一种更持久的形式，因为它还会在其他进程的任何分叉副本中禁用文件描述符。</target>
        </trans-unit>
        <trans-unit id="61dbd2c8b8aff05e41e7c5996e136b2e52680ad0" translate="yes" xml:space="preserve">
          <source>This is useful with sockets when you want to tell the other side you're done writing but not done reading, or vice versa. It's also a more insistent form of close because it also disables the file descriptor in any forked copies in other processes.</source>
          <target state="translated">当你想告诉对方你已经写完了,但还没有读完,或者反之亦然时,这对套接字很有用。这也是close的一种更坚持的形式,因为它也会在其他进程的任何分叉副本中禁用文件描述符。</target>
        </trans-unit>
        <trans-unit id="f513c390b6f7958ee20cf98d8560715b5f8df7bb" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_fcntl that &amp;lt;fcntl.h&amp;gt; should be included.</source>
          <target state="translated">在各个位置设置此变量以告诉i_fcntl应该包含&amp;lt;fcntl.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="a219720ed763ff153bf9c4206e6fc4962fcc28fa" translate="yes" xml:space="preserve">
          <source>This is variable gets set in various places to tell i_sys_file that &amp;lt;sys/file.h&amp;gt; should be included.</source>
          <target state="translated">在各个位置设置此变量，以告诉i_sys_file应该包含&amp;lt;sys / file.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="ec63ffae64519c04a43508d9591237b500c83426" translate="yes" xml:space="preserve">
          <source>This is very dangerous to push on a handle using an &lt;code&gt;:encoding&lt;/code&gt; layer, as such a layer assumes to be working with Perl's internal upgraded encoding, so you will likely get a mangled result. Instead use &lt;code&gt;:raw&lt;/code&gt; or &lt;code&gt;:pop&lt;/code&gt; to remove encoding layers.</source>
          <target state="translated">使用 &lt;code&gt;:encoding&lt;/code&gt; 层推入句柄非常危险，因为该层假定与Perl的内部升级编码一起使用，因此您可能会得到错误的结果。而是使用 &lt;code&gt;:raw&lt;/code&gt; 或 &lt;code&gt;:pop&lt;/code&gt; 删除编码层。</target>
        </trans-unit>
        <trans-unit id="ba0989b9613ab7f11b2f2270357953fc855e8dd8" translate="yes" xml:space="preserve">
          <source>This is very dangerous, as you may block forever. It assumes it's going to talk to something like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc(1)&lt;/a&gt; will read a line at a time and output a line at a time. Programs like &lt;a href=&quot;http://man.he.net/man1/sort&quot;&gt;sort(1)&lt;/a&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">这是非常危险的，因为您可能会永远受阻。它假定它将要与&lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc（1）之&lt;/a&gt;类的东西交谈，同时对其进行写入和读取。这大概是安全的，因为您&amp;ldquo;知道&amp;rdquo;诸如&lt;a href=&quot;http://man.he.net/man1/bc&quot;&gt;bc（1）之&lt;/a&gt;类的命令将一次读取一行并一次输出一行。但是，像&lt;a href=&quot;http://man.he.net/man1/sort&quot;&gt;sort（1）&lt;/a&gt;这样的程序会首先读取其整个输入流，因此很容易引起死锁。</target>
        </trans-unit>
        <trans-unit id="c6c48e550cd9137be036063a2bb992fbdc655583" translate="yes" xml:space="preserve">
          <source>This is very dangerous, as you may block forever. It assumes it's going to talk to something like &lt;b&gt;bc&lt;/b&gt;, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like &lt;b&gt;bc&lt;/b&gt; will read a line at a time and output a line at a time. Programs like &lt;b&gt;sort&lt;/b&gt; that read their entire input stream first, however, are quite apt to cause deadlock.</source>
          <target state="translated">这非常危险，因为您可能会永远受阻。它假定它将与&lt;b&gt;bc&lt;/b&gt;之类的对象进行对话，同时对其进行写入和读取。这大概是安全的，因为您&amp;ldquo;知道&amp;rdquo;诸如&lt;b&gt;bc之类的&lt;/b&gt;命令将一次读取一行并一次输出一行。但是，诸如&lt;b&gt;sort之类的&lt;/b&gt;程序会首先读取其整个输入流，因此很容易引起死锁。</target>
        </trans-unit>
        <trans-unit id="4d27e7008a46081de6bf70cf35ea9983d5762e5e" translate="yes" xml:space="preserve">
          <source>This is very similar to &quot;How do I process an entire hash?&quot;, also in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;, but a bit simpler in the common cases.</source>
          <target state="translated">这与&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4中的&lt;/a&gt; &amp;ldquo;如何处理整个散列？&amp;rdquo;非常相似，但在常见情况下要简单一些。</target>
        </trans-unit>
        <trans-unit id="e597cd56d56a437656a2f431e5a405bb225ea80c" translate="yes" xml:space="preserve">
          <source>This is very useful if you insist on taking an array reference as argument for example.</source>
          <target state="translated">例如,如果你坚持使用数组引用作为参数,这就非常有用。</target>
        </trans-unit>
        <trans-unit id="9ecc6a74af1d686f96a51556930a084f0975a2d7" translate="yes" xml:space="preserve">
          <source>This is what APPNOTE.TXT has to say on what should be stored in the zip filename header field.</source>
          <target state="translated">这是APPNOTE.TXT关于应该在zip文件名头栏中存储的内容。</target>
        </trans-unit>
        <trans-unit id="ccdaae868b02e396a128e9209508dfb651981fc3" translate="yes" xml:space="preserve">
          <source>This is what system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;), and</source>
          <target state="translated">这就是system（）（请参阅&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;）， &lt;code&gt;``&lt;/code&gt; （请参阅&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlop中的I / O运算符&lt;/a&gt;）和</target>
        </trans-unit>
        <trans-unit id="2e2119fd8993283ac1f0a47f57b06a54bbb3f262" translate="yes" xml:space="preserve">
          <source>This is what system() (see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;), &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;), and</source>
          <target state="translated">这就是system（）（请参阅&lt;a href=&quot;perlfunc#system&quot;&gt;perlfunc中的&amp;ldquo;系统&amp;rdquo;&lt;/a&gt;）， &lt;code&gt;``&lt;/code&gt; （请参阅&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlop中的&amp;ldquo; I / O操作员&amp;rdquo;&lt;/a&gt;）和</target>
        </trans-unit>
        <trans-unit id="f2eda7d1f80cf3c434dc7a7060222b6c89d945e1" translate="yes" xml:space="preserve">
          <source>This is what takes events and turns them into TAP.</source>
          <target state="translated">这就是把事件变成TAP的原因。</target>
        </trans-unit>
        <trans-unit id="57e5ac17ec3c4ac0ba4b990c6d906bee2bbc734b" translate="yes" xml:space="preserve">
          <source>This is what you really need to know as an XS programmer, of course. When an XSUB returns a pointer to a C structure that pointer is stored in an SV and a reference to that SV is placed on the XSUB stack. So the output from an XSUB which uses something like the T_PTROBJ map might look something like this:</source>
          <target state="translated">当然,这才是作为一个XS程序员真正需要知道的。当XSUB返回一个指向C结构的指针时,这个指针会被存储在SV中,并且SV的引用会被放置在XSUB堆栈中。因此,使用T_PTROBJ映射的XSUB的输出可能是这样的。</target>
        </trans-unit>
        <trans-unit id="4310f6ad3f6095c3049af8ec37cf9d1c7e8bca42" translate="yes" xml:space="preserve">
          <source>This is when the firewall implemented in the kernel (via NAT, or networking address translation), it allows you to hide a complete network behind one IP address. With this firewall no special compiling is needed as you can access hosts directly.</source>
          <target state="translated">这时在内核中实现的防火墙(通过NAT,或网络地址转换),它允许你将一个完整的网络隐藏在一个IP地址后面。有了这种防火墙,不需要特殊的编译,因为你可以直接访问主机。</target>
        </trans-unit>
        <trans-unit id="fb3eba7f97ab07f3173100c09ae1ea0eedcc95ab" translate="yes" xml:space="preserve">
          <source>This is when the firewall machine runs a web server, and to access the outside world, you must do so via that web server. If you set environment variables like http_proxy or ftp_proxy to values beginning with http://, or in your web browser you've proxy information set, then you know you are running behind an http firewall.</source>
          <target state="translated">这时防火墙的机器运行的是一个web服务器,要访问外界,必须通过这个web服务器。如果你将http_proxy或ftp_proxy等环境变量设置为以http://开头的值,或者在你的Web浏览器中设置了代理信息,那么你就知道你是在http防火墙后面运行。</target>
        </trans-unit>
        <trans-unit id="75c3d5cffa21770fa5fe6937e649710847afafb8" translate="yes" xml:space="preserve">
          <source>This is when you see something like:</source>
          <target state="translated">这时你看到的是这样的东西。</target>
        </trans-unit>
        <trans-unit id="7241b1fe1bce66db853a8d9b85416133eff0f6db" translate="yes" xml:space="preserve">
          <source>This is where all events enter the hub for processing.</source>
          <target state="translated">所有的事件都会在这里进入中心进行处理。</target>
        </trans-unit>
        <trans-unit id="837053e5aa9e97ca4eca0f75fa58885b37dbdc1f" translate="yes" xml:space="preserve">
          <source>This is where gotchas and breakages related to the Test2 upgrade are documented. The upgrade causes Test::Builder to defer to Test2 under the hood. This transition is mostly transparent, but there are a few cases that can trip you up.</source>
          <target state="translated">这里记录了与Test2升级相关的小问题和故障。升级会导致 Test::Builder 延迟到 Test2。这个过渡大部分是透明的,但也有一些情况可能会让你陷入困境。</target>
        </trans-unit>
        <trans-unit id="2ad104027af291dcad88bf06901ecbc700b85cc1" translate="yes" xml:space="preserve">
          <source>This is where roles come in. It makes a lot of sense to create a &lt;code&gt;HasOnOffSwitch&lt;/code&gt; role and apply it to both classes. This role would define a known API like providing &lt;code&gt;turn_on()&lt;/code&gt; and &lt;code&gt;turn_off()&lt;/code&gt; methods.</source>
          <target state="translated">这是角色出现的地方。创建 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; 角色并将其应用于两个类都非常有意义。该角色将定义一个已知的API，例如提供 &lt;code&gt;turn_on()&lt;/code&gt; 和 &lt;code&gt;turn_off()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4320c9ea9a75ef79b1c739e5fcf494dc9cfb50f4" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. In this case, the socket handle returned will be connected to a TCP socket, because we want a stream-oriented connection, that is, one that acts pretty much like a plain old file. Not all sockets are this of this type. For example, the UDP protocol can be used to make a datagram socket, used for message-passing.</source>
          <target state="translated">这就是要使用哪种协议。在这种情况下,返回的套接字句柄将连接到一个TCP套接字,因为我们想要的是一个面向流的连接,也就是说,这个套接字的行为很像一个普通的文件。并不是所有的套接字都是这种类型的。例如,UDP协议可以用来做一个数据报套接字,用于消息传递。</target>
        </trans-unit>
        <trans-unit id="30ceb66515d4a53e1d2f25ce989ec733d96ff6db" translate="yes" xml:space="preserve">
          <source>This is which protocol to use. Like our clients, we'll still specify &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; here.</source>
          <target state="translated">这是要使用的协议。与客户一样，我们仍将在此处指定 &lt;code&gt;&quot;tcp&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04d23d996b25b2c2795e313433104ffdca7710c6" translate="yes" xml:space="preserve">
          <source>This is, I hope, a natural term given the implementation, and should avoid connotations that are inherent in earlier uses of &quot;discipline&quot; for things which are rather different.</source>
          <target state="translated">我希望这是一个自然而然的术语,考虑到执行情况,应该避免早先使用 &quot;纪律 &quot;来表示相当不同的事物所固有的内涵。</target>
        </trans-unit>
        <trans-unit id="921e3efa52591567d6779d551efd563ccc94a973" translate="yes" xml:space="preserve">
          <source>This isn't as simple a question as it sounds. There are two parts:</source>
          <target state="translated">这不是一个听起来简单的问题。有两个部分。</target>
        </trans-unit>
        <trans-unit id="c2dda0261888bf6471240acf321fd52c01dc23ec" translate="yes" xml:space="preserve">
          <source>This issues a warning at the frame (filename and line number where errors should be reported).</source>
          <target state="translated">这将在框架处发出警告(应报告错误的文件名和行号)。</target>
        </trans-unit>
        <trans-unit id="033f6ccbcb480bbc0ac7d9079cba07009a6cd094" translate="yes" xml:space="preserve">
          <source>This item specifies the name by which the linker knows the extension, which may be different from the name of the extension itself (for instance, some linkers add an '_' to the name of the extension). If it is not specified, it is derived from the NAME attribute. It is presently used only by OS2 and Win32.</source>
          <target state="translated">这一项指定了链接者知道扩展的名称,它可能与扩展本身的名称不同(例如,有些链接者在扩展的名称中添加'_')。如果它没有被指定,则从NAME属性导出。目前它只被OS2和Win32使用。</target>
        </trans-unit>
        <trans-unit id="d17e4bc352cfe7c72913c884191bd7c2a2036595" translate="yes" xml:space="preserve">
          <source>This key allows for variable weighting of variable collation elements, which are marked with an ASTERISK in the table (NOTE: Many punctuation marks and symbols are variable in</source>
          <target state="translated">这个键可以对可变的整理元素进行可变的加权,这些元素在表格中用ASTERISK标记(注:许多标点符号和符号是可变的在</target>
        </trans-unit>
        <trans-unit id="cb089e180f4d1e1151abdbf8ed66a17ba5f2e56e" translate="yes" xml:space="preserve">
          <source>This key can be used to specify the name of the linker option file (minus the OS-specific extension), if for some reason you do not want to use the default value, which is the last word of the NAME attribute (</source>
          <target state="translated">这个键可以用来指定链接器选项文件的名称(减去操作系统特定的扩展名),如果出于某些原因你不想使用默认值,即NAME属性的最后一个字 (</target>
        </trans-unit>
        <trans-unit id="6dc6a49c5fb309cc8a7f7ab658d2498baeeb643a" translate="yes" xml:space="preserve">
          <source>This keyword allows one to define an INTERFACE using a different way to extract a function pointer from an XSUB. The text which follows this keyword should give the name of macros which would extract/set a function pointer. The extractor macro is given return type, &lt;code&gt;CV*&lt;/code&gt; , and &lt;code&gt;XSANY.any_dptr&lt;/code&gt; for this &lt;code&gt;CV*&lt;/code&gt; . The setter macro is given cv, and the function pointer.</source>
          <target state="translated">此关键字允许使用不同的方法从XSUB提取函数指针来定义接口。该关键字后面的文本应提供将提取/设置函数指针的宏的名称。提取器宏的返回类型为 &lt;code&gt;CV*&lt;/code&gt; ，并且为此 &lt;code&gt;CV*&lt;/code&gt; &lt;code&gt;XSANY.any_dptr&lt;/code&gt; 。给setter宏赋cv和功能指针。</target>
        </trans-unit>
        <trans-unit id="7f48406b453547a477c2699e1f259b5c4ed7e06a" translate="yes" xml:space="preserve">
          <source>This keyword allows one to define an INTERFACE using a different way to extract a function pointer from an XSUB. The text which follows this keyword should give the name of macros which would extract/set a function pointer. The extractor macro is given return type, &lt;code&gt;CV*&lt;/code&gt;, and &lt;code&gt;XSANY.any_dptr&lt;/code&gt; for this &lt;code&gt;CV*&lt;/code&gt;. The setter macro is given cv, and the function pointer.</source>
          <target state="translated">此关键字允许使用不同的方法从XSUB提取函数指针来定义接口。该关键字后面的文本应提供将提取/设置函数指针的宏的名称。提取器宏的返回类型为 &lt;code&gt;CV*&lt;/code&gt; ，并且为此 &lt;code&gt;CV*&lt;/code&gt; &lt;code&gt;XSANY.any_dptr&lt;/code&gt; 。给setter宏赋cv和功能指针。</target>
        </trans-unit>
        <trans-unit id="2eb4e29be94617115ad887f08c53a3d0726b0bcf" translate="yes" xml:space="preserve">
          <source>This keyword can be used to pull other files into the XS module. The other files may have XS code. INCLUDE: can also be used to run a command to generate the XS code to be pulled into the module.</source>
          <target state="translated">这个关键字可以用来将其他文件拉到XS模块中。其他文件可能有XS代码。INCLUDE:也可以用来运行一个命令来生成XS代码,并将其拉到模块中。</target>
        </trans-unit>
        <trans-unit id="7ed11759f14ddd60bb197c65bf243efdd708cc88" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special cleanup procedures before it terminates. When the CLEANUP: keyword is used it must follow any CODE:, or OUTPUT: blocks which are present in the XSUB. The code specified for the cleanup block will be added as the last statements in the XSUB.</source>
          <target state="translated">当XSUB在结束前需要特殊的清理程序时,可以使用这个关键字。当使用CLEANUP:关键字时,它必须跟随XSUB中存在的任何CODE:或OUTPUT:块。为清理块指定的代码将作为XSUB中的最后一条语句加入。</target>
        </trans-unit>
        <trans-unit id="7ea24ab5d7dbe276068f1e0046e6f8d0e31be74b" translate="yes" xml:space="preserve">
          <source>This keyword can be used when an XSUB requires special procedures executed after the C subroutine call is performed. When the POSTCALL: keyword is used it must precede OUTPUT: and CLEANUP: blocks which are present in the XSUB.</source>
          <target state="translated">当XSUB需要在执行C子程序调用后执行特殊程序时,可以使用这个关键字。当使用POSTCALL:关键字时,它必须在XSUB中存在的OUTPUT:和CLEANUP:块之前。</target>
        </trans-unit>
        <trans-unit id="ae2e5d68051ec8479ea84ba54d17bcf4606d62cb" translate="yes" xml:space="preserve">
          <source>This keyword declares the current XSUB as a keeper of the given calling signature. If some text follows this keyword, it is considered as a list of functions which have this signature, and should be attached to the current XSUB.</source>
          <target state="translated">这个关键字声明当前XSUB是给定调用签名的保存者。如果这个关键字后面有一些文本,它被认为是具有这个签名的函数的列表,并且应该附加到当前XSUB。</target>
        </trans-unit>
        <trans-unit id="58666c3be919a203268b54d032b3c1bf1338cbb5" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。请参阅&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。或者，将 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="42d2aecd2684fd64241ade61155e375dd422775d" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;fc&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;fc&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。或者，将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="f176175c36b805a68ac4fb3277c81ce3879ff21b" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。见&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。或者， &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="7248453615df5e8da2ccdbead940326c86edd409" translate="yes" xml:space="preserve">
          <source>This keyword is available only when the &lt;code&gt;&quot;say&quot;&lt;/code&gt; feature is enabled, or when prefixed with &lt;code&gt;CORE::&lt;/code&gt; ; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Alternately, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">仅当启用 &lt;code&gt;&quot;say&quot;&lt;/code&gt; 功能或带有 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，此关键字才可用。见&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。或者， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; 或更高版本包含在当前范围内。</target>
        </trans-unit>
        <trans-unit id="4ef9d8d4891aa770100745063fafba75dd87bbdc" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;../perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;记录了此关键字。</target>
        </trans-unit>
        <trans-unit id="229a0bb1d79c36394d404c5fc720a5812d12707b" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;&quot;Autoloading&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">此关键字记录&lt;a href=&quot;perlsub#Autoloading&quot;&gt;在perlsub的&amp;ldquo;自动加载&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="017edb25f20d66cd7958f76d9e8eba1497b2b334" translate="yes" xml:space="preserve">
          <source>This keyword is documented in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlsub#Autoloading&quot;&gt;在perlsub的自动加载中&lt;/a&gt;记录了此关键字。</target>
        </trans-unit>
        <trans-unit id="f7b17b66d48631c7667c9941d17b69ddf9ef0b49" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">此关键字由 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能启用；有关 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。您还可以通过在其前面加上 &lt;code&gt;CORE::&lt;/code&gt; 来访问它。可替代地，包括 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; V5.10或更高到当前范围。</target>
        </trans-unit>
        <trans-unit id="bcf1ac4839e0d0322a8d99444375f29015dd872d" translate="yes" xml:space="preserve">
          <source>This keyword is enabled by the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature; see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; for more information on &lt;code&gt;&quot;switch&quot;&lt;/code&gt; . You can also access it by prefixing it with &lt;code&gt;CORE::&lt;/code&gt; . Alternatively, include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; or later to the current scope.</source>
          <target state="translated">此关键字由 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能启用；有关 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 更多信息，请参见&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。您还可以通过在其前面加上 &lt;code&gt;CORE::&lt;/code&gt; 来访问它。可替代地，包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; V5.10或更高到当前范围。</target>
        </trans-unit>
        <trans-unit id="fd72e5a6d62fb1267e4d76dc2f0ed5b89e4e353f" translate="yes" xml:space="preserve">
          <source>This keyword is similar to the PROTOTYPES: keyword above but can be used to force &lt;b&gt;xsubpp&lt;/b&gt; to use a specific prototype for the XSUB. This keyword overrides all other prototype options and keywords but affects only the current XSUB. Consult &lt;a href=&quot;perlsub#Prototypes&quot;&gt;&quot;Prototypes&quot; in perlsub&lt;/a&gt; for information about Perl prototypes.</source>
          <target state="translated">此关键字与上面的PROTOTYPES：关键字相似，但可用于强制&lt;b&gt;xsubpp&lt;/b&gt;为XSUB使用特定的原型。该关键字将覆盖所有其他原型选项和关键字，但仅影响当前的XSUB。有关Perl原型的信息，请查阅&lt;a href=&quot;perlsub#Prototypes&quot;&gt;perlsub中的&amp;ldquo;原型&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29762772c48cba2696e2ebbb42e9c2d4888e7318" translate="yes" xml:space="preserve">
          <source>This keyword is similar to the PROTOTYPES: keyword above but can be used to force &lt;b&gt;xsubpp&lt;/b&gt; to use a specific prototype for the XSUB. This keyword overrides all other prototype options and keywords but affects only the current XSUB. Consult &lt;a href=&quot;perlsub#Prototypes&quot;&gt;Prototypes in perlsub&lt;/a&gt; for information about Perl prototypes.</source>
          <target state="translated">此关键字与上面的PROTOTYPES：关键字相似，但可用于强制&lt;b&gt;xsubpp&lt;/b&gt;为XSUB使用特定的原型。该关键字将覆盖所有其他原型选项和关键字，但仅影响当前的XSUB。有关Perl原型的信息，请查阅&lt;a href=&quot;perlsub#Prototypes&quot;&gt;perlsub中的Prototypes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="85b8915eb7407eed5e4863e8fa3af3a2f3aafc0d" translate="yes" xml:space="preserve">
          <source>This keyword is used in more complicated XSUBs which require special handling for the C function. The RETVAL variable is still declared, but it will not be returned unless it is specified in the OUTPUT: section.</source>
          <target state="translated">这个关键字用在比较复杂的XSUB中,需要对C函数进行特殊处理。RETVAL变量仍然被声明,但除非在OUTPUT:部分指定,否则它不会被返回。</target>
        </trans-unit>
        <trans-unit id="aa7963343b84df8b23c604395808970c0e2420a5" translate="yes" xml:space="preserve">
          <source>This keyword makes sense only if &lt;code&gt;RETVAL&lt;/code&gt; is going to be accessed by the user-supplied code. It is especially useful to make a function interface more Perl-like, especially when the C return value is just an error condition indicator. For example,</source>
          <target state="translated">仅当用户提供的代码将访问 &lt;code&gt;RETVAL&lt;/code&gt; 时,此关键字才有意义。使函数接口更像Perl尤其有用，尤其是当C返回值只是错误条件指示符时。例如，</target>
        </trans-unit>
        <trans-unit id="b1b52e23340e03d5e2d9ec935c2b222b8a59f7e3" translate="yes" xml:space="preserve">
          <source>This keyword may be used any time after the first MODULE keyword and should appear on a line by itself. The first blank line after the keyword will terminate the code block.</source>
          <target state="translated">这个关键字可以在第一个MODULE关键字之后的任何时间使用,并且应该单独出现在一行。关键字后的第一个空行将终止该代码块。</target>
        </trans-unit>
        <trans-unit id="8c3c885b0fa12332744123cf10bb6f10b80fe29e" translate="yes" xml:space="preserve">
          <source>This keyword should follow the PACKAGE keyword when used. If PACKAGE is not used then PREFIX should follow the MODULE keyword.</source>
          <target state="translated">当使用PACKAGE关键字时,这个关键字应该跟在PACKAGE关键字后面。如果不使用PACKAGE,那么PREFIX应该跟在MODULE关键字后面。</target>
        </trans-unit>
        <trans-unit id="febcd526951ded918c85fd19d9088e687e73cc02" translate="yes" xml:space="preserve">
          <source>This keyword will normally be used to complement the CODE: keyword. The RETVAL variable is not recognized as an output variable when the CODE: keyword is present. The OUTPUT: keyword is used in this situation to tell the compiler that RETVAL really is an output variable.</source>
          <target state="translated">这个关键字通常用于补充CODE:关键字。当CODE:关键字出现时,RETVAL变量不被识别为输出变量。在这种情况下,OUTPUT:关键字用来告诉编译器RETVAL确实是一个输出变量。</target>
        </trans-unit>
        <trans-unit id="cb6c35b047be04a4c7f82192e6412bfe49f97ba3" translate="yes" xml:space="preserve">
          <source>This last example is purely for purposes of completeness. You should not be trying to mess with the attributes of something in a package that's not your own.</source>
          <target state="translated">最后一个例子纯粹是为了完整的目的。你不应该试图在一个不是你自己的包里搞乱某些东西的属性。</target>
        </trans-unit>
        <trans-unit id="912ca0c2e267a94ac06e924425736641ec8ba084" translate="yes" xml:space="preserve">
          <source>This last example shows the use of this construct to specify an ordinary bracketed character class without additional set operations. Note the white space within it. This is allowed because &lt;code&gt;/xx&lt;/code&gt; is automatically turned on within this construct.</source>
          <target state="translated">最后一个示例显示了如何使用此结构指定普通的带括号的字符类，而无需进行额外的设置操作。注意其中的空白。这是允许的，因为 &lt;code&gt;/xx&lt;/code&gt; 在此结构中自动打开。</target>
        </trans-unit>
        <trans-unit id="862d993f36bd27f44699b4c5102357c5ca816339" translate="yes" xml:space="preserve">
          <source>This last example shows the use of this construct to specify an ordinary bracketed character class without additional set operations. Note the white space within it; &lt;code&gt;/x&lt;/code&gt; is turned on even within bracketed character classes, except you can't have comments inside them. Hence,</source>
          <target state="translated">最后一个示例显示了如何使用此结构指定普通的带括号的字符类，而无需进行额外的设置操作。注意其中的空白； &lt;code&gt;/x&lt;/code&gt; 甚至在带括号的字符类中都已打开，除非您不能在其中添加注释。因此，</target>
        </trans-unit>
        <trans-unit id="9220dfc1805deb030c183292c9d16a65be2d81b4" translate="yes" xml:space="preserve">
          <source>This last example splits &lt;code&gt;$foo&lt;/code&gt; into the first two words and the remainder of the line, and assigns those three fields to &lt;code&gt;$F1&lt;/code&gt; , &lt;code&gt;$F2&lt;/code&gt; , and &lt;code&gt;$Etc&lt;/code&gt; . The conditional is true if any variables were assigned; that is, if the pattern matched.</source>
          <target state="translated">最后一个例子拆分 &lt;code&gt;$foo&lt;/code&gt; 到前两个单词和行的剩余部分，并且这三个领域分配给 &lt;code&gt;$F1&lt;/code&gt; ， &lt;code&gt;$F2&lt;/code&gt; ，和 &lt;code&gt;$Etc&lt;/code&gt; 。如果分配了任何变量，则条件为true；否则为false。也就是说，如果模式匹配。</target>
        </trans-unit>
        <trans-unit id="28beb0fd6f81e4104dcda83e789966269c55d353" translate="yes" xml:space="preserve">
          <source>This last example splits &lt;code&gt;$foo&lt;/code&gt; into the first two words and the remainder of the line, and assigns those three fields to &lt;code&gt;$F1&lt;/code&gt;, &lt;code&gt;$F2&lt;/code&gt;, and &lt;code&gt;$Etc&lt;/code&gt;. The conditional is true if any variables were assigned; that is, if the pattern matched.</source>
          <target state="translated">最后一个例子拆分 &lt;code&gt;$foo&lt;/code&gt; 到前两个单词和行的剩余部分，并且这三个领域分配给 &lt;code&gt;$F1&lt;/code&gt; ， &lt;code&gt;$F2&lt;/code&gt; ，和 &lt;code&gt;$Etc&lt;/code&gt; 。如果分配了任何变量，则条件为true；否则为false。也就是说，如果模式匹配。</target>
        </trans-unit>
        <trans-unit id="b0e7606501a4d8dcdc827582f8772dc7d2f7c727" translate="yes" xml:space="preserve">
          <source>This last one is present only in perl 5.22.0 and higher.</source>
          <target state="translated">最后一个只在perl 5.22.0和更高版本中出现。</target>
        </trans-unit>
        <trans-unit id="71d99570ae143a5a3edf0f9d507ad7328c03cf89" translate="yes" xml:space="preserve">
          <source>This latter is improper because when the &quot;=end outer&quot; command is seen, the currently open region has the formatname &quot;inner&quot;, not &quot;outer&quot;. (It just happens that &quot;outer&quot; is the format name of a higher-up region.) This is an error. Processors must by default report this as an error, and may halt processing the document containing that error. A corollary of this is that regions cannot &quot;overlap&quot;. That is, the latter block above does not represent a region called &quot;outer&quot; which contains X and Y, overlapping a region called &quot;inner&quot; which contains Y and Z. But because it is invalid (as all apparently overlapping regions would be), it doesn't represent that, or anything at all.</source>
          <target state="translated">后者是不恰当的,因为当看到&quot;=end outer &quot;命令时,当前打开的区域的格式名是 &quot;inner&quot;,而不是&quot; outer&quot;。(只是碰巧 &quot;external &quot;是上级区域的格式名。)这是一个错误。处理器默认必须将此报告为错误,并可能停止处理包含该错误的文档。这一点的必然结果是,区域不能 &quot;重叠&quot;。也就是说,上面的后一个块并不代表一个包含X和Y的名为 &quot;外 &quot;的区域,与一个包含Y和Z的名为 &quot;内 &quot;的区域重叠,但因为它是无效的(因为所有明显重叠的区域都会无效),所以它并不代表这个区域,或者根本不代表任何东西。</target>
        </trans-unit>
        <trans-unit id="329baa8ca56fa0cbccaada8dac24e7d11eab4ae6" translate="yes" xml:space="preserve">
          <source>This layer (which actually sets a flag on the preceding layer, and is implicitly set by any &lt;code&gt;:encoding&lt;/code&gt; layer) does not translate or validate byte sequences. It instead indicates that the byte stream will have been arranged by other layers to be provided in Perl's internal upgraded encoding, which Perl code (and correctly written XS code) will interpret as decoded Unicode characters.</source>
          <target state="translated">该层（实际上在前一层设置了一个标志，并且由任何 &lt;code&gt;:encoding&lt;/code&gt; 层隐式设置）不会转换或验证字节序列。相反，它指示字节流将由其他层安排以Perl的内部升级编码提供，Perl代码（和正确编写的XS代码）将解释为解码的Unicode字符。</target>
        </trans-unit>
        <trans-unit id="07d7417365f82f63b9e8e59a7e5f2cdf78946771" translate="yes" xml:space="preserve">
          <source>This layer does &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; operations by mmap()ing the file if possible, but falls back to the default behavior if not.</source>
          <target state="translated">如果可能的话，该层通过mmap（）对文件进行 &lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;write&lt;/code&gt; 操作，但是如果不能，则返回默认行为。</target>
        </trans-unit>
        <trans-unit id="7a8db66183eb60025ea9a2964bbf14f04f11348c" translate="yes" xml:space="preserve">
          <source>This layer provides a PerlIO interface by wrapping system's ANSI C &quot;stdio&quot; library calls. The layer provides both buffering and IO. Note that the &lt;code&gt;:stdio&lt;/code&gt; layer does</source>
          <target state="translated">该层通过包装系统的ANSI C&amp;ldquo; stdio&amp;rdquo;库调用来提供PerlIO接口。该层同时提供缓冲和IO。请注意 &lt;code&gt;:stdio&lt;/code&gt; 层确实</target>
        </trans-unit>
        <trans-unit id="b630c4528c6aff17852e4e3ca55c2d5a2c70831c" translate="yes" xml:space="preserve">
          <source>This leads to the other two differences. Since a single code point is returned, the function can't handle named character sequences, as these are composed of multiple characters (it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for these. And, the code point can be that of any character, even ones that aren't legal under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma,</source>
          <target state="translated">这导致其他两个差异。由于返回了单个代码点，因此该函数无法处理命名的字符序列，因为它们由多个字符组成（对于这些字符，它返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。而且，该代码点可以是任何字符的字符，即使不是合法 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 下的编译指示，</target>
        </trans-unit>
        <trans-unit id="4878f92b6bf138d4cb047d57550f50b02dd06d3b" translate="yes" xml:space="preserve">
          <source>This leads to the other two differences. Since a single code point is returned, the function can't handle named character sequences, as these are composed of multiple characters (it returns &lt;code&gt;undef&lt;/code&gt; for these. And, the code point can be that of any character, even ones that aren't legal under the &lt;code&gt;use bytes&lt;/code&gt; pragma,</source>
          <target state="translated">这导致了另外两个差异。由于返回了单个代码点，因此该函数无法处理命名的字符序列，因为这些字符序列由多个字符组成（对于这些字符序列，它返回 &lt;code&gt;undef&lt;/code&gt; 。而且，该代码点可以是任何字符的字符，即使不是合法 &lt;code&gt;use bytes&lt;/code&gt; 下的编译指示，</target>
        </trans-unit>
        <trans-unit id="d5aa1dc9dac018985cded1aa3e48ced88d449905" translate="yes" xml:space="preserve">
          <source>This lets you build and send a V2 event directly from facets. The event is returned after it is sent.</source>
          <target state="translated">这让你可以直接从facet构建和发送V2事件。事件发送后会被返回。</target>
        </trans-unit>
        <trans-unit id="d2bfaca7128553729771ae3288647f98ec9ca08e" translate="yes" xml:space="preserve">
          <source>This lets you build and send an event of any type. The &lt;code&gt;$Type&lt;/code&gt; argument should be the event package name with &lt;code&gt;Test2::Event::&lt;/code&gt; left off, or a fully qualified package name prefixed with a '+'. The event is returned after it is sent.</source>
          <target state="translated">这使您可以构建和发送任何类型的事件。在 &lt;code&gt;$Type&lt;/code&gt; 参数应与事件包名称 &lt;code&gt;Test2::Event::&lt;/code&gt; 不放过，或用&amp;ldquo;+&amp;rdquo;前缀一个完全合格的包名。发送事件后，将返回该事件。</target>
        </trans-unit>
        <trans-unit id="d60f65e26f1f4e74963a10d1932144990bf5f1a5" translate="yes" xml:space="preserve">
          <source>This lets you override an existing type with your own custom type, or register a completely new type, eg:</source>
          <target state="translated">这让你可以用你自己的自定义类型覆盖现有的类型,或者注册一个全新的类型,例如。</target>
        </trans-unit>
        <trans-unit id="79e5d41dc2a646a1022f4533cf9e2ddc99e2b27f" translate="yes" xml:space="preserve">
          <source>This lets you provide a callback sub that will be called &lt;b&gt;ONLY&lt;/b&gt; if your call to &lt;code&gt;context()&lt;/code&gt; generated a new context. The callback &lt;b&gt;WILL NOT&lt;/b&gt; be called if &lt;code&gt;context()&lt;/code&gt; is returning an existing context. The only argument passed into the callback will be the context object itself.</source>
          <target state="translated">这样，您就可以提供一个回调子，&lt;b&gt;仅&lt;/b&gt;在对 &lt;code&gt;context()&lt;/code&gt; 的调用生成新上下文时才会被调用。如果 &lt;code&gt;context()&lt;/code&gt; 返回一个现有的上下文，则&lt;b&gt;不会&lt;/b&gt;调用该回调。传递给回调的唯一参数将是上下文对象本身。</target>
        </trans-unit>
        <trans-unit id="16fc392b63db228eb7f664add00b8a9c2d85ff42" translate="yes" xml:space="preserve">
          <source>This lets you provide a callback sub that will be called when the context instance is released. This callback will be added to the returned context even if an existing context is returned. If multiple calls to context add callbacks, then all will be called in reverse order when the context is finally released.</source>
          <target state="translated">这让你提供一个回调子,当上下文实例被释放时,它将被调用。即使返回了一个现有的上下文,这个回调也会被添加到返回的上下文中。如果多次调用上下文添加回调,那么当上下文最终被释放时,所有的回调将以相反的顺序被调用。</target>
        </trans-unit>
        <trans-unit id="4cbcd61ebbafca13e92af49c5fcc25ec65159f85" translate="yes" xml:space="preserve">
          <source>This lets you see the order in which the events were sent, unlike &lt;code&gt;intercept { ... }&lt;/code&gt; which only lets you see events as the main hub sees them.</source>
          <target state="translated">这样，您就可以查看事件的发送顺序，而 &lt;code&gt;intercept { ... }&lt;/code&gt; 只能让您在主集线器看到事件的情况下看到事件。</target>
        </trans-unit>
        <trans-unit id="563b80ae5c4cc2c80ac1a748d6ab409b86b5a4b5" translate="yes" xml:space="preserve">
          <source>This lets you send an &lt;a href=&quot;Test2::Event::Fail&quot;&gt;Test2::Event::Fail&lt;/a&gt; event. You may optionally provide a &lt;code&gt;$name&lt;/code&gt; and &lt;code&gt;@diagnostics&lt;/code&gt; messages.</source>
          <target state="translated">这使您可以发送&lt;a href=&quot;Test2::Event::Fail&quot;&gt;Test2 :: Event :: Fail&lt;/a&gt;事件。您可以选择提供 &lt;code&gt;$name&lt;/code&gt; 和 &lt;code&gt;@diagnostics&lt;/code&gt; 消息。</target>
        </trans-unit>
        <trans-unit id="3afaf78f703df78ea1b2a3a94074c1f6af7d070b" translate="yes" xml:space="preserve">
          <source>This level of sophistication puts filtering out of the reach of many programmers.</source>
          <target state="translated">这种复杂程度让很多程序员无法实现过滤。</target>
        </trans-unit>
        <trans-unit id="96b38d379d8ea7799ed19600bd96b2cf3c932e45" translate="yes" xml:space="preserve">
          <source>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">这个库的发布是希望它是有用的,但没有任何保证,甚至没有默示的适销性或适合特定用途的保证。更多细节请参见GNU通用公共许可证。</target>
        </trans-unit>
        <trans-unit id="5235941a62b852074a7c3e9fc51537a52e5be7a3" translate="yes" xml:space="preserve">
          <source>This library is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是免费软件。你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="e845c8ea27e93059361918a289ad292cdfcb8508" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.10.0 or, at your option, any later version of Perl 5 you may have available.</source>
          <target state="translated">这个库是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它,可以是Perl 5.10.0版本,也可以是您可以选择的Perl 5的任何更新版本。</target>
        </trans-unit>
        <trans-unit id="f877037944f8c1888cbf64249275515c89dec317" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.7 or, at your option, any later version of Perl 5 you may have available.</source>
          <target state="translated">这个库是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它,可以是Perl 5.8.7版本,也可以是您可以选择的Perl 5的任何更新版本。</target>
        </trans-unit>
        <trans-unit id="59869bc853c079c70b9f3b6879026f6cde3bb8df" translate="yes" xml:space="preserve">
          <source>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="95bf2cec5fb49eb84ad57753eb4accbc37f2ba0f" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布和/或修改它。</target>
        </trans-unit>
        <trans-unit id="5912c0244d5e6338722acbdad50efbccb8883b11" translate="yes" xml:space="preserve">
          <source>This library is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个库是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="40333c6cc505a0d3e27434bb83dfca9627c9c8f9" translate="yes" xml:space="preserve">
          <source>This library is useful for the &lt;code&gt;find2perl&lt;/code&gt; tool (distributed as part of the App-find2perl CPAN distribution), which when fed,</source>
          <target state="translated">该库对于 &lt;code&gt;find2perl&lt;/code&gt; 工具（作为App-find2perl CPAN发行版的一部分分发）非常有用，该工具在馈入后，</target>
        </trans-unit>
        <trans-unit id="4f410cd597bbeaeb5f199c6d8d09628b5554744f" translate="yes" xml:space="preserve">
          <source>This library is useful for the &lt;code&gt;find2perl&lt;/code&gt; tool, which when fed,</source>
          <target state="translated">该库对于 &lt;code&gt;find2perl&lt;/code&gt; 工具非常有用，该工具在喂入后，</target>
        </trans-unit>
        <trans-unit id="c0bf3b785ab345744e2dfb1b0071fc64c2b599fe" translate="yes" xml:space="preserve">
          <source>This library provides functions for common tasks involving language tags as they are needed in a variety of protocols and applications.</source>
          <target state="translated">该库为涉及语言标签的常见任务提供了功能,因为它们在各种协议和应用中都需要。</target>
        </trans-unit>
        <trans-unit id="f1885a10472534bbc801de451233880b8db2b1d7" translate="yes" xml:space="preserve">
          <source>This library provides stubs for the functions marked as [CORE] in &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt;. See that document for usage information. When any of these functions are called, the full Win32 module is loaded automatically. It is preferred that callers of these functions explicitly &lt;code&gt;use Win32;&lt;/code&gt;.</source>
          <target state="translated">该库提供了&lt;a href=&quot;win32&quot;&gt;Win32中&lt;/a&gt;标记为[CORE]的功能的存根。有关用法信息，请参阅该文档。当调用这些函数中的任何一个时，将自动加载完整的Win32模块。这些函数的调用者最好显式地 &lt;code&gt;use Win32;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c8a7928010093d74c8591010b017561f0beda8e" translate="yes" xml:space="preserve">
          <source>This library provides support for big integer calculations. It is not intended to be used by other modules. Other modules which support the same API (see below) can also be used to support Math::BigInt, like Math::BigInt::GMP and Math::BigInt::Pari.</source>
          <target state="translated">这个库提供对大整数计算的支持。它不打算被其他模块使用。其他支持相同 API 的模块(见下文)也可用于支持 Math::BigInt,如 Math::BigInt::GMP 和 Math::BigInt::Pari。</target>
        </trans-unit>
        <trans-unit id="a3eb497d536b5c644bfd0b5d3e8c9055b4a9a57d" translate="yes" xml:space="preserve">
          <source>This limitation arises from fundamental technical difficulties in cloning and restarting the stacks used by the Perl parser in the middle of a parse.</source>
          <target state="translated">这种限制来自于在解析过程中克隆和重启Perl解析器使用的堆栈的基本技术困难。</target>
        </trans-unit>
        <trans-unit id="5fe79b21d14490122d11b41cbba492989dbd2358" translate="yes" xml:space="preserve">
          <source>This limitation might be removed in a future version of perl.</source>
          <target state="translated">这个限制可能会在未来的perl版本中被删除。</target>
        </trans-unit>
        <trans-unit id="68a6939633ab7f637a699e2abcb07f19152f1003" translate="yes" xml:space="preserve">
          <source>This line is taken from &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; 3.04, and marks it as deprecated beyond Perl 5.16. If you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; in Perl 5.18, for example, and you have used &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;, then you'll get a warning message (the deprecate module looks to see whether the calling module was &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d from a core library directory, and if so, generates a warning), unless you've installed a more recent version of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text::Soundex&lt;/a&gt; from CPAN.</source>
          <target state="translated">该行摘自&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt; 3.04，并将其标记为在Perl 5.16之后不推荐使用。例如，如果您在Perl 5.18中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Text::Soundex&lt;/code&gt; ，并且已使用&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;，则将收到警告消息（不赞成使用的模块将查看调用模块是否从核心库目录中 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd，并且如果是这样，则会生成警告），除非您从CPAN 安装了更新版本的&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Soundex&quot;&gt;Text :: Soundex&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8aa26d9d42b4368a2ea1e0d808d08013501b95e4" translate="yes" xml:space="preserve">
          <source>This list can be extended by either blacklisting additional &quot;known bad&quot; methods, or whitelisting only &quot;known good&quot; methods.</source>
          <target state="translated">这个列表可以通过将额外的 &quot;已知的坏 &quot;方法列入黑名单或只将 &quot;已知的好 &quot;方法列入白名单来扩展。</target>
        </trans-unit>
        <trans-unit id="9d4d9656ee66f6221eea8c2856144cdf8d5022fd" translate="yes" xml:space="preserve">
          <source>This list includes architecture-dependent directories back to version $api_versionstring (e.g. 5.5.640) and architecture-independent directories all the way back to 5.005.</source>
          <target state="translated">这个列表包括了从$api_versionstring版本(如5.5.640)开始的依赖于架构的目录和从5.005开始的不依赖于架构的目录。</target>
        </trans-unit>
        <trans-unit id="2a2fc6936d401079e1014279fe24282359b2ced4" translate="yes" xml:space="preserve">
          <source>This list is in alphabetical order by English name of the language.</source>
          <target state="translated">该列表按语言的英文名称的字母顺序排列。</target>
        </trans-unit>
        <trans-unit id="0eb2c698e22fab613c0295cd186a49d231f78c73" translate="yes" xml:space="preserve">
          <source>This list is not as definitive as it may appear (or be claimed to be in other documentation). For example, &lt;code&gt;&quot;#&quot;&lt;/code&gt; is a metacharacter only when the &lt;code&gt;/x&lt;/code&gt; pattern modifier (described below) is used, and both &lt;code&gt;&quot;}&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt; are metacharacters only when paired with opening &lt;code&gt;&quot;{&quot;&lt;/code&gt; or &lt;code&gt;&quot;[&quot;&lt;/code&gt; respectively; other gotchas apply.</source>
          <target state="translated">该列表并不像它可能显示的那样明确（或声称在其他文档中）。例如，仅当使用 &lt;code&gt;/x&lt;/code&gt; 模式修饰符（如下所述）时， &lt;code&gt;&quot;#&quot;&lt;/code&gt; 才是元字符，仅当分别与 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 成对使用时， &lt;code&gt;&quot;}&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;]&quot;&lt;/code&gt; 才是元字符。其他陷阱。</target>
        </trans-unit>
        <trans-unit id="9439512245a21874bebe9bdb6ca9f21d2c823dcb" translate="yes" xml:space="preserve">
          <source>This list is subject to change, but is quite unlikely to. Each ASCII sequence can be any combination of upper- and lowercase.</source>
          <target state="translated">这个列表可能会改变,但不太可能。每个ASCII序列可以是大写和小写的任意组合。</target>
        </trans-unit>
        <trans-unit id="fbc78c3347e34ef8b4193dfb718a45521c4ab8d4" translate="yes" xml:space="preserve">
          <source>This list of categories is used to produce the same order as the &lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;Perl Functions by Category in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">此类别列表用于产生与&lt;a href=&quot;../perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt;部分中按类别列出的Perl函数的顺序。</target>
        </trans-unit>
        <trans-unit id="08880758fdfe951040b4a3fc486563eceb7ef61e" translate="yes" xml:space="preserve">
          <source>This list of categories is used to produce the same order as the &lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;&quot;Perl Functions by Category&quot; in perlfunc&lt;/a&gt; section.</source>
          <target state="translated">此类别列表用于产生与&lt;a href=&quot;perlfunc#Perl-Functions-by-Category&quot;&gt;perlfunc&lt;/a&gt;部分中&amp;ldquo;按类别的Perl函数&amp;rdquo;相同的顺序。</target>
        </trans-unit>
        <trans-unit id="b0d8392d22aa3f9f1cc5418d2f71d3d9b55240c2" translate="yes" xml:space="preserve">
          <source>This list used to contain :base_io prior to Opcode 1.07.</source>
          <target state="translated">在Opcode 1.07之前,这个列表包含:base_io。</target>
        </trans-unit>
        <trans-unit id="f6d74c66919ae745b2d3650dc11a98193dcd5f79" translate="yes" xml:space="preserve">
          <source>This load time hit can be a problem when startup speed is important, such as with a command-line script or a &quot;plain vanilla&quot; CGI script that must be loaded each time it is executed.</source>
          <target state="translated">当启动速度很重要的时候,比如命令行脚本或每次执行时都必须加载的 &quot;普通的vanilla &quot;CGI脚本,这种加载时间的影响可能是一个问题。</target>
        </trans-unit>
        <trans-unit id="f016e1379d18764668778064a6a84ece9741d1da" translate="yes" xml:space="preserve">
          <source>This logical name must be defined before Perl is started.</source>
          <target state="translated">这个逻辑名称必须在Perl启动之前定义。</target>
        </trans-unit>
        <trans-unit id="2da9ead2fb770925df3e972a0efa2a82cbbd6ec6" translate="yes" xml:space="preserve">
          <source>This looks in the %Lexicon of the language handle $lh and all its superclasses, looking for an entry whose key is the string</source>
          <target state="translated">这将在语言句柄$lh和所有超级类的%Lexicon中寻找一个键为字符串的条目。</target>
        </trans-unit>
        <trans-unit id="6b4001bd2a1ae040dc8e95119817ede264954c05" translate="yes" xml:space="preserve">
          <source>This loses precision, to avoid this use &lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int()&lt;/a&gt; instead.</source>
          <target state="translated">为了避免这种情况，请避免使用&lt;a href=&quot;#as_int()%2fas_number()&quot;&gt;as_int（）&lt;/a&gt;来降低精度。</target>
        </trans-unit>
        <trans-unit id="2cb2a7c80cbcd1bcc850e8fe88a609a4116cf1c4" translate="yes" xml:space="preserve">
          <source>This machine-native collation (which is what you get unless &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
locale&lt;/code&gt; has appeared earlier in the same block) must be used for sorting raw binary data, whereas the locale-dependent collation of the first example is useful for natural text.</source>
          <target state="translated">必须使用这种机器本地排序规则（除非 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 在同一块中更早出现，否则您将获得此结果），用于对原始二进制数据进行排序，而第一个示例的与语言环境有关的排序规则对于自然文本很有用。</target>
        </trans-unit>
        <trans-unit id="ed86d270c34efc62d89708174f71255637599c7d" translate="yes" xml:space="preserve">
          <source>This machine-native collation (which is what you get unless &lt;code&gt;use locale&lt;/code&gt; has appeared earlier in the same block) must be used for sorting raw binary data, whereas the locale-dependent collation of the first example is useful for natural text.</source>
          <target state="translated">这种机器本地排序规则（除非 &lt;code&gt;use locale&lt;/code&gt; 早已出现在同一块中，否则您将获得此排序规则），用于对原始二进制数据进行排序，而第一个示例的与语言环境相关的排序规则对于自然文本很有用。</target>
        </trans-unit>
        <trans-unit id="fe9b1418e4cf2456d34c78acbb912d03460323b0" translate="yes" xml:space="preserve">
          <source>This macro automatically adjusts the stack for you, if needed. Thus, you do not need to call &lt;code&gt;EXTEND&lt;/code&gt; to extend the stack.</source>
          <target state="translated">如果需要，此宏会自动为您调整堆栈。因此，您无需调用 &lt;code&gt;EXTEND&lt;/code&gt; 即可扩展堆栈。</target>
        </trans-unit>
        <trans-unit id="03eb53576978d347f479b9ace06d68ed559f1850" translate="yes" xml:space="preserve">
          <source>This macro evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are from this UTF-8 extension; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="translated">如果该字符串的前几个字节以 &lt;code&gt;s&lt;/code&gt; 开头且看起来不超过 &lt;code&gt;e - 1&lt;/code&gt; 则此宏的结果为非零；该UTF-8扩展名；否则，计算结果为0。如果非零，则该值给出从 &lt;code&gt;s&lt;/code&gt; 开始的多少个字节组成代码点的表示形式。</target>
        </trans-unit>
        <trans-unit id="87701b9dd5d8a0667150a21e302c3f738b0c69c4" translate="yes" xml:space="preserve">
          <source>This macro invokes the supplied statement or block within the context of a &lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; .. &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; pair if required, so eg:</source>
          <target state="translated">如果需要，此宏将在&lt;a href=&quot;#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&amp;ldquo; STORE_LC_NUMERIC_SET_TO_NEEDED&amp;rdquo;&lt;/a&gt; .. &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&amp;ldquo; RESTORE_LC_NUMERIC&amp;rdquo;&lt;/a&gt;对的上下文中调用提供的语句或块，例如：</target>
        </trans-unit>
        <trans-unit id="5a0683190e9b9e040d58492b89f4c05059f16d5d" translate="yes" xml:space="preserve">
          <source>This macro is intended to be used by XS modules where the inputs could be malformed, and it isn't feasible to restructure to use the safer &lt;a href=&quot;#UTF8_SAFE_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_SAFE_SKIP&lt;/code&gt;&quot;&lt;/a&gt;, for example when interfacing with a C library.</source>
          <target state="translated">此&lt;a href=&quot;#UTF8_SAFE_SKIP&quot;&gt; &lt;code&gt;UTF8_SAFE_SKIP&lt;/code&gt; &lt;/a&gt;在供输入格式可能不正确的XS模块使用，并且例如使用C语言库进行重组以使用更安全的&amp;ldquo; UTF8_SAFE_SKIP &amp;rdquo;是不可行的。</target>
        </trans-unit>
        <trans-unit id="bf6c6c2883f7df6e6775b00306eebea28bdde0f9" translate="yes" xml:space="preserve">
          <source>This macro is only used by &lt;code&gt;sv_true()&lt;/code&gt; or its macro equivalent, and only if the latter's argument is neither &lt;code&gt;SvPOK&lt;/code&gt;, &lt;code&gt;SvIOK&lt;/code&gt; nor &lt;code&gt;SvNOK&lt;/code&gt;. It calls &lt;code&gt;sv_2bool_flags&lt;/code&gt; with the &lt;code&gt;SV_GMAGIC&lt;/code&gt; flag.</source>
          <target state="translated">该宏仅由 &lt;code&gt;sv_true()&lt;/code&gt; 或其等效宏使用，并且仅当后者的参数既不是 &lt;code&gt;SvPOK&lt;/code&gt; ， &lt;code&gt;SvIOK&lt;/code&gt; 也不是 &lt;code&gt;SvNOK&lt;/code&gt; 时才使用。它使用 &lt;code&gt;SV_GMAGIC&lt;/code&gt; 标志调用 &lt;code&gt;sv_2bool_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="28984ae179e05c5bf9916303fc08d37c02058ac5" translate="yes" xml:space="preserve">
          <source>This macro is only used by sv_true() or its macro equivalent, and only if the latter's argument is neither SvPOK, SvIOK nor SvNOK. It calls sv_2bool_flags with the SV_GMAGIC flag.</source>
          <target state="translated">这个宏只有sv_true()或其等价的宏才能使用,而且只有当后者的参数既不是SvPOK、SvIOK也不是SvNOK时才能使用。它调用带有SV_GMAGIC标志的sv_2bool_flags。</target>
        </trans-unit>
        <trans-unit id="e69c1ad5fe8e7c0cb76164a9a63b43161810252f" translate="yes" xml:space="preserve">
          <source>This macro is the start of wrapping the C or XS code; the wrap ending is done by calling the &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; macro after the operation. Otherwise the state can be changed that will adversely affect other XS code.</source>
          <target state="translated">这个宏是包装C或XS代码的开始。在操作之后，通过调用&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&amp;ldquo; RESTORE_LC_NUMERIC&amp;rdquo;&lt;/a&gt;宏来完成换行结束。否则，可以更改状态，这会对其他XS代码产生不利影响。</target>
        </trans-unit>
        <trans-unit id="e10545c4894740426ee72f48ac1e29d7b762c0e6" translate="yes" xml:space="preserve">
          <source>This macro is the start of wrapping the C or XS code; the wrap ending is done by calling the &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; macro after the operation. Otherwise the state can be changed that will adversely affect other XS code.</source>
          <target state="translated">这个宏是包装C或XS代码的开始。包装结束是通过在操作后调用&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;宏来完成的。否则，可以更改状态，这会对其他XS代码产生不利影响。</target>
        </trans-unit>
        <trans-unit id="108576184697c52b594b5fe191807eddc07365bd" translate="yes" xml:space="preserve">
          <source>This macro is used to define a unique key to refer to the static data for an XS module. The suggested naming scheme, as used by h2xs, is to use a string that consists of the module name, the string &quot;::_guts&quot; and the module version number.</source>
          <target state="translated">这个宏用来定义一个唯一的键,用来引用XS模块的静态数据。建议使用h2xs使用的命名方式,即使用一个由模块名、字符串&quot;::_guts &quot;和模块版本号组成的字符串。</target>
        </trans-unit>
        <trans-unit id="c6d4c1493bd7a58de9fad441658972687cd16b89" translate="yes" xml:space="preserve">
          <source>This macro makes sure the current &lt;code&gt;LC_NUMERIC&lt;/code&gt; state is set properly, to be aware of locale if the call to the XS or C code from the Perl program is from within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ; or to ignore locale if the call is instead from outside such scope.</source>
          <target state="translated">如果从Perl程序对XS或C代码的调用是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; locale的范围内，则此宏可确保正确设置当前的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 状态，以了解语言环境。或忽略区域设置（如果调用来自该范围之外）。</target>
        </trans-unit>
        <trans-unit id="789676223757b6e3c9adb39d17261f88564cb4ea" translate="yes" xml:space="preserve">
          <source>This macro makes sure the current &lt;code&gt;LC_NUMERIC&lt;/code&gt; state is set properly, to be aware of locale if the call to the XS or C code from the Perl program is from within the scope of a &lt;code&gt;use locale&lt;/code&gt;; or to ignore locale if the call is instead from outside such scope.</source>
          <target state="translated">如果从Perl程序对XS或C代码的调用是在 &lt;code&gt;use locale&lt;/code&gt; 的范围内，则此宏可确保正确设置当前的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 状态，以了解语言环境。或忽略区域设置（如果调用来自该范围之外）。</target>
        </trans-unit>
        <trans-unit id="a92648c32efc9502af17e5ceb0078f95c4ee774c" translate="yes" xml:space="preserve">
          <source>This macro should be used as a statement. It declares a private variable (whose name begins with an underscore) that is needed by the other macros in this section. Failing to include this correctly should lead to a syntax error. For compatibility with C89 C compilers it should be placed in a block before any executable statements.</source>
          <target state="translated">这个宏应该作为一个语句使用。它声明了一个私有变量(其名称以下划线开头),本节中的其他宏需要这个变量。如果不能正确地包含这个宏,应该导致语法错误。为了与C89 C编译器兼容,它应该放在任何可执行语句之前的块中。</target>
        </trans-unit>
        <trans-unit id="b90726f024761758381d53bc05e127149501c3cd" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; return the native VMS exit status instead of emulating the POSIX exit status.</source>
          <target state="translated">这使 &lt;code&gt;$?&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 返回本地VMS退出状态，而不是模拟POSIX退出状态。</target>
        </trans-unit>
        <trans-unit id="628b3f0c435efc68cdba395167206609d25c5fc1" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt; return the native VMS exit status instead of emulating the POSIX exit status.</source>
          <target state="translated">这使 &lt;code&gt;$?&lt;/code&gt; 并且 &lt;code&gt;system&lt;/code&gt; 返回本地VMS退出状态，而不是模拟POSIX退出状态。</target>
        </trans-unit>
        <trans-unit id="8a2c6d4ff2fd838d04decac262a17dd105743f47" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; produce a successful exit (with status SS$_NORMAL), instead of emulating UNIX exit(), which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error. As with the CRTL's exit() function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of SS$_NORMAL, and any other argument to exit() is used directly as Perl's exit status.</source>
          <target state="translated">这使 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 产生一个成功的出口（状态为SS $ _NORMAL），而不是模拟UNIX exit（），后者将 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 视为错误。与CRTL的exit（）函数一样， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 也映射到SS $ _NORMAL的出口状态，而exit（）的任何其他参数直接用作Perl的出口状态。</target>
        </trans-unit>
        <trans-unit id="f530eabe223e1fc114547fb2222672ed10b84b29" translate="yes" xml:space="preserve">
          <source>This makes &lt;code&gt;exit 1&lt;/code&gt; produce a successful exit (with status SS$_NORMAL), instead of emulating UNIX exit(), which considers &lt;code&gt;exit 1&lt;/code&gt; to indicate an error. As with the CRTL's exit() function, &lt;code&gt;exit 0&lt;/code&gt; is also mapped to an exit status of SS$_NORMAL, and any other argument to exit() is used directly as Perl's exit status.</source>
          <target state="translated">这将使 &lt;code&gt;exit 1&lt;/code&gt; 产生成功的出口（状态为SS $ _NORMAL），而不是模拟UNIX exit（），后者将 &lt;code&gt;exit 1&lt;/code&gt; 视为指示错误。与CRTL的exit（）函数一样， &lt;code&gt;exit 0&lt;/code&gt; 也映射到SS $ _NORMAL的出口状态，而exit（）的任何其他参数直接用作Perl的出口状态。</target>
        </trans-unit>
        <trans-unit id="bf2d12c23e7f9dc586004c73bb11c5e4d66c884b" translate="yes" xml:space="preserve">
          <source>This makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) also modifies $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your Math::BigInt objects only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">这将再次引用&lt;b&gt;同一&lt;/b&gt;对象并将其存储在$ y中。因此，修改$ x的所有内容（重载运算符除外）也将修改$ y，反之亦然。换句话说，仅当您仅通过重载数学来修改Math :: BigInt对象时， &lt;code&gt;=&lt;/code&gt; 才是安全的。一旦使用方法调用，它就会中断：</target>
        </trans-unit>
        <trans-unit id="7bf5212d7d68fd2597a5ccb3dac44a0ec0acbc33" translate="yes" xml:space="preserve">
          <source>This makes all times relative to the local time zone, instead of the default of Universal Time (a.k.a Greenwich Mean Time, or GMT).</source>
          <target state="translated">这使得所有的时间都是相对于当地时区的,而不是默认的世界时间(也就是格林威治标准时间,或GMT)。</target>
        </trans-unit>
        <trans-unit id="9babc5bd4d4d8fad4e1a1114788e7c9d9589298f" translate="yes" xml:space="preserve">
          <source>This makes it easy for people to use your module with Perl. Note that this licensing example is neither an endorsement or a requirement, you are of course free to choose any licensing.</source>
          <target state="translated">这使得人们很容易用Perl来使用你的模块。请注意,这个授权例子既不是认可也不是要求,当然你可以自由选择任何授权方式。</target>
        </trans-unit>
        <trans-unit id="f6b677bb7d54149dada8aa52108296cc95f7e885" translate="yes" xml:space="preserve">
          <source>This makes it easy to turn memoizing on and off.</source>
          <target state="translated">这样就可以很方便地开启和关闭备忘录。</target>
        </trans-unit>
        <trans-unit id="84c2faa4aab99c70a3db865e9bc75342b3b56a52" translate="yes" xml:space="preserve">
          <source>This makes it easy to write loops that terminate when a null list is returned:</source>
          <target state="translated">这使得编写循环很容易在返回空列表时终止。</target>
        </trans-unit>
        <trans-unit id="ef9cd0d8fba7947707aa196a6028ecbb8adf2cd7" translate="yes" xml:space="preserve">
          <source>This makes it possible for you to have a single point of configuring what subclasses should be used, which means that in many cases you'll find you only need to sub-class one of the parser's components.</source>
          <target state="translated">这使得你可以在一个点上配置应该使用哪些子类,这意味着在很多情况下,你会发现你只需要对解析器的一个组件进行子类化。</target>
        </trans-unit>
        <trans-unit id="80334a3bb6611cb20a20615249beb172fdbc5b91" translate="yes" xml:space="preserve">
          <source>This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well es preserve accuracy (as in sqrt(3)).</source>
          <target state="translated">这使得它可以混合不同类的参数(如2.5+2)以及保持精度(如sqrt(3))。</target>
        </trans-unit>
        <trans-unit id="304f656ae607b7cf896345e4cfc56ab064cd5820" translate="yes" xml:space="preserve">
          <source>This makes it possible to write a constructor like this:</source>
          <target state="translated">这样就可以写一个这样的构造函数。</target>
        </trans-unit>
        <trans-unit id="fc06c6059d7797b5cf29ed701247a147f4e8dbe0" translate="yes" xml:space="preserve">
          <source>This makes it so that HashBase sees that you have your own &lt;code&gt;new()&lt;/code&gt; method. Alternatively you can define the method before loading HashBase instead of just declaring it, but that scatters your use statements.</source>
          <target state="translated">这样可以使HashBase看到您拥有自己的 &lt;code&gt;new()&lt;/code&gt; 方法。另外，您可以在加载HashBase之前定义方法，而不仅仅是声明它，但这会使您的use语句分散。</target>
        </trans-unit>
        <trans-unit id="08c53718a75ad3b112dec7a9bbaa9b39968746d5" translate="yes" xml:space="preserve">
          <source>This makes sure that &lt;code&gt;foo bar&lt;/code&gt; is treated as a string, rather than two separate arguments to the &lt;code&gt;echo&lt;/code&gt; function.</source>
          <target state="translated">这确保将 &lt;code&gt;foo bar&lt;/code&gt; 视为字符串，而不是 &lt;code&gt;echo&lt;/code&gt; 函数的两个独立参数。</target>
        </trans-unit>
        <trans-unit id="d11f54f9813ffdcb8a603cf0a760fa85bee8c0f3" translate="yes" xml:space="preserve">
          <source>This makes the four standard bitwise operators (&lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ) treat their operands consistently as numbers, and introduces four new dotted operators (&lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ) that treat their operands consistently as strings. The same applies to the assignment variants (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ).</source>
          <target state="translated">这使四个标准按位运算符（ &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ）始终将其操作数视为数字，并引入了四个新的点分运算符（ &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ）将其操作数视为字符串。分配变量也是如此（ &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="453a24b82235c09045ebce781ba5151542428ce9" translate="yes" xml:space="preserve">
          <source>This makes the four standard bitwise operators (&lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt;) treat their operands consistently as numbers, and introduces four new dotted operators (&lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt;) that treat their operands consistently as strings. The same applies to the assignment variants (&lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt;).</source>
          <target state="translated">这使四个标准按位运算符（ &lt;code&gt;&amp;amp; | ^ ~&lt;/code&gt; ）始终将其操作数视为数字，并引入了四个新的点分运算符（ &lt;code&gt;&amp;amp;. |. ^. ~.&lt;/code&gt; ）将其操作数视为字符串。这同样适用于赋值变体（ &lt;code&gt;&amp;amp;= |= ^= &amp;amp;.= |.= ^.=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="168408e4eda2afd55c396c633b53aaec0eb729d4" translate="yes" xml:space="preserve">
          <source>This makes this XSUB look similar to an ANSI C declaration. An optional semicolon is allowed after the argument list, as in</source>
          <target state="translated">这使得这个XSUB看起来类似于ANSI C声明。在参数列表后允许使用分号,如在</target>
        </trans-unit>
        <trans-unit id="2eced7035bcf730659e224115fc20b5232c60142" translate="yes" xml:space="preserve">
          <source>This man page is for the version for modern perls and so that's probably what you've got.</source>
          <target state="translated">这个手册页是针对现代perls的版本,所以这可能是你的问题。</target>
        </trans-unit>
        <trans-unit id="b1f55a347ef2e9626ef51c086b431d8a172c3d1b" translate="yes" xml:space="preserve">
          <source>This manpage contains short recipes demonstrating how to handle common Unicode operations in Perl, plus one complete program at the end. Any undeclared variables in individual recipes are assumed to have a previous appropriate value in them.</source>
          <target state="translated">本手册包含了简短的配方,演示了如何在Perl中处理常见的Unicode操作,最后还有一个完整的程序。任何未声明的变量都会被假定为有一个合适的前值。</target>
        </trans-unit>
        <trans-unit id="aa682f1e123b444504fdfffff8f8767942781c1e" translate="yes" xml:space="preserve">
          <source>This manual page discusses the syntax and use of character classes in Perl regular expressions.</source>
          <target state="translated">本手册页面讨论了Perl正则表达式中字符类的语法和使用。</target>
        </trans-unit>
        <trans-unit id="3369a77e4e9693acaaa9351801ed7f0c5ee8faea" translate="yes" xml:space="preserve">
          <source>This maps from US-ASCII codes (like 32) to the corresponding character (like space, for 32). Only characters 32 to 126 are defined. This is meant for use by &lt;code&gt;e2char($x)&lt;/code&gt; when it senses that it's running on a non-ASCII platform (where chr(32) doesn't get you a space -- but $Code2USASCII{32} will). It's documented here just in case you might find it useful.</source>
          <target state="translated">这从US-ASCII代码（如32）映射到相应的字符（如32的空格）。仅定义了字符32至126。这意味着通过使用 &lt;code&gt;e2char($x)&lt;/code&gt; ，当它感知到它在非ASCII平台上运行（其中CHR（32）不给你一个空间-但$ {Code2USASCII 32}会）。如果您可能会觉得有用，请在此处进行记录。</target>
        </trans-unit>
        <trans-unit id="3b8a1823436e8a6226985b3f21cad0fcc22240a7" translate="yes" xml:space="preserve">
          <source>This marks the end of the region opened by the matching &quot;=begin formatname&quot; region. If &quot;formatname&quot; is not the formatname of the most recent open &quot;=begin formatname&quot; region, then this is an error, and must generate an error message. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3Dbegin%2F%3Dend%22-Regions&quot;&gt;&quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;&lt;/a&gt;.</source>
          <target state="translated">这标记了由匹配的&amp;ldquo; = begin formatname&amp;rdquo;区域打开的区域的末尾。如果&amp;ldquo; formatname&amp;rdquo;不是最近打开的&amp;ldquo; = begin formatname&amp;rdquo;区域的格式名，则这是错误，并且必须生成错误消息。在&lt;a href=&quot;#About-Data-Paragraphs-and-%22%3Dbegin%2F%3Dend%22-Regions&quot;&gt;&amp;ldquo;关于数据段落和&amp;ldquo; = begin / = end&amp;rdquo;区域&amp;rdquo;&lt;/a&gt;部分中对此进行了详细讨论。</target>
        </trans-unit>
        <trans-unit id="cb4d3919cb732684c195097b0bb170a903bf1284" translate="yes" xml:space="preserve">
          <source>This marks the end of the region opened by the matching &quot;=begin formatname&quot; region. If &quot;formatname&quot; is not the formatname of the most recent open &quot;=begin formatname&quot; region, then this is an error, and must generate an error message. This is discussed in detail in the section &lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;About Data Paragraphs and =begin/=end Regions&lt;/a&gt;.</source>
          <target state="translated">这标志着由匹配的&amp;ldquo; = begin formatname&amp;rdquo;区域打开的区域的结尾。如果&amp;ldquo; formatname&amp;rdquo;不是最近打开的&amp;ldquo; = begin formatname&amp;rdquo;区域的格式名，则这是错误，并且必须生成错误消息。&lt;a href=&quot;#About-Data-Paragraphs-and-%22%3dbegin%2f%3dend%22-Regions&quot;&gt;关于数据段落和= begin / = end区域&lt;/a&gt;中将对此进行详细讨论。</target>
        </trans-unit>
        <trans-unit id="5f3eb630ccbc8c1b4b4ea62b60c2f17bbd2e13b1" translate="yes" xml:space="preserve">
          <source>This marks the following paragraphs (until the matching &quot;=end formatname&quot;) as being for some special kind of processing. Unless &quot;formatname&quot; begins with a colon, the contained non-command paragraphs are data paragraphs. But if &quot;formatname&quot;</source>
          <target state="translated">这标志着下面的段落(直到匹配的&quot;=end formatname&quot;)是为了进行某种特殊的处理。除非 &quot;formatname &quot;以冒号开头,否则包含的非命令段落都是数据段落。但如果 &quot;formatname&quot;</target>
        </trans-unit>
        <trans-unit id="199ca4d2282805128a713cd4c31b353ecaf62285" translate="yes" xml:space="preserve">
          <source>This matches a Unicode</source>
          <target state="translated">这与Unicode的</target>
        </trans-unit>
        <trans-unit id="35187fd79ec1edcbf75ff3589e7d7a4fd9384c68" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Grapheme Cluster Boundary&quot;. (Actually Perl always uses the improved &quot;extended&quot; grapheme cluster&quot;). These are explained below under &lt;a href=&quot;#%5CX&quot;&gt;&quot;&lt;code&gt;\X&lt;/code&gt;&quot;&lt;/a&gt;. In fact, &lt;code&gt;\X&lt;/code&gt; is another way to get the same functionality. It is equivalent to &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt;. Use whichever is most convenient for your situation.</source>
          <target state="translated">这与Unicode&amp;ldquo;字形簇边界&amp;rdquo;匹配。（实际上，Perl始终使用改进的&amp;ldquo;扩展&amp;rdquo;字素簇&amp;rdquo;。下面在&lt;a href=&quot;#%5CX&quot;&gt;&amp;ldquo; &lt;code&gt;\X&lt;/code&gt; &amp;rdquo;&lt;/a&gt;下进行了说明。实际上， &lt;code&gt;\X&lt;/code&gt; 是获得相同功能的另一种方法。它等效于 &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; 。请根据您的情况选择最方便的一种。</target>
        </trans-unit>
        <trans-unit id="7a2285705bf65a5f3a4137269fb669e26419a225" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Grapheme Cluster Boundary&quot;. (Actually Perl always uses the improved &quot;extended&quot; grapheme cluster&quot;). These are explained below under &lt;a href=&quot;#%5cX&quot;&gt;\X&lt;/a&gt;. In fact, &lt;code&gt;\X&lt;/code&gt; is another way to get the same functionality. It is equivalent to &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; . Use whichever is most convenient for your situation.</source>
          <target state="translated">这与Unicode&amp;ldquo;字形簇边界&amp;rdquo;匹配。（实际上，Perl始终使用改进的&amp;ldquo;扩展&amp;rdquo;字素簇&amp;rdquo;。下面在&lt;a href=&quot;#%5cX&quot;&gt;\ X&lt;/a&gt;下进行了说明。实际上， &lt;code&gt;\X&lt;/code&gt; 是获得相同功能的另一种方式。它等效于 &lt;code&gt;/.+?\b{gcb}/&lt;/code&gt; 。根据您的情况选择最方便的一种。</target>
        </trans-unit>
        <trans-unit id="43a174e3acf9fe3da094fe1e29ca009a0ac07471" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Sentence Boundary&quot;. This is an aid to parsing natural language sentences. It gives good, but imperfect results. For example, it thinks that &quot;Mr. Smith&quot; is two sentences. More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. Note also that it thinks that anything matching &lt;a href=&quot;#%5cR&quot;&gt;\R&lt;/a&gt; (except form feed and vertical tab) is a sentence boundary. &lt;code&gt;\b{sb}&lt;/code&gt; works with text designed for word-processors which wrap lines automatically for display, but hard-coded line boundaries are considered to be essentially the ends of text blocks (paragraphs really), and hence the ends of sententces. &lt;code&gt;\b{sb}&lt;/code&gt; doesn't do well with text containing embedded newlines, like the source text of the document you are reading. Such text needs to be preprocessed to get rid of the line separators before looking for sentence boundaries. Some people view this as a bug in the Unicode standard, and this behavior is quite subject to change in future Perl versions.</source>
          <target state="translated">这与Unicode&amp;ldquo;句子边界&amp;rdquo;匹配。这有助于解析自然语言句子。它给出了良好但不完美的结果。例如，它认为&amp;ldquo;史密斯先生&amp;rdquo;是两个句子。有关更多详细信息，&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;请访问http://www.unicode.org/reports/tr29/&lt;/a&gt;。还要注意，它认为与&lt;a href=&quot;#%5cR&quot;&gt;\ R&lt;/a&gt;匹配的任何内容（换页符和垂直制表符除外）都是句子边界。 &lt;code&gt;\b{sb}&lt;/code&gt; 与为文字处理器设计的文本一起使用，这些文字处理器自动换行以显示，但是硬编码的行边界本质上被认为是文本块的末端（实际上是段落），因此也是句子的末端。 &lt;code&gt;\b{sb}&lt;/code&gt; 包含嵌入式换行符的文本效果不佳，例如您正在阅读的文档的源文本。在查找句子边界之前，需要对此类文本进行预处理以消除行分隔符。有人将其视为Unicode标准中的错误，并且此行为在将来的Perl版本中会受到很大的影响。</target>
        </trans-unit>
        <trans-unit id="1cb6230dc355ad698d71f70d4c4922dccb9931e0" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Sentence Boundary&quot;. This is an aid to parsing natural language sentences. It gives good, but imperfect results. For example, it thinks that &quot;Mr. Smith&quot; is two sentences. More details are at &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;. Note also that it thinks that anything matching &lt;a href=&quot;#%5CR&quot;&gt;&quot;\R&quot;&lt;/a&gt; (except form feed and vertical tab) is a sentence boundary. &lt;code&gt;\b{sb}&lt;/code&gt; works with text designed for word-processors which wrap lines automatically for display, but hard-coded line boundaries are considered to be essentially the ends of text blocks (paragraphs really), and hence the ends of sentences. &lt;code&gt;\b{sb}&lt;/code&gt; doesn't do well with text containing embedded newlines, like the source text of the document you are reading. Such text needs to be preprocessed to get rid of the line separators before looking for sentence boundaries. Some people view this as a bug in the Unicode standard, and this behavior is quite subject to change in future Perl versions.</source>
          <target state="translated">这与Unicode&amp;ldquo;句子边界&amp;rdquo;匹配。这有助于解析自然语言句子。它给出了良好但不完美的结果。例如，它认为&amp;ldquo;史密斯先生&amp;rdquo;是两个句子。有关更多详细信息，请访问&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;。还要注意，它认为与&lt;a href=&quot;#%5CR&quot;&gt;&amp;ldquo; \ R&amp;rdquo;&lt;/a&gt;匹配的任何内容（换页符和垂直制表符除外）都是句子边界。 &lt;code&gt;\b{sb}&lt;/code&gt; 与为文字处理器设计的文本一起使用，这些文字处理器会自动换行以显示，但是硬编码的行边界本质上被认为是文本块（实际上是段落）的结尾，因此也是句子的结尾。 &lt;code&gt;\b{sb}&lt;/code&gt; 包含嵌入式换行符的文本效果不佳，例如您正在阅读的文档的源文本。在查找句子边界之前，需要对此类文本进行预处理以消除行分隔符。有人将其视为Unicode标准中的错误，并且此行为在将来的Perl版本中会受到很大的影响。</target>
        </trans-unit>
        <trans-unit id="2811398b5c9cc7a492470e9d11bff95eac375ba9" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Word Boundary&quot;, but tailored to Perl expectations. This gives better (though not perfect) results for natural language processing than plain &lt;code&gt;\b&lt;/code&gt; (without braces) does. For example, it understands that apostrophes can be in the middle of words and that parentheses aren't (see the examples below). More details are at &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;.</source>
          <target state="translated">这与Unicode&amp;ldquo; Word Boundary&amp;rdquo;相匹配，但是是根据Perl的期望量身定制的。与纯 &lt;code&gt;\b&lt;/code&gt; （不带花括号）相比，这为自然语言处理提供了更好的（尽管不是完美的）结果。例如，它理解撇号可以在单词的中间，而括号不能在单词的中间（请参见下面的示例）。有关更多详细信息，请访问&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="862d390cde50da1c3067a4f5bf13a23004164fc2" translate="yes" xml:space="preserve">
          <source>This matches a Unicode &quot;Word Boundary&quot;. This gives better (though not perfect) results for natural language processing than plain &lt;code&gt;\b&lt;/code&gt; (without braces) does. For example, it understands that apostrophes can be in the middle of words and that parentheses aren't (see the examples below). More details are at &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;.</source>
          <target state="translated">这与Unicode&amp;ldquo;单词边界&amp;rdquo;匹配。与纯 &lt;code&gt;\b&lt;/code&gt; （不带花括号）相比，这为自然语言处理提供了更好的（尽管不是完美的）结果。例如，它理解撇号可以在单词的中间，而括号不能在单词的中间（请参见下面的示例）。有关更多详细信息，&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;请访问http://www.unicode.org/reports/tr29/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ef47eed99ac1d083b3beb492e4f8913342391453" translate="yes" xml:space="preserve">
          <source>This matches according to the default Unicode Line Breaking Algorithm (&lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https://www.unicode.org/reports/tr14/&lt;/a&gt;), as customized in that document (&lt;a href=&quot;https://www.unicode.org/reports/tr14/tr14-35.html#Example7&quot;&gt;Example 7 of revision 35&lt;/a&gt;) for better handling of numeric expressions.</source>
          <target state="translated">它根据该文档中自定义的默认Unicode换行算法（&lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https://www.unicode.org/reports/tr14/&lt;/a&gt;）（&lt;a href=&quot;https://www.unicode.org/reports/tr14/tr14-35.html#Example7&quot;&gt;版本35的示例7&lt;/a&gt;）进行匹配，以更好地处理数字表达式。</target>
        </trans-unit>
        <trans-unit id="dd6302d3bb19b988247051f1fbfe94d51caf4369" translate="yes" xml:space="preserve">
          <source>This matches all code points whose numeric value is one of 0, 1, 2, 3, 4, or 5. This particular example could instead have been written as</source>
          <target state="translated">这将匹配所有数值为0、1、2、3、4或5之一的代码点。这个例子可以写成</target>
        </trans-unit>
        <trans-unit id="46f9c4b6a0133a2ba4a4536268bb4388e6462d37" translate="yes" xml:space="preserve">
          <source>This matches any &lt;code&gt;\p{Alphabetic}&lt;/code&gt; or &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; character.</source>
          <target state="translated">这匹配任何 &lt;code&gt;\p{Alphabetic}&lt;/code&gt; 或 &lt;code&gt;\p{Decimal_Number}&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="1368a197a87ba6ed14500f8908565c9ada6f62ff" translate="yes" xml:space="preserve">
          <source>This matches any assigned code point; that is, any code point whose &lt;a href=&quot;#General_Category&quot;&gt;general category&lt;/a&gt; is not &lt;code&gt;Unassigned&lt;/code&gt; (or equivalently, not &lt;code&gt;Cn&lt;/code&gt; ).</source>
          <target state="translated">这匹配任何分配的代码点；也就是说，其&lt;a href=&quot;#General_Category&quot;&gt;常规类别&lt;/a&gt;不是 &lt;code&gt;Unassigned&lt;/code&gt; （或等效地，不是 &lt;code&gt;Cn&lt;/code&gt; ）的任何代码点。</target>
        </trans-unit>
        <trans-unit id="100bdeeeb5e6097e5b9781532670a8d8611e6b85" translate="yes" xml:space="preserve">
          <source>This matches any assigned code point; that is, any code point whose &lt;a href=&quot;#General_Category&quot;&gt;general category&lt;/a&gt; is not &lt;code&gt;Unassigned&lt;/code&gt; (or equivalently, not &lt;code&gt;Cn&lt;/code&gt;).</source>
          <target state="translated">这匹配任何分配的代码点；也就是说，其&lt;a href=&quot;#General_Category&quot;&gt;常规类别&lt;/a&gt;不是 &lt;code&gt;Unassigned&lt;/code&gt; （或等效地，不是 &lt;code&gt;Cn&lt;/code&gt; ）的任何代码点。</target>
        </trans-unit>
        <trans-unit id="a2970fcf592bf526b7624da46ffe2c2926bcdb66" translate="yes" xml:space="preserve">
          <source>This matches any character that is graphical or blank, except controls.</source>
          <target state="translated">这与任何图形或空白的字符相匹配,但控件除外。</target>
        </trans-unit>
        <trans-unit id="9dcbf046b8bea0226e813051a826c67a230a6bfb" translate="yes" xml:space="preserve">
          <source>This matches any of the 128 characters in the US-ASCII character set, which is a subset of Unicode.</source>
          <target state="translated">这与US-ASCII字符集的128个字符中的任何一个相匹配,US-ASCII字符集是Unicode的一个子集。</target>
        </trans-unit>
        <trans-unit id="6f971eb914dae58555e5f55db125c34d663d6429" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. &lt;code&gt;\p{Any}&lt;/code&gt; .</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。 &lt;code&gt;\p{Any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce7e09f2891fc7e1926bcdf025e41ca7e5796fc4" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. &lt;code&gt;\p{Any}&lt;/code&gt;.</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。 &lt;code&gt;\p{Any}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50e5a95f3a6d3f1afad03782326f2e0e7b9c9ed7" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. It is a synonym for &lt;code&gt;\p{Unicode}&lt;/code&gt; .</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。它是 &lt;code&gt;\p{Unicode}&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="29cf195e8abc4c2fda5508cb856c0619ed1c39b8" translate="yes" xml:space="preserve">
          <source>This matches any of the 1_114_112 Unicode code points. It is a synonym for &lt;code&gt;\p{Unicode}&lt;/code&gt;.</source>
          <target state="translated">这匹配任何1_114_112 Unicode代码点。它是 &lt;code&gt;\p{Unicode}&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="1ddbc160eb4c94b6ef293222be013d55a26c3ebd" translate="yes" xml:space="preserve">
          <source>This matches digits that are in either the Thai or Laotian scripts.</source>
          <target state="translated">这与泰文或老挝文的数字相匹配。</target>
        </trans-unit>
        <trans-unit id="bed0a3d92b78eec58ff8b7c04af52fb9a269486e" translate="yes" xml:space="preserve">
          <source>This matches every possible code point. It is equivalent to &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt;. Unlike all the other non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if this is property is matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Beyond Unicode code points&lt;/a&gt; below).</source>
          <target state="translated">这匹配每个可能的代码点。等效于 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/./s&lt;/a&gt;&lt;/code&gt; 。与所有其他非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果此属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;Unicode代码点之外&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="54223479a01eff97835bc0fc4d5646f6d53ac4e4" translate="yes" xml:space="preserve">
          <source>This matches every possible code point. It is equivalent to &lt;code&gt;qr/./s&lt;/code&gt;. Unlike all the other non-user-defined &lt;code&gt;\p{}&lt;/code&gt; property matches, no warning is ever generated if this is property is matched against a non-Unicode code point (see &lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&quot;Beyond Unicode code points&quot;&lt;/a&gt; below).</source>
          <target state="translated">这匹配每个可能的代码点。等效于 &lt;code&gt;qr/./s&lt;/code&gt; 。与所有其他非用户定义的 &lt;code&gt;\p{}&lt;/code&gt; 属性匹配不同，如果此属性与非Unicode代码点匹配，则不会生成任何警告（请参见下面的&lt;a href=&quot;#Beyond-Unicode-code-points&quot;&gt;&amp;ldquo;超出Unicode代码点&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="39f19d0a2349916b7981752a7104f9d5ef925fc8" translate="yes" xml:space="preserve">
          <source>This matches the English vowels plus the SPACE character.</source>
          <target state="translated">这与英语元音加上SPACE字符相匹配。</target>
        </trans-unit>
        <trans-unit id="e5af876b8e44759fbc1c5f4ebb39fe615bb29e7e" translate="yes" xml:space="preserve">
          <source>This matches the English vowels plus the SPACE character. All the other escapes accepted by normal bracketed character classes are accepted here as well; but unrecognized escapes that generate warnings in normal classes are fatal errors here.</source>
          <target state="translated">这与英语元音加上SPACE字符相匹配。所有其他正常括号内字符类所接受的转义符在这里也被接受;但是在正常类中产生警告的未识别的转义符在这里是致命的错误。</target>
        </trans-unit>
        <trans-unit id="55be8f6854e7ce1e29dee30dacbad8368e941533" translate="yes" xml:space="preserve">
          <source>This may a variant of just &lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;&quot;I cannot run external programs&quot;&lt;/a&gt;, or a deeper problem. Basically: you</source>
          <target state="translated">这可能只是&lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;&amp;ldquo;我无法运行外部程序&amp;rdquo;&lt;/a&gt;的变体，或者是更深层次的问题。基本上：你</target>
        </trans-unit>
        <trans-unit id="6fe0bd3d52f9526a3bdbdf0fb7b2272dd4226b2a" translate="yes" xml:space="preserve">
          <source>This may a variant of just &lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;I cannot run external programs&lt;/a&gt;, or a deeper problem. Basically: you</source>
          <target state="translated">这可能只是&lt;a href=&quot;#I-cannot-run-external-programs&quot;&gt;我无法运行外部程序&lt;/a&gt;的变体，或者是更深层次的问题。基本上：你</target>
        </trans-unit>
        <trans-unit id="3c2e6cadd45bf9050033dd0f02dee64c1cb36e02" translate="yes" xml:space="preserve">
          <source>This may also be a good time to ensure that your /etc/protocol file and either your /etc/resolv.conf or /etc/hosts files are in place. The IBM document that described such USS system setup issues was SC28-1890-07 &quot;OS/390 UNIX System Services Planning&quot;, in particular Chapter 6 on customizing the OE shell.</source>
          <target state="translated">这也可能是确保你的/etc/protocol文件和/etc/resolv.conf或/etc/hosts文件到位的好时机。描述这种USS系统设置问题的IBM文档是SC28-1890-07 &quot;OS/390 UNIX系统服务规划&quot;,特别是第6章关于定制OE shell的内容。</target>
        </trans-unit>
        <trans-unit id="1206b674e03199df25ca78fd2210a65fd2a21ff2" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号（但是对于troff输出，字体仍然会更改）。</target>
        </trans-unit>
        <trans-unit id="345f8ac7fec5019dbde30571fee3e63e792fb3cf" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt; , in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号。</target>
        </trans-unit>
        <trans-unit id="14fa777a070fca8732a6c3aaf496e4c4e9175f3e" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt;, in which case no quote marks are added around C&amp;lt;&amp;gt; text (but the font is still changed for troff output).</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号（但是对于troff输出，字体仍然会更改）。</target>
        </trans-unit>
        <trans-unit id="61345d4379070080abacfba137fca759d14d397c" translate="yes" xml:space="preserve">
          <source>This may also be set to the special value &lt;code&gt;none&lt;/code&gt;, in which case no quote marks are added around C&amp;lt;&amp;gt; text.</source>
          <target state="translated">也可以将其设置为特殊值 &lt;code&gt;none&lt;/code&gt; ，在这种情况下，不会在C &amp;lt;&amp;gt;文本周围添加引号。</target>
        </trans-unit>
        <trans-unit id="a4b045aef9d01569a459e4507e2bf0dbcc4d078d" translate="yes" xml:space="preserve">
          <source>This may be less obvious in other situations, such as &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt;, for instance when grepping through a list of weakened references to objects that may have been destroyed already:</source>
          <target state="translated">在其他情况下，例如 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; ，这可能不太明显，例如，在通过grep遍历可能已经销毁的对象的弱引用列表时：</target>
        </trans-unit>
        <trans-unit id="aadddde396ec6250eb650b31094a85752ac5de5f" translate="yes" xml:space="preserve">
          <source>This may be less obvious in other situations, such as &lt;code&gt;grep()&lt;/code&gt;, for instance when grepping through a list of weakened references to objects that may have been destroyed already:</source>
          <target state="translated">在其他情况下，例如 &lt;code&gt;grep()&lt;/code&gt; ，这种情况可能不太明显，例如，在通过grep遍历可能已经销毁的对象的弱引用列表时：</target>
        </trans-unit>
        <trans-unit id="9b6b611a35aea5e6cbfaa34dfad89779e54d15a6" translate="yes" xml:space="preserve">
          <source>This may be useful if other modules expect this module to be</source>
          <target state="translated">如果其他模块希望这个模块是一个新的模块,这可能是有用的。</target>
        </trans-unit>
        <trans-unit id="bb1bd20d64f2ccdce3f2cc8fcef954e7c80b5a33" translate="yes" xml:space="preserve">
          <source>This may be useful since, say, types which are &lt;code&gt;typedef&lt;/code&gt; -equivalent to integers may represent OS-related handles, and one may want to work with these handles in OO-way, as in &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; . Use &lt;code&gt;-o .&lt;/code&gt; if you want to handle all the &lt;code&gt;typedef&lt;/code&gt; ed types as opaque types.</source>
          <target state="translated">这可能是有用的，因为，例如， &lt;code&gt;typedef&lt;/code&gt; 等效于整数的类型可能表示与OS相关的句柄，并且可能想要以OO方式使用这些句柄，例如 &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; 。使用 &lt;code&gt;-o .&lt;/code&gt; 如果要处理所有 &lt;code&gt;typedef&lt;/code&gt; 编类型为不透明的类型。</target>
        </trans-unit>
        <trans-unit id="bb030fdbfde4cf4510e91d4dc3720be63df3b4c9" translate="yes" xml:space="preserve">
          <source>This may be useful since, say, types which are &lt;code&gt;typedef&lt;/code&gt;-equivalent to integers may represent OS-related handles, and one may want to work with these handles in OO-way, as in &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt;. Use &lt;code&gt;-o .&lt;/code&gt; if you want to handle all the &lt;code&gt;typedef&lt;/code&gt;ed types as opaque types.</source>
          <target state="translated">这可能是有用的，因为，例如， &lt;code&gt;typedef&lt;/code&gt; 等效于整数的类型可能表示与OS相关的句柄，并且可能想要以OO方式使用这些句柄，例如 &lt;code&gt;$handle-&amp;gt;do_something()&lt;/code&gt; 。使用 &lt;code&gt;-o .&lt;/code&gt; 如果要处理所有 &lt;code&gt;typedef&lt;/code&gt; 编类型为不透明的类型。</target>
        </trans-unit>
        <trans-unit id="219180c7e012f10d4f7a83d42d7e8f2690484f40" translate="yes" xml:space="preserve">
          <source>This may break in two ways:</source>
          <target state="translated">这可能会有两个方面的突破。</target>
        </trans-unit>
        <trans-unit id="c894611388eb78ec067fed71d079c9e5816ca7b5" translate="yes" xml:space="preserve">
          <source>This may cause problems:</source>
          <target state="translated">这可能会造成问题。</target>
        </trans-unit>
        <trans-unit id="5b07568535355dc79492449b01ec4948cfdc2343" translate="yes" xml:space="preserve">
          <source>This may expect the C</source>
          <target state="translated">这可能期待C</target>
        </trans-unit>
        <trans-unit id="03f2543e21cbd92a7ee1ca79827f8f9611eefa56" translate="yes" xml:space="preserve">
          <source>This may later be extended to include other information, so be careful with pattern-matching on the results.</source>
          <target state="translated">以后可能会扩展到包括其他信息,所以在结果上要注意模式匹配。</target>
        </trans-unit>
        <trans-unit id="e21dadcda575196402392ef6ce13a8923c3356bf" translate="yes" xml:space="preserve">
          <source>This may lead to problems later in case the socket is accessed via the &quot;usual&quot; file-system calls using the &quot;initial&quot; name.</source>
          <target state="translated">这可能导致以后在使用 &quot;初始 &quot;名称通过 &quot;通常 &quot;的文件系统调用访问套接字时出现问题。</target>
        </trans-unit>
        <trans-unit id="6110636ef5b993e8ba32881ebb3b6bb734669e0b" translate="yes" xml:space="preserve">
          <source>This may take a couple of hours on 1GHz processor (when run the first time). And this should not be necessarily a smooth procedure. Some modules may not specify required dependencies, so one may need to repeat this procedure several times until the results stabilize.</source>
          <target state="translated">这在1GHz处理器上可能需要几个小时(第一次运行时)。而且这不一定是一个顺利的过程。有些模块可能没有指定所需的依赖关系,所以可能需要重复这个过程几次,直到结果稳定下来。</target>
        </trans-unit>
        <trans-unit id="21e8b83f4a4668675b959f09a3dddc3f913b92a2" translate="yes" xml:space="preserve">
          <source>This means integer values like 1.01E2 or even 1000E-2 are also accepted. Non-integer values result in NaN.</source>
          <target state="translated">这意味着像1.01E2甚至1000E-2这样的整数值也被接受。非整数值会导致NaN。</target>
        </trans-unit>
        <trans-unit id="0df399dd4c0ebd437b2b092068503ec57072d7a4" translate="yes" xml:space="preserve">
          <source>This means somewhere a routine got a BigFloat/Lite but expected a BigInt (or vice versa) and the upgrade/downgrad path was missing. This is a bug, please report it so that we can fix it.</source>
          <target state="translated">这意味着某个例程得到了BigFloat/Lite,但期望得到BigInt(或反之亦然),而升级/降级路径缺失。这是一个bug,请报告它,以便我们能够修复它。</target>
        </trans-unit>
        <trans-unit id="14a58ee32b8ae7bdc388a529d03ef7e5871a7f4e" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;catdir()&lt;/code&gt; is called only when there are two or more arguments, as one might expect.</source>
          <target state="translated">这意味着，仅在有两个或多个参数时才调用 &lt;code&gt;catdir()&lt;/code&gt; ，这可能会引起人们的预期。</target>
        </trans-unit>
        <trans-unit id="578c842326a0346c93813339f663f40295cced47" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;prop_invmap&lt;/code&gt; returns a 4 element list. For example,</source>
          <target state="translated">这意味着 &lt;code&gt;prop_invmap&lt;/code&gt; 返回一个4元素列表。例如，</target>
        </trans-unit>
        <trans-unit id="38b6532eaf6e68ec76d8a337e1c024ccfeab03a8" translate="yes" xml:space="preserve">
          <source>This means that arithmetic involving only string values or string literals will be performed using Perl's built-in operators.</source>
          <target state="translated">这意味着,只涉及字符串值或字符串字面的运算将使用 Perl 的内置运算符来执行。</target>
        </trans-unit>
        <trans-unit id="01006b71ced49944419d9cf9ecdab2df41a8f161" translate="yes" xml:space="preserve">
          <source>This means that if a developer only needs a module for the BAR standard, they should not be forced to install libraries for FOO as well.</source>
          <target state="translated">这意味着,如果一个开发者只需要一个BAR标准的模块,他们不应该被迫为FOO也安装库。</target>
        </trans-unit>
        <trans-unit id="a939b578ee66e30d68a1cb74f87d0079e5aa7b9c" translate="yes" xml:space="preserve">
          <source>This means that it short-circuits: the right expression is evaluated only if the left expression is false. Due to its precedence, you must be careful to avoid using it as replacement for the &lt;code&gt;||&lt;/code&gt; operator. It usually works out better for flow control than in assignments:</source>
          <target state="translated">这意味着它短路：仅当左表达式为false时，才对右表达式求值。由于其优先级，您必须小心避免使用它代替 &lt;code&gt;||&lt;/code&gt; 。操作员。通常，对于流量控制而言，比在分配中效果更好：</target>
        </trans-unit>
        <trans-unit id="6b325861f3ab382f335c9341221acf9229196786" translate="yes" xml:space="preserve">
          <source>This means that once RawInflate is finished &lt;code&gt;$fh&lt;/code&gt; will be left at the byte directly after the compressed data stream.</source>
          <target state="translated">这意味着一旦RawInflate完成， &lt;code&gt;$fh&lt;/code&gt; 将直接留在压缩数据流之后的字节处。</target>
        </trans-unit>
        <trans-unit id="be9154072eb271aa42c51fcc713d07f839133a3a" translate="yes" xml:space="preserve">
          <source>This means that the code points from 0 to 0x2F do not represent decimal digits; the code point 0x30 (DIGIT ZERO) represents 0; code point 0x31, (DIGIT ONE), represents 0+1-0 = 1; ... code point 0x39, (DIGIT NINE), represents 0+9-0 = 9; ... code points 0x3A through 0x65F do not represent decimal digits; 0x660 (ARABIC-INDIC DIGIT ZERO), represents 0; ... 0x07C1 (NKO DIGIT ONE), represents 0+1-0 = 1 ...</source>
          <target state="translated">这意味着从0到0x2F的代码点不代表十进制数字;代码点0x30(DIGIT ZERO)代表0;代码点0x31,(DIGIT ONE),代表0+1-0=1;......代码点0x39,(DIGIT NINE),代表0+9-0=9;......代码点0x3A到0x65F不代表十进制数字;0x660(ARABIC-INDIC DIGIT ZERO),代表0;......。0x07C1(NKO数字一),代表0+1-0=1......。</target>
        </trans-unit>
        <trans-unit id="53a7571a93760445ebdaebf443e990e621523e20" translate="yes" xml:space="preserve">
          <source>This means that the example in the synopsis could be rewritten more simply as:</source>
          <target state="translated">这意味着,提纲中的例子可以更简单地改写为。</target>
        </trans-unit>
        <trans-unit id="a1f3ea2c657f7b7f7d19db3a4421f880ee25efe3" translate="yes" xml:space="preserve">
          <source>This means that the space in the middle of the visible link text must not be broken across lines. In other words, it's the same as this:</source>
          <target state="translated">也就是说,可见链接文字中间的空格不能跨行断开。换句话说,就是和这个一样。</target>
        </trans-unit>
        <trans-unit id="64c7de2c5fffc581047d71755a716f6efa16c586" translate="yes" xml:space="preserve">
          <source>This means that the words in</source>
          <target state="translated">这意味着,在</target>
        </trans-unit>
        <trans-unit id="f1569c4431f8fc6543e767edacb7a758da5a6960" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">这意味着当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 生效时， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 允许您使用包变量而不用包名来限定它，而只能在 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明的词法范围内使用。这立即适用-即使在同一语句中也是如此。</target>
        </trans-unit>
        <trans-unit id="f586cceadb03a1ba8357cc824f5f5d4e8015da6f" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; is in effect, &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">这意味着当 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 生效时， &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 允许您使用包变量而不用包名来限定它，而只能在 &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 声明的词法范围内使用。这立即适用-即使在同一语句中也是如此。</target>
        </trans-unit>
        <trans-unit id="284eb118660ae660f27c03fcc27710a4366c9a03" translate="yes" xml:space="preserve">
          <source>This means that when &lt;code&gt;use strict 'vars'&lt;/code&gt; is in effect, &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; lets you use a package variable without qualifying it with the package name, but only within the lexical scope of the &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration. This applies immediately--even within the same statement.</source>
          <target state="translated">这意味着当 &lt;code&gt;use strict 'vars'&lt;/code&gt; 生效时，&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;允许您使用包变量而不用包名来限定它，而只能在&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;声明的词法范围内使用。这立即适用-即使在同一语句中也是如此。</target>
        </trans-unit>
        <trans-unit id="b81785772e2cebea14c023690b3e80231bc941d4" translate="yes" xml:space="preserve">
          <source>This means that you can embed Perl code in your typemap (C) code using constructs such as &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; . A common use case is to generate error messages that refer to the true function name even when using the ALIAS XS feature:</source>
          <target state="translated">这意味着您可以使用诸如 &lt;code&gt;${ perl code that evaluates to &lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt; reference here }&lt;/code&gt; 结构将Perl代码嵌入到类型映射（C）代码中。一个常见的用例是即使使用ALIAS XS功能，也会生成引用真实函数名称的错误消息：</target>
        </trans-unit>
        <trans-unit id="6159f11ee36a959a1c616223b9451cb1accb09f1" translate="yes" xml:space="preserve">
          <source>This means that you can embed Perl code in your typemap (C) code using constructs such as &lt;code&gt;${ perl code that evaluates to scalar reference here }&lt;/code&gt;. A common use case is to generate error messages that refer to the true function name even when using the ALIAS XS feature:</source>
          <target state="translated">这意味着您可以使用 &lt;code&gt;${ perl code that evaluates to scalar reference here }&lt;/code&gt; 结构将Perl代码嵌入到类型映射（C）代码中。一个常见的用例是即使使用ALIAS XS功能，也会生成引用真实函数名称的错误消息：</target>
        </trans-unit>
        <trans-unit id="fae397e13ee74537dfbe00fc3647b75575531d38" translate="yes" xml:space="preserve">
          <source>This means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C's function statics. Here's a mechanism for giving a function private variables with both lexical scoping and a static lifetime. If you do want to create something like C's static variables, just enclose the whole function in an extra block, and put the static variable outside the function but in the block.</source>
          <target state="translated">这意味着你可以传回或保存掉对词法变量的引用,而返回一个指向C语言自动变量的指针是一个严重的错误。它还为我们提供了一种模拟 C 的函数静态的方法。这里有一个机制,可以给一个函数提供私有变量,同时具有词法范围和静态寿命。如果你确实想创建类似于C的静态变量,只需将整个函数封闭在一个额外的块中,并将静态变量放在函数之外,但放在块中即可。</target>
        </trans-unit>
        <trans-unit id="ba95400be83f3e213b12cd9a0fd5821a87880672" translate="yes" xml:space="preserve">
          <source>This means that your locale settings had &lt;code&gt;LC_ALL&lt;/code&gt; set to &quot;En_US&quot; and LANG exists but has no value. Perl tried to believe you but could not. Instead, Perl gave up and fell back to the &quot;C&quot; locale, the default locale that is supposed to work no matter what. (On Windows, it first tries falling back to the system default locale.) This usually means your locale settings were wrong, they mention locales your system has never heard of, or the locale installation in your system has problems (for example, some system files are broken or missing). There are quick and temporary fixes to these problems, as well as more thorough and lasting fixes.</source>
          <target state="translated">这意味着您的区域设置将 &lt;code&gt;LC_ALL&lt;/code&gt; 设置为&amp;ldquo; En_US&amp;rdquo;，并且LANG存在但没有任何值。 Perl试图相信您，但无法相信。取而代之的是，Perl放弃并退回到&amp;ldquo; C&amp;rdquo;区域设置，该区域设置无论如何都可以正常工作。 （在Windows上，它首先尝试回退到系统默认语言环境。）这通常意味着您的语言环境设置有误，它们提到系统从未听说过的语言环境，或者系统中的语言环境安装有问题（例如，某些系统文件损坏或丢失）。有针对这些问题的快速和临时修复程序，以及更彻底，更持久的修复程序。</target>
        </trans-unit>
        <trans-unit id="935bdf240cb07ad1d6c61c4ce332cb8c8c8bea3f" translate="yes" xml:space="preserve">
          <source>This means the hook can be inherited like any other method, and that</source>
          <target state="translated">这意味着钩子可以像其他方法一样被继承,而且</target>
        </trans-unit>
        <trans-unit id="2829080b86855df25144fdad5ccaac91d3e22b76" translate="yes" xml:space="preserve">
          <source>This means the same thing as the above &quot;=begin html&quot; ... &quot;=end html&quot; region.</source>
          <target state="translated">这与上面的&quot;=begin html&quot;...的意思是一样的。&quot;=end html &quot;区域。</target>
        </trans-unit>
        <trans-unit id="44c698371a2bc8c8f85a78f7834202f417a26f2b" translate="yes" xml:space="preserve">
          <source>This means you would have to be very careful of the load order:</source>
          <target state="translated">这意味着你必须要非常小心的装载顺序。</target>
        </trans-unit>
        <trans-unit id="3337abd3921fdbd49cbcb7fb32155c6404621f35" translate="yes" xml:space="preserve">
          <source>This means your tests won't fail on MacOS. This means fewer emails from MacPerl users telling you about failing tests that you know will never work. You've got to be careful with skip tests. These are for tests which don't work and</source>
          <target state="translated">这意味着你的测试在 MacOS 上不会失败。这意味着更少的来自MacPerl用户的邮件告诉你测试失败,而你知道这些测试永远不会成功。你必须小心使用跳过测试。这些是针对那些不工作的测试,并且</target>
        </trans-unit>
        <trans-unit id="cff2ec52af1291aa43e3a1c0cb12356c3eeef13f" translate="yes" xml:space="preserve">
          <source>This member is of type &lt;code&gt;Perl_cpeep_t&lt;/code&gt; , which expands to &lt;code&gt;void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; . If it is set, this function will be called from &lt;code&gt;Perl_rpeep&lt;/code&gt; when ops of this type are encountered by the peephole optimizer.</source>
          <target state="translated">该成员的类型为 &lt;code&gt;Perl_cpeep_t&lt;/code&gt; ，它扩展为 &lt;code&gt;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; 。如果已设置，则窥孔优化器遇到这种类型的操作时，将从 &lt;code&gt;Perl_rpeep&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="db36691e48e2c67d2ea0f23d3b7c02ae12b88783" translate="yes" xml:space="preserve">
          <source>This member is of type &lt;code&gt;Perl_cpeep_t&lt;/code&gt;, which expands to &lt;code&gt;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt;. If it is set, this function will be called from &lt;code&gt;Perl_rpeep&lt;/code&gt; when ops of this type are encountered by the peephole optimizer.</source>
          <target state="translated">该成员的类型为 &lt;code&gt;Perl_cpeep_t&lt;/code&gt; ，它扩展为 &lt;code&gt;void (*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)&lt;/code&gt; 。如果已设置，则窥孔优化器遇到这种类型的操作时，将从 &lt;code&gt;Perl_rpeep&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="7a717feb83162a52d0b22449b1b2a628cde73cab" translate="yes" xml:space="preserve">
          <source>This merge strategy will try to pick the appropriate predefined strategy based on what element type. Array refs will try to use the &lt;code&gt;set_addition&lt;/code&gt; strategy, Hash refs will try to use the &lt;code&gt;uniq_map&lt;/code&gt; strategy, and everything else will try the &lt;code&gt;identical&lt;/code&gt; strategy.</source>
          <target state="translated">该合并策略将尝试根据哪种元素类型选择适当的预定义策略。数组引用将尝试使用 &lt;code&gt;set_addition&lt;/code&gt; 策略，哈希引用将尝试使用 &lt;code&gt;uniq_map&lt;/code&gt; 策略，其他所有内容都将尝试 &lt;code&gt;identical&lt;/code&gt; 策略。</target>
        </trans-unit>
        <trans-unit id="4f15c1dce331d08d1c4dfe4e281cc0a0a4b34f0a" translate="yes" xml:space="preserve">
          <source>This message can be seen quite often with DB_File on systems with &quot;hard&quot; dynamic linking, like &lt;code&gt;AIX&lt;/code&gt; and &lt;code&gt;OS/2&lt;/code&gt; . It is a bug of &lt;code&gt;Berkeley DB&lt;/code&gt; which is left unnoticed if &lt;code&gt;DB&lt;/code&gt; uses</source>
          <target state="translated">在具有&amp;ldquo;硬&amp;rdquo;动态链接的系统（例如 &lt;code&gt;AIX&lt;/code&gt; 和 &lt;code&gt;OS/2&lt;/code&gt; )上，使用DB_File可以经常看到此消息。这是 &lt;code&gt;Berkeley DB&lt;/code&gt; 的错误，如果 &lt;code&gt;DB&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="dd9cc0488fe9dc37730174b23cf738f2f87b5cde" translate="yes" xml:space="preserve">
          <source>This message can be seen quite often with DB_File on systems with &quot;hard&quot; dynamic linking, like &lt;code&gt;AIX&lt;/code&gt; and &lt;code&gt;OS/2&lt;/code&gt;. It is a bug of &lt;code&gt;Berkeley DB&lt;/code&gt; which is left unnoticed if &lt;code&gt;DB&lt;/code&gt; uses</source>
          <target state="translated">在具有&amp;ldquo;硬&amp;rdquo;动态链接的系统（例如 &lt;code&gt;AIX&lt;/code&gt; 和 &lt;code&gt;OS/2&lt;/code&gt; )上，使用DB_File可以经常看到此消息。这是 &lt;code&gt;Berkeley DB&lt;/code&gt; 的错误，如果 &lt;code&gt;DB&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="ee2510b2403247fa109d55b63b7f2961e33ab09a" translate="yes" xml:space="preserve">
          <source>This message indicates a bug either in the Perl core or in XS code. Such code was trying to find out if a character, allegedly stored internally encoded as UTF-8, was of a given type, such as being punctuation or a digit. But the character was not encoded in legal UTF-8. The &lt;code&gt;%s&lt;/code&gt; is replaced by a string that can be used by knowledgeable people to determine what the type being checked against was.</source>
          <target state="translated">此消息表明Perl内核或XS代码中存在错误。这种代码试图找出据称内部编码为UTF-8的字符是否属于给定类型，例如标点符号或数字。但是该字符未使用合法的UTF-8编码。该 &lt;code&gt;%s&lt;/code&gt; 是可以由懂行的人用来确定被检查什么类型对是一个字符串替换。</target>
        </trans-unit>
        <trans-unit id="23eb60fb126cb22151d73766a234b7a419df8dc7" translate="yes" xml:space="preserve">
          <source>This message is output once each time a bad locale is switched into within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , or on the first possibly-affected operation if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; inherits a bad one. It is not raised for any operations from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">每当在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 的范围内将不良区域设置切换到该区域时，或在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 继承了不良区域的第一个可能受影响的操作上，都会输出此消息。对于&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的任何操作，不会引发它。</target>
        </trans-unit>
        <trans-unit id="53334537f396c17eb5e0a1eb97007585d5a6b393" translate="yes" xml:space="preserve">
          <source>This message is output once each time a bad locale is switched into within the scope of &lt;code&gt;use locale&lt;/code&gt;, or on the first possibly-affected operation if the &lt;code&gt;use locale&lt;/code&gt; inherits a bad one. It is not raised for any operations from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">每当在 &lt;code&gt;use locale&lt;/code&gt; 的范围内切换到错误的区域设置时，或在 &lt;code&gt;use locale&lt;/code&gt; 继承了错误的区域的第一个可能受影响的操作上，都会一次输出此消息。对于&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的任何操作，不会引发此错误。</target>
        </trans-unit>
        <trans-unit id="9f1e56024310d1748ef48e25b309befac60c3c39" translate="yes" xml:space="preserve">
          <source>This message is suppressed (unless it has been made fatal) if it is immaterial to the results of the match if the code point is Unicode or not. For example, the property &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; only can match the 22 characters &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; , so obviously all other code points, Unicode or not, won't match it. (And &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; will match every code point except these 22.)</source>
          <target state="translated">如果代码点是否为Unicode，则对匹配结果不重要时，将禁止显示此消息（除非已使其成为致命消息）。例如，属性 &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; 只能匹配22个字符 &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; ，因此显然所有其他代码点（无论是否为Unicode）都不匹配。（并且 &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; 将匹配除这22个以外的每个代码点。）</target>
        </trans-unit>
        <trans-unit id="21e762ad2efe9f1fd68a6114f57d56c551081580" translate="yes" xml:space="preserve">
          <source>This message is suppressed (unless it has been made fatal) if it is immaterial to the results of the match if the code point is Unicode or not. For example, the property &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; only can match the 22 characters &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt;, so obviously all other code points, Unicode or not, won't match it. (And &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; will match every code point except these 22.)</source>
          <target state="translated">如果代码点是否为Unicode，则对匹配结果不重要时，将禁止显示此消息（除非已使其成为致命消息）。例如，属性 &lt;code&gt;\p{ASCII_Hex_Digit}&lt;/code&gt; 只能匹配22个字符 &lt;code&gt;[0-9A-Fa-f]&lt;/code&gt; ，因此显然所有其他代码点（无论是否为Unicode）都不匹配。（并且 &lt;code&gt;\P{ASCII_Hex_Digit}&lt;/code&gt; 将匹配除这22个以外的每个代码点。）</target>
        </trans-unit>
        <trans-unit id="7bb0745c94a8675163fb7cf1b6b4c0dfe9dfc2a4" translate="yes" xml:space="preserve">
          <source>This method (by having it return the name of a language-tag that has an existing language class) can be used for making sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle (assuming your language classes are in an appropriate @INC directory). Or you can use the next method:</source>
          <target state="translated">此方法（通过使其返回具有现有语言类的语言标签的名称）可用于确保 &lt;code&gt;get_handle&lt;/code&gt; 将始终设法构造语言句柄（假设您的语言类位于适当的@INC目录中） 。或者，您可以使用下一个方法：</target>
        </trans-unit>
        <trans-unit id="43b19e8a9632f033ee0217cf824970a6266507f4" translate="yes" xml:space="preserve">
          <source>This method &lt;b&gt;only&lt;/b&gt; recurses into hashes that are referenced by another hash. Thus a Hash of Hashes (HoH) will all be restricted, but a Hash of Arrays of Hashes (HoAoH) will only have the top hash restricted.</source>
          <target state="translated">此方法&lt;b&gt;仅&lt;/b&gt;递归到另一个哈希引用的哈希。因此，哈希散列（HoH）都将受到限制，但是哈希散列（HoAoH）只会限制顶部散列。</target>
        </trans-unit>
        <trans-unit id="2a10494b333351ed900869ddfdd97f2e586a9270" translate="yes" xml:space="preserve">
          <source>This method adds all the requirements in the given CPAN::Meta::Requirements object to the requirements object on which it was called. If there are any conflicts, an exception is thrown.</source>
          <target state="translated">这个方法将给定的CPAN::Meta::Requirements对象中的所有需求添加到调用它的需求对象中。如果有任何冲突,会产生一个异常。</target>
        </trans-unit>
        <trans-unit id="a9adaf0f299fbd1e9f3a618dc3103eaac097e023" translate="yes" xml:space="preserve">
          <source>This method allows you declare all subsequent tests as TODO tests, up until the &lt;code&gt;todo_end&lt;/code&gt; method has been called.</source>
          <target state="translated">此方法允许您将所有后续测试声明为TODO测试，直到调用 &lt;code&gt;todo_end&lt;/code&gt; 方法为止。</target>
        </trans-unit>
        <trans-unit id="730814a3d72347a8011b0b6b58b63dc1cbc1cb75" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when compressing.</source>
          <target state="translated">压缩时，此方法始终返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="335f17051fdb64efb794e2ddfe5ed9008c1e1a8a" translate="yes" xml:space="preserve">
          <source>This method always returns &lt;code&gt;undef&lt;/code&gt; when compressing.</source>
          <target state="translated">压缩时，此方法始终返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6afef23ef81e88b5f94163ca10a11464e31ea48f" translate="yes" xml:space="preserve">
          <source>This method appends the given text or parse-tree to the current parse-tree. If the last item on the parse-tree is text and the argument is also text, then the text is appended to the last item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">本方法将给定的文本或解析树附加到当前的解析树上,如果解析树上的最后一项是文本,并且参数也是文本,那么文本将被附加到最后一项上(而不是作为单独的字符串添加)。如果解析树上的最后一项是文本,而参数也是文本,那么文本将被追加到最后一项上(而不是作为一个单独的字符串添加)。否则,参数将作为一个新的字符串或解析树被添加。</target>
        </trans-unit>
        <trans-unit id="ea9b54b0560b3ed55c0cd396158f6152d9f5e42b" translate="yes" xml:space="preserve">
          <source>This method behaves like &lt;code&gt;accept_targets_as_text&lt;/code&gt; , but also marks the region as one whose content should be emitted literally, without HTML entity escaping or wrapping in a &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">此方法的行为类似于 &lt;code&gt;accept_targets_as_text&lt;/code&gt; ，但也将该区域标记为应按字面意义发出其内容的区域，而HTML实体没有转义或包装在 &lt;code&gt;div&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="71bb1e0efdfc6beccfb10261573a5eab7a2b454b" translate="yes" xml:space="preserve">
          <source>This method behaves like &lt;code&gt;accept_targets_as_text&lt;/code&gt;, but also marks the region as one whose content should be emitted literally, without HTML entity escaping or wrapping in a &lt;code&gt;div&lt;/code&gt; element.</source>
          <target state="translated">此方法的行为类似于 &lt;code&gt;accept_targets_as_text&lt;/code&gt; ，但也将该区域标记为应按字面意义发出其内容的区域，而无需将HTML实体转义或包装在 &lt;code&gt;div&lt;/code&gt; 元素中。</target>
        </trans-unit>
        <trans-unit id="366bdf6f4cd4331574bef09ad73e8fc1d9c85442" translate="yes" xml:space="preserve">
          <source>This method can also be called as a</source>
          <target state="translated">这个方法也可以作为</target>
        </trans-unit>
        <trans-unit id="715fe7c265d92fe58819e384722c797c228ac231" translate="yes" xml:space="preserve">
          <source>This method can be used to (re)parse a (new) hyperlink, i.e. the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. The result is stored in the current object. Warnings are stored in the &lt;b&gt;warnings&lt;/b&gt; property. E.g. sections like &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; are deprecated, as they do not point to Perl documents. &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; is wrong as well, the manpage section can simply be dropped.</source>
          <target state="translated">该方法可用于（重新）解析（新）超链接，即 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 序列的内容。结果存储在当前对象中。警告存储在&lt;b&gt;警告&lt;/b&gt;属性中。例如，不赞成使用 &lt;code&gt;L&amp;lt;open(2)&amp;gt;&lt;/code&gt; 类的节，因为它们未指向Perl文档。 &lt;code&gt;L&amp;lt;DBI::foo(3p)&amp;gt;&lt;/code&gt; 也是错误的，可以直接删除联机帮助页部分。</target>
        </trans-unit>
        <trans-unit id="f1f35fb67080240d23f2eac011ae3670c8591965" translate="yes" xml:space="preserve">
          <source>This method can be used to attempt to recover good data from a compressed data stream that is partially corrupt. It scans &lt;code&gt;$input&lt;/code&gt; until it reaches either a</source>
          <target state="translated">此方法可用于尝试从部分损坏的压缩数据流中恢复良好的数据。它扫描 &lt;code&gt;$input&lt;/code&gt; 直到到达一个</target>
        </trans-unit>
        <trans-unit id="90ddd0ac6657449db229f14a03b758f7e485db52" translate="yes" xml:space="preserve">
          <source>This method can be used to wait for a transfer to complete between a passive server and a non-passive server. The method should be called on the passive server with the &lt;code&gt;Net::FTP&lt;/code&gt; object for the non-passive server passed as an argument.</source>
          <target state="translated">此方法可用于等待被动服务器和非被动服务器之间的传输完成。在被动服务器上应使用 &lt;code&gt;Net::FTP&lt;/code&gt; 对象作为参数传递非被动服务器的方法。</target>
        </trans-unit>
        <trans-unit id="ef82cc525f992d173e6595484cbecf34f240de62" translate="yes" xml:space="preserve">
          <source>This method checks for the existence of a specific key/value pair. If the pair exists, the cursor is left pointing to the pair and the method returns 0. Otherwise the method returns a non-zero value.</source>
          <target state="translated">本方法检查是否存在一个特定的键/值对。如果这对键/值存在,则光标左键指向这对键/值,方法返回0。否则,本方法返回一个非零值。</target>
        </trans-unit>
        <trans-unit id="96b247f2b62f33779c178ee950a71199ee05a065" translate="yes" xml:space="preserve">
          <source>This method checks that the socket domain is &lt;code&gt;PF_INET&lt;/code&gt; and will throw an exception if it isn't.</source>
          <target state="translated">此方法检查套接字域是否为 &lt;code&gt;PF_INET&lt;/code&gt; ，如果不是，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="97fce6b5cdefe17191f11f3d49b65755477991b9" translate="yes" xml:space="preserve">
          <source>This method converts the key/value pairs from a data hash or array reference into a &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; string. The keys and values from the data reference will be UTF-8 encoded and escaped per RFC 3986. If a value is an array reference, the key will be repeated with each of the values of the array reference. If data is provided as a hash reference, the key/value pairs in the resulting string will be sorted by key and value for consistent ordering.</source>
          <target state="translated">此方法将键/值对从数据哈希或数组引用转换为 &lt;code&gt;x-www-form-urlencoded&lt;/code&gt; 字符串。来自数据引用的键和值将按照RFC 3986进行UTF-8编码和转义。如果值是数组引用，则将对数组引用的每个值重复键。如果将数据作为哈希引用提供，则结果字符串中的键/值对将按键和值进行排序，以实现一致的排序。</target>
        </trans-unit>
        <trans-unit id="082e97019fd385ec77aeb826bdad258d6d406921" translate="yes" xml:space="preserve">
          <source>This method deletes a specific key/value pair. It returns 0 if they exist and have been deleted successfully. Otherwise the method returns a non-zero value.</source>
          <target state="translated">本方法删除一个特定的键/值对。如果它们存在并且被成功删除,则返回0。否则本方法返回一个非零值。</target>
        </trans-unit>
        <trans-unit id="8613b5263cdbc40f7a909322a6d93c9325aff610" translate="yes" xml:space="preserve">
          <source>This method deletes the symbol whose name is given as the first argument. The optional second argument specifies the symbol table, as described above under &lt;code&gt;setsym&lt;/code&gt;. It returns TRUE if the symbol was successfully deleted, and FALSE if it was not.</source>
          <target state="translated">此方法删除名称为第一个参数的符号。可选的第二个参数指定符号表，如上面在 &lt;code&gt;setsym&lt;/code&gt; 下所述。如果成功删除符号，则返回TRUE，否则返回FALSE。</target>
        </trans-unit>
        <trans-unit id="f513febb40f0a4c26460c04fb3a509ae4b426b01" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of JSON and the result. If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_json_string&lt;/code&gt; .</source>
          <target state="translated">此方法反序列化给定的JSON字符串和结果。如果源是UTF-8编码的，则必须在调用 &lt;code&gt;load_json_string&lt;/code&gt; 之前对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="f5a69f9661072b68742ae779de82b9a6939ce07d" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of JSON and the result. If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_json_string&lt;/code&gt;.</source>
          <target state="translated">此方法反序列化给定的JSON字符串和结果。如果源是UTF-8编码的，则必须在调用 &lt;code&gt;load_json_string&lt;/code&gt; 之前对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="f96e67c98ce1447f296a5e844322e09f6dd910a8" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of YAML and returns the first document in it. (CPAN metadata files should always have only one document.) If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_yaml_string&lt;/code&gt; .</source>
          <target state="translated">此方法反序列化给定的YAML字符串，并返回其中的第一个文档。（CPAN元数据文件应始终只有一个文档。）如果源是UTF-8编码的，则在调用 &lt;code&gt;load_yaml_string&lt;/code&gt; 之前必须对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="81765ac41247c95703028ea8dc4ea721f8d8a884" translate="yes" xml:space="preserve">
          <source>This method deserializes the given string of YAML and returns the first document in it. (CPAN metadata files should always have only one document.) If the source was UTF-8 encoded, the string must be decoded before calling &lt;code&gt;load_yaml_string&lt;/code&gt;.</source>
          <target state="translated">此方法反序列化给定的YAML字符串，并返回其中的第一个文档。（CPAN元数据文件应始终只有一个文档。）如果源是UTF-8编码的，则必须在调用 &lt;code&gt;load_yaml_string&lt;/code&gt; 之前对字符串进行解码。</target>
        </trans-unit>
        <trans-unit id="34a514b4f19b9ac86f842d6404bf8e89dd74c0e2" translate="yes" xml:space="preserve">
          <source>This method does</source>
          <target state="translated">本方法不</target>
        </trans-unit>
        <trans-unit id="54d18cd2ca68c9792cf6431fafe4da3a6cbdd8dc" translate="yes" xml:space="preserve">
          <source>This method does not implement a complete YAML dumper, being limited to dump a hash with values which are strings, undef's or nested hashes and arrays of strings. No quoting/escaping is done.</source>
          <target state="translated">这个方法并没有实现一个完整的YAML转储器,仅限于转储一个包含字符串、undef's或嵌套的字符串哈希和数组的值。没有进行引号/转码。</target>
        </trans-unit>
        <trans-unit id="574dd9dda7a4db9253b5e2f725c2efb60e57dfca" translate="yes" xml:space="preserve">
          <source>This method executes a &lt;code&gt;POST&lt;/code&gt; request and sends the key/value pairs from a form data hash or array reference to the given URL with a &lt;code&gt;content-type&lt;/code&gt; of &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;. If data is provided as an array reference, the order is preserved; if provided as a hash reference, the terms are sorted on key and value for consistency. See documentation for the &lt;code&gt;www_form_urlencode&lt;/code&gt; method for details on the encoding.</source>
          <target state="translated">此方法执行 &lt;code&gt;POST&lt;/code&gt; 请求和从表单数据散列或数组引用发送键/值对与一个给定的URL &lt;code&gt;content-type&lt;/code&gt; 的 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 。如果将数据作为数组引用提供，则顺序将保留；否则，将保留该顺序。如果作为哈希参考提供，则这些术语将按键和值进行排序以保持一致性。有关编码的详细信息，请参见 &lt;code&gt;www_form_urlencode&lt;/code&gt; 方法的文档。</target>
        </trans-unit>
        <trans-unit id="bf3b86793c28703b24d0cd86f4cd0ebea05c47fa" translate="yes" xml:space="preserve">
          <source>This method fully supports the use of the variable &lt;code&gt;$/&lt;/code&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) to determine what constitutes an end of line. Paragraph mode, record mode and file slurp mode are all supported.</source>
          <target state="translated">该方法完全支持使用可变的 &lt;code&gt;$/&lt;/code&gt; （或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 或 &lt;code&gt;$RS&lt;/code&gt; 当 &lt;code&gt;English&lt;/code&gt; 是在使用中），以确定什么构成线的端部。支持段落模式，记录模式和文件记录模式。</target>
        </trans-unit>
        <trans-unit id="7abd31a42f5dc198423e7bfa2a6a7d4410aa53a3" translate="yes" xml:space="preserve">
          <source>This method gets faster the more sparse the bit vector is. (Courtesy of Tim Bunce and Winfried Koenig.)</source>
          <target state="translated">这种方法在位向量越稀疏的情况下速度越快。(由Tim Bunce和Winfried Koenig提供)</target>
        </trans-unit>
        <trans-unit id="5106fbdd40086fe1994d026f8235d7c19445b51f" translate="yes" xml:space="preserve">
          <source>This method gets triggered during a keys() or each() iteration. It has a second argument which is the last key that had been accessed. This is useful if you're carrying about ordering or calling the iterator from more than one sequence, or not really storing things in a hash anywhere.</source>
          <target state="translated">这个方法在keys()或each()迭代时被触发。它的第二个参数是最后一个被访问的键。如果你从多个序列中进行排序或调用迭代器,或者不是真的把东西存储在哈希中,这个方法就很有用。</target>
        </trans-unit>
        <trans-unit id="c3ff1820eacb04c426d39d93923ba67e3009b83a" translate="yes" xml:space="preserve">
          <source>This method gets triggered during a keys(), values(), or each() iteration. It has a second argument which is the last key that had been accessed. This is useful if you're caring about ordering or calling the iterator from more than one sequence, or not really storing things in a hash anywhere.</source>
          <target state="translated">这个方法在keys()、values()或each()迭代时被触发。它的第二个参数是最后一个被访问的键。如果你关心的是排序或从多个序列中调用迭代器,或者不是真的把东西存储在哈希中,这个方法就很有用。</target>
        </trans-unit>
        <trans-unit id="2b32b03e834069c38c85e8165c3d6300a8ef2db8" translate="yes" xml:space="preserve">
          <source>This method gets/sets the children of the top node in the parse-tree. If no arguments are given, it returns the list (array) of children (each of which should be either a string or a &lt;b&gt;Pod::InteriorSequence&lt;/b&gt;. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">此方法获取/设置解析树中顶级节点的子级。如果未提供任何参数，则返回子项的列表（数组）（每个子项应为字符串或&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt;。否则，如果提供了参数，则将其视为顶部子项的新子级列表）节点。</target>
        </trans-unit>
        <trans-unit id="b46a6ad296dd61f630d70737a71545994d0ce79d" translate="yes" xml:space="preserve">
          <source>This method gets/sets the top node of the parse-tree. If no arguments are given, it returns the topmost node in the tree (the root), which is also a &lt;b&gt;Pod::ParseTree&lt;/b&gt;. If it is given a single argument that is a reference, then the reference is assumed to a parse-tree and becomes the new top node. Otherwise, if arguments are given, they are treated as the new list of children for the top node.</source>
          <target state="translated">此方法获取/设置解析树的顶部节点。如果未提供任何参数，它将返回树中的最高节点（根），该节点也是&lt;b&gt;Pod :: ParseTree&lt;/b&gt;。如果给定单个参数作为引用，则该引用将假定为解析树，并成为新的顶级节点。否则，如果给出参数，则将其视为顶部节点的新子级列表。</target>
        </trans-unit>
        <trans-unit id="59076bbdbb5b4ddcc87d5e0b9c9e7bca5153b33d" translate="yes" xml:space="preserve">
          <source>This method handles the body of text that is marked up to be code. You might for instance override this to plug in a syntax highlighter. The base implementation just escapes the text.</source>
          <target state="translated">这个方法处理被标记为代码的文本主体。例如,你可以重写这个方法来插入一个语法高亮器。基本实现只是对文本进行转义。</target>
        </trans-unit>
        <trans-unit id="7f7d4c41920dd2575a0ef9de52d6dfd4b083b3af" translate="yes" xml:space="preserve">
          <source>This method handles the body of text within any element: it's the body of a paragraph, or everything between a &quot;=begin&quot; tag and the corresponding &quot;=end&quot; tag, or the text within an L entity, etc. You would want to override this if you are adding a custom element type that does more than just display formatted text. Perhaps adding a way to generate HTML tables from an extended version of POD.</source>
          <target state="translated">这个方法可以处理任何元素中的文本主体:它是一个段落的主体,或者是&quot;=begin &quot;标签和相应的&quot;=end &quot;标签之间的所有内容,或者是一个L实体中的文本等等。如果你要添加一个自定义的元素类型,不仅仅是显示格式化的文本,你会想要覆盖这一点。或许可以添加一种从POD的扩展版本中生成HTML表格的方法。</target>
        </trans-unit>
        <trans-unit id="0712996dc1b8ffb7aa50e7d069711d277d763268" translate="yes" xml:space="preserve">
          <source>This method has exactly the same effect as</source>
          <target state="translated">这种方法的效果与</target>
        </trans-unit>
        <trans-unit id="03288e53528cfed00d63abe3d07013f706a98859" translate="yes" xml:space="preserve">
          <source>This method implements Knuth's up-arrow notation, where $n is a non-negative integer representing the number of up-arrows. $n = 0 gives multiplication, $n = 1 gives exponentiation, $n = 2 gives tetration, $n = 3 gives hexation etc. The following illustrates the relation between the first values of $n.</source>
          <target state="translated">本方法实现了Knuth的上箭头符号,其中$n是一个非负整数,代表上箭头的数量。$n=0表示乘法,$n=1表示指数化,$n=2表示渗透,$n=3表示十六进制等。下面说明$n的前几个值之间的关系。</target>
        </trans-unit>
        <trans-unit id="95de431069522c19f38db980946a01f82a5e48b0" translate="yes" xml:space="preserve">
          <source>This method implements the Ackermann function:</source>
          <target state="translated">本方法实现了Ackermann函数。</target>
        </trans-unit>
        <trans-unit id="d7edf847e8421397b7662e4de22753376978e152" translate="yes" xml:space="preserve">
          <source>This method is a stopgap until we can incorporate code into this extension to traverse the process' symbol table directly, so it may disappear in a future version of this package.</source>
          <target state="translated">这个方法是一个权宜之计,直到我们可以在这个扩展中加入代码来直接遍历进程的符号表,所以它可能会在这个包的未来版本中消失。</target>
        </trans-unit>
        <trans-unit id="065b0a15e17527d35032fe1e6828915d084d4b0d" translate="yes" xml:space="preserve">
          <source>This method is a synonym for &lt;code&gt;actual_passed&lt;/code&gt; .</source>
          <target state="translated">此方法是 &lt;code&gt;actual_passed&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="95d568c5372d8395dc875c9dc86c1185a887187b" translate="yes" xml:space="preserve">
          <source>This method is a synonym for &lt;code&gt;actual_passed&lt;/code&gt;.</source>
          <target state="translated">此方法是 &lt;code&gt;actual_passed&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="b1bd4d79c24738b6fd010c8a56304f2578c0ca9b" translate="yes" xml:space="preserve">
          <source>This method is available to all &lt;code&gt;IO::Socket&lt;/code&gt; implementations but may or may not be used by the individual domain subclasses.</source>
          <target state="translated">此方法可用于所有 &lt;code&gt;IO::Socket&lt;/code&gt; 实现，但各个域子类可能会或可能不会使用。</target>
        </trans-unit>
        <trans-unit id="a3a66a71f2968f9c82df6782744ec138e9c54cf9" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used as a string.</source>
          <target state="translated">当对象被用作字符串时,本方法会被自动调用。</target>
        </trans-unit>
        <trans-unit id="a819fa8543b1fdd50426768934ef9b1f1b767855" translate="yes" xml:space="preserve">
          <source>This method is called automatically when the object is used in string context.</source>
          <target state="translated">当该对象在字符串上下文中使用时,该方法会自动调用。</target>
        </trans-unit>
        <trans-unit id="ac138a74ffc74278892e510893352f2e36c5d5e7" translate="yes" xml:space="preserve">
          <source>This method is called by &lt;code&gt;response&lt;/code&gt; as a method with one argument. It should return an array of 2 values, the 3-digit status code and a flag which is true when this is part of a multi-line response and this line is not the last.</source>
          <target state="translated">&lt;code&gt;response&lt;/code&gt; 将此方法称为带有一个参数的方法。它应返回2个值的数组，3位状态代码和一个标志，当它是多行响应的一部分并且不是最后一行时，则为true。</target>
        </trans-unit>
        <trans-unit id="caa6afaab7cedc695e3c6f58f69b2ab8274688f3" translate="yes" xml:space="preserve">
          <source>This method is called during construction by &lt;code&gt;IO::Pipe::new&lt;/code&gt; on the newly created &lt;code&gt;IO::Pipe&lt;/code&gt; object. It returns an array of two objects blessed into &lt;code&gt;IO::Pipe::End&lt;/code&gt; , or a subclass thereof.</source>
          <target state="translated">在构造期间，由新创建的 &lt;code&gt;IO::Pipe&lt;/code&gt; 对象上的 &lt;code&gt;IO::Pipe::new&lt;/code&gt; 调用此方法。它返回祝福给 &lt;code&gt;IO::Pipe::End&lt;/code&gt; 或其子类的两个对象组成的数组。</target>
        </trans-unit>
        <trans-unit id="802fcb0eb2882b26bc56d5bf7fddba3f3126ee6f" translate="yes" xml:space="preserve">
          <source>This method is called during construction by &lt;code&gt;IO::Pipe::new&lt;/code&gt; on the newly created &lt;code&gt;IO::Pipe&lt;/code&gt; object. It returns an array of two objects blessed into &lt;code&gt;IO::Pipe::End&lt;/code&gt;, or a subclass thereof.</source>
          <target state="translated">在构造期间，由新创建的 &lt;code&gt;IO::Pipe&lt;/code&gt; 对象上的 &lt;code&gt;IO::Pipe::new&lt;/code&gt; 调用此方法。它返回祝福给 &lt;code&gt;IO::Pipe::End&lt;/code&gt; 或其子类的两个对象组成的数组。</target>
        </trans-unit>
        <trans-unit id="5287b2e5ba98e503e67859e5f2d01d79cbfa6c5e" translate="yes" xml:space="preserve">
          <source>This method is called to print debugging information. TEXT is the text being sent. The method should return the text to be printed.</source>
          <target state="translated">调用本方法打印调试信息。TEXT是被发送的文本。本方法应返回要打印的文本。</target>
        </trans-unit>
        <trans-unit id="2804b4df08740bd5a57eb70c9cfa0a8dcbe84738" translate="yes" xml:space="preserve">
          <source>This method is called when Math::BigFloat encounters an object it doesn't know how to handle. For instance, assume $x is a Math::BigFloat, or subclass thereof, and $y is defined, but not a Math::BigFloat, or subclass thereof. If you do</source>
          <target state="translated">当Math::BigFloat遇到一个它不知道如何处理的对象时,就会调用这个方法。例如,假设 $x 是一个 Math::BigFloat 或其子类,而 $y 被定义,但不是一个 Math::BigFloat 或其子类。如果你做</target>
        </trans-unit>
        <trans-unit id="f167b29ab442c8210c9356c7997b2fd2247776b0" translate="yes" xml:space="preserve">
          <source>This method is called when the handle is read via &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; .</source>
          <target state="translated">通过 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; HANDLE&lt;/code&gt; 读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="2a8681e541d8a457af5b2a8ca5d7fb05501b6037" translate="yes" xml:space="preserve">
          <source>This method is called when the handle is read via &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; or &lt;code&gt;readline HANDLE&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 或 &lt;code&gt;readline HANDLE&lt;/code&gt; 读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="c6629dc17ac853da211380c0f404bf1fca26aed1" translate="yes" xml:space="preserve">
          <source>This method is called with two arguments: the relevant package name, and a reference to a variable or subroutine for which package-defined attributes are desired. The expected return value is a list of associated attributes. This list may be empty.</source>
          <target state="translated">这个方法的调用有两个参数:相关的包名,以及对需要包定义属性的变量或子程序的引用。预期的返回值是一个相关属性的列表。这个列表可以是空的。</target>
        </trans-unit>
        <trans-unit id="45320fc2f3e3a4eca2479ec9f217dfab3504ebe5" translate="yes" xml:space="preserve">
          <source>This method is called with two fixed arguments, followed by the list of attributes from the relevant declaration. The two fixed arguments are the relevant package name and a reference to the declared subroutine or variable. The expected return value is a list of attributes which were not recognized by this handler. Note that this allows for a derived class to delegate a call to its base class, and then only examine the attributes which the base class didn't already handle for it.</source>
          <target state="translated">这个方法的调用有两个固定参数,后面是相关声明的属性列表。两个固定参数是相关的包名和对声明的子程序或变量的引用。预期的返回值是一个没有被该处理程序识别的属性列表。请注意,这允许派生类将调用委托给它的基类,然后只检查基类没有为它处理的属性。</target>
        </trans-unit>
        <trans-unit id="6abefc963006076df05b84dfc6d2811ce9f6040b" translate="yes" xml:space="preserve">
          <source>This method is deprecated if running under Perl 5.8, and is no longer present if running under Perl 5.9</source>
          <target state="translated">如果在Perl 5.8下运行,此方法已被废弃,如果在Perl 5.9下运行,此方法也不再存在。</target>
        </trans-unit>
        <trans-unit id="5c663722b6a1ec14ffe0820b635acf25e140b2e8" translate="yes" xml:space="preserve">
          <source>This method is invoked after gathering up all the lines in a paragraph and after determining the cutting state of the paragraph, but before trying to further parse or interpret them. After &lt;b&gt;preprocess_paragraph()&lt;/b&gt; returns, the current cutting state (which is returned by &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; ) is examined. If it evaluates to true then input text (including the given &lt;code&gt;$text&lt;/code&gt; ) is cut (not processed) until the next POD directive is encountered.</source>
          <target state="translated">在收集段落中的所有行之后，在确定段落的剪切状态之后，但是在尝试进一步解析或解释它们之前，将调用此方法。返回&lt;b&gt;preprocess_paragraph（）&lt;/b&gt;后，将检查当前的切割状态（由 &lt;code&gt;$self-&amp;gt;cutting()&lt;/code&gt; ）。如果计算结果为true，则输入文本（包括给定的 &lt;code&gt;$text&lt;/code&gt; ）将被剪切（不处理），直到遇到下一个POD指令为止。</target>
        </trans-unit>
        <trans-unit id="10379a9139313cde9e23b44b9d3191ab35fe83cb" translate="yes" xml:space="preserve">
          <source>This method is invoked at the beginning of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document initialization.</source>
          <target state="translated">在处理开始时,对输入中遇到的每个POD文档都会调用这个方法。子类应该重写这个方法来执行任何每个文档的初始化。</target>
        </trans-unit>
        <trans-unit id="413604196761a8f6291ef93425b6ff6c449d0805" translate="yes" xml:space="preserve">
          <source>This method is invoked at the end of processing for each POD document that is encountered in the input. Subclasses should override this method to perform any per-document finalization.</source>
          <target state="translated">在处理结束时,对输入中遇到的每个POD文档都会调用这个方法。子类应该重写这个方法来执行任何每个文档的最终处理。</target>
        </trans-unit>
        <trans-unit id="c39c6b3f4be6d469d8afebc0b47e837d73cf3993" translate="yes" xml:space="preserve">
          <source>This method is invoked by &lt;b&gt;parse_from_filehandle()&lt;/b&gt; immediately</source>
          <target state="translated">&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;立即调用此方法</target>
        </trans-unit>
        <trans-unit id="6747dae8cbf5615de1cf353ad79e0a07cee8a900" translate="yes" xml:space="preserve">
          <source>This method is less often useful. It assumes that the string stored in the struct is null-terminated, and disregards the length information.</source>
          <target state="translated">这种方法不太有用。它假设存储在结构体中的字符串是空端的,并且不考虑长度信息。</target>
        </trans-unit>
        <trans-unit id="2f27eac3492ebadd4d8f82dcb6d874e3db599873" translate="yes" xml:space="preserve">
          <source>This method is no longer used and can be omitted. Methods that are not implemented by a subclass will be inherited from this class.</source>
          <target state="translated">这个方法不再使用,可以省略。未被子类实现的方法将从本类继承。</target>
        </trans-unit>
        <trans-unit id="c79ad557d9b0fbcd0831200e697c308d8d3ffa30" translate="yes" xml:space="preserve">
          <source>This method is non-blocking, and will return only as many items as are available to fulfill the request:</source>
          <target state="translated">这个方法是非阻塞的,将只返回可用来满足请求的项目数量。</target>
        </trans-unit>
        <trans-unit id="6fb78fde591144d3983cff09b4ae34dcd5c3fb9d" translate="yes" xml:space="preserve">
          <source>This method is not present if running under Perl 5.9, as the PMROOT information is no longer stored directly in the hash.</source>
          <target state="translated">如果在Perl 5.9下运行,这个方法就不存在了,因为PMROOT信息不再直接存储在哈希中。</target>
        </trans-unit>
        <trans-unit id="f1244eb4316f69131f6963e6774a849bda60f19c" translate="yes" xml:space="preserve">
          <source>This method is of no use for general Perl threads programming. Its intent is to provide other (XS-based) thread modules with the capability to access, and possibly manipulate, the underlying thread structure associated with a Perl thread.</source>
          <target state="translated">这个方法对一般的Perl线程编程没有用处。它的目的是为其他(基于XS的)线程模块提供访问并可能操作与Perl线程相关联的底层线程结构的能力。</target>
        </trans-unit>
        <trans-unit id="21dc78ea221a1896dd75e4ea5a218dfbc7c4df02" translate="yes" xml:space="preserve">
          <source>This method is protected and not intended to be called outside of MakeMaker.</source>
          <target state="translated">这个方法是受保护的,不打算在MakeMaker之外调用。</target>
        </trans-unit>
        <trans-unit id="e5a20cfe7a533839e6244ee0ceb882a48e01de5e" translate="yes" xml:space="preserve">
          <source>This method is similar to share() but allows you to explicitly name the package that symbols should be shared from. The symbol names (including type characters) are supplied as an array reference.</source>
          <target state="translated">这个方法类似于share(),但允许你明确地命名应该从哪个包共享符号。符号名称(包括类型字符)作为一个数组引用提供。</target>
        </trans-unit>
        <trans-unit id="f5a57d1e0f15bd04707c86271032904c47bf2e9b" translate="yes" xml:space="preserve">
          <source>This method is the one you usually want. It constructs a string using the length and offset information in the struct: for ordinary scalars it will return the string that you'd see from Perl, even if it contains null characters.</source>
          <target state="translated">这个方法是你通常需要的方法,它使用结构体中的长度和偏移量信息构造一个字符串。它使用结构中的长度和偏移量信息构造一个字符串:对于普通的标量,它将返回你在Perl中看到的字符串,即使它包含空字符。</target>
        </trans-unit>
        <trans-unit id="01115bf69ddf4deb1227d201ea74e47486095d25" translate="yes" xml:space="preserve">
          <source>This method is triggered when a tied hash is about to go out of scope. You don't really need it unless you're trying to add debugging or have auxiliary state to clean up. Here's a very simple function:</source>
          <target state="translated">当一个绑定的哈希即将超出范围时,这个方法会被触发。你并不真的需要它,除非你想增加调试或者有辅助状态需要清理。这里有一个非常简单的函数。</target>
        </trans-unit>
        <trans-unit id="2987f28dec8ef9effc2010b2cf05de3e78ff66c2" translate="yes" xml:space="preserve">
          <source>This method is triggered when the user uses the exists() function on a particular hash. In our example, we'll look at the &lt;code&gt;{LIST}&lt;/code&gt; hash element for this:</source>
          <target state="translated">当用户在特定哈希上使用exist（）函数时，将触发此方法。在我们的示例中，我们将为此查看 &lt;code&gt;{LIST}&lt;/code&gt; 哈希元素：</target>
        </trans-unit>
        <trans-unit id="642b5a68b22f43aa4631e9ecbebcec5f49cf6aa8" translate="yes" xml:space="preserve">
          <source>This method is triggered when the whole hash is to be cleared, usually by assigning the empty list to it.</source>
          <target state="translated">当要清除整个哈希时,这个方法就会被触发,通常是将空列表分配给它。</target>
        </trans-unit>
        <trans-unit id="b7c5e76fa8c5d820b269407c2691745bfe513299" translate="yes" xml:space="preserve">
          <source>This method is triggered when we remove an element from the hash, typically by using the delete() function. Again, we'll be careful to check whether they really want to clobber files.</source>
          <target state="translated">当我们从哈希中删除一个元素时,这个方法就会被触发,通常是通过使用delete()函数。同样,我们要注意检查他们是否真的要clobber文件。</target>
        </trans-unit>
        <trans-unit id="d44b267a60e501cab8cef2efaa122beb61916cef" translate="yes" xml:space="preserve">
          <source>This method is used to add to the currently selected sections and subsections of POD documentation that are to be printed and/or processed. See &amp;lt;select()&amp;gt; for replacing the currently selected sections.</source>
          <target state="translated">此方法用于将要打印和/或处理的POD文档添加到当前选定的部分和子部分。请参见&amp;lt;select（）&amp;gt;替换当前选定的部分。</target>
        </trans-unit>
        <trans-unit id="79298df7a94b5d243fe4caa12d96cacff3087b81" translate="yes" xml:space="preserve">
          <source>This method is used to determine if the block of text given in &lt;code&gt;$paragraph&lt;/code&gt; falls within the currently selected set of POD sections and subsections to be printed or processed. This method is also responsible for keeping track of the current input section and subsections. It is assumed that &lt;code&gt;$paragraph&lt;/code&gt; is the most recently read (but not yet processed) input paragraph.</source>
          <target state="translated">此方法用于确定 &lt;code&gt;$paragraph&lt;/code&gt; 给定的文本块是否属于要打印或处理的POD部分和子部分的当前选定集合。此方法还负责跟踪当前输入节和子节。假定 &lt;code&gt;$paragraph&lt;/code&gt; 是最近读取（但尚未处理）的输入段落。</target>
        </trans-unit>
        <trans-unit id="cb88ba93625bb2592aeeb6754a8b29bf08054638" translate="yes" xml:space="preserve">
          <source>This method is used to load a facet by name (or key). It will attempt to load the facet class, if it succeeds it will return the class it loaded. If it fails it will return &lt;code&gt;undef&lt;/code&gt;. This caches the result at the class level so that future calls will be faster.</source>
          <target state="translated">此方法用于按名称（或键）加载构面。它将尝试加载facet类，如果成功，它将返回其加载的类。如果失败，它将返回 &lt;code&gt;undef&lt;/code&gt; 。这会将结果缓存在类级别，以便将来的调用会更快。</target>
        </trans-unit>
        <trans-unit id="bbbe3e628f204e314a28a9c25f8f03f14e0f6464" translate="yes" xml:space="preserve">
          <source>This method is used to select the particular sections and subsections of POD documentation that are to be printed and/or processed. The existing set of selected sections is</source>
          <target state="translated">此方法用于选择要打印和/或处理的POD文件的特定部分和子部分。现有的选定章节集是</target>
        </trans-unit>
        <trans-unit id="bef747284ac03954e21b22973b38b9cf4e4e7f3d" translate="yes" xml:space="preserve">
          <source>This method is useful if you need to perform your own interpolation of interior sequences and can't rely upon &lt;b&gt;interpolate&lt;/b&gt; to expand them in simple bottom-up order.</source>
          <target state="translated">如果您需要对内部序列执行自己的插值并且不能依赖于&lt;b&gt;插值&lt;/b&gt;以简单的自底向上的顺序扩展它们，则此方法很有用。</target>
        </trans-unit>
        <trans-unit id="49a58cbb089494a695c730a567717e544a3c0dd9" translate="yes" xml:space="preserve">
          <source>This method isn't terribly useful since modules which share the same Test::Builder object might get exported to different packages and only the last one will be honored.</source>
          <target state="translated">这个方法并不是很有用,因为共享同一个Test::Builder对象的模块可能会被导出到不同的包中,只有最后一个才会被尊重。</target>
        </trans-unit>
        <trans-unit id="5c881172eff7368918f5da216c5dcea0fcc3039d" translate="yes" xml:space="preserve">
          <source>This method joins together all requirements across a number of phases and types into a new &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN::Meta::Requirements&lt;/a&gt; object. If arguments are omitted, it defaults to &quot;runtime&quot;, &quot;build&quot; and &quot;test&quot; for phases and &quot;requires&quot; and &quot;recommends&quot; for types.</source>
          <target state="translated">此方法将跨越多个阶段和类型的所有需求连接到一个新的&lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN :: Meta :: Requirements&lt;/a&gt;对象中。如果省略了参数，则对于阶段默认为&amp;ldquo;运行时&amp;rdquo;，&amp;ldquo;构建&amp;rdquo;和&amp;ldquo;测试&amp;rdquo;，对于类型则默认为&amp;ldquo; requires&amp;rdquo;和&amp;ldquo; recommends&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="6554ac6945a5df20c377de63d8de44dbce743773" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;../perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">此方法关键字记录&lt;a href=&quot;../perlobj#Destructors&quot;&gt;在perlobj的Destructors中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="661a4e6337bec9fa5b81482e46ab4bf4c5f238c8" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;perlobj#Destructors&quot;&gt;&quot;Destructors&quot; in perlobj&lt;/a&gt;.</source>
          <target state="translated">此方法关键字记录&lt;a href=&quot;perlobj#Destructors&quot;&gt;在perlobj的&amp;ldquo;析构函数&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e359554a4d991920df0d798d38cb8b6bf47ec29" translate="yes" xml:space="preserve">
          <source>This method keyword is documented in &lt;a href=&quot;perlobj#Destructors&quot;&gt;Destructors in perlobj&lt;/a&gt;.</source>
          <target state="translated">此方法关键字记录&lt;a href=&quot;perlobj#Destructors&quot;&gt;在perlobj的Destructors中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c21da25dd954f9e366c6cef85d1af33e75fddf8f" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually failed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际上是失败的,不管是否找到了TODO指令。</target>
        </trans-unit>
        <trans-unit id="a2b6c5d7eeef2dcb58cd2d68cdfe40caf21f8820" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed but were declared as &quot;TODO&quot; tests.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际通过了,但被声明为 &quot;TODO &quot;测试。</target>
        </trans-unit>
        <trans-unit id="08a5db262046c866f7d810a5b71d8ec989df7d80" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests actually passed, regardless of whether or not a TODO directive was found.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试实际通过了,不管是否找到了TODO指令。</target>
        </trans-unit>
        <trans-unit id="7562f7ac693aec459c0c9b344acb705680f1f7f7" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests failed. If a test passed but had a TODO directive, it will &lt;b&gt;NOT&lt;/b&gt; be counted as a failed test.</source>
          <target state="translated">此方法使您知道哪些（或多少）个测试失败。如果测试通过但具有TODO指令，则&lt;b&gt;不会&lt;/b&gt;被视为失败测试。</target>
        </trans-unit>
        <trans-unit id="b1956c9e443594eef5939e2522e06e528138f73a" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had SKIP directives.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试有SKIP指令。</target>
        </trans-unit>
        <trans-unit id="d552dee0411d16f26c2347ec73027455bcd691a0" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests had TODO directives.</source>
          <target state="translated">这个方法可以让你知道哪些(或多少)测试有TODO指令。</target>
        </trans-unit>
        <trans-unit id="62d19246ed330e746e1fe150131f18c164bb14d2" translate="yes" xml:space="preserve">
          <source>This method lets you know which (or how many) tests passed. If a test failed but had a TODO directive, it will be counted as a passed test.</source>
          <target state="translated">这个方法让你知道哪些(或多少)测试通过了。如果一个测试失败了,但有TODO指令,它将被算作一个通过的测试。</target>
        </trans-unit>
        <trans-unit id="5cdb3f6929d50bb5330f8f315f2338f1cd8897fc" translate="yes" xml:space="preserve">
          <source>This method marks the requirements finalized. Subsequent attempts to change the requirements will be fatal,</source>
          <target state="translated">这种方法标志着需求已经确定。此后再试图改变需求将是致命的。</target>
        </trans-unit>
        <trans-unit id="cc582265ee4f696fc9e8e3fad6147cf5023780c3" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a block of verbatim text is encountered. It is passed the following parameters:</source>
          <target state="translated">这个方法可以被子类重载,以便在遇到一块逐字文本时采取适当的行动。本方法的参数如下。</target>
        </trans-unit>
        <trans-unit id="2ef97fe79f3074bd51a79fd7f9a20c0d8326e891" translate="yes" xml:space="preserve">
          <source>This method may be overridden by subclasses to take the appropriate action when a normal block of POD text is encountered (although the base class method will usually do what you want). It is passed the following parameters:</source>
          <target state="translated">当遇到一个正常的POD文本块时,这个方法可以被子类重载,以采取适当的行动(尽管基类方法通常会做你想要的事情)。它被传递给以下参数。</target>
        </trans-unit>
        <trans-unit id="f193021bd1e2803e8135ddd336589fd3fdb1031b" translate="yes" xml:space="preserve">
          <source>This method merely runs the parser and parses all of the TAP.</source>
          <target state="translated">这个方法只是运行解析器并解析所有的TAP。</target>
        </trans-unit>
        <trans-unit id="d5b810a222612f34da5ba09951a3a157e593734d" translate="yes" xml:space="preserve">
          <source>This method only works on Perl v5.9.4 or later.</source>
          <target state="translated">这个方法只适用于Perl v5.9.4或更高版本。</target>
        </trans-unit>
        <trans-unit id="711e3f6546ee99d694d8611421083f48f729a0be" translate="yes" xml:space="preserve">
          <source>This method parses the passed in string and adds the appropriate requirement for the given module. A version can be a Perl &quot;v-string&quot;. It understands version ranges as described in the &lt;a href=&quot;CPAN::Meta::Spec#Version-Ranges&quot;&gt;&quot;Version Ranges&quot; in CPAN::Meta::Spec&lt;/a&gt;. For example:</source>
          <target state="translated">此方法解析传入的字符串，并为给定的模块添加适当的要求。一个版本可以是Perl的&amp;ldquo; v字符串&amp;rdquo;。它了解版本范围，如&lt;a href=&quot;CPAN::Meta::Spec#Version-Ranges&quot;&gt;CPAN :: Meta :: Spec&lt;/a&gt;的&amp;ldquo;版本范围&amp;rdquo;中所述。例如：</target>
        </trans-unit>
        <trans-unit id="3eb04a70399efe3a3bc64926ce7a5f07e9940d0a" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the interior-sequence. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">此方法对内部序列执行任何必要的清理。如果覆盖此方法，则&lt;b&gt;必须&lt;/b&gt;从自己的方法中调用父方法，否则</target>
        </trans-unit>
        <trans-unit id="714dcc55d92cf752f4b4184074298408c801245b" translate="yes" xml:space="preserve">
          <source>This method performs any necessary cleanup for the parse-tree. If you override this method then it is &lt;b&gt;imperative&lt;/b&gt; that you invoke the parent method from within your own method, otherwise</source>
          <target state="translated">此方法对解析树执行任何必要的清除。如果覆盖此方法，则&lt;b&gt;必须&lt;/b&gt;从自己的方法中调用父方法，否则</target>
        </trans-unit>
        <trans-unit id="094b13118759d86cdc1f33cdf2b7a72869820716" translate="yes" xml:space="preserve">
          <source>This method performs any necessary object initialization. It takes no arguments (other than the object instance of course, which is typically copied to a local variable named &lt;code&gt;$self&lt;/code&gt; ). If subclasses override this method then they</source>
          <target state="translated">此方法执行任何必要的对象初始化。它不带任何参数（当然不是对象实例，通常将其复制到名为 &lt;code&gt;$self&lt;/code&gt; 的局部变量中）。如果子类重写此方法，则它们</target>
        </trans-unit>
        <trans-unit id="1b4637e9cdcc1db5f14b9635de49858c878c102c" translate="yes" xml:space="preserve">
          <source>This method prepends the given text or parse-tree to the current parse-tree. If the first item on the parse-tree is text and the argument is also text, then the text is prepended to the first item (not added as a separate string). Otherwise the argument is added as a new string or parse-tree</source>
          <target state="translated">本方法将给定的文本或解析树预先加入到当前的解析树中。如果解析树上的第一项是文本,而参数也是文本,那么文本就会被预先添加到第一项中(而不是作为一个单独的字符串添加)。否则,参数将作为一个新的字符串或解析树被添加。</target>
        </trans-unit>
        <trans-unit id="843c78718fa264afa1695d6f64c3d712c49fd84a" translate="yes" xml:space="preserve">
          <source>This method prints the test as a string. It will probably be similar, but not necessarily identical, to the original test line. Directives are capitalized, some whitespace may be trimmed and a test number will be added if it was not present in the original line. If you need the original text of the test line, use the &lt;code&gt;raw&lt;/code&gt; method.</source>
          <target state="translated">此方法将测试打印为字符串。它可能与原始测试线相似，但不一定相同。指令使用大写字母，如果原始行中不存在测试编号，则可能会对其进行裁剪并添加测试编号。如果您需要测试行的原始文本，请使用 &lt;code&gt;raw&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c461db5fa5d2d546751540785c1da918e27ef9ee" translate="yes" xml:space="preserve">
          <source>This method processes an XS file and sends output to a C file. The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">该方法处理XS文件并将输出发送到C文件。该方法可以作为函数调用(这是传统的接口),然后将使用一个单人作为 invocant。</target>
        </trans-unit>
        <trans-unit id="443a8a4abd0996a8f53eec3622235de842b5198f" translate="yes" xml:space="preserve">
          <source>This method reconstructs the encoding object if necessary. If you need to store the state during encoding, this is where you clone your object.</source>
          <target state="translated">如果需要的话,这个方法可以重建编码对象。如果你需要存储编码期间的状态,这就是你克隆对象的地方。</target>
        </trans-unit>
        <trans-unit id="4be2e04731b97866ee5b4ac0d1bde14c1df759bd" translate="yes" xml:space="preserve">
          <source>This method returns 0 if the object can be modified with the given operation, or 1 if not.</source>
          <target state="translated">如果对象可以通过给定的操作进行修改,则此方法返回0,如果不能,则返回1。</target>
        </trans-unit>
        <trans-unit id="3441f0af9f59d5dc45617aeb66969ab6a0963d73" translate="yes" xml:space="preserve">
          <source>This method returns TRUE if the GP field of the GV is NULL.</source>
          <target state="translated">如果GV的GP字段为NULL,本方法返回TRUE。</target>
        </trans-unit>
        <trans-unit id="ecc3b6039f5ff097f5929abca6feaac0bb1a1360" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;a href=&quot;CPAN::Meta::Feature&quot;&gt;CPAN::Meta::Feature&lt;/a&gt; object for the optional feature with the given identifier. If no feature with that identifier exists, an exception will be raised.</source>
          <target state="translated">此方法返回具有给定标识符的可选功能部件的&lt;a href=&quot;CPAN::Meta::Feature&quot;&gt;CPAN :: Meta :: Feature&lt;/a&gt;对象。如果不存在具有该标识符的功能，则会引发异常。</target>
        </trans-unit>
        <trans-unit id="6c15f83b33ebe9626be021d25c41e755d48695b2" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN::Meta::Prereqs&lt;/a&gt; object describing all the prereqs for the distribution. If an arrayref of feature identifiers is given, the prereqs for the identified features are merged together with the distribution's core prereqs before the CPAN::Meta::Prereqs object is returned.</source>
          <target state="translated">此方法返回一个&lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN :: Meta :: Prereqs&lt;/a&gt;对象，该对象描述了分发的所有先决条件。如果给出了特征标识符的arrayref，则在返回CPAN :: Meta :: Prereqs对象之前，将已标识特征的先决条件与发行版的核心先决条件合并在一起。</target>
        </trans-unit>
        <trans-unit id="ccbe2a6326a123f59ab56735cf3ce21971d48ace" translate="yes" xml:space="preserve">
          <source>This method returns a &lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN::Meta::Requirements&lt;/a&gt; object for the given phase/type combination. If no prerequisites are registered for that combination, a new CPAN::Meta::Requirements object will be returned, and it may be added to as needed.</source>
          <target state="translated">此方法为给定的阶段/类型组合返回&lt;a href=&quot;CPAN::Meta::Requirements&quot;&gt;CPAN :: Meta :: Requirements&lt;/a&gt;对象。如果没有为该组合注册任何先决条件，则将返回一个新的CPAN :: Meta :: Requirements对象，并且可以根据需要将其添加到其中。</target>
        </trans-unit>
        <trans-unit id="cb173e29985a69e4c742ab91cf231ef598525ea6" translate="yes" xml:space="preserve">
          <source>This method returns a Prereqs object that is identical to the original object, but can be altered without affecting the original object. Finalization does not survive cloning, meaning that you may clone a finalized set of prereqs and then modify the clone.</source>
          <target state="translated">这个方法返回一个与原始对象相同的Prereqs对象,但可以在不影响原始对象的情况下进行修改。最终化不能在克隆后继续存在,这意味着你可以克隆一个最终化的Prereqs集,然后修改克隆的对象。</target>
        </trans-unit>
        <trans-unit id="8dc7e3cb1081d01b93496efbbf89c0031ab07cf1" translate="yes" xml:space="preserve">
          <source>This method returns a clone of the invocant. The clone and the original object can then be changed independent of one another.</source>
          <target state="translated">本方法返回调用者的克隆。克隆体和原始对象可以相互独立地改变。</target>
        </trans-unit>
        <trans-unit id="a660976840e65d0897ee15b1bb3e1d439893ed69" translate="yes" xml:space="preserve">
          <source>This method returns a deep copy of the object's metadata as an unblessed hash reference. It takes an optional hashref of options. If the hashref contains a &lt;code&gt;version&lt;/code&gt; argument, the copied metadata will be converted to the version of the specification and returned. For example:</source>
          <target state="translated">此方法返回对象元数据的深层副本作为无哈希值的哈希引用。它需要一个可选的hashref选项。如果hashref包含 &lt;code&gt;version&lt;/code&gt; 参数，则复制的元数据将转换为规范的版本并返回。例如：</target>
        </trans-unit>
        <trans-unit id="9d0124bb5624eddaaba9be0a0792e6b70917f5e9" translate="yes" xml:space="preserve">
          <source>This method returns a hashref containing structures suitable for dumping into a distmeta data structure. It is made up of hashes and strings, only; there will be no Prereqs, CPAN::Meta::Requirements, or &lt;code&gt;version&lt;/code&gt; objects inside it.</source>
          <target state="translated">此方法返回一个hashref，其中包含适合于转储为distmeta数据结构的结构。它仅由哈希和字符串组成；里面没有Prereqs，CPAN :: Meta :: Requirements或 &lt;code&gt;version&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="6eae8a85642b918b7b127321e5eaeb3c1f6a5f9d" translate="yes" xml:space="preserve">
          <source>This method returns a list of &lt;a href=&quot;CPAN::Meta::Feature&quot;&gt;CPAN::Meta::Feature&lt;/a&gt; objects, one for each optional feature described by the distribution's metadata.</source>
          <target state="translated">此方法返回&lt;a href=&quot;CPAN::Meta::Feature&quot;&gt;CPAN :: Meta :: Feature&lt;/a&gt;对象的列表，一个对应于分发元数据描述的每个可选功能的列表。</target>
        </trans-unit>
        <trans-unit id="ac97a18eb985efa8a4676cc3a8b597409e671815" translate="yes" xml:space="preserve">
          <source>This method returns a list of all the modules for which requirements have been specified.</source>
          <target state="translated">此方法返回所有已指定需求的模块列表。</target>
        </trans-unit>
        <trans-unit id="d7b58df6d5a2c18121bb505720d0e804af99a7dd" translate="yes" xml:space="preserve">
          <source>This method returns a list of the currently active section headings and subheadings in the document being parsed. The list of headings returned corresponds to the most recently parsed paragraph of the input.</source>
          <target state="translated">此方法返回正在解析的文档中当前有效的章节标题和副标题列表。返回的标题列表对应于输入中最近解析的段落。</target>
        </trans-unit>
        <trans-unit id="1845f64f5dff026e99802fb2b0ed9543ebdf51a7" translate="yes" xml:space="preserve">
          <source>This method returns a new CPAN::Meta object using the first document in the given YAML string. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="translated">此方法使用给定的YAML字符串中的第一个文档返回一个新的CPAN :: Meta对象。在其他方面，它与 &lt;code&gt;load_file()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="3273d3871ffcb26a5d4043675d561afe60f650f3" translate="yes" xml:space="preserve">
          <source>This method returns a new CPAN::Meta object using the structure represented by the given JSON string. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="translated">此方法使用给定JSON字符串表示的结构返回一个新的CPAN :: Meta对象。在其他方面，它与 &lt;code&gt;load_file()&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="02520ccc95c7235e07b3d427ec797731c99b95a2" translate="yes" xml:space="preserve">
          <source>This method returns a new CPAN::Meta::Prereqs objects in which all the other prerequisites given are merged into the current set. This is primarily provided for combining a distribution's core prereqs with the prereqs of one of its optional features.</source>
          <target state="translated">这个方法返回一个新的 CPAN::Meta::Prereqs 对象,在这个对象中,所有其他给定的先决条件都被合并到当前的集合中。这主要是为了将一个发行版的核心先决条件和它的一个可选特性的先决条件结合起来。</target>
        </trans-unit>
        <trans-unit id="26456adf48b8270a780502b4eaebd6bec5340107" translate="yes" xml:space="preserve">
          <source>This method returns a new set of Prereqs. The input should look like the contents of the &lt;code&gt;prereqs&lt;/code&gt; field described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;, meaning something more or less like this:</source>
          <target state="translated">此方法返回一组新的Prereq。输入应该看起来像&lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN :: Meta :: Spec中&lt;/a&gt;描述的 &lt;code&gt;prereqs&lt;/code&gt; 字段的内容，或多或少像这样：</target>
        </trans-unit>
        <trans-unit id="809605a8e893e3bde6161ec466a7256b077b2f58" translate="yes" xml:space="preserve">
          <source>This method returns a serialized copy of the object's metadata as a character string. (The strings are &lt;b&gt;not&lt;/b&gt; UTF-8 encoded.) It takes an optional hashref of options. If the hashref contains a &lt;code&gt;version&lt;/code&gt; argument, the copied metadata will be converted to the version of the specification and returned. For example:</source>
          <target state="translated">此方法以字符串形式返回对象元数据的序列化副本。（这些字符串&lt;b&gt;不是&lt;/b&gt;UTF-8编码的。）它带有可选的options的hashref。如果hashref包含 &lt;code&gt;version&lt;/code&gt; 参数，则复制的元数据将转换为规范的版本并返回。例如：</target>
        </trans-unit>
        <trans-unit id="dfd6da7f680f7708aaaafbe88d4fbd81537fbb12" translate="yes" xml:space="preserve">
          <source>This method returns either a hash reference (in scalar context) or a list or hash references (in array context) that contains information about each of the header fields in the compressed data stream(s).</source>
          <target state="translated">此方法返回一个哈希引用(在标量上下文中)或一个列表或哈希引用(在数组上下文中),其中包含压缩数据流中每个头字段的信息。</target>
        </trans-unit>
        <trans-unit id="5613e8d87481a66c6331ffba3f17e879703b23af" translate="yes" xml:space="preserve">
          <source>This method returns the &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; object associated with Your::Class. It is not a constructor so you can call it as often as you like.</source>
          <target state="translated">此方法返回与Your :: Class关联的&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;对象。它不是构造函数，因此您可以随意调用它。</target>
        </trans-unit>
        <trans-unit id="df2acf1db6d765e8b7af473cf018815f141ba1b9" translate="yes" xml:space="preserve">
          <source>This method returns the &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; object associated with Your::Class. It is not a constructor so you can call it as often as you like.</source>
          <target state="translated">此方法返回与Your :: Class关联的&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;对象。它不是构造函数，因此您可以随意调用它。</target>
        </trans-unit>
        <trans-unit id="c6ed5af13a1529fb7b65c36511f205e560c0e629" translate="yes" xml:space="preserve">
          <source>This method returns the AV specific flags. In Perl 5.9 these are now stored in with the main SV flags, so this method is no longer present.</source>
          <target state="translated">这个方法返回 AV 的特定标志。在Perl 5.9中,这些标志现在和主SV标志一起存储,所以这个方法不再存在。</target>
        </trans-unit>
        <trans-unit id="230f2b0705cb9c1bd36492ae8437541d92944923" translate="yes" xml:space="preserve">
          <source>This method returns the byte offset of the start of the &lt;code&gt;$n&lt;/code&gt; th record in the file. If there is no such record, it returns an undefined value.</source>
          <target state="translated">此方法返回文件中第 &lt;code&gt;$n&lt;/code&gt; 个记录的开始的字节偏移量。如果没有这样的记录，它将返回一个未定义的值。</target>
        </trans-unit>
        <trans-unit id="738895c1b07cd50df5407037de05d0561fa1ae9c" translate="yes" xml:space="preserve">
          <source>This method returns the byte offset of the start of the &lt;code&gt;$n&lt;/code&gt;th record in the file. If there is no such record, it returns an undefined value.</source>
          <target state="translated">此方法返回文件中第 &lt;code&gt;$n&lt;/code&gt; 个记录的开始的字节偏移量。如果没有这样的记录，它将返回一个未定义的值。</target>
        </trans-unit>
        <trans-unit id="5819846ea31de4c85ae8c84e9f4950b6d488925d" translate="yes" xml:space="preserve">
          <source>This method returns the currently stored JSON fragment as an lvalue, that is, you can manipulate it. This</source>
          <target state="translated">这个方法将当前存储的JSON片段作为一个l值返回,也就是说,你可以对它进行操作。这个</target>
        </trans-unit>
        <trans-unit id="1febcdc386a8d7c1d008e8e3e3986be768008da7" translate="yes" xml:space="preserve">
          <source>This method returns the feature's identifier.</source>
          <target state="translated">本方法返回特征的标识符。</target>
        </trans-unit>
        <trans-unit id="13ed7705e9d007aeb18dc15b134a8edd67224258" translate="yes" xml:space="preserve">
          <source>This method returns the feature's long description.</source>
          <target state="translated">本方法返回特征的长描述。</target>
        </trans-unit>
        <trans-unit id="a5202bb9ec86dc5db010454c975e82230a5006be" translate="yes" xml:space="preserve">
          <source>This method returns the feature's prerequisites as a &lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN::Meta::Prereqs&lt;/a&gt; object.</source>
          <target state="translated">此方法将功能的先决条件作为&lt;a href=&quot;CPAN::Meta::Prereqs&quot;&gt;CPAN :: Meta :: Prereqs&lt;/a&gt;对象返回。</target>
        </trans-unit>
        <trans-unit id="cda1e7a80b8c4ff8a50d7193bfa7f2353fb0bb3a" translate="yes" xml:space="preserve">
          <source>This method returns the internal length field, which consists of the number of internal bytes, not necessarily the number of logical characters.</source>
          <target state="translated">本方法返回内部长度字段,该字段由内部字节数组成,不一定是逻辑字符数。</target>
        </trans-unit>
        <trans-unit id="73630249386a32e1daa88a34d4ed3d64dadd0557" translate="yes" xml:space="preserve">
          <source>This method returns the list of all phases currently populated in the prereqs object, suitable for iterating.</source>
          <target state="translated">此方法返回当前在prereqs对象中填充的所有相位的列表,适合迭代。</target>
        </trans-unit>
        <trans-unit id="a69b31bb0a594a163fa02bab7ede41d8139fbcc3" translate="yes" xml:space="preserve">
          <source>This method returns the list of all types currently populated in the prereqs object for the provided phase, suitable for iterating.</source>
          <target state="translated">此方法返回当前在所提供阶段的prereqs对象中填充的所有类型的列表,适合迭代。</target>
        </trans-unit>
        <trans-unit id="3195470feffd08399489b4ea58a94cbd49fb15f2" translate="yes" xml:space="preserve">
          <source>This method returns the name of the glob, but if the first character of the name is a control character, then it converts it to ^X first, so that *^G would return &quot;^G&quot; rather than &quot;\cG&quot;.</source>
          <target state="translated">该方法返回glob的名称,但如果名称的第一个字符是控制字符,则先将其转换为^X,所以*^G将返回&quot;^G &quot;而不是&quot;\cG&quot;。</target>
        </trans-unit>
        <trans-unit id="d436f65e4ac4dfd0f8045b3c54271c25339bbf38" translate="yes" xml:space="preserve">
          <source>This method returns the name of the package that is the root of the compartment's namespace.</source>
          <target state="translated">这个方法返回的是作为隔间命名空间根的包的名称。</target>
        </trans-unit>
        <trans-unit id="b1039ff3465ca6dc27db9b5d11bc6e35d5848fc0" translate="yes" xml:space="preserve">
          <source>This method returns the number of [a certain kind of] errors encountered during processing of the XS file.</source>
          <target state="translated">本方法返回XS文件处理过程中遇到的[某种]错误数量。</target>
        </trans-unit>
        <trans-unit id="0d20c8d8462990e4c532228bf94cacc069885810" translate="yes" xml:space="preserve">
          <source>This method returns the number of bytes allocated (via malloc) for storing the string. This is 0 if the scalar does not &quot;own&quot; the string.</source>
          <target state="translated">本方法返回为存储字符串分配的字节数(通过malloc)。如果标量不 &quot;拥有 &quot;字符串,则返回0。</target>
        </trans-unit>
        <trans-unit id="01d67962853aa369d48416e10b895f4851d158db" translate="yes" xml:space="preserve">
          <source>This method returns the requirements object.</source>
          <target state="translated">本方法返回需求对象。</target>
        </trans-unit>
        <trans-unit id="dc49b5d5eff536554a52d021b3411834001a3a6e" translate="yes" xml:space="preserve">
          <source>This method returns the results of the parsing, one result at a time. Note that it is destructive. You can't rewind and examine previous results.</source>
          <target state="translated">这个方法每次只返回一个结果的解析结果。注意,它是破坏性的。你不能倒带和检查以前的结果。</target>
        </trans-unit>
        <trans-unit id="0ab9ad920897cda27f5f563bb7197ba468b33916" translate="yes" xml:space="preserve">
          <source>This method returns the textual representation of the hyperlink as above, but without markers (read only). Depending on the link type this is one of the following alternatives (the + and * denote the portions of the text that are marked up):</source>
          <target state="translated">此方法返回超链接的文本表示,如上所述,但没有标记(只读)。根据链接类型的不同,它是以下选项之一(+和*表示文本中被标记的部分)。</target>
        </trans-unit>
        <trans-unit id="59c2ab7b96065dfd63ce37b4f21c2d16dce7d68c" translate="yes" xml:space="preserve">
          <source>This method returns the value of the IV as an integer. It differs from &lt;code&gt;IV&lt;/code&gt; in that it returns the correct value regardless of whether it's stored signed or unsigned.</source>
          <target state="translated">此方法以整数形式返回IV的值。它与 &lt;code&gt;IV&lt;/code&gt; 的不同之处在于，无论存储的是带符号的还是无符号的，它都返回正确的值。</target>
        </trans-unit>
        <trans-unit id="cd2332acd3062dbe524d95a2c5676842caa361ce" translate="yes" xml:space="preserve">
          <source>This method returns the version part of the &lt;code&gt;meta_spec&lt;/code&gt; entry in the distmeta structure. It is equivalent to:</source>
          <target state="translated">此方法在distmeta结构中返回 &lt;code&gt;meta_spec&lt;/code&gt; 条目的版本部分。它等效于：</target>
        </trans-unit>
        <trans-unit id="097409eeb19e4610fc16463aab58579acca93a37" translate="yes" xml:space="preserve">
          <source>This method returns true if and only if all requirements are inclusive minimums -- that is, if their string expression is just the version number.</source>
          <target state="translated">如果且仅如果所有的需求都是包含最小值--也就是说,如果它们的字符串表达式只是版本号,那么这个方法返回true。</target>
        </trans-unit>
        <trans-unit id="bd9d9f9dc3232d40e9c79f888b628345d7669615" translate="yes" xml:space="preserve">
          <source>This method returns true if the given file should be indexed. It decides this by checking the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;directory&lt;/code&gt; keys in the &lt;code&gt;no_index&lt;/code&gt; property of the distmeta structure. Note that neither the version format nor &lt;code&gt;release_status&lt;/code&gt; are considered.</source>
          <target state="translated">如果给定文件索引，则此方法返回true。它通过检查distmeta结构的 &lt;code&gt;no_index&lt;/code&gt; 属性中的 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;directory&lt;/code&gt; 键来决定这一点。请注意，既不考虑版本格式也不考虑 &lt;code&gt;release_status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58ff6d5b8ce053e96c242fd66e092358e70ec413" translate="yes" xml:space="preserve">
          <source>This method returns true if the given package should be indexed. It decides this by checking the &lt;code&gt;package&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; keys in the &lt;code&gt;no_index&lt;/code&gt; property of the distmeta structure. Note that neither the version format nor &lt;code&gt;release_status&lt;/code&gt; are considered.</source>
          <target state="translated">如果给定的程序包建立索引，则此方法返回true。它通过检查distmeta结构的 &lt;code&gt;no_index&lt;/code&gt; 属性中的 &lt;code&gt;package&lt;/code&gt; 和 &lt;code&gt;namespace&lt;/code&gt; 键来决定这一点。请注意，既不考虑版本格式也不考虑 &lt;code&gt;release_status&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="740035cd86ced51cb784444de5c3729bee91714e" translate="yes" xml:space="preserve">
          <source>This method returns true if the requirements have been finalized by having the &lt;code&gt;finalize&lt;/code&gt; method called on them.</source>
          <target state="translated">如果通过调用 &lt;code&gt;finalize&lt;/code&gt; 方法来确定需求，则此方法返回true 。</target>
        </trans-unit>
        <trans-unit id="91378c22b7ed1b00b6fef0cff4776f78b85e7e4b" translate="yes" xml:space="preserve">
          <source>This method returns true if the set of prereqs has been marked &quot;finalized,&quot; and cannot be altered.</source>
          <target state="translated">如果预设值集已被标记为 &quot;最终确定&quot;,并且不能更改,则此方法返回true。</target>
        </trans-unit>
        <trans-unit id="1569bccb9cee6a2175f9b489178e6d0824ba382b" translate="yes" xml:space="preserve">
          <source>This method sets or returns the POD page this link points to.</source>
          <target state="translated">此方法设置或返回此链接指向的POD页面。</target>
        </trans-unit>
        <trans-unit id="5626475bc6df98d403b9b1a4c6d8bd8eead196ba" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 15 for 7.5-point) that the header on each page will appear in. The header is usually just &quot;</source>
          <target state="translated">这个方法可以设置每页页眉的大小(以半点为单位,比如7.5点的15点)。页眉通常只有&quot;</target>
        </trans-unit>
        <trans-unit id="49562bbb9cccfd05b2f9dd5f5c25626dc9296a99" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 21 for 10.5-point) that codeblocks (&quot;verbatim sections&quot;) will appear as.</source>
          <target state="translated">本方法设置代码块(&quot;逐字节&quot;)的大小(以半点为单位,如10.5点的21点)。</target>
        </trans-unit>
        <trans-unit id="b751a506f13c7e1535b7f83c798a478f8a346484" translate="yes" xml:space="preserve">
          <source>This method sets the size (in half-points, like 26 for 13-point) that normal paragraphic text will appear in.</source>
          <target state="translated">此方法设置正常段落文字的大小(以半点为单位,如26点为13点)。</target>
        </trans-unit>
        <trans-unit id="4a47dc314786b539ecdca5143ef23b8e1941b547" translate="yes" xml:space="preserve">
          <source>This method should</source>
          <target state="translated">此方法应</target>
        </trans-unit>
        <trans-unit id="a1c0bdcb0359edd01294194cece7860e3da71acb" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each</source>
          <target state="translated">这个方法应该被希望对每个</target>
        </trans-unit>
        <trans-unit id="4045b5b845e6b96a3e7f9e9b3149fb374504376e" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses that wish to perform any kind of preprocessing for each block (paragraph) of POD documentation that appears in the input stream. The parameter &lt;code&gt;$text&lt;/code&gt; is the POD paragraph from the input file; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number for the beginning of the corresponding paragraph.</source>
          <target state="translated">希望对输入流中出现的POD文档的每个块（段）执行任何类型的预处理的子类都应重写此方法。参数 &lt;code&gt;$text&lt;/code&gt; 是输入文件中的POD段落；参数 &lt;code&gt;$line_num&lt;/code&gt; 是相应段落开头的行号。</target>
        </trans-unit>
        <trans-unit id="517b86d5501e13cc5ca0478526d9e56418238e3c" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when a POD command paragraph (denoted by a line beginning with &quot;=&quot;) is encountered. When such a POD directive is seen in the input, this method is called and is passed:</source>
          <target state="translated">当遇到POD指令段(用&quot;=&quot;开头的行表示)时,子类应重载此方法,以采取相应的操作。当在输入中看到这样的POD指令时,就会调用本方法,并将其传递给。</target>
        </trans-unit>
        <trans-unit id="4057fa0aee2966d0f3fb518e4370c12ff228c00a" translate="yes" xml:space="preserve">
          <source>This method should be overridden by subclasses to take the appropriate action when an interior sequence is encountered. An interior sequence is an embedded command within a block of text which appears as a command name (usually a single uppercase character) followed immediately by a string of text which is enclosed in angle brackets. This method is passed the sequence command &lt;code&gt;$seq_cmd&lt;/code&gt; and the corresponding text &lt;code&gt;$seq_arg&lt;/code&gt; . It is invoked by the &lt;b&gt;interpolate()&lt;/b&gt; method for each interior sequence that occurs in the string that it is passed. It should return the desired text string to be used in place of the interior sequence. The &lt;code&gt;$pod_seq&lt;/code&gt; argument is a reference to a &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; object which contains further information about the interior sequence. Please see &lt;a href=&quot;inputobjects&quot;&gt;Pod::InputObjects&lt;/a&gt; for details if you need to access this additional information.</source>
          <target state="translated">遇到内部序列时，子类应重写此方法以采取适当的措施。内部序列是嵌入在文本块中的命令，该文本块显示为命令名称（通常是一个大写字符），紧随其后的是一串包含在尖括号中的文本字符串。该方法通过序列命令 &lt;code&gt;$seq_cmd&lt;/code&gt; 和相应的文本 &lt;code&gt;$seq_arg&lt;/code&gt; 。它由&lt;b&gt;interpolate（）&lt;/b&gt;方法为传递给它的字符串中出现的每个内部序列调用。它应返回所需的文本字符串以代替内部序列。在 &lt;code&gt;$pod_seq&lt;/code&gt; 参数是一个参考 &lt;code&gt;Pod::InteriorSequence&lt;/code&gt; 包含有关内部序列的更多信息的对象。如果您需要访问此附加信息，请参见&lt;a href=&quot;inputobjects&quot;&gt;Pod :: InputObjects&lt;/a&gt;了解详细信息。</target>
        </trans-unit>
        <trans-unit id="429d3f42da5b40589bd5bfe3cdeaeea4b58f3cb7" translate="yes" xml:space="preserve">
          <source>This method takes a filename and does the following:</source>
          <target state="translated">本方法接收一个文件名,并执行以下操作。</target>
        </trans-unit>
        <trans-unit id="7d455696794a1091f3f69965ce8778b043cee526" translate="yes" xml:space="preserve">
          <source>This method takes an input filehandle (which is assumed to already be opened for reading) and reads the entire input stream looking for blocks (paragraphs) of POD documentation to be processed. If no first argument is given the default input filehandle &lt;code&gt;STDIN&lt;/code&gt; is used.</source>
          <target state="translated">此方法采用输入文件句柄（假定已经打开以进行读取），并读取整个输入流，以查找要处理的POD文档的块（段落）。如果没有给出第一个参数，则使用默认输入文件句柄 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d21cbfa9655bea409751abece40beb185c2a106" translate="yes" xml:space="preserve">
          <source>This method takes an optional parameter, &lt;code&gt;$flush_type&lt;/code&gt; , that controls how the flushing will be carried out. By default the &lt;code&gt;$flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;$flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; , &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; and &lt;code&gt;Z_BLOCK&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does - overuse of &lt;code&gt;flush&lt;/code&gt; can seriously degrade the level of compression achieved. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">此方法采用一个可选参数 &lt;code&gt;$flush_type&lt;/code&gt; ，该参数控制将如何执行刷新。默认情况下，使用的 &lt;code&gt;$flush_type&lt;/code&gt; 是 &lt;code&gt;Z_FINISH&lt;/code&gt; 。 &lt;code&gt;$flush_type&lt;/code&gt; 其他有效值是 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 和 &lt;code&gt;Z_BLOCK&lt;/code&gt; 。强烈建议您仅在完全了解其含义的情况下才设置 &lt;code&gt;flush_type&lt;/code&gt; 参数-过度使用 &lt;code&gt;flush&lt;/code&gt; 会严重降低所达到的压缩级别。有关详细信息，请参见 &lt;code&gt;zlib&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="fb30c692d9b64ebdba6036a9ab8caf9a45ad7a4f" translate="yes" xml:space="preserve">
          <source>This method takes an optional parameter, &lt;code&gt;$flush_type&lt;/code&gt;, that controls how the flushing will be carried out. By default the &lt;code&gt;$flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt;. Other valid values for &lt;code&gt;$flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt;, &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt;, &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; and &lt;code&gt;Z_BLOCK&lt;/code&gt;. It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does - overuse of &lt;code&gt;flush&lt;/code&gt; can seriously degrade the level of compression achieved. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">此方法采用一个可选参数 &lt;code&gt;$flush_type&lt;/code&gt; ，该参数控制将如何执行刷新。默认情况下，使用的 &lt;code&gt;$flush_type&lt;/code&gt; 是 &lt;code&gt;Z_FINISH&lt;/code&gt; 。 &lt;code&gt;$flush_type&lt;/code&gt; 其他有效值是 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 和 &lt;code&gt;Z_BLOCK&lt;/code&gt; 。强烈建议您仅在完全了解其含义的情况下才设置 &lt;code&gt;flush_type&lt;/code&gt; 参数-过度使用 &lt;code&gt;flush&lt;/code&gt; 会严重降低所达到的压缩级别。有关详细信息，请参见 &lt;code&gt;zlib&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="9a36ff48f2f3559090075d4ecd3d184fea06bced" translate="yes" xml:space="preserve">
          <source>This method takes no arguments, it has the exact same effect as invoking &amp;lt;select()&amp;gt; with no arguments.</source>
          <target state="translated">此方法不带任何参数，与调用不带参数的&amp;lt;select（）&amp;gt;具有完全相同的效果。</target>
        </trans-unit>
        <trans-unit id="21a6dff8df6ddbca7896a9686976cc84571da4fe" translate="yes" xml:space="preserve">
          <source>This method translates all text (including any embedded interior sequences) in the given text string &lt;code&gt;$text&lt;/code&gt; and returns the interpolated result. The parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">此方法转换给定文本字符串 &lt;code&gt;$text&lt;/code&gt; 中的所有文本（包括任何嵌入的内部序列），并返回插值结果。参数 &lt;code&gt;$line_num&lt;/code&gt; 是与 &lt;code&gt;$text&lt;/code&gt; 开头相对应的行号。</target>
        </trans-unit>
        <trans-unit id="d98885f1731321cbbe841c4174d52925fb86ae4c" translate="yes" xml:space="preserve">
          <source>This method turns an arbitrary string into a valid XHTML ID attribute value. The rules enforced, following &lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm&lt;/a&gt;, are:</source>
          <target state="translated">此方法将任意字符串转换为有效的XHTML ID属性值。遵循&lt;a href=&quot;http://webdesign.about.com/od/htmltags/a/aa031707.htm&quot;&gt;http://webdesign.about.com/od/htmltags/a/aa031707.htm&lt;/a&gt;实施的规则是：</target>
        </trans-unit>
        <trans-unit id="5d3c6a2354f8ed5d57f49370abc6615f8bbe3512" translate="yes" xml:space="preserve">
          <source>This method used to be useful back when Test::Builder worked on Perls before 5.6 which didn't have qr//. Now its pretty useless.</source>
          <target state="translated">当Test::Builder在5.6之前的Perls上工作时,这个方法曾经很有用,因为5.6没有qr//。现在它已经没有用了。</target>
        </trans-unit>
        <trans-unit id="5ce2bae285dbd09666d07f99e460e4eebea8c753" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;commands_quote&lt;/code&gt; to determine the correct quote. If &lt;code&gt;commands_quote&lt;/code&gt; is a space, no quoting will take place.</source>
          <target state="translated">此方法使用 &lt;code&gt;commands_quote&lt;/code&gt; 确定正确的报价。如果 &lt;code&gt;commands_quote&lt;/code&gt; 是一个空格，则不会进行任何引用。</target>
        </trans-unit>
        <trans-unit id="475ff388d47d9ff8c537b04d4cf8fd2786ec177c" translate="yes" xml:space="preserve">
          <source>This method was added in v0.20 of Math::BigRat (May 2007).</source>
          <target state="translated">这个方法是在 Math::BigRat 的 v0.20 中添加的(2007 年 5 月)。</target>
        </trans-unit>
        <trans-unit id="a9fdbef062f1e260e975ac993cde1b7e7c35b43d" translate="yes" xml:space="preserve">
          <source>This method was added in v0.22 of Math::BigRat (April 2008).</source>
          <target state="translated">这个方法是在 Math::BigRat 的 v0.22 中添加的(2008 年 4 月)。</target>
        </trans-unit>
        <trans-unit id="4f274a73d8190736635c257c7c7cb3e3c0fe18c0" translate="yes" xml:space="preserve">
          <source>This method was added in v1.82 of Math::BigInt (April 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.82版本(2007年4月)中加入的。</target>
        </trans-unit>
        <trans-unit id="892100fd26e628f38d9cdb9d5d762a8a6ee16072" translate="yes" xml:space="preserve">
          <source>This method was added in v1.84 of Math::BigInt (April 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.84版本(2007年4月)中加入的。</target>
        </trans-unit>
        <trans-unit id="def53de6390772e9ab517671e2de82585ed2894d" translate="yes" xml:space="preserve">
          <source>This method was added in v1.87 of Math::BigInt (June 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.87版本(2007年6月)中加入的。</target>
        </trans-unit>
        <trans-unit id="e5821a661d4054cf93a3f0baee35e1a4e8ee9c19" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 函数时将调用此方法。</target>
        </trans-unit>
        <trans-unit id="33be8d090d52cdf9ebec70873885856aba821ff5" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 函数时将调用此方法。</target>
        </trans-unit>
        <trans-unit id="d3cb58ce3651b90ff56e3c1a01aa5df7e96bc1d2" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;eof&lt;/code&gt; function is called.</source>
          <target state="translated">当调用 &lt;code&gt;eof&lt;/code&gt; 函数时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="a3e47fe88d4c0ab44cf85620365ca3f9e7b2c4ea" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;getc&lt;/code&gt; function is called.</source>
          <target state="translated">调用 &lt;code&gt;getc&lt;/code&gt; 函数时将调用此方法。</target>
        </trans-unit>
        <trans-unit id="07abfda6230642bdc24b2988efac200062ab0904" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is closed via the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数关闭句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="e3f4f5034957d7d4e9aa3a8edbd33a9e855059ad" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is closed via the &lt;code&gt;close&lt;/code&gt; function.</source>
          <target state="translated">当通过 &lt;code&gt;close&lt;/code&gt; 函数关闭句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="8c952116674febc1216a1fb0e4796db40ca65ad8" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is read from via the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 函数从中读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="c2c8df89bf1dd475294a80263c1998064bad01a4" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is read from via the &lt;code&gt;read&lt;/code&gt; or &lt;code&gt;sysread&lt;/code&gt; functions.</source>
          <target state="translated">通过 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;sysread&lt;/code&gt; 函数从中读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="53bcf4b7992a6d18135efe380f6cf616566ace5a" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is written to via the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数将句柄写入时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="808d3e7324564412ae6c4c95a1b83f642b5294f8" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is written to via the &lt;code&gt;syswrite&lt;/code&gt; function.</source>
          <target state="translated">通过 &lt;code&gt;syswrite&lt;/code&gt; 函数将句柄写入时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="2f7eb1cf0cb3798f7407e75f4a0686ab61a556fd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied array is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something and the value we're trying to put there.</source>
          <target state="translated">每当绑定数组中的一个元素被设置(写入)时,这个方法就会被触发。它在自引用之外还需要两个参数:我们试图存储某些东西的索引和我们试图放在那里的值。</target>
        </trans-unit>
        <trans-unit id="fef1865fb35cee1965cbfbe2864d43cfb61253d3" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is accessed (read). It takes one argument beyond its self reference: the key whose value we're trying to fetch.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定哈希中的元素时被触发。它除了自身引用之外,还需要一个参数:我们试图获取其值的键。</target>
        </trans-unit>
        <trans-unit id="6ff0eaa0013ee12dae761b1f3a38cc41d40d71c7" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something, and the value we're trying to put there.</source>
          <target state="translated">每次设置(写入)绑定哈希中的元素时,这个方法都会被触发。它需要两个参数,除了它的自引用之外,还需要两个参数:我们试图存储某些东西的索引,以及我们试图放在那里的值。</target>
        </trans-unit>
        <trans-unit id="f154ed5d9dede0079ff14f755f8d64da0b6d8569" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an individual element the tied array is accessed (read). It takes one argument beyond its self reference: the index whose value we're trying to fetch.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定数组中的单个元素时被触发。它需要一个参数:我们试图获取其值的索引。</target>
        </trans-unit>
        <trans-unit id="ce4bdb5814566177219471512f35e981a551516b" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; functions. Beyond its self reference it also expects the list that was passed to the print function.</source>
          <target state="translated">每次使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递到打印功能的列表。</target>
        </trans-unit>
        <trans-unit id="46e361c76a8fe326ef26947ed7b27ef6314ab7da" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; function. Beyond its self reference it also expects the format and list that was passed to the printf function.</source>
          <target state="translated">每次使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递给printf函数的格式和列表。</target>
        </trans-unit>
        <trans-unit id="6af30ad096d6acfeecb452b74adb4a3282b5cd33" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;print()&lt;/code&gt; or &lt;code&gt;say()&lt;/code&gt; functions. Beyond its self reference it also expects the list that was passed to the print function.</source>
          <target state="translated">每次使用 &lt;code&gt;print()&lt;/code&gt; 或 &lt;code&gt;say()&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递到打印功能的列表。</target>
        </trans-unit>
        <trans-unit id="743722ad4d09e8c7a81e0e8d919d08195ccf21c8" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;printf()&lt;/code&gt; function. Beyond its self reference it also expects the format and list that was passed to the printf function.</source>
          <target state="translated">每次使用 &lt;code&gt;printf()&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递给printf函数的格式和列表。</target>
        </trans-unit>
        <trans-unit id="4d2309a54c3a525e60bc8a57c49ad44a6f62e89e" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is accessed (read). It takes no arguments beyond its self reference, which is the object representing the scalar we're dealing with. Because in this case we're using just a SCALAR ref for the tied scalar object, a simple $$self allows the method to get at the real value stored there. In our example below, that real value is the process ID to which we've tied our variable.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定变量时被触发。除了self引用之外,它不需要任何参数,self引用是代表我们正在处理的标量的对象。因为在本例中,我们对绑定的标量对象只使用了一个SCALAR ref,一个简单的$$self就可以让这个方法获得存储在那里的实际值。在下面的例子中,这个实际值就是我们绑定变量的进程ID。</target>
        </trans-unit>
        <trans-unit id="074aba193a7d4ab7fc2d92f3649243f7a2526fbd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is set (assigned). Beyond its self reference, it also expects one (and only one) argument: the new value the user is trying to assign. Don't worry about returning a value from STORE; the semantic of assignment returning the assigned value is implemented with FETCH.</source>
          <target state="translated">这个方法将在每次设置(分配)绑定变量时被触发。除了它的自引用之外,它还期待一个(也只有一个)参数:用户试图赋值的新值。不用担心从store中返回一个值,赋值返回赋值的语义是用FETCH实现的。</target>
        </trans-unit>
        <trans-unit id="a70c828d5225a812501600b7ba6a4a618714e8ab" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. This can be useful if the class needs to know when no further calls will be made. (Except DESTROY of course.) See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时将触发此方法。如果该类需要知道什么时候不再进行调用，这将很有用。（当然，除了DESTROY除外。）有关更多详细信息，请参见&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的Unt Gotcha&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2320a83af1339239a394fc9bed901eb3791c7ba6" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the &lt;code&gt;untie&lt;/code&gt; occurs. This can be useful if the class needs to know when no further calls will be made. (Except DESTROY of course.) See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below for more details.</source>
          <target state="translated">&lt;code&gt;untie&lt;/code&gt; 时将触发此方法。如果该类需要知道什么时候不再进行调用，这将很有用。（当然，除了DESTROY除外。）有关更多详细信息，请参见下面的&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&amp;ldquo; &lt;code&gt;untie&lt;/code&gt; 陷阱&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6dadf6ee9215d45834b1ebd72a2a25ea540b456" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with other object classes, such a method is seldom necessary, because Perl deallocates its moribund object's memory for you automatically--this isn't C++, you know. We'll use a DESTROY method here for debugging purposes only.</source>
          <target state="translated">当绑定的变量需要被销毁时,这个方法将被触发。和其他对象类一样,这样的方法很少是必要的,因为Perl会自动为你重新分配它那奄奄一息的对象的内存--这不是C++,你知道的。我们在这里使用 DESTROY 方法只是为了调试的目的。</target>
        </trans-unit>
        <trans-unit id="aba37b5cce6ea3c8466dd8e8d0896cfdf208ff19" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with the scalar tie class, this is almost never needed in a language that does its own garbage collection, so this time we'll just leave it out.</source>
          <target state="translated">当绑定变量需要被销毁时,这个方法将被触发。和标量绑定类一样,在自带垃圾收集功能的语言中几乎不需要这个方法,所以这次我们就不说了。</target>
        </trans-unit>
        <trans-unit id="1a30c4c1dc9863704c12fdf1f1b5872e08e0156b" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the user is going to iterate through the hash, such as via a keys() or each() call.</source>
          <target state="translated">当用户要对哈希进行迭代时,比如通过 keys()或 each()调用,这个方法将被触发。</target>
        </trans-unit>
        <trans-unit id="40a2e00fab75d6d886ea418ffd88f8aa1dbe8119" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the user is going to iterate through the hash, such as via a keys(), values(), or each() call.</source>
          <target state="translated">当用户要对哈希进行迭代时,如通过keys()、values()或each()调用时,该方法将被触发。</target>
        </trans-unit>
        <trans-unit id="241be65c4fe89a7db745cd5e6028ee4cea0a4bd5" translate="yes" xml:space="preserve">
          <source>This method will do a file transfer between two remote ftp servers. If &lt;code&gt;DEST_FILE&lt;/code&gt; is omitted then the leaf name of &lt;code&gt;SRC_FILE&lt;/code&gt; will be used.</source>
          <target state="translated">此方法将在两个远程ftp服务器之间进行文件传输。如果 &lt;code&gt;DEST_FILE&lt;/code&gt; 省略随后的叶名 &lt;code&gt;SRC_FILE&lt;/code&gt; 将被使用。</target>
        </trans-unit>
        <trans-unit id="714241362af6626714a493d5da28a5f3831d1838" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the interior sequence's text.</source>
          <target state="translated">本方法将获取/设置内部序列文本的对应解析树。</target>
        </trans-unit>
        <trans-unit id="81f73213adc2e84a3c6f2373dbd483c50f803f34" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the paragraph's text.</source>
          <target state="translated">本方法将获取/设置该段文字对应的解析树。</target>
        </trans-unit>
        <trans-unit id="e9978ed2996dd9bcc230654360a798a867715edb" translate="yes" xml:space="preserve">
          <source>This method will read the named file and deserialize it to a data structure, determining whether it should be JSON or YAML based on the filename. The file will be read using the &quot;:utf8&quot; IO layer.</source>
          <target state="translated">这个方法将读取命名的文件,并将其反序列化为一个数据结构,根据文件名决定它应该是JSON还是YAML。该文件将使用&quot;:utf8 &quot;IO层读取。</target>
        </trans-unit>
        <trans-unit id="b67738b0ceee5f0e621228df6d40624bf3ba896e" translate="yes" xml:space="preserve">
          <source>This method will reset the deflation object &lt;code&gt;$d&lt;/code&gt; . It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; has returned &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">此方法将重置通缩对象 &lt;code&gt;$d&lt;/code&gt; 。当您压缩多个数据流并且要使用同一对象压缩每个数据流时，可以使用它。仅在成功刷新了先前的数据流后，即对 &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; 的调用返回 &lt;code&gt;Z_OK&lt;/code&gt; 时，才应使用它。</target>
        </trans-unit>
        <trans-unit id="712ee53e5b0c4e0aae2bb7946407fb40095db000" translate="yes" xml:space="preserve">
          <source>This method will reset the deflation object &lt;code&gt;$d&lt;/code&gt;. It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; has returned &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">此方法将重置通缩对象 &lt;code&gt;$d&lt;/code&gt; 。当您压缩多个数据流并希望使用相同的对象来压缩每个数据流时，可以使用它。仅在成功清除先前的数据流后，即对 &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; 的调用返回 &lt;code&gt;Z_OK&lt;/code&gt; 时，才应使用它。</target>
        </trans-unit>
        <trans-unit id="c896817c407b0236207a4f8181caaf53efac5199" translate="yes" xml:space="preserve">
          <source>This method will reset the inflation object &lt;code&gt;$i&lt;/code&gt; . It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.</source>
          <target state="translated">该方法将重置通胀对象 &lt;code&gt;$i&lt;/code&gt; 。当您解压缩多个数据流并希望使用同一对象解压缩每个数据流时，可以使用它。</target>
        </trans-unit>
        <trans-unit id="97c63a4cc6642689474dcac8d841e924f47f9df6" translate="yes" xml:space="preserve">
          <source>This method will reset the inflation object &lt;code&gt;$i&lt;/code&gt;. It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.</source>
          <target state="translated">该方法将重置通胀对象 &lt;code&gt;$i&lt;/code&gt; 。当您解压缩多个数据流并希望使用同一对象解压缩每个数据流时，可以使用它。</target>
        </trans-unit>
        <trans-unit id="105ad0604f1ec5de22899d40a47afc4c0ebd09fb" translate="yes" xml:space="preserve">
          <source>This method will return a &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object representing the current line of TAP.</source>
          <target state="translated">此方法将返回一个&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;对象，该对象表示TAP的当前行。</target>
        </trans-unit>
        <trans-unit id="c910df5717be7f7845368e614ada212ccc95c585" translate="yes" xml:space="preserve">
          <source>This method will return a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object representing the current line of TAP.</source>
          <target state="translated">此方法将返回表示&lt;a href=&quot;result&quot;&gt;TAP&lt;/a&gt;当前行的TAP :: Parser :: Result对象。</target>
        </trans-unit>
        <trans-unit id="94dd0495b55dbb9479c740e8c7707434102ef2b3" translate="yes" xml:space="preserve">
          <source>This method will return the</source>
          <target state="translated">本方法将返回</target>
        </trans-unit>
        <trans-unit id="64b72f6b7b9c90292fdf0c07acf00371c342b31f" translate="yes" xml:space="preserve">
          <source>This method will return the corresponding text of the paragraph.</source>
          <target state="translated">本方法将返回该段对应的文字。</target>
        </trans-unit>
        <trans-unit id="ab1780bb79394a56eb62561ff6bce59239ad7057" translate="yes" xml:space="preserve">
          <source>This method will validate facet data and return a list of errors. If no errors are found this will return an empty list.</source>
          <target state="translated">此方法将验证面数据并返回一个错误列表。如果没有发现错误,将返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="eb400e4423b1637ce4c15ebb34457f31a6dff2be" translate="yes" xml:space="preserve">
          <source>This method, also added in 5.22, returns the ID of the outer padlist.</source>
          <target state="translated">这个方法也是在5.22中加入的,返回外挂表的ID。</target>
        </trans-unit>
        <trans-unit id="4592c3f20e832c80ee7755d708e2fc413aad3a8b" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns an ID shared by clones of the same padlist.</source>
          <target state="translated">这个方法,在5.22中引入,返回同一个padlist的克隆共享的ID。</target>
        </trans-unit>
        <trans-unit id="9809e060290c8d05a80c630d780720e4ef068203" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns the B::PADNAMELIST. It is equivalent to &lt;code&gt;ARRAYelt&lt;/code&gt; with a 0 argument.</source>
          <target state="translated">在5.22中引入的此方法返回B :: PADNAMELIST。它等效于参数为0的 &lt;code&gt;ARRAYelt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e85228faab0626451baa8274321e8bb4a24e677" translate="yes" xml:space="preserve">
          <source>This method, which just calls &lt;code&gt;B::Concise::b_terse&lt;/code&gt;, has been deprecated, and disappeared in Perl 5.28. Please use &lt;code&gt;B::Concise&lt;/code&gt; instead.</source>
          <target state="translated">仅调用 &lt;code&gt;B::Concise::b_terse&lt;/code&gt; 此方法已被弃用，并在Perl 5.28中消失了。请改为使用 &lt;code&gt;B::Concise&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29b87abd8043418845a4e29d3099fa81c542084b" translate="yes" xml:space="preserve">
          <source>This model is also handy for a form of recursive programming where, rather than having a subroutine call itself, it instead creates another thread. Prime and Fibonacci generators both map well to this form of the pipeline model. (A version of a prime number generator is presented later on.)</source>
          <target state="translated">这种模型对于递归编程的形式也很方便,在这种情况下,不是让一个子程序调用自己,而是创建另一个线程。质数发生器和斐波那契发生器都可以很好地映射到这种形式的流水线模型中。后面会介绍一个质数发生器的版本)。</target>
        </trans-unit>
        <trans-unit id="30009f920550802cc665953dfad42c7d9264746f" translate="yes" xml:space="preserve">
          <source>This model is common in GUI and server programs, where a main thread waits for some event and then passes that event to the appropriate worker threads for processing. Once the event has been passed on, the boss thread goes back to waiting for another event.</source>
          <target state="translated">这种模式在GUI和服务器程序中很常见,一个主线程等待某个事件,然后将该事件传递给相应的工作线程进行处理。一旦事件传递完毕,主线程就会回到等待另一个事件。</target>
        </trans-unit>
        <trans-unit id="b15bc8cde549f860c8eb7d12b3582c3e0ea39cf3" translate="yes" xml:space="preserve">
          <source>This model is particularly useful if the system running the program will distribute multiple threads across different processors. It can also be useful in ray tracing or rendering engines, where the individual threads can pass on interim results to give the user visual feedback.</source>
          <target state="translated">如果运行程序的系统会将多个线程分布在不同的处理器上,这种模式就特别有用。它在光线追踪或渲染引擎中也很有用,各个线程可以传递临时结果,给用户以视觉反馈。</target>
        </trans-unit>
        <trans-unit id="a46d487d5e105c40547660dc27acaa14d80672b3" translate="yes" xml:space="preserve">
          <source>This model makes the most sense if you have multiple processors so two or more threads will be executing in parallel, though it can often make sense in other contexts as well. It tends to keep the individual tasks small and simple, as well as allowing some parts of the pipeline to block (on I/O or system calls, for example) while other parts keep going. If you're running different parts of the pipeline on different processors you may also take advantage of the caches on each processor.</source>
          <target state="translated">如果你有多个处理器,所以两个或更多的线程将并行执行,这种模式是最有意义的,尽管它通常在其他情况下也有意义。它倾向于保持单个任务小而简单,以及允许管道的某些部分阻塞(例如,在I/O或系统调用上),而其他部分继续进行。如果你在不同的处理器上运行管道的不同部分,你也可以利用每个处理器上的缓存。</target>
        </trans-unit>
        <trans-unit id="ca5c3fc9e826014a4bf6c25dd9dfaa294e403640" translate="yes" xml:space="preserve">
          <source>This modifier is automatically selected by default when none of the others are, so yet another name for it is &quot;Default&quot;.</source>
          <target state="translated">当其他修饰符都没有的时候,这个修饰符会被默认自动选择,所以它的另一个名字是 &quot;默认&quot;。</target>
        </trans-unit>
        <trans-unit id="c04617ccf79d65516875370f2175f88d3d4536a0" translate="yes" xml:space="preserve">
          <source>This modifier is not portable, so its use should be restricted to &lt;code&gt;PerlIO_printf()&lt;/code&gt;.</source>
          <target state="translated">此修饰符不是可移植的，因此应仅将其使用限于 &lt;code&gt;PerlIO_printf()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d496a068117111419859bc00c9612b716988f03" translate="yes" xml:space="preserve">
          <source>This modifier is useful for people who only incidentally use Unicode, and who do not wish to be burdened with its complexities and security concerns.</source>
          <target state="translated">这个修饰符对于那些只是偶然使用Unicode的人来说很有用,他们不希望被Unicode的复杂性和安全问题所困扰。</target>
        </trans-unit>
        <trans-unit id="0e5335d13a0034ff0e79330d63821913e0ac8c3f" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher), but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; （或更高版本）将此修饰符指定为默认值，但是请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e12be54768ee3b0c57bff3f17db521cb0aa4207" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 可以将此修饰符指定为默认值，但是请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7947231e9d8ba8a56b871805ba4f83e34edd5a3b" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; . If you do so, you may actually have occasion to use the &lt;code&gt;/u&lt;/code&gt; modifier explicitly if there are a few regular expressions where you do want full Unicode rules (but even here, it's best if everything were under feature &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; , along with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ). Also see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; 将此修饰符指定为默认值。如果这样做的话，如果确实有一些需要完整的Unicode规则的正则表达式，那么实际上可能有机会显式地使用 &lt;code&gt;/u&lt;/code&gt; 修饰符（但是即使在这里，最好将所有内容都放在功能 &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; ，以及 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ）。另请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a33069e1e40dd1d406cb06f4820e8365f86b6a18" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;use feature 'unicode_strings&lt;/code&gt;, &lt;code&gt;use locale ':not_characters'&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;perlfunc#use-VERSION&quot;&gt;use 5.012&lt;/a&gt;&lt;/code&gt; (or higher), but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot;&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;use feature 'unicode_strings&lt;/code&gt; ， &lt;code&gt;use locale ':not_characters'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;perlfunc#use-VERSION&quot;&gt;use 5.012&lt;/a&gt;&lt;/code&gt; （或更高版本）将此修饰符指定为默认值，但请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&amp;ldquo;哪个字符集修饰符有效？&amp;rdquo; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e323f49369cfd817dd3ab5eb35782378466587d" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;use locale&lt;/code&gt;, but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot;&lt;/a&gt;.</source>
          <target state="translated">通过 &lt;code&gt;use locale&lt;/code&gt; 可以将此修饰符指定为默认值，但请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&amp;ldquo;哪个字符集修饰符有效？&amp;rdquo;。&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6e892a0b349e1ef5808e5c9bed02cfeaaecfdda" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;use re '/a'&lt;/code&gt; or &lt;code&gt;use re '/aa'&lt;/code&gt;. If you do so, you may actually have occasion to use the &lt;code&gt;/u&lt;/code&gt; modifier explicitly if there are a few regular expressions where you do want full Unicode rules (but even here, it's best if everything were under feature &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt;, along with the &lt;code&gt;use re '/aa'&lt;/code&gt;). Also see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot;&lt;/a&gt;.</source>
          <target state="translated">可以 &lt;code&gt;use re '/a'&lt;/code&gt; 或 &lt;code&gt;use re '/aa'&lt;/code&gt; 将此修饰符指定为默认值。如果这样做的话，如果确实有一些需要完整的Unicode规则的正则表达式，那么实际上可能有机会显式地使用 &lt;code&gt;/u&lt;/code&gt; 修饰符（但是即使在这里，最好将所有内容都放在功能 &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; ，以及 &lt;code&gt;use re '/aa'&lt;/code&gt; ）。另请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&amp;ldquo;哪个字符集修饰符有效？&amp;rdquo; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="612208176f5e5f15f70f9fe87ffb9885ed3fb4f8" translate="yes" xml:space="preserve">
          <source>This modifier means to use the &quot;Default&quot; native rules of the platform except when there is cause to use Unicode rules instead, as follows:</source>
          <target state="translated">这个修饰词的意思是使用平台的 &quot;默认 &quot;本地规则,除非有理由使用Unicode规则,如下所示。</target>
        </trans-unit>
        <trans-unit id="c88a880096800aee300b8b7d7d4d916283e4a60a" translate="yes" xml:space="preserve">
          <source>This modifier stands for ASCII-restrict (or ASCII-safe). This modifier may be doubled-up to increase its effect.</source>
          <target state="translated">这个修饰符代表ASCII限制(或ASCII安全)。这个修饰符可以双倍放大以增加其效果。</target>
        </trans-unit>
        <trans-unit id="749227e1bbfa4aaec7c32f6b70520da88bebf428" translate="yes" xml:space="preserve">
          <source>This modifier stands for ASCII-restrict (or ASCII-safe). This modifier, unlike the others, may be doubled-up to increase its effect.</source>
          <target state="translated">这个修饰符代表ASCII-restrict(或ASCII-safe)。与其他修饰符不同的是,这个修饰符可以双倍放大以增加其效果。</target>
        </trans-unit>
        <trans-unit id="d4333bd9c8e1ecf2d74d135cfc1c019d27ec9a46" translate="yes" xml:space="preserve">
          <source>This modifies the Test::Builder internals in many ways. A better was to accomplish the goal of this module is to write your own subtest function.</source>
          <target state="translated">这在很多方面修改了Test::Builder的内部结构。一个更好的方法是编写你自己的子测试函数来实现这个模块的目标。</target>
        </trans-unit>
        <trans-unit id="fa6de4fa0b87cce4f41c3c3e6b2f399a24f53e8f" translate="yes" xml:space="preserve">
          <source>This module abstracts and provides all of the hooks into Perl internal debugging functionality, so that various implementations of Perl debuggers (or packages that want to simply get at the &quot;privileged&quot; debugging data) can all benefit from the development of this common code. Currently used by Swat, the perl/Tk GUI debugger.</source>
          <target state="translated">这个模块抽象并提供了所有进入Perl内部调试功能的钩子,因此各种Perl调试器的实现(或者是想简单获取 &quot;特权 &quot;调试数据的包)都可以从这个通用代码的开发中获益。目前perl/Tk GUI调试器Swat使用。</target>
        </trans-unit>
        <trans-unit id="6875f545409eef33a68dd7123f3a8648204e39c4" translate="yes" xml:space="preserve">
          <source>This module allows one to set this attribute on a subroutine that is already defined. For Perl subroutines (XSUBs are fine), it may or may not do what you want, depending on the code inside the subroutine, with details subject to change in future Perl versions. You may run into problems with lvalue context not being propagated properly into the subroutine, or maybe even assertion failures. For this reason, a warning is emitted if warnings are enabled. In other words, you should only do this if you really know what you are doing. You have been warned.</source>
          <target state="translated">这个模块允许人们在已经定义好的子程序上设置这个属性。对于Perl子程序(XSUBs也可以),它可能会做你想要的,也可能不会做,这取决于子程序内部的代码,细节在未来的Perl版本中可能会改变。你可能会遇到lvalue上下文不能正确传播到子程序中的问题,甚至可能是断言失败。因此,如果启用了警告,就会发出警告。换句话说,只有在你真正知道自己在做什么的情况下,你才应该这样做。你已经被警告了。</target>
        </trans-unit>
        <trans-unit id="a965ba5c24e8c32086e33820dca8017e296c7bac" translate="yes" xml:space="preserve">
          <source>This module also adds a stack trace to the error message when perl dies. This is useful for pinpointing what caused the death. The &lt;b&gt;-traceonly&lt;/b&gt; (or just &lt;b&gt;-t&lt;/b&gt;) flag turns off the explanations of warning messages leaving just the stack traces. So if your script is dieing, run it again with</source>
          <target state="translated">当perl死掉时，该模块还将堆栈跟踪添加到错误消息中。这对于查明造成死亡的原因很有用。所述&lt;b&gt;-traceonly&lt;/b&gt;（或只是&lt;b&gt;-t&lt;/b&gt;）标志关闭只留下栈跟踪警告消息的解释。因此，如果您的脚本即将死机，请使用</target>
        </trans-unit>
        <trans-unit id="8f7fb6f3dfdd280d1b2872ffca7de6a38c89ca71" translate="yes" xml:space="preserve">
          <source>This module also provides a function &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; that returns true iff the language tag is syntactically valid and is for general use (like &quot;fr&quot; or &quot;fr-ca&quot;, below). That is, it returns false for tags that are syntactically invalid and for tags, like &quot;aus&quot;, that are listed in brackets below. This function is not exported.</source>
          <target state="translated">该模块还提供了一个函数 &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; ，如果该语言标记在语法上有效且可以通用（如下面的&amp;ldquo; fr&amp;rdquo;或&amp;ldquo; fr-ca&amp;rdquo; ），则返回true。也就是说，对于语法无效的标记和下面括号中列出的标记（例如&amp;ldquo; aus&amp;rdquo;），它返回false。此功能未导出。</target>
        </trans-unit>
        <trans-unit id="35c9fcef6d8c497b285988252e5e12636887688f" translate="yes" xml:space="preserve">
          <source>This module and its competitor, the CPANPLUS module, are both much cooler than the other. CPAN.pm is older. CPANPLUS was designed to be more modular, but it was never intended to be compatible with CPAN.pm.</source>
          <target state="translated">这个模块和它的竞争对手CPANPLUS模块,都比对方酷多了。CPAN.pm比较老。CPANPLUS的设计是为了更加模块化,但它从未打算与CPAN.pm兼容。</target>
        </trans-unit>
        <trans-unit id="784f2f639e9afabf2dc275e208777379339cfa1d" translate="yes" xml:space="preserve">
          <source>This module attempts to be squeaky clean w.r.t &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; and when warnings are enabled.</source>
          <target state="translated">该模块试图 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;严格的标准；以及启用警告时。</target>
        </trans-unit>
        <trans-unit id="99015cf6cbe9c998b9b79c332cc6306a7b24d6fc" translate="yes" xml:space="preserve">
          <source>This module attempts to be squeaky clean w.r.t &lt;code&gt;use strict;&lt;/code&gt; and when warnings are enabled.</source>
          <target state="translated">该模块试图 &lt;code&gt;use strict;&lt;/code&gt; 以及启用警告时。</target>
        </trans-unit>
        <trans-unit id="004ba23e4c1d9e020129a075fb1542d515c8beb8" translate="yes" xml:space="preserve">
          <source>This module by Jos Boumans &amp;lt;kane@cpan.org&amp;gt;.</source>
          <target state="translated">该模块由Jos Boumans &amp;lt;kane@cpan.org&amp;gt;提供。</target>
        </trans-unit>
        <trans-unit id="97238c429acb2a106f71561828a9705c17f2cd68" translate="yes" xml:space="preserve">
          <source>This module can be used to check that the perl C API is behaving correctly. This module provides test functions and an associated test script that verifies the output.</source>
          <target state="translated">这个模块可以用来检查perl C API是否正常运行。这个模块提供了测试函数和一个相关的测试脚本来验证输出。</target>
        </trans-unit>
        <trans-unit id="3512e67f1197d03fbeb001853d009060532cfa22" translate="yes" xml:space="preserve">
          <source>This module can build the C portions of Perl modules by invoking the appropriate compilers and linkers in a cross-platform manner. It was motivated by the &lt;code&gt;Module::Build&lt;/code&gt; project, but may be useful for other purposes as well. However, it is</source>
          <target state="translated">通过以跨平台方式调用适当的编译器和链接器，此模块可以构建Perl模块的C部分。它是由 &lt;code&gt;Module::Build&lt;/code&gt; 项目驱动的，但也可能对其他目的有用。但是，这是</target>
        </trans-unit>
        <trans-unit id="26eefbe0903fb2ede95e48daeed0c357506e5da6" translate="yes" xml:space="preserve">
          <source>This module can provoke sizeable inefficiencies for regular expressions, due to unfortunate implementation details. If performance matters in your application and you don't need $PREMATCH, $MATCH, or $POSTMATCH, try doing</source>
          <target state="translated">由于不幸的实现细节,这个模块可能会对正则表达式造成相当大的低效率。如果您的应用程序的性能很重要,而且您不需要 $PREMATCH、$MATCH 或 $POSTMATCH,请尝试做以下操作</target>
        </trans-unit>
        <trans-unit id="8cf5ae089cfd3bb924112f109262d970297de9cc" translate="yes" xml:space="preserve">
          <source>This module can read, modify, create and write Perl XS typemap files. If you don't know what a typemap is, please confer the &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; manuals.</source>
          <target state="translated">该模块可以读取，修改，创建和写入Perl XS typemap文件。如果您不知道什么是类型&lt;a href=&quot;perlxstut&quot;&gt;映射&lt;/a&gt;，请参阅perlxstut和&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;手册。</target>
        </trans-unit>
        <trans-unit id="5e29d99feceeb44433f425fbac43b49ef593d502" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种风格：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls版本没有。您可以通过查看 &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Pers 是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="3f246357be0ea9a19a9c26640bdecebe65636361" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt;: it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种口味：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls的版本则没有。您可以通过查看 &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Perls是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="febd1d0bc1aeb9c9dc580b98ecebabe324968f11" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种风格：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls版本没有。您可以通过查看 &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Perls 是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="09b0dd2743438f4a098031d43325e1efa58a9e72" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt;: it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种口味：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls的版本则没有。您可以通过查看 &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Pers是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="d14a28688b621d987b1f8fc9e23815cd4abf0ed8" translate="yes" xml:space="preserve">
          <source>This module contains a good example of how to use tie to implement a cache and an example of how to make a tied variable readonly to those outside of it.</source>
          <target state="translated">这个模块包含了一个很好的如何使用 tie 来实现缓存的例子,以及一个如何让绑定的变量对其外的人只读的例子。</target>
        </trans-unit>
        <trans-unit id="d311a4e7a3db9109ca676b3552f311797aef79ac" translate="yes" xml:space="preserve">
          <source>This module contains methods to test the reachability of remote hosts on a network. A ping object is first created with optional parameters, a variable number of hosts may be pinged multiple times and then the connection is closed.</source>
          <target state="translated">本模块包含了测试网络上远程主机的可到达性的方法。首先创建一个带有可选参数的ping对象,可以多次ping不同数量的主机,然后关闭连接。</target>
        </trans-unit>
        <trans-unit id="e7ab97b3c83db0e719a01ba25468a109c4526c8d" translate="yes" xml:space="preserve">
          <source>This module contains utility subroutines for abstracting away the underlying magic of autodie and (ab)uses of &lt;code&gt;%^H&lt;/code&gt; to call subs at the end of a (compile-time) scopes.</source>
          <target state="translated">该模块包含一些实用程序子例程，这些例程用于抽象化autodie的基本功能以及 &lt;code&gt;%^H&lt;/code&gt; （滥用）在（编译时）作用域的末尾调用子程序。</target>
        </trans-unit>
        <trans-unit id="d790b22a57580f55f37ab95818cba0bc38ecd0b0" translate="yes" xml:space="preserve">
          <source>This module converts CPAN Meta structures from one form to another. The primary use is to convert older structures to the most modern version of the specification, but other transformations may be implemented in the future as needed. (E.g. stripping all custom fields or stripping all optional fields.)</source>
          <target state="translated">该模块将CPAN元结构从一种形式转换为另一种形式。主要用途是将旧的结构转换为最新版本的规范,但将来可能会根据需要进行其他转换。(例如,删除所有自定义字段或删除所有可选字段。)</target>
        </trans-unit>
        <trans-unit id="0e0177cabfcfd905cc13252e41134159a6c784e5" translate="yes" xml:space="preserve">
          <source>This module deals with a lot of system dependencies and has quite a few architecture specific &lt;code&gt;if&lt;/code&gt; s in the code.</source>
          <target state="translated">该模块处理许多系统依赖性，并且在代码中具有许多特定于体系结构的 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d165975e418f48b0068ea6e4916ced218ae66175" translate="yes" xml:space="preserve">
          <source>This module deals with a lot of system dependencies and has quite a few architecture specific &lt;code&gt;if&lt;/code&gt;s in the code.</source>
          <target state="translated">此模块处理许多系统依赖性，并且在代码中具有许多特定于体系结构的 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="048af0729c3efd4457ee6a9d255333490a26b61d" translate="yes" xml:space="preserve">
          <source>This module defines a standard</source>
          <target state="translated">本模块定义了一个标准的</target>
        </trans-unit>
        <trans-unit id="ccc077b805dfb6d70b724e9bdd6fb4fe5347a6c3" translate="yes" xml:space="preserve">
          <source>This module defines one public function, &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; . This function is not exported (nor is even exportable), and it takes no parameters.</source>
          <target state="translated">此模块定义一个公共函数 &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; 。此函数不会导出（甚至也无法导出），并且不带任何参数。</target>
        </trans-unit>
        <trans-unit id="86eec5c4aa5efea45745f52bda7e4b24c847a408" translate="yes" xml:space="preserve">
          <source>This module defines one public function, &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt;. This function is not exported (nor is even exportable), and it takes no parameters.</source>
          <target state="translated">此模块定义一个公共函数 &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; 。此函数不会导出（甚至也无法导出），并且不带任何参数。</target>
        </trans-unit>
        <trans-unit id="d9f93c560d9ab4f740a2b97f280df75095aa9c1e" translate="yes" xml:space="preserve">
          <source>This module defines some basic input objects used by &lt;b&gt;Pod::Parser&lt;/b&gt; when reading and parsing POD text from an input source. The following objects are defined:</source>
          <target state="translated">该模块定义了从输入源读取和解析POD文本时&lt;b&gt;Pod :: Parser&lt;/b&gt;使用的一些基本输入对象。定义了以下对象：</target>
        </trans-unit>
        <trans-unit id="5588b6a383faab0057a18646001f16348459eef2" translate="yes" xml:space="preserve">
          <source>This module defines three public functions, &lt;code&gt;plan(...)&lt;/code&gt; , &lt;code&gt;ok(...)&lt;/code&gt; , and &lt;code&gt;skip(...)&lt;/code&gt; . By default, all three are exported by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; statement.</source>
          <target state="translated">这个模块定义了三个公共函数， &lt;code&gt;plan(...)&lt;/code&gt; ， &lt;code&gt;ok(...)&lt;/code&gt; 和 &lt;code&gt;skip(...)&lt;/code&gt; 。默认情况下，这三个都通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; 导出；声明。</target>
        </trans-unit>
        <trans-unit id="753823d787f9b4eb6fa8a5cbc51058ee11d7dd83" translate="yes" xml:space="preserve">
          <source>This module defines three public functions, &lt;code&gt;plan(...)&lt;/code&gt;, &lt;code&gt;ok(...)&lt;/code&gt;, and &lt;code&gt;skip(...)&lt;/code&gt;. By default, all three are exported by the &lt;code&gt;use Test;&lt;/code&gt; statement.</source>
          <target state="translated">这个模块定义了三个公共函数， &lt;code&gt;plan(...)&lt;/code&gt; ， &lt;code&gt;ok(...)&lt;/code&gt; 和 &lt;code&gt;skip(...)&lt;/code&gt; 。默认情况下，这三个都通过 &lt;code&gt;use Test;&lt;/code&gt; 导出；陈述。</target>
        </trans-unit>
        <trans-unit id="fd200c0735cc5781411adf38498d8ea6b289e130" translate="yes" xml:space="preserve">
          <source>This module directly uses hash keys in the &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; singleton. This module is also obsolete thanks to the benefits of &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;. Use &lt;code&gt;intercept()&lt;/code&gt; from &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; to achieve a similar result.</source>
          <target state="translated">该模块直接在&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;单例中使用哈希键。由于&lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;的优点，该模块也已过时。使用 &lt;code&gt;intercept()&lt;/code&gt; 从&lt;a href=&quot;Test2::API&quot;&gt;Test2的:: API&lt;/a&gt;来实现类似的结果。</target>
        </trans-unit>
        <trans-unit id="0d26bb4e43183e0559ebca4dee112bd3a0d0b364" translate="yes" xml:space="preserve">
          <source>This module encapsulates reading &lt;a href=&quot;../cpan&quot;&gt;Distroprefs&lt;/a&gt; and matching them against CPAN distributions.</source>
          <target state="translated">该模块封装了读取&lt;a href=&quot;../cpan&quot;&gt;Distroprefs&lt;/a&gt;并将其与CPAN分布进行匹配的功能。</target>
        </trans-unit>
        <trans-unit id="9be6ae2c9023c3906f7ade946637f011010709ad" translate="yes" xml:space="preserve">
          <source>This module encapsulates reading &lt;a href=&quot;cpan&quot;&gt;Distroprefs&lt;/a&gt; and matching them against CPAN distributions.</source>
          <target state="translated">该模块封装了读取&lt;a href=&quot;cpan&quot;&gt;Distroprefs&lt;/a&gt;并将其与CPAN分布进行匹配的功能。</target>
        </trans-unit>
        <trans-unit id="0c9dfd5842361144dbb1663f5f104740841b03d0" translate="yes" xml:space="preserve">
          <source>This module ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">这个模块确保所有写入DBM文件的数据都是空结束的。当你有一个perl脚本需要与一个C程序也使用的DBM文件进行交互时,这个模块是非常有用的。一个相当常见的问题是,当C程序向DBM文件写入数据时,会在一个字符串中包含终止的null。这个过滤器将确保所有写入DBM文件的数据可以被C程序读取。</target>
        </trans-unit>
        <trans-unit id="0972ca2731097996c9289706d9b5ff6a965c399a" translate="yes" xml:space="preserve">
          <source>This module exists only to provide overload resolution for Storable and similar modules. See &lt;a href=&quot;JSON::PP&quot;&gt;JSON::PP&lt;/a&gt; for more info about this class.</source>
          <target state="translated">该模块仅用于为可存储模块和类似模块提供过载解析。有关此类的更多信息，请参见&lt;a href=&quot;JSON::PP&quot;&gt;JSON :: PP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd7e8d1d3170c6e8daec0f86fc59011732a6349b" translate="yes" xml:space="preserve">
          <source>This module exports convenience functions for all of the class methods provided by File::Spec.</source>
          <target state="translated">该模块为File::Spec提供的所有类方法输出方便函数。</target>
        </trans-unit>
        <trans-unit id="225bff521140d6082b4081701a5c9f07eb77dbdc" translate="yes" xml:space="preserve">
          <source>This module exports exactly one function, &lt;code&gt;memoize&lt;/code&gt; . The rest of the functions in this package are None of Your Business.</source>
          <target state="translated">该模块仅输出一个功能，即 &lt;code&gt;memoize&lt;/code&gt; 。该软件包中的其余功能与您无关。</target>
        </trans-unit>
        <trans-unit id="c756efb0d722016c58146ce901d559a7e357a513" translate="yes" xml:space="preserve">
          <source>This module exports exactly one function, &lt;code&gt;memoize&lt;/code&gt;. The rest of the functions in this package are None of Your Business.</source>
          <target state="translated">该模块仅输出一个功能，即 &lt;code&gt;memoize&lt;/code&gt; 。该软件包中的其余功能与您无关。</target>
        </trans-unit>
        <trans-unit id="7a437808a72f5186bb9fb8b3d0a47bad3b6c57c9" translate="yes" xml:space="preserve">
          <source>This module exports several subroutines from the older event API (see &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;). These subroutines can be used as methods on any object that provides a custom &lt;code&gt;facet_data()&lt;/code&gt; method. These subroutines can also be used as functions that take a facet data hashref as arguments.</source>
          <target state="translated">该模块从较旧的事件API导出几个子例程（请参见&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;）。这些子例程可用作提供自定义 &lt;code&gt;facet_data()&lt;/code&gt; 方法的任何对象上的方法。这些子例程还可以用作以facet数据hashref作为参数的函数。</target>
        </trans-unit>
        <trans-unit id="b53f8e98717e2df0ba097b4ab532a6f74e551ea4" translate="yes" xml:space="preserve">
          <source>This module exports two functions by default, &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; .</source>
          <target state="translated">默认情况下，此模块导出两个函数 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f39641613ab5773d894c474a71a45df157f1238" translate="yes" xml:space="preserve">
          <source>This module exports two functions by default, &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="translated">默认情况下，此模块导出两个函数 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d62e7ee6ec8e2b5b39029ab7ee6ccd36cf4dfeb9" translate="yes" xml:space="preserve">
          <source>This module extends the terse diagnostics normally emitted by both the perl compiler and the perl interpreter (from running perl with a -w switch or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ), augmenting them with the more explicative and endearing descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. Like the other pragmata, it affects the compilation phase of your program rather than merely the execution phase.</source>
          <target state="translated">该模块扩展了perl编译器和perl解释器通常发出的简洁诊断（通过使用-w开关运行perl或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ），并在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;提供了更详尽和有趣的描述，以增强它们的功能。像其他实用程序一样，它会影响程序的编译阶段，而不仅仅是执行阶段。</target>
        </trans-unit>
        <trans-unit id="d517678ea3b2b09bdfcb6b56d92700cd53a59e04" translate="yes" xml:space="preserve">
          <source>This module extends the terse diagnostics normally emitted by both the perl compiler and the perl interpreter (from running perl with a -w switch or &lt;code&gt;use warnings&lt;/code&gt;), augmenting them with the more explicative and endearing descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. Like the other pragmata, it affects the compilation phase of your program rather than merely the execution phase.</source>
          <target state="translated">该模块扩展了perl编译器和perl解释器通常发出的简洁诊断（通过使用-w开关运行perl或 &lt;code&gt;use warnings&lt;/code&gt; ），并在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;提供了更详尽和有趣的描述，以增强它们的功能。像其他实用程序一样，它会影响程序的编译阶段，而不仅仅是执行阶段。</target>
        </trans-unit>
        <trans-unit id="b01dd0d6475dbad2f311d0d4cb1dacdbdfac4d66" translate="yes" xml:space="preserve">
          <source>This module has a test that appears to work around a Test::Builder bug. The bug appears to have been fixed by Test2, which means the workaround causes a failure. This can be easily updated, but nobody has done so yet.</source>
          <target state="translated">这个模块有一个似乎可以绕过Test::Builder错误的测试。这个bug似乎已经被Test2修复了,这意味着这个变通方法会导致失败。这可以很容易地更新,但还没有人这样做。</target>
        </trans-unit>
        <trans-unit id="594092911e1167036ea965c7893b43a507a34b66" translate="yes" xml:space="preserve">
          <source>This module has been deprecated since perl v5.18. See &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot;&lt;/a&gt; and &lt;a href=&quot;#BUGS&quot;&gt;&quot;BUGS&quot;&lt;/a&gt;.</source>
          <target state="translated">从perl v5.18开始不推荐使用此模块。请参阅&lt;a href=&quot;#DESCRIPTION&quot;&gt;&amp;ldquo;说明&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#BUGS&quot;&gt;&amp;ldquo;错误&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ec683936a1587c1835f23fd06a510bf338b7e80" translate="yes" xml:space="preserve">
          <source>This module has been deprecated since perl v5.18. See &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; and &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;.</source>
          <target state="translated">从perl v5.18开始不推荐使用此模块。见&lt;a href=&quot;#DESCRIPTION&quot;&gt;描述&lt;/a&gt;和&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd94517622a9ab314f7601e60ecd6670f3bc957d" translate="yes" xml:space="preserve">
          <source>This module has two interfaces, one through color() and colored() and the other through constants. It also offers the utility functions uncolor(), colorstrip(), colorvalid(), and coloralias(), which have to be explicitly imported to be used (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt;).</source>
          <target state="translated">这个模块有两个接口，一个通过color（）和colored（），另一个通过常量。它还提供实用程序函数uncolor（），colorstrip（），colorvalid（）和coloralias（），必须显式导入才能使用（请参阅&lt;a href=&quot;#SYNOPSIS&quot;&gt;&amp;ldquo;提要&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2117e00acdbd9807a78cbd1ea4a675762026720f" translate="yes" xml:space="preserve">
          <source>This module has two interfaces, one through color() and colored() and the other through constants. It also offers the utility functions uncolor(), colorstrip(), colorvalid(), and coloralias(), which have to be explicitly imported to be used (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="translated">这个模块有两个接口，一个通过color（）和colored（），另一个通过常量。它还提供了实用函数uncolor（），colorstrip（），colorvalid（）和coloralias（），必须显式导入才能使用它们（请参见&lt;a href=&quot;#SYNOPSIS&quot;&gt;提要&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ff8b16c231dc1d713254a7cb8a480c66e2ae1bd1" translate="yes" xml:space="preserve">
          <source>This module implements &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; MIME encoding for an unstructured field body of the email header. It can also be used for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; 'text' token. However, it cannot be used directly for the whole header with the field name or for the structured header fields like From, To, Cc, Message-Id, etc... There are 3 encoding names supported by this module: &lt;code&gt;MIME-Header&lt;/code&gt;, &lt;code&gt;MIME-B&lt;/code&gt; and &lt;code&gt;MIME-Q&lt;/code&gt;.</source>
          <target state="translated">此模块为电子邮件标头的非结构化字段主体实现&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; MIME编码。它也可以用于&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; &amp;ldquo;文本&amp;rdquo;令牌。但是，它不能直接用于具有字段名的整个标题或结构化的标题字段，例如From，To，Cc，Message-Id等。此模块支持3种编码名称： &lt;code&gt;MIME-Header&lt;/code&gt; ， &lt;code&gt;MIME-B&lt;/code&gt; 和 &lt;code&gt;MIME-Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b510432f8750d5bbad1de7af5fced7b88ef44df" translate="yes" xml:space="preserve">
          <source>This module implements China-based Chinese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">该模块实现了基于中国的中文字符编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="18f94573bd55ebab6dfdf33a299319140ec5bdab" translate="yes" xml:space="preserve">
          <source>This module implements Japanese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了日语的字符集编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="85a823a7495a5d305f8dfc87daf3a9452bf40405" translate="yes" xml:space="preserve">
          <source>This module implements Korean charset encodings. Encodings supported are as follows.</source>
          <target state="translated">该模块实现了韩文字符集编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="1ac6b792bfff4da11b88119131c465048e55ab98" translate="yes" xml:space="preserve">
          <source>This module implements RFC 2047 Mime Header Encoding. There are 3 variant encoding names; &lt;code&gt;MIME-Header&lt;/code&gt; , &lt;code&gt;MIME-B&lt;/code&gt; and &lt;code&gt;MIME-Q&lt;/code&gt; . The difference is described below</source>
          <target state="translated">此模块实现RFC 2047 Mime标头编码。有3种变体编码名称； &lt;code&gt;MIME-Header&lt;/code&gt; ， &lt;code&gt;MIME-B&lt;/code&gt; 和 &lt;code&gt;MIME-Q&lt;/code&gt; 。区别描述如下</target>
        </trans-unit>
        <trans-unit id="fd2c9a90ea8e309e706421846f519bfe977d609d" translate="yes" xml:space="preserve">
          <source>This module implements UTF-7 encoding documented in RFC 2152. UTF-7, as its name suggests, is a 7-bit re-encoded version of UTF-16BE. It is designed to be MTA-safe and expected to be a standard way to exchange Unicoded mails via mails. But with the advent of UTF-8 and 8-bit compliant MTAs, UTF-7 is hardly ever used.</source>
          <target state="translated">这个模块实现了RFC 2152中记载的UTF-7编码。UTF-7,顾名思义,是UTF-16BE的7位重编码版本。它被设计成MTA安全的,并被期望成为通过邮件交换Unicoded邮件的标准方式。但随着UTF-8和8位兼容MTA的出现,UTF-7几乎没有被使用过。</target>
        </trans-unit>
        <trans-unit id="6a778bf541b175d3967361a621a9111e411a3873" translate="yes" xml:space="preserve">
          <source>This module implements a PerlIO layer that works on files encoded in the quoted-printable format. It will decode from quoted-printable while reading from a handle, and it will encode as quoted-printable while writing to a handle.</source>
          <target state="translated">这个模块实现了一个PerlIO层,它可以处理以quoted-printable格式编码的文件。当从一个句柄读取时,它将从quoted-printable解码,当向一个句柄写入时,它将编码为quoted-printable。</target>
        </trans-unit>
        <trans-unit id="ed550b03d65e4b729769320dd5e86c30fc421672" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the POP3 protocol, enabling a perl5 application to talk to POP3 servers. This documentation assumes that you are familiar with the POP3 protocol described in RFC1939.</source>
          <target state="translated">这个模块实现了一个POP3协议的客户端接口,使perl5应用程序能够与POP3服务器对话。本文档假定您熟悉RFC1939中描述的POP3协议。</target>
        </trans-unit>
        <trans-unit id="ed6c1f3c1c0cdf48fd7b4bf4c3f2799a1d9ccec9" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the POP3 protocol, enabling a perl5 application to talk to POP3 servers. This documentation assumes that you are familiar with the POP3 protocol described in RFC1939. With &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; installed it also provides support for implicit and explicit TLS encryption, i.e. POP3S or POP3+STARTTLS.</source>
          <target state="translated">该模块实现了POP3协议的客户端接口，使perl5应用程序可以与POP3服务器通信。本文档假定您熟悉RFC1939中描述的POP3协议。随着&lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO ::插座:: SSL&lt;/a&gt;安装它也提供了隐性和显性TLS加密，即POP3S或POP3 + STARTTLS支持。</target>
        </trans-unit>
        <trans-unit id="ee8852ef106e152ea9b50dda8dd1b7e4ef5a1d79" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the SMTP and ESMTP protocol, enabling a perl5 application to talk to SMTP servers. This documentation assumes that you are familiar with the concepts of the SMTP protocol described in RFC2821. With &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; installed it also provides support for implicit and explicit TLS encryption, i.e. SMTPS or SMTP+STARTTLS.</source>
          <target state="translated">该模块实现了SMTP和ESMTP协议的客户端接口，使perl5应用程序可以与SMTP服务器通信。本文档假定您熟悉RFC2821中描述的SMTP协议的概念。随着&lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO ::插座:: SSL&lt;/a&gt;安装它也提供了隐性和显性TLS加密，即SMTPS或SMTP + STARTTLS支持。</target>
        </trans-unit>
        <trans-unit id="f3343630b02b7f19c2e9f15e0bc9d4d62bafd5e3" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the SMTP and ESMTP protocol, enabling a perl5 application to talk to SMTP servers. This documentation assumes that you are familiar with the concepts of the SMTP protocol described in RFC821.</source>
          <target state="translated">这个模块实现了SMTP和ESMTP协议的客户端接口,使perl5应用程序能够与SMTP服务器对话。本文档假定您熟悉RFC821中描述的SMTP协议的概念。</target>
        </trans-unit>
        <trans-unit id="a98fb3b26850ae6b1ffeeed7c797dcc990c08524" translate="yes" xml:space="preserve">
          <source>This module implements a subset of the YAML specification for use in reading and writing CPAN metadata files like</source>
          <target state="translated">该模块实现了YAML规范的一个子集,用于读写CPAN元数据文件,如</target>
        </trans-unit>
        <trans-unit id="208a0fbb6b2b9365a0b457c6e7c2a20c4ee8bdbb" translate="yes" xml:space="preserve">
          <source>This module implements all Character Encoding Schemes of Unicode that are officially documented by Unicode Consortium (except, of course, for UTF-8, which is a native format in perl).</source>
          <target state="translated">这个模块实现了Unicode联盟官方文档中的所有Unicode字符编码方案(当然,UTF-8除外,它是perl中的本地格式)。</target>
        </trans-unit>
        <trans-unit id="4a5fc149cac5c063339467ffcf19fbcbdd274ebc" translate="yes" xml:space="preserve">
          <source>This module implements symbol and dingbats encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了符号和丁巴特的编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="91d2629cfba9471ae750b605c30149641a050967" translate="yes" xml:space="preserve">
          <source>This module implements the Windows-specific parts of ExtUtils::CBuilder. Most of the Windows-specific stuff has to do with compiling and linking C code. Currently we support the 3 compilers perl itself supports: MSVC, BCC, and GCC.</source>
          <target state="translated">这个模块实现了ExtUtils::CBuilder的Windows专用部分。大部分Windows专用的东西都与编译和链接C代码有关。目前我们支持perl本身所支持的3个编译器:MSVC、BCC和GCC。MSVC,BCC,和 GCC.</target>
        </trans-unit>
        <trans-unit id="b2e6ff1b1b109fdc596717b451bfa277cebdbf15" translate="yes" xml:space="preserve">
          <source>This module implements the environmental variables that &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; uses with TAP::Harness, and instantiates the appropriate class with the appropriate arguments.</source>
          <target state="translated">该模块实现&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;与TAP :: Harness一起使用的环境变量，并使用适当的参数实例化适当的类。</target>
        </trans-unit>
        <trans-unit id="f9fa4e0ad3f8d3bc6d28f8c2e962b8d03cb9cfa8" translate="yes" xml:space="preserve">
          <source>This module implements tradition Chinese charset encodings as used in Taiwan and Hong Kong. Encodings supported are as follows.</source>
          <target state="translated">这个模块实现了台湾和香港地区使用的传统中文字符编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="6d3abe1f6aae133c8268ef4a9c7e2b3f247e4b85" translate="yes" xml:space="preserve">
          <source>This module implements various EBCDIC-Based encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了各种基于EBCDIC的编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="71223016b72a87a85df3e296ab0f30c149dbcfa6" translate="yes" xml:space="preserve">
          <source>This module implements various single byte encodings. For most cases it uses \x80-\xff (upper half) to map non-ASCII characters. Encodings supported are as follows.</source>
          <target state="translated">这个模块实现了各种单字节编码。在大多数情况下,它使用\x80-\xff(上半部分)来映射非ASCII字符。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="cc2e021c9aa08753ca094f4f9555269ba3008c18" translate="yes" xml:space="preserve">
          <source>This module inherits from &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; , so any functionality not implemented here will be implemented there. The interfaces are defined by the &lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils::CBuilder&lt;/a&gt; documentation.</source>
          <target state="translated">该模块继承自 &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; ，因此此处未实现的任何功能都将在此处实现。接口由&lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils :: CBuilder&lt;/a&gt;文档定义。</target>
        </trans-unit>
        <trans-unit id="dbd924370062e7829b2938e0ae1c44db508d0978" translate="yes" xml:space="preserve">
          <source>This module inherits from &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt;, so any functionality not implemented here will be implemented there. The interfaces are defined by the &lt;a href=&quot;ExtUtils::CBuilder&quot;&gt;ExtUtils::CBuilder&lt;/a&gt; documentation.</source>
          <target state="translated">该模块继承自 &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; ，因此此处未实现的任何功能都将在此处实现。接口由&lt;a href=&quot;ExtUtils::CBuilder&quot;&gt;ExtUtils :: CBuilder&lt;/a&gt;文档定义。</target>
        </trans-unit>
        <trans-unit id="19da1ff10a7249eedb446c4c19eb17fbb02bae8e" translate="yes" xml:space="preserve">
          <source>This module internally uses the epoch seconds system that is provided via the perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function and supported by &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块在内部使用通过perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 函数提供并由 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 支持的纪元秒制。</target>
        </trans-unit>
        <trans-unit id="61f8df0862f677bbaf5b909f320f35cfb703f533" translate="yes" xml:space="preserve">
          <source>This module internally uses the epoch seconds system that is provided via the perl &lt;code&gt;time()&lt;/code&gt; function and supported by &lt;code&gt;gmtime()&lt;/code&gt; and &lt;code&gt;localtime()&lt;/code&gt;.</source>
          <target state="translated">该模块在内部使用通过perl &lt;code&gt;time()&lt;/code&gt; 函数提供并由 &lt;code&gt;gmtime()&lt;/code&gt; 和 &lt;code&gt;localtime()&lt;/code&gt; 支持的纪元秒制。</target>
        </trans-unit>
        <trans-unit id="458e3aac1c45af194716db0ddfa546c2e44d1b98" translate="yes" xml:space="preserve">
          <source>This module is a &quot;pure virtual base class&quot;--it has nothing of its own. It's just there to inherit from one of the various DBM packages. It prefers ndbm for compatibility reasons with Perl 4, then Berkeley DB (See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;), GDBM, SDBM (which is always there--it comes with Perl), and finally ODBM. This way old programs that used to use NDBM via dbmopen() can still do so, but new ones can reorder @ISA:</source>
          <target state="translated">该模块是一个&amp;ldquo;纯虚拟基类&amp;rdquo;，它没有自己的功能。它只是从各种DBM软件包之一继承而来的。由于与Perl 4的兼容性原因，它更喜欢ndbm，然后选择Berkeley DB（请参阅&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;），GDBM，SDBM（始终存在-Perl随附），最后选择ODBM。这样，以前通过dbmopen（）使用NDBM的旧程序仍然可以这样做，但是新程序可以对@ISA重新排序：</target>
        </trans-unit>
        <trans-unit id="845ef6f7f0c9f9a1cc4bdfcd24a8c21377a02413" translate="yes" xml:space="preserve">
          <source>This module is a back-end plugin for &lt;code&gt;Sys::Syslog&lt;/code&gt;, for supporting the Win32 event log. It is not expected to be directly used by any module other than &lt;code&gt;Sys::Syslog&lt;/code&gt; therefore it's API may change at any time and no warranty is made with regards to backward compatibility. You Have Been Warned.</source>
          <target state="translated">该模块是 &lt;code&gt;Sys::Syslog&lt;/code&gt; 的后端插件，用于支持Win32事件日志。除 &lt;code&gt;Sys::Syslog&lt;/code&gt; 之外，其他模块均不能直接使用它，因此它的API随时可能更改，并且不向后保证兼容性。你被警告了。</target>
        </trans-unit>
        <trans-unit id="1c04eeff8ead05e06a53857583cc861707b5c717" translate="yes" xml:space="preserve">
          <source>This module is a simple wrapper around &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt;, designed to alleviate the need of creating</source>
          <target state="translated">该模块是&lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt;的简单包装，旨在减轻创建的需要。</target>
        </trans-unit>
        <trans-unit id="e16f5e2a01129069277c30d3b7f3daee0fb1dd1b" translate="yes" xml:space="preserve">
          <source>This module is an implementation of Unicode Technical Standard #10 (a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).</source>
          <target state="translated">这个模块是Unicode技术标准#10 (a.k.a.UTS #10)-Unicode Collation Algorithm (a.k.a.UCA)的实现。</target>
        </trans-unit>
        <trans-unit id="c1b7492744c579fc1d9bfb8835d90982b09e7c1d" translate="yes" xml:space="preserve">
          <source>This module is an outgrowth of the &lt;code&gt;Module::Build&lt;/code&gt; project, to which there have been many contributors. Notably, Randy W. Sims submitted lots of code to support 3 compilers on Windows and helped with various other platform-specific issues. Ilya Zakharevich has contributed fixes for OS/2; John E. Malmberg and Peter Prymmer have done likewise for VMS.</source>
          <target state="translated">该模块是 &lt;code&gt;Module::Build&lt;/code&gt; 项目的产物，已经有许多贡献者。值得注意的是，Randy W. Sims提交了许多代码来支持Windows上的3个编译器，并帮助解决了其他各种特定于平台的问题。Ilya Zakharevich提供了OS / 2的修复程序。John E. Malmberg和Peter Prymmer也为VMS做过同样的事情。</target>
        </trans-unit>
        <trans-unit id="1f5ba4ee559ca9f1454b4c1a05d7f38b94f36610" translate="yes" xml:space="preserve">
          <source>This module is based on a Perl 4 library, timelocal.pl, that was included with Perl 4.036, and was most likely written by Tom Christiansen.</source>
          <target state="translated">这个模块是基于Perl 4.036中包含的Perl 4库timelocal.pl,很可能是由Tom Christiansen编写的。</target>
        </trans-unit>
        <trans-unit id="21726a2ed2ceba4bf9becf7c5cf61182d2b88157" translate="yes" xml:space="preserve">
          <source>This module is by no means trying to be a complete testing system. It's just to get you started. Once you're off the ground its recommended you look at &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">此模块绝不是要成为一个完整的测试系统。只是为了让您入门。一旦您动手了，建议您看一下&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cbc64a6620dfb67500a67bd41b8098f113352da" translate="yes" xml:space="preserve">
          <source>This module is by no means trying to be a complete testing system. It's just to get you started. Once you're off the ground its recommended you look at &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">此模块绝不是要成为一个完整的测试系统。只是为了让您入门。一旦您动手了，建议您看一下&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2753244f46b0ce153d304706dfb95e861d35abaf" translate="yes" xml:space="preserve">
          <source>This module is copyright (C) Charles Bailey, Tim Bunce and David Landgren 1995-2013. All rights reserved.</source>
          <target state="translated">本模块的版权归Charles Bailey,Tim Bunce和David Landgren 1995-2013所有。保留所有权利。</target>
        </trans-unit>
        <trans-unit id="e65fc814fbe25d163ecbf16ad77b4df5d27417a3" translate="yes" xml:space="preserve">
          <source>This module is copyright (C) Charles Bailey, Tim Bunce, David Landgren, James Keenan and Richard Elberger 1995-2018. All rights reserved.</source>
          <target state="translated">这个模块的版权是(C)Charles Bailey,Tim Bunce,David Landgren,James Keenan 和 Richard Elberger 1995-2018。保留所有权利。</target>
        </trans-unit>
        <trans-unit id="c3dc79528e0a53341f5f1a2385863e6d0f321326" translate="yes" xml:space="preserve">
          <source>This module is copyright (c) 2002 - 2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. All rights reserved.</source>
          <target state="translated">该模块的版权（c）2002-2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;。版权所有。</target>
        </trans-unit>
        <trans-unit id="109646d03bdd7214b2601deb023ff86ae17771e5" translate="yes" xml:space="preserve">
          <source>This module is copyright 2005 Fergal Daly &amp;lt;fergal@esatclear.ie&amp;gt;, some parts are based on other people's work.</source>
          <target state="translated">该模块的版权为2005 Fergal Daly &amp;lt;fergal@esatclear.ie&amp;gt;，某些部分基于其他人的作品。</target>
        </trans-unit>
        <trans-unit id="1a6eac676c9809b9e5cbb0d9d7b173e56f481065" translate="yes" xml:space="preserve">
          <source>This module is currently derived from &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; by Adam Kennedy. If there are bugs in how it parses a particular META.yml file, please file a bug report in the YAML::Tiny bugtracker: &lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues&quot;&gt;https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues&lt;/a&gt;</source>
          <target state="translated">该模块当前源自Adam Kennedy的&lt;a href=&quot;YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;。如果解析特定META.yml文件的方式存在错误，请在YAML :: Tiny bugtracker中提交错误报告：&lt;a href=&quot;https://github.com/Perl-Toolchain-Gang/YAML-Tiny/issues&quot;&gt;https&lt;/a&gt;：//github.com/Perl-Toolchain-Gang/YAML-Tiny/issues</target>
        </trans-unit>
        <trans-unit id="e106aa2d7581dc33a3d1c862720a197c581da1e6" translate="yes" xml:space="preserve">
          <source>This module is designed to support operations commonly performed on file specifications (usually called &quot;file names&quot;, but not to be confused with the contents of a file, or Perl's file handles), such as concatenating several directory and file names into a single path, or determining whether a path is rooted. It is based on code directly taken from MakeMaker 5.17, code written by Andreas K&amp;ouml;nig, Andy Dougherty, Charles Bailey, Ilya Zakharevich, Paul Schinder, and others.</source>
          <target state="translated">此模块旨在支持通常对文件规范执行的操作（通常称为&amp;ldquo;文件名&amp;rdquo;，但不要与文件内容或Perl的文件句柄相混淆），例如将多个目录和文件名串联到单个路径中，或确定路径是否植根。它基于直接取自MakeMaker 5.17的代码，AndreasK&amp;ouml;nig，Andy Dougherty，Charles Bailey，Ilya Zakharevich，Paul Schinder等编写的代码。</target>
        </trans-unit>
        <trans-unit id="654671a6553728793de0b0c754d598a0cc86c710" translate="yes" xml:space="preserve">
          <source>This module is designed to work with &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. To make the Base64 transcoder example above really work, you could write a module like this:</source>
          <target state="translated">该模块旨在与&lt;a href=&quot;Encode::Encoding&quot;&gt;Encode :: Encoding一起使用&lt;/a&gt;。为了使上面的Base64转码器示例真正起作用，您可以编写类似以下的模块：</target>
        </trans-unit>
        <trans-unit id="b88b2f05f3eb8f5317475c544c0d41c821542019" translate="yes" xml:space="preserve">
          <source>This module is designed to work with &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. To make the Base64 transcoder example above really work, you could write a module like this:</source>
          <target state="translated">该模块旨在与&lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding一起使用&lt;/a&gt;。为了使上面的Base64转码器示例真正起作用，您可以编写如下模块：</target>
        </trans-unit>
        <trans-unit id="7317d71579025bf106df223a30767b582e4758a6" translate="yes" xml:space="preserve">
          <source>This module is directly inspired by chocolateboy's excellent Scope::Guard module.</source>
          <target state="translated">这个模块的灵感直接来源于chocolateboy的优秀Scope::Guard模块。</target>
        </trans-unit>
        <trans-unit id="3eaa300076a46b36258692823afcaf30f3da1dac" translate="yes" xml:space="preserve">
          <source>This module is experimental, and may contain bugs. Please report bugs to the address below.</source>
          <target state="translated">这个模块是实验性的,可能会有bug。请将错误报告到以下地址。</target>
        </trans-unit>
        <trans-unit id="c60c17d643b09d45d994b9ae1fda9eedaf2d1fcf" translate="yes" xml:space="preserve">
          <source>This module is for testing only and should not normally be installed.</source>
          <target state="translated">本模块仅用于测试,一般不应安装。</target>
        </trans-unit>
        <trans-unit id="df5a318ad47ed1cb98fcceb8a257ad12588cd0fd" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件,你可以在与Perl本身相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="0fdd885419be85bc33964005f90fc4cadf3fdd76" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl.</source>
          <target state="translated">这个模块是自由软件,你可以在与Perl相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="922385d4cd422695e010d41aeec2d5c5dffbe730" translate="yes" xml:space="preserve">
          <source>This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件。它可以在与Perl本身相同的条款下使用、重新分配和/或修改。</target>
        </trans-unit>
        <trans-unit id="8713cb7bfbc646a13e38df90a39fe040d945517a" translate="yes" xml:space="preserve">
          <source>This module is free software. You may distribute it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是免费软件。你可以在与Perl本身相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="0a56766ff465fe3b64568012924af5a4fbf7de95" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself, i.e. under the terms of either the GNU General Public License or the Artistic License, as specified in the</source>
          <target state="translated">这个模块是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它,也就是在GNU通用公共许可证或艺术许可证的条款下,如在</target>
        </trans-unit>
        <trans-unit id="870a9546afdd84e9a3a4ff38074b2ee21c55579d" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="c0830e7b6d0dd0580741b7e45292c09ed7c6c8d7" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">该模块是免费软件；您可以按照与Perl本身相同的条款重新分发和/或修改它。参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e9a38691db3cd4123a0732405c5584fd7d1ade2" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">该模块是免费软件；您可以按照与Perl本身相同的条款重新分发和/或修改它。见&lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3300a405455959dd665a3badfe243e6fa30c2626" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件;你可以在与Perl本身相同的条件下重新发布或修改它。</target>
        </trans-unit>
        <trans-unit id="428130d7bad8c548e3890e11a89bef5821bc3665" translate="yes" xml:space="preserve">
          <source>This module is just a translation of the C</source>
          <target state="translated">这个模块只是对C</target>
        </trans-unit>
        <trans-unit id="53d4261ed48fcbc4558e06b2e6b719f698501a77" translate="yes" xml:space="preserve">
          <source>This module is just for testing expiration semantics. It's not a very good example of how to write an expiration module.</source>
          <target state="translated">这个模块只是用来测试到期语义的。这不是一个很好的例子,如何写一个到期模块。</target>
        </trans-unit>
        <trans-unit id="0dc5b94f76b37ecce8785d42b0ffd5ab2b777674" translate="yes" xml:space="preserve">
          <source>This module is managed in an open GitHub repository, &lt;a href=&quot;https://github.com/perl-pod/pod-simple/&quot;&gt;https://github.com/perl-pod/pod-simple/&lt;/a&gt;. Feel free to fork and contribute, or to clone &lt;a href=&quot;git://github.com/perl-pod/pod-simple.git&quot;&gt;git://github.com/perl-pod/pod-simple.git&lt;/a&gt; and send patches!</source>
          <target state="translated">该模块在开放的GitHub存储库&lt;a href=&quot;https://github.com/perl-pod/pod-simple/&quot;&gt;https://github.com/perl-pod/pod-simple/中进行管理&lt;/a&gt;。随意分叉和贡献，或克隆&lt;a href=&quot;git://github.com/perl-pod/pod-simple.git&quot;&gt;git：//github.com/perl-pod/pod-simple.git&lt;/a&gt;并发送补丁！</target>
        </trans-unit>
        <trans-unit id="f745572f29549c61507fb4f34a61c7a87abbc5ec" translate="yes" xml:space="preserve">
          <source>This module is managed in an open GitHub repository, &lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/&lt;/a&gt;. Feel free to fork and contribute, or to clone &lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git://github.com/theory/pod-simple.git&lt;/a&gt; and send patches!</source>
          <target state="translated">该模块在开放的GitHub存储库&lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/中进行管理&lt;/a&gt;。随意分叉和贡献，或克隆&lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git：//github.com/theory/pod-simple.git&lt;/a&gt;并发送补丁！</target>
        </trans-unit>
        <trans-unit id="7d0ab6711ea5063095e0e85b171ef73740045783" translate="yes" xml:space="preserve">
          <source>This module is not compatible with Unix &lt;code&gt;compress&lt;/code&gt; .</source>
          <target state="translated">该模块与Unix &lt;code&gt;compress&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="13cc04317c942b05ce4555eb44ccdae6bba6d28a" translate="yes" xml:space="preserve">
          <source>This module is not compatible with Unix &lt;code&gt;compress&lt;/code&gt;.</source>
          <target state="translated">该模块与Unix &lt;code&gt;compress&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="d1c6a1686a9e6172b47ee3f5d419b358b2cc40a5" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Compress modules.</source>
          <target state="translated">这个模块不打算直接用于应用程序代码中,它的唯一目的是被IO::Compress模块子类化。它的唯一目的是被IO::Compress模块子类化。</target>
        </trans-unit>
        <trans-unit id="0f3671c101f1cebdeab0ce875c68fe36c60360d8" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Uncompress modules.</source>
          <target state="translated">这个模块不打算直接用于应用程序代码中,它的唯一目的是被IO::Uncompress模块子类化。它的唯一目的是被IO::Uncompress模块子类化。</target>
        </trans-unit>
        <trans-unit id="a4123b1c619055b343db1dd9134cd19fd6bddf30" translate="yes" xml:space="preserve">
          <source>This module is not meant to be installed.</source>
          <target state="translated">这个模块不是用来安装的。</target>
        </trans-unit>
        <trans-unit id="7164bd2152d2e3839e89dbfa3b86eaa11bce3dbe" translate="yes" xml:space="preserve">
          <source>This module is part of the Time::Piece distribution. It allows the user to find out the number of minutes, hours, days, weeks or years in a given number of seconds. It is returned by Time::Piece when you delta two Time::Piece objects.</source>
          <target state="translated">这个模块是Time::Piece分布的一部分,它允许用户在给定的秒数中找出分钟、小时、天、周或年的数量。它允许用户在给定的秒数中找出分钟、小时、天、周或年的数量。当你把两个Time::Piece对象进行三角运算时,Time::Piece会返回这个模块。</target>
        </trans-unit>
        <trans-unit id="22df619b80747d338bb7c64e8fdc1d4aef53ad12" translate="yes" xml:space="preserve">
          <source>This module is part of the core Perl distribution and is also maintained for CPAN by Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;.</source>
          <target state="translated">该模块是Perl核心发行版的一部分，并且由Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;维护，用于CPAN。</target>
        </trans-unit>
        <trans-unit id="194bd926549ad2d7bd7a1e89514e8690d0700ec1" translate="yes" xml:space="preserve">
          <source>This module is released under the same terms as Perl itself.</source>
          <target state="translated">这个模块是在与Perl本身相同的条件下发布的。</target>
        </trans-unit>
        <trans-unit id="9e7d44a3d58cea8a100de62304c29f63b460d560" translate="yes" xml:space="preserve">
          <source>This module is still in beta. Cygwin-knowledgeable folks are invited to offer patches and suggestions.</source>
          <target state="translated">该模块仍处于测试阶段。我们邀请熟悉Cygwin的人提供补丁和建议。</target>
        </trans-unit>
        <trans-unit id="1ba87a51378e67bc34037dd0cee84645dd48c97c" translate="yes" xml:space="preserve">
          <source>This module is the result of archaeology undertaken during QA Hackathon in Lancaster, April 2013.</source>
          <target state="translated">这个模块是2013年4月在兰开斯特的QA Hackathon期间进行的考古结果。</target>
        </trans-unit>
        <trans-unit id="f3a7ded1d62af46df9b70aea1e61bb63a4d5e250" translate="yes" xml:space="preserve">
          <source>This module is used by &lt;code&gt;h2xs&lt;/code&gt; to write the file</source>
          <target state="translated">&lt;code&gt;h2xs&lt;/code&gt; 使用此模块写入文件</target>
        </trans-unit>
        <trans-unit id="a7926bd29bba2324b3fe7c588f46c743752e1304" translate="yes" xml:space="preserve">
          <source>This module is used for running batch-conversions of a lot of HTML documents</source>
          <target state="translated">该模块用于运行大量的HTML文档的批量转换。</target>
        </trans-unit>
        <trans-unit id="839a2e768fddb8f7898e0f04347e52df5765427a" translate="yes" xml:space="preserve">
          <source>This module is used internally as a base class by Time::localtime And Time::gmtime functions. It creates a Time::tm struct object which is addressable just like's C's tm structure from</source>
          <target state="translated">这个模块在内部被Time::localtime和Time::gmtime函数用作基类。它创建了一个Time::tm结构对象,这个结构对象就像C语言的tm结构一样,可以从</target>
        </trans-unit>
        <trans-unit id="07f553b400d2280f304688df200f5b35ef787f6a" translate="yes" xml:space="preserve">
          <source>This module is used to implement the special hashes &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , but it can be used to tie other variables as you choose.</source>
          <target state="translated">该模块用于实现特殊的哈希 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; ，但可以根据需要绑定其他变量。</target>
        </trans-unit>
        <trans-unit id="019b8504cd55dd2221ad4da8c02fa2cb855f46b3" translate="yes" xml:space="preserve">
          <source>This module is used to implement the special hashes &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt;, but it can be used to tie other variables as you choose.</source>
          <target state="translated">该模块用于实现特殊的哈希 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; ，但可以根据需要绑定其他变量。</target>
        </trans-unit>
        <trans-unit id="400485993cd01628da068b6aef093ffdc1938d7e" translate="yes" xml:space="preserve">
          <source>This module is used to represent and manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; objects. Hubs are usually in a stack so that you can push a new hub into place that can intercept and handle events differently than the primary hub.</source>
          <target state="translated">该模块用于表示和管理&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hub&lt;/a&gt;对象的堆栈。集线器通常位于堆栈中，因此您可以将新的集线器推入到位，该集线器可以与主集线器不同地截取和处理事件。</target>
        </trans-unit>
        <trans-unit id="0b6698e75a7d3422775d333b4412918e440bfbef" translate="yes" xml:space="preserve">
          <source>This module is used to test that the XS typemaps distributed with perl are working as advertised. A function is available for each typemap definition (eventually). In general each function takes a variable, processes it through the OUTPUT typemap and then returns it using the INPUT typemap.</source>
          <target state="translated">该模块用于测试与perl一起发布的XS类型图是否如宣传的那样工作。每个类型地图定义都有一个函数(最终)。一般来说,每个函数都接收一个变量,通过OUTPUT类型图进行处理,然后使用INPUT类型图返回。</target>
        </trans-unit>
        <trans-unit id="1910d98cb0d7696e9377a9fe44d03beb3d7a9af8" translate="yes" xml:space="preserve">
          <source>This module is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">当与一个C/C++应用程序进行交互时,这个模块被用于使用C int作为DBM文件中的键和/或值。</target>
        </trans-unit>
        <trans-unit id="d8aa8f33e315204f28ac3fdb706ab3fb362c4d36" translate="yes" xml:space="preserve">
          <source>This module is useful for people who are writing their own back end, or who are learning about the Perl internals. It's not useful to the average programmer.</source>
          <target state="translated">这个模块对于正在编写自己的后端,或者正在学习Perl内部的人很有用。对普通程序员来说,它没有用处。</target>
        </trans-unit>
        <trans-unit id="e9e0d93149553207adf6e63dfb540679634ba91d" translate="yes" xml:space="preserve">
          <source>This module is very unusual as overloaded modules go: it does not provide any usual overloaded operators, instead it provides an implementation for &lt;a href=&quot;#nomethod&quot;&gt;&quot;&lt;code&gt;nomethod&lt;/code&gt;&quot;&lt;/a&gt;. In this example the &lt;code&gt;nomethod&lt;/code&gt; subroutine returns an object which encapsulates operations done over the objects: &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['n', 3]&lt;/code&gt;, &lt;code&gt;2 + symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt;.</source>
          <target state="translated">随着重载模块的发展，该模块非常不寻常：它不提供任何常用的重载运算符，而是提供了&lt;a href=&quot;#nomethod&quot;&gt;&amp;ldquo; &lt;code&gt;nomethod&lt;/code&gt; &amp;rdquo;&lt;/a&gt;的实现。在此示例中， &lt;code&gt;nomethod&lt;/code&gt; 子例程返回一个对象，该对象封装了对该对象执行的操作： &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['n', 3]&lt;/code&gt; ， &lt;code&gt;2 + symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="422eedc66ca57180bd78963179219d9ec2d2c3fd" translate="yes" xml:space="preserve">
          <source>This module is very unusual as overloaded modules go: it does not provide any usual overloaded operators, instead it provides an implementation for &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;. In this example the &lt;code&gt;nomethod&lt;/code&gt; subroutine returns an object which encapsulates operations done over the objects: &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['n', 3]&lt;/code&gt; , &lt;code&gt;2 +
symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; .</source>
          <target state="translated">随着重载模块的发展，该模块非常不寻常：它不提供任何常用的重载运算符，而是提供了&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;的实现。在此示例中， &lt;code&gt;nomethod&lt;/code&gt; 子例程返回一个对象，该对象封装了对对象执行的操作： &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['n', 3]&lt;/code&gt; ， &lt;code&gt;2 + symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90d7abe099cfab7f646294358451750b8f9df26b" translate="yes" xml:space="preserve">
          <source>This module looks at several environment variables: REQUEST_METHOD, HTTP_ACCEPT_LANGUAGE, LANGUAGE, LC_ALL, LC_MESSAGES, and LANG.</source>
          <target state="translated">这个模块关注了几个环境变量。REQUEST_METHOD、HTTP_ACCEPT_LANGUAGE、LANGUAGE、LC_ALL、LC_MESSAGES 和 LANG。</target>
        </trans-unit>
        <trans-unit id="c4c8914133b0b2bfc077d6c38150d307c0367148" translate="yes" xml:space="preserve">
          <source>This module looks for several environment variables, including REQUEST_METHOD, HTTP_ACCEPT_LANGUAGE, LANGUAGE, LC_ALL, LC_MESSAGES, and LANG.</source>
          <target state="translated">这个模块寻找几个环境变量,包括REQUEST_METHOD、HTTP_ACCEPT_LANGUAGE、LANGUAGE、LC_ALL、LC_MESSAGES和LANG。</target>
        </trans-unit>
        <trans-unit id="0ac738d7d9941c37feb5165dcbb5c6ab9416052c" translate="yes" xml:space="preserve">
          <source>This module may change to use a different pod-to-nroff formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">这个模块将来可能会改变使用不同的pod-to-nroffformatter类,这可能会改变支持的选项。</target>
        </trans-unit>
        <trans-unit id="76f27fbed99d6c60d342c39616884795be44e886" translate="yes" xml:space="preserve">
          <source>This module may change to use a different text formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">这个模块将来可能会改变使用不同的文本格式化类,这可能会改变支持的选项。</target>
        </trans-unit>
        <trans-unit id="94ae7d6ead04954a6412192772bd33bb7b8d4073" translate="yes" xml:space="preserve">
          <source>This module mediates between some version that perl sees in a package and the version that is published by the CPAN indexer.</source>
          <target state="translated">这个模块介于perl在软件包中看到的一些版本和CPAN索引器发布的版本之间。</target>
        </trans-unit>
        <trans-unit id="c80cea19736436ea3f987c3515d4cecb255844b4" translate="yes" xml:space="preserve">
          <source>This module needs Compress::Zlib.</source>
          <target state="translated">这个模块需要 Compress::Zlib。</target>
        </trans-unit>
        <trans-unit id="a8a13e816f80341d5aa494b1b85b44f3bab37b43" translate="yes" xml:space="preserve">
          <source>This module needs Perl5.005 or better.</source>
          <target state="translated">该模块需要Perl5.005或更高版本。</target>
        </trans-unit>
        <trans-unit id="2b02becbf011b5e3018f1c6556299552bd0354bc" translate="yes" xml:space="preserve">
          <source>This module needs the Encode module.</source>
          <target state="translated">这个模块需要Encode模块。</target>
        </trans-unit>
        <trans-unit id="9ccf2db8e0457ff61f46dc8eef8b595c0400ca84" translate="yes" xml:space="preserve">
          <source>This module needs to have been built with zlib 1.2.1 or better to work. A fatal error will be thrown if &lt;code&gt;Merge&lt;/code&gt; is used with an older version of zlib.</source>
          <target state="translated">必须使用zlib 1.2.1或更高版本构建此模块才能使用。如果将 &lt;code&gt;Merge&lt;/code&gt; 与较早版本的zlib一起使用，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="7cdcfb5298a84fa590094f08e92147e6cb58d161" translate="yes" xml:space="preserve">
          <source>This module offers a single utility function, &lt;code&gt;findsym()&lt;/code&gt; .</source>
          <target state="translated">该模块提供单个实用程序函数 &lt;code&gt;findsym()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90cadc0e8c5645533036401c53c00aa9ed6d065f" translate="yes" xml:space="preserve">
          <source>This module offers a single utility function, &lt;code&gt;findsym()&lt;/code&gt;.</source>
          <target state="translated">该模块提供单个实用程序函数 &lt;code&gt;findsym()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd94e0e36732e7bf036abc385f751fb424ec5ec9" translate="yes" xml:space="preserve">
          <source>This module only provides a single function, parselink(), which takes the text of an L&amp;lt;&amp;gt; formatting code and parses it. It returns the anchor text for the link (if any was given), the anchor text possibly inferred from the name and section, the name or URL, the section if any, and the type of link. The type will be one of &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;pod&lt;/code&gt; , or &lt;code&gt;man&lt;/code&gt; , indicating a URL, a link to a POD page, or a link to a Unix manual page.</source>
          <target state="translated">该模块仅提供一个函数parselink（），该函数接受L &amp;lt;&amp;gt;格式代码的文本并进行解析。它返回链接的锚文本（如果给出了锚文本），可能从名称和节，名称或URL，节（如果有）以及链接类型推断出的锚文本。类型将是 &lt;code&gt;url&lt;/code&gt; ， &lt;code&gt;pod&lt;/code&gt; 或 &lt;code&gt;man&lt;/code&gt; 之一，指示URL，指向POD页面的链接或指向Unix手册页面的链接。</target>
        </trans-unit>
        <trans-unit id="2d0a92cd5ce624849b5c0f1ceba2a38bdb80915f" translate="yes" xml:space="preserve">
          <source>This module only provides a single function, parselink(), which takes the text of an L&amp;lt;&amp;gt; formatting code and parses it. It returns the anchor text for the link (if any was given), the anchor text possibly inferred from the name and section, the name or URL, the section if any, and the type of link. The type will be one of &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;pod&lt;/code&gt;, or &lt;code&gt;man&lt;/code&gt;, indicating a URL, a link to a POD page, or a link to a Unix manual page.</source>
          <target state="translated">该模块仅提供一个函数parselink（），该函数接受L &amp;lt;&amp;gt;格式代码的文本并对其进行解析。它返回链接的锚文本（如果给出了锚文本），可能从名称和节，名称或URL，节（如果有的话）以及链接的类型推断出的锚文本。类型将是 &lt;code&gt;url&lt;/code&gt; ， &lt;code&gt;pod&lt;/code&gt; 或 &lt;code&gt;man&lt;/code&gt; 之一，指示URL，指向POD页面的链接或指向Unix手册页面的链接。</target>
        </trans-unit>
        <trans-unit id="3d4bf504a913c2345fd7fde3fd0264ab90a67f31" translate="yes" xml:space="preserve">
          <source>This module overloads two operators, stringify (&quot;&quot;) and numify (0+).</source>
          <target state="translated">这个模块重载了两个操作符,stringify(&quot;&quot;)和numify(0+)。</target>
        </trans-unit>
        <trans-unit id="2da35e4a0c12f0c93369385d5a64812790c47338" translate="yes" xml:space="preserve">
          <source>This module overrides &lt;code&gt;Test::Builder::subtest()&lt;/code&gt; and &lt;code&gt;Test::Builder::done_testing()&lt;/code&gt;. It also directly accesses hash elements of the singleton. It has not yet been fixed.</source>
          <target state="translated">该模块覆盖 &lt;code&gt;Test::Builder::subtest()&lt;/code&gt; 和 &lt;code&gt;Test::Builder::done_testing()&lt;/code&gt; 。它还直接访问单例的哈希元素。尚未修复。</target>
        </trans-unit>
        <trans-unit id="d52e08497f6544c9fedb6034ea4aa6706f4c4317" translate="yes" xml:space="preserve">
          <source>This module predefines the methods below:</source>
          <target state="translated">本模块预先定义了以下方法。</target>
        </trans-unit>
        <trans-unit id="af4cffa0841bdd7591fb2ce3aa6ee9b4fc1581e2" translate="yes" xml:space="preserve">
          <source>This module presumes that all packages on CPAN</source>
          <target state="translated">本模块假定CPAN上的所有包都是</target>
        </trans-unit>
        <trans-unit id="50019593ee938407217545d40776fee521fc69e2" translate="yes" xml:space="preserve">
          <source>This module prints the contents of the parse tree, but without as much information as &lt;a href=&quot;debug&quot;&gt;B::Debug&lt;/a&gt;. For comparison, &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; produced 96 lines of output from B::Debug, but only 6 from B::Terse.</source>
          <target state="translated">这个模块输出解析树的内容，但是没有&lt;a href=&quot;debug&quot;&gt;B :: Debug的信息&lt;/a&gt;。为了进行比较，请 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; 从B :: Debug产生了96行输出，但从B :: Terse仅产生了6行。</target>
        </trans-unit>
        <trans-unit id="138c64d225e0e78c4b8614f89899ef78a31a82d8" translate="yes" xml:space="preserve">
          <source>This module prints the contents of the parse tree, but without as much information as CPAN module B::Debug. For comparison, &lt;code&gt;print &quot;Hello, world.&quot;&lt;/code&gt; produced 96 lines of output from B::Debug, but only 6 from B::Terse.</source>
          <target state="translated">该模块输出解析树的内容，但没有CPAN模块B :: Debug的太多信息。为了进行比较，请 &lt;code&gt;print &quot;Hello, world.&quot;&lt;/code&gt; 从B :: Debug产生了96行输出，但从B :: Terse仅产生了6行。</target>
        </trans-unit>
        <trans-unit id="478ba76e6bcddb62163ef813460ff3c7881b3c2c" translate="yes" xml:space="preserve">
          <source>This module provide 3 convenience functions to calculate the digest of files. The following functions are provided:</source>
          <target state="translated">本模块提供3个方便的函数来计算文件的摘要。提供了以下功能。</target>
        </trans-unit>
        <trans-unit id="b0083752d49808e75aaa209a550d644242bd0980" translate="yes" xml:space="preserve">
          <source>This module provide a convenient way to create directories of arbitrary depth and to delete an entire directory subtree from the filesystem.</source>
          <target state="translated">该模块提供了一种方便的方法来创建任意深度的目录,并从文件系统中删除整个目录子树。</target>
        </trans-unit>
        <trans-unit id="b6054fa3fccb1f634d2e293413bd446f27771c13" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of bzip2 files/buffers.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="729eaec16403ec99e135cb527b2c362360b4f51e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1950.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1950的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="003753405c286c7fe622e166edd07fb3084e88a1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1951.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1951的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="450a22809e6b641290e567e29533943a53385d76" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1952.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1952的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="84795f8eb8a320fda32e6f1d9e107bd19023949a" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed in a number of formats that use the zlib compression library.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取使用zlib压缩库的各种格式的压缩文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="8e71e73c8ba4d3b122b4773810a5bebea41be94e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed with a variety of compression libraries.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取用各种压缩库压缩过的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="2c4e9ced7b139b449826926366ef08ab126e2617" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of zlib files/buffers.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取zlib文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="bb765e95103323750609fe94be953d11119327d1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing bzip2 compressed data to files or buffer.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将bzip2压缩数据写入文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="f21907b6980e5b1e79e7f9b10f3d5f2a64818f33" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1950.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1950中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="da5ecc8ed3afbcb78fee4753b59d94b3fd278392" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1951.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1951中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="4dad75c362e8d8f7864bd95ffad74f285ca796dd" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1952.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1952中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="776878df4a774de7ed832c7c095295fe08ea92ae" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing zip compressed data to files or buffer.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将zip压缩数据写入文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="2a114c29c27a96079e38fb7ba2d9cd2004ce7668" translate="yes" xml:space="preserve">
          <source>This module provides a convenient way to create directories of arbitrary depth and to delete an entire directory subtree from the filesystem.</source>
          <target state="translated">该模块提供了一种方便的方法来创建任意深度的目录,并从文件系统中删除整个目录子树。</target>
        </trans-unit>
        <trans-unit id="122a388521f8308fb94e1159722c14bed6d323e8" translate="yes" xml:space="preserve">
          <source>This module provides a function &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; that takes a language tag (see &lt;a href=&quot;../langtags&quot;&gt;I18N::LangTags&lt;/a&gt;) and returns the best attempt at an English name for it, or undef if it can't make sense of the tag.</source>
          <target state="translated">该模块提供了一个函数 &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; ，该函数带有一个语言标记（请参见&lt;a href=&quot;../langtags&quot;&gt;I18N :: LangTags&lt;/a&gt;），并以英语名称返回最佳尝试，如果不能，则返回undef标签的意义。</target>
        </trans-unit>
        <trans-unit id="e735e86bbb0a3bf0f9c8dca8d648ba33ac645037" translate="yes" xml:space="preserve">
          <source>This module provides a function &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; that takes a language tag (see &lt;a href=&quot;I18N::LangTags&quot;&gt;I18N::LangTags&lt;/a&gt;) and returns the best attempt at an English name for it, or undef if it can't make sense of the tag.</source>
          <target state="translated">该模块提供了一个函数 &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; ，该函数带有一个语言标签（请参见&lt;a href=&quot;I18N::LangTags&quot;&gt;I18N :: LangTags&lt;/a&gt;），并以英语名称返回最佳尝试，如果不能，则返回undef标签的意义。</target>
        </trans-unit>
        <trans-unit id="a229b32fb9a19828b51ceae6b05d370d58006916" translate="yes" xml:space="preserve">
          <source>This module provides a mapping between an operating system name as given by &lt;code&gt;$^O&lt;/code&gt; and a more generic type. The initial version is based on the OS type mappings provided in &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; and &lt;a href=&quot;ExtUtils::CBuilder&quot;&gt;ExtUtils::CBuilder&lt;/a&gt;. (Thus, Microsoft operating systems are given the type 'Windows' rather than 'Win32'.)</source>
          <target state="translated">此模块提供 &lt;code&gt;$^O&lt;/code&gt; 给定的操作系统名称与更通用的类型之间的映射。初始版本基于&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt;和&lt;a href=&quot;ExtUtils::CBuilder&quot;&gt;ExtUtils :: CBuilder中&lt;/a&gt;提供的OS类型映射。（因此，Microsoft操作系统的类型为&amp;ldquo; Windows&amp;rdquo;，而不是&amp;ldquo; Win32&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="06aa681296d1fc9a7c2f005908eaaf8f3c4564bc" translate="yes" xml:space="preserve">
          <source>This module provides a protocol-independent way to use IPv4 and IPv6 sockets, intended as a replacement for &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt;. Most constructor arguments and methods are provided in a backward-compatible way. For a list of known differences, see the &lt;code&gt;IO::Socket::INET&lt;/code&gt; INCOMPATIBILITES section below.</source>
          <target state="translated">该模块提供了一种独立于协议的方式来使用IPv4和IPv6套接字，旨在替代&lt;a href=&quot;IO::Socket::INET&quot;&gt;IO :: Socket :: INET&lt;/a&gt;。大多数构造函数参数和方法都以向后兼容的方式提供。有关已知差异的列表，请参见下面的 &lt;code&gt;IO::Socket::INET&lt;/code&gt; INCOMPATIBILITES部分。</target>
        </trans-unit>
        <trans-unit id="1ab89d1d5e04832a54cc7d916a65558cc98a23de" translate="yes" xml:space="preserve">
          <source>This module provides a standard way to gather metadata about a .pm file through (mostly) static analysis and (some) code execution. When determining the version of a module, the &lt;code&gt;$VERSION&lt;/code&gt; assignment is &lt;code&gt;eval&lt;/code&gt;ed, as is traditional in the CPAN toolchain.</source>
          <target state="translated">该模块提供了一种通过（主要是）静态分析和（某些）代码执行来收集有关.pm文件的元数据的标准方法。在确定模块的 &lt;code&gt;$VERSION&lt;/code&gt; ，如CPAN工具链中的传统方法那样，将 &lt;code&gt;eval&lt;/code&gt; $ VERSION分配。</target>
        </trans-unit>
        <trans-unit id="96823924a180df110252f785d7a14a45c7a178c6" translate="yes" xml:space="preserve">
          <source>This module provides a variety of constants, structure manipulators and other functions related to socket-based networking. The values and functions provided are useful when used in conjunction with Perl core functions such as socket(), setsockopt() and bind(). It also provides several other support functions, mostly for dealing with conversions of network addresses between human-readable and native binary forms, and for hostname resolver operations.</source>
          <target state="translated">这个模块提供了各种常量、结构操纵器和其他与基于socket的网络有关的函数。所提供的值和函数在与socket()、setockopt()和bind()等Perl核心函数结合使用时非常有用。它还提供了其他一些支持函数,主要用于处理网络地址在人可读和本地二进制形式之间的转换,以及用于主机名解析器操作。</target>
        </trans-unit>
        <trans-unit id="c14c6338e762c52ff6d582916956b99716820151" translate="yes" xml:space="preserve">
          <source>This module provides aliases for the built-in variables whose names no one seems to like to read. Variables with side-effects which get triggered just by accessing them (like $0) will still be affected.</source>
          <target state="translated">这个模块为内置变量提供了别名,这些变量的名字似乎没有人喜欢读。有副作用的变量,只要访问它们就会被触发(比如$0),它们仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="db82fd21a4c838f2cb867e238f620528a9b4e06a" translate="yes" xml:space="preserve">
          <source>This module provides an interface that allows filters to be applied to tied Hashes associated with DBM files. It builds on the DBM Filter hooks that are present in all the *DB*_File modules included with the standard Perl source distribution from version 5.6.1 onwards. In addition to the *DB*_File modules distributed with Perl, the BerkeleyDB module, available on CPAN, supports the DBM Filter hooks. See &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt; for more details on the DBM Filter hooks.</source>
          <target state="translated">该模块提供了一个接口，该接口允许将过滤器应用于与DBM文件关联的绑定哈希。它建立在DBM筛选器挂钩上，该挂钩存在于从5.6.1版开始的标准Perl源代码发行版随附的所有* DB * _File模块中。除了与Perl一起发行的* DB * _File模块外，CPAN上可用的BerkeleyDB模块还支持DBM过滤器挂钩。有关DBM筛选器挂钩的更多详细信息，请参见&lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b24b2421d4d30b4ae85eba6a79f975fb3c67219" translate="yes" xml:space="preserve">
          <source>This module provides four global hashes:</source>
          <target state="translated">这个模块提供了四个全局哈希。</target>
        </trans-unit>
        <trans-unit id="d5d483b4b377e197aedecfe9fa15f04f3c6c2c95" translate="yes" xml:space="preserve">
          <source>This module provides functions for determining the pathname of the current working directory. It is recommended that getcwd (or another *cwd() function) be used in</source>
          <target state="translated">本模块提供了确定当前工作目录路径名的函数,建议在工作中使用getcwd(或其他*cwd()函数)。建议在本模块中使用getcwd(或其他*cwd()函数)。</target>
        </trans-unit>
        <trans-unit id="37033effa06ce25f227ce23dc6a9e45e7efa61d9" translate="yes" xml:space="preserve">
          <source>This module provides functions that are the inverse of built-in perl functions &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. They accept a date as a six-element array, and return the corresponding &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; value in seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix, for example). This value can be positive or negative, though POSIX only requires support for positive values, so dates before the system's epoch may not work on all operating systems.</source>
          <target state="translated">该模块提供的功能与内置的perl函数 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 相反。它们接受日期作为六元素数组，并返回自系统纪元（例如，Unix上的GMT，1970年1月1日，午夜 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; 以来的相应time（2）值（以秒为单位）。尽管POSIX仅要求支持正值，但该值可以是正值或负值，因此系统纪元之前的日期可能不适用于所有操作系统。</target>
        </trans-unit>
        <trans-unit id="392d323e4c70390d247af9b47465d1285979f82d" translate="yes" xml:space="preserve">
          <source>This module provides functions that are the inverse of built-in perl functions &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;. They accept a date as a six-element array, and return the corresponding &lt;code&gt;time(2)&lt;/code&gt; value in seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix, for example). This value can be positive or negative, though POSIX only requires support for positive values, so dates before the system's epoch may not work on all operating systems.</source>
          <target state="translated">该模块提供的功能与内置perl函数 &lt;code&gt;localtime()&lt;/code&gt; 和 &lt;code&gt;gmtime()&lt;/code&gt; 相反。它们接受一个由六元素组成的数组的日期，并以系统纪元（例如，Unix上的格林尼治标准时间1970年1月1日，午夜 &lt;code&gt;time(2)&lt;/code&gt; 为单位返回相应的time（2）值（以秒为单位）。尽管POSIX仅要求支持正值，但该值可以是正值或负值，因此系统纪元之前的日期可能不适用于所有操作系统。</target>
        </trans-unit>
        <trans-unit id="d1ece64b49e28f99121f72eab284aec43cb55951" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the base64 encoding specified in RFC 2045 -</source>
          <target state="translated">这个模块提供了将字符串编码和解码为RFC 2045------------------------------------------------的base64编码的功能。</target>
        </trans-unit>
        <trans-unit id="990d143d4bc42dc7eed0bcd6394bda54ff57474f" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the quoted-printable encoding specified in RFC 2045 -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e1b2c2210a010cd2575fe18207624d8324387f" translate="yes" xml:space="preserve">
          <source>This module provides linguistic tailoring for it taking advantage of &lt;code&gt;Unicode::Collate&lt;/code&gt;.</source>
          <target state="translated">该模块利用 &lt;code&gt;Unicode::Collate&lt;/code&gt; 为它提供语言定制。</target>
        </trans-unit>
        <trans-unit id="abe4c30f310ea99cbe1696d0845fc7519b7463f7" translate="yes" xml:space="preserve">
          <source>This module provides lists of modules that are broken, or have been broken in the past, when upgrading &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to use &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="translated">当升级&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;以使用&lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;时，此模块提供了已损坏或过去已损坏的模块的列表。</target>
        </trans-unit>
        <trans-unit id="0c4de2f96f0939e0587055f3524c8f314354960c" translate="yes" xml:space="preserve">
          <source>This module provides methods for array-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie an array to a package. The basic &lt;b&gt;Tie::Array&lt;/b&gt; package provides stub &lt;code&gt;DESTROY&lt;/code&gt; , and &lt;code&gt;EXTEND&lt;/code&gt; methods that do nothing, stub &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;EXISTS&lt;/code&gt; methods that croak() if the delete() or exists() builtins are ever called on the tied array, and implementations of &lt;code&gt;PUSH&lt;/code&gt; , &lt;code&gt;POP&lt;/code&gt; , &lt;code&gt;SHIFT&lt;/code&gt; , &lt;code&gt;UNSHIFT&lt;/code&gt; , &lt;code&gt;SPLICE&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; in terms of basic &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , &lt;code&gt;FETCHSIZE&lt;/code&gt; , &lt;code&gt;STORESIZE&lt;/code&gt; .</source>
          <target state="translated">该模块提供了用于数组绑定类的方法。有关将数组绑定到包所需的功能列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本&lt;b&gt;领带::阵列&lt;/b&gt;封装提供存根 &lt;code&gt;DESTROY&lt;/code&gt; 和 &lt;code&gt;EXTEND&lt;/code&gt; 什么也不做，存根方法 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;EXISTS&lt;/code&gt; 的方法是呱呱叫（）如果删除（）或存在（）内建曾经被称为绑阵列上，并且实现 &lt;code&gt;PUSH&lt;/code&gt; ， &lt;code&gt;POP&lt;/code&gt; ， &lt;code&gt;SHIFT&lt;/code&gt; ， &lt;code&gt;UNSHIFT&lt;/code&gt; ， &lt;code&gt;SPLICE&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 在基本 &lt;code&gt;FETCH&lt;/code&gt; ， &lt;code&gt;STORE&lt;/code&gt; ， &lt;code&gt;FETCHSIZE&lt;/code&gt; 方面， &lt;code&gt;STORESIZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f29d11225e822d19d127266ee941b28ea4361eb8" translate="yes" xml:space="preserve">
          <source>This module provides methods for array-tying classes. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie an array to a package. The basic &lt;b&gt;Tie::Array&lt;/b&gt; package provides stub &lt;code&gt;DESTROY&lt;/code&gt;, and &lt;code&gt;EXTEND&lt;/code&gt; methods that do nothing, stub &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;EXISTS&lt;/code&gt; methods that croak() if the delete() or exists() builtins are ever called on the tied array, and implementations of &lt;code&gt;PUSH&lt;/code&gt;, &lt;code&gt;POP&lt;/code&gt;, &lt;code&gt;SHIFT&lt;/code&gt;, &lt;code&gt;UNSHIFT&lt;/code&gt;, &lt;code&gt;SPLICE&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; in terms of basic &lt;code&gt;FETCH&lt;/code&gt;, &lt;code&gt;STORE&lt;/code&gt;, &lt;code&gt;FETCHSIZE&lt;/code&gt;, &lt;code&gt;STORESIZE&lt;/code&gt;.</source>
          <target state="translated">该模块提供了用于数组绑定类的方法。有关将数组绑定到程序包所需的功能列表，请参见&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;。基本&lt;b&gt;领带::阵列&lt;/b&gt;封装提供存根 &lt;code&gt;DESTROY&lt;/code&gt; 和 &lt;code&gt;EXTEND&lt;/code&gt; 什么也不做，存根方法 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;EXISTS&lt;/code&gt; 的方法是呱呱叫（）如果删除（）或存在（）内建曾经被称为绑阵列上，并且实现 &lt;code&gt;PUSH&lt;/code&gt; ， &lt;code&gt;POP&lt;/code&gt; ， &lt;code&gt;SHIFT&lt;/code&gt; ， &lt;code&gt;UNSHIFT&lt;/code&gt; ， &lt;code&gt;SPLICE&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 在基本 &lt;code&gt;FETCH&lt;/code&gt; ， &lt;code&gt;STORE&lt;/code&gt; ， &lt;code&gt;FETCHSIZE&lt;/code&gt; ， &lt;code&gt;STORESIZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a02a6b6db2368ef791da2effa9e60fac9461270d" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for handle-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a handle to a package. The basic &lt;b&gt;Tie::Handle&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;PRINT&lt;/code&gt; , &lt;code&gt;PRINTF&lt;/code&gt; and &lt;code&gt;GETC&lt;/code&gt; .</source>
          <target state="translated">该模块为句柄绑定类提供了一些骨架方法。有关将句柄绑定到包所需的功能列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Handle&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHANDLE&lt;/code&gt; ， &lt;code&gt;PRINT&lt;/code&gt; ， &lt;code&gt;PRINTF&lt;/code&gt; 和 &lt;code&gt;GETC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee8f6e5404f98fd11ba8fe2fe719d028b8507eb" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for handle-tying classes. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a handle to a package. The basic &lt;b&gt;Tie::Handle&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHANDLE&lt;/code&gt;, &lt;code&gt;PRINT&lt;/code&gt;, &lt;code&gt;PRINTF&lt;/code&gt; and &lt;code&gt;GETC&lt;/code&gt;.</source>
          <target state="translated">该模块为句柄绑定类提供了一些骨架方法。有关将句柄绑定到包所需的功能的列表，请参见&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Handle&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHANDLE&lt;/code&gt; ， &lt;code&gt;PRINT&lt;/code&gt; ， &lt;code&gt;PRINTF&lt;/code&gt; 和 &lt;code&gt;GETC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1739e1ebdefff1631d8440f9ca833c6b68c52a" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for hash-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie a hash to a package. The basic &lt;b&gt;Tie::Hash&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; . The &lt;b&gt;Tie::StdHash&lt;/b&gt; and &lt;b&gt;Tie::ExtraHash&lt;/b&gt; packages provide most methods for hashes described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). They cause tied hashes to behave exactly like standard hashes, and allow for selective overwriting of methods. &lt;b&gt;Tie::Hash&lt;/b&gt; grandfathers the &lt;code&gt;new&lt;/code&gt; method: it is used if &lt;code&gt;TIEHASH&lt;/code&gt; is not defined in the case a class forgets to include a &lt;code&gt;TIEHASH&lt;/code&gt; method.</source>
          <target state="translated">该模块提供了一些用于哈希绑定类的骨架方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;，以获取将散列绑定到程序包所需的功能列表。基本的&lt;b&gt;Tie :: Hash&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHASH&lt;/code&gt; ， &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 。该&lt;b&gt;帖:: StdHash&lt;/b&gt;和&lt;b&gt;领带:: ExtraHash&lt;/b&gt;包提供用于描述哈希大多数方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;（例外是 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; ）。它们导致绑定哈希的行为与标准哈希完全相同，并允许方法的选择性覆盖。&lt;b&gt;领带::哈希&lt;/b&gt;祖父 &lt;code&gt;new&lt;/code&gt; 方法：如果 &lt;code&gt;TIEHASH&lt;/code&gt; 未包含 &lt;code&gt;TIEHASH&lt;/code&gt; 方法的情况下未定义TIEHASH，则使用此方法。</target>
        </trans-unit>
        <trans-unit id="e86347afc73eee0d0269a2eb0166a0d2b4987d04" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for hash-tying classes. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie a hash to a package. The basic &lt;b&gt;Tie::Hash&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHASH&lt;/code&gt;, &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt;. The &lt;b&gt;Tie::StdHash&lt;/b&gt; and &lt;b&gt;Tie::ExtraHash&lt;/b&gt; packages provide most methods for hashes described in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;). They cause tied hashes to behave exactly like standard hashes, and allow for selective overwriting of methods. &lt;b&gt;Tie::Hash&lt;/b&gt; grandfathers the &lt;code&gt;new&lt;/code&gt; method: it is used if &lt;code&gt;TIEHASH&lt;/code&gt; is not defined in the case a class forgets to include a &lt;code&gt;TIEHASH&lt;/code&gt; method.</source>
          <target state="translated">该模块提供了一些用于哈希绑定类的骨架方法。参见&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;以获得将散列绑定到包所需的功能列表。基本的&lt;b&gt;Tie :: Hash&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHASH&lt;/code&gt; ， &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 。该&lt;b&gt;帖:: StdHash&lt;/b&gt;和&lt;b&gt;领带:: ExtraHash&lt;/b&gt;包提供用于描述哈希大多数方法&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;（例外是 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; ）。它们导致绑定哈希的行为与标准哈希完全相同，并允许方法的选择性覆盖。&lt;b&gt;领带::哈希&lt;/b&gt;祖父 &lt;code&gt;new&lt;/code&gt; 方法：如果 &lt;code&gt;TIEHASH&lt;/code&gt; 未包含 &lt;code&gt;TIEHASH&lt;/code&gt; 方法的情况下未定义TIEHASH，则使用此方法。</target>
        </trans-unit>
        <trans-unit id="4010b9458f00ef557ee377f021a5154f08e74c91" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for scalar-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a scalar to a package. The basic &lt;b&gt;Tie::Scalar&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt; . The &lt;b&gt;Tie::StdScalar&lt;/b&gt; package provides all the methods specified in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;. It inherits from &lt;b&gt;Tie::Scalar&lt;/b&gt; and causes scalars tied to it to behave exactly like the built-in scalars, allowing for selective overloading of methods. The &lt;code&gt;new&lt;/code&gt; method is provided as a means of grandfathering, for classes that forget to provide their own &lt;code&gt;TIESCALAR&lt;/code&gt; method.</source>
          <target state="translated">该模块为标量绑定类提供了一些骨架方法。有关将标量与包绑定所需的功能的列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Scalar&lt;/b&gt;软件包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIESCALAR&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 和 &lt;code&gt;STORE&lt;/code&gt; 。该&lt;b&gt;帖:: StdScalar&lt;/b&gt;包提供了全部规定的方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。它继承自&lt;b&gt;Tie :: Scalar&lt;/b&gt;并导致与其绑定的标量的行为与内置标量完全相同，从而允许方法的选择性重载。该 &lt;code&gt;new&lt;/code&gt; 方法作为祖父的一种手段，对于忘记提供自己的类 &lt;code&gt;TIESCALAR&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1d35ccb6479014e9b69b5c1117e63a8ac16cdc51" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for scalar-tying classes. See &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a scalar to a package. The basic &lt;b&gt;Tie::Scalar&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIESCALAR&lt;/code&gt;, &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt;. The &lt;b&gt;Tie::StdScalar&lt;/b&gt; package provides all the methods specified in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;. It inherits from &lt;b&gt;Tie::Scalar&lt;/b&gt; and causes scalars tied to it to behave exactly like the built-in scalars, allowing for selective overloading of methods. The &lt;code&gt;new&lt;/code&gt; method is provided as a means of grandfathering, for classes that forget to provide their own &lt;code&gt;TIESCALAR&lt;/code&gt; method.</source>
          <target state="translated">该模块为标量绑定类提供了一些骨架方法。有关将标量与包绑定所需的功能的列表，请参见&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Scalar&lt;/b&gt;软件包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIESCALAR&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 和 &lt;code&gt;STORE&lt;/code&gt; 。该&lt;b&gt;帖:: StdScalar&lt;/b&gt;包提供了全部规定的方法&lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt;。它继承自&lt;b&gt;Tie :: Scalar，&lt;/b&gt;并导致与其关联的标量的行为与内置标量完全相同，从而允许方法的选择性重载。对于忘记提供自己的类的类，此 &lt;code&gt;new&lt;/code&gt; 方法是作为继承的一种方式提供的 &lt;code&gt;TIESCALAR&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="974d73b0ae9a5c62aa55b2cce046ca17c11ca806" translate="yes" xml:space="preserve">
          <source>This module provides support for big integer calculations. It is not intended to be used directly, but rather as a parent class for backend libraries used by Math::BigInt, Math::BigFloat, Math::BigRat, and related modules.</source>
          <target state="translated">该模块提供对大整数计算的支持。它不打算直接使用,而是作为Math::BigInt、Math::BigFloat、Math::BigRat以及相关模块所使用的后端库的父类。</target>
        </trans-unit>
        <trans-unit id="45a6ced9686dd2822231048fa2c17a6218884f07" translate="yes" xml:space="preserve">
          <source>This module provides the ability to use references as hash keys if you first &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; the hash variable to this module. Normally, only the keys of the tied hash itself are preserved as references; to use references as keys in hashes-of-hashes, use Tie::RefHash::Nestable, included as part of Tie::RefHash.</source>
          <target state="translated">如果您首先 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 哈希变量绑定到此模块，则此模块提供了将引用用作哈希键的功能。通常，只有绑定哈希表本身的键才保留为引用。要将引用用作哈希表中的键，请使用Tie :: RefHash :: Nestable（包含在Tie :: RefHash中）。</target>
        </trans-unit>
        <trans-unit id="b93d510d992a2ad95750d227093b68f7a2f27bd8" translate="yes" xml:space="preserve">
          <source>This module provides the ability to use references as hash keys if you first &lt;code&gt;tie&lt;/code&gt; the hash variable to this module. Normally, only the keys of the tied hash itself are preserved as references; to use references as keys in hashes-of-hashes, use Tie::RefHash::Nestable, included as part of Tie::RefHash.</source>
          <target state="translated">如果您首先 &lt;code&gt;tie&lt;/code&gt; 哈希变量绑定到此模块，则此模块提供了将引用用作哈希键的功能。通常，只有绑定哈希的密钥本身才保留为引用；要将引用用作哈希表中的键，请使用Tie :: RefHash :: Nestable（作为Tie :: RefHash的一部分包含在内）。</target>
        </trans-unit>
        <trans-unit id="ebae6f4a623ce67e5227c5968ced52d6ec8a379b" translate="yes" xml:space="preserve">
          <source>This module provides things that are useful in decoding Pod E&amp;lt;...&amp;gt; sequences. Presumably, it should be used only by Pod parsers and/or formatters.</source>
          <target state="translated">该模块提供了在解码Pod E &amp;lt;...&amp;gt;序列时有用的功能。据推测，它只能由Pod解析器和/或格式化程序使用。</target>
        </trans-unit>
        <trans-unit id="0b9bdfe8079862de56a9be28719c20253e80c566" translate="yes" xml:space="preserve">
          <source>This module provides thread-safe FIFO queues that can be accessed safely by any number of threads.</source>
          <target state="translated">该模块提供了线程安全的FIFO队列,可以被任何数量的线程安全访问。</target>
        </trans-unit>
        <trans-unit id="c893e4865fad5c4ebef15f59be14ed58305bf748" translate="yes" xml:space="preserve">
          <source>This module provides you with objects that will collate according to your national character set, provided that the POSIX setlocale() function is supported on your system.</source>
          <target state="translated">这个模块为你提供了根据你的国家字符集整理的对象,只要你的系统支持POSIX setlocale()函数。</target>
        </trans-unit>
        <trans-unit id="3c80ba9c5ba8104333b035c434045b2d217f883f" translate="yes" xml:space="preserve">
          <source>This module provides you with the framework to write</source>
          <target state="translated">本模块为您提供了一个框架来编写</target>
        </trans-unit>
        <trans-unit id="a42cca3ae2e3ec2aed33868679dacb4f08255f28" translate="yes" xml:space="preserve">
          <source>This module replaces the standard &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; functions with implementations that return objects. It does so in a backwards compatible manner, so that using localtime/gmtime in the way documented in perlfunc will still return what you expect.</source>
          <target state="translated">该模块用返回对象的实现替换了标准的 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 函数。它以向后兼容的方式进行操作，因此以perlfunc中记录的方式使用localtime / gmtime仍会返回您期望的结果。</target>
        </trans-unit>
        <trans-unit id="ebad2bd284dfda2fca32fe79ad6c3153c79782e2" translate="yes" xml:space="preserve">
          <source>This module replaces the standard &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; functions with implementations that return objects. It does so in a backwards compatible manner, so that using localtime/gmtime in the way documented in perlfunc will still return what you expect.</source>
          <target state="translated">该模块用返回对象的实现替换了标准的 &lt;code&gt;localtime&lt;/code&gt; 和 &lt;code&gt;gmtime&lt;/code&gt; 函数。它以向后兼容的方式进行操作，因此以perlfunc中记录的方式使用localtime / gmtime仍会返回您期望的结果。</target>
        </trans-unit>
        <trans-unit id="a5bdc953dcd00c8d1fe5956d84a4a3e6df9745fe" translate="yes" xml:space="preserve">
          <source>This module should implement a method named &lt;code&gt;new&lt;/code&gt; that returns an object with two methods: &lt;code&gt;IN&lt;/code&gt; and &lt;code&gt;OUT&lt;/code&gt; . These should return filehandles to use for debugging input and output correspondingly. The &lt;code&gt;new&lt;/code&gt; method should inspect an argument containing the value of &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; at startup, or &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; otherwise. This file is not inspected for proper ownership, so security hazards are theoretically possible.</source>
          <target state="translated">该模块应实现一个名为 &lt;code&gt;new&lt;/code&gt; 的方法，该方法使用两种方法返回对象： &lt;code&gt;IN&lt;/code&gt; 和 &lt;code&gt;OUT&lt;/code&gt; 。这些应返回文件句柄以用于相应地调试输入和输出。该 &lt;code&gt;new&lt;/code&gt; 方法应该检查包含的值的参数 &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; 在启动时，或 &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; 否则。不会检查此文件的所有权，因此从理论上讲可能存在安全隐患。</target>
        </trans-unit>
        <trans-unit id="6ae943e96b2618df870eb0a33680626556843298" translate="yes" xml:space="preserve">
          <source>This module should implement a method named &lt;code&gt;new&lt;/code&gt; that returns an object with two methods: &lt;code&gt;IN&lt;/code&gt; and &lt;code&gt;OUT&lt;/code&gt;. These should return filehandles to use for debugging input and output correspondingly. The &lt;code&gt;new&lt;/code&gt; method should inspect an argument containing the value of &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; at startup, or &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; otherwise. This file is not inspected for proper ownership, so security hazards are theoretically possible.</source>
          <target state="translated">该模块应实现一个名为 &lt;code&gt;new&lt;/code&gt; 的方法，该方法使用两种方法返回对象： &lt;code&gt;IN&lt;/code&gt; 和 &lt;code&gt;OUT&lt;/code&gt; 。这些应返回文件句柄以用于相应地调试输入和输出。该 &lt;code&gt;new&lt;/code&gt; 方法应该检查包含的值的参数 &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; 在启动时，或 &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; 否则。不会检查此文件的所有权，因此从理论上讲可能存在安全隐患。</target>
        </trans-unit>
        <trans-unit id="bad58f419e7f4aec9440c0245d2f7f3c13689acc" translate="yes" xml:space="preserve">
          <source>This module simplifies the process of diagnosing such problems. Just put this line on top of your main program:</source>
          <target state="translated">这个模块简化了诊断此类问题的过程。只要把这一行放在你的主程序上面就可以了。</target>
        </trans-unit>
        <trans-unit id="2af86b3d96524d0d85ce2a4bfec17fb68c6415ad" translate="yes" xml:space="preserve">
          <source>This module simplifies the task of writing test files for Perl modules, such that their output is in the format that &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; expects to see.</source>
          <target state="translated">该模块简化了为Perl模块编写测试文件的任务，从而使它们的输出采用&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;期望的格式。</target>
        </trans-unit>
        <trans-unit id="6a41ba09a40a54e49a9ee3baae88659ee7ff44a3" translate="yes" xml:space="preserve">
          <source>This module simplifies the task of writing test files for Perl modules, such that their output is in the format that &lt;a href=&quot;test/harness&quot;&gt;Test::Harness&lt;/a&gt; expects to see.</source>
          <target state="translated">该模块简化了为Perl模块编写测试文件的任务，从而使它们的输出采用&lt;a href=&quot;test/harness&quot;&gt;Test :: Harness&lt;/a&gt;期望的格式。</target>
        </trans-unit>
        <trans-unit id="11c0f42159d2cd738d87f4668e591361666ef5d1" translate="yes" xml:space="preserve">
          <source>This module supplies line breaking conformant with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX#14 Unicode Line Breaking Algorithm&lt;/a&gt;.</source>
          <target state="translated">该模块提供符合&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX＃14 Unicode&lt;/a&gt;换行算法的换行。</target>
        </trans-unit>
        <trans-unit id="7362dd1991fb64d8e60d1766b453419474c1d7a8" translate="yes" xml:space="preserve">
          <source>This module supports dual-valued variables created using &lt;code&gt;dualvar()&lt;/code&gt; from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;. However, while &lt;code&gt;$!&lt;/code&gt; acts like a dualvar, it is implemented as a tied SV. To propagate its value, use the follow construct, if needed:</source>
          <target state="translated">该模块支持使用创建的双值变量 &lt;code&gt;dualvar()&lt;/code&gt; 从&lt;a href=&quot;../scalar/util&quot;&gt;标量::的Util&lt;/a&gt;。但是，虽然 &lt;code&gt;$!&lt;/code&gt; 就像doublevar一样，它实现为绑定的SV。要传播其值，请根据需要使用以下构造：</target>
        </trans-unit>
        <trans-unit id="fd505ee058fc17bfb1d30b711a408033af247e5c" translate="yes" xml:space="preserve">
          <source>This module supports dual-valued variables created using &lt;code&gt;dualvar()&lt;/code&gt; from &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;. However, while &lt;code&gt;$!&lt;/code&gt; acts like a dualvar, it is implemented as a tied SV. To propagate its value, use the follow construct, if needed:</source>
          <target state="translated">该模块支持使用创建的双值变量 &lt;code&gt;dualvar()&lt;/code&gt; 从&lt;a href=&quot;Scalar::Util&quot;&gt;标量::的Util&lt;/a&gt;。但是，虽然 &lt;code&gt;$!&lt;/code&gt; 就像doublevar一样，它实现为绑定的SV。要传播其价值，请根据需要使用以下构造：</target>
        </trans-unit>
        <trans-unit id="4a9a2cc7b64dab0e46b52256bb4b3682e797fe2a" translate="yes" xml:space="preserve">
          <source>This module supports the sharing of the following data types only: scalars and scalar refs, arrays and array refs, and hashes and hash refs.</source>
          <target state="translated">该模块仅支持以下数据类型的共享:标量和标量参考,数组和数组参考,以及哈希和哈希参考。</target>
        </trans-unit>
        <trans-unit id="a0c98feb7e76c5e1cd4d46ac2f59afc0263d11ba" translate="yes" xml:space="preserve">
          <source>This module takes the existing &lt;code&gt;File::Glob&lt;/code&gt; module as a starting point and extends it to allow new filenames to be derived from the files matched by &lt;code&gt;File::Glob&lt;/code&gt; .</source>
          <target state="translated">该模块以现有的 &lt;code&gt;File::Glob&lt;/code&gt; 模块为起点，并将其扩展为允许从 &lt;code&gt;File::Glob&lt;/code&gt; 匹配的文件中派生新的文件名。</target>
        </trans-unit>
        <trans-unit id="0cfd10e3f1ec19589cfc4011f0c16d6ed897f4ea" translate="yes" xml:space="preserve">
          <source>This module takes the existing &lt;code&gt;File::Glob&lt;/code&gt; module as a starting point and extends it to allow new filenames to be derived from the files matched by &lt;code&gt;File::Glob&lt;/code&gt;.</source>
          <target state="translated">该模块以现有 &lt;code&gt;File::Glob&lt;/code&gt; 模块为起点，并将其扩展为允许从 &lt;code&gt;File::Glob&lt;/code&gt; 匹配的文件中派生新的文件名。</target>
        </trans-unit>
        <trans-unit id="052bc1b3338f70ab6cb4be4a053d4fd7e5528e2e" translate="yes" xml:space="preserve">
          <source>This module tells its users that functions in the FOOBAR package are to be autoloaded from after the &lt;code&gt;__DATA__&lt;/code&gt; token. See also &lt;a href=&quot;perlsub#Autoloading&quot;&gt;&quot;Autoloading&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">该模块告诉其用户FOOBAR软件包中的功能将从 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后自动加载。另请参见&lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub中的&amp;ldquo;自动加载&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a954cd9e0b1a91ff11e964474367fdd384bdca9c" translate="yes" xml:space="preserve">
          <source>This module tells its users that functions in the FOOBAR package are to be autoloaded from after the &lt;code&gt;__DATA__&lt;/code&gt; token. See also &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">该模块告诉其用户FOOBAR软件包中的功能将从 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后自动加载。另请参见&lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub中的自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4932847f497c060c74592b6ad7e18f95a164be8" translate="yes" xml:space="preserve">
          <source>This module tests the perl C API. Also exposes various bit of the perl internals for the use of core test scripts.</source>
          <target state="translated">该模块测试perl C API。也暴露了perl内部的各种位,供核心测试脚本使用。</target>
        </trans-unit>
        <trans-unit id="0a9a81649e360d7b3e7438be28feaaf818a5ce22" translate="yes" xml:space="preserve">
          <source>This module uses &lt;a href=&quot;Term::Cap&quot;&gt;Term::Cap&lt;/a&gt; to find the correct terminal settings. See the documentation of that module for how it finds terminal database information and how to override that behavior if necessary. If unable to find control strings for bold and underscore formatting, that formatting is skipped, resulting in the same output as Pod::Text.</source>
          <target state="translated">该模块使用&lt;a href=&quot;Term::Cap&quot;&gt;Term :: Cap&lt;/a&gt;查找正确的终端设置。请参阅该模块的文档，以了解其如何查找终端数据库信息以及在必要时如何覆盖该行为。如果找不到用于粗体和下划线格式的控件字符串，则将跳过该格式，从而得到与Pod :: Text相同的输出。</target>
        </trans-unit>
        <trans-unit id="939a336b2bb3143f369fbb6ba3a4974db4ff7afa" translate="yes" xml:space="preserve">
          <source>This module uses POSIX::setlocale(). The basic collation conversion is done by strxfrm() which terminates at NUL characters being a decent C routine. collate_xfrm() handles embedded NUL characters gracefully.</source>
          <target state="translated">这个模块使用POSIX::setlocale()。collate_xfrm()优雅地处理了嵌入的NUL字符。</target>
        </trans-unit>
        <trans-unit id="3d7e780fb3434a21970906d8c1e16da4e1e4c306" translate="yes" xml:space="preserve">
          <source>This module uses Term::Cap to retrieve the formatting escape sequences for the current terminal, and falls back on the ECMA-48 (the same in this regard as ANSI X3.64 and ISO 6429, the escape codes also used by DEC VT100 terminals) if the bold, underline, and reset codes aren't set in the termcap information.</source>
          <target state="translated">该模块使用 Term::Cap 来检索当前终端的格式化转义序列,如果在 termcap 信息中没有设置粗体、下划线和复位代码,则回落到 ECMA-48(在这方面与 ANSI X3.64 和 ISO 6429 相同,DEC VT100 终端也使用这些转义代码)。</target>
        </trans-unit>
        <trans-unit id="058e434497d0f41de20212a7e71136f58de19c26" translate="yes" xml:space="preserve">
          <source>This module uses the Encode module.</source>
          <target state="translated">本模块使用Encode模块。</target>
        </trans-unit>
        <trans-unit id="ecd2d794e766a834737cd883e299b1adbe33f061" translate="yes" xml:space="preserve">
          <source>This module validates a CPAN Meta structure against the version of the the specification claimed in the &lt;code&gt;meta-spec&lt;/code&gt; field of the structure.</source>
          <target state="translated">此模块对照结构的 &lt;code&gt;meta-spec&lt;/code&gt; 字段中要求保护的规范版本来验证CPAN Meta结构。</target>
        </trans-unit>
        <trans-unit id="f4b71953fa4633537c604ac518e043ed458e0579" translate="yes" xml:space="preserve">
          <source>This module was conceived while talking with Tony Bowden in his kitchen one night about the problems I was having writing some really complicated feature into the new Testing module. He observed that the main problem is not dealing with these edge cases but that people hate to write tests &lt;b&gt;at all&lt;/b&gt;. What was needed was a dead simple module that took all the hard work out of testing and was really, really easy to learn. Paul Johnson simultaneously had this idea (unfortunately, he wasn't in Tony's kitchen). This is it.</source>
          <target state="translated">这个模块是在晚上与Tony Bowden在他的厨房里谈论有关我正在向新的Testing模块中编写一些非常复杂的功能的问题时构思的。他观察到，主要问题不是处理这些极端情况，而是人们&lt;b&gt;根本&lt;/b&gt;不愿意编写测试。所需要的是一个简单而又简单的模块，它消除了测试中的所有辛苦工作，并且非常容易上手。保罗&amp;middot;约翰逊与此同时想到了这个（不幸的是，他不在托尼的厨房里）。就是这个。</target>
        </trans-unit>
        <trans-unit id="44e053a287d50cc7ccc07846fa0cd204c00c77bf" translate="yes" xml:space="preserve">
          <source>This module was forked from &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; to remove the cruft that had accumulated in it.</source>
          <target state="translated">该模块是从&lt;a href=&quot;base&quot;&gt;基座&lt;/a&gt;上分叉的，以除去积累在其中的碎屑。</target>
        </trans-unit>
        <trans-unit id="415f859ceb0027d691de683de60a6caa41bf897e" translate="yes" xml:space="preserve">
          <source>This module was introduced with Perl 5.004_04.</source>
          <target state="translated">这个模块是在Perl 5.004_04中引入的。</target>
        </trans-unit>
        <trans-unit id="d78d05cb96bc7dd60c1272000024e5786c3b344f" translate="yes" xml:space="preserve">
          <source>This module was originally maintained in Perl core by the Perl 5 Porters.</source>
          <target state="translated">这个模块最初是由Perl 5 Porters在Perl核心中维护的。</target>
        </trans-unit>
        <trans-unit id="d496390246382aaea7191d7bd504a81ceae75b9b" translate="yes" xml:space="preserve">
          <source>This module was written by Paul Marquess,</source>
          <target state="translated">本模块由Paul Marquess编写。</target>
        </trans-unit>
        <trans-unit id="bc6d88c0756ae538fe8de07d7958dc0a1b51e622" translate="yes" xml:space="preserve">
          <source>This module was written by Paul Marquess, &lt;code&gt;pmqs@cpan.org&lt;/code&gt;.</source>
          <target state="translated">这个模块是由Paul Marquess编写的， &lt;code&gt;pmqs@cpan.org&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="447cd8889bedc96882c7e73b779d78b4d5490566" translate="yes" xml:space="preserve">
          <source>This module was written to be able to return the configuration for the currently used perl as deeply as needed for the CPANTESTERS framework. Up until now they used the output of myconfig as a single text blob, and so it was missing the vital binary characteristics of the running perl and the optional applied patches.</source>
          <target state="translated">这个模块是为了能够根据CPANTESTERS框架的需要,深度返回当前使用的perl的配置而写的。到目前为止,他们将myconfig的输出作为一个单一的文本blob,因此它缺少了运行中的perl的重要二进制特性和可选的应用补丁。</target>
        </trans-unit>
        <trans-unit id="db6bc597ca48fae1b90746fab4916cd0188777f9" translate="yes" xml:space="preserve">
          <source>This module will arrange for the following methods to be available via the object returned from the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">该模块将安排以下方法，这些方法可以通过 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用返回的对象使用。</target>
        </trans-unit>
        <trans-unit id="0daa24844007b58d785b5b27ec35609e2bc267e2" translate="yes" xml:space="preserve">
          <source>This module will arrange for the following methods to be available via the object returned from the &lt;code&gt;tie&lt;/code&gt; call.</source>
          <target state="translated">该模块将安排通过 &lt;code&gt;tie&lt;/code&gt; 调用返回的对象提供以下方法。</target>
        </trans-unit>
        <trans-unit id="2764651445501a5ce090459b163069724d513467" translate="yes" xml:space="preserve">
          <source>This module will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">该模块将确保所有写入DBM的数据都以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d4e571c7af10e51826ae47ab8231a6af4b7edd1a" translate="yes" xml:space="preserve">
          <source>This module will have no effect unless Term::ANSIColor is installed.</source>
          <target state="translated">除非安装了Term::ANSIColor,否则该模块不会有任何效果。</target>
        </trans-unit>
        <trans-unit id="753074c360c010972baa819f6207bebbcf1369a9" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getgrent(), getgrgid(), and getgrnam() functions, replacing them with versions that return &quot;User::grent&quot; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的getgrent()、getgrgid()和getgrnam()函数,用返回 &quot;User::grent &quot;对象的版本代替。这个对象有一些方法,从C的passwd结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="bc002eb3536b764cc0a1a4a051dbfbb6d0617a7a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getgrent(), getgruid(), and getgrnam() functions, replacing them with versions that return &quot;User::grent&quot; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的getgrent()、getgruid()和getgrnam()函数,用返回 &quot;User::grent &quot;对象的版本代替。这个对象有一些方法,从C的passwd结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1581c51cdf9361d52e5059029b51bf081eb34a2a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gethostbyname() and gethostbyaddr() functions, replacing them with versions that return &quot;Net::hostent&quot; objects. This object has methods that return the similarly named structure field name from the C's hostent structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的gethostbyname()和gethostbyaddr()函数,用返回 &quot;Net::hostent &quot;对象的版本代替。这个对象的方法是从C的hostent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1cf48308305a0353920dde6f36f9628e64db01d0" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getnetbyname() and getnetbyaddr() functions, replacing them with versions that return &quot;Net::netent&quot; objects. This object has methods that return the similarly named structure field name from the C's netent structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的getnetbyname()和getnetbyaddr()函数,用返回 &quot;Net::netent &quot;对象的版本代替。这个对象的方法可以从C的netent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="63eeed3630a3c131f9be311caba9fa2bc27d9b47" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getprotoent(), getprotobyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::protoent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's protoent structure from</source>
          <target state="translated">这个模块的默认输出覆盖了核心的getprotoent()、getprotobyname()和getnetbyport()函数,用返回 &quot;Net::protoent &quot;对象的版本来代替它们。它们取默认的第二个参数为 &quot;tcp&quot;。这个对象的方法,从C的protoent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="4107e545f5b1cf8c8a8164c3254d8e830266adf1" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getpwent(), getpwuid(), and getpwnam() functions, replacing them with versions that return &lt;code&gt;User::pwent&lt;/code&gt; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">该模块的默认导出覆盖了核心getpwent（），getpwuid（）和getpwnam（）函数，并用返回 &lt;code&gt;User::pwent&lt;/code&gt; 对象的版本替换了它们。该对象具有从C的passwd结构返回类似名称的结构字段名称的方法，</target>
        </trans-unit>
        <trans-unit id="10fb02d2375c44b6670d64106c1e02dfe50c1c6b" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getservent(), getservbyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::servent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's servent structure from</source>
          <target state="translated">这个模块的默认输出覆盖了核心的getervent()、getervbyname()和getnetbyport()函数,用返回 &quot;Net::servent &quot;对象的版本来代替它们。它们取默认的第二个参数为 &quot;tcp&quot;。这个对象的方法从C的servent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="7599d7934dafe0542e5b1a0c799f665df33f32e3" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gmtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的gmtime()函数,用一个返回 &quot;Time::tm &quot;对象的版本代替。这个对象有一些方法,可以从C的tm结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1c7368710f29f58e692e516e823ad1d056f89a07" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core localtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的localtime()函数,用一个返回 &quot;Time::tm &quot;对象的版本代替。这个对象有一些方法可以返回C的tm结构中的类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="d73f3c14e45154d8cf626f7be1ef9892237475eb" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core stat() and lstat() functions, replacing them with versions that return &quot;File::stat&quot; objects. This object has methods that return the similarly named structure field name from the stat(2) function; namely, dev, ino, mode, nlink, uid, gid, rdev, size, atime, mtime, ctime, blksize, and blocks.</source>
          <target state="translated">这个模块的默认导出覆盖了核心的 stat()和 lstat()函数,用返回 &quot;File::stat &quot;对象的版本代替。这个对象有从 stat(2)函数中返回类似名称的结构字段名的方法;即dev、ino、mode、nlink、uid、gid、rdev、size、atime、mtime、ctime、blksize和block。</target>
        </trans-unit>
        <trans-unit id="cd05da270956b31cc43582962e51390407dca252" translate="yes" xml:space="preserve">
          <source>This module, when inherited by a package, allows that package's class to define attribute handler subroutines for specific attributes. Variables and subroutines subsequently defined in that package, or in packages derived from that package may be given attributes with the same names as the attribute handler subroutines, which will then be called in one of the compilation phases (i.e. in a &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; block). (&lt;code&gt;UNITCHECK&lt;/code&gt; blocks don't correspond to a global compilation phase, so they can't be specified here.)</source>
          <target state="translated">该模块在被包继承时，允许该包的类为特定属性定义属性处理程序子例程。随后在该程序包中或从该程序包派生的程序包中定义的变量和子例程可以被赋予与属性处理程序子例程相同名称的属性，然后将在编译阶段之一（即，在 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 中)进行调用。，或 &lt;code&gt;END&lt;/code&gt; 块）。 （ &lt;code&gt;UNITCHECK&lt;/code&gt; 块不对应于全局编译阶段，因此无法在此处指定。）</target>
        </trans-unit>
        <trans-unit id="99dcf55d867c5d7dcda0db6120bea9765e3ea428" translate="yes" xml:space="preserve">
          <source>This module, when inherited by a package, allows that package's class to define attribute handler subroutines for specific attributes. Variables and subroutines subsequently defined in that package, or in packages derived from that package may be given attributes with the same names as the attribute handler subroutines, which will then be called in one of the compilation phases (i.e. in a &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; block). (&lt;code&gt;UNITCHECK&lt;/code&gt; blocks don't correspond to a global compilation phase, so they can't be specified here.)</source>
          <target state="translated">该模块在被包继承时，允许该包的类为特定属性定义属性处理程序子例程。随后可以在该包中或从该包派生的包中定义的变量和子例程被赋予与属性处理程序子例程相同名称的属性，然后将在编译阶段之一（即，在 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 中)调用该子例程，或 &lt;code&gt;END&lt;/code&gt; 块）。 （ &lt;code&gt;UNITCHECK&lt;/code&gt; 块不对应于全局编译阶段，因此无法在此处指定。）</target>
        </trans-unit>
        <trans-unit id="d4b82d477760eacd25bf3c70a5e788527be511b5" translate="yes" xml:space="preserve">
          <source>This modules handles the BOM as follows.</source>
          <target state="translated">该模块处理BOM的方法如下。</target>
        </trans-unit>
        <trans-unit id="f10c5ffd35143aacf9d4aee6ffb8d09db8a38f8d" translate="yes" xml:space="preserve">
          <source>This name actually evaluates to a sequence of two Katakana characters, not just a single one, and it is illegal to try to take the complement of a sequence. (Mathematically it would mean any sequence of characters from 0 to infinity in length that weren't these two in a row, and that is likely not of any real use.)</source>
          <target state="translated">这个名字实际上是对两个片假名字符序列的评估,而不仅仅是一个,而且试图取序列的补码是非法的。(从数学上讲,它的意思是指从0到无限长的任何字符序列,而不是这两个连续的字符,这很可能没有任何实际用途。)</target>
        </trans-unit>
        <trans-unit id="3973d4b3df1b4f6e4e1a4578c3854df16aa9cfcc" translate="yes" xml:space="preserve">
          <source>This name should be as descriptive, accurate, and complete as possible. Avoid any risk of ambiguity. Always try to use two or more whole words. Generally the name should reflect what is special about what the module does rather than how it does it. Please use nested module names to group informally or categorize a module. There should be a very good reason for a module not to have a nested name. Module names should begin with a capital letter.</source>
          <target state="translated">这个名称应尽可能地描述性、准确性和完整性。避免任何含糊不清的风险。尽量使用两个或两个以上的整数词。一般来说,名称应该反映出该模块的特殊之处,而不是它是如何做的。请使用嵌套的模块名称来对模块进行非正式的分组或分类。一个模块不使用嵌套的名称应该有一个很好的理由。模块名称应该以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="179dbc2dff329a2eb588f358318a7847c0e2dc93" translate="yes" xml:space="preserve">
          <source>This namespace is for bundles of tools and plugins. Loading one of these may load multiple tools and plugins. Modules in this namespace should not implement tools directly. In general modules in this namespace should load tools and plugins, then re-export things into the consumers namespace.</source>
          <target state="translated">这个命名空间是用于工具和插件的捆绑。加载其中的一个工具可能会加载多个工具和插件。这个命名空间中的模块不应该直接实现工具。一般来说,在这个命名空间中的模块应该加载工具和插件,然后将东西重新导出到消费者命名空间。</target>
        </trans-unit>
        <trans-unit id="25625211c4cda5e1d4faa1db8d7e10f093eef9f2" translate="yes" xml:space="preserve">
          <source>This namespace is for general utilities used by testing tools. Please be considerate when adding new modules to this namespace.</source>
          <target state="translated">这个命名空间是测试工具使用的一般实用程序。在向这个命名空间添加新的模块时,请慎重考虑。</target>
        </trans-unit>
        <trans-unit id="90daa65eb98c6c93bba627fab2d39064d5b2e4dd" translate="yes" xml:space="preserve">
          <source>This namespace is for modules that cause a test to be skipped when conditions do not allow it to run. Examples would be modules that skip the test on older perls, or when non-essential modules have not been installed.</source>
          <target state="translated">这个命名空间是为那些在条件不允许时跳过测试的模块准备的。例如,在旧的perls上跳过测试的模块,或者当非必要的模块没有被安装时。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
