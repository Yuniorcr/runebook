<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">这些扩展的稳定性差异很大。有些已经成为核心语言的一部分多年。其他的则是实验性的,可能会在没有警告的情况下改变或被完全移除。请查看个别功能的文档以确认其当前状态。</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">可通过 &lt;code&gt;ST(n)&lt;/code&gt; 宏访问堆栈参数，该宏返回第 &lt;code&gt;n&lt;/code&gt; 个堆栈参数。参数0是Perl子例程调用中传递的第一个参数。这些参数是 &lt;code&gt;SV*&lt;/code&gt; ，可以在使用 &lt;code&gt;SV*&lt;/code&gt; 任何地方使用。</target>
        </trans-unit>
        <trans-unit id="607b1af778b28e37b1d81fc8b926b116b2fd196e" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt;'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt;, and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">不能改变当前已存在线程的堆栈大小,因此,以下导致上述错误。</target>
        </trans-unit>
        <trans-unit id="852fc28bbec79ad0af0406e767c0c9a99d1cbd8b" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;IO::Select&quot;&gt;&lt;code&gt;IO::Select&lt;/code&gt;&lt;/a&gt; module provides a user-friendlier interface to &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38654d44cc2a58273ab5b5792f4d5c5499881e36" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">标准的 &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; 模块，以及 &lt;code&gt;bignum&lt;/code&gt; ， &lt;code&gt;bigint&lt;/code&gt; 和 &lt;code&gt;bigrat&lt;/code&gt; 编译指示，提供了变量精度算术和重载运算符，尽管它们目前非常慢。以一些空间和相当大的速度为代价，它们避免了与有限精度表示相关联的正常陷阱。</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">标准的 &lt;code&gt;IO::Select&lt;/code&gt; 模块提供了一个用户友好的界面来 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ，主要是因为它为您完成了所有的位掩码工作。</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">标准的 &lt;code&gt;IO::Select&lt;/code&gt; 模块提供了一个用户友好的界面来 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; ，主要是因为它为您完成了所有的位掩码工作。</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">标准的Perl 5 MRO为（D，B，A，C）。结果使得&lt;b&gt;一个&lt;/b&gt;之前出现&lt;b&gt;&amp;Ccedil;&lt;/b&gt;，即使&lt;b&gt;&amp;Ccedil;&lt;/b&gt;是子类&lt;b&gt;甲&lt;/b&gt;。但是，C3 MRO算法产生以下顺序：（D，B，C，A），没有此问题。</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">标准Pod :: Parser方法parse_from_filehandle（）最多使用两个参数，第一个是从中读取POD的文件句柄，第二个是向其写入格式化输出的文件句柄。如果未指定，则第一个默认为STDIN，第二个默认为STDOUT。方法parse_from_file（）几乎相同，只是方法的两个参数分别是输入和输出磁盘文件。有关详细信息，请参见&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">标准Pod :: Simple方法parse_file（）使用一个参数命名要读取的POD文件。默认情况下，输出发送到 &lt;code&gt;STDOUT&lt;/code&gt; ，但是可以使用output_fh（）方法更改它。</target>
        </trans-unit>
        <trans-unit id="3e6fd6624c64417efc3c147b58226ae1b1c796d2" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt;, but this can be changed with the output_fh() method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">标准的Pod::Simple方法parse_from_file()需要两个参数,第一个是要读取POD的输入文件,第二个是要写入格式化输出的文件。</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">标准的Tie::RefHash模块为此提供了一个方便的变通方法。</target>
        </trans-unit>
        <trans-unit id="baf8b1f6a3bcf32c285c5388e646857a3e93b793" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot; in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">下面列出的标准Unicode属性记录在&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/中&lt;/a&gt;；Perl_Decimal_Digit &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;以Unicode :: UCD&lt;/a&gt;记录在prop_invmap（）中。其他Perl扩展&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;位于perlunicode&lt;/a&gt;中的Other Properties中；</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perl的标准版本（由Perl开发团队维护的版本）仅以源代码形式分发。您可以在&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/上&lt;/a&gt;找到最新版本。</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">手册页的标准部分是:</target>
        </trans-unit>
        <trans-unit id="da6ced5233b9d24371e1284e5b4cf92ab897f075" translate="yes" xml:space="preserve">
          <source>The standard tools that deal with module distribution (PAUSE, CPAN, etc.) form an identifier for each distribution by joining the 'name' and 'version' attributes with a dash (&lt;code&gt;-&lt;/code&gt;) character. Tools who are prepared to deal with distributions that have no version numbers generally omit the dash as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">perl 5.7之前的标准tyemap不包含PerlIO *,但它有三个流变体。直接使用PerlIO *是不向后兼容的,除非你提供自己的typemap。</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">标准的类型映射提供PerlIO *的三种变体： &lt;code&gt;InputStream&lt;/code&gt; （T_IN）， &lt;code&gt;InOutStream&lt;/code&gt; （T_INOUT）和 &lt;code&gt;OutputStream&lt;/code&gt; （T_OUT）。裸露的 &lt;code&gt;PerlIO *&lt;/code&gt; 被视为T_INOUT。如果它在您的代码中很重要（请参阅下文，了解原因）#define或typedef具体名称之一，并将其​​用作XS文件中的参数或结果类型。</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">标准/默认的目录列表,dl_findfile()将在其中搜索库等。按顺序搜索。$dl_library_path[0],[1],...等。</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">与键入的词法关联的隐藏。这将为 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; 返回％Foo ::哈希。</target>
        </trans-unit>
        <trans-unit id="b3fb6f3b4dcfdcba93815cd0cdb0c770846f5f5f" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the &lt;code&gt;%Foo::&lt;/code&gt; hash for &lt;code&gt;my Foo $bar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1de13e351b83e422c637b81ca7943274ca516a1" translate="yes" xml:space="preserve">
          <source>The stash for the package code will be compiled into.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">声明这个 &quot;我们的 &quot;变量的储藏室。</target>
        </trans-unit>
        <trans-unit id="869b087a95d93860c966339061a3c7eb5e7a6410" translate="yes" xml:space="preserve">
          <source>The stat preceding %s wasn't an lstat</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat()模式位可能对你系统中的大多数文件和目录都是正确的,因为很少有人想使用access()提供的附加功能。但是如果你的程序运行在一个使用ACLs的系统上,你可能会遇到一些意外,因为 stat()的信息不会反映实际的权限。</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">语句 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; 不会更改当前位置，但是它确实清除了句柄上的文件结束条件，因此下一个 &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; 使Perl再次尝试读取某些内容。</target>
        </trans-unit>
        <trans-unit id="29c5f769bcdc76ec76db73fb881f9e3de17be2e0" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">状态2表示指定的文件中至少有一个不含</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">从返回的状态代码 &lt;code&gt;inflate&lt;/code&gt; 只会触发主处理循环的终止，如果它不是 &lt;code&gt;Z_OK&lt;/code&gt; 。当 &lt;code&gt;LimitOutput&lt;/code&gt; 尚未使用的 &lt;code&gt;Z_OK&lt;/code&gt; 状态表示所述压缩数据流的结尾已经到达或有在解压缩了一个错误。</target>
        </trans-unit>
        <trans-unit id="779e93e5e5c79de152e0d904d8c2cb9d0f5d9a7f" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt;. When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed标志的状态也会影响编译错误时VMS错误信息的输出。同样,你仍然会得到Perl错误信息(以及$STATUS中的代码)。</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">通过最后的管道关闭返回的状态，反引号（ &lt;code&gt;``&lt;/code&gt; ）命令，成功调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 的或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 操作。这仅仅是传统的Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 系统调用返回的16位状态字（或者看起来像这样）。因此，子流程的退出值实际上是（ &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ），而 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; 给出该进程终止于哪个信号（如果有），以及 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; 报告是否存在核心转储。</target>
        </trans-unit>
        <trans-unit id="9f58cb3cab9b9d58145034f89f71fdaeeb21297a" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;wait()&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt;), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">用户的 &lt;code&gt;filter&lt;/code&gt; 方法或匿名子返回的状态值以及 &lt;code&gt;filter_read&lt;/code&gt; 和 &lt;code&gt;read_exact&lt;/code&gt; 函数采用相同的一组值，即：</target>
        </trans-unit>
        <trans-unit id="2660ee0526b1b40a8d851a0826ec3b948b6dbdee" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;&quot;Building an LP64 perl&quot;&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio（3C）联机帮助页指出，对于LP32应用程序，使用fopen（）只能打开255个文件，并且流中只能使用文件描述符0到255。由于perl调用open（）然后使用结果文件描述符调用fdopen（3C），因此即使使用sysopen（），perl也被限制为255个同时打开的文件。如果证明这是一个无法解决的问题，则可以将perl编译为LP64应用程序，有关详细信息，请参阅&lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;构建LP64 perl&lt;/a&gt;。另请注意，在Solaris上，打开文件描述符的默认资源限制为255，因此您将必须适当地修改ulimit或rctl（从Solaris 9开始）。</target>
        </trans-unit>
        <trans-unit id="5a65b444e930fbaa9c0e870b3e72484e3ba2cfa8" translate="yes" xml:space="preserve">
          <source>The steps above are in a very specific order, designed to be the reverse order of when the context was pushed. The first thing to do is to copy and/or protect any return arguments and free any temps in the current scope. Scope exits like an rvalue sub normally return a mortal copy of their return args (as opposed to lvalue subs). It is important to make this copy before the save stack is popped or variables are restored, or bad things like the following can happen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">这家商店的功能会 &lt;code&gt;croak&lt;/code&gt; ，如果他们碰上这样的引用，除非你设置 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 一些 &lt;code&gt;TRUE&lt;/code&gt; 值。在这种情况下，致命消息将转换为警告，并存储一些无意义的字符串。</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend和patend指针应该指向每个字符串最后一个字符后的字节。</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">字符串 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 。（这告诉Perl使用 &lt;code&gt;NDBM_File&lt;/code&gt; 包执行哈希函数。）</target>
        </trans-unit>
        <trans-unit id="0acc3252158ec09fb79d744584bd9ec310ab3fc7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bebcac85b77891a0ebb57e146c479aea7f7cca3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;ODBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">字符串 &lt;code&gt;$vec&lt;/code&gt; 仅占用所需的位数。例如，如果 &lt;code&gt;@ints&lt;/code&gt; 中有16个条目，则 &lt;code&gt;$vec&lt;/code&gt; 仅需要两个字节来存储它们（不计算标量变量的开销）。</target>
        </trans-unit>
        <trans-unit id="dc49e0b476d0350280c159b76d14abbf494b1cf7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt;, &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">字符串 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; 具有六个音素，但最多八个编码点。这是通过字素而不是代码点计算的：</target>
        </trans-unit>
        <trans-unit id="c8568d09543e0ac94aa7c4682834b259e167d475" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Some instances of these have been deprecated since Perl 5.24, and were made fatal in 5.28, but it turns out that in cases where the wide characters did not affect the end result, no deprecation notice was raised, and so remain legal. Now, all occurrences either are fatal or raise a deprecation warning, so that the remaining legal occurrences became fatal in 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5487cb3c1b5dd51f93004e758fb4f77bc307a840" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Using such code points with these operators was deprecated in Perl 5.24, and is fatal as of Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">上一次成功的模式匹配所匹配的字符串（不包括隐藏在当前BLOCK所包围的BLOCK或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中的任何匹配项）。例：</target>
        </trans-unit>
        <trans-unit id="3ba0048f660cfcd3f32cbfe2f76535c5c8d897d2" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995年12月12日星期二的字符串。</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">&lt;b&gt;哈希&lt;/b&gt;的字符串索引，用于查找与该键关联的&lt;b&gt;值&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b6885316bc4f379b0a1d01488371bab62a2d9d85" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">该字符串被分成由TEMPLATE描述的块。每个块分别转换为一个值。通常，字符串是 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 的结果，或者字符串的字符表示某种C结构。</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">该字符串被分成由TEMPLATE描述的块。每个块分别转换为一个值。通常，字符串是 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 的结果，或者字符串的字符表示某种C结构。</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">上一次成功的模式匹配所匹配的字符串（不计算隐藏在当前BLOCK所包围的BLOCK或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中的任何匹配项）。</target>
        </trans-unit>
        <trans-unit id="e9cf9b6b7809255e19e6a3b715176fe34d8d904e" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c0c038ca187cf5160e57a2c61c41440d3e8e16" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) is padded with zeros:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">字符串输出(浮点数的)将用0填充。</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">字符串输出将始终去除开头和结尾的零，并删除加号。 &lt;code&gt;bstr()&lt;/code&gt; 会始终为您提供带小数点的形式，而 &lt;code&gt;bsstr()&lt;/code&gt; （s表示科学）会为您提供科学计数法。</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">上一次成功的模式匹配所匹配的内容之前的字符串，不计算隐藏在当前块所包围的块或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 任何匹配。</target>
        </trans-unit>
        <trans-unit id="7f5e6eea58cb9fa29a6890f23f4c2850f3c5d5cc" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;eval&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="339432ba64926aa8fa758ffc110e1d9819cad770" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">使用语言环境信息的任何操作的字符串结果都会受到污染，因为语言环境可能是不可信任的。请参阅&amp;ldquo; &lt;a href=&quot;#SECURITY&quot;&gt;安全性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">返回的字符串并不总是NFD/NFKD。可能需要重新排序。</target>
        </trans-unit>
        <trans-unit id="2d311addc77468e8c33d61dc204474a00d32a5a2" translate="yes" xml:space="preserve">
          <source>The string that represents the C type that was not found in the typemap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">开始选项的字符串。如果常量字符串不足，请参见 &lt;code&gt;prefix_pattern&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efa5933751bfaa2a6c4eeedd57fd05169704edd2" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">要插入的字符串用</target>
        </trans-unit>
        <trans-unit id="00f6f2add8143f7b5f6195521c58d01172830e33" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by &lt;code&gt;len&lt;/code&gt; octets starting at &lt;code&gt;pv&lt;/code&gt;. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;&quot;lex_stuff_sv&quot;&lt;/a&gt; function is more convenient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">要插入的字符串用八位数来表示,开始于</target>
        </trans-unit>
        <trans-unit id="c0c0bf345ccfdae0fb09cf9ab2d8e8d8ae4c0512" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at &lt;code&gt;pv&lt;/code&gt; and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function is more appropriate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">要插入的字符串是字符串值为</target>
        </trans-unit>
        <trans-unit id="55208eb6676e3f7f6524a3ebd4f29e07cc0731fc" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of &lt;code&gt;sv&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">字符串值 &lt;code&gt;$!&lt;/code&gt; 是由CRTL的strerror（）函数返回的，因此它将包括针对VMS特定错误的VMS消息。 &lt;code&gt;$!&lt;/code&gt; 的数值 是 &lt;code&gt;errno&lt;/code&gt; 的值，除非errno是EVMSERR，在这种情况下 &lt;code&gt;$!&lt;/code&gt; 包含vaxc $ errno的值。设定 &lt;code&gt;$!&lt;/code&gt; 始终将errno设置为指定的值。如果此值为EVMSERR，则还将vaxc $ errno设置为4（NONAME-F-NOMSG），因此字符串值 &lt;code&gt;$!&lt;/code&gt; 不会反映 &lt;code&gt;$!&lt;/code&gt; 之前的VMS错误消息！被设定。</target>
        </trans-unit>
        <trans-unit id="6bce1054a07cc28e1b64ace7f7b805802c74829f" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt;, except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">作为参数提供的$data的字符串值被附加到我们计算摘要的消息中。返回值是$ctx对象本身。</target>
        </trans-unit>
        <trans-unit id="7a8e800596cb341c8f599d3168bdf4ec9c0dbea7" translate="yes" xml:space="preserve">
          <source>The strings returned may not be useful for 3-argument open().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1b5858acfdd756a7774d6480e810b1c2f37266" translate="yes" xml:space="preserve">
          <source>The stroke ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightStroke()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">结构()函数</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied()数据的结构是一个数组引用,元素是</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">perl发行版中包含的stub包允许一些额外的方法。</target>
        </trans-unit>
        <trans-unit id="69dca73bafb51f0fe392c69e65938a9183f98a5b" translate="yes" xml:space="preserve">
          <source>The sub will receive exactly 1 argument, the type of thing being tagged 'context', 'hub', or 'event'. In the future additional things may be tagged, in which case new strings will be passed in. These are purely informative, you can (and usually should) ignore them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c28ea2e9a2d4863b1fc0e89e9b8c44c6fa89947" translate="yes" xml:space="preserve">
          <source>The sub you provide should always return a unique identifier. Most things will expect a proper UUID string, however nothing in Test2::API enforces this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; 选项中的提交者地址应采用RFC 2554要求的格式，采用RFC2821引用的格式，并采用xtext编码或&amp;lt;&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="4ac8a2878ef2e11af070ab32ec1a2e0bca8078f0" translate="yes" xml:space="preserve">
          <source>The subroutine (including package) that threw the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99602f0147c6aaadcc127e8f752211c7da8fb282" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;&quot;Assignments&quot;&lt;/a&gt; above.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; 的子例程不会使Perl赋值运算符重载：它仅用于允许更改器按此处所述工作。（请参阅上面的&lt;a href=&quot;#Assignments&quot;&gt;作业&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; 子例程用于将对象插入或用作正则表达式的任何位置，包括当它出现在 &lt;code&gt;=~&lt;/code&gt; 或 &lt;code&gt;!~&lt;/code&gt; 运算符的RHS中时。</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">运算符的赋值变体的子程序只需要返回操作的结果。它允许改变其操作数的值(这是安全的,因为Perl会先调用复制构造函数),但这是可选的,因为Perl无论如何都会将返回的值分配给左手操作数。</target>
        </trans-unit>
        <trans-unit id="ae06f7431af42fbc790df16df23af545b2646544" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface, and aliases and true color attributes are supported. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">与常量接口相比,子程序接口的优势在于只有两个子程序被输出到你的命名空间,而常量接口则有38个。反过来说,常量接口的优势在于它有更好的编译时错误检查功能,因为在调用color()和colored()时拼写错误的颜色或属性的名字要到运行时才会被发现,而常量拼写错误的名字会在编译时被发现。所以,是用近二十多个子程序来污染你的命名空间,而这些子程序你可能并不经常使用,还是冒着错误键入一个属性的风险去做一个愚蠢的错误。你的选择,TMTOWTDI毕竟。</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">该子程序最多接受五个可选参数。</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">子例程最多包含四个可选参数（除了要处理的字符串之外，其他设置与 &lt;code&gt;extract_tagged&lt;/code&gt; 相同）。它返回对子例程的引用，该子例程又接受一个参数（要从中提取文本）。</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">该子程序最多接受四个可选参数。</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">该子程序最多接受两个可选参数。</target>
        </trans-unit>
        <trans-unit id="e4c12336d2e867ba9a727cf78cc335118965b26b" translate="yes" xml:space="preserve">
          <source>The subroutine that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc2edb73f368d2c8247ff6673cfa64dcc7b4601" translate="yes" xml:space="preserve">
          <source>The subroutine will have &lt;code&gt;CvFILE&lt;/code&gt; set according to &lt;code&gt;PL_curcop&lt;/code&gt;. Other aspects of the subroutine will be left in their default state. The caller is free to mutate the subroutine beyond its initial state after this function has returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265ef174cfb1c0102c91c9689e3bcac20840f609" translate="yes" xml:space="preserve">
          <source>The subroutine will have an empty prototype and will ignore any arguments when called. Its constant behaviour is determined by &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;sv&lt;/code&gt; is null, the subroutine will yield an empty list. If &lt;code&gt;sv&lt;/code&gt; points to a scalar, the subroutine will always yield that scalar. If &lt;code&gt;sv&lt;/code&gt; points to an array, the subroutine will always yield a list of the elements of that array in list context, or the number of elements in the array in scalar context. This function takes ownership of one counted reference to the scalar or array, and will arrange for the object to live as long as the subroutine does. If &lt;code&gt;sv&lt;/code&gt; points to a scalar then the inlining assumes that the value of the scalar will never change, so the caller must ensure that the scalar is not subsequently written to. If &lt;code&gt;sv&lt;/code&gt; points to an array then no such assumption is made, so it is ostensibly safe to mutate the array or its elements, but whether this is really supported has not been determined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f27fb61975933bf23afb22d7dcc89dbb6c6b52" translate="yes" xml:space="preserve">
          <source>The subroutine will have the entry point &lt;code&gt;subaddr&lt;/code&gt;. It will have the prototype specified by the nul-terminated string &lt;code&gt;proto&lt;/code&gt;, or no prototype if &lt;code&gt;proto&lt;/code&gt; is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If &lt;code&gt;filename&lt;/code&gt; is non-null, it must be a nul-terminated filename, and the subroutine will have its &lt;code&gt;CvFILE&lt;/code&gt; set accordingly. By default &lt;code&gt;CvFILE&lt;/code&gt; is set to point directly to the supplied string, which must be static. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; bit set, then a copy of the string will be taken instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; ， &lt;code&gt;'0+'&lt;/code&gt; 和 &lt;code&gt;'bool'&lt;/code&gt; 的子例程可以返回任意的Perl值。如果与此值对应的操作也过载，则将使用该值再次调用该操作。</target>
        </trans-unit>
        <trans-unit id="740359d4d5595e110911a4995def79d738d321f7" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">子程序必须返回一个特殊格式的字符串,其中包含一个或多个以新行分隔的行。每一行必须是以下内容之一:</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">多维数组仿真的下标分隔符。如果您将一个哈希元素称为</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">替代运算符。请参阅&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="96c15efd757813123cfb6bdf82217c841dbb4c27" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">替代运算符。请参阅&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlop中的Regexp类引用运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">要提取的子字符串必须出现在字符串变量的当前 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置（或者，如果未定义 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置，则显示在索引零）。换句话说， &lt;code&gt;extract_...&lt;/code&gt; 子例程</target>
        </trans-unit>
        <trans-unit id="2d860483efae722d0cafa03a2a83e556d7c44ecb" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;pos&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;pos&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c80d088e6c6c206a945e539d4bfb8f011c76009" translate="yes" xml:space="preserve">
          <source>The subtest event itself, with the first 2 events nested inside it as children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">试图将您可能格式错误的程序转换为有效的&lt;b&gt;语法树&lt;/b&gt;的技巧，但有时却是残酷的。</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">这个包的subversion级别。subversion的值来自于</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">超级用户（ &lt;code&gt;UID&lt;/code&gt; == 0）。也是文件系统的顶级目录。</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">从Perl版本v5.6开始新增了对Unicode的支持，并且在版本v5.8及更高版本中更全面地实现了Unicode。参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c60ded369392eed501121f572768a1d278a7c99" translate="yes" xml:space="preserve">
          <source>The supported features, documented further below, are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">支持的平台是Linux,和OS X(一些*BSD可能至少部分工作,但它们还没有被测试)。</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">令人惊讶的部分是 &lt;code&gt;--a&lt;/code&gt; 设置了选项 &lt;code&gt;a&lt;/code&gt; （由于自动完成），而不是 &lt;code&gt;all&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75d8922e6906461ffb1cdb138b9e2b992bbd28c0" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">环境或环境。周围代码给出的上下文确定特定&lt;b&gt;表达式&lt;/b&gt;期望返回哪种数据。三个主要上下文是&lt;b&gt;列表上下文&lt;/b&gt;，&lt;b&gt;标量&lt;/b&gt;和&lt;b&gt;无效上下文&lt;/b&gt;。标量上下文有时又细分为&lt;b&gt;布尔上下文&lt;/b&gt;，&lt;b&gt;数字上下文&lt;/b&gt;，&lt;b&gt;字符串上下文&lt;/b&gt;和&lt;b&gt;void上下文&lt;/b&gt;。还有一个&amp;ldquo;无关&amp;rdquo;上下文（如果需要的话，请参见骆驼第2章&amp;ldquo;零碎&amp;rdquo;部分）。</target>
        </trans-unit>
        <trans-unit id="295e290eb0d08f2169eeef73696284f8eecaacb4" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic函数使用 &lt;code&gt;how&lt;/code&gt; 确定应该将哪些预定义的&amp;ldquo; Magic虚拟表&amp;rdquo;分配给 &lt;code&gt;mg_virtual&lt;/code&gt; 字段。请参阅下面的&amp;ldquo; &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;魔术虚拟表&amp;rdquo;&lt;/a&gt;部分。该 &lt;code&gt;how&lt;/code&gt; 参数也存储在 &lt;code&gt;mg_type&lt;/code&gt; 领域。的价值 &lt;code&gt;how&lt;/code&gt; 应从组宏选择 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 中发现的</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switch语句称为 &lt;code&gt;given/when&lt;/code&gt; ，仅在perl 5.10或更高版本中可用。请参阅&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsyn中的Switch语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51ab4452b7e8aefb4a20c0fd55e5ee11bfae3081" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc5a13c9ade0909b5ffefb1aee0a9413eb8d3b5" translate="yes" xml:space="preserve">
          <source>The switches above deserve explanation. &lt;code&gt;--no-ff&lt;/code&gt; indicates that even if all your work can be applied linearly against blead, a merge commit should still be prepared. This ensures that all your work will be shown as a side branch, with all its commits merged into the mainstream blead by the merge commit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b8e93cb0b51582c675d9a8aa40dc2d0d3cfccab" translate="yes" xml:space="preserve">
          <source>The switches here are -r to recurse into any directories below 't' and -b which adds ./blib/lib and ./blib/arch to Perl's include path so that the tests can find the code they will be testing. If I'm testing a module of which an earlier version is already installed I need to be careful about the include path to make sure I'm not running my tests against the installed version rather than the new one that I'm working on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea55b37c83e9242fca02717bc11a9fce7934d1e9" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;&quot;OP class abbreviations&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">例如，尖括号之间的符号表示op的类型；&amp;lt;2&amp;gt;是BINOP，&amp;lt;@&amp;gt;是LISTOP，&amp;lt;＃&amp;gt;是PADOP，用于线程Perl。（请参阅&lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP类的缩写&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">软件包的符号表恰好存储在该名称的哈希中，并附加了两个冒号。主符号表的名称因此简称为 &lt;code&gt;%main::&lt;/code&gt; 或 &lt;code&gt;%::&lt;/code&gt; 。同样，前面提到的嵌套包的符号表名为 &lt;code&gt;%OUTER::INNER::&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="309a96ca92bbc8636f854ec2354e0659976f1abe" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt;, or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">符号表里的名字看起来就像线噪。</target>
        </trans-unit>
        <trans-unit id="9284dc458d23c8892508c2adfd2449416ee1df69" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the mode argument are exported by VMS::Stdio by default, and are also exported by the Fcntl package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">符号ZIP_CM_STORE、ZIP_CM_DEFLATE、ZIP_CM_BZIP2和ZIP_CM_LZMA用于选择压缩方式。</target>
        </trans-unit>
        <trans-unit id="b89d5eb1a6608598259ad58b96f51e05f4c62a8d" translate="yes" xml:space="preserve">
          <source>The synonym Strtod() may be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">使用间接对象调用语法时，方法调用及其参数之间的句法位置。（该插槽的特点是它与下一个参数之间没有逗号。） &lt;code&gt;STDERR&lt;/code&gt; 在此处的间接对象插槽中：</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">语法</target>
        </trans-unit>
        <trans-unit id="98466f6b4c50ed9b1b9be5898a44ee0da163a090" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(?[ ])&lt;/code&gt; in a regular expression yields a list of single code points, none can be a sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba4b4939723b8e356e5354c0a4613ac1ca8c7fbd" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">语法和行为与&amp;ldquo; &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 相似，不同之处在于测试将被标记为失败但可以执行。&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;会将其解释为通过。</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; 的语法大约是唯一的方法，但是仍然很混乱。只要从上面的示例开始，您就可以了。</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">输入FileGlob的语法与 &lt;code&gt;File::Glob&lt;/code&gt; 相同，但以下内容除外</target>
        </trans-unit>
        <trans-unit id="91b339d4084c59a0f56840bad513aaf8cf0b9224" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt;, except for the following</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">将文本字符串编码为二进制字符串的语法和解码一样简单。</target>
        </trans-unit>
        <trans-unit id="6de19f7b88c80bb9cdb41dbc1a8bdd69b98ff8b9" translate="yes" xml:space="preserve">
          <source>The syntax of patterns used in Perl pattern matching evolved from those supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex routines. (The code is actually derived (distantly) from Henry Spencer's freely redistributable reimplementation of those V8 routines.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">语法:</target>
        </trans-unit>
        <trans-unit id="6e911200da76df16e0a83de577d8669f75cca2df" translate="yes" xml:space="preserve">
          <source>The sysread(), recv(), syswrite() and send() operators are deprecated on handles that have the &lt;code&gt;:utf8&lt;/code&gt; layer, either explicitly, or implicitly, eg., with the &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">正在设计的系统是大型的,或有可能成为大型的。</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">系统复制例程也可以直接在VMS和OS / 2下以 &lt;code&gt;File::Copy::syscopy&lt;/code&gt; （或在VMS下以 &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; ，这是为syscopy进行实际工作的例程）。</target>
        </trans-unit>
        <trans-unit id="b94efe0827258f7a0df5937358145073b3689390" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt;, which is the routine that does the actual work for syscopy).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">系统设计已经是面向对象的。</target>
        </trans-unit>
        <trans-unit id="252893c973435ea38255f9114e6c78b7c2f4935b" translate="yes" xml:space="preserve">
          <source>The system function it replaces can have its static return buffer trashed, not only by a subesequent call to that function, but by a &lt;code&gt;freelocale&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, or other locale change. The returned buffer of this function is not changed until the next call to it, so the buffer is never in a trashed state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">系统忽略第一行,并将程序送至</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">系统时间是指内核本身代表这个进程用户执行例程或系统调用的时间。</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">空循环的系统时间可能会比带有实际代码的循环的系统时间稍长一些，因此差值可能最终小于0。</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">系统的日期时间和日历日期的概念以多种不同的方式进行控制。不要假设时区存储在 &lt;code&gt;$ENV{TZ}&lt;/code&gt; ，即使是这样，也不要假设您可以通过该变量控制时区。不要对三个字母的时区缩写做任何假设（例如，MST将是&amp;ldquo;山区标准时间&amp;rdquo;，众所周知，它代表&amp;ldquo;莫斯科标准时间&amp;rdquo;）。如果您需要使用时区，请以一些明确的格式表示它们，例如与UTC的确切分钟数偏移或POSIX时区格式。</target>
        </trans-unit>
        <trans-unit id="ed3226a2f2631da1a16aa62735723438d4e491ac" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt;, and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">下表有两列。左列包含要查找的 &lt;code&gt;\p{}&lt;/code&gt; 构造，可能前面带有上述标志；右列包含有关它们的信息，例如描述或同义词。该表显示了具有它们的每个属性的单一形式和复合形式。如果左列是属性的缩写，则右列将给出其更长的，更具描述性的名称；如果左栏是最长的名称，则右栏将显示任何等效的最短名称，适用时可以是单字形式或复合形式。</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">表文件应位于</target>
        </trans-unit>
        <trans-unit id="0f20314df9f35b36eb10a691047b3cd3cf2ffd4f" translate="yes" xml:space="preserve">
          <source>The table in this section lists all the Perl API elements available, sorted by the version in which support starts. This includes all the elements that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">所有操作的方法表都以魔术的形式缓存在包的符号表哈希中。在处理 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; ，新函数定义以及@ISA中的更改期间，缓存无效。</target>
        </trans-unit>
        <trans-unit id="2c1ebd6c35d6d5b09dedbf5b41acedd8ee971357" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;use overload&lt;/code&gt;, &lt;code&gt;no overload&lt;/code&gt;, new function definitions, and changes in @ISA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcf2718afd051a8a2171808fbbd533fc26865cc1" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; is not identical to that proposed by the Raku specification, mainly due to differences between Raku's and Perl 5's data models, but also because the Raku spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlop&lt;/a&gt;中Smartmatch Operator中的smartmatchs表与Perl 6规范中提出的表不完全相同，这主要是由于Perl 6和Perl 5的数据模型之间的差异，也是因为自Perl 5抢先采用以来Perl 6规范已更改。</target>
        </trans-unit>
        <trans-unit id="744a22264ceb5e3af0d89371d88c54fa44eb074f" translate="yes" xml:space="preserve">
          <source>The table structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">切线</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">焦油球的创建方法如下:</target>
        </trans-unit>
        <trans-unit id="5f3864dd27cd34c2e98d0ec223d6fceecc7c957c" translate="yes" xml:space="preserve">
          <source>The target directory to store the spec files in can be set using &lt;code&gt;dir&lt;/code&gt; as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">我们的目标是使OS/2成为使用/构建/开发Perl的最佳支持平台之一。</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">靶子的OP,或者什么都没有的无效OP。</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">模板可以根据每个使用的密钥采取不同的规则集。</target>
        </trans-unit>
        <trans-unit id="7dd55749521ef7a1d8d1762bd0dfd93dc2ed7572" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">模板可以是任何附加了一些X的文件名,例如F,后面的X用唯一的字母数字组合代替。</target>
        </trans-unit>
        <trans-unit id="d2a0774e46a5ddeb6abfa59a3643d774d174d289" translate="yes" xml:space="preserve">
          <source>The temporaries stack stores pointers to xVs whose reference counts will be decremented soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b658a51743ea23f5f90b8615b574c3089e0c4bce" translate="yes" xml:space="preserve">
          <source>The tenth and subsequent priorities are to look in directories named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">当我们谈论原生整数时,&quot;原生 &quot;一词的意义并不像涉及原生浮点数时那样大。但是,&quot;原生 &quot;浮点数有一个最基本的限制:它们只能表示那些转换为二进制分数时有相对 &quot;短 &quot;表示的数字。例如,0.9不能用原生浮点数表示,因为0.9的二进制分数是无限的。</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">&quot;铁路正常形式 &quot;这个术语有点深奥,&quot;语法图/图 &quot;或 &quot;铁路图/图 &quot;是更常见的术语。尽管如此,它还是提供了一个有用的重构程序的心理形象:每一个节点都可以看作是一个轨道单位,只有一个入口,大多数情况下只有一个出口点(有的轨道会分叉,但据统计并不多),整个形成了一个布局,只有一个入口和一个出口点。匹配过程可以看成是一辆沿着轨道移动的汽车,在系统中的具体路线由每个可能的连接点读取的字符决定。车子可以在任何一个点掉出轨道,但只要与轨道匹配,它就只能继续前进。</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">术语 &quot;数学 &quot;描述了数学运算符的超载实现。数理运算提出了一个问题。请看下面的代码。</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">术语&amp;ldquo; Unicode错误&amp;rdquo;已应用于与 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; 块中的代码点不一致的地方，即128到255之间。与所有其他字符或代码点不同，没有指定语言环境，这些字符可以具有取决于有效规则的语义非常不同。（代码点大于255的字符将强制执行Unicode规则；而ASCII和Unicode规则下的ASCII字符规则均相同。）</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">该终端的终端输出比特率(通常被误称为波特率)--如果没有设置,将产生警告,默认为9600。</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">将使用其termcap条目的终端类型-如果未提供，则默认为$ ENV {TERM}：如果未设置，则&lt;b&gt;Tgetent&lt;/b&gt;会&lt;b&gt;崩溃&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">终止字符串可以是标识符（单词）或某些带引号的文本。未加引号的标识符的作用类似于双引号。除非显式引用标识符，否则 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和标识符之间可能没有空格。（如果您放置一个空格，它将被视为一个空标识符，该标识符是有效的，并且与第一个空行匹配。）终止字符串必须自己出现在终止行上（未加引号且没有空格）。</target>
        </trans-unit>
        <trans-unit id="10b4a47dbe9b183e3332ce5dc657e06a6f7d67c1" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">通过将控制权暂时切换到perl解析器，可以找到运行时的终止符 &lt;code&gt;(?{...})&lt;/code&gt; ，该终止符应在找到逻辑平衡的终止符 &lt;code&gt;}&lt;/code&gt; 处停止。</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">测试线束还有很多需要改进的地方。欢迎使用补丁。</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">测试名称扩展名。默认为 &lt;code&gt;.t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6571e20ce9a71fb843fe89c152d8dbe08235f523" translate="yes" xml:space="preserve">
          <source>The test phase is when the distribution's automated test suite is run. Any library that is needed only for testing and not for subsequent use should be listed here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">测试套件要好得多,但总是需要改进。</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">测试将以255退出。</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">该测试系统旨在通过对您要测试的每个测试执行三步过程来使用。此过程首先使用 &lt;code&gt;test_out&lt;/code&gt; 和 &lt;code&gt;test_err&lt;/code&gt; 来声明要测试的测试套件将通过&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;输出到stdout和stderr。</target>
        </trans-unit>
        <trans-unit id="7d184971a14375f569314d2fb6a264dcab98a443" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">测试</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">测试 &lt;code&gt;-b&lt;/code&gt; ， &lt;code&gt;-B&lt;/code&gt; ， &lt;code&gt;-c&lt;/code&gt; ， &lt;code&gt;-C&lt;/code&gt; ， &lt;code&gt;-d&lt;/code&gt; ， &lt;code&gt;-e&lt;/code&gt; ， &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-M&lt;/code&gt; ， &lt;code&gt;-s&lt;/code&gt; ， &lt;code&gt;-S&lt;/code&gt; ， &lt;code&gt;-t&lt;/code&gt; ， &lt;code&gt;-T&lt;/code&gt; 和 &lt;code&gt;-z&lt;/code&gt; 的工作与广告一样。 &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; 的返回值告诉您是否可以实际访问该文件。这可能无法反映基于UIC的文件保护。由于真实有效的UIC在VMS下没有区别，因此 &lt;code&gt;-O&lt;/code&gt; ， &lt;code&gt;-R&lt;/code&gt; ， &lt;code&gt;-W&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 等效于 &lt;code&gt;-o&lt;/code&gt; ， &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; 。同样，在VMS下，其他几个测试（包括 &lt;code&gt;-A&lt;/code&gt; ， &lt;code&gt;-g&lt;/code&gt; ， &lt;code&gt;-k&lt;/code&gt; ， &lt;code&gt;-l&lt;/code&gt; ， &lt;code&gt;-p&lt;/code&gt; 和 &lt;code&gt;-u&lt;/code&gt; ）也不是特别有意义，这些测试返回的值反映了您的CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 例程所做的一切到st_mode字段中的等效位。最后，如果传递了没有显式目录的设备规范（例如 &lt;code&gt;DUA1:&lt;/code&gt; )以及传递了目录，则 &lt;code&gt;-d&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="9c967d1ae062bd6388a4176bc92989ac103705dc" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-B&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-S&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;, and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;. Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;-g&lt;/code&gt;, &lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and &lt;code&gt;-u&lt;/code&gt;, aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;stat()&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt;), as well as if passed a directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc12f2671ba906087d5eb6304768a3d9deaa9bcf" translate="yes" xml:space="preserve">
          <source>The tests are wholly and completely skipped. [10] This will work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8be2ba8a0a786a9e0b622bcec19843e1f59daa7" translate="yes" xml:space="preserve">
          <source>The tests for this module directly access &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; hash keys. Most, if not all of these hash keys have public API methods that could be used instead to avoid the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">文本 &quot;对象属性 &quot;构成了那里的标题。这些标题命令中的文本可以使用格式代码,如这里所示。</target>
        </trans-unit>
        <trans-unit id="5d105df3ca2da40b603c19669d88379eb24889fa" translate="yes" xml:space="preserve">
          <source>The text content will have tabs already expanded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca64065f1722f4560dea83450c678ea442c364d" translate="yes" xml:space="preserve">
          <source>The text in the above examples enclosed between the &lt;code&gt;&quot;/&quot;&lt;/code&gt; characters can be just about any regular expression. It is independent of the main pattern, so doesn't share any capturing groups,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846d0e4adec8717ba9914b28f27a3deba7538bf" translate="yes" xml:space="preserve">
          <source>The text matched by the highest used capture group of the last successful search pattern. It is logically equivalent to the highest numbered capture variable (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ...) which has a defined value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">最后一个成功搜索模式的最后一个括号所匹配的文本。如果您不知道一组备选模式中哪一个匹配,这很有用。例如</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">最后一次成功搜索模式的使用过的组(即最右边括号的组)所匹配的文本。</target>
        </trans-unit>
        <trans-unit id="5e596703d1021b4590de3b141bfc6f8bfaf78ff0" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern. This is subtly different from &lt;code&gt;$+&lt;/code&gt;. For example in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">在打印程序的使用信息之前,要立即打印的信息文本。</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile的文本在写入磁盘之前会通过这种方法运行。它让系统有机会对Makefile进行可移植性修正。</target>
        </trans-unit>
        <trans-unit id="fe3785c2d13add392a07d1b360e255c73be9984b" translate="yes" xml:space="preserve">
          <source>The text of the message as a &lt;code&gt;SVpv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">文本/二进制的问题在Cygwin文档中已有详细介绍。</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">上面的thetas、phis、方向、距离都是以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">您正在处理的事情。结构类似 &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; ，并 &lt;code&gt;given&lt;/code&gt; 通过分配来设置主题为你 &lt;code&gt;$_&lt;/code&gt; ，默认（</target>
        </trans-unit>
        <trans-unit id="d349e0f7ce22448af1f85ae29fc321760bdcefb3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt;, the default (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3293c9c16b6eb4008c2299c5283501a14ee373" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">如果作为TRUE值传​​递，第三个参数（$ binmode）将选择二进制模式。在二进制模式下，&amp;ldquo; \ n&amp;rdquo;的编码方式与其他任何不可打印的字符相同。这确保了解码器无论使用哪种行结束序列，都将以完全相同的字符串结尾。通常，最好对二进制数据使用base64编码。参见&lt;a href=&quot;base64&quot;&gt;MIME :: Base64&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf989e588a5ff932bae69e35a56b32b82b9fac73" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;\@on_fail&lt;/code&gt;) is an optional set of diagnostics to be sent in the event of a test failure. Unlike with &lt;code&gt;fail()&lt;/code&gt; these diagnostics must be plain strings, data structures are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">第三个参数可以是一个带有选项的哈希引用。注意,所有的选项都是区分大小写的。</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">第三个参数是一个可选的前缀。所有的文件将被藏在您指定的前缀目录中。因此,如果您的存档中有文件'a'和'b',而您指定'foo'作为前缀,它们将以'foo/a'和'foo/b'的形式写入存档。</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">当（且仅）两个操作数已交换时，第三个参数设置为TRUE。 Perl可以这样做，以确保第一个参数（ &lt;code&gt;$self&lt;/code&gt; ）是实现重载操作的对象，符合常规的对象调用约定。例如，如果 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 是 &lt;code&gt;Number&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e0c4e0c0cbbd72e926793186b0870f3e51aaf16b" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt;) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">您可以在Perl正则表达式中使用的字符类的第三种形式是方括号中的字符类。它以最简单的形式列出可能匹配的字符，并用方括号括起来，如下所示： &lt;code&gt;[aeiou]&lt;/code&gt; 。这匹配 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;o&lt;/code&gt; 或 &lt;code&gt;u&lt;/code&gt; 之一。与其他字符类一样，一个字符也将完全匹配。*要匹配由字符类中提到的字符组成的更长字符串，请在字符类后面加上一个&lt;a href=&quot;perlre#Quantifiers&quot;&gt;数量词&lt;/a&gt;。例如， &lt;code&gt;[aeiou]+&lt;/code&gt; 匹配一个或多个小写英语元音。</target>
        </trans-unit>
        <trans-unit id="da916e8511a4663908a2df2d14a8fc11695fa70c" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt;. This matches one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt;. Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">第三种方案是在构建Perl时,通过指定-Ui_db来配置,然后使用CPAN中的BerkeleyDB模块代替DB_File,完全禁用DB_File来解决这个问题。BerkeleyDB适用于Berkeley DB 2.*或更高版本。</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">第三个参数是整数标志，它告诉 &lt;code&gt;rmscopy&lt;/code&gt; 如何处理时间戳。如果它小于0，则没有输入文件的时间戳传播到输出文件。如果它大于0，则将其解释为位掩码：如果设置了位0（LSB），则将传播除修订日期以外的时间戳；否则，将传播该时间戳。如果设置了位1，则会传播修订日期。如果 &lt;code&gt;rmscopy&lt;/code&gt; 的第三个参数为0，则其行为类似于DCL COPY命令：如果显式指定了输出文件的名称或类型，则不会传播任何时间戳，但是如果它们是从输入filespec中隐式获取的，则除修订日期以外的所有时间戳都会传播。如果未提供此参数，则默认为0。</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 的第三个参数确定是否在不存在给定方法的情况下执行AUTOLOAD查找：非零表示是，查找AUTOLOAD；否则返回0。零表示不，不要寻找AUTOLOAD。调用 &lt;code&gt;gv_fetchmethod&lt;/code&gt; 等效于使用非零 &lt;code&gt;autoload&lt;/code&gt; 参数调用 &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">第三种更有效的方法是模仿Perl内部的做法。</target>
        </trans-unit>
        <trans-unit id="4baba8cca2cc8406f593d4d91d751f6705e4259a" translate="yes" xml:space="preserve">
          <source>The thread ID in which the event was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35817a67488b477301f26017a906bceb6698d6d8" translate="yes" xml:space="preserve">
          <source>The thread ID of the hub the event was sent to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">线程化的Perl构建在AIX 5.1上也能工作,但IBM的Perl构建(Perl v5.6.0)在AIX 5.1上不是线程化的。</target>
        </trans-unit>
        <trans-unit id="7cda8f2369f06b63a0604a363c17ca6dadb5ab34" translate="yes" xml:space="preserve">
          <source>The three alternative macros are for the most commonly needed validations; they are likely to run somewhat faster than this more general one, as they can be inlined into your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">在Perl 5.22中，这三个点状的按位赋值运算符（ &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ）是新的，并且是实验性的。请参见&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c23c9e704aad4fb3e2b155575140f095b0d8c904" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt;) are new in Perl 5.22. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">关键哈希的三个特点。</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">子程序的三次调用都是同步运行的。不过旗语可以确保一次只有一个线程访问全局变量。</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">三个预定义的变量$DB_HASH、$DB_BTREE和$DB_RECNO通常足以满足大多数应用程序的需要。如果你确实需要创建这些对象的额外实例,那么每个文件类型都有构造函数。</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">程序员的三大美德是懒惰、急躁和傲慢。原因请看《骆驼记》。</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision、api_version和api_subversion这三个变量指定了与当前perl兼容的最老的perl二进制的版本。在一个完整的版本字符串中,如</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">这三个警告功能 &lt;code&gt;warnings::warn&lt;/code&gt; ， &lt;code&gt;warnings::warnif&lt;/code&gt; ，警告和 &lt;code&gt;warnings::enabled&lt;/code&gt; 可以启用对象引用来代替类别名称。在这种情况下，函数将使用对象的类名称作为警告类别。</target>
        </trans-unit>
        <trans-unit id="7318f95ef0833e84e87f8f8ccae92d5cf168ab78" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt;, &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl＃121481]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl＃116487]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl＃119313]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl＃119315]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl＃119317]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl＃119437]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl＃119451]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl＃119453]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl＃119455]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl＃120085]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl＃122947]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl＃123630]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">此功能的票证是&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl＃123707]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">此功能的门票为&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl＃120162]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie()函数将一个变量绑定到一个类(包)上,该类将为该变量的访问方法提供实现。一旦这个魔法被执行,访问绑定的变量就会自动触发适当类中的方法调用。类的复杂性就隐藏在魔法方法调用的背后。方法的名称是用大写的,这是Perl用来表示它们是隐式调用而不是显式调用的惯例--就像BEGIN()和END()函数一样。</target>
        </trans-unit>
        <trans-unit id="0cc71f8e2650c3f7dc36c81297b9a74bd871dbac" translate="yes" xml:space="preserve">
          <source>The tighter rules given above for the single form apply to everything to the right of the colon or equals; the looser rules still apply to everything to the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">程序开始运行的时间，自该时间段（1970年开始）以来的秒数。&lt;b&gt;-M&lt;/b&gt;，&lt;b&gt;-A&lt;/b&gt;和&lt;b&gt;-C文件&lt;/b&gt;测试返回的值基于该值。</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">时间缩短了一半，从任何标准来看，这都是相当可观的速度改进。自然地，检查输出是否与第一个程序运行一致很重要，这是Unix系统 &lt;code&gt;cksum&lt;/code&gt; 实用程序出现的地方。</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">所需的时间取决于你的机器有多快和你的编码有多大。除非你的工作是像euc-tw这样大的东西,否则不会花太多时间。</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">空循环(循环次数相同但循环体为空的循环)的时间减去实循环的时间。</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">返回的时间还包括被执行了wait()的终止子进程的进程时间。这个值有点像核心Perl的 times()返回的第二个值,但不一定相同。请注意,由于向后兼容性的限制,返回的值可能会在2147秒左右或者36分钟左右绕过。</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Perl实际上正在执行您的代码所说的事情的时间，而不是之前它试图弄清楚您所说的内容是否有意义的&lt;b&gt;时间&lt;/b&gt;，这就是&lt;b&gt;编译时间&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">Perl尝试理解您的代码的时间，而不是它认为自己知道代码的含义的时间，而仅仅是尝试执行代码认为要执行的操作，即&lt;b&gt;runtime&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">PKG]中的超时时间可以指定为零来实现 &quot;轮询&quot;,但你不应该这样做,因为在幕后会创建一个新的IO::Select对象来进行单次轮询。这是非常低效的。使用相当真实的select(),句柄超时为零,或者使用非阻塞IO。</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">超时可以是一个相对于当前时间的秒数(例如,从拨打电话时起5秒),也可以是一个绝对的超时,以</target>
        </trans-unit>
        <trans-unit id="ff980bdd72965b0a57183b47bf6c39d63a6adebb" translate="yes" xml:space="preserve">
          <source>The timeout value, in seconds, for this socket connection. How exactly this value is utilized is defined in the socket domain subclasses that make use of the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">利用时间(3)和次数(3)进行计时。</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">本节的标题指示打包C结构时迟早会遇到的第二个问题。如果您打算调用的函数期望一个 &lt;code&gt;void *&lt;/code&gt; 值，则您</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;perlre&quot;&gt;perlre中&lt;/a&gt;可以找到有关Perl正则表达式的顶级文档。</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">树的顶部节点是 &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">测试运行所需的总时间,从纪元开始,以秒为单位。</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">比较的总数等于每个存储桶中条目数的平方和。对于 &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt;个存储桶中 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt;个键的随机散列，期望值为：</target>
        </trans-unit>
        <trans-unit id="dd7a1cc091879ad89ef24fb0639fcf0e894d70ac" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt;&amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt;&amp;gt; buckets, the expected value is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">测试运行的总时间（以秒为单位）。如果 &lt;code&gt;Time::HiRes&lt;/code&gt; 可用，它将具有更精细的粒度。</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">权衡的办法是,需要提前计算返回值的数量(虽然过度扩展堆栈通常除了内存消耗外不会有任何伤害)。</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">在某些系统上，传统的&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;和&amp;ldquo; 2&amp;rdquo; MODE是用不同的数值实现的。但是，由 &lt;code&gt;Fcntl&lt;/code&gt; 导出的标志（O_RDONLY，O_WRONLY，O_RDWR）应该在任何地方都有效。（Mac OS，OS / 390）</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">传统的名称后跟一个用大括号括起来的名称，意思是该名称给出的字符（或字符序列）。因此 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; 是另一种写 &lt;code&gt;*&lt;/code&gt; 的方式，在双引号字符串和正则表达式模式中均有效。在模式中，它没有未转义 &lt;code&gt;*&lt;/code&gt; 的含义。</target>
        </trans-unit>
        <trans-unit id="aa46fd7f5efd6b7870b67ed7954394e54344b140" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt;, valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">过渡性编译环境是通过以下编译器和链接器标志获得的。</target>
        </trans-unit>
        <trans-unit id="5205d19a729f5413830c865ec36ec411e1524d36" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#tr%2F%2F%2F&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a818fdcd409263a5793457d26567f24ef801cf" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#y%2F%2F%2F&quot;&gt;&lt;code&gt;y///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">音译运算符。与 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 相同。请参阅&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlop中的类似于引用的运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">陷阱法和解陷阱法是拒绝和允许的同义词,恭敬地。</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">将多条物理&lt;b&gt;线&lt;/b&gt;视为一条逻辑线。通过在&lt;b&gt;换行符&lt;/b&gt;前加反斜杠来继续&lt;b&gt;Makefile &lt;/b&gt;&lt;b&gt;行&lt;/b&gt;。RFC 822定义的邮件标题通过放置空格或制表符来继续</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">树是由编译器创建的,而</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">此任务中的技巧是找到目录。在脚本执行其他任何操作（例如 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ）之前，您可以使用Perl随附的 &lt;code&gt;Cwd&lt;/code&gt; 模块获取当前的工作目录：</target>
        </trans-unit>
        <trans-unit id="37e82dc52d548373adee493d4ea5761e5091b906" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;chdir&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">诀窍在于，如果您阅读 &lt;code&gt;BOM&lt;/code&gt; ，您将知道字节顺序，因为如果它是在big-endian平台上编写的，您将读取字节 &lt;code&gt;0xFE 0xFF&lt;/code&gt; ，但是，如果它是在little-endian平台上编写的，则您可以将读取字节 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 。（如果原始平台使用ASCII平台UTF-8编写，则将读取字节 &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="d8b1136600662502a87d3bbe9f24bb9e6d532704" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt;, you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">诀窍是在AIX上运行Configure shell脚本时,给它一个特殊参数。</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">解决此问题的技巧是避免意外的自动生存。如果您想深入检查三个键，可以天真的尝试一下：</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">要记住的是,第一个参数为真,如果你想让</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">还定义了三角常数&lt;b&gt;pi&lt;/b&gt;及其一些方便的倍数。</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">对项目2的信任是可传递的。如果A信任B，B信任C，则A信任C。因此，如果您不使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; 覆盖 &lt;code&gt;@ISA&lt;/code&gt; ，则此信任关系与&amp;ldquo;继承自&amp;rdquo;相同。</target>
        </trans-unit>
        <trans-unit id="5a53c9a156d74f53aad5146b2193b6c99edc7b60" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt;, then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">事实上,现在的perl的正则表达式要比这种结构复杂得多,但这样可视化可以帮助你在试图了解自己的方向时,它与当前的实现非常吻合。</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">在类似UNIX的环境 &lt;code&gt;stty&lt;/code&gt; 中，将tty驱动程序置于原始模式并使用操作系统特定的命令进行还原。</target>
        </trans-unit>
        <trans-unit id="cdeef98c16938c38d93335b37db574e68be16a48" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">在Llama中开始的教程在Alpaca中继续,介绍了引用、数据结构、面向对象编程和模块的中间特性。</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">来自perl的另外两行要求捕获代码中的各种常见问题。他们检查不同的事物，因此您同时需要两者。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; 潜在问题； &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; 时，将导致您的代码在遇到时立即停止；只会发出警告（如命令行开关&lt;b&gt;-w&lt;/b&gt;），并让您的代码运行。要了解更多关于他们在检查各自的手册页&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80da0e6781561e53bd7245c97926dc9ea61049b1" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;use strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;use warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits（）的两个参数形式将添加$ data中的前$ nbits位。对于最后一个可能的部分字节，仅使用高位 &lt;code&gt;$nbits % 8&lt;/code&gt; 位。如果$ nbits大于 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; ，则此方法将与 &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a487d05aa816a2a714594f695177da57d7a262a6" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;length($data) * 8&lt;/code&gt;, then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; 和 &lt;code&gt;@EXPORT&lt;/code&gt; 这两个数组非常重要。的 &lt;code&gt;@ISA&lt;/code&gt; 数组包含在其中搜索用于不在当前包中存在的方法（或子程序）的其它包的列表。这通常仅对面向对象的扩展很重要（我们将在后面讨论），因此通常不需要进行修改。</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">两个控制字符^D和^Z,以及标记__END__和__DATA__可以用来表示脚本在文件实际结束之前的逻辑结束。任何下面的文字都会被忽略。</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">这两个入口点是 &lt;code&gt;re_intuit_start()&lt;/code&gt; 和 &lt;code&gt;pregexec()&lt;/code&gt; 。这些例程之间存在某种乱伦的关系，它们的函数之间存在重叠，并且 &lt;code&gt;pregexec()&lt;/code&gt; 甚至可以自己调用 &lt;code&gt;re_intuit_start()&lt;/code&gt; 。但是，perl源代码的其他部分可能会调用其中之一，也可能两者都调用。</target>
        </trans-unit>
        <trans-unit id="18c4b8288d8734c5d96fe76caf7da0dc805d1f00" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt;. These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">这两个文件名也可以分别以 &lt;code&gt;$dirfile&lt;/code&gt; 和 &lt;code&gt;$pagfilename&lt;/code&gt; 。这适合两个没有扩展名&amp;ldquo; .dir&amp;rdquo;和&amp;ldquo; .pag&amp;rdquo;的文件，例如，&lt;a href=&quot;file/temp&quot;&gt;File :: Temp中的&lt;/a&gt;两个文件。</target>
        </trans-unit>
        <trans-unit id="d779d1807753d79ce6e5b3476dc2ab8ca5a48661" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt;. This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">前两种形式是简单的语法糖,第一次使用时自动加载正确的模块。第二种形式允许你使用包含字母的算法名,这些字母不是合法的perl标识符,例如 &quot;SHA-1&quot;。如果找不到给定算法的实现,那么就会引发一个异常。</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">这两个主要用途是切换回内部作用域内使用包子。</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">在构造数组这样的东西时,最常犯的两个错误是:要么是不小心数到了元素的数量,要么是重复地获取对同一个内存位置的引用。这里的情况是,你只得到计数而不是嵌套数组。</target>
        </trans-unit>
        <trans-unit id="bd2d45d08dbd09dca740f5cf8bff110dce877246" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;插件支持的两个主要用例是</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">最快的两个修复方法是,让Perl对任何locale的不一致保持沉默,或者在默认locale &quot;C &quot;下运行Perl。</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">这两组barch图给出了统计数字,并直观地显示了哈希的性能。</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">这两种说法。</target>
        </trans-unit>
        <trans-unit id="9d44f9be0143700229ab0017bf471dc2508dbc35" translate="yes" xml:space="preserve">
          <source>The two-sided ordering operators &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;cmp&quot;&lt;/code&gt;, and the smartmatch operator &lt;code&gt;&quot;~~&quot;&lt;/code&gt;, are non-associative with respect to each other and with respect to the equality operators of the same precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f9fd98a080c00fe06d27a5abbbe001334533cf" translate="yes" xml:space="preserve">
          <source>The type of partition. See the &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; export class for a list of known types. See also &lt;code&gt;IsRecognizedPartition&lt;/code&gt; and &lt;code&gt;IsContainerPartition&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">常数的类型(</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">第三个参数的类型就类型图而言是任意的。它只需与声明的变量一致即可。</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">匹配项的类型被粉刷（除了逗号，逗号之前没有空格，而多个 &lt;code&gt;*&lt;/code&gt; 之间没有空格）。</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">类型图检查标量引用是否从perl传递到XS。</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">这些类型是:</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">典型的C编译器的第一遍，处理以 &lt;code&gt;#&lt;/code&gt; 开头的行以进行条件编译和宏定义，并根据当前定义对程序文本进行各种操作。也称为</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">典型的方法是使用Perl调试器,描述于</target>
        </trans-unit>
        <trans-unit id="4f5664b1824b0de67fa46d923ec8d9a2b184a8da" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the &lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug(1)&lt;/a&gt; manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">一个程序的典型输入/输出流程是。</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">典型的数据之间的相互作用最好用运算符来表示。</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">典型的使用情况是用于本地磁盘上的私有模块或远程资源库中的项目工作副本。</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">典型用法是从&lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;生成的Makefile中。因此，在正常情况下，您不必直接处理此模块。</target>
        </trans-unit>
        <trans-unit id="e5ea1d13fc13ac160da9f2f104ab7304934ae9cc" translate="yes" xml:space="preserve">
          <source>The typical usage is from within perl's own Makefile (to build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">使用 &lt;code&gt;EVERY&lt;/code&gt; 调用的典型方法是将其包装在所有类都继承的另一个基本方法中。例如，要确保实际调用对象所继承的每个析构函数（而不是仅从最左深度第一开始）：</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">uncolor()函数和对ANSI_COLORS_DISABLED的支持是在Term::ANSIColor 1.04中添加的,包含在Perl 5.8.0中。</target>
        </trans-unit>
        <trans-unit id="d4305b00ed1c85486a9072f02e9b2ef3f0a22224" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;SetFilePointer&lt;/code&gt; returns &lt;code&gt;0xFFFFFFFF&lt;/code&gt; to indicate failure, but if &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, you would also have to check &lt;code&gt;$^E&lt;/code&gt; to determine whether &lt;code&gt;0xFFFFFFFF&lt;/code&gt; indicates an error or not. &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; does this checking for you and returns a false value if and only if the underlying &lt;code&gt;SetFilePointer&lt;/code&gt; failed. For this reason, &lt;code&gt;$uNewPos&lt;/code&gt; is set to &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; if you set the file pointer to the beginning of the file [or any position with 0 for the low-order 4 bytes].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2ba2ed494fcbfde7ff54569b0d33c7f011e269" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; 的基本行为由&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;模块提供。</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">底层解析器对象。如果你需要测试程序的完整信息,这很有用。</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">undump程序是一个古老的尝试,通过将已经编译好的形式存储到磁盘上来加快Perl程序的速度。这已经不是一个可行的方案了,因为它只在少数架构上有效,而且无论如何也不是一个好的解决方案。</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">不幸的是，此函数的名称与Perl的 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 运算符的相似之处完全是巧合。此功能从左开始工作； &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 从右边开始。</target>
        </trans-unit>
        <trans-unit id="a30b1d50e05e4b08ed93704bd74f564e5fd07aba" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;chop&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;chop&lt;/code&gt; works from the right.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="188f61d7ec87851548e9f8daeb9600a5a694a2e6" translate="yes" xml:space="preserve">
          <source>The union of two array refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">解开绳索,抓住你</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">解开()的疑难杂症</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">大写变体（ &lt;code&gt;\W&lt;/code&gt; ， &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\H&lt;/code&gt; 和 &lt;code&gt;\V&lt;/code&gt; ）是分别与不是单词字符，数字，空格，水平空格或垂直空格的任何字符匹配的字符类。</target>
        </trans-unit>
        <trans-unit id="969149804a3c69f65ce9535464f4fe7c8cb52284" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, and &lt;code&gt;\V&lt;/code&gt;) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">你传递给构造函数的URLI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist参数支持CD-ROM。</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">罐装过滤器的用法是。</target>
        </trans-unit>
        <trans-unit id="28d3b03a1f670128ac1940bc311030e5942649cb" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; was deprecated in Perl 5.8. The intention was to use &lt;code&gt;*glob{IO}&lt;/code&gt; instead, for which &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; is an alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">下例显示了 &lt;code&gt;//g&lt;/code&gt; 的用法。假设我们有一个由空格分隔的单词组成的字符串。如果我们事先知道有多少个单词，可以使用分组来提取单词：</target>
        </trans-unit>
        <trans-unit id="6a8f9ae899c24a9ba384007b7a56b302e1ecb384" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;/g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">不鼓励使用 &lt;code&gt;:void&lt;/code&gt; ，因为如果您使用它，可能会导致未引发异常</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">不建议将 &lt;code&gt;:void&lt;/code&gt; 与Fatal一起使用。</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">上面 &lt;code&gt;=&amp;gt;&lt;/code&gt; 的使用提供了 &lt;code&gt;MODULE&lt;/code&gt; 的必要引用。如果您不使用粗逗号（例如，您没有任何参数），则需要引用MODULE。</target>
        </trans-unit>
        <trans-unit id="3987152a02b0e8946670fa1ed3d0263b2379f73d" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\K&lt;/code&gt; inside of another lookaround assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">使用 &lt;code&gt;\Q&lt;/code&gt; 会将正则表达式中的&amp;lt;。&amp;gt;视为常规字符，因此 &lt;code&gt;P.&lt;/code&gt; 匹配一个 &lt;code&gt;P&lt;/code&gt; ,后跟一个点。</target>
        </trans-unit>
        <trans-unit id="fc1eea836569752f037bcfe192ccf1fd3a1c9537" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &lt;code&gt;.&lt;/code&gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a848a8f72097323f82bf0128df3ae2506a4c5d0" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated in Perl 5.10, and became a fatal error in Perl 5.30.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">骆驼与Perl主题的使用是O'Reilly and Associates,Inc.的商标。经许可使用。</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">在常量名称中使用大写只是一种惯例,但为了使常量更加突出,并有助于避免与其他裸词、关键字和子程序名称发生冲突,建议使用大写。常量名称必须以字母或下划线开头。以双下划线开头的名字是保留的。如果在编译时启用了警告,那么一些错误的名字会产生警告。</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">使用以连字符（ &lt;code&gt;-name&lt;/code&gt; ）开头或完全以大写（ &lt;code&gt;NAME&lt;/code&gt; ）开头的哈希键是Perl较旧版本的遗留物，其中 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符未正确处理普通的小写字符串。虽然某些模块出于历史原因或个人风格保留大写或带连字符的参数键，但大多数新模块应使用简单的小写键。无论您选择什么，都要保持一致！</target>
        </trans-unit>
        <trans-unit id="42f05d562fbd6250c25a2395c7f661a4ca156a47" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt;) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt;) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">正式&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;禁止&lt;/a&gt;在perl中使用基于解释器的线程。</target>
        </trans-unit>
        <trans-unit id="74fecb64d5ab9c5206223686d13a4c9238b9c4d9" translate="yes" xml:space="preserve">
          <source>The use of one-shot &lt;code&gt;gzip&lt;/code&gt; above just reads from &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; and writes the compressed data to standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa4d1599ed2c314509e371c80e5511844a0d9d78" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24, and became a fatal error in Perl 5.28.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9bd1a86a4853953267a9ded9b1645e890ed750a" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24; as of Perl 5.28 using a code point exceeding &lt;code&gt;IV_MAX&lt;/code&gt; throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">在&lt;b&gt;正则表达式&lt;/b&gt;中围绕&lt;b&gt;子模式&lt;/b&gt;使用括号将匹配的&lt;b&gt;子字符串&lt;/b&gt;存储为后向&lt;b&gt;引用&lt;/b&gt;。（捕获的字符串也将作为&lt;b&gt;列表上下文&lt;/b&gt;中的&lt;b&gt;列表&lt;/b&gt;返回。）请参见Camel第5章&amp;ldquo;模式匹配&amp;rdquo;。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">使用括号可以用来捕捉输入文件名的部分内容。</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">不鼓励使用以下功能，因为它们实际上不是测试功能，并且不会产生诊断信息以帮助找出问题所在。它们是在 &lt;code&gt;is_deeply()&lt;/code&gt; 存在之前编写的，因为我不知道如何显示两个任意数据结构的有用差异。</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenm选项</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">拥有该文件的用户ID</target>
        </trans-unit>
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">拥有该文件的用户名</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">用户时间是指整个进程代表用户在本系统上执行本程序的时间。</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">用户如果想根据你的策略让memoization cache过期,可以通过编写</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">一般的算术(+,-,+=,-=)也可以在对象上使用。</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">通常的调用签名是</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">通常的成语是。</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">终止线程的常用方法是使用适当的返回值从入口点函数&lt;a href=&quot;functions/return&quot;&gt;返回EXPR&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9019b0c3813c3cf91527f6ac86d5eb12ae5c43b5" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return()&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">常用的shell重定向符号 &lt;code&gt; | &lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 由CPAN壳识别&lt;b&gt;仅当由空白所包围&lt;/b&gt;。因此，用管道输送到分页器或将输出重定向到文件中的方式与在普通shell中一样，规定必须键入多余的空格。</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">如果不能读写相关文件,通常会发出警告。</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">如果不能读写相关文件,通常会发出警告。</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">通常可用的常数有</target>
        </trans-unit>
        <trans-unit id="59963cc04cd3e99323ab911f21a23f907334eab6" translate="yes" xml:space="preserve">
          <source>The usually available constants are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">util.c:1716是源码文件和行号。</target>
        </trans-unit>
        <trans-unit id="822e481a167310eec4961d968bbe1f00f0652d77" translate="yes" xml:space="preserve">
          <source>The utilities &lt;code&gt;c2ph&lt;/code&gt; and &lt;code&gt;pstruct&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f118979bfd7ebb716612c147525a5086ff812a" translate="yes" xml:space="preserve">
          <source>The utilities c2ph and pstruct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v 字符串只能移植到 v2147483647 (0x7FFF_FFFF),这就是 EBCDIC,或者更准确的说是 UTF-EBCDIC 的范围。</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">v5.16发行版还支持 &lt;code&gt;:loose&lt;/code&gt; 导入，用于字符名称的松散匹配，其作用与属性名称的松散匹配相同：也就是说，它忽略大小写，空格和下划线：</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrind工具可以用来查找内存泄漏和非法堆内存访问。从3.3.0版本开始,Valgrind只支持x86、x86-64版本的Linux和x86、x86-64版本的PowerPC和Darwin(OS X)。可以使用特殊的 &quot;test.valgrind &quot;目标来运行valgrind下的测试。发现的错误和内存泄漏会被记录在名为</target>
        </trans-unit>
        <trans-unit id="d0c464474306348983509bffccc9878d55f4fc97" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64. The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">分配给键 &lt;code&gt;'fallback'&lt;/code&gt; 告诉Perl应该多努力尝试找到另一种方法来实现缺少的运算符。</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">与 &lt;code&gt;env&lt;/code&gt; 关联的值本身就是一个哈希引用，它与 &lt;code&gt;%ENV&lt;/code&gt; 哈希中的相应值匹配。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">与 &lt;code&gt;perlconfig&lt;/code&gt; 关联的值本身就是一个hashref，它与 &lt;code&gt;Config.pm&lt;/code&gt; 模块中 &lt;code&gt;%Config::Config&lt;/code&gt; 哈希中的相应值匹配。前缀为 &lt;code&gt;not_&lt;/code&gt; 的键会否定对应的匹配项。</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">在Unix中， &lt;code&gt;$offset&lt;/code&gt; 的值为 &lt;code&gt;0&lt;/code&gt; ，但在Mac OS Classic中，此值为较大。然后可以将 &lt;code&gt;$offset&lt;/code&gt; 添加到Unix时间值中，以在任何系统上获得正确的值。</target>
        </trans-unit>
        <trans-unit id="9f9c34760dc2837fd17b567df1f5e5a179a637d8" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt;, but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">使用 &lt;code&gt;*name&lt;/code&gt; typeglob表示法时，哈希表每个条目中的值就是您所指的内容。</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">该值与 &lt;code&gt;$Config{'osname'}&lt;/code&gt; 。另请参见&lt;a href=&quot;config&quot;&gt;config&lt;/a&gt;和&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;记录的&lt;b&gt;-V&lt;/b&gt;命令行开关。</target>
        </trans-unit>
        <trans-unit id="78983deb0ac0844027ede959bcbb4cd4a4216250" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt;. See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#-V&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">$side的价值是</target>
        </trans-unit>
        <trans-unit id="31a20ded01fa49bc667d71f5d635d0f8fadc7fc6" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="773190d7908d36ab9698d1cdc21dc993faf50e45" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed978648f213fc988aacb1860e0d05dc9fcc12a7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$!&lt;/code&gt; at the time when the exception occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="495d3ee61dabdfbea0b627a5268ea9c708b5aa50" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$?&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ad0b97e1d614d4823576a0d2d5c3aedd5bf44c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$@&lt;/code&gt; when the context was created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">的值 &lt;code&gt;$Config{sitelib}&lt;/code&gt; 也是在C代码确定，而不是从读 &lt;code&gt;Config.pm&lt;/code&gt; ，这是不加载。</target>
        </trans-unit>
        <trans-unit id="e9e93b8ce5897e26af26e26d476dcd12a339350a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt;, which is not loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">OpenVMS 上 &lt;code&gt;$^O&lt;/code&gt; 值为&amp;ldquo; VMS&amp;rdquo;。要确定您正在运行的体系结构，请参考 &lt;code&gt;$Config{'archname'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">VOS 上 &lt;code&gt;$^O&lt;/code&gt; 值为&amp;ldquo; vos&amp;rdquo;。要确定正在运行的体系结构而无需加载所有 &lt;code&gt;%Config&lt;/code&gt; ，可以检查 &lt;code&gt;@INC&lt;/code&gt; 数组的内容，如下所示：</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">子返回时的 &lt;code&gt;$_&lt;/code&gt; 值将存储在文件名标题字段中。</target>
        </trans-unit>
        <trans-unit id="623588465c88b3488f6369fa12fbc193d14ce397" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be used as the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">当 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 未指向格式正确的UTF-8字符时， &lt;code&gt;flags&lt;/code&gt; 的值确定行为。如果 &lt;code&gt;flags&lt;/code&gt; 为0，则在发现 &lt;code&gt;*retlen&lt;/code&gt; ，将返回零，并设置* retlen，以便（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）是 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中下一个可能会开始以非格式字符开头的位置。同样，如果未按词法禁用UTF-8警告，则会引发警告。</target>
        </trans-unit>
        <trans-unit id="2605ec2ff838d0693c21dd89f119bc12d32e8a67" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, encountering a malformation causes zero to be returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised. Some UTF-8 input sequences may contain multiple malformations. This function tries to find every possible one in each call, so multiple warnings can be raised for the same sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">字符（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）的值是相应的Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="77376c07ae757b89b1359df5120af7875474ea9a" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;chr&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="920c1e9d793047c1281d1ee5cb5fb337f4ae7f17" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">属性的值本身可以是另一个对象。例如， &lt;code&gt;File&lt;/code&gt; 类可以返回代表该值的&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;对象，而不是将其最后的mod时间作为数字返回。</target>
        </trans-unit>
        <trans-unit id="b0e6c192bc663d6d0a358f12fd16e1e3c9bf344d" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;&quot;charprop()&quot; in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;&quot;charprops_all()&quot; in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">上面提到的任何单个代码点的任何Unicode（不包括Perl扩展名）字符属性的值都可以通过&lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;Unicode :: UCD中的charprop（）获得&lt;/a&gt;。&lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;Unicode :: UCD中的charprops_all（）&lt;/a&gt;返回给定代码点的所有Unicode属性的值。</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">修订的价值来自于</target>
        </trans-unit>
        <trans-unit id="c5c1cdba3a8acef681606512f4cdff2bb03f5d89" translate="yes" xml:space="preserve">
          <source>The value of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7754c871491afddea48233869a135f618ec6e6a4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;...Host&lt;/code&gt; argument will be split to give both the hostname and port (or service name):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 的值提示给getaddrinfo（），或者$ flags参数提示给getnameinfo（），其中包含无法识别的标志。</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">读取的adler32字段的值必须与文件中实际包含的未压缩数据的adler32值相匹配。</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">读取的CRC32字段的值必须与gzip文件中实际包含的未压缩数据的crc32值一致。</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">读取的ISIZE字段的值必须与实际从文件中读取的未压缩数据的长度一致。</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">上位机的SV值(如果有的话),以简短的人类可读格式表示。</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">函数的值不是作为函数的返回值传回来的,而是通过改变传入函数的变量的值。当你看到round的返回值是 &quot;void &quot;类型时,你可能已经猜到了。</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">如果没有条件为真，则 &lt;code&gt;given&lt;/code&gt; 块的最后一个求值表达式的值。</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">如果碰巧有一个成功的 &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 子句，则最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="658f9d607f7e2f28f592626f4c387f2ebc102faa" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55ec6306f776bf3aa6ec09d7496286d68bd8fba" translate="yes" xml:space="preserve">
          <source>The value of this expression will be TRUE if &lt;code&gt;$var&lt;/code&gt; contains that sequence of characters, and FALSE otherwise. The portion enclosed in &lt;code&gt;'/'&lt;/code&gt; characters denotes the characteristic we are looking for. We use the term</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">可以将 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 返回的值与 &lt;code&gt;getpw*&lt;/code&gt; 函数返回的UAF的加密密码进行比较，以对用户进行身份验证。如果要执行此操作，请记住，UAF中的加密密码是使用大写的用户名和密码字符串生成的；您必须大写要 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; 的参数，以确保获得正确的值：</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">在调用之后， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 所返回的值可能会受到影响，并且文件句柄可能会被刷新。（Win32的）</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 返回的值是从1970年1月1日00:00:00起的偏移量（以秒为单位）（就像CRTL的times（）例程一样），以便使来自POSIX / Unix世界的代码更容易使用。</target>
        </trans-unit>
        <trans-unit id="d9cf508ed581e40b436f75a599821b5c9826f4e6" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;crypt&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;crypt&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fe607f9117d605b4d45bd6d7204d58d2fef28d" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;time&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">DELETE返回的值成为调用delete()的返回值。如果你想模仿delete()的正常行为,你应该返回FETCH为这个键返回的任何值。在这个例子中,我们选择返回一个值来告诉调用者文件是否被成功删除。</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">返回的值</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">返回的值</target>
        </trans-unit>
        <trans-unit id="d7686ece8175813a2cb013172fefbbbe14b8eb04" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">返回的值是新样式（请参见&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;旧样式块名称与新样式块名称&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">如果参数是标量,返回的值是标量本身;如果参数是哈希、数组或子程序,返回的值是引用。</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">返回的值应对应于要在其位置使用的新文本。如果返回空字符串或返回未定义的值，则忽略给定的 &lt;code&gt;$text&lt;/code&gt; （不处理）。</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">返回的值应该与新的文本相对应。如果返回的是空字符串或未定义的值,则不会对这一行进行进一步处理。</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">如果返回值将是真实的 &lt;code&gt;$paragraph&lt;/code&gt; ，并在同一节作为文本的其余 &lt;code&gt;$paragraph&lt;/code&gt; 应选择（含税）进行处理; 否则返回错误值。</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">该值应为代码参考。它在离开当前处理的目录之前被调用。在没有参数的空上下文中调用它。当前目录的名称在 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。该钩子可用于汇总目录，例如计算其磁盘使用情况。什么时候</target>
        </trans-unit>
        <trans-unit id="704f4eb234b60fc2ba78db6c9fbae91192095f92" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ae9d02429326a11943298c08065d301c422900" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">该值应为代码参考。该代码参考在下面的&lt;a href=&quot;#The-wanted-function&quot;&gt;&amp;ldquo;所需函数&amp;rdquo;&lt;/a&gt;中进行了描述。在 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 子程序是强制性的。</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">该值应为代码参考。此代码参考用于预处理当前目录。当前处理的目录的名称位于 &lt;code&gt;$File::Find::dir&lt;/code&gt; 。您的预处理函数在 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 之后调用，但在调用 &lt;code&gt;wanted()&lt;/code&gt; 函数的循环之前调用。它使用字符串列表（实际上是文件/目录名称）进行调用，并期望返回字符串列表。该代码可用于按字母，数字顺序对文件/目录名称进行排序，或者仅根据名称来过滤目录条目。什么时候</target>
        </trans-unit>
        <trans-unit id="f55a9d5538f4afdc7e60c610536ec48e43299b30" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. Your preprocessing function is called after &lt;code&gt;readdir()&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">该值应该是完整的TAP输出。</target>
        </trans-unit>
        <trans-unit id="1236d86898ff88a6ba5efcf381d222ec31979c55" translate="yes" xml:space="preserve">
          <source>The value stack stores individual perl scalar values as temporaries between expressions. Some perl expressions operate on entire lists; for that purpose we need to know where on the stack each list begins. This is the purpose of the mark stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Comment&lt;/code&gt; 选项提供的值可以包含除NULL之外的任何字符。</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 选项提供的值可以包含除NULL之外的任何字符。</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 选项提供的值只能包含ISO 8859-1字符和换行符。</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;Name&lt;/code&gt; 选项提供的值只能包含ISO 8859-1字符。</target>
        </trans-unit>
        <trans-unit id="250b7ab858db3f7115ff282b675a91ac8e641be6" translate="yes" xml:space="preserve">
          <source>The value(s) returned by the failed subroutine. When the subroutine was called in a list context, this will always be a reference to an array containing the results. When the subroutine was called in a scalar context, this will be the actual scalar returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">在以下格式行上以与图片字段相同的顺序指定这些值。提供值的表达式必须用逗号分隔。在处理该行之前，它们都在列表上下文中求值，因此单个列表表达式可以产生多个列表元素。如果用大括号括起来，则表达式可能会扩展到多行。如果是这样，则开括号必须是第一行上的第一个标记。如果表达式的计算结果为带小数部分的数字，并且相应的图片指定小数部分应出现在输出中（即，除多个&amp;ldquo;＃&amp;rdquo;字符外&lt;b&gt;没有&lt;/b&gt;嵌入&amp;ldquo;。&amp;rdquo;的任何图片），将使用该字符如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境，则小数点的位置由当前LC_NUMERIC语言环境确定有效。这意味着，例如，如果运行时环境碰巧指定了德语语言环境，则将使用&amp;ldquo;，&amp;rdquo;代替默认的&amp;ldquo;。&amp;rdquo;。有关更多信息，请参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;#WARNINGS&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c72d7d9a1485bc34599e1ebeb09b10805e996267" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;use locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;&quot;WARNINGS&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf008b9072b1cecb517f8aeffecd9422e5c3c63" translate="yes" xml:space="preserve">
          <source>The values of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on some of these platforms include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">在某些平台上， &lt;code&gt;$^O&lt;/code&gt; 的值包括：</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">推送到XSUB返回栈的值实际上是凡人SV。将它们变成死值是为了当值被调用程序复制后,持有返回值的SV可以被重新定位。如果它们不是死的,那么在XSUB例程返回后,它们会继续存在,但不会被访问。这就是内存泄漏。</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.sh中存储的值可以是单引号或双引号。在需要在字符串中包含转义序列的情况下，双引号字符串很方便。为避免运行时变量插值，任何 &lt;code&gt;$&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt; 字符分别用 &lt;code&gt;\$&lt;/code&gt; 和 &lt;code&gt;\@&lt;/code&gt; 代替。当然，这并不是万无一失的，因此，除非您愿意处理后果，否则不要在双引号字符串中嵌入 &lt;code&gt;\$&lt;/code&gt; 或 &lt;code&gt;\@&lt;/code&gt; 。 （斜杠将最终转义，而 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 将触发变量插值）</target>
        </trans-unit>
        <trans-unit id="2fb3e0a0c43753411747016bb8289e7cafa37f14" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt;, respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">上面的哈希值中存储的值大多直接等同于它们的C对应值。和它们的C语言对应的值一样,所有的值都被设置为一个默认值--这意味着你不需要设置</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 和 &lt;code&gt;-Comment&lt;/code&gt; 选项提供的值可以包含多个嵌入式null。写入gzip标头的字符串将包含直到但不包括第一个嵌入式NULL的字符。</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; 和 &lt;code&gt;-Comment&lt;/code&gt; 选项提供的值不能包含多个嵌入式null。</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">要比较的值总是通过引用传递的,不应该被修改。</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">变量$ REF可能称为子程序 &lt;code&gt;fred&lt;/code&gt; 每当调用 &lt;code&gt;SaveSub1&lt;/code&gt; 制成，而是由时间 &lt;code&gt;CallSavedSub1&lt;/code&gt; 现在被调用它拥有数 &lt;code&gt;47&lt;/code&gt; 。因为我们只保存一个指向原来的SV &lt;code&gt;SaveSub1&lt;/code&gt; ，至$ REF的任何更改将通过指针进行跟踪 &lt;code&gt;rememberSub&lt;/code&gt; 。这意味着只要 &lt;code&gt;CallSavedSub1&lt;/code&gt; 被调用，它会尝试执行这是由SV *所引用的代码 &lt;code&gt;rememberSub&lt;/code&gt; 。但是，在这种情况下，它现在引用整数 &lt;code&gt;47&lt;/code&gt; ，因此希望Perl大声抱怨。</target>
        </trans-unit>
        <trans-unit id="b062bdbf031860e708b29efdacf136fb5d1f0b68" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt;. Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt;, any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt;. This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt;. In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt;, so expect Perl to complain loudly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C编译器单独定义的符号。cpp或cc调用cpp时定义的符号不在这个列表中,参见cppsymbols和cppccsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C编译器调用cpp时定义的符号。单独的cc或单独的cpp定义的符号不在这个列表中,参见ccsymbols和cppsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">该变量包含C预处理器单独定义的符号。cc定义的符号或cc调用cpp时定义的符号不在这个列表中,参见ccsymbols和cppccsymbols。该列表是一个以空格分隔的符号=值标记的列表。</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">变量 &lt;code&gt;$@&lt;/code&gt; ， &lt;code&gt;$!&lt;/code&gt; ， &lt;code&gt;$^E&lt;/code&gt; 和 &lt;code&gt;$?&lt;/code&gt; 包含有关在Perl程序执行期间可能出现的不同类型错误条件的信息。按照报告错误的子系统与Perl进程之间的&amp;ldquo;距离&amp;rdquo;来按顺序显示变量。它们分别对应于Perl解释器，C库，操作系统或外部程序检测到的错误。</target>
        </trans-unit>
        <trans-unit id="b727dbcbaa890861d8b1f725dd2b28a4ab07c49e" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$^E&lt;/code&gt;, and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">变量的长度为数千个字符，您知道它们不会更改，因此您需要通过让Perl跳过测试来消耗最后一点速度。（这样做会导致维护损失，因为提到 &lt;code&gt;/o&lt;/code&gt; 意味着您不会更改模式中的变量。如果您进行更改，Perl甚至不会注意到。）</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">变量（例如 &lt;code&gt;$1&lt;/code&gt; 和 &lt;code&gt;$2&lt;/code&gt; 以及 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%&amp;ndash; &lt;/code&gt; )用于保存在模式匹配中记忆的文本。请参见骆驼第5章&amp;ldquo;模式匹配&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d984e8b7b660f5c99b516a5829ac59bafa50592e" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt;, and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt;&amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01a6309a6878656688c2b0908ac3992f68dc7d19" translate="yes" xml:space="preserve">
          <source>The variant called by &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; with the &quot;syn&quot; protocol and &lt;code&gt;$syn_forking&lt;/code&gt; enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">具有默认值的OS2 :: _ control87（）的变体适用于处理异常掩码：如果没有 &lt;code&gt;mask&lt;/code&gt; ，则仅使用 &lt;code&gt;new&lt;/code&gt; 的异常掩码部分。如果没有 &lt;code&gt;new&lt;/code&gt; ，则禁用所有浮点异常。</target>
        </trans-unit>
        <trans-unit id="949da3d76c7f29272d20c982b210c531dcfc20d4" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt;, uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt;, disables all the floating point exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">可能在跳过指定的前缀字符串之后，可以使用各种 &lt;code&gt;extract_...&lt;/code&gt; 子例程来提取分隔的子字符串。默认情况下，该前缀是可选的空格（ &lt;code&gt;/\s*/&lt;/code&gt; ），但是您可以将其更改为所需的任何空格（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="53ae99cb4c2e82006930873ef81a93aa0cb472f5" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt;), but you can change it to whatever you wish (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c592ef06c081d09dc8157d9f5c4a05ab70da35e" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt;&lt;code&gt;Win32::GetOSVersion()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">各种MSWin32 Perl可以通过 &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; 返回的列表的第五个元素的值来区分正在运行的操作系统。例如：</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">各种命名的单子运算符都是作为有一个参数的函数来处理的,可选括号。</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">可以指定的各种选项有:</target>
        </trans-unit>
        <trans-unit id="d5834701f76b16947132d9ecda0666e7fbd30f61" translate="yes" xml:space="preserve">
          <source>The various stacks have different purposes, and operate in slightly different ways. Their differences are noted below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">各种类型的数据集合形成了一个自然的层次结构,方便了继承和多态的使用。</target>
        </trans-unit>
        <trans-unit id="579f7176cc72efc4b3e6d5cd5bbca1f7407618f4" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;&quot;DBM FILTERS&quot;&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">该领域中报告的绝大多数问题归结为C字符串以NULL终止，而Perl字符串不是NULL的事实。有关解决此问题的一般方法，请参见&lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">绝大多数代码由Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; ，Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; ，AndreasK&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; ，Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; 。 Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; 提供的 VMS支持。 Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; 的 OS / 2支持。 Paul &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; 和Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; 支持Mac 。由Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; 编写的abs2rel（）和rel2abs（），由Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; 修改。Barrie Slaymaker编写的splitpath（），splitdir（），catpath（）和catdir（）。</target>
        </trans-unit>
        <trans-unit id="78e57f945db726a29f3a1812670cc08732e95ca3" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt;, Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt;, Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt;. Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt;, and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt;. abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt;, modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt;. splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c837eb7150f7389b8a819378e52b179af4ab77" translate="yes" xml:space="preserve">
          <source>The vec() function may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that, and starting in Perl 5.28, a deprecation message is issued if you do so, becoming illegal in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">抽象的面纱将&lt;b&gt;接口&lt;/b&gt;与&lt;b&gt;实现&lt;/b&gt;（无论是否实施）分开，它要求对&lt;b&gt;对象&lt;/b&gt;状态的所有访问都只能通过&lt;b&gt;方法进行&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="9b9ecb3d60d103c7f5665f456eda4698f957144a" translate="yes" xml:space="preserve">
          <source>The verify method always returns true ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">XS模块的版本标识符。这通常由 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 自动处理。参见 &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7557d13ad6548a59235452a6893c4504ed7e5952" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13051932ac793eddfcf7780ddfecbd50a22ea0e" translate="yes" xml:space="preserve">
          <source>The version is essentially an arbitrary string, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">已安装模块的版本号- 如果模块没有（或无法解析）版本号，或者变量 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; 设置为true ，则此版本号为 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（有关详细信息，请参见下面的&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 部分）</target>
        </trans-unit>
        <trans-unit id="881eef9e03334c572492df3693b2b9db2367c722" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;undef&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df3b2ff1998ec5ce67afe0561e7a92741c1659e" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 2003 and Windows Home Server are identical; the SUITEMASK field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0209883e46d2f3d87480f57905626dfd8d2e876" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 7 and Windows Server 2008 R2 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3168417cf9b56ff32b762909d40ba25ab0407e1" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 8 and Windows Server 2012 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7672ecea9c16e88589676b7a7fa4e019bcc4830" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows Vista and Windows Server 2008 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">PA-RISC在本文档最后一次更新时的版本是2.0,这也是最后一次更新。HP PA-RISC系统通常用型号说明 &quot;HP 9000 &quot;来表示。这个系列的最后一款CPU是PA-8900。对PA-RISC架构机器的支持正式结束,如下表所示。</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">在VMS下执行的ext()版本与Unix-OS/2版本在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">在Win32下执行的ext()版本与Unix-OS/2版本在几个方面有所不同。</target>
        </trans-unit>
        <trans-unit id="eea453196c9ecc4c3ad7040390519b5e41971ecc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;&quot;isvstring&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">您使用的perl版本未实现Vstrings，要使用&lt;a href=&quot;#isvstring&quot;&gt;isvstring，&lt;/a&gt;您将需要使用更新版本的perl。</target>
        </trans-unit>
        <trans-unit id="decdd9bf0416592f2797901080148ed0ab06c7cc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">您使用的perl版本不会实现弱引用，要使用&lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt;或&lt;a href=&quot;#weaken&quot;&gt;弱化，&lt;/a&gt;您将需要使用更新版本的perl。</target>
        </trans-unit>
        <trans-unit id="93c33ec188f162276af3a60f34074e13ed0b75fe" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68f5af181947e373672838e7416d0d6d5457c72" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers. This is a mandatory field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">与Perl一起发布的模块版本,应尽可能是作者发布的模块的最新版本(如果是公开的Perl版本,则是最新的非beta版本),不过,南瓜的持有者可以暂缓将与Perl一起发布的模块版本升级到最新版本,直到最新版本经过充分的测试。</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Perl核心中的模块版本仍然应该被认为是原作者的作品。所有的补丁、错误报告等等都应该反馈给他们。他们的开发方向应尽可能得到尊重。</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">该模块需要的版本 ----这是可选的。</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Solaris 提供的 as 和 ld 版本可以很好地用于编译 perl。通常不需要安装GNU版本来编译perl。</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">文件的最后。</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">你应该做的第一件事就是研究从CPAN中获取Term::ReadKey扩展。正如我们前面提到的,它现在甚至对非可移植系统(读作:非开放系统、封闭的、专有的、非POSIX、非Unix等)系统有有限的支持。</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">卷的部分总是以尾部的&quot;:&quot;来返回。目录部分总是以一个前导(表示相对路径)和一个尾部的&quot;:&quot;(表示目录)返回。文件的部分总是以前面的&quot;:&quot;和后面的&quot;:&quot;(表示一个目录)返回。</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">想要的功能</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">想要的函数不接受参数,而是通过变量集合来完成工作。</target>
        </trans-unit>
        <trans-unit id="20d73a1883be618af881251a4f69445af19dc1a9" translate="yes" xml:space="preserve">
          <source>The warning category (or categories) packed into a &lt;code&gt;SVuv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">该警告被认为足够严重，不会受到&lt;b&gt;-w&lt;/b&gt;开关的影响（或其缺失），因为以前编译的函数调用仍将使用该函数的旧值。如果需要能够重新定义该子例程，则需要通过删除 &lt;code&gt;()&lt;/code&gt; 原型（更改调用语义，因此要当心）或通过以其他方式阻止该内联机制的方式，确保不对它进行内联。通过添加显式 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ，如上所述：</target>
        </trans-unit>
        <trans-unit id="dad69db2f27b61d28a567c57b099e70158211293" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;return&lt;/code&gt;, as mentioned above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">我看到的使用方式基本上是这样的。</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">Perl在解析过程中建立这些运算树的方式,可以通过检查一下</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Test::More 处理这个问题的方式是使用命名块。基本上,一个测试块可以被跳过或成为todo。最好的办法是我向你展示......</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">程序对错误的响应方式。Perl中的异常处理机制是 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="485d9ec05d9e7ee1509acc95cd728f99a6dde4db" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;eval&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">它解决实际调用哪个方法的方式是。</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">它的工作方式是，在双引号字符串中看到 &lt;code&gt;@{...}&lt;/code&gt; ，它将被视为一个块。该块创建对匿名数组的引用，该数组包含对 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; 的调用结果。因此，整个块将返回对数组的引用，然后使用 &lt;code&gt;@{...}&lt;/code&gt; 将其取消引用并粘贴到双引号字符串中。此chicanery还可用于任意表达式：</target>
        </trans-unit>
        <trans-unit id="22373b22c059855720b294750ec63ef1e1b487f7" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt;. So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">此技巧的工作方式是，不应认为代码点为 &lt;code&gt;U+FFFE&lt;/code&gt; 的字符在输入流中，因此字节序列 &lt;code&gt;0xFF 0xFE&lt;/code&gt; 明确为&amp;ldquo; &lt;code&gt;BOM&lt;/code&gt; ，以小尾数格式表示&amp;rdquo;并且不能为 &lt;code&gt;U+FFFE&lt;/code&gt; ，以big-endian格式表示&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="03d93acd73703280d7e5deb9019540799404d722" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt;, represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt;, represented in big-endian format&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f55c636a9c9c26eb587e152e4c24ce7d11dc1f3" translate="yes" xml:space="preserve">
          <source>The way this works under-the-hood is that every thread has a choice of using a locale specific to it (this is the Windows and POSIX 2008 functionality), or the global locale that is accessible to all threads (this is the functionality that has always been there). The implementations for Windows and POSIX are completely different. On Windows, the runtime can be set up so that the standard &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function either only knows about the global locale or the locale for this thread. On POSIX, &lt;code&gt;setlocale&lt;/code&gt; always deals with the global locale, and other functions have been created to handle per-thread locales. Perl makes this transparent to perl-space code. It continues to use &lt;code&gt;POSIX::setlocale()&lt;/code&gt;, and the interpreter translates that into the per-thread functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">解决此问题的方法是使用称为 &lt;code&gt;seq&lt;/code&gt; 的Berkeley DB API方法。此方法允许顺序访问键/值对。有关 &lt;code&gt;seq&lt;/code&gt; 方法和一般&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;API&lt;/a&gt;的详细信息，请参见API接口。</target>
        </trans-unit>
        <trans-unit id="365d9cd3356a85ac2e3ab542f36bc2743ee69357" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt;. This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">使用此类的方法是创建该类的新对象，设置任何选项，然后调用搜索选项之一（可能是 &lt;code&gt;survey&lt;/code&gt; 或 &lt;code&gt;find&lt;/code&gt; ）。以下各节讨论了执行所有操作的语法。</target>
        </trans-unit>
        <trans-unit id="70dcc819697307fd63c00ab11c88076b157ec890" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt;). The sections below discuss the syntaxes for doing all that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">假定处理HTTP服务的Web服务器位于其标准端口80上。如果您要连接的服务器位于其他端口（例如1080或8080），则应将其指定为&amp;ldquo;命名参数对&amp;rdquo; ， &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 。该 &lt;code&gt;autoflush&lt;/code&gt; 方法用于在插座上，因为否则系统缓存起来，我们送了它的输出。（如果您使用的是史前Mac，则还需要将代码中通过网络发送数据的每个 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 更改为 &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c2c0fa4dc9353a78eef2a13048e071f4e11d6efd" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt;. The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">众所周知的Unicode字节序号如下:如果文件以两个文字字节值0xFE 0xFF开始,这就是大字段UTF-16的BOM,如果文件以两个文字字节值0xFF 0xFE开始,这就是小字段UTF-16的BOM。如果文件以两个字面字节值0xFF 0xFE开始,这就是小字面UTF-16的BOM。在ASCII平台上,如果文件以三个文字字节值0xEF 0xBB 0xBF开始,这就是UTF-8的BOM。一个可移植到EBCDIC平台的机制是:。</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">从第14行到第26行的while循环从输入队列中抓取一个标量,并根据这个线程负责的质数进行检查。第15行检查当我们用质数除以要检查的数字时是否有余数。如果有余数,那么这个数字一定不能被我们的质数平均分割,所以我们需要把它传递给下一个线程,如果我们已经创建了一个线程(第17行),或者创建一个新的线程,如果我们没有创建。</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">整个Unicode标准&lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">&amp;ldquo;用于启动应用程序的标准C API&amp;rdquo;的整个思想是程序参数的形式 &lt;code&gt;foo&lt;/code&gt; 和 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 是完全可互换的。</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">解释两位数年份的整个方案可以说是一个bug。</target>
        </trans-unit>
        <trans-unit id="06823ddcb564d7e0125b4ed62adb0242c15ff840" translate="yes" xml:space="preserve">
          <source>The wide character is not used in the &lt;code&gt;&amp;amp;&lt;/code&gt; operation because the left operand is shorter. This now throws an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5992a1d1d14f7a847e98f6f7210198b195d54e7" translate="yes" xml:space="preserve">
          <source>The wide-character-specific (Unicode) functions. Each of these is just the same as the version without the trailing &quot;W&quot; except that strings are expected in Unicode and some lengths are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s instead of number of bytes, as indicated below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">空格中左边距的宽度。默认值为0。这是所有文本（包括标题）的边距，而不是常规文本缩进的量；对于后者，请参见&lt;b&gt;-i&lt;/b&gt;选项。</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">左边距的宽度,以空格为单位,默认为0。默认值为0,这是所有文本的页边距,包括标题,而不是常规文本的缩进量;关于后者,请参见本手册中的</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 函数将其应用于子例程的引用时返回的单词。另请参阅&lt;b&gt;CV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="6d42ff99a16e8f67b82856c6d2b84806cf10fd36" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;ref&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">文书工作完成之前，工作还没有结束，您将需要花一些时间为模块编写一些文档。 &lt;code&gt;module-starter&lt;/code&gt; 或 &lt;code&gt;h2xs&lt;/code&gt; 将提供一个存根供您填写；如果您不确定格式，请查看&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;进行介绍。提供有关如何在代码中使用模块的简要说明，说明，然后说明各个子例程或方法的语法和功能。将Perl注释用于开发人员注释，将POD用于最终用户注释。</target>
        </trans-unit>
        <trans-unit id="a31887edd2b89b26426a7d0c030500f19faef476" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;&quot;Compiled code&quot; in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">解释器的工作分为两个主要阶段：将代码编译成内部表示形式或字节码，然后执行它。&lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlguts中的编译代码&lt;/a&gt;准确地解释了编译阶段是如何发生的。</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">世界上的语言是用许多不同的文字书写的。这句话(除非你读的是翻译)是用拉丁文写的,而俄语是用西里尔文写的,希腊文是用,嗯,希腊语写的;日语主要是用平假名或片假名。还有很多。</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">最糟糕的补丁利用了系统特有的功能。在Perl语言中添加不可移植的功能是不太可能被接受的。</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">写入文件柄将开启自动刷新功能。</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">BS2000 POSIX自带的yacc对我们不起作用。所以我们不得不使用 bison。我们不得不对perl做了一些修改,以便使用bison的纯(reentrant)解析器。我们使用的是1.25版本,但由于EBCDIC的原因,我们不得不增加了一些改动。关于yacc的更多细节请看下文。</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">z / OS Unix工具和玩具列表可能会有所帮助，并且包含指向许多有助于构建Perl的软件端口的链接。&lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26c38255249743d87d50270df89b2a9ebd2b4fd7" translate="yes" xml:space="preserve">
          <source>The zhuyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightZhuyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">然后 &lt;code&gt;$reg&lt;/code&gt; 可以用作正则表达式：</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">不过,你也可以一直用括号。</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">然后出现了Unicode,它有超过一百万个字符的空间(Perl允许更多的字符)。这意味着一个字符可能需要超过一个字节来表示它,因此这两个术语不再是等价的。重要的是作为整体实体的字符,而不是通常由它们组成的字节。这就是本节标题中 &quot;字符语义 &quot;一词的含义。</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">然后编译。</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">然后将setargv.obj复制到%PlatformSDKDir%/lib。</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">然后删除文件夹中任何地方发现的所有.bundle文件。</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">然后继续声明并在函数中使用您的变量而没有任何限制。有关模块创建中的机制和样式问题的详细信息，请参见&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;和&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0260e987a9bcfe5e51c92652bad4a0b41e5cc334" translate="yes" xml:space="preserve">
          <source>Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27efe9215ba97f3d69be224566771bce0e52d95d" translate="yes" xml:space="preserve">
          <source>Then make your changes. For example, if Leon Brocard changes his name to Orange Brocard, we should change his name in the AUTHORS file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">然后移动文件(可能只是</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">然后在子类中重写 &lt;code&gt;start_for&lt;/code&gt; 方法，以检查&amp;ldquo; $ flags- &amp;gt; {'target'}&amp;rdquo;何时等于&amp;ldquo; foo&amp;rdquo;，并设置一个标志，以标记您在foo块中（也许是&amp;ldquo; $ self-&amp;gt; {'in_foo'} = 1&amp;ldquo;）。然后重写 &lt;code&gt;handle_text&lt;/code&gt; 方法以检查标志，然后将$ text传递给您的自定义子例程以构造'foo'元素的HTML输出，如下所示：</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">然后运行以下脚本(或类似的脚本)。</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">然后，该文本以及所有直到并包括以 &lt;code&gt;=cut&lt;/code&gt; 开头的行的所有剩余文本将被忽略。插入文本的格式在&lt;a href=&quot;perlpod&quot;&gt;perlpod中进行了&lt;/a&gt;描述。</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">然后,左手边带有间接性的赋值将使用已有的引用。</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">然后,处理程序完全不试图解释它所收到的数据,而只是将其作为一个字符串传递。</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">然后执行匹配,余下的行文描述过程。</target>
        </trans-unit>
        <trans-unit id="41718c26f8da915843d6b183e2c76ef5e3a2e26d" translate="yes" xml:space="preserve">
          <source>Then to use it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">然后像使用普通文件句柄一样使用其中任何一个。Perl期望文件句柄的任何地方，都可以使用间接文件句柄代替。间接文件句柄只是包含文件句柄的标量变量。诸如 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond运算符之类的函数将接受命名的文件句柄或包含一个的标量变量：</target>
        </trans-unit>
        <trans-unit id="1cf2cb2bbe0265bf12a87e03d2ba1a967297063a" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">然后像这样使用。</target>
        </trans-unit>
        <trans-unit id="ac583abd9dd0b62af4de435d7d5497c2d6ffcb6a" translate="yes" xml:space="preserve">
          <source>Then we have to give each character a unique ID so your computer can tell the difference between 'a' and 'A'. This itemized character repertoire is now a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">然后当您调用$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="ef2df7391bceda4d0a67009f959c0d587bbf6bd2" translate="yes" xml:space="preserve">
          <source>Then you can merge it into master like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">然后,你可以通过0x2000-0x204D范围内的任何剩余的著名Unicode字符(参考www.unicode.org),以及其他任何你喜欢的字符。例如,在</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">然后，可以将 &lt;code&gt;FH&lt;/code&gt; 用作文件句柄，并以 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 和 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; &lt;a href=&quot;close&quot;&gt;关闭&lt;/a&gt;。请注意，这是一个全局变量，因此在新代码中不建议使用此形式。</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">然后，可以将 &lt;code&gt;FH&lt;/code&gt; 用作文件句柄，并以 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; 和 &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; &lt;a href=&quot;functions/close&quot;&gt;关闭&lt;/a&gt;。请注意，这是一个全局变量，因此在新代码中不建议使用此形式。</target>
        </trans-unit>
        <trans-unit id="8845af43a427cd30379b447f56ac8ef63aa6a453" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;close FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended when dealing with filehandles other than Perl's built-in ones (e.g. STDOUT and STDIN).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">然后，您将需要知道如何操作Perl堆栈。这在&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;中有所描述。</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">然后，您需要传递 &lt;code&gt;nocase&lt;/code&gt; 选项以识别&amp;ldquo;名称&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">然后，您只需在其参数前面提供一个自动 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; ，这可能会有点令人惊讶。过去用来保存一件事的 &lt;code&gt;@foo&lt;/code&gt; 不会传递。相反， &lt;code&gt;func()&lt;/code&gt; 现在传递为 &lt;code&gt;1&lt;/code&gt; ；即 &lt;code&gt;@foo&lt;/code&gt; 中的元素数。并且 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 在标量上下文中被调用，因此它开始在您的 &lt;code&gt;@_&lt;/code&gt; 参数列表上进行书写。哎哟!</target>
        </trans-unit>
        <trans-unit id="b0ba92bfa9d677231987d2b57b0a01cd1852383d" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;scalar&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt;; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt;. And the &lt;code&gt;m//g&lt;/code&gt; gets called in scalar context so instead of a list of words it returns a boolean result and advances &lt;code&gt;pos($text)&lt;/code&gt;. Ouch!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2223d4e367bda9f7a187be5ce1bdedd21df546" translate="yes" xml:space="preserve">
          <source>Then your Russian translator calls on the phone, to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">然后,它确定它被调用的上下文的类和方法名。</target>
        </trans-unit>
        <trans-unit id="6c23388be94a600da1203bed601e75b409a6b29f" translate="yes" xml:space="preserve">
          <source>Then, push your new branch to your fork.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bc01ce529788e374ab9bf2dcdef9e77b7d91a8" translate="yes" xml:space="preserve">
          <source>There (probably) should be a semicolon at the end of the opening token</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">在BS2000 POSIX系统上的浮点数实现中似乎存在一个错误,即对一个数和一个小数的乘积调用int()与对这个数和一个大数的商调用int()是不一样的。例如,在下面的Perl代码中。</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">在S/390系统上,浮点运算的实现似乎存在一个错误,即对一个数和一个小数的乘积调用int()和对该数和一个大数的商调用int()是不一样的。例如,在下面的Perl代码中。</target>
        </trans-unit>
        <trans-unit id="4eb2187ac5dc9a4b6af234beb08ab0fae2350bcf" translate="yes" xml:space="preserve">
          <source>There are 2 types of hooks, init hooks, and release hooks. As the names suggest, these hooks are triggered when contexts are created or released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">有3种项目可以被填充;特殊模式、#vars和逐字复制的文字。是的,这是一套s//g步骤)。</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">Makefile中有 &lt;code&gt;lint&lt;/code&gt; 和&amp;lt;splint&amp;gt;目标，但是您可能不得不使用标志（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">有DECC特征逻辑名和ODS-5卷属性也控制着日期字段的返回值。</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">上述规则有几个例外。 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; 始终被解释为Unicode代码点，因此即使在EBCDIC平台上， &lt;code&gt;\N{U+0050}&lt;/code&gt; 也是 &lt;code&gt;&quot;P&quot;&lt;/code&gt; 。并且如果 &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; 有效，则认为该数字是该编码中的数字，并且如果存在相应的本机字符，则将其从数字转换为平台的本机编码；否则为Unicode。</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">XS模块中有两个宏可以执行非常基本的异常处理。您必须先定义 &lt;code&gt;NO_XSLOCKS&lt;/code&gt; ,然后再包括</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">还有一些其他的符号,你可能会遇到,但这些符号并不是真正的类型指定符。</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">还有一些特殊的数组，例如 &lt;code&gt;@ARGV&lt;/code&gt; （脚本的命令行参数）和 &lt;code&gt;@_&lt;/code&gt; （传递给子例程的参数）。这些在&lt;a href=&quot;perlvar&quot;&gt;perlvar中&lt;/a&gt;有记录。</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">关于此分析，有两点需要注意。首先，第二组&amp;ldquo; de&amp;rdquo;中的第三个备选方案也允许进行比赛，但我们在达到目标之前就停了下来-在给定角色位置，最左边的胜利。其次，我们能够在字符串&amp;ldquo; a&amp;rdquo;的第一个字符位置获得匹配项。如果在第一个位置没有匹配，Perl将移动到第二个字符位置&amp;ldquo; b&amp;rdquo;，然后再次尝试匹配。只有在用尽所有可能的字符位置的所有可能路径时，Perl才会放弃并声明 &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; 是假的。</target>
        </trans-unit>
        <trans-unit id="deb5e7398add69ec1651990d98a23a3300e8eb2d" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group &lt;code&gt;'de'&lt;/code&gt; also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string &lt;code&gt;'a'&lt;/code&gt;. If there were no matches at the first position, Perl would move to the second character position &lt;code&gt;'b'&lt;/code&gt; and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">有几种方法可以处理整个哈希。你可以得到一个键的列表,然后通过每个键,或者一次抓取一个键值对。</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">有几个基本原则定义了面向对象的Perl。</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">有几个例外，但： &lt;code&gt;x&lt;/code&gt; 可以是字符串重复或列表重复，这取决于左操作数的类型， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 可以是字符串或数字位操作。</target>
        </trans-unit>
        <trans-unit id="90c71cfbe20f7e4576d0df45674b3d041e6521fa" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">关于匹配运算符，您可能还需要了解几件事。全局修饰符 &lt;code&gt;//g&lt;/code&gt; 允许匹配的运算符在一个字符串内尽可能多地匹配。在标量上下文中，与字符串的连续匹配将在匹配之间跳转 &lt;code&gt;//g&lt;/code&gt; ，从而跟踪字符串在字符串中的位置。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 函数获取或设置位置。例如，</target>
        </trans-unit>
        <trans-unit id="21076df5229fe033ea741a2399501b4983daa45a" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;/g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">如果你想改变BTREE数据库的排序,有几点需要记住。</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">创建自己的 &lt;code&gt;ResultFactory&lt;/code&gt; 时，需要牢记一些注意事项：</target>
        </trans-unit>
        <trans-unit id="de8a54b9295025b3c139573926386493cb554215" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">不过,有几件事你需要知道。</target>
        </trans-unit>
        <trans-unit id="52b3f437a68cd4b70bf1c33277b0b324dc172b8a" translate="yes" xml:space="preserve">
          <source>There are a handful of cases where a tool author may want to create a new context by hand, which is why the &lt;code&gt;new&lt;/code&gt; method exists. Unless you really know what you are doing you should avoid this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291c6f1e95cd386fbf1435fa808c577724438440" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPAN上有很多模块，很容易错过与您计划贡献的模块相似的模块。仔细浏览&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;并确保您不是重塑方向盘的人！</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">有许多&amp;ldquo;魔术&amp;rdquo;标量，其名称看起来像标点符号或行噪声。这些特殊变量用于各种目的，并在&lt;a href=&quot;perlvar&quot;&gt;perlvar中进行了说明&lt;/a&gt;。您现在唯一需要了解的就是 &lt;code&gt;$_&lt;/code&gt; ，它是&amp;ldquo;默认变量&amp;rdquo;。它在Perl中用作许多函数的默认参数，并且由某些循环构造隐式设置。</target>
        </trans-unit>
        <trans-unit id="bbba855a854345636dbf0d940dc495c0ac9b2bb4" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match a sequence of multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt;. Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 下有许多与多个字符匹配的Unicode字符。例如， &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; 应该匹配序列 &lt;code&gt;fi&lt;/code&gt; 。当多个字符位于模式中并且在分组之间划分时，或者对一个或多个进行量化时，Perl当前无法执行此操作。从而</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">有一些逃生序列和字符类,我们还没有介绍。</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">有一些标志可以在正则表达式构造的末尾找到,它们是</target>
        </trans-unit>
        <trans-unit id="9c8583e91f1bbf24b33308cfc971070d355cbca1" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;&quot;i&quot;&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">关于Unicode规则中不区分大小写的匹配，存在许多问题。请参阅上面的&lt;a href=&quot;#Modifiers&quot;&gt;修饰符&lt;/a&gt;下的 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">您可以在 NDBM 文件中存储的数据的大小有一些限制,最重要的是一个密钥的长度加上相关值的长度不能超过 1008 字节。最重要的是,一个密钥的长度,加上其相关值的长度,不得超过1008字节。</target>
        </trans-unit>
        <trans-unit id="98194cdd08210646c306ab64213d7decc3e2f871" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the ODBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">在SDBM文件中可以存储的数据大小有一些限制,最重要的是一个密钥的长度加上相关值的长度不能超过1008字节。最重要的是,一个密钥的长度,加上其相关值的长度,不得超过1008字节。</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">有很多模块可以让你用Perl编写GUI。大多数GUI工具包都有一个perl接口:下面是一个不完整的列表。</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">这里介绍了一些新的概念,下面介绍一下。</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; 选项还有许多其他限制：</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">您可能出于多种原因而偏爱 &lt;code&gt;Tie::File&lt;/code&gt; 。可以从 &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; 获得列表。</target>
        </trans-unit>
        <trans-unit id="13eb2afa7bef68b0d1a21f81cf96c931809f02f6" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt;. A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">完整的Unicode字符列表存在许多安全问题。参见&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">有很多方法可以解决此类问题。最好的方法是始终让所有线程都以完全相同的顺序获取锁。如果，例如，你锁定变量 &lt;code&gt;$x&lt;/code&gt; ， &lt;code&gt;$y&lt;/code&gt; ，和 &lt;code&gt;$z&lt;/code&gt; ，始终锁定 &lt;code&gt;$x&lt;/code&gt; 之前 &lt;code&gt;$y&lt;/code&gt; ，和 &lt;code&gt;$y&lt;/code&gt; 前 &lt;code&gt;$z&lt;/code&gt; 。最好也将锁保持较短的时间，以最大程度地降低死锁的风险。</target>
        </trans-unit>
        <trans-unit id="cb7bd877fbaa099a03520b258b73c60485273da7" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt;, &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$z&lt;/code&gt;, always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt;. It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">有很多方法可以隐藏Perl程序的源码,其 &quot;安全 &quot;程度各不相同。</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">有很多方法，效率各不相同。如果要对字符串中的某个单个字符（X）进行计数，则可以使用 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 函数，如下所示：</target>
        </trans-unit>
        <trans-unit id="b49ba886c3971e0e735660e0bc77176d9460c20e" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;tr///&lt;/code&gt; function like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">有一组实用工具可以帮助你开发Perl程序,特别是用C语言扩展Perl。</target>
        </trans-unit>
        <trans-unit id="38b993b6e04cfcdc788f4b122babf509e8a292ac" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22 and 5.24. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22附带的CPAN模块中有大量测试失败。这些仅在不是主要由Perl 5 porter维护的模块中。其中一些只是测试失败：他们没有意识到在EBCDIC平台上获得不同的结果是适当的。有些失败是真正的错误。如果您在Perl上编译并进行 &lt;code&gt;make test&lt;/code&gt; ，则 &lt;code&gt;/cpan&lt;/code&gt; 目录上的所有测试都将被跳过。</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">用字符集内映射来转换数据的方法有很多种,可以达到各种目的。上一节讨论了排序,下一节将讨论其他几种比较流行的映射技术。</target>
        </trans-unit>
        <trans-unit id="263ac344d4080439af54082913373a451c912861" translate="yes" xml:space="preserve">
          <source>There are actually two distinct kinds of version objects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">实际上，空字符串有两种（有时称为&amp;ldquo;空&amp;rdquo;字符串），一种是已定义的，另一种是未定义的。定义的版本只是一个长度为零的字符串，例如 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。未定义版本是表示某物没有实际值的值，例如发生错误时，文件末尾或引用未初始化的变量或数组或哈希元素时。尽管在Perl的早期版本中，当在需要定义值的地方首次使用时，可能会定义未定义的标量，但这种情况不再发生，除非如perlref中所述的&lt;a href=&quot;perlref&quot;&gt;极少数自动生存的情况&lt;/a&gt;。您可以使用define（）运算符来确定是否定义了标量值（这对数组或哈希值没有意义），可以使用undef（）运算符来生成未定义的值。</target>
        </trans-unit>
        <trans-unit id="fe88dd9a713bfccf6064f23560d8e8bd2b27790f" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt;. The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">还有一些其他宏，这些宏的值可以与 &lt;code&gt;GV_ADD&lt;/code&gt; 参数进行按位或运算以启用某些其他功能。这些位是：</target>
        </trans-unit>
        <trans-unit id="7a746509c86dffe25d4594a4b2c6a264d173eb5e" translate="yes" xml:space="preserve">
          <source>There are additional methods for regular expression patterns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">还有 &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; 和 &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; 尝试使用 &lt;code&gt;perldoc Win32&lt;/code&gt; ，从libwin32 0.19开始（不是核心Perl发行版的一部分） &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 。便携式 &lt;code&gt;POSIX::uname()&lt;/code&gt; 也可以使用：</target>
        </trans-unit>
        <trans-unit id="a575561f3064d05553d9a3fbf390d2ed1e96d270" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt;, &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt;, and &lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt;&lt;code&gt;Win32::GetOSName()&lt;/code&gt;&lt;/a&gt;; try &lt;a href=&quot;win32&quot;&gt;&lt;code&gt;perldoc Win32&lt;/code&gt;&lt;/a&gt;. The very portable &lt;a href=&quot;posix#uname&quot;&gt;&lt;code&gt;POSIX::uname()&lt;/code&gt;&lt;/a&gt; will work too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e848855fa991c061ba1b0f19b935d8e48a52c00" translate="yes" xml:space="preserve">
          <source>There are also a variety of other special-purpose macros which save particular types or values of interest. &lt;code&gt;SAVETMPS&lt;/code&gt; has already been mentioned above. Others include &lt;code&gt;SAVEFREEPV&lt;/code&gt; which arranges for a PV (i.e. a string buffer) to be freed, or &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; which arranges for a given function pointer to be invoked on scope exit. A full list of such macros can be found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23127dab9bc88fbefc66139b670c575d072a34d4" translate="yes" xml:space="preserve">
          <source>There are also certain operations that are illegal. You can't nest &lt;code&gt;\p{...}&lt;/code&gt; and &lt;code&gt;\P{...}&lt;/code&gt; calls within a wildcard subpattern, and &lt;code&gt;\G&lt;/code&gt; doesn't make sense, so is also prohibited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">也有无限的可能性来使用</target>
        </trans-unit>
        <trans-unit id="d8a2e4b90dc5ccc934f88be56fb54a760d42a1e5" translate="yes" xml:space="preserve">
          <source>There are also layers which actually just set flags on lower layers, or layers that modify the current stack but don't persist on the stack themselves; these are referred to as pseudo-layers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">在 &lt;code&gt;comp.lang.perl.*&lt;/code&gt; 下还有很多与Perl相关的新闻组。</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">还有一些商业产品可能对你有用,尽管你必须购买它们的许可证。</target>
        </trans-unit>
        <trans-unit id="8875c64205867a602cf00ce82127ede7aefa737d" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">还有一些用于该任务的常用模块。&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;（随5.8一起分发）提供对perl内部函数 &lt;code&gt;looks_like_number&lt;/code&gt; 的访问，以确定变量是否看起来像数字。&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt;导出使用上述正则表达式和其他正则表达式验证数据类型的函数。第三，&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;具有正则表达式以匹配各种类型的数字。这三个模块可从CPAN获得。</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">还有其他一些op类型： &lt;code&gt;PMOP&lt;/code&gt; 包含一个正则表达式，并且没有子代，而 &lt;code&gt;LOOP&lt;/code&gt; 可能有也可能没有子代。如果 &lt;code&gt;op_children&lt;/code&gt; 字段不为零，则其行为类似于 &lt;code&gt;LISTOP&lt;/code&gt; 。使问题复杂化的是，如果优化后 &lt;code&gt;UNOP&lt;/code&gt; 实际上是一个 &lt;code&gt;null&lt;/code&gt; 操作（请参阅&lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;编译阶段2：上下文传播&lt;/a&gt;），则它仍将具有其先前类型的子代。</target>
        </trans-unit>
        <trans-unit id="11f74fbe23dd4e59c95a6d0f147c6383a5a62308" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt;. To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;&quot;Compile pass 2: context propagation&quot;&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 和累加器变量 &lt;code&gt;$^A&lt;/code&gt; 玩一些技巧，但是由于 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 无法处理分页等原因，您会损失很多格式值。使用它们时，最终会重新实现格式。</target>
        </trans-unit>
        <trans-unit id="4d45adb6b43e1a59ad871510a945d0116f3df08b" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;formline&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt;, but you lose a lot of the value of formats since &lt;code&gt;formline&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">还有两个值 &lt;code&gt;PL_sv_yes&lt;/code&gt; 和 &lt;code&gt;PL_sv_no&lt;/code&gt; ，分别包含布尔值TRUE和FALSE。像 &lt;code&gt;PL_sv_undef&lt;/code&gt; 一样，只要需要 &lt;code&gt;SV*&lt;/code&gt; ，就可以使用它们的地址。</target>
        </trans-unit>
        <trans-unit id="bada6ac2c7944b1149547067859a10dc227a309f" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt;, which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt;, their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">还有一些版本的函数在名称后附加&quot;_hex &quot;或&quot;_base64&quot;,以指定的形式返回摘要。</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">在哈希引用中至少存储了两个实例变量,{数据}和{编码}。</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">在某些情况下,你不会事先知道你的脚本要运行多少测试,在这种情况下,你可以在最后声明你的测试。在这种情况下,你可以在最后声明你的测试。</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">在某些应用领域,CPAN已经提供了非常、非常好的服务。一个例子是模板系统,另一个是日期和时间模块,还有很多。虽然写出自己版本的这些东西是一种仪式,但请仔细考虑Perl世界是否真的需要你来发布它。</target>
        </trans-unit>
        <trans-unit id="6418df0a423a65fdef15c0f2ab1cbad9a1e3cda6" translate="yes" xml:space="preserve">
          <source>There are certain properties that wildcard subpatterns don't currently work with. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">四个类别中的每个类别都有对应的单字母命令 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ，另一个类别中的 &lt;code&gt;i&lt;/code&gt; 对应一个字母命令。四个实体中的每一个都被实现为一个类，其显示对象的方法略有不同。</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">目前有三种实施方式。</target>
        </trans-unit>
        <trans-unit id="97e0702d9f24205eb392b550bdee3cc7f1886fbc" translate="yes" xml:space="preserve">
          <source>There are currently two implementations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1fef3dafc65f2dd5f6f03815febb7cc02429e1" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;命名空间中有不同的类，用于支持各种邮箱类型。请注意，这些模块通常相当有限，仅支持&lt;b&gt;阅读&lt;/b&gt;而不是写作。</target>
        </trans-unit>
        <trans-unit id="7ffae46f4361bbc29cee623ab319bb8483adbbdb" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">上面提到的用于解除引用操作的规则（如果步骤1失败，将始终退回到常规的内置实现-请参阅&amp;ldquo;解除引用&amp;rdquo;），对于 &lt;code&gt;~~&lt;/code&gt; （具有自己的规则集-请参见&amp;ldquo; &lt;code&gt;Matching&lt;/code&gt; 下的规则）有例外。以上的可&lt;a href=&quot;#Overloadable-Operations&quot;&gt;重载操作&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">简单标量映射有一些例外。一些属性的映射列表中包含一些元素，这些元素本身就是标量列表。并返回一些不按原样解释的特殊字符串。返回的四个元素列表的元素[2]（在上面的示例中放入 &lt;code&gt;$format&lt;/code&gt; 中）告诉您地图是否具有以下任何特殊元素，如下所示：</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">除了模式和待检查的源之间严格的一对一匹配外,还有五种模式匹配操作。</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">有四个论点。</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">有四种方法与DBM过滤器有关。所有方法的工作原理都是一样的,每个方法都用来安装(或卸载)一个DBM过滤器。每种方法都需要一个参数,即一个子的引用。它们之间唯一的区别是过滤器被安装的位置。</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">有四个例程可以用来从C程序中调用Perl子程序。这四个例程是:</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">参考的方法只有两种,有了参考后的使用方法也只有两种。</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">除了这里介绍的模块外,CPAN上还有几十个与OO相关的模块,如果你使用别人的代码,你很可能会遇到其中的一个或多个。</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">还有更多的命令和选项,但以上就可以了。</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">有许多关于各种主题的Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;邮件列表&lt;/a&gt;，尤其是&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;初学者列表&lt;/a&gt;可能有用。</target>
        </trans-unit>
        <trans-unit id="c100a4e2353b8e1e3f993e428fe4246a2ed1c1dd" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">关于Perl和与Perl相关的书籍很​​多。其中一些很好，有些还可以，但是很多都不值得。在&lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/上&lt;/a&gt;有这些书的清单，有些书有详尽的评论。我们在这里列出了一些书，虽然列出一本书意味着我们的认可，但不要认为不包括书就没有任何意义。</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">目前有很多不同的ftp防火墙产品。但不幸的是,如何穿越防火墙并没有一个标准。下面的列表显示了Net::FTP将使用的命令序列。</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;关于Perl的书&lt;/a&gt;很多。</target>
        </trans-unit>
        <trans-unit id="25f8cf87f8d0d010ba0c130a03c0c733508760a7" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">除了这里描述的非常基本的属性以外，还有更多的属性。完整列表在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">由于 FileHandle 是 IO::File、IO::Seekable 和 IO::Handle 的后裔,所以还有很多其他的函数可用。更多的函数请参见相关页面的文档。</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">原因有很多,但最主要的是跨平台兼容。</target>
        </trans-unit>
        <trans-unit id="ec8353eb61918c8ea09b548fd2c7481452870299" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">有很多方法可以确保值是您期望或想要接受的。除了我们在perlfaq中介绍的特定示例外，您还可以查看名称中带有&amp;ldquo; Assert&amp;rdquo;和&amp;ldquo; Validate&amp;rdquo;的模块，以及诸如&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common之&lt;/a&gt;类的其他模块。</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">有多种方法可以将多行数据转换为字符串。如果您希望它在读取输入时自动发生，则需要设置$ /（对于段落可能设置为&amp;rdquo;，对于整个文件则设置为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ），以允许您一次读取多行。</target>
        </trans-unit>
        <trans-unit id="d0c13e2ae1a5d488cf21f540ff8605d82939bccd" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;undef&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">有很多很多Unicode字符属性。有关完整列表，请参见&lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;。它们中的大多数具有短名称的同义词，也在此列出。一些同义词是单个字符。对于这些，您可以放下大括号。例如， &lt;code&gt;\pM&lt;/code&gt; 与 &lt;code&gt;\p{Mark}&lt;/code&gt; ，意味着带有重音符号的东西。</target>
        </trans-unit>
        <trans-unit id="69da32a8fafef027c405b2092d6a66a08f07e5a2" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt;, meaning things like accent marks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">代码点有很多很多,但计算机是用字节工作的,一个字节只能容纳256个值。Unicode有很多比这更多的字符,所以你需要一种方法来使这些字符能够被访问。</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">关于Solaris的信息有很多很多的来源。对于perl来说,有几个重要的。</target>
        </trans-unit>
        <trans-unit id="83467e96db886b15aa3db22c9e9e4b034057eea3" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt;, &lt;a href=&quot;Minilla::Tutorial&quot;&gt;Minilla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist::Milla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist::Zilla::Starter&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">有一些模块可以帮助您完成编写模块的过程：&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da29172199b45020f43775089b9830c405a497fb" translate="yes" xml:space="preserve">
          <source>There are no deprecations or fatalizations scheduled for Perl 5.34.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">没有参考的循环。</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">对于未知的结果,没有唯一的方法。</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; 下有一些非显而易见的Unicode规则，它们可以可变地匹配，但是您可能认为不可能。例如，子字符串 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 可以匹配单个字符LATIN SMALL LETTER SHARPS。还有其他可以匹配单个连字字符的ASCII字符序列，例如，与 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; 匹配的LATIN SMALL LIGATURE FFI 。从Perl v5.16开始，如果只关心ASCII匹配，则将 &lt;code&gt;/aa&lt;/code&gt; 修饰符添加到正则表达式中将排除所有这些非显而易见的匹配，从而消除了此消息。您也可以说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; 将 &lt;code&gt;/aa&lt;/code&gt; 应用于在其范围内编译的所有正则表达式。参见&lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">现在,代码中有两个嵌套循环:外层循环用于从STDIN中读取压缩数据,就像之前一样;内层循环用于进行解压。</target>
        </trans-unit>
        <trans-unit id="30d7f3a596ae687e7d1a74baf88a83df7d754b06" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">目前，Perl本身（或直接由此模块（取决于您如何看待））处理的属性只有少数。但是，扩展机制允许特定于包的属性。（请参阅下面&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;的特定于包的属性处理&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">还有其他文件可能包含你要找的信息。</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">还有其他一些细微的差别，特别是关于 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; ，但是通常，对应关系非常接近。</target>
        </trans-unit>
        <trans-unit id="496c73a8b66b8bb32b2aaf26def98246996ff9e4" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;exists&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">还有其他运行时选项。您可以使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c3cf0f599cf582932d460a014aeed655f3e2812" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;pack()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">有的平台长线是64位,有的平台ints是64位,当我们要冲击你的时候,甚至有的平台短线是64位。根据C标准,这都是合法的。(换句话说,&quot;long长 &quot;并不是一种可移植的指定64位的方式,&quot;long长 &quot;甚至不能保证比 &quot;long &quot;更宽)。</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">在非ASCII平台(EBCDIC)上可能还有很多bug。</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">有不少系统做得更差!</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">在极少数情况下，这种基于包的解决方案可能会成为问题。如果将子例程从一个程序包复制到另一个程序包，则将基于原始程序包完成 &lt;code&gt;SUPER&lt;/code&gt; 解析。</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">perl的发展其实有两个轨道:一个维护版和一个实验版。维护版本是稳定的,并且有一个偶数作为次要版本(例如perl5.18.x,其中18是次要版本)。实验版本可能包含一些没有进入稳定版本的功能,并且以奇数作为次要版本(例如 perl5.19.x,其中 19 是次要版本)。</target>
        </trans-unit>
        <trans-unit id="f3f1aa2e43835efb5ebefe1c81df4f88e92a3e7e" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.24.x, where 24 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.25.x, where 25 is the minor release).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">有几个I/O运算符是你应该知道的。</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">有几种模棱两可的情况,转换例程无法确定输入的文件名是Unix格式还是VMS格式,因为现在VMS和Unix文件规范中都可能有一些字符,可能被误认为是另一种类型的语法定界符。所以有些路径名根本不能在允许任何一种类型的路径名存在的模式下使用。Perl会倾向于假设一个模棱两可的文件名是Unix格式的。</target>
        </trans-unit>
        <trans-unit id="83b566d12c94cc6ef80e2c552897da25fbcd52af" translate="yes" xml:space="preserve">
          <source>There are several components in CPAN.pm that use environment variables. The build tools, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; and &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; use some, while others matter to the levels above them. Some of these are specified by the Perl Toolchain Gang:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别国家。您可以使用名称或本模块自动导出的常量来指定代码集。</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别货币。您可以使用名称或本模块自动导出的常量来指定代码集。</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别语言。代码集可以使用名称或本模块自动导出的常量来指定。</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">您可以使用几种不同的代码集来识别脚本。代码集可以使用名称或本模块自动导出的常量来指定。</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">有多个转义序列可在大写和小写之间转换字符或字符串，并且它们也可在模式中使用。 &lt;code&gt;\l&lt;/code&gt; 和 &lt;code&gt;\u&lt;/code&gt; 将下一个字符转换为小写或大写：</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">有几种功能可以在测试中方便地指定字符和代码点。始终预加载的函数 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 及其逆向 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; 代码点并进行适当转换。文件</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">有很多资源可用于安排研讨会：上面提到的&lt;a href=&quot;#Websites&quot;&gt;网站，&lt;/a&gt;下面提到的&lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;日历&lt;/a&gt;，以及YAPC欧洲网站&lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;，这可能是欧洲Perl活动的最佳资源。</target>
        </trans-unit>
        <trans-unit id="832a8879ea071712935214efe0cfd19085976c3b" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">对于Posix类，其中有几种使用 &lt;code&gt;\p{}&lt;/code&gt; 表示形式是等效的，并&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;在perlrecharclass&lt;/a&gt;中的POSIX字符类中进行了描述。</target>
        </trans-unit>
        <trans-unit id="f33ad2d3a2c17446bc61c87b03a2741b5207b2ef" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">其中有几种，它们是扩展到完整Unicode范围的标准Posix类。&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;在perlrecharclass&lt;/a&gt;中的POSIX字符类中对其进行了描述。</target>
        </trans-unit>
        <trans-unit id="ff60b9f3f7c3df35d25431cc4664ba95f5cce4d6" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl实现了几种类型的字符类测试。此处描述的唯一函数是直接对应于对8位字符进行操作的C库函数的函数，但是也存在与对宽字符和UTF-8编码的字符串进行操作的等效项。所有被更充分地描述&lt;a href=&quot;perlapi#Character-classification&quot;&gt;字符分类中负责填实perlapi&lt;/a&gt;和&lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;字符情况变化负责填实perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">调用调试器有几种方法。</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">有几种方法可以将Perl脚本包装在DCL中。</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt; 模板中存在一些错误</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">在某些情况下，Perl无法立即说出表达式和语句之间的区别。例如，块的语法和匿名哈希引用构造函数的外观相同，除非花括号中的内容可以为Perl提供提示。如果Perl没猜到 &lt;code&gt;{ ... }&lt;/code&gt; 是一个块，则省略号是语法错误。在那种情况下，它不认为 &lt;code&gt;...&lt;/code&gt; 是省略号，因为它期望使用表达式而不是语句：</target>
        </trans-unit>
        <trans-unit id="56b7755399d4ee6979402a39fa3144930c83cfee" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">使用运行时语句有一些注意事项，例如 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; 和对程序包变量的分配，这对于不了解程序的程序员可能非常微妙。例如，这可能会在相互递归的模块中发生，这些模块受相关构造的执行时间影响。</target>
        </trans-unit>
        <trans-unit id="4f5521a0adc9e1424f0db1d5eef9bf6747b3a1ab" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;require Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344f93501dc28c704b9a2e67faf75c375217d583" translate="yes" xml:space="preserve">
          <source>There are some complications that are ignored in the examples above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">有一些便利功能可以帮助销毁xV。这些功能引入了&amp;ldquo;死亡率&amp;rdquo;的概念。致命的xV已将其参考计数标记为递减，但实际上并未递减，直到&amp;ldquo;稍后&amp;rdquo;。通常，术语&amp;ldquo;稍后时间短&amp;rdquo;表示单个Perl语句，例如对XSUB函数的调用。凡人xV的参考计数递减的实际决定因素取决于两个宏SAVETMPS和FREETMPS。有关这些宏的更多详细信息，请参见&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;和&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d7095e4177705611245878da2c1cd341f565d3b" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. Much documentation speaks of an xV itself being mortal, but this is misleading. It is really</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aad51f0e11a34d98334dfd8a5325d2defc4e5c1" translate="yes" xml:space="preserve">
          <source>There are some different considerations for each form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">如果你想操作一个有重复键的BTREE数据库,使用绑定哈希接口会有一些困难。考虑一下这段代码。</target>
        </trans-unit>
        <trans-unit id="c09cd4cd0008c42a9eb3710539a1c18a01958eae" translate="yes" xml:space="preserve">
          <source>There are some downsides here: the size economy will not stand at runtime after this &lt;code&gt;init()&lt;/code&gt; runs. But it should not be that critical, since if you don't have space for that, you won't have space for any other language besides the main one as well. You could do that too with ties, expanding the value at lookup time which should be more time expensive as an option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">这种方法有一些缺点。其一是任何调用任何文件操纵C函数的扩展都需要重新编译(只需按照通常的 &quot;perl Makefile.PL;make;make test;make install &quot;程序)。</target>
        </trans-unit>
        <trans-unit id="9cd4d89394373d1a964c062cbd37f2a471efcbee" translate="yes" xml:space="preserve">
          <source>There are some locale-related library calls that still aren't thread-safe because they return data in a buffer global to all threads. In the past, these didn't matter as locales weren't thread-safe at all. But now you have to be aware of them in case your module is called in a multi-threaded application. The known ones are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">这种技术有一些明显的缺点。</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">您可以传递一些可选选项来进行 &lt;code&gt;memoize&lt;/code&gt; 以更改其行为方式。要提供选项，请像这样调用 &lt;code&gt;memoize&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="94c539cef62e9aa25e310b57bc5c00ca12ad3ddb" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C in perlrun&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">有一些简单的捷径可供选择。在&lt;a href=&quot;perlrun&quot;&gt;perlrun中&lt;/a&gt;查看&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="242b6f00a4806779b2651b44eef8a2d396dd9333" translate="yes" xml:space="preserve">
          <source>There are some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt;, you have to run make as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">对于畸形的超链接,有一些警告。</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">在Perl中，仍然有很多地方可以将Unicode（以某种编码或另一种形式）作为参数或作为结果接收，或在这两者中都可以，但是，尽管Perl具有使用Unicode进行输入和输出的广泛方法，但事实并非如此。其他一些&amp;ldquo;入口点&amp;rdquo;，例如 &lt;code&gt;@ARGV&lt;/code&gt; 数组（有时可以解释为UTF-8）。</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">有三个命令行标志可以用来控制何时产生(或不产生)警告。</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">运行外部命令的基本方式有三种。</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">有三种基本的方式可以构建一个线程程序。你选择哪种模型取决于你需要你的程序做什么。对于许多非平凡的线程,你需要为你的程序的不同部分选择不同的模型。</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">在regex引擎中,&quot;下一个 &quot;有三个截然不同的概念,必须要明确。</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">有三种避免这种开销的流行方法。一种解决方案涉及使用带有mod_perl或mod_fastcgi插件模块的Apache HTTP服务器（可从&lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/获得&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">在 Perl 正则表达式中,有三种类型的字符类:圆点、反斜杠序列和用方括号括起来的形式。但请记住,术语 &quot;字符类 &quot;通常只用来指方括号内的形式。当然,大多数Perl文档都是这样做的。</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">有三种方法可以做到这一点。第一,简单但效率不高的方法,这也是默认的,为了保持源码与扩展的兼容性:每当</target>
        </trans-unit>
        <trans-unit id="95c05fa69dfba88648a1ac130ade8afd3e3bcc34" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">可以通过三种方法在核心中编写测试：&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">有三种方法可以编写自己的源过滤器。你可以用C语言写,用外部程序做过滤器,或者用Perl写过滤器。前两种我不会很详细地介绍,所以我先把它们说出来。用Perl写过滤器是最方便的,所以我用最多的篇幅来介绍。</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">有些时候,你可能会发现让一个线程明确地把CPU让给另一个线程是很有用的。你可能正在做一些处理器密集型的事情,并希望确保用户接口线程被频繁调用。无论如何,有些时候,你可能会希望一个线程放弃处理器。</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">有两种基本的操作模式(如果关闭则加转)。</target>
        </trans-unit>
        <trans-unit id="a13ac870bbe694381404312541ad897bb1c7bfff" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">有两个回调，在所有情况下都将调用 &lt;code&gt;named_buff&lt;/code&gt; ：FETCH，STORE，DELETE，CLEAR，EXISTS和SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;回调将在与 &lt;code&gt;named_buff_iter&lt;/code&gt; 和NEXTKEY相同的情况下更改为 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 和named_buff_iter。</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">有两种情况,多字节和单字节定位。先说多字节。</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">有两种情况。</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">有两种常用的剖析可执行文件的技术。</target>
        </trans-unit>
        <trans-unit id="ca79bf7ca29122cb03591230567965097d73b502" translate="yes" xml:space="preserve">
          <source>There are two different types of version objects, corresponding to the two different styles of versions in use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">OS/2的dyna-link模型有两个明显的特点:第一,所有对外部函数的引用都在编译时解决;第二,DLL加载到内存中后,不需要在运行时对其进行修复。与其他模型相比,第一个特点有一个巨大的优势:当一个应用程序使用的几个DLL导出的条目名称相同时,它可以避免冲突。在这种情况下,dyna-link 的 &quot;其他 &quot;模型只是使用一些随机标准在这两个入口点之间进行选择--其结果是可预见的灾难。但是,正是第二个功能需要构建</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">从内部解压循环有两个出口。</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">八进制转义有两种形式。每一种形式都是用八进制符号指定一个字符的码点。</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">有两个重要的点要记住。</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">在哈希中,有两个键具有特殊的意义。&quot;读 &quot;和 &quot;写&quot;。这些键包含了packlist文件。复制完成后,install()将把目标文件的列表写入$from_to{write}。如果给定了 $from_to{read},这个文件的内容将被合并到写入的文件中。读出的文件和写出的文件可能是相同的,但是在AFS上,人们很有可能安装到一个与后来出现的文件不同的目录。</target>
        </trans-unit>
        <trans-unit id="127794821c87aa3c1561f9022c74d909b021fad3" translate="yes" xml:space="preserve">
          <source>There are two main ways that contexts are popped. During normal execution as scopes are exited, functions like &lt;code&gt;pp_leave&lt;/code&gt;, &lt;code&gt;pp_leaveloop&lt;/code&gt; and &lt;code&gt;pp_leavesub&lt;/code&gt; process and pop just one context using &lt;code&gt;cx_popfoo&lt;/code&gt; and &lt;code&gt;cx_popblock&lt;/code&gt;. On the other hand, things like &lt;code&gt;pp_return&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; may have to pop back several scopes until a sub or loop context is found, and exceptions (such as &lt;code&gt;die&lt;/code&gt;) need to pop back contexts until an eval context is found. Both of these are accomplished by &lt;code&gt;dounwind()&lt;/code&gt;, which is capable of processing and popping all contexts above the target one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">有两个新的显示参数。</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">有两个操作数,但没有给出你想如何组合它们的操作数。</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perl中有两个包分隔符：双冒号（ &lt;code&gt;::&lt;/code&gt; 和单引号（ &lt;code&gt;'&lt;/code&gt; ）。普通标识符可以以双冒号开头或结尾，并且可以包含由双冒号分隔的多个部分。单引号具有相似的规则，但唯一的 &lt;code&gt;$foo'bar&lt;/code&gt; 是标识符在标识符末尾不合法：即 &lt;code&gt;$'foo&lt;/code&gt; 和$ foo'bar是合法的，但 &lt;code&gt;$foo'bar'&lt;/code&gt; 不合法。</target>
        </trans-unit>
        <trans-unit id="281389919696086dbd7adfd1393b788681ca075b" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt;) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">报告OS / 2 API的错误情况有两种主要的约定（将它们称为 &lt;code&gt;Dos*&lt;/code&gt; 和 &lt;code&gt;Win*&lt;/code&gt; 是有用的-尽管函数签名的这一部分并不总是由API的名称确定）。大多数 &lt;code&gt;Dos*&lt;/code&gt; API都会将错误代码报告为调用的结果（因此0表示成功，并且错误的类型很多）。大多数 &lt;code&gt;Win*&lt;/code&gt; API通过将结果为 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 来报告成功/失败；要查找失败的原因，应调用WinGetLastError（）API。</target>
        </trans-unit>
        <trans-unit id="2eaa4513f3f865ba65175af81cc35fc35f264abc" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt;; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">运行测试套件有两个步骤。</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有两种用于存储已编译正则表达式的结构。第一种，&lt;a href=&quot;perlreapi&quot;&gt;perlreapi中&lt;/a&gt;描述的 &lt;code&gt;regexp&lt;/code&gt; 结构由当前正在使用的引擎填充。使用了它，perl读取了其中的某些字段以实现诸如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 的字符串化之类的功能。</target>
        </trans-unit>
        <trans-unit id="5100abedaa25e172d048855813a77ed10197f346" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">格式化代码有两种语法。</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">我能想到的有两个。</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">在Perl 5.10中有两种方法来构建持久私有变量。首先，您可以简单地使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 功能。或者，如果您想与5.10之前的版本保持兼容，则可以使用闭包。</target>
        </trans-unit>
        <trans-unit id="61e69f88599a859bbb0f9c52d49cc582b32af203" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;state&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">有两种方法可以创建和加载一个AV。第一种方法是创建一个空的AV。</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">有两种方法可以启用正则表达式的调试输出。</target>
        </trans-unit>
        <trans-unit id="0ef643530975df52bad47239ca43b62c4abb64aa" translate="yes" xml:space="preserve">
          <source>There are two ways to enter v-strings: a bare number with two or more decimal points, or a bare number with one or more decimal points and a leading 'v' character (also bare). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">有两种方法可以隐式加载 &lt;code&gt;feature&lt;/code&gt; 杂注：</target>
        </trans-unit>
        <trans-unit id="af911c100c71eb3b76adfb1d6d843d034d346f08" translate="yes" xml:space="preserve">
          <source>There are two ways to specify the selection. Either a string (scalar) representing a selection regexp for sections to be printed when -verbose is set to 99, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">有两种方法可以从Perl中使用Cocoa。苹果的PerlObjCBridge模块,包含在Mac OS X中,可以被独立的脚本用来访问基金会(即非GUI)类和对象。</target>
        </trans-unit>
        <trans-unit id="767f59a65489b12a4b5161b27a3a60165cdfb67b" translate="yes" xml:space="preserve">
          <source>There are two ways to use a DBM Filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">在如此时髦的代码中,无疑潜藏着严重的bug:-)我们非常欢迎BUG报告和其他反馈。</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">毫无疑问,这段代码中的某个地方潜藏着严重的错误,如果只是因为其中的部分内容给人的印象是他们对 Perl 的理解比实际情况要多得多。</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">这个主题有很多有用的变化。可以使用 &lt;code&gt;!~&lt;/code&gt; 运算符反转匹配的含义：</target>
        </trans-unit>
        <trans-unit id="ccb3b88b50c8aa38b3bc60c7b4f5ddbf691da924" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; to access those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">每个可能的值通常都有几个同义词。使用&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;来访问它们。</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">通常有三个或四个间隔计时器（信号）可用： &lt;code&gt;$which&lt;/code&gt; 可以是 &lt;code&gt;ITIMER_REAL&lt;/code&gt; ， &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; ， &lt;code&gt;ITIMER_PROF&lt;/code&gt; 或 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; 。请注意，哪些可用取决于：真正的UNIX平台通常具有前三个，但是只有Solaris似乎具有 &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; （用于配置多线程程序）。不幸的是，Win32没有间隔计时器。</target>
        </trans-unit>
        <trans-unit id="ed047ca7fa087626bb96ec97a8dcb6e6e48edfcd" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt;, &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt;, &lt;code&gt;ITIMER_PROF&lt;/code&gt;, or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt;. Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">模式有很多方面,可以按照这些思路来促进优化。</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">从SunOS 4.1.4和gcc 3.2.2开始，还有许多其他故障，它们看起来很像gcc错误。许多失败都发生在Encode测试中，例如，当测试期望&amp;ldquo; 0&amp;rdquo;时，您将获得&amp;ldquo;＆＃48;&amp;rdquo;。稍稍s起眼睛后，看起来确实很奇怪。另一个例子是在</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">除了表中列出的名称之外，还可以使用其他各种同义​​词。例如， &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; 可以写为 &lt;code&gt;\p{Alpha}&lt;/code&gt; 。所有这些都列&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;在perluniprops中可通过\ p {}和\ P {}访问的属性中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc8fcc00bcaa69a62d8c2fd3f050d67f5a95dbce" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt;. All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">有各种特殊的make target可以用来测试Perl,与标准的 &quot;测试 &quot;目标略有不同。并不是所有的目标都能给出100%的成功率。它们中的许多都有几个别名,而且其中许多在某些操作系统上是不可用的。</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">下面列出了各种语法。在给定的语法中， &lt;code&gt;text&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;section&lt;/code&gt; 不能包含字符'/'和'|'；并且任何&amp;ldquo; &amp;lt;&amp;rdquo;或&amp;ldquo;&amp;gt;&amp;rdquo;都应匹配。</target>
        </trans-unit>
        <trans-unit id="154dae7c2bfb8ff3e2e9f53b8d516d9eec568a2c" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">需要注意的事项有很多种。</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">私有标志和公共标志有多种不同的方式。例如,在 perl 5.16 和更早的版本中,一个绑定的 SV 可能在 IV 槽中有一个有效的底层值(所以 SvIOKp 为真),但是数据应该通过 FETCH 例程而不是直接访问,所以 SvIOK 为假。(在perl 5.18以后,绑定标量与未绑定标量的使用方式相同)。另一种情况是当数值转换已经发生,并且精度已经丢失:只有私有标志被设置在 &quot;有损 &quot;的值上。因此,当一个 NV 转换为有损失的 IV 时,SvIOKp、SvNOKp 和 SvNOK 会被设置,而 SvIOK 不会被设置。</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">邮件列表的网络档案在:</target>
        </trans-unit>
        <trans-unit id="491c71a7d655138bb171154df9a2d69cb67f8248" translate="yes" xml:space="preserve">
          <source>There are, at first glance, three kinds of L links: URL, man, and pod.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">目前还没有任何真正的UTF-8本地化,尽管有些本地化名称包含 &quot;UTF-8 &quot;字符串。</target>
        </trans-unit>
        <trans-unit id="f18bc503764d637966b24fa60ca1825eff55d27b" translate="yes" xml:space="preserve">
          <source>There can (and in some cases, must) be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;q#foo#&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt;, while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;q&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">运算符和引号字符之间可以有空格，除非将 &lt;code&gt;#&lt;/code&gt; 用作引号字符。 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; 被解析为字符串 &lt;code&gt;foo&lt;/code&gt; ，而 &lt;code&gt;q #foo#&lt;/code&gt; 是运算符 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ,后跟一个注释。其参数将从下一行获取。这使您可以编写：</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &amp;rdquo;行的开头不需要空格，但是对于提高可读性很有用。在该行的末尾放置分号也是可选的。在&amp;ldquo; &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;input&lt;/code&gt; &amp;rdquo; 之间可以放置任何数量和种类的空格。</target>
        </trans-unit>
        <trans-unit id="0ed8a4a87dc8b9885199d341701749c4f7ba168d" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;int input&lt;/code&gt;&quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;int&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">存在一个到ILE环境的Perl端口。但是，此端口基于Perl的较旧版本，Perl 5.00502（1998年8月）。（从2002年7月开始，Perl的最新版本是5.8.0，甚至从2001年4月开始已经发布5.6.1。）但是，如果您需要在ILE上运行Perl，则可能需要此旧端口：&lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http：// www.cpan.org/ports/#os400&lt;/a&gt;注意任何Perl的后续版本比5.00502还没有被移植到ILE。</target>
        </trans-unit>
        <trans-unit id="0d9d302333913269ef8b0575b5cd9f95eaae918e" translate="yes" xml:space="preserve">
          <source>There has been a long-standing bug in Perl that causes a lexical variable not to be cleared at scope exit when its declaration includes a false conditional. Some people have exploited this bug to achieve a kind of static variable. To allow us to fix this bug, people should not be relying on this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e08bda06a78f17f34330ccdc939ea82e2b5bf49" translate="yes" xml:space="preserve">
          <source>There is Coverity setup for the perl5 project: &lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https://scan.coverity.com/projects/perl5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">BS2000有一个名为hints.posix-bc的 &quot;提示 &quot;文件(因为posix-bc是`uname`给出的操作系统名称),它规定了大多数事情的正确值。主要的问题是(当然)EBCDIC字符集。我们有德文EBCDIC版本。</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">有一个$diagnostics::DEBUG变量,如果你非常好奇被拦截的是什么东西,你可以设置。</target>
        </trans-unit>
        <trans-unit id="4e2dabede0ae332ec4295f1f32bf75c6726b72c4" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;lint&lt;/code&gt; target in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b8779e0a6e284066d3e0c5dc63c7524691a431" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, &lt;code&gt;ucfirst()&lt;/code&gt;, and &lt;code&gt;fc&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt;). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">有一个CPAN模块 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; ，它允许您定义自己的映射以用于 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; （或双引号的字符串内联版本）例如 &lt;code&gt;\U&lt;/code&gt; ）。（在Perl 5.16之前，此功能部分地在Perl内核中提供，但是由于存在许多无法克服的缺陷，因此改为编写CPAN模块。）</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">在CPAN上有一个Clone模块,它可以实现原生的深度克隆,即不需要冻结内存和解冻结果。它的目标是有朝一日取代Storable的dclone()。然而,它目前不支持Storable钩子来重新定义深度克隆的方式。</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">TrollTech的Qt工具包有一个Perl接口,但似乎没有维护。</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">在perl5.6.0中，有一个UV &amp;gt;&amp;gt; 1 &amp;lt;&amp;lt; 31的错误。这将显示为dualvar.t的测试8和9失败</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Perl社区有一个中央目录：&lt;a href=&quot;http://perl.org&quot;&gt;http&lt;/a&gt; : //perl.org，由Perl基金会（&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;）维护，该目录跟踪并为其他各种社区站点提供服务。</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; 中有一个类方法，该方法被实现为XS代码。通过 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 调用它以验证层：</target>
        </trans-unit>
        <trans-unit id="ba9884f209caf6d0506a39ac341c0ea3ddd78c13" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;import&lt;/code&gt; to validate the layers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">有一种叫做 &quot;文件扩展名关联 &quot;的设施。这可以通过Windows的标准命令 &quot;assoc &quot;和 &quot;ftype &quot;来操作。输入 &quot;ftype /?&quot;,可以看到一个完整的例子,说明如何为perl脚本设置这个功能(说什么? 你以为Windows还没有perl-ready?</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">在行指令中包含了一个相当明显的陷阱。调试器和剖析器只会显示给定文件中最后一行出现在特定行号的源码。需要注意的是,不要在你以后要调试的代码中造成行号冲突。</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">在Changes文件中有完整的版本历史记录，可以使用&lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;找到包含为核心的Test :: More版本：</target>
        </trans-unit>
        <trans-unit id="fc72621c4f74524103b116a2301e947655e4bfff" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">有一个功能编程API可供程序员查询信息。</target>
        </trans-unit>
        <trans-unit id="a15e4bcad41aa0b597b5c043d274e21e152196d8" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">非封闭式匿名子(即那些不指向该子之外的任何词汇的子)还有一个复杂的问题。在这种情况下,匿名原型是共享的,而不是被克隆的。这样做的后果是,父类可能被释放,而仍然有活跃的子类,例如</target>
        </trans-unit>
        <trans-unit id="6e38f9a6f0524cb60060c7ab66b100df8645a3df" translate="yes" xml:space="preserve">
          <source>There is a given/when statement in Perl, but it is experimental and likely to change in future. See &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bfd060d0feb488ff6b3d46ad13ea7e46b879b0f" translate="yes" xml:space="preserve">
          <source>There is a known bug in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">有大量的地域定义集合在。</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">每条记录偏移和每个缓存条目都有很大的内存开销:每条缓存数据记录约310字节,每个偏移表条目约21字节。</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">从&lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt;有一个名为 &lt;code&gt;splint&lt;/code&gt; （安全编程棉绒）的皮棉变体，可以在任何类似Unix的平台上进行编译。</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">在标记行的正上方有一个列表 &lt;code&gt;=item&lt;/code&gt; ，没有文本内容。您可能要删除空项目。</target>
        </trans-unit>
        <trans-unit id="9491003a2d6e2370bad105f107b81a379a482390" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; that has no text contents. You probably want to delete empty items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f99dfe0ca2905f67ecab8086230b0fc7ddbaec" translate="yes" xml:space="preserve">
          <source>There is a mailing list available for users of this distribution, &lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto:datetime@perl.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">有一个局部解决方法（可以使用较新的OS / 2内核来完成）：创建一个与旧版Perl的DLL具有相同名称的转发器DLL，它将入口点转发到较新的Perl的DLL。使这个DLL在（例如）新Perl可执行文件的 &lt;code&gt;BEGINLIBPATH&lt;/code&gt; 上可访问。当新的可执行文件访问旧的Perl扩展DLL时，它们将按名称请求旧的Perl DLL，而是获取转发器，从而有效地链接到当前正在运行的（新）Perl DLL。</target>
        </trans-unit>
        <trans-unit id="d1126a23763c29c3a1bec0b9bdcdb94247472fba" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">签名和原型之间可能存在语法上的歧义（请参见&lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;），因为两者都以开括号开头并且都可以出现在某些相同的地方，例如在子例程声明中的名称之后。由于历史原因，当未启用签名时，在这种情况下的任何左括号都将触发非常宽容的原型解析。在这种情况下，大多数签名将被解释为原型，但不是有效的原型。 （有效的原型不能包含任何字母字符。）这将导致出现一些令人困惑的错误消息。</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">角色和类之间存在关系，因为每个类都隐含着同名角色。继承与角色之间也存在关系，因为从祖先类继承的子类隐式执行其父级执行的任何角色。因此，您可以安全地使用 &lt;code&gt;DOES&lt;/code&gt; 代替 &lt;code&gt;isa&lt;/code&gt; ，因为它在 &lt;code&gt;isa&lt;/code&gt; 将返回true的所有地方都将返回true（前提是任何重写的 &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt;命名空间下在CPAN上有一个丰富的 &lt;code&gt;Moose&lt;/code&gt; 扩展生态系统。此外，CPAN上的许多模块已经在使用 &lt;code&gt;Moose&lt;/code&gt; ，为您提供了很多示例可供学习。</target>
        </trans-unit>
        <trans-unit id="63c6a415ec649ec3fee18b8a757da8ffbc58b528" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt;, providing you with lots of examples to learn from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">在页面名称L &amp;lt;...&amp;gt;中检测到一个部分，例如 &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 。 POD超链接可能仅指向POD文档。请改写 &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 。一些格式化程序可以将其扩展为适当的代码。有关（内置）函数的链接，请说 &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; ，不带（）。</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">有一个名为 &lt;code&gt;PL_defstash&lt;/code&gt; 的存储区，用于保存 &lt;code&gt;main&lt;/code&gt; 包中存在的项目。要获取其他包装中的物品，请在包装名称后附加字符串&amp;ldquo; ::&amp;rdquo;。 &lt;code&gt;Foo&lt;/code&gt; 包中的项目位于PL_defstash 中的存储 &lt;code&gt;Foo::&lt;/code&gt; 中。在这些项目 &lt;code&gt;Bar::Baz&lt;/code&gt; 包是在藏匿 &lt;code&gt;Baz::&lt;/code&gt; 在 &lt;code&gt;Bar::&lt;/code&gt; 的藏匿处。</target>
        </trans-unit>
        <trans-unit id="da12b97e4f2d1305f926ea3b6d55a42d5c8e4baf" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt;'s stash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">此构造有一种特殊形式，称为 &lt;code&gt;\K&lt;/code&gt; （自Perl 5.10.0起可用），它使正则表达式引擎&amp;ldquo;保留&amp;rdquo;它在 &lt;code&gt;\K&lt;/code&gt; 之前匹配的所有内容，而不将其包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中。这有效地提供了变长后向。允许在另一个环视断言中使用 &lt;code&gt;\K&lt;/code&gt; ，但是该行为目前尚未很好定义。</target>
        </trans-unit>
        <trans-unit id="132434df2410147d359e3620818bc1c35f77d26b" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt;. This effectively provides non-experimental variable-length lookbehind of any length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">在/usr/include/sys/socket.h头文件中存在一个语法错误,IBM随USS V2R7、V2R8以及可能的V2R9一起提供。该头文件的问题是,在SO_REUSEPORT常量的定义附近,有一个虚假的额外'/'字符,在注释之外,像这样。</target>
        </trans-unit>
        <trans-unit id="4f5af7c338789d7b91669b50869dfdd492384f9b" translate="yes" xml:space="preserve">
          <source>There is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">在充分利用一种特定类型的计算机和利用它们的全部类型之间存在着一种权衡。自然而然,随着你的范围扩大,变得越来越多样化,共同因素就会下降,你剩下的共同领域越来越小,你可以在其中操作来完成某项任务。因此,当你开始攻克一个问题时,重要的是要考虑你要在权衡曲线的哪一部分下操作。具体来说,你必须决定你正在编码的任务是否具有可移植的完全通用性,还是只需现在就完成任务是重要的。这是最难做出的选择。剩下的就很容易了,因为Perl提供了很多选择,无论你想用哪种方式来解决你的问题。</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">此模块提供了一个名为&lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt;的实用程序，该实用程序是从命令行查询的便捷方式。</target>
        </trans-unit>
        <trans-unit id="26e6ac611235e43f07c357cfef8c6952cf104cdd" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有一个变量 &lt;code&gt;$File::Find::fullname&lt;/code&gt; ，它保存文件的绝对路径名，并解析所有符号链接。如果该链接是悬挂的符号链接，则全名将设置为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="973df2b639c4d3b005a76e2b6bc5345ee00adfab" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">有一种方法可以通过Perl API从C语言实现类似的任务:创建一个</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">编译设置 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; 有一种方法可以完全隐藏任何可修改的全局变量（它们都移到了堆中）。它通常不使用，但是可以用于测试，请在&lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background和perlguts中的PERL_IMPLICIT_CONTEXT中&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="f6e88f7ecf4798ea1155b449543fac9f0b354b61" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt;. It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">有一种方法可以告诉perl进行完全清理:将环境变量PERL_DESTRUCT_LEVEL设置为非零值。t/TEST包装器确实将其设置为2,如果你不想看到 &quot;全局泄漏&quot;,也需要这样做。例如,在valgrind下运行</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">绝对没有借口不记录你的扩展名。文档属于.pm文件。这个文件将被送入 pod2man,嵌入的文档将被转换为 manpage 格式,然后放在 blib 目录中。当安装扩展时,它将被复制到Perl的manpage目录中。</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">也有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; 这给了你很大的理由：</target>
        </trans-unit>
        <trans-unit id="9cf519c73fbae0fe8c0d4ffe79764b81487dc294" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;use bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">还有一个功能可以为 &lt;code&gt;HV&lt;/code&gt; 添加魔术：</target>
        </trans-unit>
        <trans-unit id="5e09c6821154895943bc8dd098914ffb05015157" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">还有一个较大形式的char类结构，用于表示 &lt;code&gt;/l&lt;/code&gt; 匹配下的POSIX char类，称为 &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; ，它具有一个附加的32位位图，用于指示已包括哪些POSIX char类。</target>
        </trans-unit>
        <trans-unit id="76c5f483367def15ac8c922d54c4856b499dee91" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">还有一个用Perl编写的基于toyedit文本小部件的编辑器，与CPAN上的Tk模块一起分发。ptkdb（&lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt;）是基于Perl / Tk的调试器，可作为各种开发环境。Perl Composer（&lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt;）是用于创建Perl / Tk GUI的IDE。</target>
        </trans-unit>
        <trans-unit id="d6fbaba8f9d7c369b3de63f57e236ae1dbe1ef42" translate="yes" xml:space="preserve">
          <source>There is also an irc channel available for users of this distribution, at &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;&lt;code&gt;#toolchain&lt;/code&gt; on &lt;code&gt;irc.perl.org&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d533bbf93c93c54738d070099b6cc38c79c4b031" translate="yes" xml:space="preserve">
          <source>There is an active user community that provides many software packages for the Synology DSM systems; at the time of writing this document they provide Perl version 5.24.1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">在子例程中使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 时，存在一个极端情况，该子例程是在与调用它的模块不同的模块中创建的。听起来很复杂，但实际上并非如此。这是一个无法正常工作的示例：</target>
        </trans-unit>
        <trans-unit id="689977e776e24b93188512fdd38744344797e09f" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;next::method&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">还有另一个目录（$ CPAN :: Config-&amp;gt; {keep_source_where}），用于保存原始分发文件。该目录不受高速缓存管理器的限制，必须由用户控制。如果选择与build_dir和keep_source_where目录具有相同的目录，则将使用相同的fifo机制删除源。</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">还有一种方法可以使用,即在回调终止后,只要Perl重新获得控制权,就会让Perl自动为你做这件事。要做到这一点,只需不使用</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">还有一种方法可以用清晰换取紧凑。INPUT部分允许声明不出现在子程序参数列表中的C变量。因此,上面的mutate()代码可以重写为</target>
        </trans-unit>
        <trans-unit id="69c800bd073688bcd19d75ca494a0e096bef464f" translate="yes" xml:space="preserve">
          <source>There is currently no method for going the other way; but I can probably provide one upon request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">目前还没有办法关闭试图对未标记的文本进行适当格式化的猜测工作,而且有时不希望这样做(特别是在使用 POD 来记录 Perl 以外的其他内容时)。不过,现在已经完成了大部分的修复工作,还需要的是一个用户界面。</target>
        </trans-unit>
        <trans-unit id="658a8d7bbc3f0f0bd3eee360c95b181c02d32e56" translate="yes" xml:space="preserve">
          <source>There is lots more to bracketed character classes; full details are in &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">没有</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">进程大小没有2GB的限制。</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">扩展名没有提供 &lt;code&gt;*.bs&lt;/code&gt; 文件。相反，可能有一个 &lt;code&gt;*_BS&lt;/code&gt; 文件，其中包含特殊情况的代码，例如NeXT上berkeley db的posix。</target>
        </trans-unit>
        <trans-unit id="f9908fb44bd4986c8ec4678f0acbb2e49a902c07" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">虽然没有 BNF,但如果你特别勇敢的话,你可以在源码发行版的 perly.y 中摸索 yacc 语法。这个语法依赖于非常聪明的标记化代码,所以也要准备好进入 toke.c。</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">将子例程放在 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后总是被调用没有好处。</target>
        </trans-unit>
        <trans-unit id="a280984dba8147f4930e83be6fff5dcdd90c3af1" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; function calls the &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method for the package used. See also &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">没有内置的方法可以说:&quot;无论它有多宽,都要把它漂浮到页面的右侧&quot;。你必须指定它的位置。真正绝望的人可以根据当前的列数,在飞行中生成自己的格式,然后eval()它。</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">没有检查可以断言从Perl传递到C的文件句柄是使用正确的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 模式创建的。</target>
        </trans-unit>
        <trans-unit id="218dbdb05fa2faf351feae2d57dfa67d5a01ea2a" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;open()&lt;/code&gt; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">在压缩数据流之后,没有紧接着的数据。</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">没有解密功能。这个函数对于加密学来说并不是那么有用(关于这个,请查找</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">对于大多数非Perl定义的属性，没有给出描述（有关此&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;信息&lt;/a&gt;，请参见http://www.unicode.org/reports/tr44/）。</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perl中没有双重插值法，因此 &lt;code&gt;$100&lt;/code&gt; 保持不变。</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">在 &lt;code&gt;Archive::Tar&lt;/code&gt; 没有简单的方法来提供此功能，因为tarball可以包含许多文件，并且每个文件都可以以不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="5f678f49ea0f0b1f3db41874eff418b0f56e6c16" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt;, because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">没有等效的运算符可以强制在列表上下文中插入表达式，因为实际上不需要。但是，如果您确实想这样做，可以使用结构 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; ，但通常只需一个简单的 &lt;code&gt;(some expression)&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="7cb80803d06b14ddbd06119d95cbdefe4be98fc5" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt;, but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">没有 &lt;code&gt;fgets&lt;/code&gt; ; 应该使用 &lt;code&gt;sv_gets&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="9c4f353571f4abb0cafbf257cbbb852b1668ac0d" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt;; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">没有防火墙</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">所有这些都没有一般的解决办法。这是一个混乱的问题。</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">这一切都没有一般的解决办法。只是一团糟。</target>
        </trans-unit>
        <trans-unit id="b2b55e890caeb51d36e6b91d2ac8fcb1b35de4f5" translate="yes" xml:space="preserve">
          <source>There is no interface to request alternative CHECK behavior as for decode_argv(). If you need that you need to call encode/decode yourself. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">定义-OR没有低优先运算符。</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">无需从&lt;b&gt;SelfLoader&lt;/b&gt;继承。</target>
        </trans-unit>
        <trans-unit id="6e895b74ce6094374e60e95c58a0d18a65714b5a" translate="yes" xml:space="preserve">
          <source>There is no need to upgrade if you already have it installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9d8d1ae5518832290b8aa40a4082b8960c7be8" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;a href=&quot;sdbm_file&quot;&gt;&lt;code&gt;SDBM_File&lt;/code&gt;&lt;/a&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;a href=&quot;ndbm_file&quot;&gt;&lt;code&gt;NDBM_File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;db_file&quot;&gt;&lt;code&gt;DB_File&lt;/code&gt;&lt;/a&gt; are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">在所有平台上都没有一个DBM模块可用。 &lt;code&gt;SDBM_File&lt;/code&gt; 和其他文件通常在所有Unix和DOSish端口上可用，但在MacPerl中则不可用，在MacPerl中只有 &lt;code&gt;NDBM_File&lt;/code&gt; 和 &lt;code&gt;DB_File&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="dc935adca7e5bcb15422e7a69e6858c66da25299" translate="yes" xml:space="preserve">
          <source>There is no provision for delaying a request body using an &lt;code&gt;Expect&lt;/code&gt; header. Unexpected &lt;code&gt;1XX&lt;/code&gt; responses are silently ignored as per the specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93f05645168f7a6ce32010423ff327f27468e22" translate="yes" xml:space="preserve">
          <source>There is no public API for popping individual values or items from the save stack. Instead, via the scope stack, the &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; pair form a way to start and stop nested scopes. Leaving a nested scope via &lt;code&gt;LEAVE&lt;/code&gt; will restore all of the saved values that had been pushed since the most recent &lt;code&gt;ENTER&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d4d5447e705702a110e831b9f5c50697a0ccfe" translate="yes" xml:space="preserve">
          <source>There is no public API to directly push items to the temporaries stack. Instead, the API function &lt;code&gt;sv_2mortal()&lt;/code&gt; is used to mortalize an xV, adding its address to the temporaries stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">没有量词 &lt;code&gt;{,n}&lt;/code&gt; 。那被解释为文字字符串。</target>
        </trans-unit>
        <trans-unit id="4e5e1c10d207641a72418018f1f75f1613935380" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt;. That's currently illegal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61924ba7fcca566e3d46f3a27c41097477fd32e" translate="yes" xml:space="preserve">
          <source>There is no reason to directly use this package. This package is documented for completeness. This package can change, or go away completely at any time. Directly using, or monkeypatching this package is not supported in any way shape or form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">您没有理由不使用 Perl 作为一种语言将 Unix 工具粘合在一起,或者将 Macintosh 应用程序原型化,或者管理 Windows 注册表。如果出于这样或那样的原因,在一个特定的程序中追求可移植性是没有意义的,那就别费劲了。</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">没有要求转换任何东西。</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">没有set_layers（），也没有get_layers（）返回镜像堆栈的绑定数组，或者类似的东西。这不是偶然的或无意的。PerlIO层堆栈比仅堆栈要复杂一些（例如，参见 &lt;code&gt;:raw&lt;/code&gt; 的行为）。您应该使用open（）和binmode（）来操纵堆栈。</target>
        </trans-unit>
        <trans-unit id="382f006c5b68a9b9a43fcd623fca8e14332f9212" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt;). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">没有外壳程序可以处理元字符，本机标准是将以&amp;ldquo; \ n&amp;rdquo;，&amp;ldquo; \ r&amp;rdquo;或&amp;ldquo; \ 0&amp;rdquo;结尾的命令行传递给生成的程序。诸如 &lt;code&gt;&amp;gt; foo&lt;/code&gt; 重定向（如果有的话）由产生的程序的运行时库执行。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">在编译时和运行时创建类之间并没有明显的速度提升,有的只是一个新的、更标准的事件顺序。</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">这个问题没有简单的答案。Perl框架可以运行从基本的文件服务器和小规模的内部网到大规模的多国多语言网站,这些都是国际企业的核心。</target>
        </trans-unit>
        <trans-unit id="300fa34c66267d66af5fbbb27ef916d4adcee2ea" translate="yes" xml:space="preserve">
          <source>There is no simple replacement possible since a qualifier and all its subqualifiers must be considered together, so we use our own utility routine for the replacement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">由于printf()的智能有限,没有简单的解决方案,但对于许多类型来说,正确的格式是可用的,例如,后缀为'f'或'_f'。</target>
        </trans-unit>
        <trans-unit id="5540c0e13568fd5e0e7ecd528ea43dc498771d2a" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">没有简单的方法来访问WPS对象。我知道的唯一方法是通过 &lt;code&gt;OS2::REXX&lt;/code&gt; 和 &lt;code&gt;SOM&lt;/code&gt; 扩展（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;）。但是，我们无法使用Object-REXX的便捷方法。（有可能吗？我不知道Object-REXX API。） &lt;code&gt;SOM&lt;/code&gt; 扩展名（当前为字母文本）可能最终消除了这一缺点。但是，由于 &lt;code&gt;SOM&lt;/code&gt; 模块不支持DII ，因此使用 &lt;code&gt;SOM&lt;/code&gt; 并不像人们期望的那样方便。</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">在Perl中没有特殊的类语法,但是如果一个包提供了作为方法的子程序,那么它可以作为一个类来使用。这样的包也可以通过在它的全局@ISA数组中列出其他包名(必须是包的全局名,而不是词法名),从另一个类(包)中派生出一些方法。</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS上没有专门针对Perl的邮件列表,您可以联系您所在地区的Stratus Technologies客户支持中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。您可以联系您所在地区的Stratus Technologies客户援助中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; 命令后没有格式化程序的规范。</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">对于实数来说,没有网络表示法这种东西,所以如果你想跨计算机边界发送你的实数,你最好坚持使用文本表示法,可能使用十六进制浮点数格式(避免十进制转换损失),除非你绝对确定线的另一端是什么。对于更冒险的人,你可以使用上一节也是关于浮点码的字节序修改器。</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">目前还不支持绑定的@ISA。注意到@ISA的设置所需的魔法条目和实现 &quot;绑定 &quot;所需的魔法条目之间存在潜在的冲突。</target>
        </trans-unit>
        <trans-unit id="8ce7f675d43b056af9ee6718421eba4a7f2bb579" translate="yes" xml:space="preserve">
          <source>There is no support for a Request-URI of '*' for the 'OPTIONS' request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4 不支持动态链接库。</target>
        </trans-unit>
        <trans-unit id="ddb797616f9cbf4b2f8a2cb06d0ccee2c08c8ad1" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; doesn't work well on device files (like ttys) anyway. Use &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; and check for a return value of 0 to decide whether you're done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">没有syseof()函数,这是好的,因为eof()对设备文件(如ttys)并不好用。使用sysread()并检查返回值为0来决定是否完成。</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">没有技术上的原因,为什么Berkeley DB数据库不能由Perl和C应用程序共享。</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">没有办法可靠地自动检测编码,所以如果人们一直向你发送没有标明字符集的数据,你可能不得不教育他们。</target>
        </trans-unit>
        <trans-unit id="20ec9f83105615b23b9fac938fd715b5bc923fe1" translate="yes" xml:space="preserve">
          <source>There is no way to turn it back on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize::Expire并没有什么特别之处。它只是一个例子。如果你不喜欢它所实现的策略,你可以自由地编写自己的过期策略模块,实现任何你想要的策略。下面是如何做到这一点。让我们假设你的模块将被命名为MyExpirePolicy。</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">现在有一个 &lt;code&gt;bsstr()&lt;/code&gt; 方法以科学记数法（即 &lt;code&gt;1e+2&lt;/code&gt; 而不是 &lt;code&gt;100&lt;/code&gt; ）获取字符串。请注意，重载的&amp;ldquo; eq&amp;rdquo;始终使用bstr（）进行比较，但是Perl会将某些数字表示为100，而其他数字表示为1e + 308。如有疑问，请将两个参数都转换为Math :: BigInt，然后将它们作为字符串进行比较：</target>
        </trans-unit>
        <trans-unit id="5ae720bb4190ab9bd815350aa7eadedcf7d8ced5" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">当然，还有很多可以发现的东西，这只是表面。了解更多信息的最佳方法是使用perldoc查找有关该语言的更多信息，阅读在线帮助（&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;可能是下一个选择），当然还有实验。</target>
        </trans-unit>
        <trans-unit id="4c5dc52000b85d6cc8d7d71cfdf7a1cf6d094cbc" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">往往是见仁见智的问题,没有任何一个答案适合所有人。一般来说,你希望使用当前的稳定版本,或者紧接着之前的稳定版本。目前,这些版本分别是perl5.18.x和perl5.16.x。</target>
        </trans-unit>
        <trans-unit id="6fddc6aff8f6804eafbdecf55f8d9d2197b85b37" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">但是，INSTALL_BASE有一个警告，因为它的作用与&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker的&lt;/a&gt;较早版本主张的PREFIX和LIB设置不同。 INSTALL_BASE不支持在同一目录下为Perl的多个版本或不同体系结构安装模块。您应该考虑是否确实需要，如果需要，请使用旧的PREFIX和LIB设置。有关更多详细信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="14196e0aaa427146743d8121cb1facbe4cf5fb5c" translate="yes" xml:space="preserve">
          <source>There is one crucial restriction: the prereqs of an optional feature &lt;b&gt;must not&lt;/b&gt; include &lt;code&gt;configure&lt;/code&gt; phase prereqs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">所有这些都有一个例外。 &lt;code&gt;\p{All}&lt;/code&gt; 看起来像一个Unicode属性，但这是一个Perl扩展，定义为对所有可能的代码点（无论是否为Unicode）都为true，因此，将其与非Unicode代码点进行匹配时不会生成任何警告。（在v5.20之前，它是 &lt;code&gt;\p{Any}&lt;/code&gt; 的确切同义词，匹配代码点 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;0x10FFFF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a280fffe45cedb42744a2a95530fed2f40145dd0" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt;, matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">这个规则有一个例外。</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">有一个例外,那就是基数2为负数$x。</target>
        </trans-unit>
        <trans-unit id="8cbb7256d41af14511a3636bc506131a71d8c56d" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">有一个例外。如果使用字母数字字符作为模式的定界符（出于可读性原因，您可能不应该这样做），则要匹配定界符，必须对其进行转义。Perl不会发出警告。另请参见&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;在perlop中解析引用的构造的Gory详细信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">有一个微小的区别：如果在 &lt;code&gt;for&lt;/code&gt; 的初始化部分中用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明了变量，则这些变量的词法作用域恰好是 &lt;code&gt;for&lt;/code&gt; 循环（循环的主体和控制部分）。</target>
        </trans-unit>
        <trans-unit id="9813dc853a6a86bf5a99b935f981b5a1ed789ab3" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;my&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt;, the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; 之间只有一个小区别：前者不会影响变量的赋值和某些函数的返回值。 &lt;code&gt;bigint&lt;/code&gt; 也将这些结果截断为整数：</target>
        </trans-unit>
        <trans-unit id="b8649e02d1e449cfaae6e608c7b04929643e83c2" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use bigint&lt;/code&gt;: the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">以下说法有一个微妙的区别。</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">有一个单利运算符。</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">只有一个 &lt;code&gt;%^H&lt;/code&gt; ，但是任意多个模块想要使用其作用域语义。为了避免踩到对方的脚趾，他们需要确保在哈希中使用不同的键。因此，常规上，模块仅使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。在此模块标识前缀之后，密钥的其余部分完全取决于模块：它可以包含任何字符。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 和 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 。遵循此约定的模块可以很好地相互配合。</target>
        </trans-unit>
        <trans-unit id="3740e3b8de22c29d0f5b6e37bf6c582521c6e016" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt;, but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt;. Modules following this convention all play nicely with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">大纲上支持PerlIO与stdio共存。显然,如果PerlIO是用stdio实现的,就没有问题。然而在其他情况下,就必须有机制来创建一个FILE *,它可以传递给要使用stdio调用的库代码。</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">关于 &quot;regexp &quot;还是 &quot;regex&quot;,有一些争论。在本文件中,我们将使用 &quot;regex &quot;一词,除非有特殊原因,在这种情况下,我们将解释原因。</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 在线程Perl下工作的方式存在一些问题，可能是由于 &lt;code&gt;@_&lt;/code&gt; 的词法作用域。这是Perl中的一个错误，在解决之前，已记忆的函数将看到略有不同的 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; ,并且在线程Perl上的执行要比非线程Perl慢一些。</target>
        </trans-unit>
        <trans-unit id="2bcd1c67f3d88bee674b646d4ad741c0978c442b" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;goto &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt;. This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;caller()&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">在看似空的行上有一些空格。POD对此类事物非常敏感，因此将其标记出来。&lt;b&gt;vi&lt;/b&gt;用户打开&lt;b&gt;list&lt;/b&gt;选项可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">还有很大一部分的API不支持。</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">从理论上讲，信号仍然有很小的机会会在完成之前中断系统级的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 操作。即使缓冲区为空，某些STDIO实现也可能会调用多个系统级 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。在某些系统中，该可能性降低为零，并且使用 &lt;code&gt;:perlio&lt;/code&gt; 而不是系统的STDIO 时无需担心。</target>
        </trans-unit>
        <trans-unit id="0c9adb8b47f26bb800c4b672d40c4761b57cb21d" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;write()&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;write()&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">有一个给定的regnode的 &quot;下一个regnode&quot;,这个值很少有用,只是有时它与其他的一个regnode在值上吻合,有时代码会认为总是如此。</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">这是一个给定的regop/regnode的 &quot;下一个regop&quot;。这是由当前regop的大小决定的,物理上位于当前regop之后的regop。这通常是有用的,例如当转储结构时,我们使用这个顺序来遍历。有时,代码会假设 &quot;下一个regnode &quot;和 &quot;下一个regop &quot;是一样的,或者换句话说,假设给定的regop类型的大小总是要大一个regnode。</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">有来自给定regop的&amp;ldquo; regnext&amp;rdquo;。这是regop，可以通过向前跳转 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 的值来达到，或者在某些情况下可以通过 &lt;code&gt;regnode_1&lt;/code&gt; 结构的 &lt;code&gt;arg1&lt;/code&gt; 字段进行更长的跳转。子例程 &lt;code&gt;regnext()&lt;/code&gt; 透明地进行处理。这是节点的逻辑后继者，在某些情况下，像 &lt;code&gt;BRANCH&lt;/code&gt; regop一样，具有特殊的含义。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
