<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d34178e964cf584fdf5806f55c96a0bc4853575e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; blocks are run just after the unit which defined them has been compiled. The main program file and each module it loads are compilation units, as are string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s, run-time code compiled using the &lt;code&gt;(?{ })&lt;/code&gt; construct in a regex, calls to &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; FILE&lt;/code&gt; , and code after the &lt;code&gt;-e&lt;/code&gt; switch on the command line.</source>
          <target state="translated">&lt;code&gt;UNITCHECK&lt;/code&gt; 块在定义它们的单元编译后立即运行。主程序文件及其加载的每个模块都是编译单元，字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 也是它们，在正则表达式中使用 &lt;code&gt;(?{ })&lt;/code&gt; 构造编译的运行时代码，调用 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; FILE&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; FILE&lt;/code&gt; ，以及 &lt;code&gt;-e&lt;/code&gt; 之后的代码在命令行上切换。</target>
        </trans-unit>
        <trans-unit id="d0b34c789eb4701c037da956f420b7e815dbc83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt; blocks are run just after the unit which defined them has been compiled. The main program file and each module it loads are compilation units, as are string &lt;code&gt;eval&lt;/code&gt;s, run-time code compiled using the &lt;code&gt;(?{ })&lt;/code&gt; construct in a regex, calls to &lt;code&gt;do FILE&lt;/code&gt;, &lt;code&gt;require FILE&lt;/code&gt;, and code after the &lt;code&gt;-e&lt;/code&gt; switch on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993680698e7847eec1247ae490639ce741c5d46c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; code blocks are useful to catch the transition between the compilation phase and the execution phase of the main program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29082300972578ac172b3bcf60b3baedc1711b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; is the base class from which all blessed references inherit. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; 是所有受祝福引用都继承自的基类。参见&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40ee2201428c064e4abefc93cea2f5adb84494a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNIVERSAL&lt;/code&gt; provides the following methods:</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; 提供以下方法：</target>
        </trans-unit>
        <trans-unit id="48bcc00e56d5f4d3ae407316df106ebd67bb3cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-16&lt;/code&gt; support in any software you're going to be using/interoperating with has probably been less tested then &lt;code&gt;UTF-8&lt;/code&gt; support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6668e1349203a01e97d9d0c7131694668cceca2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; coded data seamlessly passes traditional command piping (&lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;more&lt;/code&gt;, etc.) while &lt;code&gt;UTF-16&lt;/code&gt; coded data is likely to cause confusion (with its zero bytes, for example)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8236e4ed6563ca685881ecd85fb5fbeb9a8352ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is internally known as &lt;code&gt;utf-8-strict&lt;/code&gt; . The tutorial uses UTF-8 consistently, even where utf8 is actually used internally, because the distinction can be hard to make, and is mostly irrelevant.</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 内部称为 &lt;code&gt;utf-8-strict&lt;/code&gt; 。本教程始终使用UTF-8，即使在内部实际使用utf8的情况下，也是如此，因为区分起来很难，而且几乎没有关系。</target>
        </trans-unit>
        <trans-unit id="155fb80f2152bf4ffcfd5f143e6e7654fb7aa8b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is internally known as &lt;code&gt;utf-8-strict&lt;/code&gt;. The tutorial uses UTF-8 consistently, even where utf8 is actually used internally, because the distinction can be hard to make, and is mostly irrelevant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8de8fd8fcf48c479a5f2548a2ea84553cbb55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is the official standard. &lt;code&gt;utf8&lt;/code&gt; is Perl's way of being liberal in what it accepts. If you have to communicate with things that aren't so liberal, you may want to consider using &lt;code&gt;UTF-8&lt;/code&gt; . If you have to communicate with things that are too liberal, you may have to use &lt;code&gt;utf8&lt;/code&gt; . The full explanation is in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; 是官方标准。 &lt;code&gt;utf8&lt;/code&gt; 是Perl接受的自由方式。如果您必须与不太自由的事物进行交流，则可以考虑使用 &lt;code&gt;UTF-8&lt;/code&gt; 。如果您必须与过于自由的事物进行交流，则可能必须使用 &lt;code&gt;utf8&lt;/code&gt; 。完整的解释在&lt;a href=&quot;encode&quot;&gt;Encode中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac5912852fa9a734f9b95a1101aa81c0d3a5bec6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF-8&lt;/code&gt; is the official standard. &lt;code&gt;utf8&lt;/code&gt; is Perl's way of being liberal in what it accepts. If you have to communicate with things that aren't so liberal, you may want to consider using &lt;code&gt;UTF-8&lt;/code&gt;. If you have to communicate with things that are too liberal, you may have to use &lt;code&gt;utf8&lt;/code&gt;. The full explanation is in &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;&quot;UTF-8 vs. utf8 vs. UTF8&quot; in Encode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648b8e1ece55e870da0fa029a2d05ec2a1a49ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt; and &lt;code&gt;UTF8_GOT_NON_CONTINUATION&lt;/code&gt; both indicate a too short sequence. The difference is that &lt;code&gt;UTF8_GOT_NON_CONTINUATION&lt;/code&gt; indicates always that there is an error, while &lt;code&gt;UTF8_GOT_SHORT&lt;/code&gt; means that an incomplete sequence was looked at. If no other flags are present, it means that the sequence was valid as far as it went. Depending on the application, this could mean one of three things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5ad314dc68bfcf9c5118562765d9026038fdea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Big5&lt;/code&gt; provides &lt;code&gt;weightBig5()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's big5han ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda35f95559414b24b0f7588f4920e637e99eecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::GB2312&lt;/code&gt; provides &lt;code&gt;weightGB2312()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's gb2312han ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b93d61a2bcdb017d1da4cb4a7e3de0c0b6f57d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::JISX0208&lt;/code&gt; provides &lt;code&gt;weightJISX0208()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of 6355 kanji (CJK Unified Ideographs) in the JIS X 0208 order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bd2e4df2dcc667d23fa9130f85c3c4fe05e14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Korean&lt;/code&gt; provides &lt;code&gt;weightKorean()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's Korean ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd09d4d7986483cdb514ee8d55c84344ad28e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Pinyin&lt;/code&gt; provides &lt;code&gt;weightPinyin()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's pinyin ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbba643a43bc8fa99d423cd8af99518aa199ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Stroke&lt;/code&gt; provides &lt;code&gt;weightStroke()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's stroke ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cad4d3162f98026817fba4d323f45f7e7e8acc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::CJK::Zhuyin&lt;/code&gt; provides &lt;code&gt;weightZhuyin()&lt;/code&gt;, that is adequate for &lt;code&gt;overrideCJK&lt;/code&gt; of &lt;code&gt;Unicode::Collate&lt;/code&gt; and makes tailoring of CJK Unified Ideographs in the order of CLDR's zhuyin (bopomofo) ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da0ed2cdd1ac72f2bf3f9e083bf202dcf2c866fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; is a subclass of &lt;code&gt;Unicode::Collate&lt;/code&gt; and methods other than &lt;code&gt;new&lt;/code&gt; are inherited from &lt;code&gt;Unicode::Collate&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a0fc4be9864abfdfe213f730a836cf153d3d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unix&lt;/code&gt; has a few filetypes that aren't supported on other platforms, like &lt;code&gt;Win32&lt;/code&gt; . If we encounter a &lt;code&gt;hardlink&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; we'll just try to make a copy of the original file, rather than throwing an error.</source>
          <target state="translated">&lt;code&gt;Unix&lt;/code&gt; 具有其他平台（例如 &lt;code&gt;Win32&lt;/code&gt; )不支持的一些文件类型。如果遇到 &lt;code&gt;hardlink&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; 或符号链接，我们将尝试制作原始文件的副本，而不是抛出错误。</target>
        </trans-unit>
        <trans-unit id="a182b7c96cc889f6bd8227eeff8484aa3820a3e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Unix&lt;/code&gt; has a few filetypes that aren't supported on other platforms, like &lt;code&gt;Win32&lt;/code&gt;. If we encounter a &lt;code&gt;hardlink&lt;/code&gt; or &lt;code&gt;symlink&lt;/code&gt; we'll just try to make a copy of the original file, rather than throwing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d74c9b056759689807d86e862d255692b030b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VEOF&lt;/code&gt;&lt;code&gt;VEOL&lt;/code&gt;&lt;code&gt;VERASE&lt;/code&gt;&lt;code&gt;VINTR&lt;/code&gt;&lt;code&gt;VKILL&lt;/code&gt;&lt;code&gt;VQUIT&lt;/code&gt;&lt;code&gt;VSUSP&lt;/code&gt;&lt;code&gt;VSTART&lt;/code&gt;&lt;code&gt;VSTOP&lt;/code&gt;&lt;code&gt;VMIN&lt;/code&gt;&lt;code&gt;VTIME&lt;/code&gt;&lt;code&gt;NCCS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e64ceff700bffb9b0e49ed00840d8567272b98d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; can be called as either a class (static) method or an object method.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 可以称为类（静态）方法或对象方法。</target>
        </trans-unit>
        <trans-unit id="53e5c5bf9414f45f9ee6cd495857a6d0af8135b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; will return the value of the variable &lt;code&gt;$VERSION&lt;/code&gt; in the package the object is blessed into. If &lt;code&gt;REQUIRE&lt;/code&gt; is given then it will do a comparison and die if the package version is not greater than or equal to &lt;code&gt;REQUIRE&lt;/code&gt; , or if either &lt;code&gt;$VERSION&lt;/code&gt; or &lt;code&gt;REQUIRE&lt;/code&gt; is not a &quot;lax&quot; version number (as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module).</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; 将在对象被祝福到的包中返回变量 &lt;code&gt;$VERSION&lt;/code&gt; 的值。如果给出 &lt;code&gt;REQUIRE&lt;/code&gt; ，则它将进行比较，如果软件包的版本不大于或等于 &lt;code&gt;REQUIRE&lt;/code&gt; ，或者 &lt;code&gt;$VERSION&lt;/code&gt; 或 &lt;code&gt;REQUIRE&lt;/code&gt; 都不是&amp;ldquo;宽松&amp;rdquo;版本号（由&lt;a href=&quot;version&quot;&gt;版本&lt;/a&gt;模块定义），它将终止。</target>
        </trans-unit>
        <trans-unit id="325270b8b61d72ca064d946a7eaba60462295b3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;VERSION&lt;/code&gt; will return the value of the variable &lt;code&gt;$VERSION&lt;/code&gt; in the package the object is blessed into. If &lt;code&gt;REQUIRE&lt;/code&gt; is given then it will do a comparison and die if the package version is not greater than or equal to &lt;code&gt;REQUIRE&lt;/code&gt;, or if either &lt;code&gt;$VERSION&lt;/code&gt; or &lt;code&gt;REQUIRE&lt;/code&gt; is not a &quot;lax&quot; version number (as defined by the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09d07e4d00536d5b65342f6fda4e06e40de674a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WEXITSTATUS(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the normal exit status of the child process (only meaningful if &lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WEXITSTATUS(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 返回子进程的正常退出状态（仅在 &lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 为true 时才有意义）</target>
        </trans-unit>
        <trans-unit id="ba14e82200cc3ea888304902d4a8a4dbe69a35f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WHICH&lt;/code&gt; can be any of &lt;code&gt;PRIO_PROCESS&lt;/code&gt;, &lt;code&gt;PRIO_PGRP&lt;/code&gt; or &lt;code&gt;PRIO_USER&lt;/code&gt; imported from &lt;a href=&quot;posix#RESOURCE-CONSTANTS&quot;&gt;&quot;RESOURCE CONSTANTS&quot; in POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50caa072d18e392639ac8cbf2652792fc96e056a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process exited normally (&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; or by falling off the end of &lt;code&gt;main()&lt;/code&gt; )</source>
          <target state="translated">&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 如果子进程正常退出返回true（ &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 或脱落年底 &lt;code&gt;main()&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3c429b7be20772ea3ed8789304f68e213333fbd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process exited normally (&lt;code&gt;exit()&lt;/code&gt; or by falling off the end of &lt;code&gt;main()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a10acdd8d4b5cbcaa19166a65359a79e72c10ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WIFEXITED&lt;/code&gt;&lt;code&gt;WEXITSTATUS&lt;/code&gt;&lt;code&gt;WIFSIGNALED&lt;/code&gt;&lt;code&gt;WTERMSIG&lt;/code&gt;&lt;code&gt;WIFSTOPPED&lt;/code&gt;&lt;code&gt;WSTOPSIG&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="913c2440e3192214324c69c5042c74731bd768ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process terminated because of a signal</source>
          <target state="translated">&lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 如果子进程由于信号而终止，则WIFSIGNALED（$ {^ CHILD_ERROR_NATIVE}）返回true</target>
        </trans-unit>
        <trans-unit id="d31cf55751c90a24957243f3a757494178f490f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process is currently stopped (can happen only if you specified the WUNTRACED flag to &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 如果子进程当前正在停止，则WIFSTOPPED（$ {^ CHILD_ERROR_NATIVE}）返回true（仅当您将WUNTRACED标志指定为 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; 时,这种情况才会发生）</target>
        </trans-unit>
        <trans-unit id="2f5c7480a044543eb0b27617a59e1b6eadff4585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns true if the child process is currently stopped (can happen only if you specified the WUNTRACED flag to &lt;code&gt;waitpid()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0ae9473f56b8cede4edc36cb20deb25c332b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WNOHANG&lt;/code&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c862071bd5aa21d5d7f098f0f89e7235360ec4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WSAEINTR&lt;/code&gt;&lt;code&gt;WSAEBADF&lt;/code&gt;&lt;code&gt;WSAEACCES&lt;/code&gt;&lt;code&gt;WSAEFAULT&lt;/code&gt;&lt;code&gt;WSAEINVAL&lt;/code&gt;&lt;code&gt;WSAEMFILE&lt;/code&gt;&lt;code&gt;WSAEWOULDBLOCK&lt;/code&gt;&lt;code&gt;WSAEINPROGRESS&lt;/code&gt;&lt;code&gt;WSAEALREADY&lt;/code&gt;&lt;code&gt;WSAENOTSOCK&lt;/code&gt;&lt;code&gt;WSAEDESTADDRREQ&lt;/code&gt;&lt;code&gt;WSAEMSGSIZE&lt;/code&gt;&lt;code&gt;WSAEPROTOTYPE&lt;/code&gt;&lt;code&gt;WSAENOPROTOOPT&lt;/code&gt;&lt;code&gt;WSAEPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;WSAESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEOPNOTSUPP&lt;/code&gt;&lt;code&gt;WSAEPFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEAFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEADDRINUSE&lt;/code&gt;&lt;code&gt;WSAEADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;WSAENETDOWN&lt;/code&gt;&lt;code&gt;WSAENETUNREACH&lt;/code&gt;&lt;code&gt;WSAENETRESET&lt;/code&gt;&lt;code&gt;WSAECONNABORTED&lt;/code&gt;&lt;code&gt;WSAECONNRESET&lt;/code&gt;&lt;code&gt;WSAENOBUFS&lt;/code&gt;&lt;code&gt;WSAEISCONN&lt;/code&gt;&lt;code&gt;WSAENOTCONN&lt;/code&gt;&lt;code&gt;WSAESHUTDOWN&lt;/code&gt;&lt;code&gt;WSAETOOMANYREFS&lt;/code&gt;&lt;code&gt;WSAETIMEDOUT&lt;/code&gt;&lt;code&gt;WSAECONNREFUSED&lt;/code&gt;&lt;code&gt;WSAELOOP&lt;/code&gt;&lt;code&gt;WSAENAMETOOLONG&lt;/code&gt;&lt;code&gt;WSAEHOSTDOWN&lt;/code&gt;&lt;code&gt;WSAEHOSTUNREACH&lt;/code&gt;&lt;code&gt;WSAENOTEMPTY&lt;/code&gt;&lt;code&gt;WSAEPROCLIM&lt;/code&gt;&lt;code&gt;WSAEUSERS&lt;/code&gt;&lt;code&gt;WSAEDQUOT&lt;/code&gt;&lt;code&gt;WSAESTALE&lt;/code&gt;&lt;code&gt;WSAEREMOTE&lt;/code&gt;&lt;code&gt;WSAEDISCON&lt;/code&gt;&lt;code&gt;WSAENOMORE&lt;/code&gt;&lt;code&gt;WSAECANCELLED&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROCTABLE&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROVIDER&lt;/code&gt;&lt;code&gt;WSAEPROVIDERFAILEDINIT&lt;/code&gt;&lt;code&gt;WSAEREFUSED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;WSAEINTR&lt;/code&gt;&lt;code&gt;WSAEBADF&lt;/code&gt;&lt;code&gt;WSAEACCES&lt;/code&gt;&lt;code&gt;WSAEFAULT&lt;/code&gt;&lt;code&gt;WSAEINVAL&lt;/code&gt;&lt;code&gt;WSAEMFILE&lt;/code&gt;&lt;code&gt;WSAEWOULDBLOCK&lt;/code&gt;&lt;code&gt;WSAEINPROGRESS&lt;/code&gt;&lt;code&gt;WSAEALREADY&lt;/code&gt;&lt;code&gt;WSAENOTSOCK&lt;/code&gt;&lt;code&gt;WSAEDESTADDRREQ&lt;/code&gt;&lt;code&gt;WSAEMSGSIZE&lt;/code&gt;&lt;code&gt;WSAEPROTOTYPE&lt;/code&gt;&lt;code&gt;WSAENOPROTOOPT&lt;/code&gt;&lt;code&gt;WSAEPROTONOSUPPORT&lt;/code&gt;&lt;code&gt;WSAESOCKTNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEOPNOTSUPP&lt;/code&gt;&lt;code&gt;WSAEPFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEAFNOSUPPORT&lt;/code&gt;&lt;code&gt;WSAEADDRINUSE&lt;/code&gt;&lt;code&gt;WSAEADDRNOTAVAIL&lt;/code&gt;&lt;code&gt;WSAENETDOWN&lt;/code&gt;&lt;code&gt;WSAENETUNREACH&lt;/code&gt;&lt;code&gt;WSAENETRESET&lt;/code&gt;&lt;code&gt;WSAECONNABORTED&lt;/code&gt;&lt;code&gt;WSAECONNRESET&lt;/code&gt;&lt;code&gt;WSAENOBUFS&lt;/code&gt;&lt;code&gt;WSAEISCONN&lt;/code&gt;&lt;code&gt;WSAENOTCONN&lt;/code&gt;&lt;code&gt;WSAESHUTDOWN&lt;/code&gt;&lt;code&gt;WSAETOOMANYREFS&lt;/code&gt;&lt;code&gt;WSAETIMEDOUT&lt;/code&gt;&lt;code&gt;WSAECONNREFUSED&lt;/code&gt;&lt;code&gt;WSAELOOP&lt;/code&gt;&lt;code&gt;WSAENAMETOOLONG&lt;/code&gt;&lt;code&gt;WSAEHOSTDOWN&lt;/code&gt;&lt;code&gt;WSAEHOSTUNREACH&lt;/code&gt;&lt;code&gt;WSAENOTEMPTY&lt;/code&gt;&lt;code&gt;WSAEPROCLIM&lt;/code&gt;&lt;code&gt;WSAEUSERS&lt;/code&gt;&lt;code&gt;WSAEDQUOT&lt;/code&gt;&lt;code&gt;WSAESTALE&lt;/code&gt;&lt;code&gt;WSAEREMOTE&lt;/code&gt;&lt;code&gt;WSAEDISCON&lt;/code&gt;&lt;code&gt;WSAENOMORE&lt;/code&gt;&lt;code&gt;WSAECANCELLED&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROCTABLE&lt;/code&gt;&lt;code&gt;WSAEINVALIDPROVIDER&lt;/code&gt;&lt;code&gt;WSAEPROVIDERFAILEDINIT&lt;/code&gt;&lt;code&gt;WSAEREFUSED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6b1ff61466d78e7b46ba9478c03225a6e4901f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WSTOPSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process was stopped for (only meaningful if &lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WSTOPSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 返回停止子进程的信号（仅在 &lt;code&gt;WIFSTOPPED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 为true 时才有意义）</target>
        </trans-unit>
        <trans-unit id="6fce0cd0fb21ad8f415dada694b22cfb2560526f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WTERMSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; returns the signal the child process terminated for (only meaningful if &lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; is true)</source>
          <target state="translated">&lt;code&gt;WTERMSIG(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 返回终止子进程的信号（仅当 &lt;code&gt;WIFSIGNALED(${^CHILD_ERROR_NATIVE})&lt;/code&gt; 为true 时才有意义）</target>
        </trans-unit>
        <trans-unit id="9280239300b5e2da4b3afad680afacc165216bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WriteFile&lt;/code&gt; takes one optional argument. When called with one argument, it expects to be passed a filename. When called with no arguments, it defaults to the filename</source>
          <target state="translated">&lt;code&gt;WriteFile&lt;/code&gt; 使用一个可选参数。当使用一个参数调用时，它希望传递一个文件名。不带参数调用时，默认为文件名</target>
        </trans-unit>
        <trans-unit id="1f09964bf66b2f253d1d0b56951b3810e5d395ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;X&amp;lt;topic name&amp;gt;&lt;/code&gt; -- an index entry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2f93eb05588029257a866afb2ec29cefadaab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;XXX&lt;/code&gt; To do: Since compatibility can depend on compile time options (such as bincompat, longlong, etc.) it should (perhaps) be set by Configure, but currently it isn't. Currently, we read a hard-wired value from</source>
          <target state="translated">&lt;code&gt;XXX&lt;/code&gt; 要做的事情：由于兼容性可能取决于编译时选项（例如bincompat，longlong等），因此（也许）应由Configure进行设置，但目前不是。目前，我们从</target>
        </trans-unit>
        <trans-unit id="1d73e9513462d0441d882a14aedf29b4d48f493f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Y&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; designating if</source>
          <target state="translated">&lt;code&gt;Y&lt;/code&gt; 或 &lt;code&gt;N&lt;/code&gt; 指定是否</target>
        </trans-unit>
        <trans-unit id="27c11c80d0abef9d58bbbf93ce2d9bb6be27b7d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; -- a null (zero-effect) formatting code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63907946795eb9d983c7251fc87f03561c9ef960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Zip64&lt;/code&gt; will be automatically set, as needed, if working with the one-shot interface when the input is either a filename or a scalar reference.</source>
          <target state="translated">&lt;code&gt;Zip64&lt;/code&gt; 如果在输入是文件名或标量引用的情况下使用单发界面，则会根据需要自动设置Zip64。</target>
        </trans-unit>
        <trans-unit id="9c080ff6a40a2d784f921c0451433798850e94e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[ ITEMS ]&lt;/code&gt; makes a new, anonymous array, and returns a reference to that array. &lt;code&gt;{ ITEMS }&lt;/code&gt; makes a new, anonymous hash, and returns a reference to that hash.</source>
          <target state="translated">&lt;code&gt;[ ITEMS ]&lt;/code&gt; 创建一个新的匿名数组，并返回对该数组的引用。 &lt;code&gt;{ ITEMS }&lt;/code&gt; 创建一个新的匿名哈希，并返回对该哈希的引用。</target>
        </trans-unit>
        <trans-unit id="1e197e33c6ccb5f4067a4525a2143eb1d616cb64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:ascii:]]&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;[[:ascii:]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f37bb18db43b263ed54e8b3969a3b7847ffee7aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[[:ascii:]]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[[:ascii:]]&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2cfa2d0098181bbefe03441d8231e81eb9677e4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\A&lt;/code&gt; only matches at the beginning of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\A/&lt;/code&gt; is equivalent to &lt;code&gt;/^/&lt;/code&gt; . However, if the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/^/&lt;/code&gt; matches internal newlines, but the meaning of &lt;code&gt;/\A/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\A&lt;/code&gt; matches at the beginning of the string regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="translated">&lt;code&gt;\A&lt;/code&gt; 仅匹配字符串的开头。如果未使用 &lt;code&gt;/m&lt;/code&gt; 修饰符，则 &lt;code&gt;/\A/&lt;/code&gt; 等效于 &lt;code&gt;/^/&lt;/code&gt; 。但是，如果使用了 &lt;code&gt;/m&lt;/code&gt; 修饰符，则 &lt;code&gt;/^/&lt;/code&gt; 匹配内部换行符，但 &lt;code&gt;/m&lt;/code&gt; 的含义不会更改 &lt;code&gt;/\A/&lt;/code&gt; 的含义。 &lt;code&gt;\A&lt;/code&gt; 匹配字符串的开头，无论是否使用 &lt;code&gt;/m&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="e50f906321e007a37b63b827ace3fa35f352a0f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\A&lt;/code&gt; only matches at the beginning of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\A/&lt;/code&gt; is equivalent to &lt;code&gt;/^/&lt;/code&gt;. However, if the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/^/&lt;/code&gt; matches internal newlines, but the meaning of &lt;code&gt;/\A/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\A&lt;/code&gt; matches at the beginning of the string regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f53fba386e9c1d0f782db562212650e214f36ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\D&lt;/code&gt; is a negated &lt;code&gt;\d&lt;/code&gt;; it represents any other character than a digit, or &lt;code&gt;[^\d]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef23e4d1b4ae86eeb209dd5770450d03008a5b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\F&lt;/code&gt; can be used to casefold all characters following, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. It provides the functionality similar to the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;\F&lt;/code&gt; 可以用于折叠所有字符，直到下一个 &lt;code&gt;\E&lt;/code&gt; 或模式结尾。它提供的功能类似于 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="365839803ed113e88d1e4c38934367dd708136e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\F&lt;/code&gt; can be used to casefold all characters following, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. It provides the functionality similar to the &lt;code&gt;fc&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29175559120891c17a696d6942f87d50d6868998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is also invaluable in processing fixed-length records with regexps. Suppose we have a snippet of coding region DNA, encoded as base pair letters &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; and we want to find all the stop codons &lt;code&gt;TGA&lt;/code&gt; . In a coding region, codons are 3-letter sequences, so we can think of the DNA snippet as a sequence of 3-letter records. The naive regexp</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 在使用正则表达式处理定长记录时也非常有用。假设我们有一个编码区DNA的片段，编码为碱基对字母 &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; ，我们想找到所有的终止密码子 &lt;code&gt;TGA&lt;/code&gt; 。在编码区中，密码子是3个字母的序列，因此我们可以将DNA片段视为3个字母的记录的序列。天真的regexp</target>
        </trans-unit>
        <trans-unit id="1dd50305d5ec65e04a41dcb9f7d034a715808afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is also invaluable in processing fixed-length records with regexps. Suppose we have a snippet of coding region DNA, encoded as base pair letters &lt;code&gt;ATCGTTGAAT...&lt;/code&gt; and we want to find all the stop codons &lt;code&gt;TGA&lt;/code&gt;. In a coding region, codons are 3-letter sequences, so we can think of the DNA snippet as a sequence of 3-letter records. The naive regexp</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc01fdb07dcb48f3990f7e9986cc181c1d1aa3c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; is usually used only in combination with the &lt;code&gt;/g&lt;/code&gt; modifier. If the &lt;code&gt;/g&lt;/code&gt; modifier is used and the match is done in scalar context, Perl remembers where in the source string the last match ended, and the next time, it will start the match from where it ended the previous time.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 通常仅与 &lt;code&gt;/g&lt;/code&gt; 修饰符结合使用。如果使用了 &lt;code&gt;/g&lt;/code&gt; 修饰符，并且匹配是在标量上下文中完成的，则Perl会记住上一次匹配在源字符串中的结束位置，下次，它将从上一次结束的位置开始进行匹配。</target>
        </trans-unit>
        <trans-unit id="fab760e95f43824629065b7030ad07437049f251" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\G&lt;/code&gt; matches the point where the previous match on that string ended, or the beginning of that string if there was no previous match.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 匹配该字符串上一次匹配结束的点，如果没有先前的匹配，则匹配该字符串的开头。</target>
        </trans-unit>
        <trans-unit id="caee3f50983ee96aea6298365c6e4a735aeffd91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; , and &lt;code&gt;\Q&lt;/code&gt; can stack, in which case you need one &lt;code&gt;\E&lt;/code&gt; for each. For example:</source>
          <target state="translated">&lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\F&lt;/code&gt; 和 &lt;code&gt;\Q&lt;/code&gt; 可以堆叠，在这种情况下，每个需要一个 &lt;code&gt;\E&lt;/code&gt; 例如：</target>
        </trans-unit>
        <trans-unit id="5909711f4ae861799ae1fae7c311412305b8ff53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt;, and &lt;code&gt;\Q&lt;/code&gt; can stack, in which case you need one &lt;code&gt;\E&lt;/code&gt; for each. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b715a8c878ff64b76422f5de0db4d867e6df23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; , available starting in v5.12, like the dot, matches any character that is not a newline. The difference is that &lt;code&gt;\N&lt;/code&gt; is not influenced by the</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; 从v5.12开始可用，例如点，可以匹配不是换行符的任何字符。区别在于 &lt;code&gt;\N&lt;/code&gt; 不受</target>
        </trans-unit>
        <trans-unit id="80779fa1da204f29defd5bf097dbba87c9107e16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt; within a bracketed character class must be of the forms &lt;code&gt;\N{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, and NOT be the form that matches non-newlines, for the same reason that a dot &lt;code&gt;.&lt;/code&gt; inside a bracketed character class loses its special meaning: it matches nearly anything, which generally isn't what you want to happen.</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; 加括号的字符类中必须是形式的 &lt;code&gt;\N{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; 或 &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; 和NOT是匹配的非换行符，出于同样的原因，一个点的形式 &lt;code&gt;.&lt;/code&gt; 放在方括号中的字符类将失去其特殊含义：它几乎匹配任何内容，通常这不是您想要发生的事情。</target>
        </trans-unit>
        <trans-unit id="e6d81a41dd89c6b0d1f649e117d863c99956c556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt;, available starting in v5.12, like the dot, matches any character that is not a newline. The difference is that &lt;code&gt;\N&lt;/code&gt; is not influenced by the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b5f532beea0b3b2b86d420fa419b0ed4b659f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N&lt;/code&gt;, like the period, matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt;, but it does so regardless of whether the modifier &lt;code&gt;/s&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2706754019f77a1fbbc94bb64673d2224cda545c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\N{U+&lt;i&gt;hexadecimal number&lt;/i&gt;}&lt;/code&gt; means the Unicode character whose Unicode code point is</source>
          <target state="translated">&lt;code&gt;\N{U+&lt;i&gt;hexadecimal number&lt;/i&gt;}&lt;/code&gt; 表示Unicode代码点为的Unicode字符</target>
        </trans-unit>
        <trans-unit id="3d883253a04efed05a5ba1744b87b2c80c0e4bf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; are actually part of double-quotish syntax, and not part of regexp syntax proper. They will work if they appear in a regular expression embedded directly in a program, but not when contained in a string that is interpolated in a pattern.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 实际上是双引号语法的一部分，而不是正则表达式语法的一部分。如果它们出现在直接嵌入程序中的正则表达式中，则它们将起作用，但是当包含在模式中插入的字符串中时，它们将不会起作用。</target>
        </trans-unit>
        <trans-unit id="b7ed1242ac7474e94b7458c0ba21e510aab5efa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\F&lt;/code&gt; (possibly paired with &lt;code&gt;\E&lt;/code&gt; ) are converted to corresponding Perl constructs. Thus, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; is converted to &lt;code&gt;$foo . (&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;(&quot;baz&quot; . $bar))&lt;/code&gt; internally. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are replaced with appropriate expansions.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\l&lt;/code&gt; ， &lt;code&gt;\F&lt;/code&gt; （可能与 &lt;code&gt;\E&lt;/code&gt; 配对）被转换为相应的Perl构造。因此， &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; 将转换为 &lt;code&gt;$foo . (&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;(&quot;baz&quot; . $bar))&lt;/code&gt; 内部。其他转义序列（例如 &lt;code&gt;\200&lt;/code&gt; 和 &lt;code&gt;\t&lt;/code&gt; 和反斜杠字符（例如 &lt;code&gt;\\&lt;/code&gt; 和 &lt;code&gt;\-&lt;/code&gt; )将替换为适当的扩展名。</target>
        </trans-unit>
        <trans-unit id="ad0b64315a3fe9c58415fa16564b8e316472bbe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; is used to quote (disable) pattern metacharacters, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. &lt;code&gt;\Q&lt;/code&gt; adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt; for details on what gets quoted for non-ASCII code points. Using this ensures that any character between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; will be matched literally, not interpreted as a metacharacter by the regex engine.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; 用于引用（禁用）模式元字符，直至下一个 &lt;code&gt;\E&lt;/code&gt; 或模式结尾。 &lt;code&gt;\Q&lt;/code&gt; 在可能对Perl具有特殊含义的任何字符上添加一个反斜杠。在ASCII范围内，它引用不是字母，数字或下划线的每个字符。有关非ASCII代码点引用内容的详细信息，请参见&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;。使用此选项可确保 &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 之间的任何字符都将按字面意义进行匹配，而正则表达式引擎不会将其解释为元字符。</target>
        </trans-unit>
        <trans-unit id="b2d3b5ecfda1f481831379606005c6fdc0235a92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt; is used to quote (disable) pattern metacharacters, up to the next &lt;code&gt;\E&lt;/code&gt; or the end of the pattern. &lt;code&gt;\Q&lt;/code&gt; adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn't a letter, digit, or underscore. See &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt; for details on what gets quoted for non-ASCII code points. Using this ensures that any character between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; will be matched literally, not interpreted as a metacharacter by the regex engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9799ed12cbfcbc248ce704b4b60109bd99ced67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; are actually part of double-quotish syntax, and not part of regexp syntax proper. They will work if they appear in a regular expression embedded directly in a program, but not when contained in a string that is interpolated in a pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b2da020c4ab183ef1012c1e82d0c6206ed9968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\Q&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\F&lt;/code&gt; (possibly paired with &lt;code&gt;\E&lt;/code&gt;) are converted to corresponding Perl constructs. Thus, &lt;code&gt;&quot;$foo\Qbaz$bar&quot;&lt;/code&gt; is converted to &lt;code&gt;$foo . (quotemeta(&quot;baz&quot; . $bar))&lt;/code&gt; internally. The other escape sequences such as &lt;code&gt;\200&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; and backslashed characters such as &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\-&lt;/code&gt; are replaced with appropriate expansions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fdb89c706826e363f4d1a15c85386d62762386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches a</source>
          <target state="translated">&lt;code&gt;\R&lt;/code&gt; 匹配一个</target>
        </trans-unit>
        <trans-unit id="8ffa61af84fa5204640b2d3a9297ad766cd2302f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\R&lt;/code&gt; matches anything that can be considered a newline under Unicode rules. It can match a multi-character sequence. It cannot be used inside a bracketed character class; use &lt;code&gt;\v&lt;/code&gt; instead (vertical whitespace). It uses the platform's native character set, and does not consider any locale that may otherwise be in use. Details are discussed in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\R&lt;/code&gt; 匹配在Unicode规则下可以视为换行符的任何内容。它可以匹配一个多字符序列。不能在带括号的字符类中使用；使用 &lt;code&gt;\v&lt;/code&gt; 代替（垂直空格）。它使用平台的本机字符集，并且不考虑可能会使用的任何语言环境。有关详细信息，请&lt;a href=&quot;perlrebackslash&quot;&gt;参见perlrebackslash&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a06cae4c5b667f92e564253136f924fbd5c999da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\S&lt;/code&gt; is a negated &lt;code&gt;\s&lt;/code&gt;; it represents any non-whitespace character &lt;code&gt;[^\s]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9219cc84269298f3472b27e9a771ce07439ec14c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\W&lt;/code&gt; is a negated &lt;code&gt;\w&lt;/code&gt;; it represents any non-word character &lt;code&gt;[^\w]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c079457c2c94c9296bb94d74fe70faff7c8e990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; is an abbreviation for a character class that comprises a Unicode</source>
          <target state="translated">&lt;code&gt;\X&lt;/code&gt; 是包含Unicode的字符类的缩写</target>
        </trans-unit>
        <trans-unit id="55e23bb607e060dee7b3f1229c353a21e48fea15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\X&lt;/code&gt; matches quite well what normal (non-Unicode-programmer) usage would consider a single character. As an example, consider a G with some sort of diacritic mark, such as an arrow. There is no such single character in Unicode, but one can be composed by using a G followed by a Unicode &quot;COMBINING UPWARDS ARROW BELOW&quot;, and would be displayed by Unicode-aware software as if it were a single character.</source>
          <target state="translated">&lt;code&gt;\X&lt;/code&gt; 与正常情况下（非Unicode程序员）使用单个字符的匹配非常好。例如，考虑带有某种变音符号的G，例如箭头。Unicode中没有这样的单个字符，但是可以使用G后面跟一个Unicode&amp;ldquo; COMBINING UPWARDS ARROW BELOW&amp;rdquo;，然后由Unicode感知软件将其显示为单个字符来组成一个字符。</target>
        </trans-unit>
        <trans-unit id="34d7b3ea79034dbcabd4d97597212e6ab2de3c37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; . This matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 。这匹配单词字符和非单词字符 &lt;code&gt;\w\W&lt;/code&gt; 或 &lt;code&gt;\W\w&lt;/code&gt; 之间的边界：</target>
        </trans-unit>
        <trans-unit id="d75241b44033641bce1ae791eaa2652fadc31474" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; and &lt;code&gt;\B&lt;/code&gt; assume there's a non-word character before the beginning and after the end of the source string; so &lt;code&gt;\b&lt;/code&gt; will match at the beginning (or end) of the source string if the source string begins (or ends) with a word character. Otherwise, &lt;code&gt;\B&lt;/code&gt; will match.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 和 &lt;code&gt;\B&lt;/code&gt; 假定在源字符串的开头和结尾之前有一个非单词字符；因此，如果源字符串以单词字符开头（或结尾）， &lt;code&gt;\b&lt;/code&gt; 将在源字符串的开头（或结尾）匹配。否则， &lt;code&gt;\B&lt;/code&gt; 将匹配。</target>
        </trans-unit>
        <trans-unit id="6dc4a462570407b89d8c1b47db7b8c34eb82f528" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; is the backspace character only inside a character class. Outside a character class, &lt;code&gt;\b&lt;/code&gt; alone is a word-character/non-word-character boundary, and &lt;code&gt;\b{}&lt;/code&gt; is some other type of boundary.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 是仅在字符类内部的退格字符。在字符类之外，单独的 &lt;code&gt;\b&lt;/code&gt; 是单词字符/非单词字符的边界，而 &lt;code&gt;\b{}&lt;/code&gt; 是其他类型的边界。</target>
        </trans-unit>
        <trans-unit id="7c4c255a44ab388eea9df94821b04725a1eb1239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between a word (something matched by &lt;code&gt;\w&lt;/code&gt; ) and a non-word character (&lt;code&gt;\W&lt;/code&gt; ); &lt;code&gt;\B&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b&lt;/code&gt; doesn't match. To get better word matching of natural language text, see \b{wb} below.</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; 当单词（由 &lt;code&gt;\w&lt;/code&gt; 匹配的内容）与非单词字符（ &lt;code&gt;\W&lt;/code&gt; ）之间的任意位置不立即匹配时，则不紧跟 &lt;code&gt;&quot;{&quot;&lt;/code&gt; ； &lt;code&gt;\B&lt;/code&gt; 当没有紧跟一个 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 匹配在其中的字符之间的任何地方 &lt;code&gt;\b&lt;/code&gt; 不匹配。为了更好地匹配自然语言文本，请参见下面的\ b {wb}。</target>
        </trans-unit>
        <trans-unit id="02a3a101dc7c6ce41ce7dac0f8acb2a72c03768d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between a word (something matched by &lt;code&gt;\w&lt;/code&gt;) and a non-word character (&lt;code&gt;\W&lt;/code&gt;); &lt;code&gt;\B&lt;/code&gt; when not immediately followed by a &lt;code&gt;&quot;{&quot;&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b&lt;/code&gt; doesn't match. To get better word matching of natural language text, see &lt;a href=&quot;#%5Cb%7Bwb%7D&quot;&gt;&quot;\b{wb}&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9cb1f2f5a9aaa3621bb6a3914daee2f66d97c91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt;. This matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5781002df3a961ccd9eb514485a027a250771de9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{...}&lt;/code&gt; , available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The currently known boundary types are given a few paragraphs below. &lt;code&gt;\B{...}&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b{...}&lt;/code&gt; of the same type doesn't match.</source>
          <target state="translated">&lt;code&gt;\b{...}&lt;/code&gt; 从v5.22开始可用的\ b {...}根据边界类型的Unicode规则匹配边界（两个字符之间，或字符串的第一个字符之前，或字符串的最后一个字符之后）大括号内指定。下面几段给出了当前已知的边界类型。 &lt;code&gt;\B{...}&lt;/code&gt; 在相同类型的 &lt;code&gt;\b{...}&lt;/code&gt; 不匹配的字符之间的任何位置匹配。</target>
        </trans-unit>
        <trans-unit id="5254c153c7a9a13ecdcba15f421c507a50c055a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{...}&lt;/code&gt;, available starting in v5.22, matches a boundary (between two characters, or before the first character of the string, or after the final character of the string) based on the Unicode rules for the boundary type specified inside the braces. The boundary types are given a few paragraphs below. &lt;code&gt;\B{...}&lt;/code&gt; matches at any place between characters where &lt;code&gt;\b{...}&lt;/code&gt; of the same type doesn't match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d397b8738e99fa32effd6fc49a759f69d58d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b{gcb}&lt;/code&gt; or &lt;code&gt;\b{g}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e43fb282e8b27b2619badf10578d9a503c1e675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; is used to denote a control character; the character following &lt;code&gt;\c&lt;/code&gt; determines the value of the construct. For example the value of &lt;code&gt;\cA&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, and the value of &lt;code&gt;\cb&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(2)&lt;/a&gt;&lt;/code&gt;, etc. The gory details are in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. A complete list of what &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. means for ASCII and EBCDIC platforms is in &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\c&lt;/code&gt; 用于表示控制字符； &lt;code&gt;\c&lt;/code&gt; 后面的字符确定构造的值。例如， &lt;code&gt;\cA&lt;/code&gt; 的值是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;\cb&lt;/code&gt; 的值是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(2)&lt;/a&gt;&lt;/code&gt; ，等等。详细信息&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perlop&lt;/a&gt;中的Regexp Quote-Like运算符中。&lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;在perlebcdic的OPERATOR DIFFERENCES中&lt;/a&gt;，有关ASCII和EBCDIC平台的 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; 等含义的完整列表。</target>
        </trans-unit>
        <trans-unit id="7f8369187d869841fa9df7d04e998ab51ca1871a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\c&lt;/code&gt; is used to denote a control character; the character following &lt;code&gt;\c&lt;/code&gt; determines the value of the construct. For example the value of &lt;code&gt;\cA&lt;/code&gt; is &lt;code&gt;chr(1)&lt;/code&gt;, and the value of &lt;code&gt;\cb&lt;/code&gt; is &lt;code&gt;chr(2)&lt;/code&gt;, etc. The gory details are in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. A complete list of what &lt;code&gt;chr(1)&lt;/code&gt;, etc. means for ASCII and EBCDIC platforms is in &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b703fe9d5ec022fd6b34eba05b9bfd296c7a519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; matches a digit, not just &lt;code&gt;[0-9]&lt;/code&gt; but also digits from non-roman scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a0ca0d9ef67cf04ea6ca6b5bd701f43d0336bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; matches a single character considered to be a decimal</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 与被认为是十进制的单个字符匹配</target>
        </trans-unit>
        <trans-unit id="428b825cb343a5c9509774542fc16bc60189535f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0) is used for relative addressing. (It can be written as &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt;.) It refers to the</source>
          <target state="translated">&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; （从Perl 5.10.0开始）用于相对寻址。（可以写为 &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 。）它是指</target>
        </trans-unit>
        <trans-unit id="5d621328865d134486d37d521b1b45ba19a42975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g-&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0) is used for relative addressing. (It can be written as &lt;code&gt;\g{-&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt;.) It refers to the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad3328b2720f5bc3f94fe796543159d6af46703a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; ,... Backreferences are simply matching variables that can be used</source>
          <target state="translated">&lt;code&gt;\g1&lt;/code&gt; ， &lt;code&gt;\g2&lt;/code&gt; ，...向后引用只是可以使用的匹配变量</target>
        </trans-unit>
        <trans-unit id="e147c50c59c0f13ef05885d480813a22104b20ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;,... Backreferences are simply matching variables that can be used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33ee556e38924ce3e6215adbca979c4cfab3cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; (starting in Perl 5.10.0) can be used to back refer to a named capture group, dispensing completely with having to think about capture buffer positions.</source>
          <target state="translated">&lt;code&gt;\g{&lt;i&gt;name&lt;/i&gt;}&lt;/code&gt; （从Perl 5.10.0开始）可用于反向引用已命名的捕获组，从而省去了必须考虑捕获缓冲区位置的麻烦。</target>
        </trans-unit>
        <trans-unit id="3acb4bd92904b84995c318e676ce7b840ab01ca4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\h&lt;/code&gt; matches any character considered horizontal whitespace; this includes the platform's space and tab characters and several others listed in the table below. &lt;code&gt;\H&lt;/code&gt; matches any character not considered horizontal whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="translated">&lt;code&gt;\h&lt;/code&gt; 匹配被视为水平空白的任何字符；这包括平台的空格和制表符以及下表中列出的其他几个字符。 &lt;code&gt;\H&lt;/code&gt; 匹配任何不被视为水平空白的字符。他们使用平台的本机字符集，并且不考虑可能会使用的任何语言环境。</target>
        </trans-unit>
        <trans-unit id="f48e53b9236a29c7807d180f9e942a8de2e93b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; matches a logical newline. Perl converts between &lt;code&gt;\n&lt;/code&gt; and your OS's native newline character when reading from or writing to text files.</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; 匹配逻辑换行符。在读取或写入文本文件时，Perl在 &lt;code&gt;\n&lt;/code&gt; 和操作系统的本机换行符之间转换。</target>
        </trans-unit>
        <trans-unit id="bbb9812a2f255e06ab4f64b927320bb9082a1028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; (where &lt;code&gt;P&lt;/code&gt; is a single letter) and &lt;code&gt;\p{Property}&lt;/code&gt; are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to &lt;code&gt;\PP&lt;/code&gt; and &lt;code&gt;\P{Property}&lt;/code&gt; make the sequence match a character that doesn't match the given Unicode property. For more details, see &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;&quot;Backslash sequences&quot; in perlrecharclass&lt;/a&gt; and &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;&quot;Unicode Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47a61f1d11f4dbc31ff29f399c1b03054d85480" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; (where &lt;code&gt;P&lt;/code&gt; is a single letter) and &lt;code&gt;\p{Property}&lt;/code&gt; are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to &lt;code&gt;\PP&lt;/code&gt; and &lt;code&gt;\P{Property}&lt;/code&gt; make the sequence match a character that doesn't match the given Unicode property. For more details, see &lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;Backslash sequences in perlrecharclass&lt;/a&gt; and &lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;Unicode Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\pP&lt;/code&gt; （其中 &lt;code&gt;P&lt;/code&gt; 是单个字母）和 &lt;code&gt;\p{Property}&lt;/code&gt; 用于匹配与给定Unicode属性匹配的字符；属性包括&amp;ldquo;字母&amp;rdquo;或&amp;ldquo;泰国字符&amp;rdquo;之类的内容。将序列大写为 &lt;code&gt;\PP&lt;/code&gt; 和 &lt;code&gt;\P{Property}&lt;/code&gt; 可使序列匹配与给定Unicode属性不匹配的字符。有关详细信息，请参阅&lt;a href=&quot;perlrecharclass#Backslash-sequences&quot;&gt;在perlrecharclass反斜杠序列&lt;/a&gt;，并&lt;a href=&quot;perlunicode#Unicode-Character-Properties&quot;&gt;在perlunicode Unicode字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d84c55ace76e1ff0519f5aac6666720a80072bd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; and &lt;code&gt;\p{Prop}&lt;/code&gt; are character classes to match characters that fit given Unicode properties. One letter property names can be used in the &lt;code&gt;\pP&lt;/code&gt; form, with the property name following the &lt;code&gt;\p&lt;/code&gt; , otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like &lt;code&gt;\p{name=value}&lt;/code&gt; , which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as &lt;code&gt;/\pN/&lt;/code&gt; or as &lt;code&gt;/\p{Number}/&lt;/code&gt; , or as &lt;code&gt;/\p{Number=True}/&lt;/code&gt; . Lowercase letters are matched by the property</source>
          <target state="translated">&lt;code&gt;\pP&lt;/code&gt; 和 &lt;code&gt;\p{Prop}&lt;/code&gt; 是字符类，用于匹配适合给定Unicode属性的字符。可以以 &lt;code&gt;\pP&lt;/code&gt; 格式使用一个字母的属性名称，该属性名称后跟 &lt;code&gt;\p&lt;/code&gt; ，否则必须使用花括号。使用花括号时，只有一个形式，即括号中包含的属性名称，而复合形式看起来像 &lt;code&gt;\p{name=value}&lt;/code&gt; ，这意味着如果字符的属性&amp;ldquo; name&amp;rdquo;具有该特定的&amp;ldquo;值&amp;rdquo;。例如，数字的匹配项可以写为 &lt;code&gt;/\pN/&lt;/code&gt; 或 &lt;code&gt;/\p{Number}/&lt;/code&gt; 或 &lt;code&gt;/\p{Number=True}/&lt;/code&gt; 。小写字母由属性匹配</target>
        </trans-unit>
        <trans-unit id="098dbbc62b16ee5d92c2a2b0fc0e6743a9b88819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\pP&lt;/code&gt; and &lt;code&gt;\p{Prop}&lt;/code&gt; are character classes to match characters that fit given Unicode properties. One letter property names can be used in the &lt;code&gt;\pP&lt;/code&gt; form, with the property name following the &lt;code&gt;\p&lt;/code&gt;, otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like &lt;code&gt;\p{name=value}&lt;/code&gt;, which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as &lt;code&gt;/\pN/&lt;/code&gt; or as &lt;code&gt;/\p{Number}/&lt;/code&gt;, or as &lt;code&gt;/\p{Number=True}/&lt;/code&gt;. Lowercase letters are matched by the property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85149b0f3a91ea78c71d331abbaa6fc18476f335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{Blank}&lt;/code&gt; and &lt;code&gt;\p{HorizSpace}&lt;/code&gt; are synonyms.</source>
          <target state="translated">&lt;code&gt;\p{Blank}&lt;/code&gt; 和 &lt;code&gt;\p{HorizSpace}&lt;/code&gt; 是同义词。</target>
        </trans-unit>
        <trans-unit id="25c9fecf27d0a09b0629761f6ae905625678010b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{PosixPunct}&lt;/code&gt; and &lt;code&gt;[[:punct:]]&lt;/code&gt; in the ASCII range match all non-controls, non-alphanumeric, non-space characters: &lt;code&gt;[-!&quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]^_`{|}~]&lt;/code&gt; (although if a locale is in effect, it could alter the behavior of &lt;code&gt;[[:punct:]]&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;\p{PosixPunct}&lt;/code&gt; ASCII范围内的\ p {PosixPunct}和 &lt;code&gt;[[:punct:]]&lt;/code&gt; 与所有非控件，非字母数字，非空格字符匹配： &lt;code&gt;[-!&quot;#$%&amp;amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]^_`{|}~]&lt;/code&gt; （尽管有效的语言环境可能会改变 &lt;code&gt;[[:punct:]]&lt;/code&gt; 的行为）。</target>
        </trans-unit>
        <trans-unit id="755edd19d42bc00d2d42f52db8c39e41d61b74f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; and &lt;code&gt;\p{Space}&lt;/code&gt; match identically starting with Perl v5.18. In earlier versions, these differ only in that in non-locale matching, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; did not match the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . Same for the two ASCII-only range forms.</source>
          <target state="translated">&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; 从Perl v5.18开始，\ p {XPerlSpace}和 &lt;code&gt;\p{Space}&lt;/code&gt; 完全相同。在早期版本中，这些区别仅在于非语言环境匹配 &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; 与垂直选项卡 &lt;code&gt;\cK&lt;/code&gt; 不匹配。对于两个仅ASCII范围形式相同。</target>
        </trans-unit>
        <trans-unit id="ee6e8fa4e9c9641c6848540794bf24bd1ff86f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPerlSpace}&lt;/code&gt; and &lt;code&gt;\p{Space}&lt;/code&gt; match identically starting with Perl v5.18. In earlier versions, these differ only in that in non-locale matching, &lt;code&gt;\p{XPerlSpace}&lt;/code&gt; did not match the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. Same for the two ASCII-only range forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bf92acce79d5b5002afaba6916dbd6bb155338" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; and (under Unicode rules) &lt;code&gt;[[:punct:]]&lt;/code&gt;, match what &lt;code&gt;\p{PosixPunct}&lt;/code&gt; matches in the ASCII range, plus what &lt;code&gt;\p{Punct}&lt;/code&gt; matches. This is different than strictly matching according to &lt;code&gt;\p{Punct}&lt;/code&gt; . Another way to say it is that if Unicode rules are in effect, &lt;code&gt;[[:punct:]]&lt;/code&gt; matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</source>
          <target state="translated">&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; 和（根据Unicode规则） &lt;code&gt;[[:punct:]]&lt;/code&gt; ，匹配 &lt;code&gt;\p{PosixPunct}&lt;/code&gt; 在ASCII范围内匹配的内容，再匹配 &lt;code&gt;\p{Punct}&lt;/code&gt; 。这与根据 &lt;code&gt;\p{Punct}&lt;/code&gt; 严格匹配不同。换句话说，如果Unicode规则有效，则 &lt;code&gt;[[:punct:]]&lt;/code&gt; 匹配Unicode认为标点的所有字符，以及Unicode认为符号的所有ASCII范围字符。</target>
        </trans-unit>
        <trans-unit id="218f42f116c5754d91ca08dc27a0759faa30d3d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\p{XPosixPunct}&lt;/code&gt; and (under Unicode rules) &lt;code&gt;[[:punct:]]&lt;/code&gt;, match what &lt;code&gt;\p{PosixPunct}&lt;/code&gt; matches in the ASCII range, plus what &lt;code&gt;\p{Punct}&lt;/code&gt; matches. This is different than strictly matching according to &lt;code&gt;\p{Punct}&lt;/code&gt;. Another way to say it is that if Unicode rules are in effect, &lt;code&gt;[[:punct:]]&lt;/code&gt; matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3cef3a5e22571510fa5a04adc6bd52e2e9e07c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . (See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.) Note that this list doesn't include the non-breaking space.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 匹配[\ t \ n \ f \ r]，从Perl v5.18开始，垂直标签为 &lt;code&gt;\cK&lt;/code&gt; 。（有关此内容的讨论，请参见下面的注释 &lt;code&gt;[1]&lt;/code&gt; 。）请注意，此列表不包含不间断的空格。</target>
        </trans-unit>
        <trans-unit id="899af5f086bd5390390892789adbfc29fa69cfb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches [\t\n\f\r ] and, starting in Perl v5.18, the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. (See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.) Note that this list doesn't include the non-breaking space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3e843f9e7609a6b386f439f2b807f775b93a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches a whitespace character, the set &lt;code&gt;[\ \t\r\n\f]&lt;/code&gt; and others</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ad191b59c68476309e8cdff37277905b3d644e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches any single character considered whitespace.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 匹配被视为空格的任何单个字符。</target>
        </trans-unit>
        <trans-unit id="164846db6b825e570c0d7edc2e8e99d0a8cd9c3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the characters shown with an &quot;s&quot; column in the table below.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 完全匹配下表中用&amp;ldquo; s&amp;rdquo;列显示的字符。</target>
        </trans-unit>
        <trans-unit id="dfe6b3493a7e126712936240780ab43a7647b5c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches exactly the code points above 255 shown with an &quot;s&quot; column in the table below.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 与下表中用&amp;ldquo; s&amp;rdquo;列显示的255以上的代码点完全匹配。</target>
        </trans-unit>
        <trans-unit id="53c42afe9cf980295f6ccaddc4816a2d0390a04f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; matches whatever the locale considers to be whitespace.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 匹配任何语言环境认为是空格的地方。</target>
        </trans-unit>
        <trans-unit id="e17398607beae9e16f5d507bd2de1c2792253d60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; matches any character considered vertical whitespace; this includes the platform's carriage return and line feed characters (newline) plus several other characters, all listed in the table below. &lt;code&gt;\V&lt;/code&gt; matches any character not considered vertical whitespace. They use the platform's native character set, and do not consider any locale that may otherwise be in use.</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; 匹配被视为垂直空格的任何字符；这包括平台的回车符和换行符（换行符）以及其他几个字符，所有这些字符均列在下表中。 &lt;code&gt;\V&lt;/code&gt; 匹配任何不被视为垂直空格的字符。他们使用平台的本机字符集，并且不考虑可能会使用的任何语言环境。</target>
        </trans-unit>
        <trans-unit id="e84d6b7c93d52f35bcd484412e96304ddb465e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; can be used to match a Japanese ideograph, for instance; and &lt;code&gt;[[:digit:]]&lt;/code&gt; a Bengali number.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 可用于匹配日本表意文字；和 &lt;code&gt;[[:digit:]]&lt;/code&gt; 孟加拉数字。</target>
        </trans-unit>
        <trans-unit id="12b56560fcb8e649f2853269006af953eb9769e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; is a character class that matches any single</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 是与任何单个字符匹配的字符类</target>
        </trans-unit>
        <trans-unit id="48cb702e25188808179cd08641633cb28eaa0eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches [a-zA-Z0-9_].</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 匹配[a-zA-Z0-9_]。</target>
        </trans-unit>
        <trans-unit id="a751c502830d54a0d9d3ca25fa6632bc343a71c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches a word character (alphanumeric or &lt;code&gt;'_'&lt;/code&gt;), not just &lt;code&gt;[0-9a-zA-Z_]&lt;/code&gt; but also digits and characters from non-roman scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2fd3f12a256fac6c8c475c41016b746e332589d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches exactly what &lt;code&gt;\p{Word}&lt;/code&gt; matches.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 与 &lt;code&gt;\p{Word}&lt;/code&gt; 匹配。</target>
        </trans-unit>
        <trans-unit id="fbdee4d0daab297bf0961e4ccefe2a5955a8d76f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the 63 characters [a-zA-Z0-9_].</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 匹配63个字符[a-zA-Z0-9_]。</target>
        </trans-unit>
        <trans-unit id="eb954d084b4018682f968a2007d9fb696787dd4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the platform's native underscore character plus whatever the locale considers to be alphanumeric.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 与平台的本机下划线字符以及语言环境认为是字母数字的任何字符匹配。</target>
        </trans-unit>
        <trans-unit id="1175cf96f88bb9109cfcdb274bab554078c0da6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\w&lt;/code&gt; matches the same as &lt;code&gt;\p{Word}&lt;/code&gt; matches in this range. That is, it matches Thai letters, Greek letters, etc. This includes connector punctuation (like the underscore) which connect two words together, or diacritics, such as a &lt;code&gt;COMBINING TILDE&lt;/code&gt; and the modifier letters, which are generally used to add auxiliary markings to letters.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 在此范围内与 &lt;code&gt;\p{Word}&lt;/code&gt; 匹配相同。也就是说，它匹配泰语字母，希腊字母等。这包括将两个单词连接在一起的连接器标点符号（例如下划线），或变音符号，例如 &lt;code&gt;COMBINING TILDE&lt;/code&gt; 和修饰符字母，通常用于在其上添加辅助标记字母。</target>
        </trans-unit>
        <trans-unit id="fdf252af84459ebbc3355f5052e1c483febc2e96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{}&lt;/code&gt; and &lt;code&gt;\o{}&lt;/code&gt; can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; for code points less than 256.</source>
          <target state="translated">&lt;code&gt;\x{}&lt;/code&gt; 和 &lt;code&gt;\o{}&lt;/code&gt; 也可以用于在编译时以双引号字符串指定代码点，但是，为了与较早的Perls向后兼容，对于小于256的代码点，应使用与 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; 相同的规则。</target>
        </trans-unit>
        <trans-unit id="76c959405321ee93f9b650cda58480e255b74a80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{}&lt;/code&gt; and &lt;code&gt;\o{}&lt;/code&gt; can also be used to specify code points at compile time in double-quotish strings, but, for backward compatibility with older Perls, the same rules apply as with &lt;code&gt;chr()&lt;/code&gt; for code points less than 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe4cad9ff217e9c6a9d88999a2c91a4805e6cd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; match at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\Z/&lt;/code&gt; is equivalent to &lt;code&gt;/$/&lt;/code&gt; ; that is, it matches at the end of the string, or one before the newline at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/$/&lt;/code&gt; matches at internal newlines, but the meaning of &lt;code&gt;/\Z/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\Z&lt;/code&gt; matches at the end of the string (or just before a trailing newline) regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="translated">&lt;code&gt;\z&lt;/code&gt; 和 &lt;code&gt;\Z&lt;/code&gt; 在字符串末尾匹配。如果未使用 &lt;code&gt;/m&lt;/code&gt; 修饰符，则 &lt;code&gt;/\Z/&lt;/code&gt; 等效于 &lt;code&gt;/$/&lt;/code&gt; ;也就是说，它在字符串的末尾匹配，或者在字符串的末尾在换行符之前匹配。如果使用了 &lt;code&gt;/m&lt;/code&gt; 修饰符，则 &lt;code&gt;/$/&lt;/code&gt; 在内部换行符处匹配，但 &lt;code&gt;/m&lt;/code&gt; &lt;code&gt;/\Z/&lt;/code&gt; 不会改变/ \ Z /的含义。不管是否使用 &lt;code&gt;/m&lt;/code&gt; 修饰符， &lt;code&gt;\Z&lt;/code&gt; 将在字符串末尾（或紧跟在换行符之后）匹配。</target>
        </trans-unit>
        <trans-unit id="624cd6975bec00d59c30751190892372b771ed6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; and &lt;code&gt;\Z&lt;/code&gt; match at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier isn't used, then &lt;code&gt;/\Z/&lt;/code&gt; is equivalent to &lt;code&gt;/$/&lt;/code&gt;; that is, it matches at the end of the string, or one before the newline at the end of the string. If the &lt;code&gt;/m&lt;/code&gt; modifier is used, then &lt;code&gt;/$/&lt;/code&gt; matches at internal newlines, but the meaning of &lt;code&gt;/\Z/&lt;/code&gt; isn't changed by the &lt;code&gt;/m&lt;/code&gt; modifier. &lt;code&gt;\Z&lt;/code&gt; matches at the end of the string (or just before a trailing newline) regardless whether the &lt;code&gt;/m&lt;/code&gt; modifier is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f47b559e51c9cb06b7531b5b8a212ee7a07836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; is just like &lt;code&gt;\Z&lt;/code&gt; , except that it does not match before a trailing newline. &lt;code&gt;\z&lt;/code&gt; matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</source>
          <target state="translated">&lt;code&gt;\z&lt;/code&gt; 就像 &lt;code&gt;\Z&lt;/code&gt; ，只不过它在尾随换行符之前不匹配。 &lt;code&gt;\z&lt;/code&gt; 仅在字符串的末尾匹配，而与使用的修饰符无关，并且不仅在换行符之前。这是在所有条件下如何将匹配项锚定到字符串的真实结尾的方法。</target>
        </trans-unit>
        <trans-unit id="0dddfca295a15998343d3e2118aed035cd1b453e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\z&lt;/code&gt; is just like &lt;code&gt;\Z&lt;/code&gt;, except that it does not match before a trailing newline. &lt;code&gt;\z&lt;/code&gt; matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a70aedbc9fae24b3656fb271fb5a35b52ef808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;]&lt;/code&gt; is the offset of the start of the substring matched by</source>
          <target state="translated">&lt;code&gt;]&lt;/code&gt; 是匹配的子字符串开头的偏移量</target>
        </trans-unit>
        <trans-unit id="e1d7f97ecc73edc5732b4917233d89a3115636be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in regular expression patterns are supposed to match all these, but don't. These characters also don't, but should, affect &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;code&gt;$.&lt;/code&gt; , and script line numbers.</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; 正则表达式模式中的^和 &lt;code&gt;$&lt;/code&gt; 应该匹配所有这些，但不匹配。这些字符也不会但应该影响 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; &lt;code&gt;$.&lt;/code&gt; 以及脚本行号。</target>
        </trans-unit>
        <trans-unit id="86ae5c851c3a1cc84b8441895b384c4179ba8046" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in regular expression patterns are supposed to match all these, but don't. These characters also don't, but should, affect &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;&lt;code&gt;$.&lt;/code&gt;, and script line numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2224dcf7ebf0b526271854823f3d301837385c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_PC_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_PC_LINK_MAX&lt;/code&gt;&lt;code&gt;_PC_MAX_CANON&lt;/code&gt;&lt;code&gt;_PC_MAX_INPUT&lt;/code&gt;&lt;code&gt;_PC_NAME_MAX&lt;/code&gt;&lt;code&gt;_PC_NO_TRUNC&lt;/code&gt;&lt;code&gt;_PC_PATH_MAX&lt;/code&gt;&lt;code&gt;_PC_PIPE_BUF&lt;/code&gt;&lt;code&gt;_PC_VDISABLE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63011a4008ee629a0f26075a9a743d3b2b2ede8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_POSIX_ARG_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHILD_MAX&lt;/code&gt;&lt;code&gt;_POSIX_CHOWN_RESTRICTED&lt;/code&gt;&lt;code&gt;_POSIX_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_POSIX_LINK_MAX&lt;/code&gt;&lt;code&gt;_POSIX_MAX_CANON&lt;/code&gt;&lt;code&gt;_POSIX_MAX_INPUT&lt;/code&gt;&lt;code&gt;_POSIX_NAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_POSIX_NO_TRUNC&lt;/code&gt;&lt;code&gt;_POSIX_OPEN_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PATH_MAX&lt;/code&gt;&lt;code&gt;_POSIX_PIPE_BUF&lt;/code&gt;&lt;code&gt;_POSIX_SAVED_IDS&lt;/code&gt;&lt;code&gt;_POSIX_SSIZE_MAX&lt;/code&gt;&lt;code&gt;_POSIX_STREAM_MAX&lt;/code&gt;&lt;code&gt;_POSIX_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_POSIX_VDISABLE&lt;/code&gt;&lt;code&gt;_POSIX_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0338a6cffd158f71c4a073e1191fe24d695975" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;_SC_ARG_MAX&lt;/code&gt;&lt;code&gt;_SC_CHILD_MAX&lt;/code&gt;&lt;code&gt;_SC_CLK_TCK&lt;/code&gt;&lt;code&gt;_SC_JOB_CONTROL&lt;/code&gt;&lt;code&gt;_SC_NGROUPS_MAX&lt;/code&gt;&lt;code&gt;_SC_OPEN_MAX&lt;/code&gt;&lt;code&gt;_SC_PAGESIZE&lt;/code&gt;&lt;code&gt;_SC_SAVED_IDS&lt;/code&gt;&lt;code&gt;_SC_STREAM_MAX&lt;/code&gt;&lt;code&gt;_SC_TZNAME_MAX&lt;/code&gt;&lt;code&gt;_SC_VERSION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c4507a34314e4717b1cc2380be0c570f4cf8cc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; ， &lt;code&gt;__END__&lt;/code&gt; ， &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;elsif&lt;/code&gt; ， &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 的， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 的， &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;unless&lt;/code&gt; ， &lt;code&gt;until&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;xor&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ac8079a493704c080d46e2cca7389fdc1d58946" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DATA__&lt;/code&gt;, &lt;code&gt;__END__&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;dump&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;eval&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qr&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;redo&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt;, &lt;code&gt;use&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f436bfdadc0a4193ec468e3af9c90fc24e2967c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DIE__&lt;/code&gt; /&lt;code&gt;__WARN__&lt;/code&gt; handlers are very special in one respect: they may be called to report (probable) errors found by the parser. In such a case the parser may be in inconsistent state, so any attempt to evaluate Perl code from such a handler will probably result in a segfault. This means that warnings or errors that result from parsing Perl should be used with extreme caution, like this:</source>
          <target state="translated">&lt;code&gt;__DIE__&lt;/code&gt; / &lt;code&gt;__WARN__&lt;/code&gt; 处理程序在一个方面非常特殊：可以调用它们来报告解析器发现的（可能）错误。在这种情况下，解析器可能处于不一致状态，因此任何从此类处理程序评估Perl代码的尝试都可能导致段错误。这意味着在解析Perl时产生的警告或错误应格外小心，例如：</target>
        </trans-unit>
        <trans-unit id="b9456911678627db4da96f2529e10a2ad6d37dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__DIE__&lt;/code&gt;/&lt;code&gt;__WARN__&lt;/code&gt; handlers are very special in one respect: they may be called to report (probable) errors found by the parser. In such a case the parser may be in inconsistent state, so any attempt to evaluate Perl code from such a handler will probably result in a segfault. This means that warnings or errors that result from parsing Perl should be used with extreme caution, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d0b679130382dce8fe2a86280667432e82e672" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_fieldhash&lt;/code&gt; is the internal function used to create field hashes. It takes two arguments, a hashref and a mode. If the mode is boolean false, the hash is not changed but tested if it is a field hash. If the hash isn't a field hash the return value is boolean false. If it is, the return value indicates the mode of field hash. When called with a boolean true mode, it turns the given hash into a field hash of this mode, returning the mode of the created field hash. &lt;code&gt;_fieldhash&lt;/code&gt; does not erase the given hash.</source>
          <target state="translated">&lt;code&gt;_fieldhash&lt;/code&gt; 是用于创建字段哈希的内部函数。它有两个参数，一个hashref和一个模式。如果模式为boolean false，则不更改哈希值，但会测试它是否是字段哈希值。如果哈希值不是字段哈希值，则返回值为布尔值false。如果是，则返回值指示字段哈希的模式。当使用布尔值true模式调用时，它将给定的哈希转换为该模式的字段哈希，并返回创建的字段哈希的模式。 &lt;code&gt;_fieldhash&lt;/code&gt; 不会擦除给定的哈希。</target>
        </trans-unit>
        <trans-unit id="2e8e054b1c07b425b270bb9c7e13c794d2d9092f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="aa85beb7344aca10b8cc8699807de44f549b3521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;``&lt;/code&gt; and pipe-&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; do not work under DOS.</source>
          <target state="translated">&lt;code&gt;``&lt;/code&gt; 和管道 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 在DOS下不起作用。</target>
        </trans-unit>
        <trans-unit id="2bdd809918440b8fcbcd0e948d96987513362e99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;``&lt;/code&gt; and pipe-&lt;code&gt;open&lt;/code&gt; do not work under DOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8938480285fe7482d06df8890143549cb42503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; = match 'a' 0 or more times, i.e., any number of times</source>
          <target state="translated">&lt;code&gt;a*&lt;/code&gt; =匹配'a'0次或多次，即任意次数</target>
        </trans-unit>
        <trans-unit id="21b92f8e0d8dad1b0caf50f135db9b635632e760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times</source>
          <target state="translated">&lt;code&gt;a*&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 0次或多次，即任意次数</target>
        </trans-unit>
        <trans-unit id="f3ca7559101ce7ae9003fe0fcdfc72bd09f589b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab7362646f1c360bc9715cbf44b1a07df61dc33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*?&lt;/code&gt; means: match 'a' 0 or more times, i.e., any number of times, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a*?&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 0次或多次，即任意次数，但次数尽可能少</target>
        </trans-unit>
        <trans-unit id="82581292c96ab4ca634a840738db2ae15f10b364" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a*?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ca230acfe7cf51016cf1f4619d8d0fb5d9ddc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; = match 'a' 1 or more times, i.e., at least once</source>
          <target state="translated">&lt;code&gt;a+&lt;/code&gt; =匹配&amp;ldquo; a&amp;rdquo; 1次或更多次，即至少一次</target>
        </trans-unit>
        <trans-unit id="57839f788d53642fe08867e5699ec952e95d5a35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once</source>
          <target state="translated">&lt;code&gt;a+&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 1次或更多次，即至少匹配一次</target>
        </trans-unit>
        <trans-unit id="b52db27e1bf1a298f6c2fec4c1555cb45de1273c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07e81ca192d31fdf9434c5f46dda1eb5e709a3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+?&lt;/code&gt; means: match 'a' 1 or more times, i.e., at least once, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a+?&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 1次或更多次，即至少匹配一次，但次数越少越好</target>
        </trans-unit>
        <trans-unit id="845574760c8db8566f430ffa9647822edd5003c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a+?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or more times,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe405e15c76b256da476c55e02d7cd0a2d157a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.out&lt;/code&gt; -style build</source>
          <target state="translated">&lt;code&gt;a.out&lt;/code&gt; 样式的构建</target>
        </trans-unit>
        <trans-unit id="35dd9ca1d0d88ad1a96375ce9b702e755846541d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.out&lt;/code&gt;-style build</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230edf66068099823e9804e4de860018cd863dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; = match 'a' 1 or 0 times</source>
          <target state="translated">&lt;code&gt;a?&lt;/code&gt; =匹配'a'1或0次</target>
        </trans-unit>
        <trans-unit id="9da27773f632fe6532ea60454a7e99563c5df049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; means: match 'a' 1 or 0 times</source>
          <target state="translated">&lt;code&gt;a?&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 1或0次</target>
        </trans-unit>
        <trans-unit id="7d837c40b361a1b0e068afb77ac8901111672b8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a?&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 1 or 0 times</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95b02ff02305f1ba01c669bd763805726d17747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a??&lt;/code&gt; means: match 'a' 0 or 1 times. Try 0 first, then 1.</source>
          <target state="translated">&lt;code&gt;a??&lt;/code&gt; 表示：匹配&amp;ldquo; a&amp;rdquo; 0或1次。首先尝试0，然后尝试1。</target>
        </trans-unit>
        <trans-unit id="3f5ee01f6638a46ec4227de038a3818c92264fe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a??&lt;/code&gt; means: match &lt;code&gt;'a'&lt;/code&gt; 0 or 1 times. Try 0 first, then 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f5437673cd5bd4b3828d004ecfdf8a717e1140" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;agent&lt;/code&gt; &amp;mdash; A user-agent string (defaults to 'HTTP-Tiny/$VERSION'). If &lt;code&gt;agent&lt;/code&gt; &amp;mdash; ends in a space character, the default user-agent string is appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fc80bf6fcacd730498ea7c90f9cf90dcfb60ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt; , &lt;code&gt;AUTOLOAD&lt;/code&gt; , &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;CORE&lt;/code&gt; , &lt;code&gt;__DATA__&lt;/code&gt; , &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;DESTROY&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;__END__&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; , &lt;code&gt;until&lt;/code&gt; , &lt;code&gt;when&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;xor&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;AUTOLOAD&lt;/code&gt; ， &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;cmp&lt;/code&gt; ， &lt;code&gt;CORE&lt;/code&gt; ， &lt;code&gt;__DATA__&lt;/code&gt; ， &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;DESTROY&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/elseif&quot;&gt;elseif&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;elsif&lt;/code&gt; ， &lt;code&gt;END&lt;/code&gt; ， &lt;code&gt;__END__&lt;/code&gt; ， &lt;code&gt;eq&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;ge&lt;/code&gt; ， &lt;code&gt;given&lt;/code&gt; ， &lt;code&gt;gt&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; ， &lt;code&gt;le&lt;/code&gt; ， &lt;code&gt;lt&lt;/code&gt; ， &lt;code&gt;ne&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;unless&lt;/code&gt; ， &lt;code&gt;until&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;xor&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c5ba6e6c064f75fd46dc68781fbd7e30ef75f65c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;AUTOLOAD&lt;/code&gt;, &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;CORE&lt;/code&gt;, &lt;code&gt;__DATA__&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;DESTROY&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;elsif&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;__END__&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;given&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;xor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a730339d13b6dfc5b68c65a3de6e0fc8a3004b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ansi16&lt;/code&gt; through &lt;code&gt;ansi255&lt;/code&gt;, as aliases for the &lt;code&gt;rgb&lt;/code&gt; and &lt;code&gt;grey&lt;/code&gt; colors, and the corresponding &lt;code&gt;on_ansi&lt;/code&gt; names and &lt;code&gt;ANSI&lt;/code&gt; and &lt;code&gt;ON_ANSI&lt;/code&gt; constants were added in Term::ANSIColor 4.06, included in Perl 5.25.7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237ce529899dd468665989ad0de897e59c5ea0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; 至少需要两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ac0ab28f5ff68d86ee5d0ef5fa75665ecf352d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a199cbe1000a9f2232c1b768205f8a71916e5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyuncompress&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;anyuncompress&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31f7ade2046429d24fa7160a950e7d33814b0b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anyuncompress&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bc2e19b99e66854df10c6d2fbab2bff562ade5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; supply a set of command-line arguments to the Perl interpreter, as would normally be passed to the &lt;code&gt;main&lt;/code&gt; function of a C program. &lt;code&gt;argv[argc]&lt;/code&gt; must be null. These arguments are where the script to parse is specified, either by naming a script file or by providing a script in a &lt;code&gt;-e&lt;/code&gt; option. If &lt;a href=&quot;perlvar#%240&quot;&gt;&lt;code&gt;$0&lt;/code&gt;&lt;/a&gt; will be written to in the Perl interpreter, then the argument strings must be in writable memory, and so mustn't just be string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="594b23475e0e1b9413cc86129d116de9c7483b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argc&lt;/code&gt; is the number of args (in addition to $self) to pass to the method.</source>
          <target state="translated">&lt;code&gt;argc&lt;/code&gt; 是传递给该方法的args数目（除$ self外）。</target>
        </trans-unit>
        <trans-unit id="505e15e930b4bc514b93c1cfe1a341934396366a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arrayDepth&lt;/code&gt;, &lt;code&gt;hashDepth&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b9598ca1d453d19423eb15b8ff0422182e407fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array_base&lt;/code&gt; - allow the use of &lt;code&gt;$[&lt;/code&gt; to change the starting index of &lt;code&gt;@array&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecb8a104e58709e3b9705ed1f8707f7f5de3bcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias for &lt;code&gt;as_int()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; 是一个别名 &lt;code&gt;as_int()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01e55f32d5564665acf56907988f94adcc97855a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias for &lt;code&gt;as_int()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f96c96a7f64071f26b5a17951cc68865a282d2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias to &lt;code&gt;as_int()&lt;/code&gt;. &lt;code&gt;as_number&lt;/code&gt; was introduced in v1.22, while &lt;code&gt;as_int()&lt;/code&gt; was introduced in v1.68.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d961a102b3d98060a65c3134d4e3d1aa8466353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_number()&lt;/code&gt; is an alias to this method. &lt;code&gt;as_number&lt;/code&gt; was introduced in v1.22, while &lt;code&gt;as_int()&lt;/code&gt; was only introduced in v1.68.</source>
          <target state="translated">&lt;code&gt;as_number()&lt;/code&gt; 是此方法的别名。 &lt;code&gt;as_number&lt;/code&gt; 中引入了as_number，而 &lt;code&gt;as_int()&lt;/code&gt; 中仅引入了as_int （）。</target>
        </trans-unit>
        <trans-unit id="71746fcdf6fe99a0ad5a137467eb6e68086bdb69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous sub, and so must have a semi-colon after the closing brace. Like &lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a thread object.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 创建一个线程以立即执行紧随其后的块。该块被视为匿名子，因此在右括号后必须使用分号。像 &lt;code&gt;Thread-&amp;amp;gt;new&lt;/code&gt; 一样， &lt;code&gt;async&lt;/code&gt; 返回线程对象。</target>
        </trans-unit>
        <trans-unit id="4ba0ddb0d8e6b435990a0ead91a242e7776f8136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous sub, and so must have a semi-colon after the closing brace. Like &lt;code&gt;Thread-&amp;gt;new&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; returns a thread object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f0efd0ea8940854ffa84069ded342e116934964" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous subroutine, and so must have a semicolon after the closing brace. Like &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; , &lt;code&gt;async&lt;/code&gt; returns a</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 创建一个线程以立即执行紧随其后的块。该块被视为匿名子例程，因此在右括号后必须使用分号。像 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; 一样， &lt;code&gt;async&lt;/code&gt; 返回一个</target>
        </trans-unit>
        <trans-unit id="c76c25874f5f4c53d86f76f24c8b58e617286e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; creates a thread to execute the block immediately following it. This block is treated as an anonymous subroutine, and so must have a semicolon after the closing brace. Like &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt;, &lt;code&gt;async&lt;/code&gt; returns a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386d7ab5826c9a6c629f35748fdbfe0d620acdb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attrs&lt;/code&gt; supplies attributes to be applied the subroutine. A handful of attributes take effect by built-in means, being applied to &lt;code&gt;PL_compcv&lt;/code&gt; immediately when seen. Other attributes are collected up and attached to the subroutine by this route. &lt;code&gt;attrs&lt;/code&gt; may be null to supply no attributes, or point to a &lt;code&gt;const&lt;/code&gt; op for a single attribute, or point to a &lt;code&gt;list&lt;/code&gt; op whose children apart from the &lt;code&gt;pushmark&lt;/code&gt; are &lt;code&gt;const&lt;/code&gt; ops for one or more attributes. Each &lt;code&gt;const&lt;/code&gt; op must be a string, giving the attribute name optionally followed by parenthesised arguments, in the manner in which attributes appear in Perl source. The attributes will be applied to the sub by this function. &lt;code&gt;attrs&lt;/code&gt; is consumed by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20e239fdae6920d9515de44e7fcc79dd92cfa709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_help&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;auto_help&lt;/code&gt; 如果调用程序在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句中显式指定了高于2.32的版本号，则将启用auto_help。</target>
        </trans-unit>
        <trans-unit id="15046591e9456a06fe2fca89490693922c130301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_help&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44063872f18d367e632a96d4c2413f4a5756f7e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_version&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;auto_version&lt;/code&gt; 如果调用程序在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句中显式指定了高于2.32的版本号，则将启用auto_version。</target>
        </trans-unit>
        <trans-unit id="4a74561dc358511e7fd16173d3a37bd02a6dccc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_version&lt;/code&gt; will be enabled if the calling program explicitly specified a version number higher than 2.32 in the &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1347f069f43387e1b93d21850e69034397cebbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autobundle&lt;/code&gt; writes a bundle file into the &lt;code&gt;$CPAN::Config-&amp;gt;{cpan_home}/Bundle&lt;/code&gt; directory. The file contains a list of all modules that are both available from CPAN and currently installed within @INC. Duplicates of each distribution are suppressed. The name of the bundle file is based on the current date and a counter, e.g.</source>
          <target state="translated">&lt;code&gt;autobundle&lt;/code&gt; 将捆绑文件写入 &lt;code&gt;$CPAN::Config-&amp;gt;{cpan_home}/Bundle&lt;/code&gt; 目录。该文件包含所有模块的列表，这些模块都可以从CPAN获得，并且当前已安装在@INC中。抑制每个分布的重复。捆绑文件的名称基于当前日期和计数器，例如</target>
        </trans-unit>
        <trans-unit id="8c7e7ae5f16a14cbcac229ca9b12c6c3b27e362b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoderef&lt;/code&gt; - allow push, each, keys, and other built-ins on references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8340269df63e967accad5f4e76ab74dd450f63e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie::skip&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b650573b7b7b2cbf42f22f273aca6f48d4d98e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; can be enabled for all of Perl's built-ins, including &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; with:</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 可以为所有Perl的内置插件，其中包括启用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 有：</target>
        </trans-unit>
        <trans-unit id="a09b6de086f61d0a65534bde69dd283b4e2d788f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; can be enabled for all of Perl's built-ins, including &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fad0431ea3a38aae4174e77bf5178a3d0e649d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; may not work correctly if used inside a file with a name that looks like a string eval, such as</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 如果在名称类似于字符串eval的文件中使用autodie，则autodie可能无法正常工作，例如</target>
        </trans-unit>
        <trans-unit id="454c5cd48c87ed2210f01705090343cf6b8e7234" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; performs no checking of called context to determine whether to throw an exception; the explicitness of error handling with &lt;code&gt;autodie&lt;/code&gt; is a deliberate feature.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 不检查被调用的上下文以确定是否抛出异常；使用 &lt;code&gt;autodie&lt;/code&gt; 进行错误处理的显式性是故意的。</target>
        </trans-unit>
        <trans-unit id="0db3f5b6429d1ec4bd262f8ef515af9dd0c28044" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; provides a passive interface to allow you to declare hints for your module. These hints will be found and used by &lt;code&gt;autodie&lt;/code&gt; if it is loaded, but otherwise have no effect (or dependencies) without autodie. To set these, your module needs to declare that it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72fbd0d22196753cef72e3aaeff8f62e055b88f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; uses the &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to change &lt;code&gt;system&lt;/code&gt;. See its documentation for further information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0331eb04d953ce3ea3a3439a3951a3642b45368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autodie&lt;/code&gt; uses the &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; module to change &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;. See its documentation for further information.</source>
          <target state="translated">&lt;code&gt;autodie&lt;/code&gt; 使用&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;模块更改 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 。有关更多信息，请参见其文档。</target>
        </trans-unit>
        <trans-unit id="0e6a31e9af4af180479c7899fb188e9a03c0bf8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoftp&lt;/code&gt; is a program that can retrieve, send, or list files via the FTP protocol in a non-interactive manner.</source>
          <target state="translated">&lt;code&gt;autoftp&lt;/code&gt; 是一个程序，可以以非交互方式通过FTP协议检索，发送或列出文件。</target>
        </trans-unit>
        <trans-unit id="2bc7ee78e0a3ef2c6ca2c0dc57cbee30b57d77f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; imports the default functions automatically, but &lt;code&gt;load&lt;/code&gt; do not import any functions.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; 自动导入默认功能，但是 &lt;code&gt;load&lt;/code&gt; 不导入任何功能。</target>
        </trans-unit>
        <trans-unit id="232241e3903140051e2046c8f6440d532e004aca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is usable under &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN{};&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;autoload&lt;/code&gt; 可在 &lt;code&gt;&lt;a href=&quot;../functions/begin&quot;&gt;BEGIN{};&lt;/a&gt;&lt;/code&gt; 下使用；。</target>
        </trans-unit>
        <trans-unit id="e24e49bd446fae2d8a274e067f35727fbe6cf233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;autoload&lt;/code&gt; is usable under &lt;code&gt;BEGIN{};&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3895a69d42fb934afc4c8b2a1c096fa7c3b874a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;av_fetch&lt;/code&gt; and the corresponding hash functions &lt;code&gt;hv_fetch&lt;/code&gt; and &lt;code&gt;hv_fetch_ent&lt;/code&gt; actually return an undefined mortal value whose magic has been initialized using &lt;code&gt;mg_copy&lt;/code&gt; . Note the value so returned does not need to be deallocated, as it is already mortal. [MAYCHANGE] But you will need to call &lt;code&gt;mg_get()&lt;/code&gt; on the returned value in order to actually invoke the perl level &quot;FETCH&quot; method on the underlying TIE object. Similarly, you may also call &lt;code&gt;mg_set()&lt;/code&gt; on the return value after possibly assigning a suitable value to it using &lt;code&gt;sv_setsv&lt;/code&gt; , which will invoke the &quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</source>
          <target state="translated">&lt;code&gt;av_fetch&lt;/code&gt; 和相应的哈希函数 &lt;code&gt;hv_fetch&lt;/code&gt; 和 &lt;code&gt;hv_fetch_ent&lt;/code&gt; 实际上返回一个未定义的凡人值，其魔力已使用 &lt;code&gt;mg_copy&lt;/code&gt; 初始化。请注意，这样返回的值不需要重新分配，因为它已经是致命的了。 [MAYCHANGE]但是您将需要在返回值上调用 &lt;code&gt;mg_get()&lt;/code&gt; 以便在基础TIE对象上实际调用perl级别的&amp;ldquo; FETCH&amp;rdquo;方法。同样，在可能使用 &lt;code&gt;sv_setsv&lt;/code&gt; 为其分配了合适的值之后，也可以在返回值上调用 &lt;code&gt;mg_set()&lt;/code&gt; ，这将在TIE对象上调用&amp;ldquo; STORE&amp;rdquo;方法。 [/ MAYCHANGE]</target>
        </trans-unit>
        <trans-unit id="44a90e091fe36f583c32fdbf611cdbf4b367267d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;av_fetch&lt;/code&gt; and the corresponding hash functions &lt;code&gt;hv_fetch&lt;/code&gt; and &lt;code&gt;hv_fetch_ent&lt;/code&gt; actually return an undefined mortal value whose magic has been initialized using &lt;code&gt;mg_copy&lt;/code&gt;. Note the value so returned does not need to be deallocated, as it is already mortal. [MAYCHANGE] But you will need to call &lt;code&gt;mg_get()&lt;/code&gt; on the returned value in order to actually invoke the perl level &quot;FETCH&quot; method on the underlying TIE object. Similarly, you may also call &lt;code&gt;mg_set()&lt;/code&gt; on the return value after possibly assigning a suitable value to it using &lt;code&gt;sv_setsv&lt;/code&gt;, which will invoke the &quot;STORE&quot; method on the TIE object. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370ecf3fa40e8e270cd9e8d46abf508006b8748f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as many times as possible, and don't give anything up. &lt;code&gt;a?+&lt;/code&gt; is short for &lt;code&gt;a{0,1}+&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;a{n,m}+&lt;/code&gt; 意思是：匹配至少 &lt;code&gt;n&lt;/code&gt; 次，最多不超过 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 次，并且不放弃任何东西。 &lt;code&gt;a?+&lt;/code&gt; 是 &lt;code&gt;a{0,1}+&lt;/code&gt; 缩写</target>
        </trans-unit>
        <trans-unit id="1ae130a0ed68c92222592fa86f1895a7e988c6c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;m&lt;/code&gt; times, as many times as possible, and don't give anything up. &lt;code&gt;a?+&lt;/code&gt; is short for &lt;code&gt;a{0,1}+&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e375a004d6e03b949adf214a1f3c21deb80331" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;a{n,m}&lt;/code&gt; =至少匹配 &lt;code&gt;n&lt;/code&gt; 次，但不超过 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 次。</target>
        </trans-unit>
        <trans-unit id="0fe113abe8bdde84607c26df4f6e9a7a76262ea0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;m&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc66155533b942e5ab8f7ec970fd9b80f6477f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;a{n,m}&lt;/code&gt; 表示：匹配至少 &lt;code&gt;n&lt;/code&gt; 次，但不超过 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 次。</target>
        </trans-unit>
        <trans-unit id="5b055a491eac57ec668a2f9d193ea3b24ff90d2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but not more than &lt;code&gt;m&lt;/code&gt; times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5c7c3b0091b46feced5840b89ec76e6c84ecde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; times, as few times as possible</source>
          <target state="translated">&lt;code&gt;a{n,m}?&lt;/code&gt; 意思是：至少匹配 &lt;code&gt;n&lt;/code&gt; 次，不超过 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 次，尽可能少地匹配</target>
        </trans-unit>
        <trans-unit id="d5c2ac0fbfcd05ee2c63a5f902268a4d61c84e09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,m}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, not more than &lt;code&gt;m&lt;/code&gt; times, as few times as possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b5ef56170764cdecbc0d347e679c1d12841cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as many times as possible, and don't give anything up. &lt;code&gt;a*+&lt;/code&gt; is short for &lt;code&gt;a{0,}+&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt; is short for &lt;code&gt;a{1,}+&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;a{n,}+&lt;/code&gt; 意思是：至少匹配 &lt;code&gt;n&lt;/code&gt; 次，但匹配次数尽可能多，并且不放弃任何内容。 &lt;code&gt;a*+&lt;/code&gt; 表示 &lt;code&gt;a{0,}+&lt;/code&gt; 缩写，而 &lt;code&gt;a++&lt;/code&gt; 表示 &lt;code&gt;a{1,}+&lt;/code&gt; 缩写。</target>
        </trans-unit>
        <trans-unit id="88b4985e9406ac84c6a9bc0a09eb0c7779e2dfda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}+&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as many times as possible, and don't give anything up. &lt;code&gt;a*+&lt;/code&gt; is short for &lt;code&gt;a{0,}+&lt;/code&gt; and &lt;code&gt;a++&lt;/code&gt; is short for &lt;code&gt;a{1,}+&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e64ab97f56cca83c147d8db97bd5f38b759239" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; = match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="translated">&lt;code&gt;a{n,}&lt;/code&gt; =至少匹配 &lt;code&gt;n&lt;/code&gt; 次或更多次</target>
        </trans-unit>
        <trans-unit id="55d47f9ce037822c6fc7d0cc1f2af2151924474e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; or more times</source>
          <target state="translated">&lt;code&gt;a{n,}&lt;/code&gt; 表示：至少匹配 &lt;code&gt;n&lt;/code&gt; 次或更多次</target>
        </trans-unit>
        <trans-unit id="4796e3b46c1c24af1a67d6416b09b75dcbb56116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n,}?&lt;/code&gt; means: match at least &lt;code&gt;n&lt;/code&gt; times, but as few times as possible</source>
          <target state="translated">&lt;code&gt;a{n,}?&lt;/code&gt; 表示：至少匹配 &lt;code&gt;n&lt;/code&gt; 次，但尽可能少地匹配</target>
        </trans-unit>
        <trans-unit id="e98166d002c5d2230a03efe89288ff0c20693e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}+&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. It is just there for notational consistency.</source>
          <target state="translated">&lt;code&gt;a{n}+&lt;/code&gt; 表示：精确匹配 &lt;code&gt;n&lt;/code&gt; 次。只是为了保持符号一致。</target>
        </trans-unit>
        <trans-unit id="aff6bf2bdc74bd6dd9dac4febf280883951ce36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; = match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="translated">&lt;code&gt;a{n}&lt;/code&gt; =精确匹配 &lt;code&gt;n&lt;/code&gt; 次</target>
        </trans-unit>
        <trans-unit id="488e096629b1696be9c45608edaf6f60d2af36fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times</source>
          <target state="translated">&lt;code&gt;a{n}&lt;/code&gt; 表示：精确匹配 &lt;code&gt;n&lt;/code&gt; 次</target>
        </trans-unit>
        <trans-unit id="cca987a62d500844e024a8db45998e5cb0a2b3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a{n}?&lt;/code&gt; means: match exactly &lt;code&gt;n&lt;/code&gt; times. Because we match exactly &lt;code&gt;n&lt;/code&gt; times, &lt;code&gt;a{n}?&lt;/code&gt; is equivalent to &lt;code&gt;a{n}&lt;/code&gt; and is just there for notational consistency.</source>
          <target state="translated">&lt;code&gt;a{n}?&lt;/code&gt; 表示：完全匹配 &lt;code&gt;n&lt;/code&gt; 次。因为我们恰好匹配 &lt;code&gt;n&lt;/code&gt; 次，所以 &lt;code&gt;a{n}?&lt;/code&gt; 等价于 &lt;code&gt;a{n}&lt;/code&gt; ，只是为了保持符号一致。</target>
        </trans-unit>
        <trans-unit id="9f0b21f37b253e85a0595d1e8980ee852b5acc4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_version_hook&lt;/code&gt; -- if provided, when a version cannot be parsed into a version object, this code reference will be called with the invalid version string as first argument, and the module name as second argument. It must return a valid version object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52c5653f4696bd55e9f87cb851ed5b97df1c68e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bailout&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;bailout&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="85746857608dedc350be9624fa95666d17cbadec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; will also initialize the fields if one of the base classes has it. Multiple inheritance of fields is &lt;b&gt;NOT&lt;/b&gt; supported, if two or more base classes each have inheritable fields the 'base' pragma will croak. See &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; for a description of this feature.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 也将初始化场如果一个基类有它。&lt;b&gt;不&lt;/b&gt;支持字段的多重继承，如果两个或多个基类每个都有可继承的字段，则&amp;ldquo; base&amp;rdquo;杂注将崩溃。请参阅&lt;a href=&quot;fields&quot;&gt;字段&lt;/a&gt;以了解此功能。</target>
        </trans-unit>
        <trans-unit id="a49870f1dbf6685e5c25e3fe1a1f02ddb9994bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;baseex&lt;/code&gt; is the error message or object. If it is a reference, it will be used as-is. Otherwise it is used as a string, and if it does not end with a newline then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191bfc9558f7a150df37f22495b9090b9cec45da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;baseex&lt;/code&gt; is the error message or object. If it is a reference, it will be used as-is. Otherwise it is used as a string, and if it does not end with a newline then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;baseex&lt;/code&gt; 是错误消息或对象。如果它是参考，它将按原样使用。否则，它将用作字符串，并且如果不以换行符结尾，则将使用对代码中当前位置的某种指示来对其进行扩展，如&lt;a href=&quot;#mess_sv&quot;&gt;mess_sv所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b66a2dfa7d8acaa040a7d0a40556f020987bdaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basemsg&lt;/code&gt; is the initial message or object. If it is a reference, it will be used as-is and will be the result of this function. Otherwise it is used as a string, and if it already ends with a newline, it is taken to be complete, and the result of this function will be the same string. If the message does not end with a newline, then a segment such as &lt;code&gt;at
foo.pl line 37&lt;/code&gt; will be appended, and possibly other clauses indicating the current state of execution. The resulting message will end with a dot and a newline.</source>
          <target state="translated">&lt;code&gt;basemsg&lt;/code&gt; 是初始消息或对象。如果它是参考，它将按原样使用，并将作为此函数的结果。否则，它将用作字符串，并且如果它已经以换行符结尾，则将其视为完整字符串，并且此函数的结果将是相同的字符串。如果消息不是以换行符结尾，则将附加一段，例如 &lt;code&gt;at foo.pl line 37&lt;/code&gt; ，并且可能还有其他子句指示当前的执行状态。结果消息将以点和换行符结尾。</target>
        </trans-unit>
        <trans-unit id="1cb5487d902affd230109c249c6cfd2461d057fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basename()&lt;/code&gt; returns the last level of a filepath even if the last level is clearly directory. In effect, it is acting like &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop()&lt;/a&gt;&lt;/code&gt; for paths. This differs from &lt;code&gt;fileparse()&lt;/code&gt; 's behaviour.</source>
          <target state="translated">&lt;code&gt;basename()&lt;/code&gt; 即使最后一级显然是目录，basename（）也会返回文件路径的最后一级。实际上，它的作用类似于 &lt;code&gt;&lt;a href=&quot;../functions/pop&quot;&gt;pop()&lt;/a&gt;&lt;/code&gt; 的路径。这与 &lt;code&gt;fileparse()&lt;/code&gt; 的行为不同。</target>
        </trans-unit>
        <trans-unit id="481b1743fd918f442200d9ffe7f48dbe81189cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basename()&lt;/code&gt; returns the last level of a filepath even if the last level is clearly directory. In effect, it is acting like &lt;code&gt;pop()&lt;/code&gt; for paths. This differs from &lt;code&gt;fileparse()&lt;/code&gt;'s behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c350e4c9f21cb0a1a08b12c3f3a234fd3306d7d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; 只是Math :: BigInt系列的各个模块的薄包装。可以将其视为一家之主，由他经营商店，并命令其他人进行这项工作。</target>
        </trans-unit>
        <trans-unit id="d9ef559a5aee4fc6060476dc9dce6429a54a1fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; overrides these routines with versions that can also handle big integer values. Under Perl prior to version v5.9.4, however, this will not happen unless you specifically ask for it with the two import tags &quot;hex&quot; and &quot;oct&quot; - and then it will be global and cannot be disabled inside a scope with &quot;no bigint&quot;:</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; 使用也可以处理大整数值的版本覆盖这些例程。但是，在v5.9.4之前的Perl版本中，除非您使用两个导入标签&amp;ldquo; hex&amp;rdquo;和&amp;ldquo; oct&amp;rdquo;明确要求，否则不会发生这种情况-然后它将是全局的，并且不能在带有&amp;ldquo; no&amp;rdquo;的作用域内禁用bigint&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="77855777212dc0e61b0deaffae594983ca8d2546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9648bd882ff18dacc401ac93a3cbc5bdbf4c9d3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigint&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bigint&lt;/code&gt; 的工作方式是重载整数和浮点文字的处理，然后将它们转换为&lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="e67fd9272e03c0fff199bea83aa5f87ef9db2f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; 只是Math :: BigInt系列的各个模块的薄包装。可以将其视为一家之主，由他经营商店，并命令其他人进行这项工作。</target>
        </trans-unit>
        <trans-unit id="6dce9e30bbfb12ce58e81b2b758a61886ed75fa6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4484da561486fa621b4d5b400e117645932edd50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bignum&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bignum&lt;/code&gt; 的工作方式是重载整数和浮点文字的处理，然后将它们转换为&lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt;或&lt;a href=&quot;math/bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="0997be7992ad036fe88c07a1a2c5ae3b3d710948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; is just a thin wrapper around various modules of the Math::BigInt family. Think of it as the head of the family, who runs the shop, and orders the others to do the work.</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; 只是Math :: BigInt系列的各个模块的薄包装。可以将其视为一家之主，由他经营商店，并命令其他人进行这项工作。</target>
        </trans-unit>
        <trans-unit id="31610ed7d713b997c6fc0c581db5b312ee95d486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1cc1a07b43faefb3cad91d623e619dcf6f61922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bigrat&lt;/code&gt; works by overloading handling of integer and floating point literals, converting them to &lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt; or &lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;bigrat&lt;/code&gt; 的工作方式是重载整数和浮点文字的处理，然后将它们转换为&lt;a href=&quot;math/bigint&quot;&gt;Math :: BigInt&lt;/a&gt;或&lt;a href=&quot;math/bigrat&quot;&gt;Math :: BigRat&lt;/a&gt;对象。</target>
        </trans-unit>
        <trans-unit id="4c21de8e7500902adaf01a3b784729b7ecd719ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binmode&lt;/code&gt; accepts one optional parameter, which is the layer to be passed on to the &lt;code&gt;binmode&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e783c908b4a308a204b7ce2483e8ec429148213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binmode&lt;/code&gt; sets &lt;code&gt;binmode&lt;/code&gt; on the underlying &lt;code&gt;IO&lt;/code&gt; object, as documented in &lt;code&gt;perldoc -f binmode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f80f2e5367f2767803da654200383c339903fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitwise&lt;/code&gt; - allow the new stringwise bit operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b6c07a71f5686ac19cd9774ee11d986397deac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bless&lt;/code&gt;, &lt;code&gt;blessed&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10db204f6c1bcb2f5fdc7fee81a4199ba0a57f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocking&lt;/code&gt; will return the value of the previous setting, or the current setting if &lt;code&gt;BOOL&lt;/code&gt; is not given.</source>
          <target state="translated">&lt;code&gt;blocking&lt;/code&gt; 将返回先前设置的值，或者如果未给出 &lt;code&gt;BOOL&lt;/code&gt; 则返回当前设置的值。</target>
        </trans-unit>
        <trans-unit id="f9c9b344df6b3d92130baeb97d1162148eeccf12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bmodpow&lt;/code&gt; also supports negative exponents.</source>
          <target state="translated">&lt;code&gt;bmodpow&lt;/code&gt; 还支持负指数。</target>
        </trans-unit>
        <trans-unit id="cf87ddfc025679a4d593ab2adfc2fee4551858ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bnorm()&lt;/code&gt; on a BigInt object is now effectively a no-op, since the numbers are always stored in normalized form. If passed a string, creates a BigInt object from the input.</source>
          <target state="translated">&lt;code&gt;bnorm()&lt;/code&gt; 现在，BigInt对象上的bnorm（）实际上是无操作的，因为数字始终以规范化形式存储。如果传递了字符串，则从输入中创建一个BigInt对象。</target>
        </trans-unit>
        <trans-unit id="b4162c471db6a86a9b946348362a41973f1acb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first three modifies $x, the last one won't:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798cacd9e526afca183dccd1f959cca59d152f9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first three will modify $x, the last one won't:</source>
          <target state="translated">&lt;code&gt;bpow()&lt;/code&gt; （和舍入函数）现在修改第一个参数并返回它，这与旧的代码不同，旧的代码将其保留为一，仅返回结果。这与 &lt;code&gt;badd()&lt;/code&gt; 等保持一致。前三个将修改$ x，后一个则不会：</target>
        </trans-unit>
        <trans-unit id="849aa8872c1c17a134807b61340d2432f9319b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bpow()&lt;/code&gt; now modifies the first argument, unlike the old code which left it alone and only returned the result. This is to be consistent with &lt;code&gt;badd()&lt;/code&gt; etc. The first will modify $x, the second one won't:</source>
          <target state="translated">&lt;code&gt;bpow()&lt;/code&gt; 现在修改第一个参数，这与旧的代码不同，旧的代码将其保留为单独状态并仅返回结果。这与 &lt;code&gt;badd()&lt;/code&gt; 等保持一致。第一个将修改$ x，第二个将不会：</target>
        </trans-unit>
        <trans-unit id="a80a75fc2d5e34cc7d42f63e584e793a52a18a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;__PACKAGE__&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;__FILE__&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;__LINE__&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;__PACKAGE__&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d37b9dd4d4b04a787d223ae6bcbe782e25d34036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;break&lt;/code&gt; is available only if you enable the experimental &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature or use the &lt;code&gt;CORE::&lt;/code&gt; prefix. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature also enables the &lt;code&gt;default&lt;/code&gt; , &lt;code&gt;given&lt;/code&gt; and &lt;code&gt;when&lt;/code&gt; statements, which are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;. The &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature is enabled automatically with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; (or higher) declaration in the current scope. In Perl v5.14 and earlier, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; required the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature, like the other keywords.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 仅当启用实验性 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能或使用 &lt;code&gt;CORE::&lt;/code&gt; 前缀时，break才可用。该 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能也使得 &lt;code&gt;default&lt;/code&gt; ， &lt;code&gt;given&lt;/code&gt; 和 &lt;code&gt;when&lt;/code&gt; 声明，这是在记录&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;中perlsyn switch语句&lt;/a&gt;。的 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 的功能与自动启用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.10&lt;/code&gt; （或更高）的声明在当前范围内。在Perl v5.14和更早版本中， &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 需要 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 功能，就像其他关键字一样。</target>
        </trans-unit>
        <trans-unit id="9c0c24e8a494482705a4281d9651a49d0ed492fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsearch()&lt;/code&gt; not supplied. For doing binary search on wordlists, see &lt;a href=&quot;Search::Dict&quot;&gt;Search::Dict&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d28a27314909fae3508f8ed1164a5ec5399fbac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsearch()&lt;/code&gt; not supplied. For doing binary search on wordlists, see &lt;a href=&quot;search/dict&quot;&gt;Search::Dict&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bsearch()&lt;/code&gt; 未提供bsearch（）。有关对单词表进行二进制搜索的信息，请参见&lt;a href=&quot;search/dict&quot;&gt;Search :: Dict&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0363f4ea35e1c639b600e344e40421943c6fc8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsqrt()&lt;/code&gt; returns the square root truncated to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1b1c495b5749e6b5ca6c410c06a5dadd577616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bsqrt()&lt;/code&gt; works only good if the result is a big integer, e.g. the square root of 144 is 12, but from 12 the square root is 3, regardless of rounding mode. The reason is that the result is always truncated to an integer.</source>
          <target state="translated">&lt;code&gt;bsqrt()&lt;/code&gt; 仅在结果为大整数时才有效，例如144的平方根为12，但无论舍入模式如何，从12的平方根均为3。原因是结果总是被截断为整数。</target>
        </trans-unit>
        <trans-unit id="e6f4bf676cc3a699b15481fc4a058909b15b5eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bunzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;bunzip2&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10729fb23cd747af7b8a893586b2811efe1265c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bunzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1289eb7503b5143976f8e66e1ad335db6fef90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes2str&lt;/code&gt; may be used as an alias for &lt;code&gt;decode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47b055b13026beadfc746983011dadb9ab6a7eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes::length()&lt;/code&gt; is admittedly handy if you need to know the &lt;b&gt;byte length&lt;/b&gt; of a Perl scalar. But a more modern way is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80f379583e71a36acd14cfcdac38bda86a7df34d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes::substr()&lt;/code&gt; does not work as an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e79e566033f6f8c25d3096a1053f32dc8e50d7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;bzip2&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6feed4079636ffa0babf642233a4e45624b7769" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bzip2&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c814516cc2d759e7d3157d53c1fbf37fa67a461" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_cc&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb399b427b2bc07d4aad0c9ddb246210f218065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_cflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695ddbb31e07202aa85c70bfeef73b32b2bcbf33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_iflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad78af9e16e140b0e1106aa00db5da80627d1e33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_lflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c939558c1553fa1f8bed0d585516c7250dbd25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_oflag&lt;/code&gt; field values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b53f1266a06652ab4c19a127fb6358e6d1bc2de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; cannot know whether an object will be able to provide a method through AUTOLOAD (unless the object's class has overridden &lt;code&gt;can&lt;/code&gt; appropriately), so a return value of</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 无法知道一个对象是否将能够通过AUTOLOAD是提供一种方法（除非对象的类已经重写 &lt;code&gt;can&lt;/code&gt; 适当地），所以返回值</target>
        </trans-unit>
        <trans-unit id="dfd77132ceb27f8ce6ebaf76ddb70f3498008f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; checks if the object or class has a method called &lt;code&gt;METHOD&lt;/code&gt; . If it does, then it returns a reference to the sub. If it does not, then it returns</source>
          <target state="translated">&lt;code&gt;can&lt;/code&gt; 检查对象或类是否具有称为 &lt;code&gt;METHOD&lt;/code&gt; 的方法。如果是，则返回对子的引用。如果不是，则返回</target>
        </trans-unit>
        <trans-unit id="518e9d2b8d4a6dec7e1bf8b236e463e2975de7e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can&lt;/code&gt; checks if the object or class has a method called &lt;code&gt;METHOD&lt;/code&gt;. If it does, then it returns a reference to the sub. If it does not, then it returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4425b178b213ffd266cc097cac94373284912ece" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; keeps its results in a cache, so it will not load the same module twice, nor will it attempt to load a module that has already failed to load before. By default, &lt;code&gt;can_load&lt;/code&gt; will check its cache, but you can override that by setting &lt;code&gt;nocache&lt;/code&gt; to true.</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; 将其结果保存在缓存中，因此它不会两次加载同一模块，也不会尝试加载之前已失败的模块。默认情况下， &lt;code&gt;can_load&lt;/code&gt; 将检查其缓存，但是您可以通过将 &lt;code&gt;nocache&lt;/code&gt; 设置为true 来覆盖它。</target>
        </trans-unit>
        <trans-unit id="80eef2d6b11e6af56916a4d9fed0cb49b43cc441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; takes the following arguments:</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; 采用以下参数：</target>
        </trans-unit>
        <trans-unit id="8c301228074969b093786c28df06529f261955aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_load&lt;/code&gt; will take a list of modules, optionally with version numbers and determine if it is able to load them. If it can load *ALL* of them, it will. If one or more are unloadable, none will be loaded.</source>
          <target state="translated">&lt;code&gt;can_load&lt;/code&gt; 将获取模块列表，并可选地列出版本号，并确定是否能够加载它们。如果它可以全部加载*，那么它将。如果一个或多个可卸载，则不会加载任何一个。</target>
        </trans-unit>
        <trans-unit id="a478303bf076c83556297908a48dd42d425490d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_run&lt;/code&gt; takes only one argument: the name of a binary you wish to locate. &lt;code&gt;can_run&lt;/code&gt; works much like the unix binary &lt;code&gt;which&lt;/code&gt; or the bash command &lt;code&gt;type&lt;/code&gt; , which scans through your path, looking for the requested binary.</source>
          <target state="translated">&lt;code&gt;can_run&lt;/code&gt; 仅接受一个参数：您要查找的二进制文件的名称。 &lt;code&gt;can_run&lt;/code&gt; 很像Unix的二进制 &lt;code&gt;which&lt;/code&gt; 或bash命令 &lt;code&gt;type&lt;/code&gt; ，它通过你的路径扫描，寻找所需的二进制文件。</target>
        </trans-unit>
        <trans-unit id="4c713ea52c968b6131449303769d26a672774869" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;can_run&lt;/code&gt; takes only one argument: the name of a binary you wish to locate. &lt;code&gt;can_run&lt;/code&gt; works much like the unix binary &lt;code&gt;which&lt;/code&gt; or the bash command &lt;code&gt;type&lt;/code&gt;, which scans through your path, looking for the requested binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc99e95e5b60b47d7f6807a79b190e2a3f9be43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change()&lt;/code&gt; handles &lt;code&gt;long_contraction&lt;/code&gt; explicitly only. If &lt;code&gt;long_contraction&lt;/code&gt; is not specified in &lt;code&gt;change()&lt;/code&gt; , even though &lt;code&gt;UCA_Version&lt;/code&gt; is changed, &lt;code&gt;long_contraction&lt;/code&gt; will not be changed.</source>
          <target state="translated">&lt;code&gt;change()&lt;/code&gt; &lt;code&gt;long_contraction&lt;/code&gt; 显式处理long_contraction。如果 &lt;code&gt;long_contraction&lt;/code&gt; 在未指定 &lt;code&gt;change()&lt;/code&gt; ，即使 &lt;code&gt;UCA_Version&lt;/code&gt; 改变， &lt;code&gt;long_contraction&lt;/code&gt; 不会改变。</target>
        </trans-unit>
        <trans-unit id="6b12455f5010981a7caf03ee723a0131c5689a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;change()&lt;/code&gt; handles &lt;code&gt;long_contraction&lt;/code&gt; explicitly only. If &lt;code&gt;long_contraction&lt;/code&gt; is not specified in &lt;code&gt;change()&lt;/code&gt;, even though &lt;code&gt;UCA_Version&lt;/code&gt; is changed, &lt;code&gt;long_contraction&lt;/code&gt; will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd64d856a574f3533b0b14b407870b871d3428ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charblocks()&lt;/code&gt; returns a reference to a hash with the known block names as the keys, and the code point ranges (see &lt;a href=&quot;#charblock%28%29&quot;&gt;&quot;charblock()&quot;&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f558974fb9e8f6fa2958daad656d8e76c141ee94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charblocks()&lt;/code&gt; returns a reference to a hash with the known block names as the keys, and the code point ranges (see &lt;a href=&quot;#charblock()&quot;&gt;charblock()&lt;/a&gt;) as the values.</source>
          <target state="translated">&lt;code&gt;charblocks()&lt;/code&gt; 返回对哈希的引用，该哈希以已知的块名称作为键，而代码点范围（请参见&lt;a href=&quot;#charblock()&quot;&gt;charblock（）&lt;/a&gt;）作为值。</target>
        </trans-unit>
        <trans-unit id="f837d8bad7cfec5d4bd3123e3e4f4763462fd63b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charnames::string_vianame()&lt;/code&gt; was introduced in v5.14. Prior to that, &lt;code&gt;charnames::vianame()&lt;/code&gt; should work, but only if the argument is of the form &lt;code&gt;&quot;U+...&quot;&lt;/code&gt; . Your best bet there for runtime Unicode by character name is probably:</source>
          <target state="translated">&lt;code&gt;charnames::string_vianame()&lt;/code&gt; 在v5.14中引入。在此之前， &lt;code&gt;charnames::vianame()&lt;/code&gt; 应该起作用，但前提是参数的形式为 &lt;code&gt;&quot;U+...&quot;&lt;/code&gt; 。最好通过字符名称在此处运行时Unicode的最佳选择是：</target>
        </trans-unit>
        <trans-unit id="303cbcdfbfc51ae434dd13ddc4e0d249896c36b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charnames::string_vianame()&lt;/code&gt; was introduced in v5.14. Prior to that, &lt;code&gt;charnames::vianame()&lt;/code&gt; should work, but only if the argument is of the form &lt;code&gt;&quot;U+...&quot;&lt;/code&gt;. Your best bet there for runtime Unicode by character name is probably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="367ccda5de213efa8e6de896b82a1a539bd095da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charscripts()&lt;/code&gt; returns a reference to a hash with the known script names as the keys, and the code point ranges (see &lt;a href=&quot;#charscript%28%29&quot;&gt;&quot;charscript()&quot;&lt;/a&gt;) as the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead2be91e2308e7b32a2e10b2c8928960675c93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;charscripts()&lt;/code&gt; returns a reference to a hash with the known script names as the keys, and the code point ranges (see &lt;a href=&quot;#charscript()&quot;&gt;charscript()&lt;/a&gt;) as the values.</source>
          <target state="translated">&lt;code&gt;charscripts()&lt;/code&gt; 返回对哈希的引用，该哈希以已知的脚本名称作为键，而代码点范围（请参见&lt;a href=&quot;#charscript()&quot;&gt;charscript（）&lt;/a&gt;）作为值。</target>
        </trans-unit>
        <trans-unit id="a194b4aab45221d04d6645b5c82186f03345b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chdir&lt;/code&gt;, &lt;code&gt;chmod&lt;/code&gt;, &lt;code&gt;chown&lt;/code&gt;, &lt;code&gt;chroot&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;symlink&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, &lt;code&gt;utime&lt;/code&gt;, &lt;code&gt;-X&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9d4908831f89243a57108c98d8f05e40e1deab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chdir&lt;/code&gt;, &lt;code&gt;chomp&lt;/code&gt;, &lt;code&gt;chop&lt;/code&gt;, &lt;code&gt;defined&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;eof&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;exists&lt;/code&gt;, &lt;code&gt;lstat&lt;/code&gt;, &lt;code&gt;split&lt;/code&gt;, &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;truncate&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c2d5d27e775d5bf2acdbed6ec527b752b22f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; takes a list of arguments, as follows:</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 采用参数列表，如下所示：</target>
        </trans-unit>
        <trans-unit id="61a6a6f073c5f32501789dfae5a4e3b8efb86cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check&lt;/code&gt; will return when it fails, or a hashref with lowercase keys of parsed arguments when it succeeds.</source>
          <target state="translated">&lt;code&gt;check&lt;/code&gt; 将在失败时返回，或者在成功时返回带有已解析参数的小写字母的hashref。</target>
        </trans-unit>
        <trans-unit id="7bc394e8518231d46cc35fa58854fec4567f4a31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;check_install&lt;/code&gt; allows you to verify if a certain module is installed or not. You may call it with the following arguments:</source>
          <target state="translated">&lt;code&gt;check_install&lt;/code&gt; 允许您验证是否安装了某个模块。您可以使用以下参数来调用它：</target>
        </trans-unit>
        <trans-unit id="2a75a5bd66390a72de974d7ef911d9b417527a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chr()&lt;/code&gt; must be given an EBCDIC code number argument to yield a desired character return value on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10c9412671604351afd83ac42dacea6431fa59b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chr()&lt;/code&gt;, &lt;code&gt;ord()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;index()&lt;/code&gt; and &lt;code&gt;rindex()&lt;/code&gt; behave similarly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6fc696fb8f44c377c8dffe5ed97242d9663724" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ckflags&lt;/code&gt; is a bitset, in which only the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit currently has a defined meaning (for which see above). All other bits should be clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f4747e95e85b4a1c67cb7b51c9949e228f03f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; clears the current in-memory archive. This effectively gives you a 'blank' object, ready to be filled again. Note that &lt;code&gt;clear&lt;/code&gt; only has effect on the object, not the underlying tarfile.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 清除当前的内存存档。这实际上为您提供了一个&amp;ldquo;空白&amp;rdquo;对象，准备再次填充。请注意， &lt;code&gt;clear&lt;/code&gt; 仅对对象有效，而对基础tarfile不起作用。</target>
        </trans-unit>
        <trans-unit id="8b1ff99d5c7ed83e6f2dcc9a357801da554024fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmp&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="3dbfc6b5ac858f99cbcc4507d320823e6f6fa5ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmpthese&lt;/code&gt; can also be passed the data structure that timethese() returns:</source>
          <target state="translated">&lt;code&gt;cmpthese&lt;/code&gt; 也可以传递timethese（）返回的数据结构：</target>
        </trans-unit>
        <trans-unit id="88b7a2613718eb73647eecdfe075d3be2ed24da6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;collect_pod&lt;/code&gt; is a optional boolean argument that determines whether POD data is collected and stored for reference. POD data is not collected by default. POD headings are always collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb5332ff0a73638efd42ab63fc32fe9bd7dbabeb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comment&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;comment&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="af6a5aaf7404876ed305ccda400e6d0a215f75ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compactDump&lt;/code&gt;, &lt;code&gt;veryCompact&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da23c990c0b340d65a11e6c4dd9a9fbcf9e8cbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compexcl()&lt;/code&gt; is included for backwards compatibility, but as of Perl 5.12 and more modern Unicode versions, for most purposes it is probably more convenient to use one of the following instead:</source>
          <target state="translated">&lt;code&gt;compexcl()&lt;/code&gt; 包括compexcl（）是为了向后兼容，但是从Perl 5.12和更现代的Unicode版本开始，对于大多数目的，使用以下其中一种可能更方便：</target>
        </trans-unit>
        <trans-unit id="86a708da1901bbb301c133e94da37987c89cff89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cond_signal&lt;/code&gt; will normally generate a warning if you attempt to use it on an unlocked variable. On the rare occasions where doing this may be sensible, you can suppress the warning with:</source>
          <target state="translated">&lt;code&gt;cond_signal&lt;/code&gt; 如果您尝试在未锁定的变量上使用cond_signal，通常会生成警告。在极少数情况下，这样做可能是明智的，您可以通过以下方式禁止显示警告：</target>
        </trans-unit>
        <trans-unit id="096889c63611c83b225ce2ede691d1f2be6bc5be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cons&lt;/code&gt; - This option is ignored, since the failover mechanism will drop down to the console automatically if all other media fail.</source>
          <target state="translated">&lt;code&gt;cons&lt;/code&gt; -此选项将被忽略，因为如果所有其他媒体都发生故障，则故障转移机制将自动降至控制台。</target>
        </trans-unit>
        <trans-unit id="ccf34562306a2add3d0f9fffd0dcebc556cdc8b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_attr&lt;/code&gt; - allow the :const attribute on subs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8f921f3f9ebaaa79e3f8dc4dbc81789cde77f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; &amp;mdash; A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the request</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c670ca5f082b8bfcb9d79e037f8aad33c25a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; &amp;mdash; The body of the response. If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5293347d474b74e679c0c8d8acc423646a13b60d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context()&lt;/code&gt; has some mechanisms to protect you if you do cause a context to persist beyond the scope in which it was obtained. In practice you should not rely on these protections, and they are fairly noisy with warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08e95c0960fcde197f4415ccb8265611c6ebc18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cookie_jar&lt;/code&gt; &amp;mdash; An instance of &lt;a href=&quot;HTTP::CookieJar&quot;&gt;HTTP::CookieJar&lt;/a&gt; &amp;mdash; or equivalent class that supports the &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;cookie_header&lt;/code&gt; methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b45a4c8bee9a24fa02b0048a41bb38158983a350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak()&lt;/code&gt; only when your module absolutely cannot figure out what to do. (&lt;code&gt;croak()&lt;/code&gt; is a better version of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; for use within modules, which reports its errors from the perspective of the caller. See &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; for details of &lt;code&gt;croak()&lt;/code&gt; , &lt;code&gt;carp()&lt;/code&gt; and other useful routines.)</source>
          <target state="translated">&lt;code&gt;croak()&lt;/code&gt; 仅当您的模块绝对无法确定要做什么时，才选择croak（）。（ &lt;code&gt;croak()&lt;/code&gt; 是在模块内使用的 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 的更好版本，它从调用者的角度报告其错误。有关 &lt;code&gt;croak()&lt;/code&gt; ， &lt;code&gt;carp()&lt;/code&gt; 和其他有用例程的详细信息，请参阅&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="3eff87280ab028320576494ad606b509973528c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak()&lt;/code&gt; only when your module absolutely cannot figure out what to do. (&lt;code&gt;croak()&lt;/code&gt; is a better version of &lt;code&gt;die()&lt;/code&gt; for use within modules, which reports its errors from the perspective of the caller. See &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; for details of &lt;code&gt;croak()&lt;/code&gt;, &lt;code&gt;carp()&lt;/code&gt; and other useful routines.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b8a9015ad51073a532bf2517dde18f5bf47fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak&lt;/code&gt; s on error.</source>
          <target state="translated">&lt;code&gt;croak&lt;/code&gt; S ON错误。</target>
        </trans-unit>
        <trans-unit id="043b01e1b87e6d38097e84b5fabb99178f74e5c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;croak&lt;/code&gt;s on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36abc39484041a3f0447981e6bf653e5088681e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cuserid&lt;/code&gt; [POSIX.1-1988]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f481b6f09b03efdc76158927658d21de33362c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cygserver&lt;/code&gt; (&lt;code&gt;use IPC::SysV&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dde23af6c8093917aed5e9b5c89f44d6c944ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dMY_CXT&lt;/code&gt; may be quite expensive to calculate, and to avoid the overhead of invoking it in each function it is possible to pass the declaration onto other functions using the &lt;code&gt;aMY_CXT&lt;/code&gt; /&lt;code&gt;pMY_CXT&lt;/code&gt; macros, eg</source>
          <target state="translated">&lt;code&gt;dMY_CXT&lt;/code&gt; 的计算可能非常昂贵，并且为避免在每个函数中调用它的开销，可以使用 &lt;code&gt;aMY_CXT&lt;/code&gt; / &lt;code&gt;pMY_CXT&lt;/code&gt; 宏将声明传递给其他函数，例如</target>
        </trans-unit>
        <trans-unit id="e4a63dc7a30dddaaa715074fdef2d6ceba7f15ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dMY_CXT&lt;/code&gt; may be quite expensive to calculate, and to avoid the overhead of invoking it in each function it is possible to pass the declaration onto other functions using the &lt;code&gt;aMY_CXT&lt;/code&gt;/&lt;code&gt;pMY_CXT&lt;/code&gt; macros, eg</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4109496804f1ccff0cccb7a3ca87fce4ed59e63f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dTHR&lt;/code&gt; was introduced in perl 5.005 to support the older thread model. The older thread model now uses the &lt;code&gt;THX&lt;/code&gt; mechanism to pass context pointers around, so &lt;code&gt;dTHR&lt;/code&gt; is not useful any more. Perl 5.6.0 and later still have it for backward source compatibility, but it is defined to be a no-op.</source>
          <target state="translated">&lt;code&gt;dTHR&lt;/code&gt; 在perl 5.005中引入了dTHR，以支持较早的线程模型。现在，较旧的线程模型使用 &lt;code&gt;THX&lt;/code&gt; 机制来传递上下文指针，因此 &lt;code&gt;dTHR&lt;/code&gt; 不再有用。Perl 5.6.0及更高版本仍然具有向后兼容源的功能，但将其定义为&amp;ldquo;无操作&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="184b83c9bdd4160a6f19f8a87fdd37ff4439be00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data_callback&lt;/code&gt; &amp;mdash; A code reference that will be called for each chunks of the response body received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ceaf96a959f0ab255fc37f7042654f8b20ff9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decode&lt;/code&gt; will not be affected in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead45fe5123d73507a0666226aa4b62056b56233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; behaves exactly like &lt;code&gt;when(1 == 1)&lt;/code&gt; , which is to say that it always matches.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 的行为与 &lt;code&gt;when(1 == 1)&lt;/code&gt; 完全一样，也就是说，它总是匹配的。</target>
        </trans-unit>
        <trans-unit id="a06f18d30284f6d44f03247eaa672884455fdd2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; behaves exactly like &lt;code&gt;when(1 == 1)&lt;/code&gt;, which is to say that it always matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad68f7d290433009d56d45688f048a290bc76143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_headers&lt;/code&gt; &amp;mdash; A hashref of default headers to apply to requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4008378ece0030f25890322578641b9c803138" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; , &lt;code&gt;flush&lt;/code&gt; , &lt;code&gt;discard&lt;/code&gt; , and &lt;code&gt;autodefer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; ， &lt;code&gt;flush&lt;/code&gt; ， &lt;code&gt;discard&lt;/code&gt; 和 &lt;code&gt;autodefer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1c2104168e369e8fabf33105315025902f2e03c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;flush&lt;/code&gt;, &lt;code&gt;discard&lt;/code&gt;, and &lt;code&gt;autodefer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84b466c384022ad6a6c0ee4613433ddf76214dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;deflate&lt;/code&gt; 至少需要两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceceb616a766b6f9d05c9cf3776a9455b1010d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbe4b40b78522ef59ec6c73489a586461d9b98e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;del_count&lt;/code&gt; is the number of nodes to delete. If zero, no nodes are deleted. If -1 or greater than or equal to the number of remaining kids, all remaining kids are deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557a8972e18c8311f342ad928d9daccc79114ada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach()&lt;/code&gt; can also be called as a class method to allow a thread to detach itself:</source>
          <target state="translated">&lt;code&gt;detach()&lt;/code&gt; 也可以作为类方法来调用，以允许线程自行分离：</target>
        </trans-unit>
        <trans-unit id="666fcacf663b1020377f259716313e99a0eb4f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detach&lt;/code&gt; tells a thread that it is never going to be joined i.e. that all traces of its existence can be removed once it stops running. Errors in detached threads will not be visible anywhere - if you want to catch them, you should use $SIG{__DIE__} or something like that.</source>
          <target state="translated">&lt;code&gt;detach&lt;/code&gt; 告诉线程它永远不会被连接，即一旦它停止运行就可以删除存在的所有痕迹。分离线程中的错误在任何地方都不可见-如果要捕获它们，则应使用$ SIG {__ DIE__}或类似的东西。</target>
        </trans-unit>
        <trans-unit id="ed21b3a7df5531dd2a26c649db73afbe33d707ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;detail()&lt;/code&gt; is an alias to the &lt;code&gt;details&lt;/code&gt; facet field for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c706946d64e27cf97e29790209d2503e94a440" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;die&lt;/code&gt; will force the native VMS exit status to be an SS$_ABORT code if neither of the $! or $? status values are ones that would cause the native status to be interpreted as being what VMS classifies as SEVERE_ERROR severity for DCL error handling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661b85004cec88114e1166343b36ceb5260be457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do './stat.pl'&lt;/code&gt; is largely like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28deeed6e04a81a7b1b3d5f9280331de50a5fa35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15b8c42099321a9dbc082b929829cf8884cb2c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_testing()&lt;/code&gt; is, in effect, used when you'd want to use &lt;code&gt;no_plan&lt;/code&gt; , but safer. You'd use it like so:</source>
          <target state="translated">&lt;code&gt;done_testing()&lt;/code&gt; 实际上，done_testing（）是在您希望使用 &lt;code&gt;no_plan&lt;/code&gt; 时使用的，但更安全。您将像这样使用它：</target>
        </trans-unit>
        <trans-unit id="93aecb7cbc419e0b6c443a22d048d6c94926bc80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;done_testing()&lt;/code&gt; is, in effect, used when you'd want to use &lt;code&gt;no_plan&lt;/code&gt;, but safer. You'd use it like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96ac2e7a1323e3e95635e4b26ab827cf6f59afef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dprofpp&lt;/code&gt; will produce some quite detailed reporting on the activity of the &lt;code&gt;wordmatch&lt;/code&gt; program. The wallclock, user and system, times are at the top of the analysis, and after this are the main columns defining which define the report. Check the &lt;code&gt;dprofpp&lt;/code&gt; docs for details of the many options it supports.</source>
          <target state="translated">&lt;code&gt;dprofpp&lt;/code&gt; 将针对 &lt;code&gt;wordmatch&lt;/code&gt; 程序的活动生成一些非常详细的报告。挂钟，用户和系统时间在分析的顶部，之后是定义报告的主要列。检查 &lt;code&gt;dprofpp&lt;/code&gt; 文档，以了解其支持的许多选项的详细信息。</target>
        </trans-unit>
        <trans-unit id="698546fdd428508dc98fcd9f8400a97d365533e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encode_language_tag&lt;/code&gt; returns undef if given anything other than a formally valid language tag.</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; 如果给定了除形式上有效的语言标记之外的任何内容，encode_language_tag将返回undef。</target>
        </trans-unit>
        <trans-unit id="4644e1dff58efff563e5617be7b3a2a308bb228b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encoding&lt;/code&gt; is assumed to be an &lt;code&gt;Encode&lt;/code&gt; object, on entry the PV of &lt;code&gt;sv&lt;/code&gt; is assumed to be octets in that encoding, and &lt;code&gt;sv&lt;/code&gt; will be converted into Unicode (and UTF-8).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8d497bcf36f684076d940db11c02fdb241dc56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;encoding&lt;/code&gt; is assumed to be an &lt;code&gt;Encode&lt;/code&gt; object, the PV of &lt;code&gt;ssv&lt;/code&gt; is assumed to be octets in that encoding and decoding the input starts from the position which &lt;code&gt;(PV + *offset)&lt;/code&gt; pointed to. &lt;code&gt;dsv&lt;/code&gt; will be concatenated with the decoded UTF-8 string from &lt;code&gt;ssv&lt;/code&gt;. Decoding will terminate when the string &lt;code&gt;tstr&lt;/code&gt; appears in decoding output or the input ends on the PV of &lt;code&gt;ssv&lt;/code&gt;. The value which &lt;code&gt;offset&lt;/code&gt; points will be modified to the last input position on &lt;code&gt;ssv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fbe3f0825cfe73fe04528e4db975b00a52f6e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; are scoping ops, and their job is to perform any housekeeping every time you enter and leave a block: lexical variables are tidied up, unreferenced variables are destroyed, and so on. Every program will have those first three lines: &lt;code&gt;leave&lt;/code&gt; is a list, and its children are all the statements in the block. Statements are delimited by &lt;code&gt;nextstate&lt;/code&gt; , so a block is a collection of &lt;code&gt;nextstate&lt;/code&gt; ops, with the ops to be performed for each statement being the children of &lt;code&gt;nextstate&lt;/code&gt; . &lt;code&gt;enter&lt;/code&gt; is a single op which functions as a marker.</source>
          <target state="translated">&lt;code&gt;enter&lt;/code&gt; 和 &lt;code&gt;leave&lt;/code&gt; 是作用域操作，每次进入和离开一个块时，它们的工作就是执行任何内部管理：整理词法变量，销毁未引用的变量，依此类推。每个程序都将具有前三行： &lt;code&gt;leave&lt;/code&gt; 是一个列表，其子代是该块中的所有语句。语句由 &lt;code&gt;nextstate&lt;/code&gt; 分隔，因此块是 &lt;code&gt;nextstate&lt;/code&gt; 操作的集合，每个语句要执行的操作是 &lt;code&gt;nextstate&lt;/code&gt; 的子代。 &lt;code&gt;enter&lt;/code&gt; 是充当标记的单个操作。</target>
        </trans-unit>
        <trans-unit id="e62a268f7e0b4e07691bd53126566c52f96fd283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; are scoping ops, and their job is to perform any housekeeping every time you enter and leave a block: lexical variables are tidied up, unreferenced variables are destroyed, and so on. Every program will have those first three lines: &lt;code&gt;leave&lt;/code&gt; is a list, and its children are all the statements in the block. Statements are delimited by &lt;code&gt;nextstate&lt;/code&gt;, so a block is a collection of &lt;code&gt;nextstate&lt;/code&gt; ops, with the ops to be performed for each statement being the children of &lt;code&gt;nextstate&lt;/code&gt;. &lt;code&gt;enter&lt;/code&gt; is a single op which functions as a marker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648391c4210cab349da16e1ff376040829af58eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;env&lt;/code&gt; specifies a set of environment variables that will be used by this Perl interpreter. If non-null, it must point to a null-terminated array of environment strings. If null, the Perl interpreter will use the environment supplied by the &lt;code&gt;environ&lt;/code&gt; global variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66996551ac21df55b2bc452ee7dc1f32731364d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equal&lt;/code&gt; tests whether two thread objects represent the same thread and returns true if they do.</source>
          <target state="translated">&lt;code&gt;equal&lt;/code&gt; 测试两个线程对象是否表示同一线程，如果相等则返回true。</target>
        </trans-unit>
        <trans-unit id="e24b23b819e56dad7d90e5a9ceb7af6412558ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval BLOCK&lt;/code&gt; does</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e984f3706aa5038760690eeba859e2db477c4f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt; in all its forms is used to execute a little Perl program, trapping any errors encountered so they don't crash the calling program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dadf8642958e7d1245426d45e425e26d43b8550" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt;ed strings (when accessible) are considered to be filenames: &lt;code&gt;f (eval 7)&lt;/code&gt; and &lt;code&gt;f eval 7\b&lt;/code&gt; access the body of the 7th &lt;code&gt;eval&lt;/code&gt;ed string (in the order of execution). The bodies of the currently executed &lt;code&gt;eval&lt;/code&gt; and of &lt;code&gt;eval&lt;/code&gt;ed strings that define subroutines are saved and thus accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0256dbe29caeaa86a1eb795ffc2729a2a5b7219f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval&lt;/code&gt;ed strings are compiled in the package in which the eval() was compiled. (Assignments to &lt;code&gt;$SIG{}&lt;/code&gt;, however, assume the signal handler specified is in the &lt;code&gt;main&lt;/code&gt; package. Qualify the signal handler name if you wish to have a signal handler in a package.) For an example, examine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d705110bcea9e4e4300cef1535c4cf468db00f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_pv&lt;/code&gt; is used to compile the anonymous subroutine, which will be the return value as well (read more about &lt;code&gt;eval_pv&lt;/code&gt; in &lt;a href=&quot;perlapi#eval_pv&quot;&gt;&quot;eval_pv&quot; in perlapi&lt;/a&gt;). Once this code reference is in hand, it can be mixed in with all the previous examples we've shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce2d19eb1b9a11a41c8b0d6eda83832900f64ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;eval_pv&lt;/code&gt; is used to compile the anonymous subroutine, which will be the return value as well (read more about &lt;code&gt;eval_pv&lt;/code&gt; in &lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv in perlapi&lt;/a&gt;). Once this code reference is in hand, it can be mixed in with all the previous examples we've shown.</source>
          <target state="translated">&lt;code&gt;eval_pv&lt;/code&gt; 用于编译匿名子例程，该例程也是返回值（有关更多信息，请 &lt;code&gt;eval_pv&lt;/code&gt; 中&lt;a href=&quot;perlapi#eval_pv&quot;&gt;eval_pv中的eval_pv&lt;/a&gt;）。掌握了此代码参考之后，就可以将其与我们前面显示的所有示例混合使用。</target>
        </trans-unit>
        <trans-unit id="c51683fd64ab48d3812924b1c50b14489246e459" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;evalbytes&lt;/code&gt; is like string &lt;code&gt;eval&lt;/code&gt;, but operating on a byte stream that is not UTF-8 encoded. Details are at &lt;a href=&quot;perlfunc#evalbytes-EXPR&quot;&gt;&quot;evalbytes EXPR&quot; in perlfunc&lt;/a&gt;. Without a &lt;code&gt;use feature 'evalbytes'&lt;/code&gt; nor a &lt;code&gt;use v5.16&lt;/code&gt; (or higher) declaration in the current scope, you can still access it by instead writing &lt;code&gt;CORE::evalbytes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179018de7994d8b6f7b55507310a9615bad0e417" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expect: &amp;lt;array&amp;gt;&lt;/code&gt; is a short notation for this &lt;code&gt;eexpect&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;expect: &amp;lt;array&amp;gt;&lt;/code&gt; 是此 &lt;code&gt;eexpect&lt;/code&gt; 的简写：</target>
        </trans-unit>
        <trans-unit id="74b965e6bf6e28d59b48d2bde20f57fce49e6c34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extensions&lt;/code&gt; (optional)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deecc348c11dde7ab1e03c51382e2279d9a03d0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extproc&lt;/code&gt; on the first line</source>
          <target state="translated">&lt;code&gt;extproc&lt;/code&gt; 第一行上的extproc</target>
        </trans-unit>
        <trans-unit id="19dbee10355caceed0f77948f5b13c6093e8c93f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_archive&lt;/code&gt; will return a list of files it extracted. If the archive extraction fails for any reason, &lt;code&gt;extract_archive&lt;/code&gt; will return false. Please use the &lt;code&gt;error&lt;/code&gt; method to find the cause of the failure.</source>
          <target state="translated">&lt;code&gt;extract_archive&lt;/code&gt; 将返回它提取的文件列表。如果档案提取由于任何原因失败，则 &lt;code&gt;extract_archive&lt;/code&gt; 将返回false。请使用 &lt;code&gt;error&lt;/code&gt; 方法查找失败原因。</target>
        </trans-unit>
        <trans-unit id="ca87326018240d68425ad1527419ad3fb2334b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; encountered a closing bracket where none was expected.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; ， &lt;code&gt;extract_quotelike&lt;/code&gt; 或 &lt;code&gt;extract_codeblock&lt;/code&gt; 遇到了一个不希望出现的右括号。</target>
        </trans-unit>
        <trans-unit id="72a77e28ef0d2e144274c8fbd24790f3d60b8b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found a valid bracket delimiter, but it was the wrong species. This usually indicates a nesting error, but may indicate incorrect quoting or escaping.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; ， &lt;code&gt;extract_quotelike&lt;/code&gt; 或 &lt;code&gt;extract_codeblock&lt;/code&gt; 找到有效的括号定界符，但这是错误的种类。这通常表示嵌套错误，但可能表示引用或转义不正确。</target>
        </trans-unit>
        <trans-unit id="f1c61a56ae758be3198ca7d3e691e7f13c95604c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; , &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; ran out of characters in the text before closing one or more levels of nested brackets.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 在关闭一层或多层嵌套括号之前，extract_bracketed， &lt;code&gt;extract_quotelike&lt;/code&gt; 或 &lt;code&gt;extract_codeblock&lt;/code&gt; 用尽了文本中的字符。</target>
        </trans-unit>
        <trans-unit id="bfcf9f5f74cb5d8d60170baf76820bbca368d16b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; attempted to match an embedded quoted substring, but failed to find a closing quote to match it.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 尝试匹配嵌入的带引号的子字符串，但找不到匹配的结束引号。</target>
        </trans-unit>
        <trans-unit id="bfae41ac82a57d25a5fa6795b1393b8584c13411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; extracts a balanced-bracket-delimited substring (using any one (or more) of the user-specified delimiter brackets: '(..)', '{..}', '[..]', or '&amp;lt;..&amp;gt;'). Optionally it will also respect quoted unbalanced brackets (see below).</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 提取由括号分隔的，由用户指定的定界括号中的任意一个（或多个）的子字符串：&amp;ldquo;（..）&amp;rdquo;，&amp;ldquo; {..}&amp;rdquo;，&amp;ldquo; [..]&amp;rdquo;或&amp;ldquo; &amp;lt;&amp;rdquo;。 。&amp;gt;'）。也可以选择引用不平衡括号（请参阅下文）。</target>
        </trans-unit>
        <trans-unit id="833ede635970a6e5a4797a94bd40b236c96804f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; was expecting a particular kind of bracket at the start of the text, and didn't find it.</source>
          <target state="translated">&lt;code&gt;extract_bracketed&lt;/code&gt; 或 &lt;code&gt;extract_codeblock&lt;/code&gt; 在文本开始处期望使用一种特定的括号，但未找到。</target>
        </trans-unit>
        <trans-unit id="4a45731bb5aa248616cdb9fafdf56e8d940bf269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; encountered a closing bracket where none was expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d590e5fca928736e4fae37f9e6f0f84bdee1c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found a valid bracket delimiter, but it was the wrong species. This usually indicates a nesting error, but may indicate incorrect quoting or escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddee3801248709ac16da6636768868acf2620266" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_bracketed&lt;/code&gt;, &lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; ran out of characters in the text before closing one or more levels of nested brackets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f0769606e5c4df36d78fd7ab228e7c6b52a6d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; attempts to recognize and extract a balanced bracket delimited substring that may contain unbalanced brackets inside Perl quotes or quotelike operations. That is, &lt;code&gt;extract_codeblock&lt;/code&gt; is like a combination of &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; and &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; 尝试识别并提取平衡括号定界的子字符串，该子字符串可能在Perl引号或类似quotes的操作中包含不平衡的括号。也就是说， &lt;code&gt;extract_codeblock&lt;/code&gt; 类似于 &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4da43577dc402673868ed17831e422f8eccde828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; attempts to recognize and extract a balanced bracket delimited substring that may contain unbalanced brackets inside Perl quotes or quotelike operations. That is, &lt;code&gt;extract_codeblock&lt;/code&gt; is like a combination of &lt;code&gt;&quot;extract_bracketed&quot;&lt;/code&gt; and &lt;code&gt;&quot;extract_quotelike&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="694f659fbf30e806d0fa08eafebb27223e5e1129" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find a closing bracket to match the outermost opening bracket.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; 无法找到与最外面的开括号匹配的右括号。</target>
        </trans-unit>
        <trans-unit id="2f9d1a3929e3f32a4e394299c676fec1e2f105c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; failed to find any of the outermost opening brackets that were specified.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; 无法找到指定的任何最外面的左括号。</target>
        </trans-unit>
        <trans-unit id="8bdacc14c0fedd54fcae38c1a59283dd12b5836e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; or &lt;code&gt;extract_quotelike&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; followed by only one block.</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; 或 &lt;code&gt;extract_quotelike&lt;/code&gt; 找到了单引号运算符 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 之一,后面仅是一个块。</target>
        </trans-unit>
        <trans-unit id="f6a92eacd39bc7f787944a3b9917dfa9f9b5ec41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; or &lt;code&gt;extract_quotelike&lt;/code&gt; found one of the quotelike operators &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; followed by only one block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2826adf3635e5637db1b98091d6fce40bd4513f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; takes the same initial three parameters as &lt;code&gt;extract_bracketed&lt;/code&gt; : a text to process, a set of delimiter brackets to look for, and a prefix to match first. It also takes an optional fourth parameter, which allows the outermost delimiter brackets to be specified separately (see below).</source>
          <target state="translated">&lt;code&gt;extract_codeblock&lt;/code&gt; 的初始三个参数与 &lt;code&gt;extract_bracketed&lt;/code&gt; 相同：要处理的文本，要查找的一组定括号，以及首先匹配的前缀。它还带有一个可选的第四个参数，该参数允许单独指定最外面的定界符括号（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="f5cda6d68a0151b9aacc663e55ec28d4b940acf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_codeblock&lt;/code&gt; takes the same initial three parameters as &lt;code&gt;extract_bracketed&lt;/code&gt;: a text to process, a set of delimiter brackets to look for, and a prefix to match first. It also takes an optional fourth parameter, which allows the outermost delimiter brackets to be specified separately (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da20ba6f0882f09698a1ff177d4124f0036f0383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_delimited&lt;/code&gt; takes up to four scalars (the input text, the delimiters, a prefix pattern to be skipped, and any escape characters) and extracts the initial substring of the text that is appropriately delimited. If the delimiter string has multiple characters, the first one encountered in the text is taken to delimit the substring. The third argument specifies a prefix pattern that is to be skipped (but must be present!) before the substring is extracted. The final argument specifies the escape character to be used for each delimiter.</source>
          <target state="translated">&lt;code&gt;extract_delimited&lt;/code&gt; 最多使用四个标量（输入文本，定界符，要跳过的前缀模式以及任何转义字符），并提取适当定界的文本的初始子字符串。如果定界符字符串包含多个字符，则将文本中遇到的第一个字符定界为子字符串。第三个参数指定在提取子字符串之前将被跳过（但必须存在！）的前缀模式。最后一个参数指定每个分隔符使用的转义字符。</target>
        </trans-unit>
        <trans-unit id="9a4b075e70a63982d5b04d16716a200671436a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; and &quot;here documents&quot;</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 和&amp;ldquo;这里文档&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5c7ff486ca0937ffab3f029877d80d0f77ca3ff8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; attempts to recognize, extract, and segment any one of the various Perl quotes and quotelike operators (see</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 尝试识别，提取和分段各种Perl引号和quotelike运算符中的任何一个（请参见</target>
        </trans-unit>
        <trans-unit id="e49376bba1a57bb121a86f40bd906f99d7e393b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; attempts to recognize, extract, and segment any one of the various Perl quotes and quotelike operators (see &lt;a href=&quot;http://man.he.net/man3/perlop&quot;&gt;perlop(3)&lt;/a&gt;) Nested backslashed delimiters, embedded balanced bracket delimiters (for the quotelike operators), and trailing modifiers are all caught. For example, in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59ff49a4b5f6ba09b71fdea263cb8784806bf34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; can successfully extract &quot;here documents&quot; from an input string, but with an important caveat in list contexts.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 可以从输入字符串中成功提取&amp;ldquo;此处文档&amp;rdquo;，但在列表上下文中有一个重要警告。</target>
        </trans-unit>
        <trans-unit id="eb113a6f5a0b8ca2853b562185e3dd6bf68a942d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; didn't find one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; at the start of the substring it was extracting.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 在要提取的子字符串的开头未找到quotelike运算符 &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 之一。</target>
        </trans-unit>
        <trans-unit id="3a30762562d768e35f6aede04f00e83c3be02aab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; didn't find one of the quotelike operators &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; at the start of the substring it was extracting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639f29c8f92e2cdfb541e8edc25037e7eac4fd9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found one of the quotelike operators &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; without a suitable block after it.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 或 &lt;code&gt;extract_codeblock&lt;/code&gt; 找到了quotelike运算符 &lt;code&gt;&lt;a href=&quot;../functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qq&quot;&gt;qq&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qw&quot;&gt;qw&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; 之一,之后没有合适的块。</target>
        </trans-unit>
        <trans-unit id="d7b0db775ac5b5ea6f3ac5b6f63eeb7043731821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; or &lt;code&gt;extract_codeblock&lt;/code&gt; found one of the quotelike operators &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;qq&lt;/code&gt;, &lt;code&gt;qw&lt;/code&gt;, &lt;code&gt;qx&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; without a suitable block after it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce38c6b480941e81870d18e2d86b4e985230f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; takes two arguments: the text to be processed and a prefix to be matched at the very beginning of the text. If no prefix is specified, optional whitespace is the default. If no text is given, &lt;code&gt;$_&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 具有两个参数：要处理的文本和在文本开头要匹配的前缀。如果未指定前缀，则默认为可选空格。如果未给出任何文本，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5cd291985f40d2410dcdccea5aef6741ed9a4c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_quotelike&lt;/code&gt; was unable to find a closing delimiter to match the one that opened the quote-like operation.</source>
          <target state="translated">&lt;code&gt;extract_quotelike&lt;/code&gt; 无法找到结束定界符来匹配打开了类似报价操作的定界符。</target>
        </trans-unit>
        <trans-unit id="ab932311516affb26a779abd90bbf158ec7ed4da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; did not find a suitable opening tag (after any specified prefix was removed).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 找不到合适的开始标记（在删除任何指定的前缀之后）。</target>
        </trans-unit>
        <trans-unit id="d49b4a8e3f85ed5cd73910afb7ee2c747a5c1b85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; extracts and segments text between (balanced) specified tags.</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 提取并分割（平衡的）指定标签之间的文本。</target>
        </trans-unit>
        <trans-unit id="637bdb2768eba3ece0f28cf5c91285d816ae9df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested opening tag that was not matched by a corresponding nested closing tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 找到了与相应的嵌套结束标签不匹配的嵌套开始标签（并且失败模式不是&amp;ldquo; MAX&amp;rdquo;或&amp;ldquo; PARA&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="907d9c187b04ce8805d54962d6f295d6dafa82c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; found a nested tag that appeared in the &quot;reject&quot; list (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 找到了一个嵌套标签，该标签出现在&amp;ldquo;拒绝&amp;rdquo;列表中（并且失败模式不是&amp;ldquo; MAX&amp;rdquo;或&amp;ldquo; PARA&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="2c6e6b22bc490e070f19db3dd2c598898377ca76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; matched the specified opening tag and tried to modify the matched text to produce a matching closing tag (because none was specified). It failed to generate the closing tag, almost certainly because the opening tag did not start with a bracket of some kind.</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 匹配指定的开始标记，并尝试修改匹配的文本以产生匹配的结束标记（因为未指定任何结束标记）。它未能生成结束标记，几乎可以肯定是因为开始标记不是以某种括号开头。</target>
        </trans-unit>
        <trans-unit id="618b7e2d79570afb079bf76fc8475883cfbcb511" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_tagged&lt;/code&gt; reached the end of the text without finding a closing tag to match the original opening tag (and the failure mode was not &quot;MAX&quot; or &quot;PARA&quot;).</source>
          <target state="translated">&lt;code&gt;extract_tagged&lt;/code&gt; 到达了文本的结尾，而没有找到与原始的开始标记匹配的结束标记（并且失败模式不是&amp;ldquo; MAX&amp;rdquo;或&amp;ldquo; PARA&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="dc8016033fd7e7766b06e4030e83ba977c1f1697" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; extracts any valid Perl variable or variable-involved expression, including scalars, arrays, hashes, array accesses, hash look-ups, method calls through objects, subroutine calls through subroutine references, etc.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; 提取任何有效的Perl变量或涉及变量的表达式，包括标量，数组，哈希，数组访问，哈希查找，通过对象的方法调用，通过子例程引用的子例程调用等。</target>
        </trans-unit>
        <trans-unit id="9b44e96da00224d0d2ec78bc381db1051d7b97be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; found a '$', '@', or '%' indicating a variable, but that character was not followed by a legal Perl identifier.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; 找到了表示变量的'$'，'@'或'％'，但是该字符后没有合法的Perl标识符。</target>
        </trans-unit>
        <trans-unit id="73dce7208a693c0dcdcc44097a9a03bc9f5f50c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extract_variable&lt;/code&gt; was expecting one of '$', '@', or '%' at the start of a variable, but didn't find any of them.</source>
          <target state="translated">&lt;code&gt;extract_variable&lt;/code&gt; 期望变量开头为&amp;ldquo; $&amp;rdquo;，&amp;ldquo; @&amp;rdquo;或&amp;ldquo;％&amp;rdquo;之一，但未找到任何一个。</target>
        </trans-unit>
        <trans-unit id="20f94a649b0ac6110d4b4e974451200d805dd893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facet_data()&lt;/code&gt;&lt;b&gt;MUST NOT&lt;/b&gt; bless the data it returns, the main hashref, and nested facet hashrefs &lt;b&gt;MUST&lt;/b&gt; be bare, though items contained within each facet may be blessed. The data returned by this method &lt;b&gt;should&lt;/b&gt; also be copies of the internal data in order to prevent accidental state modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c207b36e130877d93d86cdcf28960f660fef059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;facets()&lt;/code&gt; takes the data from &lt;code&gt;facet_data()&lt;/code&gt; and blesses it into the &lt;code&gt;Test2::EventFacet::*&lt;/code&gt; packages. This is rarely used however, the EventFacet packages are primarily for convenience and documentation. The EventFacet classes are not used at all internally, instead the raw data is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7183702bf36011a80e32e87169e8ae3121aaff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdopen&lt;/code&gt; is like an ordinary &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, an IO::Handle object, or a file descriptor number. (For the documentation of the &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; method, see &lt;a href=&quot;file&quot;&gt;IO::File&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;fdopen&lt;/code&gt; 类似于普通的 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 不同之处在于它的第一个参数不是文件名而是文件句柄名称，IO :: Handle对象或文件描述符号。（有关 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 方法的文档，请参见&lt;a href=&quot;file&quot;&gt;IO :: File&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="ba238f8e74bf4f53dc4869a9be342bb73099fd15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fdopen&lt;/code&gt; is like an ordinary &lt;code&gt;open&lt;/code&gt; except that its first parameter is not a filename but rather a file handle name, an IO::Handle object, or a file descriptor number. (For the documentation of the &lt;code&gt;open&lt;/code&gt; method, see &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03fc961bee53ba972305eb9fb700a55c4e14e62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fill_mstats($buf)&lt;/code&gt; is a much cheaper call (both speedwise and memory-wise) which collects the statistic into $buf in machine-readable form. At a later moment you may need to call &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; to use this information to fill %hash.</source>
          <target state="translated">&lt;code&gt;fill_mstats($buf)&lt;/code&gt; 是一个便宜得多的调用（包括速度和内存），它以机器可读的形式将统计信息收集到$ buf中。稍后，您可能需要调用 &lt;code&gt;mstats2hash($buf, %hash)&lt;/code&gt; 来使用此信息填充％hash。</target>
        </trans-unit>
        <trans-unit id="a7e5d4f5538cc74799b8419786d322d044582dea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find()&lt;/code&gt; does a depth-first search over the given &lt;code&gt;@directories&lt;/code&gt; in the order they are given. For each file or directory found, it calls the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine. (See below for details on how to use the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function). Additionally, for each directory found, it will &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; into that directory and continue the search, invoking the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function on each file or subdirectory in the directory.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 按照给定的 &lt;code&gt;@directories&lt;/code&gt; 顺序进行深度优先搜索。对于找到的每个文件或目录，它都调用 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 子例程。（有关如何使用 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 功能的详细信息，请参见下文）。此外，对于找到的每个目录，它将 &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 进入该目录并继续搜索，并在目录中的每个文件或子目录上调用 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ecdfb26abf3b15965a5901fd7cf35ec4653a258c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find()&lt;/code&gt; does a depth-first search over the given &lt;code&gt;@directories&lt;/code&gt; in the order they are given. For each file or directory found, it calls the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine. (See below for details on how to use the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function). Additionally, for each directory found, it will &lt;code&gt;chdir()&lt;/code&gt; into that directory and continue the search, invoking the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function on each file or subdirectory in the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26ed17cfa2816485cbc28d5fbb0568e82932f2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finddepth()&lt;/code&gt; works just like &lt;code&gt;find()&lt;/code&gt; except that it invokes the &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function for a directory</source>
          <target state="translated">&lt;code&gt;finddepth()&lt;/code&gt; 的作用与 &lt;code&gt;find()&lt;/code&gt; 相同，只是它为目录调用 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="29620a24a0df648a414eb9cf851d4bf4806d6e4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; allows only &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt; , which allows for trailing non-numeric text on an otherwise successful</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 仅允许 &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt; ，这允许在非成功文本上尾随非数字文本</target>
        </trans-unit>
        <trans-unit id="7171c0330153fbec23956fd5954483c8d49fec81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; allows only &lt;code&gt;PERL_SCAN_TRAILING&lt;/code&gt;, which allows for trailing non-numeric text on an otherwise successful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="614a8eed1e0bbdcf6096b1e5784e3dc7f58643a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; can be set to &lt;code&gt;SVf_UTF8&lt;/code&gt; if &lt;code&gt;name&lt;/code&gt; is a UTF-8 string, or the return value of SvUTF8(sv). It can also take the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag, which means to pretend that the GV has been seen before (i.e., suppress &quot;Used once&quot; warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaeb70073109db72816d4b058f24b70066251071" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; can be set to SVf_UTF8 if &lt;code&gt;name&lt;/code&gt; is a UTF8 string, or the return value of SvUTF8(sv). It can also take the GV_ADDMULTI flag, which means to pretend that the GV has been seen before (i.e., suppress &quot;Used once&quot; warnings).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 如果 &lt;code&gt;name&lt;/code&gt; 是UTF8字符串或SvUTF8（sv）的返回值，则可以将标志设置为SVf_UTF8 。它还可以采用GV_ADDMULTI标志，这意味着要假装以前已经看到过GV（即，禁止显示&amp;ldquo; Used一次&amp;rdquo;警告）。</target>
        </trans-unit>
        <trans-unit id="af26d30e7c49fe5fc911e7d99c64282995d4a35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op, except that (in both cases) some bits will be set automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d63eaae2e4ad0abf234a638df832de5d65b2c05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; gives the eight bits of &lt;code&gt;op_flags&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op and, shifted up eight bits, the eight bits of &lt;code&gt;op_private&lt;/code&gt; for the &lt;code&gt;leaveloop&lt;/code&gt; op, except that (in both cases) some bits will be set automatically. &lt;code&gt;debuggable&lt;/code&gt; is currently unused and should always be 1. &lt;code&gt;has_my&lt;/code&gt; can be supplied as true to force the loop body to be enclosed in its own scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b88293d06ab0496f44e00df866b365eed7013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt; should not have bits set other than &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e3f0cb7744b6ea7a16d5b8162ae81c50f936d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush&lt;/code&gt; causes perl to flush any buffered data at the perlio api level. Any unread data in the buffer will be discarded, and any unwritten data will be written to the underlying file descriptor. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 使perl在perlio api级别刷新所有缓冲的数据。缓冲区中所有未读取的数据都将被丢弃，所有未写入的数据将被写入基础文件描述符。成功返回&amp;ldquo; 0但为真&amp;rdquo;，错误返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91e1b1bbf7facbe29fb8a23eea44f2865198a992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush&lt;/code&gt; causes perl to flush any buffered data at the perlio api level. Any unread data in the buffer will be discarded, and any unwritten data will be written to the underlying file descriptor. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9905682a79a998de7ff1e83caeeafa645f241b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush_cache(function)&lt;/code&gt; will flush out the caches, discarding</source>
          <target state="translated">&lt;code&gt;flush_cache(function)&lt;/code&gt; 将刷新缓存，丢弃</target>
        </trans-unit>
        <trans-unit id="3b5d6c6cb2f1fedfbb1c398cf830e60872b2d25d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==0&lt;/code&gt; causes File::Find to die if any file is about to be processed a second time.</source>
          <target state="translated">&lt;code&gt;follow_skip==0&lt;/code&gt; 导致File :: Find死亡，如果有任何文件将要第二次处理。</target>
        </trans-unit>
        <trans-unit id="245a14cc849e45d0f21aa3c6a45e6687f9b1b64a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==1&lt;/code&gt; , which is the default, causes all files which are neither directories nor symbolic links to be ignored if they are about to be processed a second time. If a directory or a symbolic link are about to be processed a second time, File::Find dies.</source>
          <target state="translated">&lt;code&gt;follow_skip==1&lt;/code&gt; ，这是默认设置，如果要第二次处理的文件既不是目录也不是符号链接，则这些文件将被忽略。如果将要再次处理目录或符号链接，则File :: Find将消失。</target>
        </trans-unit>
        <trans-unit id="026104b97f9533b4576c52cb6c4fc5b33b90adb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==1&lt;/code&gt;, which is the default, causes all files which are neither directories nor symbolic links to be ignored if they are about to be processed a second time. If a directory or a symbolic link are about to be processed a second time, File::Find dies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a84133d805b081624353f19b1e15e4f4f2316a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;follow_skip==2&lt;/code&gt; causes File::Find to ignore any duplicate files and directories but to proceed normally otherwise.</source>
          <target state="translated">&lt;code&gt;follow_skip==2&lt;/code&gt; 导致File :: Find忽略任何重复的文件和目录，但否则继续正常进行。</target>
        </trans-unit>
        <trans-unit id="b488c92ca6be1e23d4299b935b09ca768ca7bd88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="af037f92dbe22f9677ccba3af252180c69239c0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foreach&lt;/code&gt; probably won't do what you expect if VAR is a tied or other special variable. Don't do that either.</source>
          <target state="translated">&lt;code&gt;foreach&lt;/code&gt; 如果VAR是绑定变量或其他特殊变量，foreach可能不会达到您的期望。也不要那样做。</target>
        </trans-unit>
        <trans-unit id="c77ca2a6b9d0be9c729a47c07b760579edd1d389" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fork()&lt;/code&gt; failures in io_* tests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4a74a3423620b717e8515966c608ea94d077f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_to()&lt;/code&gt; returns the length of the converted string in octets on success, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error.</source>
          <target state="translated">&lt;code&gt;from_to()&lt;/code&gt; 成功时返回转换后的字符串的长度（以八位字节为单位），错误时返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="672d95b5197c0899f13971854b9235675a12d726" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from_to()&lt;/code&gt; returns the length of the converted string in octets on success, and &lt;code&gt;undef&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee56073a87e8cb2ec407581f4115873a117f0638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_delimited_pat&lt;/code&gt; may also be called with an optional second argument, which specifies the &quot;escape&quot; character(s) to be used for each delimiter. For example to match a Pascal-style string (where ' is the delimiter and '' is a literal ' within the string):</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; 也可以使用可选的第二个参数来调用，该参数指定要用于每个定界符的&amp;ldquo;转义&amp;rdquo;字符。例如，匹配Pascal样式的字符串（其中'是定界符，而'是字符串中的文字'）：</target>
        </trans-unit>
        <trans-unit id="6a3889013df238b89a769a62665a92aecb6580a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_extract_tagged&lt;/code&gt; generates a new anonymous subroutine which extracts text between (balanced) specified tags. In other words, it generates a function identical in function to &lt;code&gt;extract_tagged&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gen_extract_tagged&lt;/code&gt; 生成一个新的匿名子例程，该例程提取（平衡的）指定标签之间的文本。换句话说，它将生成一个功能与 &lt;code&gt;extract_tagged&lt;/code&gt; 相同的函数。</target>
        </trans-unit>
        <trans-unit id="9bbf5657fac9df51b50196a5452cc515e378127f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gen_extract_tagged&lt;/code&gt; generates a new anonymous subroutine which extracts text between (balanced) specified tags. In other words, it generates a function identical in function to &lt;code&gt;extract_tagged&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fc46087afc34909f3ff50b3a35f51dd87159b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; downloads a distribution file and untars or unzips it, &lt;code&gt;make&lt;/code&gt; builds it, &lt;code&gt;test&lt;/code&gt; runs the test suite, and &lt;code&gt;install&lt;/code&gt; installs it.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 下载一个分发文件并解压缩或解压缩， &lt;code&gt;make&lt;/code&gt; 构建， &lt;code&gt;test&lt;/code&gt; 运行测试套件，然后 &lt;code&gt;install&lt;/code&gt; 安装。</target>
        </trans-unit>
        <trans-unit id="d351e786b644f3f2b7497656e40ab3f1597c2ae6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_boolean_values&lt;/code&gt; will return both &lt;code&gt;$false&lt;/code&gt; and &lt;code&gt;$true&lt;/code&gt; values, or the empty list when they are set to the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597f829bafddc48835ebea8c700b577d34cea8b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of the list of classes it will try using. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_language_classes&lt;/code&gt; , which currently returns an empty list, &lt;code&gt;()&lt;/code&gt; . By setting this to some value (namely, the name of a loadable language class), you can be sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle.</source>
          <target state="translated">&lt;code&gt;get_handle&lt;/code&gt; 将此返回值附加到它将尝试使用的类列表的末尾。除非您重写此方法，否则您的项目类将继承Locale :: Maketext的 &lt;code&gt;fallback_language_classes&lt;/code&gt; ，该类当前返回一个空列表 &lt;code&gt;()&lt;/code&gt; 。通过将此值设置为某个值（即可加载语言类的名称），可以确保 &lt;code&gt;get_handle&lt;/code&gt; 将始终设法构造语言句柄。</target>
        </trans-unit>
        <trans-unit id="22ee173dd1f9b2a3f3bb6edc486372896578d7ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of the list of classes it will try using. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_language_classes&lt;/code&gt;, which currently returns an empty list, &lt;code&gt;()&lt;/code&gt;. By setting this to some value (namely, the name of a loadable language class), you can be sure that &lt;code&gt;get_handle&lt;/code&gt; will always manage to construct a language handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d51dfcba73441795cbac2c1e95e837ccfcfefe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of whatever list of languages you pass &lt;code&gt;get_handle&lt;/code&gt; . Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_languages&lt;/code&gt; , which currently returns &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt; . (&quot;i-default&quot; is defined in RFC 2277).</source>
          <target state="translated">&lt;code&gt;get_handle&lt;/code&gt; 将此返回值附加到您传递 &lt;code&gt;get_handle&lt;/code&gt; 的任何语言列表的末尾。除非您重写此方法，否则您的项目类将继承Locale :: Maketext的 &lt;code&gt;fallback_languages&lt;/code&gt; ，当前返回 &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt; 。（&amp;ldquo; i-default&amp;rdquo;在RFC 2277中定义）。</target>
        </trans-unit>
        <trans-unit id="d8695d8032fc674b78a2595bf473473eea2d50cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_handle&lt;/code&gt; appends the return value of this to the end of whatever list of languages you pass &lt;code&gt;get_handle&lt;/code&gt;. Unless you override this method, your project class will inherit Locale::Maketext's &lt;code&gt;fallback_languages&lt;/code&gt;, which currently returns &lt;code&gt;('i-default', 'en', 'en-US')&lt;/code&gt;. (&quot;i-default&quot; is defined in RFC 2277).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5a63aa356061956451266a1a4014ccae3657913" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gflags&lt;/code&gt; is a bitset passed into &lt;code&gt;cv_get_call_checker_flags&lt;/code&gt;, in which only the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit currently has a defined meaning (for which see above). All other bits should be clear.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b6200f87d8690cdac1f4cd712e3e4cb1d3352b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git help bisect&lt;/code&gt; has much more information on how you can tweak your binary searches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf569ccd5c0de9aae2bc67f8d6ef04eaf70c3485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git&lt;/code&gt; only supports &lt;code&gt;git://&lt;/code&gt; style urls.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 仅支持 &lt;code&gt;git://&lt;/code&gt; 样式网址。</target>
        </trans-unit>
        <trans-unit id="d8268d82cd8cca36bfee8e5f93d5ca671bace665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git&lt;/code&gt; provides a built-in way to determine which commit should be blamed for introducing a given bug. &lt;code&gt;git bisect&lt;/code&gt; performs a binary search of history to locate the first failing commit. It is fast, powerful and flexible, but requires some setup and to automate the process an auxiliary shell script is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc088f44c39e54fa76b55bd407e420ecf8e1449" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;glob&lt;/code&gt; (aka the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85aa8588ef6572feba5f3f7196b55f9be2ff8a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gnu_compat&lt;/code&gt; controls whether &lt;code&gt;--opt=&lt;/code&gt; is allowed, and what it should do. Without &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; gives an error. With &lt;code&gt;gnu_compat&lt;/code&gt; , &lt;code&gt;--opt=&lt;/code&gt; will give option &lt;code&gt;opt&lt;/code&gt; and empty value. This is the way GNU getopt_long() does it.</source>
          <target state="translated">&lt;code&gt;gnu_compat&lt;/code&gt; 控制是否允许 &lt;code&gt;--opt=&lt;/code&gt; 以及它应该做什么。如果没有 &lt;code&gt;gnu_compat&lt;/code&gt; ，-- opt &lt;code&gt;--opt=&lt;/code&gt; 会给出错误。使用 &lt;code&gt;gnu_compat&lt;/code&gt; 时，-- &lt;code&gt;opt&lt;/code&gt; &lt;code&gt;--opt=&lt;/code&gt; 将提供选项opt和空值。这就是GNU getopt_long（）做到的方式。</target>
        </trans-unit>
        <trans-unit id="1fb0e41171264b2fcf37c5326ff38ff8093328b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gnu_compat&lt;/code&gt; controls whether &lt;code&gt;--opt=&lt;/code&gt; is allowed, and what it should do. Without &lt;code&gt;gnu_compat&lt;/code&gt;, &lt;code&gt;--opt=&lt;/code&gt; gives an error. With &lt;code&gt;gnu_compat&lt;/code&gt;, &lt;code&gt;--opt=&lt;/code&gt; will give option &lt;code&gt;opt&lt;/code&gt; and empty value. This is the way GNU getopt_long() does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da23eeb6ab9c230c23432ea70d9c9e7b965fbe5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gunzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gunzip&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c9ace767cb2b2374e63f5abf0af97e52a9d9d8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gunzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b8e8c4b2f2968447ed1a4e47f9c92d6075290d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gv&lt;/code&gt; is the scalar to be converted.</source>
          <target state="translated">&lt;code&gt;gv&lt;/code&gt; 是要转换的标量。</target>
        </trans-unit>
        <trans-unit id="29db96deb265ac3c7d7d0953f53bc03ef4c2f394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzip&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5da4c82cd1e22cff5477e13c973e757d29f5ee30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e485962ec7928cc06b861622e567d3b05cbb64fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;headers&lt;/code&gt; &amp;mdash; A hashref containing headers to include with the request. If the value for a header is an array reference, the header will be output multiple times with each value in the array. These headers over-write any default headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1d4418109cbb26543d41a26530b027814f6656" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;headers&lt;/code&gt; &amp;mdash; A hashref of header fields. All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e77ef19371ab42dd3ee159db29ed1de58b556a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;help&lt;/code&gt; will get you into the documentation, but here are the most useful commands:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 将带您进入文档，但以下是最有用的命令：</target>
        </trans-unit>
        <trans-unit id="f33ba501199bdab9a127e2b1f7b1b40f51678514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;host&lt;/code&gt; - sets the hostname to send the messages to. Defaults to the local host.</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; -设置要将消息发送到的主机名。默认为本地主机。</target>
        </trans-unit>
        <trans-unit id="4e594d75a523d0b29a6964865cae46c3baf58a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http_proxy&lt;/code&gt; &amp;mdash; URL of a proxy server to use for HTTP connections (default is &lt;code&gt;$ENV{http_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5895745da68f010ab6aec5d542142c34e2b7b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;https_proxy&lt;/code&gt; &amp;mdash; URL of a proxy server to use for HTTPS connections (default is &lt;code&gt;$ENV{https_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c02ec2bc6d085cd003b0ab590c3cedf46f1d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; are also allowed, but only for completeness' sake: they are identical to &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;i!&lt;/code&gt; 和 &lt;code&gt;I!&lt;/code&gt; 也允许，但仅出于完整性考虑：它们与 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;I&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="6dde773a6381ea57f8b793ad51ce4b833a11dc40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; are also allowed, but only for completeness' sake: they are identical to &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38745558cff56e73757d72d93d0e833b8ab829ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id()&lt;/code&gt; also uses a caching technique that makes it faster when the id of an object is requested often, but slower if it is needed only once or twice.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 还使用了一种缓存技术，该缓存技术可以在经常请求对象的id时提高速度，而在仅需要一次或两次时才需要降低速度。</target>
        </trans-unit>
        <trans-unit id="1014df6f9393ccdb9b982a8f0cdabec78db82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; executes the statement once</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 执行一次语句</target>
        </trans-unit>
        <trans-unit id="eb7b50383640c576cc08e55940c0c7707ec58e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import()&lt;/code&gt; also sets the &lt;code&gt;exported_to()&lt;/code&gt; attribute of your builder to be the caller of the &lt;code&gt;import()&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b896458be3e65959268ad7eb2dbf0a7972aba118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import_extra()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt;. It provides an opportunity for you to add behaviors to your module based on its import list.</source>
          <target state="translated">&lt;code&gt;import_extra()&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 调用。它为您提供了一个机会，可以根据其导入列表将行为添加到模块中。</target>
        </trans-unit>
        <trans-unit id="f483cc5110be6dfd3ea84e7481c93d23c9b2cfbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import_extra()&lt;/code&gt; is called by &lt;code&gt;import()&lt;/code&gt;. It provides an opportunity for you to add behaviors to your module based on its import list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf041671b0859bae0d069d4abdaaec3333d3078b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0f527451c4c09e71909bf3e5ee9143eaa7dc55c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3558f4a652411d66d86103524bc11a04a66d749f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert&lt;/code&gt; is the first of a chain of nodes to be inserted in place of the nodes. If &lt;code&gt;NULL&lt;/code&gt;, no nodes are inserted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd51f04bea97ece8157da9d1a364211a462e769c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int()&lt;/code&gt; returns (at least for Perl v5.7.1 and up) another Math::BigInt, not a Perl scalar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71a7ef622103e498c3f87e97051142dd1bd19ab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intsize&lt;/code&gt;, &lt;code&gt;longsize&lt;/code&gt;, &lt;code&gt;ptrsize&lt;/code&gt;, &lt;code&gt;nvsize&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48e2284b44cc7c2c571d6415bc1d2a1c3a3bad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iosock&lt;/code&gt; is a very limited &lt;a href=&quot;../io/socket/inet&quot;&gt;IO::Socket::INET&lt;/a&gt; based mechanism for retrieving &lt;code&gt;http&lt;/code&gt; schemed urls. It doesn't follow redirects for instance.</source>
          <target state="translated">&lt;code&gt;iosock&lt;/code&gt; 是一种非常有限的基于&lt;a href=&quot;../io/socket/inet&quot;&gt;IO :: Socket :: INET&lt;/a&gt;的机制，用于检索 &lt;code&gt;http&lt;/code&gt; 计划的url。例如，它不遵循重定向。</target>
        </trans-unit>
        <trans-unit id="0dbd4c2804b7173533ec0bb2e4bcaf5ac3324b87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iosock&lt;/code&gt; is a very limited &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt; based mechanism for retrieving &lt;code&gt;http&lt;/code&gt; schemed urls. It doesn't follow redirects for instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f4cb95b2a1340b2264c404136042989b18f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; can do that better and with diagnostics.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; 可以更好地进行诊断。</target>
        </trans-unit>
        <trans-unit id="fa45eb9c353e9becb0910ea19cd26aa2cc1efcb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; compares the dereferenced values of references, the references themselves (except for their type) are ignored. This means aspects such as blessing and ties are not considered &quot;different&quot;.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; 比较引用的解引用值，引用本身（类型除外）将被忽略。这意味着祝福和纽带等方面不被视为&amp;ldquo;不同&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3ac9608b72d885f105d8ded955f2852bb1f4026f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_deeply()&lt;/code&gt; currently has very limited handling of function reference and globs. It merely checks if they have the same referent. This may improve in the future.</source>
          <target state="translated">&lt;code&gt;is_deeply()&lt;/code&gt; 当前对函数引用和glob的处理非常有限。它仅检查它们是否具有相同的引用对象。将来可能会有所改善。</target>
        </trans-unit>
        <trans-unit id="fc0cb7e93ec296bf828a3ee1cf8be61d7fd1fa20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_indexable($package)&lt;/code&gt; or &lt;code&gt;is_indexable()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fee01bdd14b870e8f587577165aaba8174b5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_loaded&lt;/code&gt; tells you if &lt;code&gt;PACKAGE&lt;/code&gt; has been marked as loaded yet. &lt;code&gt;PACKAGE&lt;/code&gt; can be a bareword or string.</source>
          <target state="translated">&lt;code&gt;is_loaded&lt;/code&gt; 告诉您 &lt;code&gt;PACKAGE&lt;/code&gt; 是否已标记为已加载。 &lt;code&gt;PACKAGE&lt;/code&gt; 可以是空词或字符串。</target>
        </trans-unit>
        <trans-unit id="908cf7f802a6484de1a86d6a37939c96ffeeea32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_negative()&lt;/code&gt; is an alias for &lt;code&gt;is_neg()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;is_negative()&lt;/code&gt; 是一个别名 &lt;code&gt;is_neg()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00a89aa2da974da0bd80f4ecc1bc689f4a5b20cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_negative()&lt;/code&gt; is an alias for &lt;code&gt;is_neg()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57e24bd0e67b03038233cb69159892773438e44e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_our&lt;/code&gt; indicates that the name to check is an 'our' declaration.</source>
          <target state="translated">&lt;code&gt;is_our&lt;/code&gt; 表示要检查的名称是&amp;ldquo;我们的&amp;rdquo;声明。</target>
        </trans-unit>
        <trans-unit id="da7b72a6911cc56de693b87d7cfcdd8872eb161b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_our&lt;/code&gt; indicates that the name to check is an &lt;code&gt;&quot;our&quot;&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a514d3b918898f19b078949b55c4b50405311f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; are aliases to &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; , respectively. &lt;code&gt;is_positive()&lt;/code&gt; and &lt;code&gt;is_negative()&lt;/code&gt; were introduced in v1.36, while &lt;code&gt;is_pos()&lt;/code&gt; and &lt;code&gt;is_neg()&lt;/code&gt; were only introduced in v1.68.</source>
          <target state="translated">&lt;code&gt;is_positive()&lt;/code&gt; 和 &lt;code&gt;is_negative()&lt;/code&gt; 是别名 &lt;code&gt;is_pos()&lt;/code&gt; 和 &lt;code&gt;is_neg()&lt;/code&gt; ，分别。 &lt;code&gt;is_positive()&lt;/code&gt; 和 &lt;code&gt;is_negative()&lt;/code&gt; 在v1.36进行了介绍，而 &lt;code&gt;is_pos()&lt;/code&gt; 和 &lt;code&gt;is_neg()&lt;/code&gt; 在v1.68只引入。</target>
        </trans-unit>
        <trans-unit id="36dbe9a547bda60465b84e97fa8c4255f94a0b23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; is an alias for &lt;code&gt;is_pos()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;is_positive()&lt;/code&gt; 是一个别名 &lt;code&gt;is_pos()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b45717725a93f97c98ac885f9335033581a7488" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_positive()&lt;/code&gt; is an alias for &lt;code&gt;is_pos()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ebfddb80039ad6fdcb40b1907d93271e7168e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_shared&lt;/code&gt; checks if the specified variable is shared or not. If shared, returns the variable's internal ID (similar to &lt;code&gt;refaddr()&lt;/code&gt; (see &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;). Otherwise, returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_shared&lt;/code&gt; 检查指定的变量是否共享。如果是共享的，则返回变量的内部ID（类似于 &lt;code&gt;refaddr()&lt;/code&gt; （请参见&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;）；否则，返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ea930a53c7c204137f02e24dcafe61cde400408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_shared&lt;/code&gt; checks if the specified variable is shared or not. If shared, returns the variable's internal ID (similar to &lt;code&gt;refaddr()&lt;/code&gt; (see &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;). Otherwise, returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3e625f9dccecad6923a6b9bcad7bcf170e05e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isa&lt;/code&gt; methods behave appropriately).</source>
          <target state="translated">&lt;code&gt;isa&lt;/code&gt; 方法的行为正确）。</target>
        </trans-unit>
        <trans-unit id="e786fb8e004ccf42441c2bae194809a7fa5f68ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05461b3d98ad64340381f43af6ab96dfd13c6be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator_factory_class&lt;/code&gt; 如&lt;a href=&quot;#new&quot;&gt;new中&lt;/a&gt;所述，可以定制iterator_factory_class。</target>
        </trans-unit>
        <trans-unit id="9d7fdef8ee5f35a68781b987a4bd55b551b5e336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join()&lt;/code&gt; does three things: it waits for a thread to exit, cleans up after it, and returns any data the thread may have produced. But what if you're not interested in the thread's return values, and you don't really care when the thread finishes? All you want is for the thread to get cleaned up after when it's done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f600d5a5ec1c47fef7c4bad5c4b07ebc4ec7f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;join&lt;/code&gt; waits for a thread to end and returns any values the thread exited with. &lt;code&gt;join&lt;/code&gt; will block until the thread has ended, though it won't block if the thread has already terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7caa9a76fe0a2484851b25ef43baeabc279b7cf3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keep_alive&lt;/code&gt; &amp;mdash; Whether to reuse the last connection (if for the same scheme, host and port) (defaults to 1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5239c2a7e96ba60463f277c06ec272bfc1e133d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill('KILL', ...)&lt;/code&gt; can be used to terminate a pseudo-process by passing it the ID returned by fork(). The outcome of kill on a pseudo-process is unpredictable and it should not be used except under dire circumstances, because the operating system may not guarantee integrity of the process resources when a running thread is terminated. The process which implements the pseudo-processes can be blocked and the Perl interpreter hangs. Note that using &lt;code&gt;kill('KILL', ...)&lt;/code&gt; on a pseudo-process() may typically cause memory leaks, because the thread that implements the pseudo-process does not get a chance to clean up its resources.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eef3dae065531bba805f7320fe343d9e413e353" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kill('TERM', ...)&lt;/code&gt; can also be used on pseudo-processes, but the signal will not be delivered while the pseudo-process is blocked by a system call, e.g. waiting for a socket to connect, or trying to read from a socket with no data available. Starting in Perl 5.14 the parent process will not wait for children to exit once they have been signalled with &lt;code&gt;kill('TERM', ...)&lt;/code&gt; to avoid deadlock during process exit. You will have to explicitly call waitpid() to make sure the child has time to clean-up itself, but you are then also responsible that the child is not blocking on I/O either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6539369a23b2286b09807225af454e166df5f9af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;latin1&lt;/code&gt; or &lt;code&gt;ascii&lt;/code&gt; flags enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e5d23ad52b94ac87ccff8d84b8e8122490c818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_subs&lt;/code&gt; - allow the use of lexical subroutines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0fd51fe978af46143ef7e476cf8a91d754f9403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_topic&lt;/code&gt; - allow the use of lexical &lt;code&gt;$_&lt;/code&gt; via &lt;code&gt;my $_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778b80cfdd673f8fb55921afdf3d3a38219c358b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; is maintained by the perl5-porters. Please direct any questions to the canonical mailing list. Anything that is applicable to the CPAN release can be sent to its maintainer, though.</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 由perl5-porters维护。如有任何疑问，请直接向规范邮件列表发送。但是，适用于CPAN版本的所有内容都可以发送到其维护者。</target>
        </trans-unit>
        <trans-unit id="a79ceaa8331c46467666b58e2fedd38e6ff4a586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lib&lt;/code&gt; will warn about this. The sole exceptions are files with the &lt;code&gt;.par&lt;/code&gt; extension which are intended to be used as libraries.</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 将对此发出警告。唯一的例外是带有 &lt;code&gt;.par&lt;/code&gt; 扩展名的文件，这些文件旨在用作库。</target>
        </trans-unit>
        <trans-unit id="7dbdb4f0306520f7abe5482b14dfce7a7aa50e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;load_handlers&lt;/code&gt; will attempt to load the &lt;code&gt;MySourceHandler&lt;/code&gt; class by looking in &lt;code&gt;@INC&lt;/code&gt; for it in this order:</source>
          <target state="translated">&lt;code&gt;load_handlers&lt;/code&gt; 将尝试通过按以下顺序在 &lt;code&gt;@INC&lt;/code&gt; 中查找来加载 &lt;code&gt;MySourceHandler&lt;/code&gt; 类：</target>
        </trans-unit>
        <trans-unit id="347f0b37a026018219924f60ce1e17db3ba49ed4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local($x)&lt;/code&gt; saves away the old value of the global variable &lt;code&gt;$x&lt;/code&gt; and assigns a new value for the duration of the subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc21d0f7a4117a8fe63729506522a787886c5b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local_address&lt;/code&gt; &amp;mdash; The local IP address to bind to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781e302076091acf759d87fc441e0a784931b032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localeconv()&lt;/code&gt; takes no arguments, and returns &lt;b&gt;a reference to&lt;/b&gt; a hash. The keys of this hash are variable names for formatting, such as &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; . The values are the corresponding, er, values. See &lt;a href=&quot;posix#localeconv&quot;&gt;localeconv in POSIX&lt;/a&gt; for a longer example listing the categories an implementation might be expected to provide; some provide more and others fewer. You don't need an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , because &lt;code&gt;localeconv()&lt;/code&gt; always observes the current locale.</source>
          <target state="translated">&lt;code&gt;localeconv()&lt;/code&gt; 不接受任何参数，并返回&lt;b&gt;对&lt;/b&gt;哈希&lt;b&gt;的引用&lt;/b&gt;。这个哈希键是格式化的变量名，如 &lt;code&gt;decimal_point&lt;/code&gt; 和 &lt;code&gt;thousands_sep&lt;/code&gt; 。这些值是相应的er值。请参阅&lt;a href=&quot;posix#localeconv&quot;&gt;POSIX&lt;/a&gt;中的localeconv，以获得一个更长的示例，其中列出了可能期望实现提供的类别。一些提供更多而其他提供更少。您不需要显式的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，因为 &lt;code&gt;localeconv()&lt;/code&gt; 始终遵守当前语言环境。</target>
        </trans-unit>
        <trans-unit id="3f66fab5460d4dc9728ad1ba256d520cd78b6a49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localeconv()&lt;/code&gt; takes no arguments, and returns &lt;b&gt;a reference to&lt;/b&gt; a hash. The keys of this hash are variable names for formatting, such as &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt;. The values are the corresponding, er, values. See &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; for a longer example listing the categories an implementation might be expected to provide; some provide more and others fewer. You don't need an explicit &lt;code&gt;use locale&lt;/code&gt;, because &lt;code&gt;localeconv()&lt;/code&gt; always observes the current locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f45c80463df0b85e5ba5ab579ddd13fc8d375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;localtime&lt;/code&gt; has the same range as &lt;a href=&quot;#gmtime&quot;&gt;&quot;gmtime&quot;&lt;/a&gt;, but because time zone rules change, its accuracy for historical and future times may degrade but usually by no more than an hour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5a8604c9701ff564566be832ebca55c49fc48f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock()&lt;/code&gt; blocks the thread until the variable being locked is available. When &lt;code&gt;lock()&lt;/code&gt; returns, your thread can be sure that no other thread can lock that variable until the block containing the lock exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09118e18715d2d6315b0a6dadf4317baf4a851d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; follows references exactly</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9281d382b272fae184a0276036a0f570f6c161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; places a &lt;b&gt;advisory&lt;/b&gt; lock on a variable until the lock goes out of scope. If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. Multiple calls to &lt;code&gt;lock&lt;/code&gt; by the same thread from within dynamically nested scopes are safe -- the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ab05ea94c87b62ab35478b213c751ba976e63e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock&lt;/code&gt; places a lock on a variable until the lock goes out of scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d252978807d4a7ce13ddf9824c30a75650ac4c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loop&lt;/code&gt; is an optional preconstructed &lt;code&gt;enterloop&lt;/code&gt; op to use in the loop; if it is null then a suitable op will be constructed automatically. &lt;code&gt;expr&lt;/code&gt; supplies the loop's controlling expression. &lt;code&gt;block&lt;/code&gt; supplies the main body of the loop, and &lt;code&gt;cont&lt;/code&gt; optionally supplies a &lt;code&gt;continue&lt;/code&gt; block that operates as a second half of the body. All of these optree inputs are consumed by this function and become part of the constructed op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4a29ff759286dc4a0d846a54fba072c0f2b509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lseek()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt; only work with files opened in binary mode.</source>
          <target state="translated">&lt;code&gt;lseek()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek()&lt;/a&gt;&lt;/code&gt; 仅适用于以二进制模式打开的文件。</target>
        </trans-unit>
        <trans-unit id="7b60fd594e78546a6d22f780ff2e2a2c8b8234c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lseek()&lt;/code&gt;, &lt;code&gt;tell()&lt;/code&gt; and &lt;code&gt;sysseek()&lt;/code&gt; only work with files opened in binary mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883ccb60af102a63dca29d53e2d458e06fa1f4e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lynx&lt;/code&gt; can only fetch remote files by dumping its contents to &lt;code&gt;STDOUT&lt;/code&gt; , which we in turn capture. If that content is a 'custom' error file (like, say, a &lt;code&gt;404 handler&lt;/code&gt;), you will get that contents instead.</source>
          <target state="translated">&lt;code&gt;lynx&lt;/code&gt; 只能通过将其内容转储到 &lt;code&gt;STDOUT&lt;/code&gt; 来获取远程文件，然后我们将其捕获。如果该内容是&amp;ldquo;自定义&amp;rdquo;错误文件（例如 &lt;code&gt;404 handler&lt;/code&gt; ），则将获取该内容。</target>
        </trans-unit>
        <trans-unit id="ca8181bd7507b944c5da73ef1d60cb5b9183b0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lynx&lt;/code&gt; can only fetch remote files by dumping its contents to &lt;code&gt;STDOUT&lt;/code&gt;, which we in turn capture. If that content is a 'custom' error file (like, say, a &lt;code&gt;404 handler&lt;/code&gt;), you will get that contents instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63d1cb13b2e2d34f317b472c81b8bed46501684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m''&lt;/code&gt;, the pattern of &lt;code&gt;s'''&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18d18bb4566b22549963c5fa12983047cd227b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m/pattern/msixpogcdualn&lt;/code&gt; searches a string for a pattern match, applying the given options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6908309921cfb034efc3e4069f56b25e3fb5b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;m?pattern?&lt;/code&gt; is like &lt;code&gt;m/pattern/&lt;/code&gt; but matches only once. No alternate delimiters can be used. Must be reset with reset().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385b785dc276da4cc64862fa5145b732ada18a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major&lt;/code&gt;, &lt;code&gt;minor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61daddd4de3c593af044da2e2d7ce6201973b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make&lt;/code&gt;, however, failed with output (excerpted) like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d886031ca39127136a93f5c58154011b1571ac4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the group ownership of created directories to the symbolic name [group], but &lt;code&gt;&lt;a href=&quot;../functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric gid. The directory will be created, but group ownership will not be changed.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 指示make_path将创建目录的组所有权赋予符号名[group]，但 &lt;code&gt;&lt;a href=&quot;../functions/getgrnam&quot;&gt;getgrnam&lt;/a&gt;&lt;/code&gt; 不会返回相应的数字gid。将创建目录，但组所有权不会更改。</target>
        </trans-unit>
        <trans-unit id="58791d691818b086bac47e6b8fe80f3a3d7fc75e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the group ownership of created directories to the symbolic name [group], but &lt;code&gt;getgrnam&lt;/code&gt; did not return the corresponding numeric gid. The directory will be created, but group ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3237359a6cb04586bfde967ca0039e3278fe9e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the ownership of created directories to the symbolic name [owner], but &lt;code&gt;&lt;a href=&quot;../functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; did not return the corresponding numeric uid. The directory will be created, but ownership will not be changed.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 指示make_path将创建的目录的所有权赋予符号名称[owner]，但 &lt;code&gt;&lt;a href=&quot;../functions/getpwnam&quot;&gt;getpwnam&lt;/a&gt;&lt;/code&gt; 没有返回相应的数字uid。将创建目录，但不会更改所有权。</target>
        </trans-unit>
        <trans-unit id="0eb8e4fce86b24625447f0fee5c1f2f51f994fc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was instructed to give the ownership of created directories to the symbolic name [owner], but &lt;code&gt;getpwnam&lt;/code&gt; did not return the corresponding numeric uid. The directory will be created, but ownership will not be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc7e268861ebf6c487de7b9a430854e30e76cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was not given any paths to create. This message is only emitted if the routine is called with the traditional interface. The modern interface will remain silent if given nothing to do.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 为make_path提供任何创建路径。仅当使用传统接口调用例程时，才发出此消息。如果无事可做，现代界面将保持沉默。</target>
        </trans-unit>
        <trans-unit id="2e443672231a8aa8a3a54538e9ff5974e9e3a2dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was unable to create the path. Probably some sort of permissions error at the point of departure or insufficient resources (such as free inodes on Unix).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755c6f5063eb2e334da849c0ce6318b9f39c061" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_path&lt;/code&gt; was unable to create the path. Probably some sort of permissions error at the point of departure, or insufficient resources (such as free inodes on Unix).</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; 无法创建路径。可能在离开时出现某种权限错误，或者资源不足（例如Unix上的免费inode）。</target>
        </trans-unit>
        <trans-unit id="07a8fe35478388c546b0d41c18eefc372419fd9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maketext&lt;/code&gt; and other methods to do with accessing %Lexicon data for a given language handle.</source>
          <target state="translated">&lt;code&gt;maketext&lt;/code&gt; 和其他用于访问给定语言句柄的％Lexicon数据的方法。</target>
        </trans-unit>
        <trans-unit id="8d3d67fea62a065d10c5926428fdebd26c6a5f56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mantissa()&lt;/code&gt; and &lt;code&gt;exponent()&lt;/code&gt; return the said parts of the BigInt such that:</source>
          <target state="translated">&lt;code&gt;mantissa()&lt;/code&gt; 和 &lt;code&gt;exponent()&lt;/code&gt; 返回BigInt的所述部分，使得：</target>
        </trans-unit>
        <trans-unit id="8b922a1e8b8a437e6a25aad879f34f0de9830b8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask&lt;/code&gt; is recognised as an alias for this parameter.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; 被识别为该参数的别名。</target>
        </trans-unit>
        <trans-unit id="2cdbbfa91b28de49c104d6b9af4f6f87846706f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matches&lt;/code&gt; is used to determine whether a given exception matches a particular role.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="735db1093393eee079ae5f4991770e04f6968586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_redirect&lt;/code&gt; &amp;mdash; Maximum number of redirects allowed (defaults to 5)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeee7b55442af72793e10221eaf9fc76d8f198ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_size&lt;/code&gt; &amp;mdash; Maximum response size in bytes (only when not using a data callback). If defined, responses larger than this will return an exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03355b926946894926cfadae3a6b81818310b791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memoize&lt;/code&gt; knows that if the normalized version of the arguments is the same for two argument lists, then it can safely look up the value that it computed for one argument list and return it as the result of calling the function with the other argument list, even if the argument lists look different.</source>
          <target state="translated">&lt;code&gt;memoize&lt;/code&gt; 知道，如果两个参数列表的参数规范化版本相同，则它可以安全地查找为一个参数列表计算的值，并将其返回给另一个参数列表调用该函数，甚至如果参数列表看起来不同。</target>
        </trans-unit>
        <trans-unit id="638289935cbe995e57c2ecbf17c23e84ccb8dd5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; uses various strategies to combine different elements of the CPAN::Meta objects. The following strategies can be used with the extra_mappings argument of &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588d0d71e67f680f937b2933e4e80482741a6b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meth&lt;/code&gt; is the name of the method to call.</source>
          <target state="translated">&lt;code&gt;meth&lt;/code&gt; 是要调用的方法的名称。</target>
        </trans-unit>
        <trans-unit id="712fb23828e7aa39570d1c187a557f284fbccd22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mg_freeext(sv, how, NULL)&lt;/code&gt; is equivalent to &lt;code&gt;mg_free_type(sv, how)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c382bf574ac941794f4ceb11f1a7cf0a554b70e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;miniperl -MCross -MConfig -we 1&lt;/code&gt; should run okay, and it will provide right</source>
          <target state="translated">&lt;code&gt;miniperl -MCross -MConfig -we 1&lt;/code&gt; 应该可以正常运行，它将提供正确的</target>
        </trans-unit>
        <trans-unit id="4fffeff3899ad34654b8fd715931df104143ede2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;minlen&lt;/code&gt;&lt;code&gt;minlenret&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ff8f6ef90463a78a4980b3e772f012f8f89756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlenret&lt;/code&gt; is the minimum length (in characters) of the string that would be found in $&amp;amp; after a match.</source>
          <target state="translated">&lt;code&gt;minlenret&lt;/code&gt; 是匹配后在$＆中找到的字符串的最小长度（以字符为单位）。</target>
        </trans-unit>
        <trans-unit id="6bbd4a399f25a390cfec881966b0de3c042c6005" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa93a538eb746e066effec46888283ca286ffddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may have the values &lt;code&gt;deterministic&lt;/code&gt; for the case where all questions come in the order written down and &lt;code&gt;anyorder&lt;/code&gt; for the case where the questions may come in any order. The default mode is &lt;code&gt;deterministic&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 可能具有的值 &lt;code&gt;deterministic&lt;/code&gt; 的情况下，所有的问题进来写下来和秩序 &lt;code&gt;anyorder&lt;/code&gt; 对于其中的问题可能会在任何顺序的情况。默认模式是 &lt;code&gt;deterministic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e1fa5e0cf856c0cfac64557627a7bf6ca8e2afc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my($x)&lt;/code&gt; creates a new variable that is only visible in the current subroutine. This is done at compile-time, so it is called lexical or static scoping. my() always affects private variables, also called lexical variables or (improperly) static(ly scoped) variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3be2cea04198936ddec55cc82c2731dab3af0258" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my()&lt;/code&gt; and &lt;code&gt;local()&lt;/code&gt; give list context to the right hand side of &lt;code&gt;=&lt;/code&gt;. The &amp;lt;$fh&amp;gt; read operation, like so many of Perl's functions and operators, can tell which context it was called in and behaves appropriately. In general, the scalar() function can help. This function does nothing to the data itself (contrary to popular myth) but rather tells its argument to behave in whatever its scalar fashion is. If that function doesn't have a defined scalar behavior, this of course doesn't help you (such as with sort()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f6bd4829fd2ba12633873148c47d9a80090bdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my&lt;/code&gt; variables are scoped to the current block, not to the current function. If you write &lt;code&gt;{my $x;} $x;&lt;/code&gt;, the second &lt;code&gt;$x&lt;/code&gt; does not refer to the one declared inside the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b07f3d996d9ac376632ed1fb891e52a9c59c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter that is to parse the script. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;. &lt;code&gt;xsinit&lt;/code&gt; points to a callback function that will be called to set up the ability for this Perl interpreter to load XS extensions, or may be null to perform no such setup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e31baaedd01c699e3021af78994eb9360ab9836b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;, and initialised through &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt;. This function should not be called if &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; returned a non-zero value, indicating a failure in initialisation or compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1947b5fb6cb99db3b3240eacc1379b1a337b2c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_perl&lt;/code&gt; points to the Perl interpreter. It must have been previously created through the use of &lt;a href=&quot;#perl_alloc&quot;&gt;&quot;perl_alloc&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;. It may have been initialised through &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt;, and may have been used through &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; and other means. This function should be called for any Perl interpreter that has been constructed with &lt;a href=&quot;#perl_construct&quot;&gt;&quot;perl_construct&quot;&lt;/a&gt;, even if subsequent operations on it failed, for example if &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; returned a non-zero value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77a292f2351d2499cb4d3956fe35448489fd6cf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_popen&lt;/code&gt; uses</source>
          <target state="translated">&lt;code&gt;my_popen&lt;/code&gt; 使用</target>
        </trans-unit>
        <trans-unit id="fe304a6dc30cae0afd16e8b92b6cd1cd7ce95c7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcat()&lt;/code&gt; appends string &lt;code&gt;src&lt;/code&gt; to the end of &lt;code&gt;dst&lt;/code&gt; . It will append at most &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; characters. It will then &lt;code&gt;NUL&lt;/code&gt; -terminate, unless &lt;code&gt;size&lt;/code&gt; is 0 or the original &lt;code&gt;dst&lt;/code&gt; string was longer than &lt;code&gt;size&lt;/code&gt; (in practice this should not happen as it means that either &lt;code&gt;size&lt;/code&gt; is incorrect or that &lt;code&gt;dst&lt;/code&gt; is not a proper &lt;code&gt;NUL&lt;/code&gt; -terminated string).</source>
          <target state="translated">&lt;code&gt;my_strlcat()&lt;/code&gt; 将字符串 &lt;code&gt;src&lt;/code&gt; 附加到 &lt;code&gt;dst&lt;/code&gt; 的末尾。它将附加最大 &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; 字符。然后它将以 &lt;code&gt;NUL&lt;/code&gt; 终止，除非 &lt;code&gt;size&lt;/code&gt; 为0或原始 &lt;code&gt;dst&lt;/code&gt; 字符串长于 &lt;code&gt;size&lt;/code&gt; （实际上不应发生这种情况，因为这意味着 &lt;code&gt;size&lt;/code&gt; 不正确或 &lt;code&gt;dst&lt;/code&gt; 不是以 &lt;code&gt;NUL&lt;/code&gt; 终止的正确字符串）。</target>
        </trans-unit>
        <trans-unit id="f1af893d16b0d24596b5c31d0490c98a1626dcfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcat()&lt;/code&gt; appends string &lt;code&gt;src&lt;/code&gt; to the end of &lt;code&gt;dst&lt;/code&gt;. It will append at most &lt;code&gt;size - strlen(dst) - 1&lt;/code&gt; characters. It will then &lt;code&gt;NUL&lt;/code&gt;-terminate, unless &lt;code&gt;size&lt;/code&gt; is 0 or the original &lt;code&gt;dst&lt;/code&gt; string was longer than &lt;code&gt;size&lt;/code&gt; (in practice this should not happen as it means that either &lt;code&gt;size&lt;/code&gt; is incorrect or that &lt;code&gt;dst&lt;/code&gt; is not a proper &lt;code&gt;NUL&lt;/code&gt;-terminated string).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdedecbe5c820473f669d0af506ce2015ddd5193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcpy()&lt;/code&gt; copies up to &lt;code&gt;size - 1&lt;/code&gt; characters from the string &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; , &lt;code&gt;NUL&lt;/code&gt; -terminating the result if &lt;code&gt;size&lt;/code&gt; is not 0.</source>
          <target state="translated">&lt;code&gt;my_strlcpy()&lt;/code&gt; 最多将 &lt;code&gt;size - 1&lt;/code&gt; 字符从字符串 &lt;code&gt;src&lt;/code&gt; 复制到 &lt;code&gt;dst&lt;/code&gt; ， &lt;code&gt;NUL&lt;/code&gt; -如果 &lt;code&gt;size&lt;/code&gt; 不为0 则终止结果。</target>
        </trans-unit>
        <trans-unit id="c49e5ae33724b1666c685d2e7a72b62073255c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strlcpy()&lt;/code&gt; copies up to &lt;code&gt;size - 1&lt;/code&gt; characters from the string &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;, &lt;code&gt;NUL&lt;/code&gt;-terminating the result if &lt;code&gt;size&lt;/code&gt; is not 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ec8d3fbd253d28a1634c761ae477719ded646f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;my_strnlen()&lt;/code&gt; computes the length of the string, up to &lt;code&gt;maxlen&lt;/code&gt; characters. It will never attempt to address more than &lt;code&gt;maxlen&lt;/code&gt; characters, making it suitable for use with strings that are not guaranteed to be NUL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4001332f8ab98ef832acfc949829d1eb7d7cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to represent signed 16-/32-bit integers in big-/little-endian order. This is portable only when all platforms sharing packed data use the same binary representation for signed integers; for example, when all platforms use two's-complement representation.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 接受 &lt;code&gt;!&lt;/code&gt; 修饰符，以大/小端顺序表示带符号的16/32位整数。仅当所有共享打包数据的平台对带符号整数使用相同的二进制表示形式时，此方法才是可移植的。例如，当所有平台都使用二进制补码表示时。</target>
        </trans-unit>
        <trans-unit id="0844e932cd53e139fa2cf155e2c24b47a2e370a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to represent signed 16-/32-bit integers in big-/little-endian order. This is portable only when all platforms sharing packed data use the same binary representation for signed integers; for example, when all platforms use two's-complement representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6a21fed22915a331be3383e5b5b4032f977a5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; give the name. The name must be unqualified; that is, it must not include the package name. If &lt;code&gt;gv&lt;/code&gt; is a stash element, it is the caller's responsibility to ensure that the name passed to this function matches the name of the element. If it does not match, perl's internal bookkeeping will get out of sync.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;len&lt;/code&gt; 给出名字。名称不能为空。也就是说，它不能包含软件包名称。如果 &lt;code&gt;gv&lt;/code&gt; 是stash元素，则调用者有责任确保传递给此函数的名称与该元素的名称匹配。如果不匹配，perl的内部簿记将不同步。</target>
        </trans-unit>
        <trans-unit id="505efe65fc0e388dda45d46fcc78a224697b6312" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namegv&lt;/code&gt; may not actually be a GV. For efficiency, perl may pass a CV or other SV instead. Whatever is passed can be used as the first argument to &lt;a href=&quot;#cv_name&quot;&gt;&quot;cv_name&quot;&lt;/a&gt;. You can force perl to pass a GV by including &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; in the &lt;code&gt;ckflags&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65dcbed646c24c8b29a7a565d322acb0ec423da0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namegv&lt;/code&gt; may not actually be a GV. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is clear in &lt;code&gt;*ckflags_p&lt;/code&gt;, it is permitted to pass a CV or other SV instead, anything that can be used as the first argument to &lt;a href=&quot;#cv_name&quot;&gt;&quot;cv_name&quot;&lt;/a&gt;. If the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; bit is set in &lt;code&gt;*ckflags_p&lt;/code&gt; then the check function requires &lt;code&gt;namegv&lt;/code&gt; to be a genuine GV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da77eb1fcc99f55a77cfa3187a8be6d00b79f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namepv&lt;/code&gt;/&lt;code&gt;namelen&lt;/code&gt; specify the variable's name, including leading sigil. If &lt;code&gt;typestash&lt;/code&gt; is non-null, the name is for a typed lexical, and this identifies the type. If &lt;code&gt;ourstash&lt;/code&gt; is non-null, it's a lexical reference to a package variable, and this identifies the package. The following flags can be OR'ed together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95c68737e4cdbac2fa96320e25fc1fa20440782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ndelay&lt;/code&gt; - Open the connection immediately (normally, the connection is opened when the first message is logged).</source>
          <target state="translated">&lt;code&gt;ndelay&lt;/code&gt; -立即打开连接（通常，在记录第一条消息时打开连接）。</target>
        </trans-unit>
        <trans-unit id="7953c406c8ff699f7523d2c0fa454774e594fafa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new()&lt;/code&gt; is a synonym for &lt;code&gt;create()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;new()&lt;/code&gt; 是 &lt;code&gt;create()&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="246e4e12c5e8b7fc27f98e6de494470349960771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new()&lt;/code&gt; is a synonym for &lt;code&gt;create()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2a9ff681510122f5292361c80d05ba72747aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; creates a new semaphore, and initializes its count to the specified number (which must be an integer). If no number is specified, the semaphore's count defaults to 1.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 创建一个新的信号量，并将其计数初始化为指定的数字（必须为整数）。如果未指定任何数字，则信号量的计数默认为1。</target>
        </trans-unit>
        <trans-unit id="efedbfabb0d57daca4e55f1c80323100b61e0eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is the constructor for &lt;code&gt;IO::Dir&lt;/code&gt; objects. It accepts one optional argument which, if given, &lt;code&gt;new&lt;/code&gt; will pass to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 是 &lt;code&gt;IO::Dir&lt;/code&gt; 对象的构造函数。它接受一个可选参数，如果给定，则 &lt;code&gt;new&lt;/code&gt; 将传递给 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c47c2969ff9b3b9f7bd94f334a283572d1c7f86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; is the constructor for &lt;code&gt;IO::Dir&lt;/code&gt; objects. It accepts one optional argument which, if given, &lt;code&gt;new&lt;/code&gt; will pass to &lt;code&gt;open&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ebed1aa25ba5c1ac9f9e4c204e2addbac198e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; starts a new thread of execution in the referenced subroutine. The optional list is passed as parameters to the subroutine. Execution continues in both the subroutine and the code after the &lt;code&gt;new&lt;/code&gt; call.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 在引用的子例程中启动一个新的执行线程。可选列表作为参数传递给子例程。 &lt;code&gt;new&lt;/code&gt; 调用之后，子例程和代码中的执行继续。</target>
        </trans-unit>
        <trans-unit id="6d41331a192901f578b387cab4cc0d24438aec85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_ok()&lt;/code&gt;&lt;code&gt;note()&lt;/code&gt; and &lt;code&gt;explain()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7152783cf0f9c5159afb5dc6873309aa1eacea66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;use bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a26c54b2961967f48d7aafce8700f53ea0a4ade3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no feature 'unicode_strings'&lt;/code&gt; tells the compiler to use the traditional Perl rules wherein the native character set rules is used unless it is clear to Perl that Unicode is desired. This can lead to some surprises when the behavior suddenly changes. (See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt; for details.) For this reason, if you are potentially using Unicode in your program, the &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; subpragma is &lt;b&gt;strongly&lt;/b&gt; recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37881fef53e1354528db97e9719ec39121a9bfd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no feature&lt;/code&gt; with no features specified will reset to the default group. To disable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3d04f34da29bde4052794af89e457120eb309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; will turn off the effect of &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; for the given flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028ecddd058bf1fc3c87c0a21533cf8523a0ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_proxy&lt;/code&gt; &amp;mdash; List of domain suffixes that should not be proxied. Must be a comma-separated string or an array reference. (default is &lt;code&gt;$ENV{no_proxy}&lt;/code&gt; &amp;mdash;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a92dfd8fef1985419787a429944b6929b7d15145" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noeol&lt;/code&gt; - When set to true, no end of line character (&lt;code&gt;\n&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="translated">&lt;code&gt;noeol&lt;/code&gt; -设置为true时，行尾字符（ &lt;code&gt;\n&lt;/code&gt; ）不会附加到消息中。这对于某些有问题的syslog守护程序可能很有用。</target>
        </trans-unit>
        <trans-unit id="cb0a6b6ffe1f8acfe1a779ce54faf3e76c8e41b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noeol&lt;/code&gt; - When set to true, no end of line character (&lt;code&gt;\n&lt;/code&gt;) will be appended to the message. This can be useful for some syslog daemons. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.29.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7da13afac64a19ada71fa128b3727ac19b9a817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nofatal&lt;/code&gt; - When set to true, &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt; will only emit warnings instead of dying if the connection to the syslog can't be established.</source>
          <target state="translated">&lt;code&gt;nofatal&lt;/code&gt; -设置为true时，如果无法建立与syslog的连接，则 &lt;code&gt;openlog()&lt;/code&gt; 和 &lt;code&gt;syslog()&lt;/code&gt; 只会发出警告，而不是死亡。</target>
        </trans-unit>
        <trans-unit id="ca122e6abeda68819afe86c5366b7c3712efdf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nofatal&lt;/code&gt; - When set to true, &lt;code&gt;openlog()&lt;/code&gt; and &lt;code&gt;syslog()&lt;/code&gt; will only emit warnings instead of dying if the connection to the syslog can't be established. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d145b40dff849bfb7be76022f83e7b4e1ab3e8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonul&lt;/code&gt; - When set to true, no &lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;\0&lt;/code&gt; ) will be appended to the message. This can be useful for some buggy syslog daemons.</source>
          <target state="translated">&lt;code&gt;nonul&lt;/code&gt; -设置为true时，不会在消息后附加 &lt;code&gt;NUL&lt;/code&gt; 字符（ &lt;code&gt;\0&lt;/code&gt; ）。这对于某些有问题的syslog守护程序可能很有用。</target>
        </trans-unit>
        <trans-unit id="dc012306f72212eaa59d4c933f581373eb5695b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nonul&lt;/code&gt; - When set to true, no &lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;\0&lt;/code&gt;) will be appended to the message. This can be useful for some syslog daemons. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.29.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eced03bcdab870ab9edcbe9dc4bb03fa8ec64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normal&lt;/code&gt; is a string like &quot;ToLower&quot; which means the swash %utf8::ToLower.</source>
          <target state="translated">&lt;code&gt;normal&lt;/code&gt; 是一个类似于&amp;ldquo; ToLower&amp;rdquo;的字符串，它表示斜率％utf8 :: ToLower。</target>
        </trans-unit>
        <trans-unit id="e54ce6f923598d61f4c291c2231596a77ff50261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalization&lt;/code&gt; is performed after &lt;code&gt;preprocess&lt;/code&gt; (if defined).</source>
          <target state="translated">&lt;code&gt;normalization&lt;/code&gt; 在 &lt;code&gt;preprocess&lt;/code&gt; （如果已定义）之后执行。</target>
        </trans-unit>
        <trans-unit id="6c787cbcd0d732de5ebfc6c56bc124a3d88f16c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;normalize&lt;/code&gt; and other some functions: on request.</source>
          <target state="translated">&lt;code&gt;normalize&lt;/code&gt; 和其他一些功能：根据要求。</target>
        </trans-unit>
        <trans-unit id="f38203e290e1449681c9a41b7d479b27b8df21db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nowait&lt;/code&gt; - Don't wait for child processes that may have been created while logging the message. (The GNU C library does not create a child process, so this option has no effect on Linux.)</source>
          <target state="translated">&lt;code&gt;nowait&lt;/code&gt; -不要等待记录消息时可能已经创建的子进程。（GNU C库不会创建子进程，因此此选项在Linux上无效。）</target>
        </trans-unit>
        <trans-unit id="4694888bc88f2c3c8dc0bbded8e50a8bc2b38846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparens&lt;/code&gt; , &lt;code&gt;lastparen&lt;/code&gt; , and &lt;code&gt;lastcloseparen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;nparens&lt;/code&gt; ， &lt;code&gt;lastparen&lt;/code&gt; 和 &lt;code&gt;lastcloseparen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52be97add4ff2683463a744b45fdd5976f903fed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparens&lt;/code&gt;, &lt;code&gt;lastparen&lt;/code&gt;, and &lt;code&gt;lastcloseparen&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104bc44857c778695c79d0d1e8b5b9a2c1281a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num()&lt;/code&gt; returns the numeric value of the input Unicode string; or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't think the entire string has a completely valid, safe numeric value.</source>
          <target state="translated">&lt;code&gt;num()&lt;/code&gt; 返回输入的Unicode字符串的数值；或 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (如果它认为整个字符串不具有完全有效的安全数字值）。</target>
        </trans-unit>
        <trans-unit id="143ac08b13ce4ad3b7dad5ef00e10449159ff968" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num()&lt;/code&gt; returns the numeric value of the input Unicode string; or &lt;code&gt;undef&lt;/code&gt; if it doesn't think the entire string has a completely valid, safe numeric value. If called with an optional second parameter, a reference to a scalar, &lt;code&gt;num()&lt;/code&gt; will set the scalar to the length of any valid initial substring; or to 0 if none.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a7b6da46d3ad3066f3c734bb010fb7646c3f1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num&lt;/code&gt; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize. Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points. The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &lt;code&gt;\d&lt;/code&gt; will not match them. A single-character string containing one of these digits will have its decimal value returned by &lt;code&gt;num&lt;/code&gt; , but any longer string containing only these digits will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; 犯错安全的一侧，并有可能成为十进制数字有效字符串，它不承认。请注意，Unicode定义了许多不是&amp;ldquo;十进制数字&amp;rdquo;字符的&amp;ldquo;数字&amp;rdquo;字符。 &amp;ldquo;十进制数字&amp;rdquo;具有以下属性：它们具有位置值，即存在单位位置，10的位置，100的位置等，并且它们以Unicode的形式排列在10个连续代码点的块中。例如，中文数字不在这种连续的块中，因此Unicode不会将它们视为十进制数字，而只能将其视为数字，因此 &lt;code&gt;\d&lt;/code&gt; 将不与它们匹配。包含这些数字之一的单字符字符串将使用 &lt;code&gt;num&lt;/code&gt; 返回其十进制值，但任何仅包含这些数字的更长字符串将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b32e68b8130281ee35f097f4391a4cff47007bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num&lt;/code&gt; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize. Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points. The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &lt;code&gt;\d&lt;/code&gt; will not match them. A single-character string containing one of these digits will have its decimal value returned by &lt;code&gt;num&lt;/code&gt;, but any longer string containing only these digits will return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be874a64ffa774adf425ae056b0282a20c6623c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o debug&lt;/code&gt; without an argument lists the valid package names and the current set of packages in debugging mode. &lt;code&gt;o debug&lt;/code&gt; has built-in completion support.</source>
          <target state="translated">&lt;code&gt;o debug&lt;/code&gt; 不带参数的调试将列出有效的程序包名称以及调试模式下的当前程序包集。 &lt;code&gt;o debug&lt;/code&gt; 具有内置的完成支持。</target>
        </trans-unit>
        <trans-unit id="209f16e359fcd3b6ba3b8313e7009d000c6c97f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt; must be non-negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee9e272a7f7d5aba509cf3d9269033834525fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt; must be non-positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466246a0ea0bcd1da5e37ea4ea93b6e2eb95b97a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; is given an expression (in this case &lt;code&gt;$foo eq $bar&lt;/code&gt; ). If it's true, the test passed. If it's false, it didn't. That's about it.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 给ok（）一个表达式（在本例中 &lt;code&gt;$foo eq $bar&lt;/code&gt; ）。如果属实，则测试通过。如果它是错误的，则不是。就是这样</target>
        </trans-unit>
        <trans-unit id="af31a705cde9721fcbca5948bef10e2333a178e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; is given an expression (in this case &lt;code&gt;$foo eq $bar&lt;/code&gt;). If it's true, the test passed. If it's false, it didn't. That's about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ab5a47d8307c5982472639709641b589ddb9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok()&lt;/code&gt; prints out either &quot;ok&quot; or &quot;not ok&quot; along with a test number (it keeps track of that for you).</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; 会打印出&amp;ldquo; ok&amp;rdquo;或&amp;ldquo; not ok&amp;rdquo;以及测试编号（它会为您跟踪该编号）。</target>
        </trans-unit>
        <trans-unit id="02f0e19d76f2346c39f954fb30c54feae693b547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's special handing of strings which look like they might be regexes can also cause unexpected behavior. An innocent:</source>
          <target state="translated">&lt;code&gt;ok(...)&lt;/code&gt; 看起来像是正则表达式的字符串的特殊处理也可能导致意外行为。天真：</target>
        </trans-unit>
        <trans-unit id="b9453067bce99ddb6c0b34c1ad76b7773aa72eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt; 's use of string &lt;code&gt;eq&lt;/code&gt; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:</source>
          <target state="translated">&lt;code&gt;ok(...)&lt;/code&gt; 的字符串 &lt;code&gt;eq&lt;/code&gt; 有时在比较数字时会引起奇怪的问题，尤其是当您将字符串转换为数字时：</target>
        </trans-unit>
        <trans-unit id="c66df15d1b7a6f4eb10c201fd544c892f039b887" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt;'s special handing of strings which look like they might be regexes can also cause unexpected behavior. An innocent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfa5c97305499145ba41c92e0d7854dbfd6d33e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ok(...)&lt;/code&gt;'s use of string &lt;code&gt;eq&lt;/code&gt; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6826999eb95521e6d8d3b9f0c51592f03d979f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onfail&lt;/code&gt; hook might be used simply to print out the version of your package and/or how to report problems. It might also be used to generate extremely sophisticated diagnostics for a particularly bizarre test failure. However it's not a panacea. Core dumps or other unrecoverable errors prevent the &lt;code&gt;onfail&lt;/code&gt; hook from running. (It is run inside an &lt;code&gt;END&lt;/code&gt; block.) Besides, &lt;code&gt;onfail&lt;/code&gt; is probably over-kill in most cases. (Your test code should be simpler than the code it is testing, yes?)</source>
          <target state="translated">&lt;code&gt;onfail&lt;/code&gt; 挂钩可能仅用于打印软件包的版本和/或如何报告问题。它也可以用于生成极其复杂的诊断，以解决特别奇怪的测试失败。但是，它不是万能药。核心转储或其他不可恢复的错误会阻止 &lt;code&gt;onfail&lt;/code&gt; 挂钩运行。（它在 &lt;code&gt;END&lt;/code&gt; 块中运行。）此外，在大多数情况下， &lt;code&gt;onfail&lt;/code&gt; 可能会导致过多的故障。（您的测试代码应该比正在测试的代码简单，是吗？）</target>
        </trans-unit>
        <trans-unit id="8f088836ce0fde68df7eee4d30bfbe00374a2996" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open FH, &quot;-|&quot;&lt;/code&gt;, in other words, opening pipes to itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffe39b6fc765d2c5dd23b3d8fe3f83a8a2cd05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open()&lt;/code&gt; ignores this variable (and the default layers) when called with 3 arguments and explicit layers are specified. Indirect calls to these functions via modules like &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; are not affected as they occur in a different lexical scope. Directory handles such as opened by &lt;code&gt;opendir()&lt;/code&gt; are not currently affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e22ef4d238b8913182581bd4c36483578c9a28e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; accepts one, two or three parameters. With one parameter, it is just a front end for the built-in &lt;code&gt;open&lt;/code&gt; function. With two or three parameters, the first parameter is a filename that may include whitespace or other special characters, and the second parameter is the open mode, optionally followed by a file permission value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731e105522272d59aee11be93bacdc1e634f424a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt; takes two arguments. The first is the name of the file to open and the second is the open mode. The mode can be anything acceptable to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt; and by extension anything acceptable to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09da5e2afa2630c81481fae033003b0e56465a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open&lt;/code&gt;, &lt;code&gt;opendir&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155f0eaaf34c1ec0b370e6041e98b86611585735" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optype&lt;/code&gt; should be an opcode indicating the type of operation that the pad entry is to support. This doesn't affect operational semantics, but is used for debugging.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cb592938f64645a65fb717b7ef6050e2ffefe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ord()&lt;/code&gt; will return EBCDIC code number values on an EBCDIC platform. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7349d9655c667539e75d17a6e784d90202513f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os2_stat&lt;/code&gt; special-cases</source>
          <target state="translated">&lt;code&gt;os2_stat&lt;/code&gt; 特殊情况</target>
        </trans-unit>
        <trans-unit id="054fe1a81b97f07c540d64d60a64f4af0bb07c47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;our&lt;/code&gt; subroutines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae20ae53e9337f9b303890d15d0d3b627b7ddae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overrideOut&lt;/code&gt; can perform it algorithmically. This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">&lt;code&gt;overrideOut&lt;/code&gt; 可以通过算法执行。此参数的工作方式类似于 &lt;code&gt;overrideCJK&lt;/code&gt; ，因此请参见示例。</target>
        </trans-unit>
        <trans-unit id="c34a051850d5e5b37bbb57119a0f770afe423277" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overrideOut&lt;/code&gt; can perform it algorithmically. This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt;, so see there for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018daadf3e8c264d84f963dafe9df6707fe0f4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; contains the pointer to the UTF-8 string encoding the character that is being converted. This routine assumes that the character at &lt;code&gt;p&lt;/code&gt; is well-formed.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 包含指向UTF-8字符串的指针，该字符串编码正在转换的字符。该例程假定 &lt;code&gt;p&lt;/code&gt; 处的字符格式正确。</target>
        </trans-unit>
        <trans-unit id="c11c698ac9fefb8ffaa9a6b715e3d39e29a9a669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pTHX_&lt;/code&gt; is one of a number of macros (in</source>
          <target state="translated">&lt;code&gt;pTHX_&lt;/code&gt; 是许多宏之一（在</target>
        </trans-unit>
        <trans-unit id="57a1669a25a493393b0012e07977a3873f7b6b80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are two functions for transforming data according to a user-defined template, between the guarded way Perl stores values and some well-defined representation as might be required in the environment of a Perl program. Unfortunately, they're also two of the most misunderstood and most often overlooked functions that Perl provides. This tutorial will demystify them for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9201b2c58a06704aec378eb824713ef3409725ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;package Foo VERSION&lt;/code&gt; is also checked for. The first version declaration found is used, but this may change as it differs from how Perl does it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ccf88eb3a10e91884da8fd743ed1839362f4282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; is the parent node of the sibling chain. It may passed as &lt;code&gt;NULL&lt;/code&gt; if the splicing doesn't affect the first or last op in the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379c431d9679f0fc2a97bd40d54e5841f92e2796" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parent&lt;/code&gt; points to the rest of the &lt;code&gt;refcounted_he&lt;/code&gt; chain to be attached to the new &lt;code&gt;refcounted_he&lt;/code&gt;. This function takes ownership of one reference to &lt;code&gt;parent&lt;/code&gt;, and returns one reference to the new &lt;code&gt;refcounted_he&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2417866550bcf9c7016549d6b067e3913e71d22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list, respectively. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc595ac7a8786ad6d7a447f65fc9b523ab4209c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;&quot;mess_sv&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5576100284e538d6e57d1d31b55e0b0abbd897e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pat&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt; are a sprintf-style format pattern and encapsulated argument list. These are used to generate a string message. If the message does not end with a newline, then it will be extended with some indication of the current location in the code, as described for &lt;a href=&quot;#mess_sv&quot;&gt;mess_sv&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pat&lt;/code&gt; 和 &lt;code&gt;args&lt;/code&gt; 是sprintf样式的格式模式和封装的参数列表。这些用于生成字符串消息。如果消息不是以换行符结尾，则将使用代码中当前位置的某种指示来对其进行扩展，如&lt;a href=&quot;#mess_sv&quot;&gt;mess_sv所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cad345d37c7dffa7c8f4f00e258549543dd5b66f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - equivalent to &lt;code&gt;$stream_location&lt;/code&gt; , sets the stream location. Defaults to standard Unix location, or &lt;code&gt;_PATH_LOG&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; -相当于 &lt;code&gt;$stream_location&lt;/code&gt; ，将流位置。默认为标准Unix位置或 &lt;code&gt;_PATH_LOG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fc6e62bba2086e4237ad6cc1a42a60f5fcb785e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - equivalent to &lt;code&gt;$stream_location&lt;/code&gt;, sets the stream location. Defaults to standard Unix location, or &lt;code&gt;_PATH_LOG&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b3947fbb2cde48071637c1ce2c9e11e4a635a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pattern&lt;/code&gt; would match if anchored at the given position, and it matches</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 如果锚定在给定位置，则模式将匹配，并且匹配</target>
        </trans-unit>
        <trans-unit id="4c0897f276ad7729fd94fc3034bc703086540690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peer&lt;/code&gt; &amp;mdash; Override host resolution and force all connections to go only to a specific peer address, regardless of the URL of the request. This will include any redirections! This options should be used with extreme caution (e.g. debugging or very special circumstances). It can be given as either a scalar or a code reference that will receive the hostname and whose response will be taken as the address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c80fd8c8f76edfb1295d8c13bd88d5a82fdd6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_clone&lt;/code&gt; takes these flags as parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363c3b041828e47609537312596fa6f5289a7cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_parse&lt;/code&gt; is actually a wrapper around &lt;code&gt;S_parse_body&lt;/code&gt; , as defined in</source>
          <target state="translated">&lt;code&gt;perl_parse&lt;/code&gt; 实际上是 &lt;code&gt;S_parse_body&lt;/code&gt; 的包装，如</target>
        </trans-unit>
        <trans-unit id="db5ef3e7bb38cef785d8a05800afe7ac86d72bfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perl_parse&lt;/code&gt; is actually a wrapper around &lt;code&gt;S_parse_body&lt;/code&gt;, as defined in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f98336dcec32bd23880560249be78854ad195f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; also searches directories specified by the &lt;code&gt;PERL5LIB&lt;/code&gt; (or &lt;code&gt;PERLLIB&lt;/code&gt; if &lt;code&gt;PERL5LIB&lt;/code&gt; is not defined) and &lt;code&gt;PATH&lt;/code&gt; environment variables. (The latter is so that embedded pods for executables, such as &lt;code&gt;perldoc&lt;/code&gt; itself, are available.)</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; 还搜索由 &lt;code&gt;PERL5LIB&lt;/code&gt; （如果 &lt;code&gt;PERL5LIB&lt;/code&gt; &lt;code&gt;PERLLIB&lt;/code&gt; 则为PERLLIB）和 &lt;code&gt;PATH&lt;/code&gt; 环境变量指定的目录。（后者是为了提供可执行的嵌入式Pod，例如 &lt;code&gt;perldoc&lt;/code&gt; 本身。）</target>
        </trans-unit>
        <trans-unit id="845299ed0481bf59a19162b1d7d0d6134de3b1f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; is also a useful tool for browsing information contained in the documentation, especially in conjunction with a pager like &lt;code&gt;less&lt;/code&gt; (recent versions of which have Windows support). You may have to set the PAGER environment variable to use a specific pager. &quot;perldoc -f foo&quot; will print information about the perl operator &quot;foo&quot;.</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; 还是浏览文档中包含的信息的有用工具，尤其是与 &lt;code&gt;less&lt;/code&gt; 喜欢的寻呼机（其最新版本具有Windows支持）结合使用时。您可能必须将PAGER环境变量设置为使用特定的寻呼机。&amp;ldquo; perldoc -f foo&amp;rdquo;将打印有关perl运算符&amp;ldquo; foo&amp;rdquo;的信息。</target>
        </trans-unit>
        <trans-unit id="08ef34f009dc3c8dfa646a2efd211a1e35cb6acf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; will use, in order of preference, the pager defined in &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; , &lt;code&gt;MANPAGER&lt;/code&gt; , or &lt;code&gt;PAGER&lt;/code&gt; before trying to find a pager on its own. (&lt;code&gt;MANPAGER&lt;/code&gt; is not used if &lt;code&gt;perldoc&lt;/code&gt; was told to display plain text or unformatted pod.)</source>
          <target state="translated">&lt;code&gt;perldoc&lt;/code&gt; 在尝试自行查找传呼机之前，perldoc将按照优先顺序使用在 &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; ， &lt;code&gt;MANPAGER&lt;/code&gt; 或 &lt;code&gt;PAGER&lt;/code&gt; 中定义的传呼机。（如果告诉 &lt;code&gt;perldoc&lt;/code&gt; 显示纯文本或未格式化的窗格，则不使用 &lt;code&gt;MANPAGER&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="cd549af6c14da6fe8e46fcc76ca0b3c072f19abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perldoc&lt;/code&gt; will use, in order of preference, the pager defined in &lt;code&gt;PERLDOC_PAGER&lt;/code&gt;, &lt;code&gt;MANPAGER&lt;/code&gt;, or &lt;code&gt;PAGER&lt;/code&gt; before trying to find a pager on its own. (&lt;code&gt;MANPAGER&lt;/code&gt; is not used if &lt;code&gt;perldoc&lt;/code&gt; was told to display plain text or unformatted pod.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2849be26c68f462d616e31ee18a116b7064450b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perror&lt;/code&gt; - Write the message to standard error output as well to the system log (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22).</source>
          <target state="translated">&lt;code&gt;perror&lt;/code&gt; -将消息写到标准错误输出以及系统日志中（添加到 &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22中）。</target>
        </trans-unit>
        <trans-unit id="49676e81e4f423a3b3f261058e81e4680c24804d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perror&lt;/code&gt; - Write the message to standard error output as well to the system log. Added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.22.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7d63b44a36159d8e1d4d4335b3daf634e99588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; - Include PID with each message.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; -在每条消息中包含PID。</target>
        </trans-unit>
        <trans-unit id="809c4b7facc3eb780b2058815a2dcb35dc65ca46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plan&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;plan&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="fdb276cbb4ba5fc7d3b0e940bad1ed0150bce045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;port&lt;/code&gt; - sets the TCP or UDP port to connect to. Defaults to the first standard syslog port available on the system.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; -设置要连接的TCP或UDP端口。默认为系统上可用的第一个标准syslog端口。</target>
        </trans-unit>
        <trans-unit id="baac547aeaff5393799b5b0cafcc4eaeb65a4579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postderef&lt;/code&gt; - allow the use of postfix dereferencing expressions, including in interpolating strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ec803c3dc008a3da16774edaa8dc9ffe50879f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;postok&lt;/code&gt; will return</source>
          <target state="translated">&lt;code&gt;postok&lt;/code&gt; 将返回</target>
        </trans-unit>
        <trans-unit id="2d01a0fab20d0ff1f998f75c0cb1da085f4f2052" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pragma&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;pragma&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="826665825a05ce6bea816703958f3affe8424f0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision()&lt;/code&gt; sets or gets the global or local precision, aka at which digit before or after the dot to round all results. A set global precision also applies to all newly created numbers!</source>
          <target state="translated">&lt;code&gt;precision()&lt;/code&gt; 设置或获取全局或局部精度，也就是在点之前或之后的数字将所有结果取整。设置的全局精度也适用于所有新创建的数字！</target>
        </trans-unit>
        <trans-unit id="7976cc4186db8951c059e488dda4302f51af45d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;precomp&lt;/code&gt;&lt;code&gt;prelen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a05fc7c2ec9c9f8d0b33a7a4310351fcbd1f41e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; means: where to install the resulting perl library. Giving correct prefix you may avoid the need to specify &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; , see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 表示：将生成的perl库安装在何处。提供正确的前缀可以避免指定 &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt; 的需要，请参阅&lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;PERLLIB_PREFIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1f60f3b80a6c51144983ea914c0cd0a4c743661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; means: where to install the resulting perl library. Giving correct prefix you may avoid the need to specify &lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;, see &lt;a href=&quot;#PERLLIB_PREFIX&quot;&gt;&quot;&lt;code&gt;PERLLIB_PREFIX&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aaf8a737c0d23218299cfdec2230f7a8f0c080c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pregexec()&lt;/code&gt; is the main entry point for running a regex. It contains support for initialising the regex interpreter's state, running &lt;code&gt;re_intuit_start()&lt;/code&gt; if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter &lt;code&gt;pregexec()&lt;/code&gt; calls &lt;code&gt;regtry()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;pregexec()&lt;/code&gt; 是运行正则表达式的主要入口点。它包含以下方面的支持：初始化正则表达式解释器的状态，如果需要，运行 &lt;code&gt;re_intuit_start()&lt;/code&gt; ，并根据需要在各个起始位置的字符串上运行解释器。必要时使用正则表达式解释器 &lt;code&gt;pregexec()&lt;/code&gt; 调用 &lt;code&gt;regtry()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cff59e34d92eb388384f7cee854ef39563b37c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pregexec()&lt;/code&gt; is the main entry point for running a regex. It contains support for initialising the regex interpreter's state, running &lt;code&gt;re_intuit_start()&lt;/code&gt; if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter &lt;code&gt;pregexec()&lt;/code&gt; calls &lt;code&gt;regtry()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5650857d710e489383ebef502cde7faf3c94b385" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess&lt;/code&gt; is performed before &lt;code&gt;normalization&lt;/code&gt; (if defined).</source>
          <target state="translated">&lt;code&gt;preprocess&lt;/code&gt; 在 &lt;code&gt;normalization&lt;/code&gt; （如果定义）之前执行预处理。</target>
        </trans-unit>
        <trans-unit id="27df3d04b2fd880e0c0f8504356cc9a3aee349a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does know about the Perl extensions to Unicode properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;XPosixAlpha&lt;/code&gt; , and the single form equivalents to Unicode properties such as &lt;code&gt;XDigit&lt;/code&gt; , &lt;code&gt;Greek&lt;/code&gt; , &lt;code&gt;In_Greek&lt;/code&gt; , and &lt;code&gt;Is_Greek&lt;/code&gt; . The final example demonstrates that the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix is recognized for these extensions; it is needed to resolve ambiguities. For example, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; returns the list &lt;code&gt;(&lt;a href=&quot;../functions/lc&quot;&gt;lc&lt;/a&gt;, Lowercase_Mapping)&lt;/code&gt; , but &lt;code&gt;prop_aliases('islc')&lt;/code&gt; returns &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; . This is because &lt;code&gt;islc&lt;/code&gt; is a Perl extension which is short for &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; . The lists returned for the Perl extensions will not include the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix (whether or not the input had it) unless needed to resolve ambiguities, as shown in the &lt;code&gt;&quot;islc&quot;&lt;/code&gt; example, where the returned list had one element containing &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; , and the other without.</source>
          <target state="translated">&lt;code&gt;prop_aliases&lt;/code&gt; 确实了解Perl对Unicode属性的扩展，例如 &lt;code&gt;Any&lt;/code&gt; 和 &lt;code&gt;XPosixAlpha&lt;/code&gt; ，以及与Unicode属性的单形式等效项，例如 &lt;code&gt;XDigit&lt;/code&gt; ， &lt;code&gt;Greek&lt;/code&gt; ， &lt;code&gt;In_Greek&lt;/code&gt; 和 &lt;code&gt;Is_Greek&lt;/code&gt; 。最后的示例说明了这些扩展名可以识别为 &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; 前缀。需要解决歧义。例如， &lt;code&gt;prop_aliases('lc')&lt;/code&gt; 返回列表 &lt;code&gt;(&lt;a href=&quot;../functions/lc&quot;&gt;lc&lt;/a&gt;, Lowercase_Mapping)&lt;/code&gt; &lt;code&gt;prop_aliases('islc')&lt;/code&gt; ），而prop_aliases（'islc'）返回 &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt; 。这是因为 &lt;code&gt;islc&lt;/code&gt; 是Perl扩展名，它是 &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; 的缩写。除非需要解决歧义，否则为Perl扩展返回的列表将不包含 &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; 前缀（无论输入是否具有），如 &lt;code&gt;&quot;islc&quot;&lt;/code&gt; 示例所示，其中返回的列表具有一个包含 &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; 元素，而另一个没有。</target>
        </trans-unit>
        <trans-unit id="6745986d559f8896e412c863591b2be2488937a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does know about the Perl extensions to Unicode properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;XPosixAlpha&lt;/code&gt;, and the single form equivalents to Unicode properties such as &lt;code&gt;XDigit&lt;/code&gt;, &lt;code&gt;Greek&lt;/code&gt;, &lt;code&gt;In_Greek&lt;/code&gt;, and &lt;code&gt;Is_Greek&lt;/code&gt;. The final example demonstrates that the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix is recognized for these extensions; it is needed to resolve ambiguities. For example, &lt;code&gt;prop_aliases('lc')&lt;/code&gt; returns the list &lt;code&gt;(lc, Lowercase_Mapping)&lt;/code&gt;, but &lt;code&gt;prop_aliases('islc')&lt;/code&gt; returns &lt;code&gt;(Is_LC, Cased_Letter)&lt;/code&gt;. This is because &lt;code&gt;islc&lt;/code&gt; is a Perl extension which is short for &lt;code&gt;General_Category=Cased Letter&lt;/code&gt;. The lists returned for the Perl extensions will not include the &lt;code&gt;&quot;Is_&quot;&lt;/code&gt; prefix (whether or not the input had it) unless needed to resolve ambiguities, as shown in the &lt;code&gt;&quot;islc&quot;&lt;/code&gt; example, where the returned list had one element containing &lt;code&gt;&quot;Is_&quot;&lt;/code&gt;, and the other without.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84247d6d8b5f4deb4e612831eb63153e1c94e8c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those. Likewise for Perl internal properties, with the exception of &quot;Perl_Decimal_Digit&quot; which it does know about (and which is documented below in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;prop_aliases&lt;/code&gt; 不知道任何用户定义的属性，如果使用其中之一调用，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。同样，对于Perl内部属性，除了它确实知道的&amp;ldquo; Perl_Decimal_Digit&amp;rdquo;（以及在&lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap（）中记录的内容&lt;/a&gt;）之外。</target>
        </trans-unit>
        <trans-unit id="7953418e303ebec2e000b3657eaba392401f0f7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those. Likewise for Perl internal properties, with the exception of &quot;Perl_Decimal_Digit&quot; which it does know about (and which is documented below in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf618289fe95f5c6591702e1bf3bea4922c7495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; does not know about any user-defined nor Perl internal-only properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_invlist&lt;/code&gt; 不知道任何用户定义的属性或Perl仅供内部使用的属性，并且如果使用其中之一进行调用将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1638bd6528e8315c734f262e578bda41a74ac380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; does not know about any user-defined nor Perl internal-only properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5aeeb87bafc369250d5ed39e16fa0a2f0af855" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invlist&lt;/code&gt; returns an inversion list (described below) that defines all the code points for the binary Unicode property (or &quot;property=value&quot; pair) given by the input parameter string:</source>
          <target state="translated">&lt;code&gt;prop_invlist&lt;/code&gt; 返回一个反转列表（如下所述），该列表定义了输入参数字符串给定的二进制Unicode属性（或&amp;ldquo; property = value&amp;rdquo;对）的所有代码点：</target>
        </trans-unit>
        <trans-unit id="fa989c8b4b5a95be8ec4aa8facd791849d814072" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; 不知道任何用户定义的属性，如果使用其中之一调用，则会返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f434f40fc0c8cfb7f61886611000f3ab0f7f5797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b5d2b41a100d477c28d52672a39b5906a388f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is called with the name of the desired property. The name is loosely matched, meaning that differences in case, white-space, hyphens, and underscores are not meaningful (except for the trailing underscore in the old-form grandfathered-in property &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , or even better, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; 使用所需属性的名称调用prop_invmap。该名称是松散匹配的，这意味着大小写，空格，连字符和下划线的区别没有意义（旧式 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; 属性&amp;ldquo; L_&amp;rdquo;中的尾随下划线除外，最好将其写为 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ，甚至更好， &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="703bfeb4db55845afb59c57463ce2882efc9ee21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is called with the name of the desired property. The name is loosely matched, meaning that differences in case, white-space, hyphens, and underscores are not meaningful (except for the trailing underscore in the old-form grandfathered-in property &lt;code&gt;&quot;L_&quot;&lt;/code&gt;, which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt;, or even better, &lt;code&gt;&quot;Gc=LC&quot;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3074dd56d5e2ce626fd458ce5170ea74b97c7854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_invmap&lt;/code&gt; is used to get the complete mapping definition for a property, in the form of an inversion map. An inversion map consists of two parallel arrays. One is an ordered list of code points that mark range beginnings, and the other gives the value (or mapping) that all code points in the corresponding range have.</source>
          <target state="translated">&lt;code&gt;prop_invmap&lt;/code&gt; 用于以反向映射的形式获取属性的完整映射定义。反转图由两个并行数组组成。一个是标记范围起点的代码点的有序列表，另一个是对应范围内所有代码点所具有的值（或映射）。</target>
        </trans-unit>
        <trans-unit id="65de781e7dc1c905cffccb28d15af3c75f99eaef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_value_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_value_aliases&lt;/code&gt; 不了解任何用户定义的属性，如果使用其中之一调用，则将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d87971a864bcd8a658d6ec337955f9b90543f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_value_aliases&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13aedd3349055ca063b2a3be5fc3130232f4fe52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_values&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if called with one of those.</source>
          <target state="translated">&lt;code&gt;prop_values&lt;/code&gt; 不知道任何用户定义的属性，如果使用其中之一进行调用将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa6a8976393f856a6612e00a4cc756fe33e448f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prop_values&lt;/code&gt; does not know about any user-defined properties, and will return &lt;code&gt;undef&lt;/code&gt; if called with one of those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddc272f36f5e49350c5abcefb9763e22470ad34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proto&lt;/code&gt; specifies the protocol to use when doing a ping. The current choices are &quot;tcp&quot;, &quot;udp&quot;, &quot;icmp&quot;, &quot;icmpv6&quot;, &quot;stream&quot;, &quot;syn&quot;, or &quot;external&quot;. The default is &quot;tcp&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d3b7247a55fb61841c2cd9220df8051e3eff0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proto&lt;/code&gt; specifies the subroutine's prototype, unless one is supplied as an attribute (see below). If &lt;code&gt;proto&lt;/code&gt; is null, then the subroutine will not have a prototype. If &lt;code&gt;proto&lt;/code&gt; is non-null, it must point to a &lt;code&gt;const&lt;/code&gt; op whose value is a string, and the subroutine will have that string as its prototype. If a prototype is supplied as an attribute, the attribute takes precedence over &lt;code&gt;proto&lt;/code&gt;, but in that case &lt;code&gt;proto&lt;/code&gt; should preferably be null. In any case, &lt;code&gt;proto&lt;/code&gt; is consumed by this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025e4acec1a7e67356fe238218a8a736c87f0ad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protocol&lt;/code&gt; - If this field exists, it is the protocol of the response such as HTTP/1.0 or HTTP/1.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e345aaf2d0965411b10af684de0165f324819cb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protosv&lt;/code&gt; supplies the subroutine prototype to be applied to the call, or indicates that there is no prototype. It may be a normal scalar, in which case if it is defined then the string value will be used as a prototype, and if it is undefined then there is no prototype. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt;), of which the prototype will be used if it has one. The prototype (or lack thereof) supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff45ab6432c237367d478b2fc2feb55b5064d36b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protosv&lt;/code&gt; supplies the subroutine prototype to be applied to the call. It may be a normal defined scalar, of which the string value will be used. Alternatively, for convenience, it may be a subroutine object (a &lt;code&gt;CV*&lt;/code&gt; that has been cast to &lt;code&gt;SV*&lt;/code&gt;) which has a prototype. The prototype supplied, in whichever form, does not need to match the actual callee referenced by the op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda9cda944e40e411f22f900e42edf69ce3fb4e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;proxy&lt;/code&gt; &amp;mdash; URL of a generic proxy server for both HTTP and HTTPS connections (default is &lt;code&gt;$ENV{all_proxy}&lt;/code&gt; &amp;mdash; if set)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4cc0a06278943ac41398dc99f108f246fb54a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt; cannot be deferred. When you perform one of these operations, any deferred data is written to the file and the operation is performed immediately. This may change in a future version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afae59394fcb0c2c8ba7fce697eedb4d4f7b0ca0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr/pattern/msixpodualn&lt;/code&gt; lets you store a regex in a variable, or pass one around. Modifiers as for &lt;code&gt;m//&lt;/code&gt;, and are stored within the regex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8acb95a5fba19d0ac89c9aa75acbca0f4c389ed0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qr&lt;/code&gt; must return a compiled regexp, or a ref to a compiled regexp (such as &lt;code&gt;qr//&lt;/code&gt; returns), and any further overloading on the return value will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e332d3a9c72cce75d77414d7900c29b799b64b26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_format_needed()&lt;/code&gt; returns true if the &lt;code&gt;format&lt;/code&gt; string seems to contain at least one non-Q-prefixed &lt;code&gt;%[efgaEFGA]&lt;/code&gt; format specifier, or returns false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf0fb739653e12e7a6a4c395c0a5d42c93032d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_format_valid()&lt;/code&gt; checks that the intended single spec looks sane: begins with &lt;code&gt;%&lt;/code&gt;, has only one &lt;code&gt;%&lt;/code&gt;, ends with &lt;code&gt;[efgaEFGA]&lt;/code&gt;, and has &lt;code&gt;Q&lt;/code&gt; before it. This is not a full &quot;printf syntax check&quot;, just the basics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d83b784fb7fbf828698d133f5d9df87ff65ca3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict about its &lt;code&gt;format&lt;/code&gt; string and will fail, returning -1, if the format is invalid. It accepts exactly one format spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c062a836b2a17ba1fed01a1ef5000f0f504308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;HighBit&lt;/code&gt;, &lt;code&gt;undefPrint&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e20f11d061f309c8e06e804fa973c7cd62bdffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;quotemeta()&lt;/code&gt; and &lt;code&gt;\Q&lt;/code&gt; are fully described in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5c4503b427b56019a1f3a486ec67152a932298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qx//&lt;/code&gt; can also be called like a function with &lt;a href=&quot;perlfunc#readpipe&quot;&gt;&quot;readpipe&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d2317779e8d3054fa2ce4aa172a9af30ee26ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qx&lt;/code&gt; (aka the backtick operator), &lt;code&gt;system&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b59a52af9bb8b07d9a7e6951db46bf17370248d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rand($x)&lt;/code&gt; returns a number such that &lt;code&gt;0 &amp;lt;= rand($x) &amp;lt; $x&lt;/code&gt;. Thus what you want to have perl figure out is a random number in the range from 0 to the difference between your</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe37f0dcf25b4c9fbcdaa8fe00af0106f0a081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawdeflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rawdeflate&lt;/code&gt; 至少需要两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3de78f1b73590498b86947f2d769c7f1f2a64a3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawdeflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8c618e9a88333bd82066b9c07a4093fb94d4fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;rawinflate&lt;/code&gt; 至少需要两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6900770c7e3e9b0d226402924902ef0da9d825e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rawinflate&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3e1d0c526ec4f08f4256e3d160e1ce60b273a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_intuit_start()&lt;/code&gt; is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by &lt;code&gt;study_chunk()&lt;/code&gt; (and described in &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;&quot;Peep-hole Optimisation and Analysis&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1f960c44856903d77b260a19d1e06dab18de4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_intuit_start()&lt;/code&gt; is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by &lt;code&gt;study_chunk()&lt;/code&gt; (and described in &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;Peep-hole Optimisation and Analysis&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;re_intuit_start()&lt;/code&gt; 负责处理起点和不匹配的优化，这由 &lt;code&gt;study_chunk()&lt;/code&gt; 完成的分析结果确定（并在&amp;ldquo; &lt;a href=&quot;#Peep-hole-Optimisation-and-Analysis&quot;&gt;窥孔优化和分析&amp;rdquo;中进行了介绍&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e9879c08ced97a0fc27f0387bd62c459097f0631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;re_strict&lt;/code&gt; - enables strict mode in regular expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4d6f0e0e943c5446c9b9802362a19e836e3f0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;read()&lt;/code&gt; reads characters and returns the number of characters. &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;tell()&lt;/code&gt; operate on byte counts, as does &lt;code&gt;sysseek()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22e31c7f0f9aa65c05ce98460ad154ac12527a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readdir&lt;/code&gt;, &lt;code&gt;readlink&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6225c296acfc5e3b5f6f0c2e8719d05816704086" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readme&lt;/code&gt; displays the README file of the associated distribution. &lt;code&gt;Look&lt;/code&gt; gets and untars (if not yet done) the distribution file, changes to the appropriate directory and opens a subshell process in that directory. &lt;code&gt;perldoc&lt;/code&gt; displays the module's pod documentation in html or plain text format.</source>
          <target state="translated">&lt;code&gt;readme&lt;/code&gt; 文件显示关联发行版的README文件。 &lt;code&gt;Look&lt;/code&gt; 分发文件的获取和解压缩（如果尚未完成），更改为适当的目录，然后在该目录中打开一个子Shell进程。 &lt;code&gt;perldoc&lt;/code&gt; 以html或纯文本格式显示模块的pod文档。</target>
        </trans-unit>
        <trans-unit id="616eedbf531a925f329a14e071a3cf7f343db86b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rearrange&lt;/code&gt; and &lt;code&gt;hangul_terminator&lt;/code&gt; parameters are neglected. &lt;code&gt;katakana_before_hiragana&lt;/code&gt; and &lt;code&gt;upper_before_lower&lt;/code&gt; don't affect matching and searching, as it doesn't matter whether greater or less.</source>
          <target state="translated">&lt;code&gt;rearrange&lt;/code&gt; 和 &lt;code&gt;hangul_terminator&lt;/code&gt; 参数被忽略。 &lt;code&gt;katakana_before_hiragana&lt;/code&gt; 和 &lt;code&gt;upper_before_lower&lt;/code&gt; 不影响匹配和搜索，因为它并不不论大或小。</target>
        </trans-unit>
        <trans-unit id="b71d1e85a9f87ede8f1c8dcd7a1c4f81e4492184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; &amp;mdash; The response phrase returned by the server</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7088a75b0ffcb8196d5342cb6b0d84db9b2c212b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recallCommand&lt;/code&gt;, &lt;code&gt;ShellBang&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2031053d2f73cf50b46dd9d6bf80b7fe5eefaa91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redirects&lt;/code&gt; If this field exists, it is an arrayref of response hash references from redirects in the same order that redirections occurred. If it does not exist, then no redirections occurred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b051b18f244f32b477dab470c052b7ab042e5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refaliasing&lt;/code&gt; - allow aliasing via &lt;code&gt;\$x = \$y&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32262b67d0cac610b2102229a9b0152387e6b973" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reg()&lt;/code&gt; is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl's regexes have. For instance when parsing &lt;code&gt;/x(?:foo)y/&lt;/code&gt;, &lt;code&gt;reg()&lt;/code&gt; will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7e3a62ac5d117a96b72d8dcabc1b9d96e467f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reg()&lt;/code&gt; is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl's regexes have. For instance when parsing &lt;code&gt;/x(?:foo)y/&lt;/code&gt;&lt;code&gt;reg()&lt;/code&gt; will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</source>
          <target state="translated">&lt;code&gt;reg()&lt;/code&gt; 是解析过程的开始。它负责解析模式的任意块，直到字符串的末尾或在模式中遇到的第一个右括号。这意味着它可用于解析顶级正则表达式或分组括号内的任何部分。它还处理perl的正则表达式所具有的&amp;ldquo;特殊内容&amp;rdquo;。例如，当解析 &lt;code&gt;/x(?:foo)y/&lt;/code&gt; &lt;code&gt;reg()&lt;/code&gt; 时,将在某一时刻从&amp;ldquo;？&amp;rdquo;进行解析。直到（包括）&amp;ldquo;）的符号。</target>
        </trans-unit>
        <trans-unit id="0c957111983f253e3076925e4631813db6c2822e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regbranch()&lt;/code&gt; in turn calls &lt;code&gt;regpiece()&lt;/code&gt; which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, &lt;code&gt;regatom()&lt;/code&gt; is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like &lt;code&gt;$&lt;/code&gt; . If &lt;code&gt;regatom()&lt;/code&gt; encounters a &quot;(&quot; character it in turn calls &lt;code&gt;reg()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regbranch()&lt;/code&gt; 依次调用 &lt;code&gt;regpiece()&lt;/code&gt; ，后者处理后跟量词的&amp;ldquo;事物&amp;rdquo;。为了解析&amp;ldquo;事物&amp;rdquo;， &lt;code&gt;regatom()&lt;/code&gt; 。这是最低级别的例程，它解析常量字符串，字符类以及各种特殊符号（如 &lt;code&gt;$&lt;/code&gt; )。如果 &lt;code&gt;regatom()&lt;/code&gt; 遇到&amp;ldquo;（&amp;rdquo;字符，则依次调用 &lt;code&gt;reg()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a7f8fbab91692448d1ed9c47ed3f28aba84fad77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regbranch()&lt;/code&gt; in turn calls &lt;code&gt;regpiece()&lt;/code&gt; which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, &lt;code&gt;regatom()&lt;/code&gt; is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like &lt;code&gt;$&lt;/code&gt;. If &lt;code&gt;regatom()&lt;/code&gt; encounters a &quot;(&quot; character it in turn calls &lt;code&gt;reg()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eebbd56aa29755a9b8438c1a1a34663c687bfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_sets&lt;/code&gt; - allow extended bracketed character classes in regexps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e0285a40e365527c3360c8043442411516f88d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regmatch&lt;/code&gt; is the main &quot;recursive loop&quot; of the interpreter. It is basically a giant switch statement that implements a state machine, where the possible states are the regops themselves, plus a number of additional intermediate and failure states. A few of the states are implemented as subroutines but the bulk are inline code.</source>
          <target state="translated">&lt;code&gt;regmatch&lt;/code&gt; 是解释器的主要&amp;ldquo;递归循环&amp;rdquo;。从根本上讲，它是一个巨型的switch语句，用于实现状态机，其中可能的状态是regop本身，再加上许多其他的中间状态和故障状态。一些状态被实现为子例程，但大部分是内联代码。</target>
        </trans-unit>
        <trans-unit id="34320379070d5c0b4b993f583fcab86440065756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_1&lt;/code&gt; structures have the same header, followed by a single four-byte argument; &lt;code&gt;regnode_2&lt;/code&gt; structures contain two two-byte arguments instead:</source>
          <target state="translated">&lt;code&gt;regnode_1&lt;/code&gt; 结构具有相同的标头，后跟一个四个字节的参数； &lt;code&gt;regnode_2&lt;/code&gt; 结构改为包含两个两个字节的参数：</target>
        </trans-unit>
        <trans-unit id="e4dba4a9bca93381c17cd610e0197a487dcb2427" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_string&lt;/code&gt; structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the end with zero bytes so that the total length of the node is a multiple of four bytes:</source>
          <target state="translated">&lt;code&gt;regnode_string&lt;/code&gt; 用于文字字符串的regnode_string结构在标头后跟一个字节的长度，然后是字符串数据。最后用零字节填充字符串，以使节点的总长度为四个字节的倍数：</target>
        </trans-unit>
        <trans-unit id="e47b82a6ae23398c73ac5e31fc2c21109ab1136e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regnode_string&lt;/code&gt; structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the tail end with zero bytes so that the total length of the node is a multiple of four bytes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da61c4024c5fde5d0d5083c10881096ea875b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regtry()&lt;/code&gt; is the entry point into the regex interpreter. It expects as arguments a pointer to a &lt;code&gt;regmatch_info&lt;/code&gt; structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around &lt;code&gt;regmatch()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;regtry()&lt;/code&gt; 是正则表达式解释器的入口。它期望将指向 &lt;code&gt;regmatch_info&lt;/code&gt; 结构的指针和指向字符串的指针作为参数。它返回一个整数1表示成功，返回0表示失败。它基本上是 &lt;code&gt;regmatch()&lt;/code&gt; 的设置包装器。</target>
        </trans-unit>
        <trans-unit id="6ccbb08535479a243005d71982c034d77a82adda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regtry()&lt;/code&gt; is the entry point into the regex interpreter. It expects as arguments a pointer to a &lt;code&gt;regmatch_info&lt;/code&gt; structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around &lt;code&gt;regmatch()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756a74a73b044c834db8626f057853b231e20123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree()&lt;/code&gt;'s behaviour may be tuned by an optional hashref appearing as the last parameter on the call. If an empty string is passed to &lt;code&gt;remove_tree&lt;/code&gt;, an error will occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d191563625501cd0dd042566cf3df9fdb6af17ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything and restored the permissions of a directory, was unable to chdir back to the parent. The program halts to avoid a race condition from occurring.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 删除了所有内容并恢复了目录的权限后，无法chdir返回到父目录。程序停止运行以避免发生竞争情况。</target>
        </trans-unit>
        <trans-unit id="0e30094b13da141ed1e37ede35a62255c66728a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; , after having deleted everything in a directory, attempted to restore its permissions to the original state but failed. The directory may wind up being left behind.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 删除目录中的所有内容后，尝试将其权限恢复到原始状态，但失败。目录可能会被遗忘。</target>
        </trans-unit>
        <trans-unit id="ae7b650aa563617f4ec9fe94e5aa32c051a39081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to change the permissions on the current directory to ensure that subsequent unlinkings would not run into problems, but was unable to do so. The permissions remain as they were, and the program will carry on, doing the best it can.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试更改当前目录的权限，以确保后续的取消链接不会出现问题，但无法这样做。权限将保持原样，程序将继续尽其所能。</target>
        </trans-unit>
        <trans-unit id="95bc3df474e248a2e04291479bd3fa33e8cd5330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to determine the initial directory by calling &lt;code&gt;Cwd::getcwd&lt;/code&gt; , but the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试通过调用 &lt;code&gt;Cwd::getcwd&lt;/code&gt; 来确定初始目录，但是由于某种原因，调用失败。不会尝试删除任何内容。</target>
        </trans-unit>
        <trans-unit id="62def726fb82f655a702cd2c3581e60db5288319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to determine the initial directory by calling &lt;code&gt;Cwd::getcwd&lt;/code&gt;, but the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6ce072680f1019c3f3f85b4a8ee961eafa33e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to force the permissions of a file to ensure it could be deleted, but failed to do so. It will, however, still attempt to unlink the file.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试强制文件的权限以确保可以删除该文件，但未能这样做。但是，它将仍然尝试取消链接文件。</target>
        </trans-unit>
        <trans-unit id="97c03af431f1ab44b99d8b5b8fc841f1d6a8b1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to remove a directory, but failed. This may be because some objects that were unable to be removed remain in the directory, or it could be a permissions issue. The directory will be left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49be99d75fc1d4ab8517776a2c9c7bb74ae38eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to remove a directory, but failed. This may because some objects that were unable to be removed remain in the directory, or a permissions issue. The directory will be left behind.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试删除目录，但失败。这可能是因为某些无法删除的对象保留在目录中，或者出现权限问题。该目录将被留下。</target>
        </trans-unit>
        <trans-unit id="e7616985ed5b969eec07392de1388ed772d59985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to set the working directory in order to begin deleting the objects therein, but was unsuccessful. This is usually a permissions issue. The routine will continue to delete other things, but this directory will be left intact.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 试图设置工作目录以便开始删除其中的对象，但未成功。这通常是权限问题。该例程将继续删除其他内容，但此目录将保持不变。</target>
        </trans-unit>
        <trans-unit id="721db6f7a6d0b1be4b6b64fdeb2aa4c3fac630d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to stat the initial directory (after having successfully obtained its name via &lt;code&gt;getcwd&lt;/code&gt; ), however, the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试统计初始目录（通过 &lt;code&gt;getcwd&lt;/code&gt; 成功获取其名称后），但是，由于某种原因，调用失败。不会尝试删除任何内容。</target>
        </trans-unit>
        <trans-unit id="5ad6e37f9ee24026c6891f8ea8cad5b065fcc2f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; attempted to stat the initial directory (after having successfully obtained its name via &lt;code&gt;getcwd&lt;/code&gt;), however, the call failed for some reason. No attempt will be made to delete anything.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2cfce733e90f2119a65972900f218ea1224963" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; failed to remove a file. Probably a permissions issue.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 无法删除文件。可能是权限问题。</target>
        </trans-unit>
        <trans-unit id="7780e89fe07af9e10d0c6e4dc374ef9437694de0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; recorded the device and inode of a directory, and then moved into it. It then performed a &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on the current directory and detected that the device and inode were no longer the same. As this is at the heart of the race condition problem, the program will die at this point.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 记录设备和目录的inode，然后移入其中。然后，它在当前目录上执行 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ，并检测到设备和inode不再相同。由于这是争用条件问题的核心，因此程序将在此时死亡。</target>
        </trans-unit>
        <trans-unit id="0c1ce908a28184dec15f73c4d24f75d1ae429287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; recorded the device and inode of a directory, and then moved into it. It then performed a &lt;code&gt;stat&lt;/code&gt; on the current directory and detected that the device and inode were no longer the same. As this is at the heart of the race condition problem, the program will die at this point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c936a52751bd20d0155292a8ba2362d698dcd12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; tried to read the contents of the directory in order to acquire the names of the directory entries to be unlinked, but was unsuccessful. This is usually a permissions issue. The program will continue, but the files in this directory will remain after the call.</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 尝试读取目录的内容，以获取要取消链接的目录条目的名称，但未成功。这通常是权限问题。该程序将继续，但是该目录中的文件将在调用后保留。</target>
        </trans-unit>
        <trans-unit id="b0893a833dba2da63d1689754e9baa173690a309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; was unable to stat the parent directory after have returned from the child. Since there is no way of knowing if we returned to where we think we should be (by comparing device and inode) the only way out is to &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;remove_tree&lt;/code&gt; 从子级返回后，remove_tree无法统计父目录。由于无法知道我们是否返回了我们认为应该到达的位置（通过比较设备和inode），因此唯一的出路便是 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcc95caadd39c701babb53aed7cf4e82983752f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt; was unable to stat the parent directory after having returned from the child. Since there is no way of knowing if we returned to where we think we should be (by comparing device and inode) the only way out is to &lt;code&gt;croak&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c7739d189f502724359c79e96830844cc603dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt;, after having deleted everything and restored the permissions of a directory, was unable to chdir back to the parent. The program halts to avoid a race condition from occurring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e916929195c589fedc7fa6f3a273954aeac14e7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;remove_tree&lt;/code&gt;, after having deleted everything in a directory, attempted to restore its permissions to the original state but failed. The directory may wind up being left behind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1c7944247d6ffcb61ad07a6ffe54b513d1812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require&lt;/code&gt; has special additional dark magic: if you invoke your &lt;code&gt;require&lt;/code&gt; replacement as &lt;code&gt;require Foo::Bar&lt;/code&gt;, it will actually receive the argument &lt;code&gt;&quot;Foo/Bar.pm&quot;&lt;/code&gt; in @_. See &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd69d2d3e18f341cf60a46af272519b5c3cf1a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;require_ok&lt;/code&gt; will guess whether the input is a module name or a filename.</source>
          <target state="translated">&lt;code&gt;require_ok&lt;/code&gt; 将猜测输入的是模块名称还是文件名。</target>
        </trans-unit>
        <trans-unit id="8505e44467f89d3c5f13e3b0f5be5320e0760bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; can tell you what other modules a particular module requires. This is particularly useful when you're intending to write a module for public release and are listing its prerequisites.</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; 可以告诉您特定模块还需要哪些其他模块。当您打算编写要公开发布的模块并列出其先决条件时，这特别有用。</target>
        </trans-unit>
        <trans-unit id="d7622f99d032d83f40f152407bc369319dc35bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; takes but one argument: the name of a module. It will then first check if it can actually load this module, and return undef if it can't. Otherwise, it will return a list of modules and pragmas that would have been loaded on the module's behalf.</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; 需要一个参数：模块的名称。然后它将首先检查它是否可以实际加载该模块，如果不能，则返回undef。否则，它将返回将代表该模块加载的模块和编译指示的列表。</target>
        </trans-unit>
        <trans-unit id="6e6e70e552e6b050c1d411581b7b701935fc2d73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve_alias()&lt;/code&gt; does not need &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode::Alias&lt;/code&gt; ; it can be imported via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(resolve_alias)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;resolve_alias()&lt;/code&gt; 不需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode::Alias&lt;/code&gt; ; 可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(resolve_alias)&lt;/code&gt; 导入。</target>
        </trans-unit>
        <trans-unit id="6e6ee4d86f14b41f2347416cb6fbd72c3ea8b481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resolve_alias()&lt;/code&gt; does not need &lt;code&gt;use Encode::Alias&lt;/code&gt;; it can be imported via &lt;code&gt;use Encode qw(resolve_alias)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ec72b98ab29e9376244e1a028463dfab7884f99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_class&lt;/code&gt; (optional)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ca88a64ac36a768e80f1c263135396e20389ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rewind&lt;/code&gt; resets the current position of the specified file handle to the beginning of the file. It's really just a convenience method equivalent in effect to &lt;code&gt;seek($fh,0,0)&lt;/code&gt;. It returns a true value if successful, and &lt;code&gt;undef&lt;/code&gt; if it fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d808ac5985f7e78ab592ddff0b507312a4763996" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmscopy&lt;/code&gt; is VMS specific and cannot be exported; it must be referenced by its full name, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d220ebd3516c866a42a58737ac32f73d7b60593" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmsexpand&lt;/code&gt; on success will produce a name that fits in a 255 byte buffer, which is required for parameters passed to the DCL interpreter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7605f60079f8f1dc12ac3bd7e4a4ddde112eae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rmtree&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; will not work with multithreaded applications due to its use of &lt;code&gt;chdir&lt;/code&gt;. At this time, no warning or error is generated in this situation. You will certainly encounter unexpected results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409864670ba5b3a51d91aefad2f1baba7ffb1971" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; takes 4 arguments:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 需要4个参数：</target>
        </trans-unit>
        <trans-unit id="6e5e870ed1d46dfd7cef6254dbdde44232014c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will return a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; when called in scalar context. In list context, you will be returned a list of the following items:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 在标量上下文中运行时，run将返回简单的 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。在列表上下文中，将返回以下项目的列表：</target>
        </trans-unit>
        <trans-unit id="71adfc24f9d2e25fb176cec5e34573530b5011a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run&lt;/code&gt; will try to execute your command using the following logic:</source>
          <target state="translated">&lt;code&gt;run&lt;/code&gt; 将尝试使用以下逻辑来执行您的命令：</target>
        </trans-unit>
        <trans-unit id="61bf1af5a461bb65504ae6074130c8cb94c99510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is designed to survive and successfully terminate almost any long running task, even a fork bomb in case your system has the resources to survive during given timeout.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; 旨在生存并成功终止几乎所有长时间运行的任务，甚至包括分叉炸弹，以防您的系统在给定的超时时间内有生存的资源。</target>
        </trans-unit>
        <trans-unit id="dc5d98ab787a66354808b7b8789a0245cef29116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; is used to execute some program or a coderef, optionally feed it with some input, get its return code and output (both stdout and stderr into separate buffers). In addition, it allows to terminate the program if it takes too long to finish.</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; 用于执行某些程序或coderef，可以选择向其提供一些输入，获取其返回代码和输出（将stdout和stderr放入单独的缓冲区中）。另外，如果完成时间太长，它可以终止程序。</target>
        </trans-unit>
        <trans-unit id="420efc1f7e2a39e2d481baf8e0b32a892ee30985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_forked&lt;/code&gt; will return a HASHREF with the following keys:</source>
          <target state="translated">&lt;code&gt;run_forked&lt;/code&gt; 将返回带有以下键的HASHREF：</target>
        </trans-unit>
        <trans-unit id="2ffbf4e9e54a9897056a3f4cba8e11fe42ef030b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s/pattern/replacement/msixpogcedual&lt;/code&gt; substitutes matches of 'pattern' with 'replacement'. Modifiers as for &lt;code&gt;m//&lt;/code&gt;, with two additions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6532d404d405df3e3e80f6cf86d34916835c1ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; must be after or equal to &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca13c13725c8021829e1d9c9d0e16b479e48be9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt; must be before or equal to &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44468ed2da13e6b0326d22ae098610e252ce2bf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;same_language_tag&lt;/code&gt; works by just seeing whether &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; is the same as &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;same_language_tag&lt;/code&gt; 的工作原理是只看到是否 &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; 相同 &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="549db5722367437213a1dc3c58ec222287aa16f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;same_language_tag&lt;/code&gt; works by just seeing whether &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; is the same as &lt;code&gt;encode_language_tag($lang2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56eb36ce4645c802df1270fcfeea6fea69a3f470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;say()&lt;/code&gt; acts just like &lt;code&gt;print()&lt;/code&gt; except $\ will be localized to &lt;code&gt;\n&lt;/code&gt; so you need do nothing special to handle &lt;code&gt;say()&lt;/code&gt; in &lt;code&gt;PRINT()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f0e2afe2ef50aa67d8d4951eafeeaff281449ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scalar reverse()&lt;/code&gt; reverses by character rather than by byte.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9775e76df105754a2894401b2cc225239eed703d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_invlist&lt;/code&gt; is used to search an inversion list returned by &lt;code&gt;prop_invlist&lt;/code&gt; or &lt;code&gt;prop_invmap&lt;/code&gt; for a particular &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;. &lt;code&gt;undef&lt;/code&gt; is returned if the code point is not found in the inversion list (this happens only when it is not a legal &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or is less than the list's first element). A warning is raised in the first instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d48e38b365ce4bf6a3953fa6b04bb2ccda99aa7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;search_invlist&lt;/code&gt; is used to search an inversion list returned by &lt;code&gt;prop_invlist&lt;/code&gt; or &lt;code&gt;prop_invmap&lt;/code&gt; for a particular &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned if the code point is not found in the inversion list (this happens only when it is not a legal &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or is less than the list's first element). A warning is raised in the first instance.</source>
          <target state="translated">&lt;code&gt;search_invlist&lt;/code&gt; 用于搜索 &lt;code&gt;prop_invlist&lt;/code&gt; 或 &lt;code&gt;prop_invmap&lt;/code&gt; 返回的反转列表以查找特定的&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;。如果在反转列表中未找到代码点，则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （仅当它不是合法的&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;或小于列表的第一个元素时才会发生）。首先会发出警告。</target>
        </trans-unit>
        <trans-unit id="f0a8f69cac4c41cf105bf7401f5fffbc32923e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;select&lt;/code&gt; is a static method, that is you call it with the package name like &lt;code&gt;new&lt;/code&gt;. &lt;code&gt;READ&lt;/code&gt;, &lt;code&gt;WRITE&lt;/code&gt; and &lt;code&gt;EXCEPTION&lt;/code&gt; are either &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;IO::Select&lt;/code&gt; objects. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional and has the same effect as for the core select call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e70016d81c26851fdc1268a308e2475dcb72857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; accepts either a stat object, as returned by the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; method, or a list of</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 接受 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 方法返回的stat对象或列表</target>
        </trans-unit>
        <trans-unit id="5223afef6e1c6aea2ac19f7b51152375c25bd386" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; accepts either a stat object, as returned by the &lt;code&gt;stat&lt;/code&gt; method, or a list of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c710408719efbb408db55c8531da370f8ff3d836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the message queue.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 将设置与消息队列关联的 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 结构的以下值。</target>
        </trans-unit>
        <trans-unit id="ed728d4e7f99edf863813e9844924ed524fa1809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; structure associated with the semaphore set.</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 将设置与信号量集关联的 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 结构的以下值。</target>
        </trans-unit>
        <trans-unit id="99ae188a2af52b6d7409745617183138a71114cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;stat&lt;/code&gt; structure associated with the message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c430521619281049c53f3dce3f5848f9b3b73b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set&lt;/code&gt; will set the following values of the &lt;code&gt;stat&lt;/code&gt; structure associated with the semaphore set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d152a9c3ab9b89b16e2ee46596cf4f0fc19888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location)&lt;/code&gt; (added in Perl 5.004_02)</source>
          <target state="translated">&lt;code&gt;setlogsock($sock_type, $stream_location)&lt;/code&gt; （在Perl 5.004_02中添加）</target>
        </trans-unit>
        <trans-unit id="583013ce20407688d7c0e999267ffc67b0502e8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock($sock_type, $stream_location, $sock_timeout)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.25)</source>
          <target state="translated">&lt;code&gt;setlogsock($sock_type, $stream_location, $sock_timeout)&lt;/code&gt; （已添加到 &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.25中）</target>
        </trans-unit>
        <trans-unit id="87975c40147558f5f2ec4bebf437a9d770df0f75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setlogsock(\%options)&lt;/code&gt; (added in &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.28)</source>
          <target state="translated">&lt;code&gt;setlogsock(\%options)&lt;/code&gt; （已添加到 &lt;code&gt;Sys::Syslog&lt;/code&gt; 0.28中）</target>
        </trans-unit>
        <trans-unit id="f63809e33adb9f81d5272829313f7ce53ea0505c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setpriority&lt;/code&gt; and &lt;code&gt;getpriority&lt;/code&gt; are not compatible with earlier ports by Andreas Kaiser. See &lt;code&gt;&quot;setpriority, getpriority&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf698e71179f95e287e17aca75aec29afcab647" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setpriority&lt;/code&gt;, &lt;code&gt;getpriority&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd0c1e5dd9ea33cf369c7adb90355be92008a07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; allows you to &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; and &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; without giving any error message. But the &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; or &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; shared, causing the error &quot;lock can only be used on shared values&quot; to occur when you attempt to &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($hashref-&amp;gt;{key})&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($arrayref-&amp;gt;[idx])&lt;/a&gt;&lt;/code&gt; in another thread.</source>
          <target state="translated">&lt;code&gt;share()&lt;/code&gt; 允许您 &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; 和 &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; 而不给出任何错误消息。但 &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; 或 &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; 是&lt;b&gt;不&lt;/b&gt;共享，从而导致错误&amp;ldquo;锁只能在共享的值用的&amp;rdquo;当您尝试发生 &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($hashref-&amp;gt;{key})&lt;/a&gt;&lt;/code&gt; 或在另一个线程中 &lt;code&gt;&lt;a href=&quot;../functions/lock&quot;&gt;lock($arrayref-&amp;gt;[idx])&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6f2fdb2df98877bd6f8ae7cd61329aad3b830e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; allows you to &lt;code&gt;share($hashref-&amp;gt;{key})&lt;/code&gt; and &lt;code&gt;share($arrayref-&amp;gt;[idx])&lt;/code&gt; without giving any error message. But the &lt;code&gt;$hashref-&amp;gt;{key}&lt;/code&gt; or &lt;code&gt;$arrayref-&amp;gt;[idx]&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; shared, causing the error &quot;lock can only be used on shared values&quot; to occur when you attempt to &lt;code&gt;lock($hashref-&amp;gt;{key})&lt;/code&gt; or &lt;code&gt;lock($arrayref-&amp;gt;[idx])&lt;/code&gt; in another thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81400b21c44e81d3c85b6d25672fdb393b6c9649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; takes a variable and marks it as shared:</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; 接受一个变量并将其标记为shared：</target>
        </trans-unit>
        <trans-unit id="7b5f83dec6e18c4adabc00639c9878d8824925ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share&lt;/code&gt; will return the shared rvalue, but always as a reference.</source>
          <target state="translated">&lt;code&gt;share&lt;/code&gt; 将返回共享的右值，但始终作为参考。</target>
        </trans-unit>
        <trans-unit id="ce12ad32c52f4a291a29b41a4671200a88ca0b1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shared_clone&lt;/code&gt; takes a reference, and returns a shared version of its argument, performing a deep copy on any non-shared elements. Any shared elements in the argument are used as is (i.e., they are not cloned).</source>
          <target state="translated">&lt;code&gt;shared_clone&lt;/code&gt; 获取一个引用，并返回其参数的共享版本，对任何非共享元素执行深层复制。参数中的任何共享元素均按原样使用（即，它们不会被克隆）。</target>
        </trans-unit>
        <trans-unit id="88260b4ec0de821010e9a0a312a183095afd1ad4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signalLevel&lt;/code&gt;, &lt;code&gt;warnLevel&lt;/code&gt;, &lt;code&gt;dieLevel&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0c4d06136111a386d2b4203fa99ebc9d89ada4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signatures&lt;/code&gt; - allow subroutine signatures (for named arguments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a908f874fe3ace52e6aab214508c8fd2542bd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;smartmatch&lt;/code&gt; - allow the use of &lt;code&gt;~~&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8658f86d4777991376871c792874bcf7ea900b4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;special&lt;/code&gt; is a string, normally &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; . &lt;code&gt;NULL&lt;/code&gt; means to not use any special mappings; &lt;code&gt;&quot;&quot;&lt;/code&gt; means to use the special mappings. Values other than these two are treated as the name of the hash containing the special mappings, like &lt;code&gt;&quot;utf8::ToSpecLower&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;special&lt;/code&gt; 是一个字符串，通常为 &lt;code&gt;NULL&lt;/code&gt; 或 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。 &lt;code&gt;NULL&lt;/code&gt; 表示不使用任何特殊映射。 &lt;code&gt;&quot;&quot;&lt;/code&gt; 表示使用特殊映射。除这两个值以外的其他值均视为包含特殊映射的哈希名称，例如 &lt;code&gt;&quot;utf8::ToSpecLower&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="afd56f6fe104f2fc631089f285a812aa6fe50322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split /regex/, string&lt;/code&gt; splits &lt;code&gt;string&lt;/code&gt; into a list of substrings and returns that list. The regex determines the character sequence that &lt;code&gt;string&lt;/code&gt; is split with respect to. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da4c96f14b329fe16bad75b1f046bad021a838c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;splitOnLastStarter()&lt;/code&gt; should be called with a pre-normalized parameter &lt;code&gt;$normalized&lt;/code&gt; , that is in the same form as &lt;code&gt;$form&lt;/code&gt; you want.</source>
          <target state="translated">&lt;code&gt;splitOnLastStarter()&lt;/code&gt; 应该使用预规范化的参数 &lt;code&gt;$normalized&lt;/code&gt; 调用splitOnLastStarter（），该参数的形式与您想要的 &lt;code&gt;$form&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="8beef4cc5d29a6d5ad8b96d76357f9686085a8c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;splitOnLastStarter()&lt;/code&gt; should be called with a pre-normalized parameter &lt;code&gt;$normalized&lt;/code&gt;, that is in the same form as &lt;code&gt;$form&lt;/code&gt; you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05ad3d7e63ac0b923f42fda199d17cb36805c894" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;split_command&lt;/code&gt; will return a series of @cmds each processing part of the args. Collectively they will process all the arguments. Each individual line in @cmds will not be longer than the $self-&amp;gt;max_exec_len being careful to take into account macro expansion.</source>
          <target state="translated">&lt;code&gt;split_command&lt;/code&gt; 将在args的每个处理部分返回一系列@cmds。他们将共同处理所有参数。@cmds中的每一行都不会超过$ self-&amp;gt; max_exec_len，请小心考虑宏扩展。</target>
        </trans-unit>
        <trans-unit id="df7e33590ee18899069cc6cb7e5e1a3b180d3b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; is the node preceding the first node to be spliced. Node(s) following it will be deleted, and ops will be inserted after it. If it is &lt;code&gt;NULL&lt;/code&gt;, the first node onwards is deleted, and nodes are inserted at the beginning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9992eebbce269337eb7319fad7e4bae82773d69d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stash&lt;/code&gt; is the parent stash/package, if any.</source>
          <target state="translated">&lt;code&gt;stash&lt;/code&gt; 是父存储/程序包（如果有）。</target>
        </trans-unit>
        <trans-unit id="442fca8656f150edfde3e5013ba8d6ad88bb942b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;state &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; &lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194270003754ace4d214d73b56dfc0757735e5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state sub&lt;/code&gt; vs &lt;code&gt;my sub&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e85d873b3bc435bca89449147842f21071d9602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; variables were introduced in Perl 5.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cec3fb10dc556b8a200f91b68a1f1978d91a6823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; &amp;mdash; The HTTP status code of the response</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba8a29a29201132badc9fd27134fdf17ce04a300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str2bytes&lt;/code&gt; may be used as an alias for &lt;code&gt;encode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f9a328ccbc35b2b8e9066fa880a1d90d69b6a5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict 'subs'&lt;/code&gt; , with Perl 5.6.1, erroneously permitted to use an unquoted compound identifier (e.g. &lt;code&gt;Foo::Bar&lt;/code&gt; ) as a hash key (before &lt;code&gt;=&amp;gt;&lt;/code&gt; or inside curlies), but without forcing it always to a literal string.</source>
          <target state="translated">&lt;code&gt;strict 'subs'&lt;/code&gt; 在Perl 5.6.1中，严格的'subs'被错误地允许使用未加引号的复合标识符（例如 &lt;code&gt;Foo::Bar&lt;/code&gt; ）作为哈希键（在 &lt;code&gt;=&amp;gt;&lt;/code&gt; 之前或在curlies中），但没有将其始终强制为文字字符串。</target>
        </trans-unit>
        <trans-unit id="b3b8f269ae4845105b8f57708804986163c25e74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict 'subs'&lt;/code&gt;, with Perl 5.6.1, erroneously permitted to use an unquoted compound identifier (e.g. &lt;code&gt;Foo::Bar&lt;/code&gt;) as a hash key (before &lt;code&gt;=&amp;gt;&lt;/code&gt; or inside curlies), but without forcing it always to a literal string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a318f24d8bab6a75e045b750d78d7dd84307fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtod&lt;/code&gt; respects any POSIX &lt;code&gt;setlocale()&lt;/code&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt; settings, regardless of whether or not it is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Prior to Perl 5.28, or when operating in a non thread-safe environment, it should not be used in a threaded application unless it's certain that the underlying locale is C or POSIX. This is because it otherwise changes the locale, which globally affects all threads simultaneously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d0dc79bd558fb009a4a67ce8058c54beea585e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtod&lt;/code&gt; respects any POSIX &lt;code&gt;setlocale()&lt;/code&gt;&lt;code&gt;LC_TIME&lt;/code&gt; settings, regardless of whether or not it is called from Perl code that is within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;strtod&lt;/code&gt; 遵守任何POSIX &lt;code&gt;setlocale()&lt;/code&gt; &lt;code&gt;LC_TIME&lt;/code&gt; 设置，无论是否从 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 范围内的Perl代码中调用它。</target>
        </trans-unit>
        <trans-unit id="e6c9831d319071b95082e8dc2f29b6eca1f78c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strtol&lt;/code&gt; should respect any POSIX</source>
          <target state="translated">&lt;code&gt;strtol&lt;/code&gt; 应该尊重任何POSIX</target>
        </trans-unit>
        <trans-unit id="07d9fc447173aa1507860d93adda713683bb7035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; always creates a constructor called &lt;code&gt;new&lt;/code&gt; . That constructor may take a list of initializers for the various elements of the new struct.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 总是创建一个名为 &lt;code&gt;new&lt;/code&gt; 的构造函数。该构造函数可以为新结构的各个元素获取一个初始化程序列表。</target>
        </trans-unit>
        <trans-unit id="4588f880e95ab5093116d0d4a6242c2e9115a856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; always creates a constructor called &lt;code&gt;new&lt;/code&gt;. That constructor may take a list of initializers for the various elements of the new struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3422bf47e22c738697fbe6e62d2577b16012d3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strxfrm()&lt;/code&gt; takes a string and maps it into a transformed string for use in char-by-char comparisons against other transformed strings during collation. &quot;Under the hood&quot;, locale-affected Perl comparison operators call &lt;code&gt;strxfrm()&lt;/code&gt; for both operands, then do a char-by-char comparison of the transformed strings. By calling &lt;code&gt;strxfrm()&lt;/code&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;&quot;Magic Variables&quot; in perlguts&lt;/a&gt;) creates the transformed version of a string the first time it's needed in a comparison, then keeps this version around in case it's needed again. An example rewritten the easy way with &lt;code&gt;cmp&lt;/code&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call &lt;code&gt;strxfrm()&lt;/code&gt; directly, it treats the first null it finds as a terminator. Don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call &lt;code&gt;strxfrm()&lt;/code&gt; directly: let Perl do it for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f3f10d3365e07935bc666c63b8354aa30d2606" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strxfrm()&lt;/code&gt; takes a string and maps it into a transformed string for use in char-by-char comparisons against other transformed strings during collation. &quot;Under the hood&quot;, locale-affected Perl comparison operators call &lt;code&gt;strxfrm()&lt;/code&gt; for both operands, then do a char-by-char comparison of the transformed strings. By calling &lt;code&gt;strxfrm()&lt;/code&gt; explicitly and using a non locale-affected comparison, the example attempts to save a couple of transformations. But in fact, it doesn't save anything: Perl magic (see &lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;Magic Variables in perlguts&lt;/a&gt;) creates the transformed version of a string the first time it's needed in a comparison, then keeps this version around in case it's needed again. An example rewritten the easy way with &lt;code&gt;cmp&lt;/code&gt; runs just about as fast. It also copes with null characters embedded in strings; if you call &lt;code&gt;strxfrm()&lt;/code&gt; directly, it treats the first null it finds as a terminator. don't expect the transformed strings it produces to be portable across systems--or even from one revision of your operating system to the next. In short, don't call &lt;code&gt;strxfrm()&lt;/code&gt; directly: let Perl do it for you.</source>
          <target state="translated">&lt;code&gt;strxfrm()&lt;/code&gt; 接受一个字符串，并将其映射到一个转换后的字符串中，以便在整理期间与其他转换后的字符串进行逐个字符比较。受内部影响的Perl比较运算符&amp;ldquo;在 &lt;code&gt;strxfrm()&lt;/code&gt; 针对两个操作数调用strxfrm（），然后对转换后的字符串进行逐字符比较。通过显式调用 &lt;code&gt;strxfrm()&lt;/code&gt; 并使用不受区域设置影响的比较，该示例尝试保存一些转换。但是实际上，它并不能保存任何东西：Perl magic（请参阅&lt;a href=&quot;perlguts#Magic-Variables&quot;&gt;perlguts中的Magic Variables&lt;/a&gt;）在第一次比较时会创建字符串的转换版本，然后保留该版本，以防再次需要时使用。一个示例用 &lt;code&gt;cmp&lt;/code&gt; 重写了简单方法运行速度差不多。它还可以处理字符串中嵌入的空字符。如果直接调用 &lt;code&gt;strxfrm()&lt;/code&gt; ，它将把找到的第一个null视为终止符。不要期望它产生的转换后的字符串可以跨系统移植，甚至不能从操作系统的一个版本移植到下一个版本。简而言之，不要直接调用 &lt;code&gt;strxfrm()&lt;/code&gt; ：让Perl为您完成。</target>
        </trans-unit>
        <trans-unit id="eae013383db419ee7073c6ec936d1ee516677026" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;subbeg&lt;/code&gt;&lt;code&gt;sublen&lt;/code&gt;&lt;code&gt;saved_copy&lt;/code&gt;&lt;code&gt;suboffset&lt;/code&gt;&lt;code&gt;subcoffset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bbbc9ec3becb0729e14cb1a39b889ca48e69af5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest()&lt;/code&gt; runs the &amp;amp;code as its own little test with its own plan and its own result. The main test counts this as a single test using the result of the whole subtest to determine if its ok or not ok.</source>
          <target state="translated">&lt;code&gt;subtest()&lt;/code&gt; 使用自己的计划和结果将＆code作为自己的小测试运行。主测试使用整个子测试的结果将其计为单个测试，以确定其是否正常。</target>
        </trans-unit>
        <trans-unit id="40bfa9180cd766541f95ecd65e0c84670fed2bea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subtest&lt;/code&gt; also, and optionally, accepts arguments which will be passed to the subtests reference.</source>
          <target state="translated">&lt;code&gt;subtest&lt;/code&gt; 也可以选择接受参数，这些参数将传递给子测试引用。</target>
        </trans-unit>
        <trans-unit id="3d7e26bf7c2983b065b13497648ff49834a4e28e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt; &amp;mdash; Boolean indicating whether the operation returned a 2XX status code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53945fe0e229f2a3d9e218abb1d550e5ef4cb623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , or &lt;code&gt;fatal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; ， &lt;code&gt;warning&lt;/code&gt; 或 &lt;code&gt;fatal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e91ef20313244695042fbdb9523a597b0812cbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;success&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;fatal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5edbfcf499afde359ec82161688eeb181e0cc64e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;summary&lt;/code&gt; prints the summary report after all tests are run. The first argument is an aggregate to summarise. An optional second argument may be set to a true value to indicate that the summary is being output as a result of an interrupted test run.</source>
          <target state="translated">&lt;code&gt;summary&lt;/code&gt; 在运行所有测试后打印摘要报告。第一个参数是一个汇总。可以将可选的第二个参数设置为true值，以指示由于测试运行中断而正在输出摘要。</target>
        </trans-unit>
        <trans-unit id="b7d76fa49c169f566fa1c1da718f1e7b2ad5c1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; , &lt;code&gt;av&lt;/code&gt; , &lt;code&gt;hv&lt;/code&gt; , etc. represent variables of their respective types.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; ， &lt;code&gt;av&lt;/code&gt; ， &lt;code&gt;hv&lt;/code&gt; 等表示它们各自类型的变量。</target>
        </trans-unit>
        <trans-unit id="40e738adb0309ebb6a8435f716aa40a76e770938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;mg&lt;/code&gt; are the tied thingy and the tie magic.</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; 和 &lt;code&gt;mg&lt;/code&gt; 是捆绑物和领带魔术。</target>
        </trans-unit>
        <trans-unit id="fd7ac714e7e858b4bd36af6eb630a83e9e72f3e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt; optionally supplies the variable that will be aliased to each item in turn; if null, it defaults to &lt;code&gt;$_&lt;/code&gt;. &lt;code&gt;expr&lt;/code&gt; supplies the list of values to iterate over. &lt;code&gt;block&lt;/code&gt; supplies the main body of the loop, and &lt;code&gt;cont&lt;/code&gt; optionally supplies a &lt;code&gt;continue&lt;/code&gt; block that operates as a second half of the body. All of these optree inputs are consumed by this function and become part of the constructed op tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f519f07c55ae031f435eafb31d68db181893e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv&lt;/code&gt;, &lt;code&gt;av&lt;/code&gt;, &lt;code&gt;hv&lt;/code&gt;, etc. represent variables of their respective types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6186b5a2d793323ec197d8a7ba5e492ded38439" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_newmortal()&lt;/code&gt; creates an SV (with the undefined value) whose sole reference is mortal. &lt;code&gt;sv_mortalcopy()&lt;/code&gt; creates an xV whose value is a copy of a supplied xV and whose sole reference is mortal. &lt;code&gt;sv_2mortal()&lt;/code&gt; mortalises an existing xV reference: it transfers ownership of a reference from the caller to the temps stack. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt;, &lt;code&gt;sv_setiv&lt;/code&gt;, etc. :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c898bb2d89a58d12a4afd52693893972cc7118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt; , and &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">&lt;code&gt;sv_utf8_upgrade&lt;/code&gt; ， &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt; 和 &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; 是根据此功能实现的。</target>
        </trans-unit>
        <trans-unit id="29e86afca5e89be112747e7c177a4d9e70c992e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_utf8_upgrade&lt;/code&gt;, &lt;code&gt;sv_utf8_upgrade_nomg&lt;/code&gt;, and &lt;code&gt;sv_utf8_upgrade_flags&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="157cb2f67b5c943efab75ae716b270926cd23e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_vsetpvfn&lt;/code&gt; is an analogue of &lt;code&gt;vsprintf&lt;/code&gt; , but it allows you to specify either a pointer to a variable argument list or the address and length of an array of SVs. The last argument points to a boolean; on return, if that boolean is true, then locale-specific information has been used to format the string, and the string's contents are therefore untrustworthy (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). This pointer may be NULL if that information is not important. Note that this function requires you to specify the length of the format.</source>
          <target state="translated">&lt;code&gt;sv_vsetpvfn&lt;/code&gt; 是 &lt;code&gt;vsprintf&lt;/code&gt; 的类似物，但是它允许您指定指向变量参数列表的指针或SV数组的地址和长度。最后一个参数指向一个布尔值；返回时，如果该布尔值为true，则使用了特定于语言环境的信息来格式化字符串，因此字符串的内容是不可信任的（请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。如果该信息不重要，则此指针可以为NULL。请注意，此功能要求您指定格式的长度。</target>
        </trans-unit>
        <trans-unit id="45b0e4532eab3f4685ffc68239603f95fffd5e78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sv_vsetpvfn&lt;/code&gt; is an analogue of &lt;code&gt;vsprintf&lt;/code&gt;, but it allows you to specify either a pointer to a variable argument list or the address and length of an array of SVs. The last argument points to a boolean; on return, if that boolean is true, then locale-specific information has been used to format the string, and the string's contents are therefore untrustworthy (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). This pointer may be NULL if that information is not important. Note that this function requires you to specify the length of the format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6192b1f9a09d1e08c5d741af54f3f7df0fea1f0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;swashp&lt;/code&gt; is a pointer to the swash to use.</source>
          <target state="translated">&lt;code&gt;swashp&lt;/code&gt; 是要使用的swash的指针。</target>
        </trans-unit>
        <trans-unit id="aef4e35b1afe3553efb4b712e9852e7aa7d3f53a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; - allow the use of &lt;code&gt;~~&lt;/code&gt;, given, and when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2da7c9c32ace5dff26064e81dc2ec6cc09498f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync&lt;/code&gt; synchronizes a file's in-memory state with that on the physical medium. &lt;code&gt;sync&lt;/code&gt; does not operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and systell). This means that any data held at the perlio api level will not be synchronized. To synchronize data that is buffered at the perlio api level you must use the flush method. &lt;code&gt;sync&lt;/code&gt; is not implemented on all platforms. Returns &quot;0 but true&quot; on success, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for an invalid handle. See</source>
          <target state="translated">&lt;code&gt;sync&lt;/code&gt; 将文件的内存状态与物理介质上的状态同步。 &lt;code&gt;sync&lt;/code&gt; 不是在perlio api级别上运行，而是在文件描述符上运行（类似于sysread，sysseek和systell）。这意味着保存在perlio api级别的任何数据都不会同步。要同步在perlio api级别上缓冲的数据，您必须使用flush方法。并非在所有平台上都实现 &lt;code&gt;sync&lt;/code&gt; 。返回&amp;ldquo;0，但真正的&amp;rdquo;成功， &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 上的错误， &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 为无效句柄。看到</target>
        </trans-unit>
        <trans-unit id="641ae46752b733268d4ff91c13386322a2ff65db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync&lt;/code&gt; synchronizes a file's in-memory state with that on the physical medium. &lt;code&gt;sync&lt;/code&gt; does not operate at the perlio api level, but operates on the file descriptor (similar to sysread, sysseek and systell). This means that any data held at the perlio api level will not be synchronized. To synchronize data that is buffered at the perlio api level you must use the flush method. &lt;code&gt;sync&lt;/code&gt; is not implemented on all platforms. Returns &quot;0 but true&quot; on success, &lt;code&gt;undef&lt;/code&gt; on error, &lt;code&gt;undef&lt;/code&gt; for an invalid handle. See &lt;a&gt;fsync(3c)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f52732e5ca5d6dc1f9d7a73b47a336dd75ae0832" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sysread()&lt;/code&gt; and &lt;code&gt;syswrite()&lt;/code&gt; should not be used on file handles with character encoding layers, they behave badly, and that behaviour has been deprecated since perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7a1d988b5d966d66bda631776a131bc7766695f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;system&lt;/code&gt; also provides direct control over whether shell wildcard processing may take place, whereas backticks do not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dae47b8de1a6666d5c99c3d891e28c5d893f5b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;talk&lt;/code&gt; is a reference to an array that contains alternating questions and answers. Questions are regular expressions and answers are literal strings. The Expect module watches the stream from the execution of the external program (&lt;code&gt;perl Makefile.PL&lt;/code&gt; , &lt;code&gt;perl
Build.PL&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , etc.).</source>
          <target state="translated">&lt;code&gt;talk&lt;/code&gt; 是对包含交替的问题和答案的数组的引用。问题是正则表达式，答案是文字字符串。Expect模块从外部程序（ &lt;code&gt;perl Makefile.PL&lt;/code&gt; ， &lt;code&gt;perl Build.PL&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; 等）的执行中监视流。</target>
        </trans-unit>
        <trans-unit id="5a08a149b1432446a1f11c65976e031610a41451" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="0ad3f8e851285dfbe4f6b91f450bb2505e866a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test_fail&lt;/code&gt; exists as a convenience function that can be called instead. It takes one argument, the offset from the current line that the line that causes the fail is on.</source>
          <target state="translated">&lt;code&gt;test_fail&lt;/code&gt; 作为方便函数存在，可以调用它。它采用一个参数，即导致失败的行在当前行上的偏移量。</target>
        </trans-unit>
        <trans-unit id="90da6b1102889759293d832aa8ea25d7abcef86c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; returns a list of thread objects, one for each thread that's currently running and not detached. Handy for a number of things, including cleaning up at the end of your program (from the main Perl thread, of course):</source>
          <target state="translated">&lt;code&gt;threads-&amp;gt;list()&lt;/code&gt; 返回线程对象的列表，每个当前正在运行但未分离的线程一个。在很多事情上都很方便，包括在程序结束时进行清理（当然是从Perl主线程）：</target>
        </trans-unit>
        <trans-unit id="01a84580d195b2879df6edd3b9fb211e6bd1e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tick&lt;/code&gt;, &lt;code&gt;quoteHighBit&lt;/code&gt;, &lt;code&gt;printUndef&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37fe7f59563dbe7257cc9d61b178eb076121ea2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tid()&lt;/code&gt; is a thread object method that returns the thread ID of the thread the object represents. Thread IDs are integers, with the main thread in a program being 0. Currently Perl assigns a unique TID to every thread ever created in your program, assigning the first thread to be created a TID of 1, and increasing the TID by 1 for each new thread that's created. When used as a class method, &lt;code&gt;threads-&amp;gt;tid()&lt;/code&gt; can be used by a thread to get its own TID.</source>
          <target state="translated">&lt;code&gt;tid()&lt;/code&gt; 是一个线程对象方法，它返回该对象表示的线程的线程ID。线程ID是整数，程序中的主线程为0。当前，Perl为程序中创建的每个线程分配一个唯一的TID，将要创建的第一个线程的TID分配为1，并将每个线程的TID增加1。创建的新线程。当用作类方法时，线程可以使用 &lt;code&gt;threads-&amp;gt;tid()&lt;/code&gt; 获得自己的TID。</target>
        </trans-unit>
        <trans-unit id="3e5a788348d8864316119440464ae18df37f7eaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="81be08d630009f1394c690c301f7f5a7b2339e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15042c572a01150cfb24fe4943a335ce4853ab16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal_modern()&lt;/code&gt; and &lt;code&gt;timegm_modern()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d00ab1ec67e662b179958a94aeba2124bbb15e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;timelocal_nocheck()&lt;/code&gt; 和 &lt;code&gt;timegm_nocheck()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47bf99f23525fe65db8d003f48ed26cc136216f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; &amp;mdash; Request timeout in seconds (default is 60) If a socket open, read or write takes longer than the timeout, an exception is thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1f26ad06e5c0601fee78fd543cafca65d09238" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - equivalent to &lt;code&gt;$sock_timeout&lt;/code&gt; , sets the socket timeout in seconds. Defaults to 0 on all systems except Mac OS X where it is set to 0.25 sec.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; -相当于 &lt;code&gt;$sock_timeout&lt;/code&gt; ，设置以秒为套接字超时。除Mac OS X设置为0.25秒外，所有系统上的默认值均为0。</target>
        </trans-unit>
        <trans-unit id="0d40ed8263db69f63f85252a957f6a1923552655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; - equivalent to &lt;code&gt;$sock_timeout&lt;/code&gt;, sets the socket timeout in seconds. Defaults to 0 on all systems except Mac OS X where it is set to 0.25 sec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1223429184be3c4a3e3dbe7bc07b1c04c106dc15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; denotes a timeout in seconds. Floating-point timeouts are OK. With &lt;code&gt;mode=deterministic&lt;/code&gt; , the timeout denotes the timeout per question; with &lt;code&gt;mode=anyorder&lt;/code&gt; it denotes the timeout per byte received from the stream or questions.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 表示以秒为单位的超时。浮点超时是可以的。使用 &lt;code&gt;mode=deterministic&lt;/code&gt; 时，超时表示每个问题的超时；与 &lt;code&gt;mode=anyorder&lt;/code&gt; 一起,它表示从流或问题接收到的每个字节的超时。</target>
        </trans-unit>
        <trans-unit id="dd0df4bd3a02dfe65598daa77dcdc6e0c0b22412" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo()&lt;/code&gt; is about finding the right package to look for &lt;code&gt;$TODO&lt;/code&gt; in. It's pretty good at guessing the right package to look at. It first looks for the caller based on &lt;code&gt;$Level + 1&lt;/code&gt; , since &lt;code&gt;todo()&lt;/code&gt; is usually called inside a test function. As a last resort it will use &lt;code&gt;exported_to()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;todo()&lt;/code&gt; 关于找到合适的包来寻找 &lt;code&gt;$TODO&lt;/code&gt; 。它很好地猜测了要看的合适包。它首先根据 &lt;code&gt;$Level + 1&lt;/code&gt; 查找调用方，因为 &lt;code&gt;todo()&lt;/code&gt; 通常在测试函数中调用。作为最后的手段，它将使用 &lt;code&gt;exported_to()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f258b2d9b8d09d9fae8fc22e4845c2a47b1ddb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo()&lt;/code&gt; is about finding the right package to look for &lt;code&gt;$TODO&lt;/code&gt; in. It's pretty good at guessing the right package to look at. It first looks for the caller based on &lt;code&gt;$Level + 1&lt;/code&gt;, since &lt;code&gt;todo()&lt;/code&gt; is usually called inside a test function. As a last resort it will use &lt;code&gt;exported_to()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="480a9cfa214732ba9a24ba357b41b6de49286344" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todo_output&lt;/code&gt; is used instead of &lt;code&gt;failure_output()&lt;/code&gt; for the diagnostics of a failing TODO test. These will not be seen by the user.</source>
          <target state="translated">&lt;code&gt;todo_output&lt;/code&gt; 对于失败的TODO测试，使用todo_output代替 &lt;code&gt;failure_output()&lt;/code&gt; 。这些将不会被用户看到。</target>
        </trans-unit>
        <trans-unit id="63b5f25eda63530af4b5b7de433395a3f0e3e276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tr///&lt;/code&gt;, &lt;code&gt;y///&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ddec8a45eeda13fb91eb0ae8954551ddba8e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trailer_callback&lt;/code&gt; &amp;mdash; A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f6fa502080435164a069d25ad4e047384a776b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - equivalent to &lt;code&gt;$sock_type&lt;/code&gt; , selects the socket type (or &quot;mechanism&quot;). An array reference can be passed to specify several mechanisms to try, in the given order.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; -等同于 &lt;code&gt;$sock_type&lt;/code&gt; ，选择插座型（或&amp;ldquo;机构&amp;rdquo;）。可以传递数组引用以指定给定顺序的几种尝试机制。</target>
        </trans-unit>
        <trans-unit id="f30209a9c17c2698d845377a2869740567d6669e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - equivalent to &lt;code&gt;$sock_type&lt;/code&gt;, selects the socket type (or &quot;mechanism&quot;). An array reference can be passed to specify several mechanisms to try, in the given order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201b469f2e38039b039595a7bfd410577149a7cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt; , where it is equivalent to 1 (or 45, which here is equivalent).</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; ，它等于1（或45，在这里等效）。</target>
        </trans-unit>
        <trans-unit id="47456dc4ed8c495bfa1ec258b5fe33359e7ae949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;u&lt;/code&gt;, where it is equivalent to 1 (or 45, which here is equivalent).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904baef9244a9061ba1e5baaa7bde6857e2dd419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; is always treated as numeric, and in particular is changed to &lt;code&gt;0&lt;/code&gt; before incrementing (so that a post-increment of an undef value will return &lt;code&gt;0&lt;/code&gt; rather than &lt;code&gt;undef&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d344aa8d59bc6d9dc9bc4053bff6b659ec168c15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; only ever matches another &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14c4c57a89d245b76f4faa55818a7b4b4128be79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt; will only ever match &lt;code&gt;undef&lt;/code&gt;. So you can test a value against &lt;code&gt;undef&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd3ff8b5f0a042c50be93a5729b5b85e516c3d3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;, indicating that no prefs files remain to be found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57cc6e1b81814a09169f200f225fe6bcb63529d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;, which is a valid scalar), the original deserialised hash will be inserted. This setting can slow down decoding considerably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b4d96f2f281815a4c230e88fda03f84150f077" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;-ing a &lt;code&gt;Tie::File&lt;/code&gt; array element just blanks out the corresponding record in the file. When you read it back again, you'll get the empty string, so the supposedly-&lt;code&gt;undef&lt;/code&gt;'ed value will be defined. Similarly, if you have &lt;code&gt;autochomp&lt;/code&gt; disabled, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedf861fafa961a23cfda13ddd6f5764ed4cc713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undef&lt;/code&gt;. The value of the macro is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04aeee1dcd5104050c34c9167c016f0abab6c44f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode_eval&lt;/code&gt; changes the behavior of plain string &lt;code&gt;eval&lt;/code&gt; to work more consistently, especially in the Unicode world. Certain (mis)behaviors couldn't be changed without breaking some things that had come to rely on them, so the feature can be enabled and disabled. Details are at &lt;a href=&quot;perlfunc#Under-the-%22unicode_eval%22-feature&quot;&gt;&quot;Under the &quot;unicode_eval&quot; feature&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d894b0dfce17a1497005852b9dfd4d7177a5014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unixify&lt;/code&gt; on the resulting file specification may not result in the original Unix file specification, so programs should not plan to convert a file specification from Unix to VMS and then back to Unix again after modification of the components.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ef1be18f87901f5ccbe85addef0901d51f67cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unknown&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="4f83ff1d4682685cbd2f8afa49310d2e61c28282" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unlink&lt;/code&gt; will delete a file if at all possible, even if it requires changing file protection (though it won't try to change the protection of the parent directory). You can tell whether you've got explicit delete access to a file by using the &lt;code&gt;VMS::Filespec::candelete&lt;/code&gt; operator. For instance, in order to delete only files to which you have delete access, you could say something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467b41679413c9a8fc738c593b15964285b5346c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unlink&lt;/code&gt; will delete the highest version of a file only; in order to delete all versions, you need to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8613fe9e8f4b7f5c053abd048c52ac7b66243a9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unmemoize&lt;/code&gt; accepts a reference to, or the name of a previously memoized function, and undoes whatever it did to provide the memoized version in the first place, including making the name refer to the unmemoized version if appropriate. It returns a reference to the unmemoized version of the function.</source>
          <target state="translated">&lt;code&gt;unmemoize&lt;/code&gt; 接受对先前记忆功能的引用或名称，并且首先撤消其提供记忆版本的操作，包括在适当的情况下使名称引用未记忆版本。它返回对该函数的未存储版本的引用。</target>
        </trans-unit>
        <trans-unit id="d37e0040afc632f6d7e9f0edcbcd7999ecda8585" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unwrapped|made|tested successfully&lt;/code&gt; or something similar. Another situation where CPAN refuses to act is an &lt;code&gt;install&lt;/code&gt; if the corresponding &lt;code&gt;test&lt;/code&gt; was not successful.</source>
          <target state="translated">&lt;code&gt;unwrapped|made|tested successfully&lt;/code&gt; 或类似。如果相应的 &lt;code&gt;test&lt;/code&gt; 不成功，则CPAN拒绝采取行动的另一种情况是 &lt;code&gt;install&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c76e8afb9eb470c6542de95c6fdb923fa4e1dc22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;unzip&lt;/code&gt; 至少需要两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a141367ed9e8db70d8a48598a73de00d6074b349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unzip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5e5dfa01f20adda70ae490b1d7ced48e4188740" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;url&lt;/code&gt; &amp;mdash; URL that provided the response. This is the URL of the request unless there were redirections, in which case it is the last URL queried in a redirection chain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775adf7a055e6dd04a94860178a8c7033a66114b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use VERSION&lt;/code&gt; also lexically enables all features available in the requested version as defined by the &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; pragma, disabling any features not in the requested version's feature bundle. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. Similarly, if the specified Perl version is greater than or equal to 5.12.0, strictures are enabled lexically as with &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt;. Any explicit use of &lt;code&gt;use strict&lt;/code&gt; or &lt;code&gt;no strict&lt;/code&gt; overrides &lt;code&gt;use VERSION&lt;/code&gt;, even if it comes before it. Later use of &lt;code&gt;use VERSION&lt;/code&gt; will override all behavior of a previous &lt;code&gt;use VERSION&lt;/code&gt;, possibly removing the &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;feature&lt;/code&gt; added by &lt;code&gt;use VERSION&lt;/code&gt;. &lt;code&gt;use VERSION&lt;/code&gt; does not load the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717c117d37180baef4adfbf000524727bc507192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use bytes&lt;/code&gt; is usually a failed attempt to do something useful. Just forget about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aa38eb6ffe74b5abdd43e2e0ac5b726882991ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use encoding ...&lt;/code&gt; is not thread-safe (i.e., do not use in threaded applications).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f2b56f1c9a3044d97aa218ad8aea7f7b9cdf18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'fc'&lt;/code&gt; tells the compiler to enable the &lt;code&gt;fc&lt;/code&gt; function, which implements Unicode casefolding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e16745836f5ce127bfa2bfd2cc3af2cfefa548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'say'&lt;/code&gt; tells the compiler to enable the Perl 6 style &lt;code&gt;say&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a96afe18265d9e679f00d2a3490fb1e880a320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'state'&lt;/code&gt; tells the compiler to enable &lt;code&gt;state&lt;/code&gt; variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19eba9a202b007212807a12e2c4702f09b892a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'switch'&lt;/code&gt; tells the compiler to enable the Perl 6 given/when construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b1d8b49d90ed7714df07f45c6118bdb1fefaf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells the compiler to use Unicode rules in all string operations executed within its scope (unless they are also within the scope of either &lt;code&gt;use locale&lt;/code&gt; or &lt;code&gt;use bytes&lt;/code&gt;). The same applies to all regular expressions compiled within the scope, even if executed outside it. It does not change the internal representation of strings, but only how they are interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be49598767088a16f67d8e865b1d6de66c06090b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use re 'debug'&lt;/code&gt; enables you to see the gory details of how the Perl regular expression engine works. In order to understand this typically voluminous output, one must not only have some idea about how regular expression matching works in general, but also know how Perl's regular expressions are internally compiled into an automaton. These matters are explored in some detail in &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc1e6e58c1c375445799dfd763325680eeb68f86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use utf8&lt;/code&gt; still needed to enable &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt; in scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef69911d7fdf83a2eb4ad2b4a9ebf4ca7e75fe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use utf8&lt;/code&gt; wasn't implicitly declared so you have to &lt;code&gt;use utf8&lt;/code&gt; to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578368502634d503139789b27f785f7a4040cb4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use&lt;/code&gt; a Perl module if a condition holds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba4443e83dc26256681811989a51344cf04a795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; are aliases of &lt;code&gt;owner&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;uid&lt;/code&gt; 是 &lt;code&gt;owner&lt;/code&gt; 的别名。</target>
        </trans-unit>
        <trans-unit id="db9006160e92aa365d9ee98dad3ea083afe695fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt; and &lt;code&gt;uid&lt;/code&gt; are aliases of &lt;code&gt;owner&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f1ed7e3d101e35e8cb1464b06fde105ee5daff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ustrp&lt;/code&gt; is a pointer to the character buffer to put the conversion result to. &lt;code&gt;lenp&lt;/code&gt; is a pointer to the length of the result.</source>
          <target state="translated">&lt;code&gt;ustrp&lt;/code&gt; 是指向转换结果放入的字符缓冲区的指针。 &lt;code&gt;lenp&lt;/code&gt; 是指向结果长度的指针。</target>
        </trans-unit>
        <trans-unit id="8bd04fa099b83f91457c14073be07a2b7a9907c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::encode&lt;/code&gt; is like &lt;code&gt;utf8::upgrade&lt;/code&gt; , but the UTF8 flag is cleared. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more on the UTF8 flag and the C API functions &lt;code&gt;sv_utf8_upgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; , &lt;code&gt;sv_utf8_encode&lt;/code&gt; , and &lt;code&gt;sv_utf8_decode&lt;/code&gt; , which are wrapped by the Perl functions &lt;code&gt;utf8::upgrade&lt;/code&gt; , &lt;code&gt;utf8::downgrade&lt;/code&gt; , &lt;code&gt;utf8::encode&lt;/code&gt; and &lt;code&gt;utf8::decode&lt;/code&gt; . Also, the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode, utf8::upgrade, and utf8::downgrade are actually internal, and thus always available, without a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; utf8&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;utf8::encode&lt;/code&gt; 类似于 &lt;code&gt;utf8::upgrade&lt;/code&gt; ，但已清除UTF8标志。见&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;更多的UTF8标志和C API函数 &lt;code&gt;sv_utf8_upgrade&lt;/code&gt; ， &lt;code&gt;sv_utf8_downgrade&lt;/code&gt; ， &lt;code&gt;sv_utf8_encode&lt;/code&gt; 和 &lt;code&gt;sv_utf8_decode&lt;/code&gt; ，其由Perl函数包裹 &lt;code&gt;utf8::upgrade&lt;/code&gt; ， &lt;code&gt;utf8::downgrade&lt;/code&gt; ， &lt;code&gt;utf8::encode&lt;/code&gt; 和 &lt;code&gt;utf8::decode&lt;/code&gt; 。同样，函数utf8 :: is_utf8，utf8 :: valid，utf8 :: encode，utf8 :: decode，utf8 :: upgrade和utf8 :: downgrade实际上是内部的，因此始终可用，而 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; utf8&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="314672849dfbf9b9ebb5a47602618e0588d51913" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::encode&lt;/code&gt; is like &lt;code&gt;utf8::upgrade&lt;/code&gt;, but the UTF8 flag is cleared. See &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and the C API functions &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_upgrade&quot;&gt;sv_utf8_upgrade&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_downgrade&quot;&gt;&quot;sv_utf8_downgrade&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_encode&quot;&gt;&quot;sv_utf8_encode&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;perlapi#sv_utf8_decode&quot;&gt;&quot;sv_utf8_decode&quot; in perlapi&lt;/a&gt;&lt;/code&gt;, which are wrapped by the Perl functions &lt;code&gt;utf8::upgrade&lt;/code&gt;, &lt;code&gt;utf8::downgrade&lt;/code&gt;, &lt;code&gt;utf8::encode&lt;/code&gt; and &lt;code&gt;utf8::decode&lt;/code&gt;. Also, the functions &lt;code&gt;utf8::is_utf8&lt;/code&gt;, &lt;code&gt;utf8::valid&lt;/code&gt;, &lt;code&gt;utf8::encode&lt;/code&gt;, &lt;code&gt;utf8::decode&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt;, and &lt;code&gt;utf8::downgrade&lt;/code&gt; are actually internal, and thus always available, without a &lt;code&gt;require utf8&lt;/code&gt; statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0f365565ea0f61a34ffea2e594515494b47b89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; 和 &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="322d02f8ccba9a276f3a31a9c308a4604cffd341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; is used so that the Perl code is portable to EBCDIC platforms. You can omit it if you're</source>
          <target state="translated">&lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; ，以便Perl代码可移植到EBCDIC平台。您可以忽略它</target>
        </trans-unit>
        <trans-unit id="bed6a550355dcf622a3f0f64161c1780b07934df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; controls whether the JSON text created by &lt;code&gt;encode&lt;/code&gt; (and expected by &lt;code&gt;decode&lt;/code&gt;) is UTF-8 encoded or not, while &lt;code&gt;latin1&lt;/code&gt; and &lt;code&gt;ascii&lt;/code&gt; only control whether &lt;code&gt;encode&lt;/code&gt; escapes character values outside their respective codeset range. Neither of these flags conflict with each other, although some combinations make less sense than others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b33702a1264871bd0f65d056d75eef0c8add3f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; flag disabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2347ffa560fd355d58edc7dc62ab06f88d3e71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;utf8&lt;/code&gt; flag enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2ca2030a09ee21c736f85339947d800c4bc9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; is the scalar value to store for this key. &lt;code&gt;value&lt;/code&gt; is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the &lt;code&gt;refcounted_he&lt;/code&gt;. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings. &lt;code&gt;value&lt;/code&gt; may be either null or &lt;code&gt;&amp;amp;PL_sv_placeholder&lt;/code&gt; to indicate that no value is to be associated with the key; this, as with any non-null value, takes precedence over the existence of a value for the key further along the chain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8887e9f6da99c9e54f474e1c8e4528efba33e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; is the scalar value to store for this key. &lt;code&gt;value&lt;/code&gt; is copied by this function, which thus does not take ownership of any reference to it, and later changes to the scalar will not be reflected in the value visible in the cop hints hash. Complex types of scalar will not be stored with referential integrity, but will be coerced to strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2456e01d09f8a12420ae40af42332b053f7c264a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vec&lt;/code&gt; views its string argument as a sequence of bits. A string containing a code point over 0xFF is nonsensical. This usage is deprecated in Perl 5.28, and was removed in Perl 5.32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cfd635c57ecac1d51dc11cad357b4c3a79fac0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;verify_SSL&lt;/code&gt; &amp;mdash; A boolean that indicates whether to validate the SSL certificate of an &lt;code&gt;https&lt;/code&gt; &amp;mdash; connection (default is false)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f01183b1a1f7dd216a740e1f42d689e51a1b7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;version&lt;/code&gt; -- Indicates the desired specification version (e.g. &quot;1.0&quot;, &quot;1.1&quot; ... &quot;1.4&quot;, &quot;2&quot;). Defaults to the latest version of the CPAN Meta Spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4becaf3941402b9ca744e200b8de0784426b345e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vmsify&lt;/code&gt; on the resulting file specification may not result in the original VMS file specification, so programs should not plan to convert a file specification from VMS to Unix and then back to VMS again after modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11ec83e2e9ef7c3f580ec8c19b91c726b07fd6f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; . This practice is now deprecated, and may be not supported at some future version. Use the return value &lt;code&gt;SV *&lt;/code&gt; in such cases. (Currently &lt;code&gt;xsubpp&lt;/code&gt; contains some heuristic code which tries to disambiguate between &quot;truly-void&quot; and &quot;old-practice-declared-as-void&quot; functions. Hence your code is at mercy of this heuristics unless you use &lt;code&gt;SV *&lt;/code&gt; as return value.)</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 。现在已弃用此做法，将来的某些版本可能不支持此做法。在这种情况下，请使用返回值 &lt;code&gt;SV *&lt;/code&gt; 。（当前， &lt;code&gt;xsubpp&lt;/code&gt; 包含一些启发式代码，这些代码试图在&amp;ldquo;真正无效&amp;rdquo;和&amp;ldquo;老实践声明为无效&amp;rdquo;函数之间进行歧义。因此，除非您使用 &lt;code&gt;SV *&lt;/code&gt; 作为返回值，否则您的代码将受此启发式的影响。）</target>
        </trans-unit>
        <trans-unit id="1d1d1a26482e5914160e7c9dae08ae2ac89d54e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;. This practice is now deprecated, and may be not supported at some future version. Use the return value &lt;code&gt;SV *&lt;/code&gt; in such cases. (Currently &lt;code&gt;xsubpp&lt;/code&gt; contains some heuristic code which tries to disambiguate between &quot;truly-void&quot; and &quot;old-practice-declared-as-void&quot; functions. Hence your code is at mercy of this heuristics unless you use &lt;code&gt;SV *&lt;/code&gt; as return value.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a6c93919cd34815869f280cd8b84f1065ac630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;warn()&lt;/code&gt; or &lt;code&gt;carp()&lt;/code&gt; a message to STDERR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b4bda69ddbb085c5edb8604f61fe1eebd17ca61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;what&lt;/code&gt; and &lt;code&gt;op_name&lt;/code&gt; are used in any warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e091f4a7021829a7a3620da2c2a10b4eed1eec79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while&lt;/code&gt; repeats the statement</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 重复该语句时</target>
        </trans-unit>
        <trans-unit id="906db552d87a0ee4629c6f29180b89745fa23b64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;win32_perlio&lt;/code&gt; - allows the use of the :win32 IO layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ccd06f1dd27edc527ebd4684db2ea14ab08f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrap()&lt;/code&gt; compresses trailing whitespace into one newline, and &lt;code&gt;fill()&lt;/code&gt; deletes all trailing whitespace.</source>
          <target state="translated">&lt;code&gt;wrap()&lt;/code&gt; 将尾随的空白压缩到一个换行符，而 &lt;code&gt;fill()&lt;/code&gt; 删除所有尾随的空白。</target>
        </trans-unit>
        <trans-unit id="3ec46baadad1061a82a3fe84c7b3bdcb20c88b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;wrapped&lt;/code&gt;&lt;code&gt;wraplen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf9f7426eb12c72cfe1066d3cb1703d1a365da78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;writemain()&lt;/code&gt; takes an argument list of directories containing archive libraries that relate to perl modules and should be linked into a new perl binary. It writes a corresponding</source>
          <target state="translated">&lt;code&gt;writemain()&lt;/code&gt; 接受目录的参数列表，该目录包含与perl模块相关的存档库，应链接到新的perl二进制文件中。它写了一个对应的</target>
        </trans-unit>
        <trans-unit id="a72e7abf95992836126047e9bceb660c62707d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;writemain()&lt;/code&gt; takes an argument list of zero or more directories containing archive libraries that relate to perl modules and should be linked into a new perl binary. It writes a corresponding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4899d555a14c4548680da3fdcd57d8b2f3cbfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to act as alignment commands: they jump forward or back to the closest position aligned at a multiple of &lt;code&gt;count&lt;/code&gt; characters. For example, to &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; a C structure like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1585b59da49174f182f412bb70b4355173d36595" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; accept the &lt;code&gt;!&lt;/code&gt; modifier to act as alignment commands: they jump forward or back to the closest position aligned at a multiple of &lt;code&gt;count&lt;/code&gt; characters. For example, to pack() or unpack() a C structure like</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 接受 &lt;code&gt;!&lt;/code&gt; 修饰符，用作对齐命令：它们向前或向后跳转到以多个 &lt;code&gt;count&lt;/code&gt; 字符对齐的最近位置。例如，要打包（）或解包（）一个C结构，例如</target>
        </trans-unit>
        <trans-unit id="7e4cad6d660d7f4a7c0baea9ffb828f6306a6484" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means &quot;skip a byte&quot; when &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;ing; when &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing, it means &quot;introduce a null byte&quot; - that's probably not what you mean if you're dealing with plain text.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 表示 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 时&amp;ldquo;跳过一个字节&amp;rdquo; ；当 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 荷兰国际集团，它的意思是&amp;ldquo;引进一个空字节&amp;rdquo; -这可能不是你的意思是，如果你正在处理的纯文本。</target>
        </trans-unit>
        <trans-unit id="1949a962fd727fc6380668963f686ebb3a36d981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; means &quot;skip a byte&quot; when &lt;code&gt;unpack&lt;/code&gt;ing; when &lt;code&gt;pack&lt;/code&gt;ing, it means &quot;introduce a null byte&quot; - that's probably not what you mean if you're dealing with plain text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1dc3716ea8b4a3c4500628aaf4e0c7696cd52fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsinit()&lt;/code&gt; uses the xsi_* functions to generate most of its code.</source>
          <target state="translated">&lt;code&gt;xsinit()&lt;/code&gt; 使用xsi_ *函数生成其大部分代码。</target>
        </trans-unit>
        <trans-unit id="128b946d69152a1f151c55bf6ce61c0c49ec7ac8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xsubpp&lt;/code&gt; variables and internal functions</source>
          <target state="translated">&lt;code&gt;xsubpp&lt;/code&gt; 变量和内部函数</target>
        </trans-unit>
        <trans-unit id="c0a014552c003a1e76f63cc934b125b95e0ed6d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yyparse&lt;/code&gt; , the parser, lives in</source>
          <target state="translated">&lt;code&gt;yyparse&lt;/code&gt; 解析器yyparse居住在</target>
        </trans-unit>
        <trans-unit id="e1bd2c7f4ad0b95dac90b8f9dccee5e2723b0111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yyparse&lt;/code&gt;, the parser, lives in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86a8316320772d083e312e9c2712b98b8a990576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 需要至少两个参数 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 和 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53fde9627e4f5d3ddafe17173f4ac0adc9d93ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;zip&lt;/code&gt; expects at least two parameters, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; and zero or more optional parameters (see &lt;a href=&quot;#Optional-Parameters&quot;&gt;&quot;Optional Parameters&quot;&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa9997ee07cb992ab27678e726038881ca04b2d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; starts both hash references and blocks, so &lt;code&gt;map { ...&lt;/code&gt; could be either the start of map BLOCK LIST or map EXPR, LIST. Because Perl doesn't look ahead for the closing &lt;code&gt;}&lt;/code&gt; it has to take a guess at which it's dealing with based on what it finds just after the &lt;code&gt;{&lt;/code&gt;. Usually it gets it right, but if it doesn't it won't realize something is wrong until it gets to the &lt;code&gt;}&lt;/code&gt; and encounters the missing (or unexpected) comma. The syntax error will be reported close to the &lt;code&gt;}&lt;/code&gt;, but you'll need to change something near the &lt;code&gt;{&lt;/code&gt; such as using a unary &lt;code&gt;+&lt;/code&gt; or semicolon to give Perl some help:</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; 会同时启动哈希引用和块，因此 &lt;code&gt;map { ...&lt;/code&gt; 可以是map BLOCK LIST或map EXPR，LIST的开始。因为Perl并没有期待结束 &lt;code&gt;}&lt;/code&gt; ,所以必须根据 &lt;code&gt;{&lt;/code&gt; 之后的发现来猜测它要处理的内容。通常情况下，它正确无误，但如果不正确，直到到达 &lt;code&gt;}&lt;/code&gt; 并遇到缺失（或意外）逗号时，它才会意识到出了问题。语法错误将在 &lt;code&gt;}&lt;/code&gt; 附近报告，但您需要在 &lt;code&gt;{&lt;/code&gt; 附近进行更改，例如使用一元 &lt;code&gt;+&lt;/code&gt; 或分号为Perl提供帮助：</target>
        </trans-unit>
        <trans-unit id="0cd290126c35f35fc479ffe56d6b6254d337e17d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;}&lt;/code&gt;, then Perl uses the translations of</source>
          <target state="translated">&lt;code&gt;}&lt;/code&gt; ，然后Perl使用以下语言的翻译</target>
        </trans-unit>
        <trans-unit id="21606782c65e44cac7afbb90977d8b6f82140e76" translate="yes" xml:space="preserve">
          <source>=</source>
          <target state="translated">=</target>
        </trans-unit>
        <trans-unit id="6094cc9ff960a73a386684d75df1b2bb88685e24" translate="yes" xml:space="preserve">
          <source>= -1, something interesting happens when it encounters an invalid character.</source>
          <target state="translated">= -1，遇到无效字符时会发生一些有趣的事情。</target>
        </trans-unit>
        <trans-unit id="95c890966f60daadce1620989a28ff084f43d99b" translate="yes" xml:space="preserve">
          <source>= 1. When</source>
          <target state="translated">= 1.何时</target>
        </trans-unit>
        <trans-unit id="10deb21dfe010a9b190b8fab61389604b35082cd" translate="yes" xml:space="preserve">
          <source>= Encode::FB_HTMLCREF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e18d4d666804ece9ce8365c94263f7a8e5f6c98" translate="yes" xml:space="preserve">
          <source>= Encode::FB_PERLQQ)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb3d0f118188166d4957f38ffdec132d7c720d9" translate="yes" xml:space="preserve">
          <source>= Encode::FB_XMLCREF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce244797a5393c0d083ac5c5cd677ded6dd73fb4" translate="yes" xml:space="preserve">
          <source>= [alias value]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaa5194c11bd01ab12e097ce99731d72f37c02c6" translate="yes" xml:space="preserve">
          <source>== 1.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ebfe1c30e34e4f20325b1f93f5044c1926e1ed" translate="yes" xml:space="preserve">
          <source>=back doesn't take any parameters, but you said =back</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3812f8c5ebf6f7d3279508d78200275c68d4125d" translate="yes" xml:space="preserve">
          <source>=back without =over</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7b65cb3ebd5ea6ad9a8426f1b32e5a4f6d3d3f" translate="yes" xml:space="preserve">
          <source>=begin</source>
          <target state="translated">=begin</target>
        </trans-unit>
        <trans-unit id="4d79569dbfe21a79189226f4869b7ea13a4ee892" translate="yes" xml:space="preserve">
          <source>=begin without a target?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525cfb869c22e44fe640e7deffdfbcf3a81ac5a5" translate="yes" xml:space="preserve">
          <source>=cut found outside a pod block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f96a5fee4cc895a4f10ae462b41be3e191aa8a" translate="yes" xml:space="preserve">
          <source>=end</source>
          <target state="translated">=end</target>
        </trans-unit>
        <trans-unit id="a9247d8da17206c58d355978136b2d317b17f236" translate="yes" xml:space="preserve">
          <source>=for without a target?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a39a2fe941bc076bdccd939ab48a37eae4767c" translate="yes" xml:space="preserve">
          <source>=head</source>
          <target state="translated">=head</target>
        </trans-unit>
        <trans-unit id="0e4b392e21d1de949bac9b0aee0a7c137af80689" translate="yes" xml:space="preserve">
          <source>=item has no contents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f531fb2fa54f44cc2ce6bd625537e0c6da8e2acb" translate="yes" xml:space="preserve">
          <source>=over is the last thing in the document?!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bb543dbcda97babdf2a89c6106c60ddb02fc24" translate="yes" xml:space="preserve">
          <source>=over on line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="240bb3121b98782679e3097abdefad1a5776163f" translate="yes" xml:space="preserve">
          <source>=over should be: '=over' or '=over positive_number'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5deab936208074df56367974c408aedaeeae3ccb" translate="yes" xml:space="preserve">
          <source>=pod directives shouldn't be over one line long! Ignoring all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dd648593099ecae45709a4626d725e1810fbd4b" translate="yes" xml:space="preserve">
          <source>?....?= . The parts that RFC 2047 forbids to encode are left as is and long lines are folded within 76 bytes per line.</source>
          <target state="translated">？....？= RFC 2047禁止编码的部分保持原样，并且长行被折叠为每行76个字节。</target>
        </trans-unit>
        <trans-unit id="d1366a3067fee46eb14eef8f2f316e5f38df3c4f" translate="yes" xml:space="preserve">
          <source>?:\JUST_ADD\view.exe</source>
          <target state="translated">?:\JUST_ADD\view.exe</target>
        </trans-unit>
        <trans-unit id="b79900189f259297171d1e45127a682acacd788e" translate="yes" xml:space="preserve">
          <source>?=),</source>
          <target state="translated">?=),</target>
        </trans-unit>
        <trans-unit id="b2bb6d4e8459b319a09e5016032a5674f0a79ce5" translate="yes" xml:space="preserve">
          <source>?pattern?</source>
          <target state="translated">?pattern?</target>
        </trans-unit>
        <trans-unit id="4975709a996fa9b7e1ddb66e5180bce67c8d47ae" translate="yes" xml:space="preserve">
          <source>@+</source>
          <target state="translated">@+</target>
        </trans-unit>
        <trans-unit id="ce4580a08b328e135e8ec88a9d66dd4a93b8a8e8" translate="yes" xml:space="preserve">
          <source>@-</source>
          <target state="translated">@-</target>
        </trans-unit>
        <trans-unit id="754891735fac8c3066a07c36d22a346ee1c40ce8" translate="yes" xml:space="preserve">
          <source>@ARG</source>
          <target state="translated">@ARG</target>
        </trans-unit>
        <trans-unit id="ff2c17be6bd781f95fdd0bd9610749034c81b62d" translate="yes" xml:space="preserve">
          <source>@ARGS</source>
          <target state="translated">@ARGS</target>
        </trans-unit>
        <trans-unit id="1fe7c7755c50a190c523c3b1fcb23fe7a59fb1d9" translate="yes" xml:space="preserve">
          <source>@ARGV</source>
          <target state="translated">@ARGV</target>
        </trans-unit>
        <trans-unit id="f9dae5e61c647f83e0f197da0f3c40b160b62b37" translate="yes" xml:space="preserve">
          <source>@CARP_NOT</source>
          <target state="translated">@CARP_NOT</target>
        </trans-unit>
        <trans-unit id="ad2f81672f5d55e6e410552c159a1082a8356487" translate="yes" xml:space="preserve">
          <source>@DB::args</source>
          <target state="translated">@DB::args</target>
        </trans-unit>
        <trans-unit id="e0df44f8992230085a70d4f0818bc9554a496358" translate="yes" xml:space="preserve">
          <source>@DB::dbline</source>
          <target state="translated">@DB::dbline</target>
        </trans-unit>
        <trans-unit id="d2679734ab2cc1a1383b43572c627a2a4a786046" translate="yes" xml:space="preserve">
          <source>@EXPORT</source>
          <target state="translated">@EXPORT</target>
        </trans-unit>
        <trans-unit id="935219ed0644ee8e535456d71cde263f06c07d6f" translate="yes" xml:space="preserve">
          <source>@F</source>
          <target state="translated">@F</target>
        </trans-unit>
        <trans-unit id="39bf41a4cd083c6ae641220a6f38628a92b8c395" translate="yes" xml:space="preserve">
          <source>@INC</source>
          <target state="translated">@INC</target>
        </trans-unit>
        <trans-unit id="aea913a438cedea020e13eccaab58993130508dc" translate="yes" xml:space="preserve">
          <source>@ISA</source>
          <target state="translated">@ISA</target>
        </trans-unit>
        <trans-unit id="86e1dd598d092bf5b80c27bd2b6ae9c16e5e0c7d" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_END</source>
          <target state="translated">@LAST_MATCH_END</target>
        </trans-unit>
        <trans-unit id="f583b3cef6a6f01f053f249151fd446d413e0372" translate="yes" xml:space="preserve">
          <source>@LAST_MATCH_START</source>
          <target state="translated">@LAST_MATCH_START</target>
        </trans-unit>
        <trans-unit id="8ad7a99208be11331312728e281eba7694f68521" translate="yes" xml:space="preserve">
          <source>@Type_Order</source>
          <target state="translated">@Type_Order</target>
        </trans-unit>
        <trans-unit id="dee27aa9c706f064e962a3f3512b8abd08138be2" translate="yes" xml:space="preserve">
          <source>@_</source>
          <target state="translated">@_</target>
        </trans-unit>
        <trans-unit id="42d68da353f4ee79e3d0efb49913bbbc2bfb30e2" translate="yes" xml:space="preserve">
          <source>@a is an array with three elements, and each one is a reference to another array.</source>
          <target state="translated">@a是一个包含三个元素的数组，每个元素都是对另一个数组的引用。</target>
        </trans-unit>
        <trans-unit id="adf32768466829ecfdd11f5e83805fb15ad821b6" translate="yes" xml:space="preserve">
          <source>@bool_or_empty = $e-&amp;gt;global</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aaaa33622fe7cf15aa704511ebf7554d9e1555" translate="yes" xml:space="preserve">
          <source>@classes = $e-&amp;gt;FACET_TYPES()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a86fc8bd3666cc1290cb0c02f063d0f0c5d455" translate="yes" xml:space="preserve">
          <source>@classes = Test2::Event-&amp;gt;FACET_TYPES()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9827d0a65193417d4fa8b6a9aa912ea1f04e305" translate="yes" xml:space="preserve">
          <source>@ctx = $md5-&amp;gt;context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b77365339fd60f4f7b9dc5e67d7bc301973ddce" translate="yes" xml:space="preserve">
          <source>@dl_library_path</source>
          <target state="translated">@dl_library_path</target>
        </trans-unit>
        <trans-unit id="0b43abc97824c06b15af6b73f75f3917997f9c60" translate="yes" xml:space="preserve">
          <source>@dl_library_path is initialised to hold the list of 'normal' directories (</source>
          <target state="translated">@dl_library_path初始化为包含&amp;ldquo;普通&amp;rdquo;目录的列表（</target>
        </trans-unit>
        <trans-unit id="9f0e33f7f6545d4dff610e53e6f0b71945335437" translate="yes" xml:space="preserve">
          <source>@dl_library_path should also be initialised with any other directories that can be determined from the environment at runtime (such as LD_LIBRARY_PATH for SunOS).</source>
          <target state="translated">@dl_library_path也应该使用在运行时可以从环境中确定的任何其他目录（例如，SunOS的LD_LIBRARY_PATH）进行初始化。</target>
        </trans-unit>
        <trans-unit id="daf7b1b2d89fc478ca04c0a7e85ecc11fb240ad7" translate="yes" xml:space="preserve">
          <source>@dl_librefs</source>
          <target state="translated">@dl_librefs</target>
        </trans-unit>
        <trans-unit id="15a8f1a478c081e49040591f8d8a7f42c88ac449" translate="yes" xml:space="preserve">
          <source>@dl_modules</source>
          <target state="translated">@dl_modules</target>
        </trans-unit>
        <trans-unit id="437544024eb7d70c6f42757950b2a94cd83916e2" translate="yes" xml:space="preserve">
          <source>@dl_require_symbols</source>
          <target state="translated">@dl_require_symbols</target>
        </trans-unit>
        <trans-unit id="45769939e624f551921b77e0dca5fb8dcb247e29" translate="yes" xml:space="preserve">
          <source>@dl_resolve_using</source>
          <target state="translated">@dl_resolve_using</target>
        </trans-unit>
        <trans-unit id="f8106890b4ff0b0b473007492009d3c775e7220f" translate="yes" xml:space="preserve">
          <source>@dl_shared_objects</source>
          <target state="translated">@dl_shared_objects</target>
        </trans-unit>
        <trans-unit id="749a8fa7c771df5d761814a312cd22538deb3176" translate="yes" xml:space="preserve">
          <source>@drivers = test2_ipc_drivers()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb768ba2f4343df04d65b54e1e44a3adc7c75128" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data(%params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2403555a23c2936510d043a0b009358f7d5bafa3" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data();</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c99e5f673dab141d07b5c87f1e12b763a22b7a7" translate="yes" xml:space="preserve">
          <source>@errors = $e-&amp;gt;validate_facet_data(\%facets, %params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d30f6e44aeb339351d84ebd7b1884475b877654" translate="yes" xml:space="preserve">
          <source>@errors = Test2::Event-&amp;gt;validate_facet_data(%params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eac66c830b57faa08b90a583c5a9254e21460d" translate="yes" xml:space="preserve">
          <source>@errors = Test2::Event-&amp;gt;validate_facet_data(\%facets, %params);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55dd52d8b6eddbc15cc8f30ba9623fcc805828c" translate="yes" xml:space="preserve">
          <source>@events = $ipc-&amp;gt;cull($hid)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8084a2ae39ff7cb9d811f1712dc1602a663ee9e4" translate="yes" xml:space="preserve">
          <source>@formatters = test2_formatters()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c4bdd65f5d5393c4b65063b2f6d490d0ed9481" translate="yes" xml:space="preserve">
          <source>@hubs = $stack-&amp;gt;all</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e174ab278b42b42f4292927ee5370df64f9370" translate="yes" xml:space="preserve">
          <source>@int_or_empty = $e-&amp;gt;terminate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13ba7c337ace12468d7413245c28893a95eaa72" translate="yes" xml:space="preserve">
          <source>@list = $class-&amp;gt;Test2::Util::HashBase::attr_list()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15e60d5d52bb406bfa3ad86f61d6ecec4e535528" translate="yes" xml:space="preserve">
          <source>@list = Test2::Util::HashBase::attr_list($class)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50e636a2b33daee08498b2ec237c8cf65cae7cb" translate="yes" xml:space="preserve">
          <source>@list = requires( MODULE );</source>
          <target state="translated">@list = require（MODULE）;</target>
        </trans-unit>
        <trans-unit id="0b0562e456636b39bfe73900954fa1570225ecc1" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_acquire_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a17cd013fc295d9e892c7cc1b5b85f22fc71e42a" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_init_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a572837e26cb97b7ebbd08a4152e27c673ddc55d" translate="yes" xml:space="preserve">
          <source>@list = test2_list_context_release_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9240e5c70594cb2051ed4f4f418585863cd7d0" translate="yes" xml:space="preserve">
          <source>@list = test2_list_exit_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a67aa2e57876f6c06b83b6205d552dc9dbe3c942" translate="yes" xml:space="preserve">
          <source>@list = test2_list_post_load_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b630c5fabe7c03aee28faeca7dbc849609efe5de" translate="yes" xml:space="preserve">
          <source>@list = test2_list_pre_subtest_callbacks()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea639b29e92b8ed3a63688b25f32407745db27b0" translate="yes" xml:space="preserve">
          <source>@optype</source>
          <target state="translated">@optype</target>
        </trans-unit>
        <trans-unit id="2b5fee7ea42b8b01c834815b53c906e15aa53eaf" translate="yes" xml:space="preserve">
          <source>@os_flavor is the style of operating system this is, usually corresponding to the MM_*.pm file we're using.</source>
          <target state="translated">@os_flavor是这种操作系统的样式，通常对应于我们正在使用的MM _ *。pm文件。</target>
        </trans-unit>
        <trans-unit id="afb0f810173e11fd936bc2500d009de431bffbf7" translate="yes" xml:space="preserve">
          <source>@plan = $e-&amp;gt;sets_plan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c8ab27f10d0374b95344a707e26226f7fa18c" translate="yes" xml:space="preserve">
          <source>@results is an array of test result hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ad7cdc98082f9250ec3afd4e2caed14f583e94" translate="yes" xml:space="preserve">
          <source>@specialsv_name</source>
          <target state="translated">@specialsv_name</target>
        </trans-unit>
        <trans-unit id="bce99a33d22d4c2dffd2eeac8a8e4c5d9894b283" translate="yes" xml:space="preserve">
          <source>@suffixes work as in &lt;code&gt;fileparse()&lt;/code&gt; except all regex metacharacters are quoted.</source>
          <target state="translated">@后缀的工作方式与 &lt;code&gt;fileparse()&lt;/code&gt; 相同，只是所有正则表达式元字符都被引用了。</target>
        </trans-unit>
        <trans-unit id="317b12ea1477d9e9b136839fa7ac896988adc6ac" translate="yes" xml:space="preserve">
          <source>@test_files</source>
          <target state="translated">@test_files</target>
        </trans-unit>
        <trans-unit id="2563b52b2c674ef6e847cc65202d47f3d3604f00" translate="yes" xml:space="preserve">
          <source>@test_libs are run in alphabetical order.</source>
          <target state="translated">@test_libs按字母顺序运行。</target>
        </trans-unit>
        <trans-unit id="33c41cdd560e2632c4cb6a1fb1bf4b8576d6aa71" translate="yes" xml:space="preserve">
          <source>@{^CAPTURE}</source>
          <target state="translated">@{^CAPTURE}</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="313a7fe99a568a50c330c2db6c46b2f1743f3e95" translate="yes" xml:space="preserve">
          <source>A &quot;balanced-bracket-delimited substring&quot; is a substring bounded by matched brackets, such that any other (left or right) delimiter bracket</source>
          <target state="translated">一个 &quot;平衡括号分隔的子串 &quot;是一个由匹配的括号限定的子串,这样任何其他(左或右)定界符括号</target>
        </trans-unit>
        <trans-unit id="f251b2b1824e87d1320c2c41c33a42711d82807a" translate="yes" xml:space="preserve">
          <source>A &quot;delimiter bracket&quot; is a bracket in list of delimiters passed as &lt;code&gt;extract_bracketed&lt;/code&gt; 's second argument. Delimiter brackets are specified by giving either the left or right (or both!) versions of the required bracket(s). Note that the order in which two or more delimiter brackets are specified is not significant.</source>
          <target state="translated">&amp;ldquo;定界符括号&amp;rdquo;是作为 &lt;code&gt;extract_bracketed&lt;/code&gt; 的第二个参数传递的定界符列表中的括号。通过给出所需括号的左或右（或两者！）版本来指定定界括号。请注意，指定两个或多个定界括号的顺序并不重要。</target>
        </trans-unit>
        <trans-unit id="526fbc5865ea8795168a507fd915095cce0c32be" translate="yes" xml:space="preserve">
          <source>A &quot;delimiter bracket&quot; is a bracket in list of delimiters passed as &lt;code&gt;extract_bracketed&lt;/code&gt;'s second argument. Delimiter brackets are specified by giving either the left or right (or both!) versions of the required bracket(s). Note that the order in which two or more delimiter brackets are specified is not significant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe875008ceb9916a221027985bdd7156792bab2e" translate="yes" xml:space="preserve">
          <source>A &quot;drive&quot; that does not have a file system. This can be a drive letter that hasn't been defined or a drive letter assigned to a partition that hasn't been formatted yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2d100a2729032ea387e666018839a1da0e8c93" translate="yes" xml:space="preserve">
          <source>A &quot;layer&quot; is composed of two parts:</source>
          <target state="translated">一个 &quot;层 &quot;由两部分组成。</target>
        </trans-unit>
        <trans-unit id="756b059631bfde6d82f3c717b79716728efe722a" translate="yes" xml:space="preserve">
          <source>A &quot;macro&quot; 1 signals that the constant is always defined, so the &lt;code&gt;#if&lt;/code&gt; /&lt;code&gt;#endif&lt;/code&gt; test is omitted.</source>
          <target state="translated">&amp;ldquo;宏&amp;rdquo; 1表示始终定义该常数，因此省略了 &lt;code&gt;#if&lt;/code&gt; / &lt;code&gt;#endif&lt;/code&gt; 测试。</target>
        </trans-unit>
        <trans-unit id="93bdc8ebabd9b8481383b7e876c2d37c090ff594" translate="yes" xml:space="preserve">
          <source>A &quot;macro&quot; 1 signals that the constant is always defined, so the &lt;code&gt;#if&lt;/code&gt;/&lt;code&gt;#endif&lt;/code&gt; test is omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb023ba582a7a015faea89ec15dc62641da6a16" translate="yes" xml:space="preserve">
          <source>A &quot;picture&quot; line giving the format for one output line.</source>
          <target state="translated">一个 &quot;图片 &quot;行,给出一个输出行的格式。</target>
        </trans-unit>
        <trans-unit id="15236a61eccb3430b3222ecc1658fa660d7fb563" translate="yes" xml:space="preserve">
          <source>A &quot;ram disk&quot; or memory-resident virtual file system used for high-speed access to small amounts of temporary file space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc2e7f2e34238799324926fcafe5bd02066c9e0" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;constructor&amp;rdquo; for a &lt;b&gt;referent&lt;/b&gt; that isn&amp;rsquo;t really an &lt;b&gt;object&lt;/b&gt;, like an anonymous array or a hash (or a sonata, for that matter). For example, a pair of braces acts as a composer for a hash, and a pair of brackets acts as a composer for an array. See the section &amp;ldquo;Creating References&amp;rdquo; in Camel chapter 8, &amp;ldquo;References&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;引用对象的&lt;/b&gt; &amp;ldquo;构造函数&amp;rdquo; 实际上不是&lt;b&gt;对象&lt;/b&gt;，例如匿名数组或哈希（就此而言，奏鸣曲）。例如，一对大括号充当哈希的编写器，而一对括号充当数组的编写器。请参阅骆驼第8章&amp;ldquo;参考&amp;rdquo;中的&amp;ldquo;创建参考&amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="5775eb71cdc3ede48fee03da70ab6b5ce985e619" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;page&amp;rdquo; from the manuals, typically accessed via the</source>
          <target state="translated">手册中的&amp;ldquo;页面&amp;rdquo;，通常可通过</target>
        </trans-unit>
        <trans-unit id="6a5409d36bd9ef539cfe14ba7c067e7ccfc9c3b3" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;pointer value&amp;rdquo;, which is Perl Internals Talk for a &lt;code&gt;char*&lt;/code&gt; .</source>
          <target state="translated">一个&amp;ldquo;指针值&amp;rdquo;，它是Perl Internals Talk中的一个 &lt;code&gt;char*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef91c8339eba64aba8bfb16207fcf550f326e17c" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;pointer value&amp;rdquo;, which is Perl Internals Talk for a &lt;code&gt;char*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a072b3ed907a60cfcde96be105ecbc6bbfc2bd" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;version&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; &lt;b&gt;string&lt;/b&gt; specified with a &lt;code&gt;v&lt;/code&gt; followed by a series of decimal integers in dot notation, for instance, &lt;code&gt;v1.20.300.4000&lt;/code&gt; . Each number turns into a &lt;b&gt;character&lt;/b&gt; with the specified ordinal value. (The &lt;code&gt;v&lt;/code&gt; is optional when there are at least three integers.)</source>
          <target state="translated">用 &lt;code&gt;v&lt;/code&gt; 指定的&amp;ldquo;版本&amp;rdquo;或&amp;ldquo;向量&amp;rdquo; &lt;b&gt;字符串&lt;/b&gt;，后跟一系列点表示形式的十进制整数，例如 &lt;code&gt;v1.20.300.4000&lt;/code&gt; 。每个数字都会变成具有指定序数值的&lt;b&gt;字符&lt;/b&gt;。（当至少有三个整数时， &lt;code&gt;v&lt;/code&gt; 是可选的。）&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f44fbc3181b1ca1a0035e4d075bfe5736c6c89a4" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;version&amp;rdquo; or &amp;ldquo;vector&amp;rdquo; &lt;b&gt;string&lt;/b&gt; specified with a &lt;code&gt;v&lt;/code&gt; followed by a series of decimal integers in dot notation, for instance, &lt;code&gt;v1.20.300.4000&lt;/code&gt;. Each number turns into a &lt;b&gt;character&lt;/b&gt; with the specified ordinal value. (The &lt;code&gt;v&lt;/code&gt; is optional when there are at least three integers.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b175ccd55b8cb24fce37d2a53ada08e5f179945" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;wildcard&amp;rdquo; match on &lt;b&gt;filenames&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">&lt;b&gt;文件名&lt;/b&gt;上的&amp;ldquo;通配符&amp;rdquo;匹配。请参阅 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="0f35ef12127d73c5a356b6b9c82b522f5ce5d165" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;wildcard&amp;rdquo; match on &lt;b&gt;filenames&lt;/b&gt;. See the &lt;code&gt;glob&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785d257f2e5d0030320c5f3a55e4dd08614b8fda" translate="yes" xml:space="preserve">
          <source>A '=cut' directive found in the middle of non-POD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084adee5c9094841f2603af0ff0ac058d61aaa79" translate="yes" xml:space="preserve">
          <source>A 'my $pack_lexical' statement makes the variable $pack_lexical local _only_ to the file up to the &lt;code&gt;__DATA__&lt;/code&gt; token. Subroutines declared elsewhere _cannot_ see these types of variables, just as if you declared subroutines in the package but in another file, they cannot see these variables.</source>
          <target state="translated">&amp;ldquo; my $ pack_lexical&amp;rdquo;语句使变量$ pack_lexical local _only_成为文件，直到 &lt;code&gt;__DATA__&lt;/code&gt; 令牌为止。_cannot_在其他地方声明的子例程将看到这些类型的变量，就像您在包中但在另一个文件中声明了子例程一样，它们看不到这些变量。</target>
        </trans-unit>
        <trans-unit id="fd982dc10b95832dad0fd4ffab7cc84fc2034769" translate="yes" xml:space="preserve">
          <source>A (discouraged from use) synonym is &lt;code&gt;isALNUMC&lt;/code&gt; (where the &lt;code&gt;C&lt;/code&gt; suffix means this corresponds to the C language alphanumeric definition). Also there are the variants &lt;code&gt;isALNUMC_A&lt;/code&gt;, &lt;code&gt;isALNUMC_L1&lt;/code&gt;&lt;code&gt;isALNUMC_LC&lt;/code&gt;, and &lt;code&gt;isALNUMC_LC_uvchr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ededfcca2c8bd4e7eb6351a42ed32e72537533cd" translate="yes" xml:space="preserve">
          <source>A (file)glob evaluates its (embedded) argument only when it is starting a new list. All values must be read before it will start over. In list context, this isn't important because you automatically get them all anyway. However, in scalar context the operator returns the next value each time it's called, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the list has run out. As with filehandle reads, an automatic &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; is generated when the glob occurs in the test part of a &lt;code&gt;while&lt;/code&gt; , because legal glob returns (for example, a file called</source>
          <target state="translated">（file）glob仅在开始新列表时才评估其（嵌入式）参数。必须重新读取所有值，然后才能重新开始。在列表上下文中，这并不重要，因为无论如何您都会自动获取它们。但是，在标量上下文中，运算符每次调用时都会返回下一个值，或者在列表用完时返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。与文件句柄读取，自动 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; 时，圆顶封装在一个的测试部分时，将生成 &lt;code&gt;while&lt;/code&gt; ，因为合法的glob返回（例如，称为文件</target>
        </trans-unit>
        <trans-unit id="f613941228a4b2edbfa60c354ef431255d44d42e" translate="yes" xml:space="preserve">
          <source>A (file)glob evaluates its (embedded) argument only when it is starting a new list. All values must be read before it will start over. In list context, this isn't important because you automatically get them all anyway. However, in scalar context the operator returns the next value each time it's called, or &lt;code&gt;undef&lt;/code&gt; when the list has run out. As with filehandle reads, an automatic &lt;code&gt;defined&lt;/code&gt; is generated when the glob occurs in the test part of a &lt;code&gt;while&lt;/code&gt;, because legal glob returns (for example, a file called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc6e3b905b08fc1fe3e1757559d1f8c510fb5e73" translate="yes" xml:space="preserve">
          <source>A (very) lightweight introduction in the use of the perl debugger, and a pointer to existing, deeper sources of information on the subject of debugging perl programs.</source>
          <target state="translated">一个(非常)轻量级的perl调试器使用介绍,以及一个指向现有的、更深入的关于perl程序调试主题的信息源的指针。</target>
        </trans-unit>
        <trans-unit id="4b33de80b0daa04de9d0537f91968aca3441bb5a" translate="yes" xml:space="preserve">
          <source>A *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ac1d8d5b46f4c8322e0f808eeb9e2cdf4d41ab" translate="yes" xml:space="preserve">
          <source>A 64-bit native application will run much more efficiently on Itanium hardware.</source>
          <target state="translated">64位原生应用在Itanium硬件上的运行效率会更高。</target>
        </trans-unit>
        <trans-unit id="3898ac399c4bda023fcfcb7cda3f39d85b95f13a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#my-VARLIST&quot;&gt;&lt;code&gt;my&lt;/code&gt;&lt;/a&gt; declares the listed variables to be local (lexically) to the enclosing block, file, or &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;. If more than one variable is listed, the list must be placed in parentheses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f93189e72cc0f75abc0b3834c32b379484b25ed" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper that has the ability to lock and unlock the database while it is being used. Avoids the tie-before-flock problem by simply re-tie-ing the database when you get or drop a lock. Because of the flexibility in dropping and re-acquiring the lock in the middle of a session, this can be massaged into a system that will work with long updates and/or reads if the application follows the hints in the POD documentation.</source>
          <target state="translated">一个&lt;b&gt;DB_File&lt;/b&gt;包装器，具有在使用时锁定和解锁数据库的功能。通过在获得或释放锁时简单地重新绑定数据库，避免了先行绑定问题。由于在会话中间可以灵活地删除和重新获取锁，因此，如果应用程序遵循POD文档中的提示，则可以将其压缩到一个可以进行长时间更新和/或读取的系统中。</target>
        </trans-unit>
        <trans-unit id="1b51e848321e977ce5d13c2818c175d0f41effb3" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;DB_File&lt;/b&gt; wrapper which creates copies of the database file for read access, so that you have a kind of a multiversioning concurrent read system. However, updates are still serial. Use for databases where reads may be lengthy and consistency problems may occur.</source>
          <target state="translated">一个&lt;b&gt;DB_File&lt;/b&gt;包装器，用于创建数据库文件的副本以进行读取访问，因此您具有一种多版本并发读取系统。但是，更新仍然是串行的。用于读取可能很长且可能会出现一致性问题的数据库。</target>
        </trans-unit>
        <trans-unit id="a028dc9e0b2f7388284cb78c959a40269b50fa27" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;Pod parser&lt;/b&gt; is a module meant for parsing Pod (regardless of whether this involves calling callbacks or building a parse tree or directly formatting it). A &lt;b&gt;Pod formatter&lt;/b&gt; (or &lt;b&gt;Pod translator&lt;/b&gt;) is a module or program that converts Pod to some other format (HTML, plaintext, TeX, PostScript, RTF). A &lt;b&gt;Pod processor&lt;/b&gt; might be a formatter or translator, or might be a program that does something else with the Pod (like counting words, scanning for index points, etc.).</source>
          <target state="translated">一个&lt;b&gt;吊舱解析器&lt;/b&gt;是指用于解析波德模块（无论这是否涉及调用回调或构建解析树或者直接格式化）。甲&lt;b&gt;波德格式化器&lt;/b&gt;（或&lt;b&gt;波德译者&lt;/b&gt;）是一个模块或程序，其将波德某些其他格式（HTML，明文，TeX的，在PostScript，RTF）。一个&lt;b&gt;主机处理器&lt;/b&gt;可以是格式化或翻译，或者可能是一个程序，做别的东西与波德（如计数的话，扫描指数点等）。</target>
        </trans-unit>
        <trans-unit id="75e0b45072c8738547ff8a165f7f145bc64c09c0" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that divides a number by some power of 2.</source>
          <target state="translated">甲&lt;b&gt;比特移位&lt;/b&gt;，通过2一些力量把一个号码。</target>
        </trans-unit>
        <trans-unit id="12a4a3ed2cee1e69194024985900709da0279c32" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;bit shift&lt;/b&gt; that multiplies the number by some power of 2.</source>
          <target state="translated">甲&lt;b&gt;位移位&lt;/b&gt;即乘以2的一些力量数量。</target>
        </trans-unit>
        <trans-unit id="835a63b1a5a99de9e5e4d92a77a7c97441fd9cb5" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;blank line&lt;/b&gt; is a line consisting entirely of zero or more spaces (ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file. A &lt;b&gt;non-blank line&lt;/b&gt; is a line containing one or more characters other than space or tab (and terminated by a newline or end-of-file).</source>
          <target state="translated">甲&lt;b&gt;空白行&lt;/b&gt;是全部由零个或多个空格（ASCII 32）或突出部（ASCII 9）的线，和一个换行或文件结束终止的。阿&lt;b&gt;非空白行&lt;/b&gt;是含有除空格或制表其他（和一个换行或结束文件终止）一个或多个字符的线。</target>
        </trans-unit>
        <trans-unit id="3728bf609a9f402c616e07291d2f146bcd65679f" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character class&lt;/b&gt; allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. Character classes are denoted by brackets &lt;code&gt;[...]&lt;/code&gt; , with the set of characters to be possibly matched inside. Here are some examples:</source>
          <target state="translated">一个&lt;b&gt;字符类&lt;/b&gt;允许一组可能的字符，而不仅仅是单个字符，匹配在正则表达式中的特定点。字符类由括号表示 &lt;code&gt;[...]&lt;/code&gt; ，与所述的字符集被可能匹配的内部。这里有些例子：</target>
        </trans-unit>
        <trans-unit id="88667454d168bdf07729fef4c08a10e0dab39990" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character class&lt;/b&gt; allows a set of possible characters, rather than just a single character, to match at a particular point in a regex. There are a number of different types of character classes, but usually when people use this term, they are referring to the type described in this section, which are technically called &quot;Bracketed character classes&quot;, because they are denoted by brackets &lt;code&gt;[...]&lt;/code&gt;, with the set of characters to be possibly matched inside. But we'll drop the &quot;bracketed&quot; below to correspond with common usage. Here are some examples of (bracketed) character classes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669c2da4b19c631926975e69d3d84a786a63080d" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;character&lt;/b&gt; or &lt;b&gt;string&lt;/b&gt; that keeps two surrounding strings from being confused with each other. The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; function works on separators. Not to be confused with &lt;b&gt;delimiters&lt;/b&gt; or &lt;b&gt;terminators&lt;/b&gt;. The &amp;ldquo;or&amp;rdquo; in the previous sentence separated the two alternatives.</source>
          <target state="translated">防止两个周围的字符串相互混淆的&lt;b&gt;字符&lt;/b&gt;或&lt;b&gt;字符串&lt;/b&gt;。该 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 功能适用于分离器。不要与&lt;b&gt;分隔符&lt;/b&gt;或&lt;b&gt;终止&lt;/b&gt;&lt;b&gt;符&lt;/b&gt;混淆。上一句话中的&amp;ldquo;或&amp;rdquo;将这两种选择分开。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
