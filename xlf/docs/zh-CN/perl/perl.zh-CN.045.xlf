<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="e91fc700eef8c024136a19a3d1a25e4a4aec8312" translate="yes" xml:space="preserve">
          <source>Note also that there are some basic rules to using &quot;=over&quot; ... &quot;=back&quot; regions:</source>
          <target state="translated">还要注意的是,使用&quot;=over &quot;有一些基本规则......。&quot;=回 &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f240a6fbb992211509f6bddbfc9324c218ab462f" translate="yes" xml:space="preserve">
          <source>Note also that this is a minimum setup; you might want to add other packages of &lt;b&gt;ADE&lt;/b&gt; (the</source>
          <target state="translated">另请注意，这是最低设置。您可能要添加其他&lt;b&gt;ADE&lt;/b&gt;软件包（</target>
        </trans-unit>
        <trans-unit id="8f0a8f1a21849e70b5e894c297b75fbda2be2da8" translate="yes" xml:space="preserve">
          <source>Note also that you &lt;b&gt;must&lt;/b&gt; consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value. (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)</source>
          <target state="translated">还要注意，您&lt;b&gt;必须&lt;/b&gt;将编码值视为原子值。也就是说，除了不透明，无法分析的字符串值之外，您不应将其视为任何其他内容。（随着语言标记标准随时间变化，编码方法的内部结构可能会在将来的版本中更改。）</target>
        </trans-unit>
        <trans-unit id="5bce497daf670728bb21a4272ea4f02098c78b3e" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , combining concatenation with formatting.</source>
          <target state="translated">还要注意 &lt;code&gt;sv_catpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 的存在，将串联与格式化结合在一起。</target>
        </trans-unit>
        <trans-unit id="224cbc8c1a831f9514ed249fa0fe0c7401070694" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt;, combining concatenation with formatting.</source>
          <target state="translated">还要注意 &lt;code&gt;sv_catpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 的存在，将串联与格式化结合在一起。</target>
        </trans-unit>
        <trans-unit id="2c03a1bb63438d075c735c239a360c45cd5c5f8e" translate="yes" xml:space="preserve">
          <source>Note especially that &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; is</source>
          <target state="translated">请特别注意， &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="5984ffc263d935d0debbee07663c497020c0e0f9" translate="yes" xml:space="preserve">
          <source>Note event type</source>
          <target state="translated">注事件类型</target>
        </trans-unit>
        <trans-unit id="329f3fa12538d44b63cb4bc769615094799f44fc" translate="yes" xml:space="preserve">
          <source>Note for BSD users: setting &lt;code&gt;$0&lt;/code&gt; does not completely remove &quot;perl&quot; from the ps(1) output. For example, setting &lt;code&gt;$0&lt;/code&gt; to &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; (whether both the &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; prefix and the &quot; (perl)&quot; suffix are shown depends on your exact BSD variant and version). This is an operating system feature, Perl cannot help it.</source>
          <target state="translated">BSD用户注意：设置 &lt;code&gt;$0&lt;/code&gt; 不会完全从ps（1）输出中删除&amp;ldquo; perl&amp;rdquo;。例如，设置 &lt;code&gt;$0&lt;/code&gt; 至 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 可能导致 &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; （无论这两个 &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; 前缀和&amp;ldquo;（perl的）&amp;rdquo;后缀表示要看您的具体BSD变种和版本）。这是一个操作系统功能，Perl无法帮助它。</target>
        </trans-unit>
        <trans-unit id="7293fa6262cc45f7e2dbf5481215c1d362820f1d" translate="yes" xml:space="preserve">
          <source>Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl would emulate POSIX semantics on Linux systems using LinuxThreads, a partial implementation of POSIX Threads that has since been superseded by the Native POSIX Thread Library (NPTL).</source>
          <target state="translated">Linux和Debian GNU/kFreeBSD用户须知。在Perl v5.16.0之前,perl会在Linux系统上使用LinuxThreads来模拟POSIX语义,LinuxThreads是POSIX线程的部分实现,后来被NPTL所取代。</target>
        </trans-unit>
        <trans-unit id="7aea9b8c7cfe32358e543467b0f84f66f59444bc" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux用户注意事项：在v5.8.1和v5.16.0之间，Perl可以在使用LinuxThreads的少数Linux系统（和Debian GNU / kFreeBSD系统）使用非POSIX线程语义的情况下工作，此仿真已被删除。有关详细信息，请参见文档以获取&lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbdce38416b294a5283ce0536b64d8889c65db49" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux用户注意事项：在v5.8.1和v5.16.0之间，Perl可以在使用LinuxThreads的少数Linux系统（和Debian GNU / kFreeBSD系统）使用非POSIX线程语义的情况下工作，此仿真已被删除。有关详细信息，请参见文档以获取&lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb69bfe72361defc6ffb1f69be5dc9409ce2ae2e" translate="yes" xml:space="preserve">
          <source>Note how the first and last entries are protected by quotes in order to protect the spaces.</source>
          <target state="translated">请注意,为了保护空格,第一条和最后一条是如何用引号保护的。</target>
        </trans-unit>
        <trans-unit id="b9400fb5715aebae33791834189bda7b7f0594aa" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;. That is, if you say</source>
          <target state="translated">请注意解析器如何特别处理上表中的最后三个示例。 &lt;code&gt;mygrep()&lt;/code&gt; 被解析为真列表运算符， &lt;code&gt;myrand()&lt;/code&gt; 被解析为与 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 相同的一元优先级的真正一元运算符，而 &lt;code&gt;mytime()&lt;/code&gt; 确实没有参数，就像 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 一样。也就是说，如果你说</target>
        </trans-unit>
        <trans-unit id="cdc635a59a5a874516823dc99b8a94c5e05a2fb1" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;time()&lt;/code&gt;. That is, if you say</source>
          <target state="translated">请注意解析器如何特别处理上表中的最后三个示例。 &lt;code&gt;mygrep()&lt;/code&gt; 被解析为真列表运算符， &lt;code&gt;myrand()&lt;/code&gt; 被解析为与 &lt;code&gt;rand()&lt;/code&gt; 相同的一元优先级的真正一元运算符，而 &lt;code&gt;mytime()&lt;/code&gt; 确实没有参数，就像 &lt;code&gt;time()&lt;/code&gt; 一样。也就是说，如果你说</target>
        </trans-unit>
        <trans-unit id="32d61faf03809511f3cea1cbe82aa61f0b9ca92a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; being called.</source>
          <target state="translated">请注意，我们如何使用空列表 &lt;code&gt;()&lt;/code&gt; 加载用户pragma &lt;code&gt;myint&lt;/code&gt; 以防止其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="ee3224d5b447023fa11e54a3bfa8eb9adee42e7a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;import&lt;/code&gt; being called.</source>
          <target state="translated">请注意，我们如何使用空列表 &lt;code&gt;()&lt;/code&gt; 加载用户pragma &lt;code&gt;myint&lt;/code&gt; 以防止其 &lt;code&gt;import&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="25c06a27ee940fb1ce392065b6dccdd03fd73088" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">但是请注意，某些内置程序无法通过原型来表达其语法（例如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ）。如果您覆盖它们，则将无法完全模仿其原始语法。</target>
        </trans-unit>
        <trans-unit id="b7efc6d20035a67bd96018a6137a333a9fd4a32a" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;chomp&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">但是请注意，某些内置程序无法通过原型来表达其语法（例如 &lt;code&gt;system&lt;/code&gt; 或 &lt;code&gt;chomp&lt;/code&gt; ）。如果覆盖它们，则将无法完全模仿其原始语法。</target>
        </trans-unit>
        <trans-unit id="d4aeaafb27edb37453c0434b81658b1a8e907549" translate="yes" xml:space="preserve">
          <source>Note however that these versions will not behave as nicely in scalar context.</source>
          <target state="translated">但是请注意,这些版本在标量上下文中的表现并不尽如人意。</target>
        </trans-unit>
        <trans-unit id="7440d14152f809ce4da1ad00d96fe84e5f29c7fb" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;&quot;Pdksh&quot;&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;&quot;Frequently asked questions&quot;&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&quot;&lt;code&gt;PERL_SH_DIR&lt;/code&gt;&quot;&lt;/a&gt;).</source>
          <target state="translated">但是请注意，要使用其中的某些运算符，您需要安装sh语法shell（请参阅&lt;a href=&quot;#Pdksh&quot;&gt;&amp;ldquo; Pdksh&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#Frequently-asked-questions&quot;&gt;&amp;ldquo;常见问题&amp;rdquo;&lt;/a&gt;），并且perl应该能够找到它（请参阅&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;&amp;ldquo; &lt;code&gt;PERL_SH_DIR&lt;/code&gt; &amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="210da70db6283ccd39e5584b10f4c87c0f89d9d6" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Frequently asked questions&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">但是请注意，要使用其中一些运算符，您需要安装sh语法shell（请参阅&lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;，&lt;a href=&quot;#Frequently-asked-questions&quot;&gt;常见问题&lt;/a&gt;），并且perl应该能够找到它（请参阅&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6cd6d4fe1827d7816f9b8f3e1b0034bce7c56311" translate="yes" xml:space="preserve">
          <source>Note however, that this function does an exact match using &lt;code&gt;eq&lt;/code&gt; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</source>
          <target state="translated">但是请注意，此函数在完整路径上使用 &lt;code&gt;eq&lt;/code&gt; 进行完全匹配。因此，它无法补偿不区分大小写的文件系统，也无法比较2条路径以查看它们是否指向同一基础文件。</target>
        </trans-unit>
        <trans-unit id="e19273a97b7ee5052886f577d9a46a4421684819" translate="yes" xml:space="preserve">
          <source>Note however, that you need to have</source>
          <target state="translated">但请注意,您需要有</target>
        </trans-unit>
        <trans-unit id="507e6816311ba5923485459a746f4c205372d3f9" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">请注意，如果您指定 &lt;code&gt;-&lt;/code&gt; 作为命令，以类似的方式 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; 则子进程将只是派生的Perl进程，而不是外部命令。Win32平台尚不支持此功能。</target>
        </trans-unit>
        <trans-unit id="26e2cd3813c47d5570ed4f20adb47fcd58c86c5c" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;open(my $fh, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">注意，如果您指定 &lt;code&gt;-&lt;/code&gt; 作为命令，以类似的方式 &lt;code&gt;open(my $fh, &quot;-|&quot;)&lt;/code&gt; 则子进程将只是派生的Perl进程，而不是外部命令。Win32平台尚不支持此功能。</target>
        </trans-unit>
        <trans-unit id="da9342b413d4bbcd1dc6fe59e3ee28645b823224" translate="yes" xml:space="preserve">
          <source>Note in the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">请注意,在最后一个例子中,字符串的结尾被认为是一个字的边界。</target>
        </trans-unit>
        <trans-unit id="07e19a6ca0b876d2709ab0ec0dfc79383c491dc1" translate="yes" xml:space="preserve">
          <source>Note on ISO-2022-JP(-1)?</source>
          <target state="translated">关于ISO-2022-JP(-1)的说明?</target>
        </trans-unit>
        <trans-unit id="4950ea862c3beae92921259b5ea2a7679f983598" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;&quot;BUGS AND PITFALLS&quot;&lt;/a&gt;.</source>
          <target state="translated">请注意步骤7：某些运算符的语义取决于操作数的类型。由于无法指示Perl将操作数视为例如数字而不是字符串，因此这里的结果可能不是您期望的。请参阅&lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;&amp;ldquo;气泡和小瀑布&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b88ed054c638a5f7768e2dd282a5e1b35bab783a" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;BUGS AND PITFALLS&lt;/a&gt;.</source>
          <target state="translated">关于步骤7的注意事项：某些运算符的语义取决于操作数的类型。由于无法指示Perl将操作数视为例如数字而不是字符串，因此这里的结果可能不是您期望的。请参阅&amp;ldquo;错误&lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;和失败&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15bc1023efea2381a2db802c419cf3e98569e03f" translate="yes" xml:space="preserve">
          <source>Note on the format of the urllist parameter</source>
          <target state="translated">关于urllist参数格式的说明。</target>
        </trans-unit>
        <trans-unit id="cc738b8cb2fe5493887c63f096423e4e822a4785" translate="yes" xml:space="preserve">
          <source>Note particularly that $x continues to refer to the value passed into newprint()</source>
          <target state="translated">请特别注意,$x仍然是指传入newprint()的值。</target>
        </trans-unit>
        <trans-unit id="977ff75717e2ad5549c27c1fec3fb1a8727cd2e9" translate="yes" xml:space="preserve">
          <source>Note several important features of this example. First of all, the</source>
          <target state="translated">请注意这个例子的几个重要特点。首先,</target>
        </trans-unit>
        <trans-unit id="8d22a2ef918195af9fe48ae6fe3621002cfec585" translate="yes" xml:space="preserve">
          <source>Note specifically in the case that the list is already empty, &lt;code&gt;mark&lt;/code&gt; will equal &lt;code&gt;PL_stack_sp&lt;/code&gt;.</source>
          <target state="translated">特别注意在列表已经为空的情况下， &lt;code&gt;mark&lt;/code&gt; 将等于 &lt;code&gt;PL_stack_sp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e563f06c888e88271ecc5783df82aad24c908977" translate="yes" xml:space="preserve">
          <source>Note specifically that SV pointers on the value stack do not contribute to the overall reference count of the xVs being referred to. If newly-created xVs are being pushed to the stack you must arrange for them to be destroyed at a suitable time; usually by using one of the &lt;code&gt;mPUSH*&lt;/code&gt; macros or &lt;code&gt;sv_2mortal()&lt;/code&gt; to mortalise the xV.</source>
          <target state="translated">请特别注意，值堆栈上的SV指针对所引用的xV的总引用计数没有贡献。如果将新创建的xV推入堆栈，则必须安排在适当的时候销毁它们。通常通过使用 &lt;code&gt;mPUSH*&lt;/code&gt; 宏或 &lt;code&gt;sv_2mortal()&lt;/code&gt; 之一使xV失效。</target>
        </trans-unit>
        <trans-unit id="99e506d24bb1d2d8c0953ced78837622f6175e3d" translate="yes" xml:space="preserve">
          <source>Note that &quot;&amp;lt;&amp;amp;STDIN&quot; makes a copy, but &quot;&amp;lt;&amp;amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</source>
          <target state="translated">请注意，&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;进行复制，而&amp;ldquo; &amp;lt;＆= STDIN&amp;rdquo;进行别名。这意味着，如果关闭别名句柄，则所有别名都将无法访问。复制的副本不是这样。</target>
        </trans-unit>
        <trans-unit id="8b99f4b81966ee04ac35bb63df371e65272f50e3" translate="yes" xml:space="preserve">
          <source>Note that &quot;alpha&quot; version objects (where the version string contains a trailing underscore segment) compare as less than the equivalent version without an underscore:</source>
          <target state="translated">请注意,&quot;alpha &quot;版本对象(版本字符串包含尾部的下划线段)比没有下划线的等效版本要少。</target>
        </trans-unit>
        <trans-unit id="760e35c71509b97a49875e6fc164a9d4be791312" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . E.g.,</source>
          <target state="translated">请注意，由于未操作$ x，因此其真实非整数值5.8仍被打印。还要注意从最大的正整数到最大的负整数的环绕。此外，参数传递给函数和由它们返回的值都&lt;b&gt;不会&lt;/b&gt;影响 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="d8269433400ad0b6edc5ad3382abffca519f241b" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;use integer;&lt;/code&gt;. E.g.,</source>
          <target state="translated">请注意，由于未操作$ x，其实际非整数值5.8仍被打印。还要注意从最大的正整数到最大的负整数的折回。此外，参数传递给函数和由它们返回的值都&lt;b&gt;不会&lt;/b&gt;影响 &lt;code&gt;use integer;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="e599f385e86c967c815cb5ac633fbf5c8b743e32" translate="yes" xml:space="preserve">
          <source>Note that &amp;lt;FILE&amp;gt; is</source>
          <target state="translated">请注意，&amp;lt;FILE&amp;gt;是</target>
        </trans-unit>
        <trans-unit id="ae365970981ca6f4f0ae8ce0570b2cbd5480afa9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; returns the last character. To return all but the last character, use &lt;code&gt;substr($string, 0, -1)&lt;/code&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt;将返回最后一个字符。要返回除最后一个字符以外的所有字符，请使用 &lt;code&gt;substr($string, 0, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4044113059cc30bd1d9822bf229d1fd6518f819" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">请注意，&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;不会调用您的 &lt;code&gt;END&lt;/code&gt; 块，也不会在您的对象上调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="5e9dcf768d88acd6e9245dc33c6d534334d98435" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt; raises an exception if used on a machine that doesn't implement &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt;. See the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module or your &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; manpage to learn what functions are available on your system.</source>
          <target state="translated">请注意，如果在未实现&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;的计算机上使用&lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;fcntl&lt;/code&gt; &lt;/a&gt;，则会引发异常。请参阅&lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;模块或&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;联机帮助页以了解系统上可用的功能。</target>
        </trans-unit>
        <trans-unit id="ac11071b2447bfeff67f1ad413aafb72592d54ad" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#glob-EXPR&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;glob(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">请注意，&lt;a href=&quot;#glob-EXPR&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt;在空白处拆分其参数，并将每个段视为单独的模式。这样， &lt;code&gt;glob(&quot;*.c *.h&quot;)&lt;/code&gt; 会将所有文件与</target>
        </trans-unit>
        <trans-unit id="2247c7b4f4b47f7aa53f8ef346d558c46baa5e4f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;&quot;make_iterator&quot;&lt;/a&gt; has been</source>
          <target state="translated">请注意，&lt;a href=&quot;#make_iterator&quot;&gt;&amp;ldquo; make_iterator&amp;rdquo;&lt;/a&gt;已被</target>
        </trans-unit>
        <trans-unit id="f28b0b3d67592306ce241a091fd7fa4b9b9390b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; has been</source>
          <target state="translated">请注意，&lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt;已被</target>
        </trans-unit>
        <trans-unit id="d5449cbba5d5e7a82db88f55e4440d98e4342ea0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">请注意，&lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt;是一种特殊情况，它必须直接调用 &lt;code&gt;boot_DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b80b3ef08be16efffcb210c1f8271336ce263029" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">请注意，&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;是一种特殊情况，它必须直接调用 &lt;code&gt;boot_DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0526d5d85fc0534ff6f7d2f9105c957dadfacb23" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt;, &lt;a href=&quot;#map-BLOCK-LIST&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; or another &lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/a&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">请注意，&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。同样，grep将别名返回到原始列表中，就像for循环的索引变量为列表元素别名一样。也就是说，修改grep返回的列表的元素（例如，在 &lt;code&gt;foreach&lt;/code&gt; ，&lt;a href=&quot;#map-BLOCK-LIST&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;或另一个&lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt; &lt;code&gt;grep&lt;/code&gt; 中&lt;/a&gt;）实际上会修改原始列表中的元素。在编写清晰的代码时通常应避免这种情况。</target>
        </trans-unit>
        <trans-unit id="f5d74fe4c4d980bb13b58d3feb16b0acc19c76fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt;&lt;code&gt;grep&lt;/code&gt;&lt;/a&gt; for a list composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">请注意，&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。在大多数情况下，使用常规的 &lt;code&gt;foreach&lt;/code&gt; 循环会更清晰。另请参见&lt;a href=&quot;#grep-BLOCK-LIST&quot;&gt; &lt;code&gt;grep&lt;/code&gt; &lt;/a&gt;，以获取由原始列表中BLOCK或EXPR评估为true的那些项组成的列表。</target>
        </trans-unit>
        <trans-unit id="d2b414b3045e4a13e62684509b81beee13f1a03b" translate="yes" xml:space="preserve">
          <source>Note that &lt;b&gt;-S&lt;/b&gt; switch supports scripts with additional extensions</source>
          <target state="translated">请注意，&lt;b&gt;-S&lt;/b&gt;开关支持带有其他扩展名的脚本</target>
        </trans-unit>
        <trans-unit id="df5cabe56a3fab1a8dfd7142a90c482f8fae0efd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; has lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">请注意， &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 优先级低于关系运算符，因此，例如在诸如</target>
        </trans-unit>
        <trans-unit id="6fb0ba015a70a1ecbbac6efb61ce95fa86c8c327" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt; variable if scripts are not careful.</source>
          <target state="translated">注意 &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; 并且正则表达式中 &lt;code&gt;$&lt;/code&gt; 插值的第二阶段将与$产生冲突&lt;a href=&quot;perlvar#%24.&quot;&gt; &lt;code&gt;$.&lt;/code&gt; &lt;/a&gt;如果脚本不小心，则变量。</target>
        </trans-unit>
        <trans-unit id="522782427bfce1d8f14995dfc30aaa97199ffa5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;code&gt;$.&lt;/code&gt; if scripts are not careful.</source>
          <target state="translated">注意 &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; 并且正则表达式中 &lt;code&gt;$&lt;/code&gt; 插值的第二阶段将与$产生冲突 &lt;code&gt;$.&lt;/code&gt; 如果脚本不小心。</target>
        </trans-unit>
        <trans-unit id="12ecea42a6af74c63b7121532319090437ea634b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;|&quot;&lt;/code&gt; and &lt;code&gt;&quot;^&quot;&lt;/code&gt; have lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">请注意， &lt;code&gt;&quot;|&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 优先级低于关系运算符，因此例如在测试中括号是必不可少的</target>
        </trans-unit>
        <trans-unit id="79eafdbed824b09455353e30518fbddb877197c5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。同样，grep将别名返回到原始列表中，就像for循环的索引变量为列表元素别名一样。也就是说，修改grep返回的列表的元素（例如，在 &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或另一个 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 中）实际上会修改原始列表中的元素。在编写清晰的代码时通常应避免这种情况。</target>
        </trans-unit>
        <trans-unit id="922c04cd95d993e5139c2b97058698400e67f636" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。同样，grep将别名返回到原始列表中，就像for循环的索引变量为列表元素别名一样。也就是说，修改grep返回的列表的元素（例如，在 &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或另一个 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 中）实际上会修改原始列表中的元素。在编写清晰的代码时通常应避免这种情况。</target>
        </trans-unit>
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。在大多数情况下，使用常规的 &lt;code&gt;foreach&lt;/code&gt; 循环会更清晰。另请参见&lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt;，以了解由原始列表中BLOCK或EXPR评估为true的那些项组成的数组。</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。在大多数情况下，使用常规的 &lt;code&gt;foreach&lt;/code&gt; 循环会更清晰。另请参见&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;，以了解由原始列表中BLOCK或EXPR评估为true的那些项组成的数组。</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;$processed&lt;/code&gt; 可能为空（当 &lt;code&gt;$normalized&lt;/code&gt; 包含启动器或从最后一个启动器开始时），然后 &lt;code&gt;$unprocessed&lt;/code&gt; 应该等于整个 &lt;code&gt;$normalized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2dca7ba63a68f9fddd9b7ac309791bf8abd311e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;$processed&lt;/code&gt; 可能为空（当 &lt;code&gt;$normalized&lt;/code&gt; 包含任何启动程序或从最后一个启动程序开始时），然后 &lt;code&gt;$unprocessed&lt;/code&gt; 应该等于整个 &lt;code&gt;$normalized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6f1dc26add5ebccf190f8ef66eb27e1f5723ef3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt;, the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">请注意， &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%b&lt;/code&gt; （一周中的一天和一年中的月份的缩写）不一定是三个字符宽。</target>
        </trans-unit>
        <trans-unit id="2098e1cc9941a87eb89bbdff478cb887098142a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(?[ ])&lt;/code&gt; is a regex-compile-time construct. Any attempt to use something which isn't knowable at the time the containing regular expression is compiled is a fatal error. In practice, this means just three limitations:</source>
          <target state="translated">注意 &lt;code&gt;(?[ ])&lt;/code&gt; 是一个正则表达式编译时构造。任何试图使用在编译包含正则表达式时都不知道的东西的尝试都是致命的错误。实际上，这意味着三个限制：</target>
        </trans-unit>
        <trans-unit id="cd09559e1981494f86fde1566facece3e2639305" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--opt value&lt;/code&gt; is still accepted, even though GNU getopt_long() doesn't.</source>
          <target state="translated">请注意，即使GNU getopt_long（）不接受 &lt;code&gt;--opt value&lt;/code&gt; 仍被接受。</target>
        </trans-unit>
        <trans-unit id="afc9bdd2d79f09af0f88913bcc31f66fb74dccd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-register&lt;/code&gt; is a global setting that applies to the entire program; it cannot be applied only for certain callers, removed, or limited by lexical scope.</source>
          <target state="translated">请注意， &lt;code&gt;-register&lt;/code&gt; 是适用于整个程序的全局设置。它不能仅适用于某些调用者，已删除或受词法范围限制的调用者。</target>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">请注意， &lt;code&gt;-s/a/b/&lt;/code&gt; 不会进行取反。话说 &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 仍正常工作，但是：只有下面一个负单字母解释为文件的测试。</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">请注意， &lt;code&gt;-s/a/b/&lt;/code&gt; 不会进行取反。话说 &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 仍正常工作，但是：只有下面一个负单字母解释为文件的测试。</target>
        </trans-unit>
        <trans-unit id="e3f960c753f2dbcaaba10ddc75d049f8c367286e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-exp($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">请注意， &lt;code&gt;-s/a/b/&lt;/code&gt; 不会进行否定替换。但是，说 &lt;code&gt;-exp($foo)&lt;/code&gt; 仍然可以按预期工作：将减号后的单个字母解释为文件测试。</target>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">注意 &lt;code&gt;:constants256&lt;/code&gt; 不包含其他常量，因此，如果要混合使用它们，则还必须包含 &lt;code&gt;:constants&lt;/code&gt; 。您可能要显式导入至少 &lt;code&gt;RESET&lt;/code&gt; ，如：</target>
        </trans-unit>
        <trans-unit id="e353e5ca3a012a60bd40d8c3d650a30fa181791c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt;, as in:</source>
          <target state="translated">注意 &lt;code&gt;:constants256&lt;/code&gt; 不包括其他常量，因此，如果要混合使用它们，则还必须包括 &lt;code&gt;:constants&lt;/code&gt; 。您可能要显式导入至少 &lt;code&gt;RESET&lt;/code&gt; ，如：</target>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 是每个测试的等待和退出状态的总和。如果这些值中的任何一个都不为零，则总计这些值仅是为了提供真实值。</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 不在上面列出。如果在Time :: Piece对象上作为方法调用，它们将充当构造函数，并在当前时间返回新的Time :: Piece对象。换句话说：它们作为方法没有用。</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 将返回最后一个字符。要返回除最后一个字符以外的所有字符，请使用 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 不会调用您的 &lt;code&gt;END&lt;/code&gt; 块，也不会在您的对象上调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">请注意，如果在未实现fcntl（2）的计算机上使用 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ，则会引发异常。请参阅Fcntl模块或fcntl（2）联机帮助页以了解系统上可用的功能。</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">注意，当使用普通文件句柄时，通常不需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。提供该文件是为了使您可以在必要时控制对现有记录结构文件的I / O。您还可以在VMS :: Stdio扩展中使用 &lt;code&gt;vmsfopen&lt;/code&gt; 函数，以更好地控制具有不同记录结构的文件和设备的I / O。</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 将返回最后一个字符。要返回除最后一个字符以外的所有字符，请使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 不会调用您的 &lt;code&gt;END&lt;/code&gt; 块，也不会在您的对象上调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">请注意，如果在未实现fcntl（2）的计算机上使用 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ，则会引发异常。请参阅Fcntl模块或fcntl（2）联机帮助页以了解系统上可用的功能。</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 在空白处拆分其参数，并将每个段视为单独的模式。这样， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 会将所有文件与</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; 不适用于当前版本的EMX。</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 取决于fdopen（）C库函数。在许多Unix系统上，已知当文件描述符超过某个值（通常为255）时，fdopen（）会失败。如果您需要的文件描述符超过此值，请考虑使用POSIX :: open（）函数。</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">需要注意的是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 并&lt;b&gt;没有&lt;/b&gt;做正则表达式字符类，如 &lt;code&gt;\d&lt;/code&gt; 或 &lt;code&gt;\pL&lt;/code&gt; 。的 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 操作者是不等同于 &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; 实用程序。如果要在大小写之间映射字符串，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;和&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;，如果需要正则表达式，通常考虑使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 运算符。替换运算符右侧的 &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; 和 &lt;code&gt;\l&lt;/code&gt; 字符串插值转义将执行正确的大小写映射，但是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; 不会（有时在旧版7位数据上除外）。</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">请注意，插值字符串中的 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 转换为大写，而插值字符串中的 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\u&lt;/code&gt; 转换为区分大小写的语言的首字母大写（等同于不区分大小写的语言中的大写字母）。</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 在空白处拆分其参数，并将每个段视为单独的模式。这样， &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 会将所有文件与</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 取决于fdopen（）C库函数。在许多Unix系统上，已知当文件描述符超过某个值（通常为255）时，fdopen（）会失败。如果您需要的文件描述符超过此值，请考虑使用POSIX :: open（）函数。</target>
        </trans-unit>
        <trans-unit id="f9b1a84ba3ae7615ac251b965f25b6f6929c148a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; requires &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; because the conversion routine cannot differentiate whether the last &lt;code&gt;.&lt;/code&gt; of a Unix specification is delimiting a version, or is just part of a file specification.</source>
          <target state="translated">请注意， &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 需要 &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; 因为转换例程无法区分是否为last &lt;code&gt;.&lt;/code&gt; Unix规范的定义正在界定版本，或者仅仅是文件规范的一部分。</target>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">请注意， &lt;code&gt;Dump&lt;/code&gt; 不会报告</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">请注意， &lt;code&gt;END&lt;/code&gt; 代码块&lt;b&gt;不会&lt;/b&gt;在字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 的末尾执行：如果在字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中创建了任何 &lt;code&gt;END&lt;/code&gt; 代码块，它们将与该包中的其他任何 &lt;code&gt;END&lt;/code&gt; 代码块一样按LIFO顺序执行。在退出解释器之前。</target>
        </trans-unit>
        <trans-unit id="87d3d5579888e295497dd30ab3df3385d0ee5915" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;eval()&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;eval()&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">请注意， &lt;code&gt;END&lt;/code&gt; 代码块&lt;b&gt;不会&lt;/b&gt;在字符串 &lt;code&gt;eval()&lt;/code&gt; 的末尾执行：如果在字符串 &lt;code&gt;eval()&lt;/code&gt; 中创建了任何 &lt;code&gt;END&lt;/code&gt; 代码块，它们将与该包中的其他任何 &lt;code&gt;END&lt;/code&gt; 代码块一样按LIFO顺序执行。在退出解释器之前。</target>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; 和 &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; 设置了全局变量，因此&lt;b&gt;任何&lt;/b&gt;新创建的数字都将&lt;b&gt;立即&lt;/b&gt;进行全局舍入。这意味着在上面的示例中， &lt;code&gt;bdiv()&lt;/code&gt; 的 &lt;code&gt;3&lt;/code&gt; 作为参数也将获得&lt;b&gt;5&lt;/b&gt;的精度。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;NULL&lt;/code&gt; 是有效的 &lt;code&gt;proto&lt;/code&gt; 并且将始终返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="199f2f9c1f354b6dfdfcfb899b79a41c177c2dfa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;NULL&lt;/code&gt; 是有效的 &lt;code&gt;proto&lt;/code&gt; 并且将始终返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">请注意，无论如何都不会更改 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">请注意， &lt;code&gt;TAP::Parser&lt;/code&gt; 被设计为中央&amp;ldquo;制造者&amp;rdquo;-即：它负责在 &lt;code&gt;TAP::Parser::*&lt;/code&gt; 名称空间中创建大多数新对象。</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">请注意，即使所有类都隐式继承自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 及其父级的方法， &lt;code&gt;UNIVERSAL&lt;/code&gt; （和 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的MRO的任何成员）也不属于类的MRO 。</target>
        </trans-unit>
        <trans-unit id="d2ebe68731e3dfdbe752ef6caa15931a10fc553d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt;'s MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">请注意，即使所有类都隐式继承自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 及其父级的方法， &lt;code&gt;UNIVERSAL&lt;/code&gt; （和 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的MRO的任何成员）也不属于类的MRO 。</target>
        </trans-unit>
        <trans-unit id="3fd56e1e046b5a0f876bfdbc7dc77a2bed0822bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, it matches the character or character sequence whose name is</source>
          <target state="translated">注意 &lt;code&gt;\N&lt;/code&gt; 有两个含义。当格式为 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; ，它与名称为的字符或字符序列匹配</target>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">注意 &lt;code&gt;\N&lt;/code&gt; 有两个含义。当格式为 &lt;code&gt;\N{NAME}&lt;/code&gt; ，它与名称为 &lt;code&gt;NAME&lt;/code&gt; 的字符或字符序列匹配；并且类似地，当格式为 &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; ，它匹配Unicode代码点为</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;\N{...}&lt;/code&gt; 可以表示&lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;命名或编号字符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">注意 &lt;code&gt;\N{...}&lt;/code&gt; 是编译时；这是双引号字符串中使用的字符串常量的一种特殊形式；这意味着您不能在 &lt;code&gt;\N{...}&lt;/code&gt; 内部使用变量。如果您想要类似的运行时功能，请使用&lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ceeaecdecef4fbab384a44465508a20a199dce2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt;. If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">注意 &lt;code&gt;\N{...}&lt;/code&gt; 是编译时；这是在双引号字符串中使用的字符串常量的一种特殊形式；这意味着您不能在 &lt;code&gt;\N{...}&lt;/code&gt; 内部使用变量。如果您想要类似的运行时功能，请使用&lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames :: string_vianame（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">请注意 &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">请注意，在正则表达式（或双引号字符串）末尾单独使用 &lt;code&gt;\c\&lt;/code&gt; 无效。反斜杠后必须跟另一个字符。也就是说， &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 表示 &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; 所有字符均为&amp;ldquo; &lt;i&gt;X&lt;/i&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e1ebc62194ed9270f2f0ded9d5873b50990282bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;binmode&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">注意，当使用普通文件句柄时，通常不需要 &lt;code&gt;binmode&lt;/code&gt; 。提供它是为了使您可以在必要时控制对现有记录结构文件的I / O。您还可以在VMS :: Stdio扩展名中使用 &lt;code&gt;vmsfopen&lt;/code&gt; 函数，以更好地控制具有不同记录结构的文件和设备的I / O。</target>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">请注意，如果 &lt;code&gt;$thing&lt;/code&gt; 被祝福到名为&amp;ldquo; 0&amp;rdquo;的类中，则 &lt;code&gt;blessed($thing)&lt;/code&gt; 也将返回false 。这是可能的，但是很病态。除非您知道自己在做什么，否则不要创建名为&amp;ldquo; 0&amp;rdquo;的类。</target>
        </trans-unit>
        <trans-unit id="e26f8bbaa602bc77ce825cb115ea483aef29de1d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cx_pushblock()&lt;/code&gt; sets two new floors: for the args stack (to &lt;code&gt;MARK&lt;/code&gt;) and the temps stack (to &lt;code&gt;PL_tmps_ix&lt;/code&gt;). While executing at this scope level, every &lt;code&gt;nextstate&lt;/code&gt; (amongst others) will reset the args and tmps stack levels to these floors. Note that since &lt;code&gt;cx_pushblock&lt;/code&gt; uses the current value of &lt;code&gt;PL_tmps_ix&lt;/code&gt; rather than it being passed as an arg, this dictates at what point &lt;code&gt;cx_pushblock&lt;/code&gt; should be called. In particular, any new mortals which should be freed only on scope exit (rather than at the next &lt;code&gt;nextstate&lt;/code&gt;) should be created first.</source>
          <target state="translated">请注意， &lt;code&gt;cx_pushblock()&lt;/code&gt; 设置了两个新的楼层：args堆栈（至 &lt;code&gt;MARK&lt;/code&gt; ）和temps堆栈（至 &lt;code&gt;PL_tmps_ix&lt;/code&gt; ）。在此作用域级别执行时，每个 &lt;code&gt;nextstate&lt;/code&gt; （以及其他状态）都会将args和tmps堆栈级别重置为这些楼层。注意，由于 &lt;code&gt;cx_pushblock&lt;/code&gt; 使用的电流值 &lt;code&gt;PL_tmps_ix&lt;/code&gt; 而不是将其作为一个ARG被传递，这就要求在什么时候 &lt;code&gt;cx_pushblock&lt;/code&gt; 应该叫。特别是，应该首先创建仅在范围出口（而不是在下一个 &lt;code&gt;nextstate&lt;/code&gt; ）上释放的任何新凡人。</target>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">请注意， &lt;code&gt;gen_delimited_pat&lt;/code&gt; 以前称为 &lt;code&gt;delimited_pat&lt;/code&gt; 。该名称可能仍会使用，但现在已弃用。</target>
        </trans-unit>
        <trans-unit id="72d7884266eebfa7e1a24e791ad9ea94730bed68" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt;. That name may still be used, but is now deprecated.</source>
          <target state="translated">请注意， &lt;code&gt;gen_delimited_pat&lt;/code&gt; 以前称为 &lt;code&gt;delimited_pat&lt;/code&gt; 。该名称可能仍会使用，但现在已弃用。</target>
        </trans-unit>
        <trans-unit id="18a865bc718b78b08d20efdc599ac6b3675ef080" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;kill -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">请注意， &lt;code&gt;kill -9&lt;/code&gt; 不适用于当前版本的EMX。</target>
        </trans-unit>
        <trans-unit id="7dd7dada581d4f39d8fce5c8c1d0ecbac2ea1218" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">请注意， &lt;code&gt;localtime&lt;/code&gt; 和 &lt;code&gt;gmtime&lt;/code&gt; 不在上面列出。如果在Time :: Piece对象上作为方法调用，它们将充当构造函数，并在当前时间返回一个新的Time :: Piece对象。换句话说：它们作为方法没有用。</target>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">请注意， &lt;code&gt;make_source&lt;/code&gt; 和 &lt;code&gt;make_perl_source&lt;/code&gt; 已被</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">请注意，现在 &lt;code&gt;openlog()&lt;/code&gt; 需要三个参数，就像 &lt;code&gt;openlog(3)&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="107847c03394449c5b753c11d610306353b4ed86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt;.</source>
          <target state="translated">请注意，现在 &lt;code&gt;openlog()&lt;/code&gt; 需要三个参数，就像 &lt;code&gt;openlog(3)&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="20aeb476985aacd52e5f965fd1bbff8fbe0c7c39" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;pad_findlex()&lt;/code&gt; is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in &lt;code&gt;xpadn_low&lt;/code&gt; the index into the parent pad.</source>
          <target state="translated">注意 &lt;code&gt;pad_findlex()&lt;/code&gt; 是递归的；它沿着CV链递归，然后又下降，并随即添加虚假条目。之所以必须采用这种方式，是因为匿名原型中的虚假名称必须存储在 &lt;code&gt;xpadn_low&lt;/code&gt; 中，并存储在父板中的索引中。</target>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;size&lt;/code&gt; 是目标缓冲区的完整大小，如果有空间，结果将保证为 &lt;code&gt;NUL&lt;/code&gt; 终止。需要注意的是房间的 &lt;code&gt;NUL&lt;/code&gt; 应包括在 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1eb316f8ef59a8e93ddd67dae614660ddbd436c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt;-terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;size&lt;/code&gt; 是目标缓冲区的完整大小，如果有空间，结果将保证为 &lt;code&gt;NUL&lt;/code&gt; 终止。需要注意的是房间的 &lt;code&gt;NUL&lt;/code&gt; 应包括在 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8099742523782e905e75bc531c5f7ea28d83c88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort_by&lt;/code&gt; affects all the plain hashes in the data structure. If you need finer control, &lt;code&gt;tie&lt;/code&gt; necessary hashes with a module that implements ordered hash (such as &lt;a href=&quot;Hash::Ordered&quot;&gt;Hash::Ordered&lt;/a&gt; and &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt;). &lt;code&gt;canonical&lt;/code&gt; and &lt;code&gt;sort_by&lt;/code&gt; don't affect the key order in &lt;code&gt;tie&lt;/code&gt;d hashes.</source>
          <target state="translated">请注意， &lt;code&gt;sort_by&lt;/code&gt; 会影响数据结构中的所有普通哈希。如果需要更好的控制，请将必要的哈希值与实现有序哈希的模块 &lt;code&gt;tie&lt;/code&gt; 在一起（例如&lt;a href=&quot;Hash::Ordered&quot;&gt;Hash :: Ordered&lt;/a&gt;和&lt;a href=&quot;Tie::IxHash&quot;&gt;Tie :: IxHash&lt;/a&gt;）。 &lt;code&gt;canonical&lt;/code&gt; 和 &lt;code&gt;sort_by&lt;/code&gt; 不会影响 &lt;code&gt;tie&lt;/code&gt; 哈希中的键顺序。</target>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">请注意， &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;tap&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="c694dbb84b91dadc0270b7093942a49dccfcd18d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are</source>
          <target state="translated">请注意， &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;tap&lt;/code&gt; 和 &lt;code&gt;exec&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="297cb2762357bcbc37087b287127235df664073c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs, and add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="translated">需要注意的是 &lt;code&gt;sv_magicext&lt;/code&gt; 将使事情 &lt;code&gt;sv_magic&lt;/code&gt; 不会。特别是，您可以向 &lt;code&gt;SvREADONLY&lt;/code&gt; SV添加魔术，并添加多个 &lt;code&gt;how&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">需要注意的是 &lt;code&gt;sv_magicext&lt;/code&gt; 将使事情 &lt;code&gt;sv_magic&lt;/code&gt; 不会。特别是，您可以向SvREADONLY SV添加魔术，并添加多个相同&amp;ldquo;操作&amp;rdquo;实例。</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">请注意， &lt;code&gt;sv_setref_pv&lt;/code&gt; 复制指针，而这会复制字符串。</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">请注意， &lt;code&gt;sv_setref_pvn&lt;/code&gt; 复制字符串，同时复制指针。</target>
        </trans-unit>
        <trans-unit id="ca9054fd02ce103d72fc003e486b493405a56eb5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tr&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt;. The &lt;code&gt;tr&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; utility. &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; will uppercase the 26 letters &quot;a&quot; through &quot;z&quot;, but for case changing not confined to ASCII, use &lt;a href=&quot;perlfunc#lc&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#uc&quot;&gt;&lt;code&gt;uc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lcfirst&quot;&gt;&lt;code&gt;lcfirst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ucfirst&quot;&gt;&lt;code&gt;ucfirst&lt;/code&gt;&lt;/a&gt; (all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;), or the &lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;substitution operator &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt;&lt;/a&gt; (with &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes in the</source>
          <target state="translated">需要注意的是 &lt;code&gt;tr&lt;/code&gt; 并&lt;b&gt;没有&lt;/b&gt;做正则表达式字符类，如 &lt;code&gt;\d&lt;/code&gt; 或 &lt;code&gt;\pL&lt;/code&gt; 。的 &lt;code&gt;tr&lt;/code&gt; 操作者是不等同于 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; 实用程序。 &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; 将26个字母&amp;ldquo; a&amp;rdquo;到&amp;ldquo; z&amp;rdquo;大写，但是对于大小写变化不限于ASCII的情况，请使用&lt;a href=&quot;perlfunc#lc&quot;&gt; &lt;code&gt;lc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlfunc#uc&quot;&gt; &lt;code&gt;uc&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlfunc#lcfirst&quot;&gt; &lt;code&gt;lcfirst&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlfunc#ucfirst&quot;&gt; &lt;code&gt;ucfirst&lt;/code&gt; &lt;/a&gt;（全部记录在&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;）或&lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;替换运算符 &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt; &lt;/a&gt;（带有 &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; ，而 &lt;code&gt;\l&lt;/code&gt; string-interpolation在</target>
        </trans-unit>
        <trans-unit id="968eb220f1920402825447b300d7614d04828e7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;uc()&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;ucfirst&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">请注意，插值字符串中的 &lt;code&gt;uc()&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 转换为大写，而插值字符串中的 &lt;code&gt;ucfirst&lt;/code&gt; 或 &lt;code&gt;\u&lt;/code&gt; 转换为区分大小写的语言的首字母大写（等同于不区分大小写的语言中的大写字母）。</target>
        </trans-unit>
        <trans-unit id="b40c8f91ea36b67ee3cfa45c32946c2ec3844b33" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqint&lt;/code&gt; are well-behaved as integers.</source>
          <target state="translated">请注意，对 &lt;code&gt;undef&lt;/code&gt; 的处理方式与其他数值运算对它的处理方式一样；它比较等于零，但如果启用了这样的警告，则会另外产生警告（请 &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。另外，将返回列表中的 &lt;code&gt;undef&lt;/code&gt; 强制转换为数字零，以便 &lt;code&gt;uniqint&lt;/code&gt; 返回的整个值列表都表现为整数。</target>
        </trans-unit>
        <trans-unit id="adf172390d0d301f41e881eb119b5f9d655cba59" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqnum&lt;/code&gt; are well-behaved as numbers.</source>
          <target state="translated">请注意，对 &lt;code&gt;undef&lt;/code&gt; 的处理方式与其他数值运算对它的处理方式一样；它比较等于零，但如果启用了这样的警告，则会另外产生警告（请 &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。另外，将返回列表中的 &lt;code&gt;undef&lt;/code&gt; 强制转换为数字零，以便 &lt;code&gt;uniqnum&lt;/code&gt; 返回的整个值列表都表现为数字。</target>
        </trans-unit>
        <trans-unit id="1438af20c640a879b280a807cfcb4c4b1f563f7c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other string operations treat it; it compares equal to the empty string but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into an empty string, so that the entire list of values returned by &lt;code&gt;uniqstr&lt;/code&gt; are well-behaved as strings.</source>
          <target state="translated">请注意，对 &lt;code&gt;undef&lt;/code&gt; 的处理与对其他字符串操作的处理一样。它比较等于空字符串，但如果启用了这样的警告，则会另外产生警告（请 &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。另外，将返回列表中的 &lt;code&gt;undef&lt;/code&gt; 强制转换为空字符串，以便 &lt;code&gt;uniqstr&lt;/code&gt; 返回的整个值列表都表现为字符串。</target>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">请注意，如果字符串包含不适合字节的字符，则 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 可能会失败。</target>
        </trans-unit>
        <trans-unit id="244a344737b42f7a4dc0804c6a1816a678ff0765" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">请注意， &lt;code&gt;wait&lt;/code&gt; 和 &lt;code&gt;exit&lt;/code&gt; 是每个测试的等待和退出状态的总和。如果这些值中的任何一个都不为零，则总计这些值仅是为了提供真实值。</target>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">请注意,=end命令必须与当前打开的=begin命令相匹配。也就是说,它们必须正确地嵌套。例如,这是有效的。</target>
        </trans-unit>
        <trans-unit id="eaeb65853d186efa2ac24ebd60591d6679af5af8" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&quot;&quot;\c%c&quot; is more clearly written simply as &quot;%s&quot;&quot;&lt;/a&gt;.</source>
          <target state="translated">请注意，不建议不要映射到控制字符的ASCII字符，它们会生成警告（启用后），&lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&amp;ldquo;&amp;rdquo; \ c％c&amp;ldquo;更清楚地写为&amp;rdquo;％s&amp;ldquo;&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">请注意，不鼓励不要映射到控制字符的ASCII字符，并且会生成警告（启用后），&lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c％c更清楚地写为％s&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">请注意，E &amp;lt;number&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">请注意，版本1.14之前的GNU tar不能很好地处理 &lt;code&gt;POSIX header prefix&lt;/code&gt; 。如果使用这样的版本，请考虑将 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 变量设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1703b14dd9d7aca1f4b440f1de3dd5da07ea976" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt;. If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">请注意，版本1.14之前的GNU tar不能很好地处理 &lt;code&gt;POSIX header prefix&lt;/code&gt; 。如果使用这样的版本，请考虑将 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 变量设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">请注意,GNU的gzip/gunzip与Info-ZIP的zip/unzip包是不同的。前者是一个简单的压缩工具;后者允许创建多文件档案。</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">需要注意的是,理想的散列质量得分应该是1,接近和低于1的数字表示散列效果好,明显高于1的数字表示得分差。在实践中,它应该是0.95到1.05左右。它的定义是:</target>
        </trans-unit>
        <trans-unit id="5fc2a35e63a8ddebfc4d138e20ffc7c6e9a57238" translate="yes" xml:space="preserve">
          <source>Note that I could not run successful smokes when initiated by the Synology Task Scheduler. I resorted to initiating the smokes via a cron job run on another system, using ssh:</source>
          <target state="translated">请注意,当我使用Synology任务调度程序启动时,我无法成功运行烟雾弹。我只好使用ssh在另一个系统上运行cron作业来启动烟雾弹。</target>
        </trans-unit>
        <trans-unit id="a0b4524e41048103b895691d929d6149e5d9f22f" translate="yes" xml:space="preserve">
          <source>Note that ISO-8859-1-</source>
          <target state="translated">请注意,ISO-8859-1</target>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">需要注意的是,META文件应该是UTF-8编码的,只能是UTF-8编码。当转换字符串数据时,必须首先对其进行UTF-8解码。</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">请注意,MakeMaker实际上会根据它认为你使用的 &quot;make &quot;发出不同语法的makefile。因此,在Config.pm中出现以下值之一是很重要的。</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">请注意，Perl可以在ASCII或EBCDIC下编译并运行（请参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;）。大多数文档（甚至代码中的注释）都忽略了EBCDIC的可能性。对于几乎所有目的，差异都是透明的。例如，在EBCDIC下，使用UTF-EBCDIC而不是UTF-8来编码Unicode字符串，因此，每当本文档引用 &lt;code&gt;utf8&lt;/code&gt; （以及该名称的变体，包括函数名称）时，它也（实质上是透明的）表示 &lt;code&gt;UTF-EBCDIC&lt;/code&gt; 。但是，ASCII，EBCDIC和UTF编码之间的字符顺序有所不同，并且以UTF-EBCDIC编码的字符串可能比在UTF-8中占用更多的字节。</target>
        </trans-unit>
        <trans-unit id="1e8390b60c04725a0174dd4b5588a54acdd18f9b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt;. But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy a different number of bytes than in UTF-8.</source>
          <target state="translated">请注意，Perl可以在ASCII或EBCDIC下进行编译和运行（请参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;）。大多数文档（甚至代码中的注释）都忽略了EBCDIC的可能性。对于几乎所有目的，差异都是透明的。例如，在EBCDIC下，使用UTF-EBCDIC而不是UTF-8来编码Unicode字符串，因此，每当本文档引用 &lt;code&gt;utf8&lt;/code&gt; （以及该名称的变体，包括函数名称）时，它也（实质上透明）表示 &lt;code&gt;UTF-EBCDIC&lt;/code&gt; 。但是，ASCII，EBCDIC和UTF编码之间的字符序号有所不同，并且以UTF-EBCDIC编码的字符串所占的字节数可能与使用UTF-8的字节数不同。</target>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">请注意,Perl认为词素簇是独立的字符,所以例如</target>
        </trans-unit>
        <trans-unit id="29139db0e01423398a38202c816ab0163a1e630a" translate="yes" xml:space="preserve">
          <source>Note that Perl does Full case-folding in matching, not Simple:</source>
          <target state="translated">需要注意的是,Perl 在匹配中采用的是 Full case-folding,而不是 Simple。</target>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">需要注意的是,Perl并没有使用COMSPEC,因为COMSPEC在用户之间的差异性很大,导致了可移植性的问题。此外,Perl可以使用一个可能不适合交互式使用的shell,将COMSPEC设置为这样的shell可能会干扰其他程序的正常运行(这些程序通常在COMSPEC中寻找适合交互式使用的shell)。</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">请注意,Perl 支持最多只传递 14 个参数到你的 syscall 中,这在实践中应该(通常)已经足够了。</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">请注意，仅当OS / 2无法启动指定的应用程序时，Perl才会开始查找脚本，因此，如果存在可执行文件，则 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; 将不查找脚本</target>
        </trans-unit>
        <trans-unit id="44957b723edd6e235f882ee4085c7777338d3275" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;system 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">请注意，仅当OS / 2无法启动指定的应用程序时，Perl才会开始查找脚本，因此，如果存在可执行文件，则 &lt;code&gt;system 'blah'&lt;/code&gt; 将不查找脚本</target>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">请注意，Pod作者可以在&amp;ldquo; L &amp;lt;text | name&amp;gt;&amp;rdquo;的&amp;ldquo; text&amp;rdquo;部分内使用格式代码（对于L &amp;lt;text | /&amp;ldquo; sec&amp;rdquo;&amp;gt;依此类推）。</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">需要注意的是,RFC 1951数据并不是单独使用压缩格式的好选择,尤其是当你想自动检测的时候。</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">注意,SHA-1和SHA-2使用的是</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">注意,TODO测试</target>
        </trans-unit>
        <trans-unit id="40402ed7efd78d7a86f48194a3b6516e77f57a23" translate="yes" xml:space="preserve">
          <source>Note that Test::Builder ensures that any diagnostics end in a \n and it in earlier versions of Test::Tester it was essential that you have the final \n in your expected diagnostics. From version 0.10 onward, Test::Tester will add the \n if you forgot it. It will not add a \n if you are expecting no diagnostics. See below for help tracking down hard to find space and tab related problems.</source>
          <target state="translated">请注意 Test::Builder 确保任何诊断程序都以 \n 结尾,在 Test::Tester 的早期版本中,你必须在你的预期诊断程序中加入最后的 \n。从0.10版本开始,Test::Tester会在你忘记的情况下增加一个&quot;/&quot;。如果你没有预期的诊断程序,它将不会添加\n。请看下面的帮助,以追踪难以找到的空间和标签相关的问题。</target>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">请注意,Tie::File 只会关闭它在内部打开的任何文件柄。如果你像上面一样传递给它一个文件柄,你就 &quot;拥有 &quot;这个文件柄,并负责在你解开 @array 的绑定后关闭它。</target>
        </trans-unit>
        <trans-unit id="0bba5758898958160c86aa3ac20956cb9f092bfd" translate="yes" xml:space="preserve">
          <source>Note that Vietnamese is listed above. Also read &quot;Encoding vs Charset&quot; below. Also note that these are implemented in distinct modules by countries, due to the size concerns (simplified Chinese is mapped to 'CN', continental China, while traditional Chinese is mapped to 'TW', Taiwan). Please refer to their respective documentation pages.</source>
          <target state="translated">请注意,上面列出的是越南语。也请阅读下面的 &quot;编码与字符集&quot;。另外请注意,由于规模的问题,这些都是在不同的国家模块中实现的(简体中文被映射到'CN',中国大陆,而繁体中文被映射到'TW',台湾)。请参考它们各自的文档页面。</target>
        </trans-unit>
        <trans-unit id="6817ce7211b8227d70ebd744addb1493f99a5309" translate="yes" xml:space="preserve">
          <source>Note that [= =] and [. .] are not currently implemented; they are simply placeholders for future extensions and will cause fatal errors. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">请注意[= =]和[。。]当前未实现；它们只是未来扩展的占位符，将导致致命错误。&amp;lt;-HERE在正则表达式中显示发现问题的行踪。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">请注意,&quot;=begin</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">请注意，空白行中不能有空白。因此， &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; 是一个段落，而 &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; 是两个段落。</target>
        </trans-unit>
        <trans-unit id="06686ad7be28b42e56c1b53fdf5f7299621f801d" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt;可以用于使此类块提前退出。</target>
        </trans-unit>
        <trans-unit id="c6af33f5ad0150d9ac083cf6a5c7a2b96b3db24b" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will exit such a block early.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;将尽早退出此类障碍。</target>
        </trans-unit>
        <trans-unit id="a98374e4e319a2a54ea762e6c2ec205f5e2e7d62" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，在这样的块内&lt;a href=&quot;#redo-LABEL&quot;&gt; &lt;code&gt;redo&lt;/code&gt; &lt;/a&gt;将有效地将其变成循环构造。</target>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 可以用于使此类块提前退出。</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 将尽早退出此类障碍。</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，在这样的块内 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 将有效地将其变成循环构造。</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 可以用于使此类块提前退出。</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 将尽早退出此类障碍。</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，在这样的块内 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 将有效地将其变成循环构造。</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">请注意,以八进制转义表示的字符被 regex 引擎认为是没有特殊意义的字符,将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">请注意,用这些转义词表示的字符被regex引擎认为是一个没有特殊含义的字符,并将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">需要注意的是,以命名或编号字符表示的字符或字符序列,在regex引擎中被认为是没有特殊含义的字符,将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="1aed6736ceb1599c4759de82b494ba581fec4d4a" translate="yes" xml:space="preserve">
          <source>Note that a comment can go just about anywhere, except in the middle of an escape sequence. Examples:</source>
          <target state="translated">请注意,注释可以放在任何地方,除了在转义序列的中间。例子:</target>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">请注意,一个格式以字母 &quot;a &quot;开头,如果且仅有它的属性需要通过添加多元素范围内的偏移量来调整。对于所有这些属性,只有当映射是一个整数的标量时,才应该调整一个条目。也就是说,它必须符合正则表达式。</target>
        </trans-unit>
        <trans-unit id="1afc508afbed8c0f7ac0e4b478337da8478bd121" translate="yes" xml:space="preserve">
          <source>Note that a parser is not expected to distinguish between something that looks like pod, but is in a quoted string, such as a here document.</source>
          <target state="translated">请注意,解析器不应该区分看起来像pod,但却在一个引号字符串中的东西,如here文档。</target>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">需要注意的是,可以通过数值运算使标量同时具有字符串和数值内容。</target>
        </trans-unit>
        <trans-unit id="7e66da593ccdd13e9412f5c3278043542df9a102" translate="yes" xml:space="preserve">
          <source>Note that a server that is also a domain controller is reported as PRODUCTTYPE 2 (Domaincontroller) and not PRODUCTTYPE 3 (Server).</source>
          <target state="translated">请注意,同时也是域控制器的服务器被报告为PRODUCTTYPE 2(域控制器),而不是PRODUCTTYPE 3(服务器)。</target>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">请注意,共享变量可以保证如果两个或多个线程同时尝试修改它,变量的内部状态不会被破坏。但是,除此之外没有任何保证,这将在下一节中解释。</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">请注意，上面的副作用是 &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 不再输出。这是由于 &lt;code&gt;Exporter&lt;/code&gt; 模块的工作方式。如果要迁移代码库以使用新界面，则必须明确列出所有内容。但这毕竟是一个好习惯。</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">请注意,根据 POSIX 1003.1-1996,FILENAME 可以有任意数量的斜杠。有些操作系统和文件系统并没有做到这一点,所以Perl会自动删除所有的尾部斜杠,以保证大家都满意。</target>
        </trans-unit>
        <trans-unit id="128d061a1fa86fd129c7cba87a1e4d16eaa8deb7" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">请注意，所有C程序（包括用C编写的perl解释器）始终具有基础语言环境。该语言环境是&amp;ldquo; C&amp;rdquo;语言环境，除非通过调用&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;进行了更改。当Perl启动时，它将基础语言环境更改为&lt;a href=&quot;#ENVIRONMENT&quot;&gt;&amp;ldquo;环境&amp;rdquo;&lt;/a&gt;指示的语言环境。使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块或编写XS代码时，请记住，即使程序未明确更改基础语言环境，也可能是&amp;ldquo; C&amp;rdquo;以外的语言。</target>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">请注意，所有C程序（包括用C编写的perl解释器）始终具有基础语言环境。该语言环境是&amp;ldquo; C&amp;rdquo;语言环境，除非通过调用&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;进行了更改。当Perl启动时，它将基础语言环境更改为&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;指示的语言环境。使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块或编写XS代码时，请记住，即使程序未明确更改基础语言环境，也可能是&amp;ldquo; C&amp;rdquo;以外的语言。</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">请注意，所有Perl API全局变量都必须使用 &lt;code&gt;PL_&lt;/code&gt; 前缀引用。同样，此处未列出的扩展程序切勿由扩展程序编写人员使用，并且可以在不另行通知的情况下进行更改或删除。与宏相同。提供了一些宏来与较旧的未经修饰的名称兼容，但是在将来的发行版中可能会禁用此支持。</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">注意,所有的访问都是只读的。你不能通过使用这个模块来修改内部结构。另外,请注意本模块创建的 B::OP 和 B::SV 对象只有在底层对象存在的时候才有效;它们的创建不会增加底层对象的引用次数。试图访问一个被释放的对象的字段会得到难以理解的结果,甚至更糟。</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">请注意,在显示以下简称时,所有非必要的下划线都会被删除。</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">请注意，以上所有内容在 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 范围内都被覆盖；但您应该仅将此杂注用于调试。</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">需要注意的是,%result的所有更新都是加法的,使用前不会清空哈希值,因此可以方便地将很多安装的状态结果进行汇总。</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">请注意，我们在此快速概述中所描述的只是使用&lt;b&gt;Pod :: Parser&lt;/b&gt;最简单，最直接的方法来进行基于流的解析。也可以使用&lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt;函数执行更复杂的基于树的解析。请参阅&lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;基于树的解析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31e72345bf22d6545d4882f14a8418945d8ea12a" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. But there are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt;s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt;, both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;.</source>
          <target state="translated">请注意，几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。但是有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。 （这两个集合之间的区别是，某些东西（例如罗马数字）同时以大写和小写形式出现，因此它们是 &lt;code&gt;Cased&lt;/code&gt; ，但不视为字母，因此不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。它们实际上是 &lt;code&gt;Letter_Number&lt;/code&gt; 。）此集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都在 &lt;code&gt;/i&lt;/code&gt; 下与 &lt;code&gt;PosixAlpha&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">请注意，几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。 （这两个集合之间的区别在于，某些东西（例如罗马数字）同时使用大写和小写形式，因此它们是 &lt;code&gt;Cased&lt;/code&gt; ，但不视为字母，因此不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。它们实际上是 &lt;code&gt;Letter_Number&lt;/code&gt; 。）此集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都在 &lt;code&gt;/i&lt;/code&gt; 下与 &lt;code&gt;PosixAlpha&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="410bccdb373a09459be0a143786fbdbb58b254bf" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be a dual-valued variable, it is actually implemented as a magical variable inside the interpreter:</source>
          <target state="translated">注意，虽然 &lt;code&gt;$!&lt;/code&gt; 似乎是一个双值变量，它实际上是在解释器内部实现的一个神奇变量：</target>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">注意，虽然 &lt;code&gt;$!&lt;/code&gt; 似乎是双值变量，它实际上是使用绑定标量实现的：</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">请注意,&quot;=over&quot;...&quot;=back &quot;区域应该有一些内容。&quot;=back &quot;区域应该有一些内容。也就是说,作者不应该有一个像这样的空区域。</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">请注意,一个INVARIANT字符(即非EBCDIC机器上的ASCII字符)是一个有效的UTF-8字符。</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">请注意,因为 &quot;使用vmsish &quot;而被编译成 &quot;hashhed &quot;的exit()或die(),在运行时调用vmsish::hashhed(0)并不能解除hush。</target>
        </trans-unit>
        <trans-unit id="81d903b0a8613702e9500c6611625b2061527ec5" translate="yes" xml:space="preserve">
          <source>Note that an implication of this form is that there are identifiers only legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, and vice-versa, for example the identifier &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; is legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, but is otherwise considered to be the single character variable &lt;code&gt;$&amp;eacute;&lt;/code&gt; followed by the bareword &lt;code&gt;&quot;tat&quot;&lt;/code&gt;, the combination of which is a syntax error.</source>
          <target state="translated">请注意，这种形式的含义是，在 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 下仅存在合法的标识符，反之亦然，例如，标识符&amp;ldquo; &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 在&amp;ldquo; use utf8&amp;rdquo;下是合法的，但否则被认为是单个字符变量 &lt;code&gt;$&amp;eacute;&lt;/code&gt; 后跟裸字 &lt;code&gt;&quot;tat&quot;&lt;/code&gt; ，两者的组合是语法错误。</target>
        </trans-unit>
        <trans-unit id="a51bafab03bc7a99a9ff353e9d7023e5249a4ecb" translate="yes" xml:space="preserve">
          <source>Note that any &lt;code&gt;()&lt;/code&gt; constructs enclosed within this one will still capture unless the &lt;code&gt;/n&lt;/code&gt; modifier is in effect.</source>
          <target state="translated">请注意，除非有效 &lt;code&gt;/n&lt;/code&gt; 修饰符，否则包含在其中的任何 &lt;code&gt;()&lt;/code&gt; 构造仍将捕获。</target>
        </trans-unit>
        <trans-unit id="76d96be8f0f46d40e0807e85460543821cad6f82" translate="yes" xml:space="preserve">
          <source>Note that any filehandle being printed to under UTF-8 must be expecting UTF-8 in order to get good results and avoid Wide-character warnings. One way to do this for typical filehandles is to invoke perl with the &lt;code&gt;-C&lt;/code&gt;&amp;gt; parameter. (See &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;-C [number/list]&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">请注意，在UTF-8下打印到的任何文件句柄都必须使用UTF-8，以便获得良好的结果并避免出现宽字符警告。对典型文件句柄执行此操作的一种方法是使用 &lt;code&gt;-C&lt;/code&gt; &amp;gt;参数调用perl 。 （请参阅&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun中的&amp;ldquo; -C [数字/列表]&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">请注意，本文档（或&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;）中未记录的任何变量和函数仅供内部使用，因此如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">请注意，本手册页（或&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;）中未记录的任何变量和函数仅供内部使用，因此如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;\Q...\E&lt;/code&gt; 中的任何内容均不受 &lt;code&gt;/x&lt;/code&gt; 的影响。并注意 &lt;code&gt;/x&lt;/code&gt; 不会影响单个多字符构造中的空间解释。例如，在 &lt;code&gt;\x{...}&lt;/code&gt; ，无论使用 &lt;code&gt;/x&lt;/code&gt; 修饰符如何，都不能有空格。对于诸如 &lt;code&gt;{3}&lt;/code&gt; 或 &lt;code&gt;{5,}&lt;/code&gt; 之类的&lt;a href=&quot;#Quantifiers&quot;&gt;量词也是&lt;/a&gt;如此。同样， &lt;code&gt;(?:...)&lt;/code&gt; 在 &lt;code&gt;(&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 之间不能有空格。在此类构造的任何分隔符内，允许的空间不受 &lt;code&gt;/x&lt;/code&gt; 的影响，而是取决于构造。例如， &lt;code&gt;\x{...}&lt;/code&gt; 不能有空格，因为十六进制数字中没有空格。但是，Unicode属性可以包含空格，因此在 &lt;code&gt;\p{...}&lt;/code&gt; 中可以存在遵循Unicode规则的空格，有关这些&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;属性&lt;/a&gt;，请参见perluniprops中可通过\ p {}和\ P {}访问的属性。</target>
        </trans-unit>
        <trans-unit id="f395c3581775a33605e1a803ed3454f86e6d0f9b" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt;, regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt;. Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;?&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;\Q...\E&lt;/code&gt; 中的任何内容均不受 &lt;code&gt;/x&lt;/code&gt; 的影响。并注意 &lt;code&gt;/x&lt;/code&gt; 不会影响单个多字符构造中的空间解释。例如，在 &lt;code&gt;\x{...}&lt;/code&gt; ，无论使用 &lt;code&gt;/x&lt;/code&gt; 修饰符如何，都不能有空格。对于诸如 &lt;code&gt;{3}&lt;/code&gt; 或 &lt;code&gt;{5,}&lt;/code&gt; 之类的&lt;a href=&quot;#Quantifiers&quot;&gt;量词也是&lt;/a&gt;如此。同样， &lt;code&gt;(?:...)&lt;/code&gt; 在 &lt;code&gt;&quot;(&quot;&lt;/code&gt; ， &lt;code&gt;&quot;?&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 之间不能有空格。在此类构造的任何分隔符中，允许的空间不受 &lt;code&gt;/x&lt;/code&gt; 的影响，并且取决于构造，例如 &lt;code&gt;\x{...}&lt;/code&gt; 不能有空格，因为十六进制数字中没有空格。但是，Unicode属性可以有空格，因此在 &lt;code&gt;\p{...}&lt;/code&gt; 中可以有遵循Unicode规则的空格，有关这些空格，请参见&lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;perluniprops中的&amp;ldquo;可通过\ p {}和\ P {}访问的属性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">请注意，从Perl 5.14开始， &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; 会将命名序列插入双引号字符串中，而 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; 将返回此函数执行的相同字符串，但是还可以对未命名的字符名称进行操作，而无需知道哪些字符。请参阅&lt;a href=&quot;../charnames&quot;&gt;字符名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27d84df2d91f0e561094d3cfef990178b71accb1" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">请注意，从Perl 5.14开始， &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; 会将命名的序列插入双引号字符串中，并且 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; 将返回此函数执行的相同字符串，但是会还可以对未命名的字符名称进行操作，而无需知道哪些字符。请参阅&lt;a href=&quot;charnames&quot;&gt;字符名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">请注意,从Perl 5.20开始,变量名中的控制字符将被取消;从Perl 5.22开始,任何其他非图形字符也将被取消。</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">注意,atan2(0,0)的定义并不明确。</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">注意，一旦检测到属性（即在执行任何后续定义的 &lt;code&gt;BEGIN&lt;/code&gt; 块之前），便会立即处理为 &lt;code&gt;BEGIN&lt;/code&gt; 阶段安排的属性处理程序。</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">请注意，由于&lt;b&gt;-i&lt;/b&gt;在创建具有相同名称的新文件之前会重命名或删除原始文件，因此将不会保留Unix样式的软链接和硬链接。</target>
        </trans-unit>
        <trans-unit id="b8849f4f72b8ea78a7d87446400823a7e27b0cb3" translate="yes" xml:space="preserve">
          <source>Note that because how the floating point formats work out, on the most common platforms signaling payload of zero is best avoided, since it might end up being identical to &lt;code&gt;+Inf&lt;/code&gt;.</source>
          <target state="translated">请注意，因为浮点格式是如何工作的，所以在最常见的平台上，最好避免发送零载荷的信号，因为最终可能与 &lt;code&gt;+Inf&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">请注意，由于多个扩展可能正在使用 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 或 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术，因此，扩展必须格外小心以避免冲突，这一点很重要。通常，仅对具有扩展名的对象使用魔法就足够了。对于 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 魔术，通常最好定义一个 &lt;code&gt;MGVTBL&lt;/code&gt; ，即使其所有字段都为 &lt;code&gt;0&lt;/code&gt; ，也可以使用其魔术虚拟表将各个 &lt;code&gt;MAGIC&lt;/code&gt; 指针识别为一种特殊的魔术。 &lt;code&gt;mg_findext&lt;/code&gt; 提供了一种简单的方法：</target>
        </trans-unit>
        <trans-unit id="cd112df3b0c7a62a90b0cf37e126e846a5257960" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt;, even if all its fields will be &lt;code&gt;0&lt;/code&gt;, so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">请注意，由于多个扩展可能正在使用 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 或 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术，因此，扩展必须格外小心以避免冲突，这一点很重要。通常，仅对具有扩展名的对象使用魔法就足够了。对于 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 魔术，通常最好定义一个 &lt;code&gt;MGVTBL&lt;/code&gt; ，即使其所有字段均为 &lt;code&gt;0&lt;/code&gt; ，也可以使用其魔术虚拟表将单个 &lt;code&gt;MAGIC&lt;/code&gt; 指针识别为一种特殊的魔术。 &lt;code&gt;mg_findext&lt;/code&gt; 提供了一种简单的方法：</target>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">请注意，由于愚蠢的OS / 2限制，当您使用 &lt;code&gt;extproc&lt;/code&gt; 时，perl脚本的完整路径不可用，因此您不得不使用 &lt;code&gt;-S&lt;/code&gt; perl开关，并且脚本应位于 &lt;code&gt;PATH&lt;/code&gt; 上。顺带一提，如果您知道脚本的完整路径，则仍可以使用</target>
        </trans-unit>
        <trans-unit id="c787f61f07dfdba933460c5bff80047d250cdab7" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt;, thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt;. As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">请注意，由于愚蠢的OS / 2限制，当您使用 &lt;code&gt;extproc&lt;/code&gt; 时，perl脚本的完整路径不可用，因此您不得不使用 &lt;code&gt;-S&lt;/code&gt; perl开关，并且脚本应位于 &lt;code&gt;PATH&lt;/code&gt; 上。顺带一提，如果您知道脚本的完整路径，则仍可以使用</target>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">请注意,因为这个渲染是在一个非线程的perl上完成的,所以前面例子中的PADOPs现在变成了SVOPs,一些(但不是全部)方括号被替换成了圆括号。这是一个微妙的功能,为线程和非线程perl上的渲染提供了一些视觉上的区别。</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">请注意,因为我们是在实数的近似值上进行操作,所以当仅仅是 &quot;太接近 &quot;上面列出的奇点时,就会发生这些错误。</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">请注意，Perl中的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 均使用C中的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 直接实现。如果强制 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; （请参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;），则使用带符号的C整数，否则使用无符号的C整数。无论哪种方式，实现都不会产生比Perl所构建的整数类型（32位或64位）大的结果。</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">请注意， &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 都不会增加存储的 &lt;code&gt;val&lt;/code&gt; 的引用计数，这是调用者的责任。如果这些函数返回NULL值，则调用程序通常将必须减少 &lt;code&gt;val&lt;/code&gt; 的引用计数，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="621c69fc1e5d56916169e38ace21016b25be56a4" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt;, which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">请注意， &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 都不会增加存储的 &lt;code&gt;val&lt;/code&gt; 的引用计数，这是调用者的责任。如果这些函数返回NULL值，则调用方通常将必须减少 &lt;code&gt;val&lt;/code&gt; 的引用计数，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">请注意,这两个路径都被假定为有一个符号来区分目录路径(带尾部':')和文件路径(不带尾部':')。</target>
        </trans-unit>
        <trans-unit id="faee99938a7847d18bb03c4600be6dd36dc0274e" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the</source>
          <target state="translated">请注意， &lt;code&gt;CanonicalName&lt;/code&gt; 和 &lt;code&gt;FilterName&lt;/code&gt; 选项都可以修改用于</target>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">请注意， &lt;code&gt;CanonicalName&lt;/code&gt; 和 &lt;code&gt;FilterName&lt;/code&gt; 选项都可以修改用于zip文件名标头字段的值。</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">请注意，bsd_glob（）通过不将 &lt;code&gt;ENOENT&lt;/code&gt; 和 &lt;code&gt;ENOTDIR&lt;/code&gt; 视为错误而偏离了POSIX和FreeBSD glob（3）行为-尽管存在这些错误，bsd_glob（）仍将继续处理，除非设置了 &lt;code&gt;GLOB_ERR&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="bacd6d900d14ad3f25c92e37f8d7ca4d2e6dc3f9" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; on array values is strongly discouraged.</source>
          <target state="translated">请注意，强烈建议不要对数组值调用&lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c998cb784e028342e5006462f8a42c5345c1974" translate="yes" xml:space="preserve">
          <source>Note that calls to the platform's underlying &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function may block. If &lt;code&gt;IO::Socket::IP&lt;/code&gt; has to perform this lookup, the constructor will block even when in non-blocking mode.</source>
          <target state="translated">请注意，对该平台的底层 &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 函数的调用可能会阻塞。如果 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 必须执行此查找，则即使在非阻塞模式下，构造函数也会阻塞。</target>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">请注意，在递归返回之后无法访问在递归内匹配的捕获组，因此捕获组的额外层是必需的。因此，即使 &lt;code&gt;$+{NAME}&lt;/code&gt; 被定义，也不会定义 &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">请注意，某些幂表达式不明确的：这些包括 &lt;code&gt;0**0&lt;/code&gt; ， &lt;code&gt;1**Inf&lt;/code&gt; ，和 &lt;code&gt;Inf**0&lt;/code&gt; 。不要期望这些特殊情况有任何特定的结果，这些结果取决于平台。</target>
        </trans-unit>
        <trans-unit id="3494a62839407764105a4d292aa5c1e195c2757d" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt;, &lt;code&gt;1**Inf&lt;/code&gt;, and &lt;code&gt;Inf**0&lt;/code&gt;. Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">请注意，某些幂表达式不明确的：这些包括 &lt;code&gt;0**0&lt;/code&gt; ， &lt;code&gt;1**Inf&lt;/code&gt; ，和 &lt;code&gt;Inf**0&lt;/code&gt; 。在这些特殊情况下，不要期望任何特定的结果，这些结果取决于平台。</target>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">请注意,出于向后兼容的原因,128至255(含)的字符默认在内部不被编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="8a46ebdf91483bc350551ae23b26255499157816" translate="yes" xml:space="preserve">
          <source>Note that checking for a &lt;code&gt;%DOES&lt;/code&gt; hash is an &lt;code&gt;autodie&lt;/code&gt;-only short-cut. Other modules do not use this mechanism for checking roles, although you can use the &lt;code&gt;Class::DOES&lt;/code&gt; module from the CPAN to allow it.</source>
          <target state="translated">请注意，检查 &lt;code&gt;%DOES&lt;/code&gt; 哈希是仅 &lt;code&gt;autodie&lt;/code&gt; 的快捷方式。尽管您可以使用CPAN中的 &lt;code&gt;Class::DOES&lt;/code&gt; 模块来允许它，但是其他模块不使用此机制来检查角色。</target>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">请注意，不支持 &lt;code&gt;GNU Extended Header&lt;/code&gt; 功能的客户端将无法读取这些档案。这些客户端包括 &lt;code&gt;Solaris&lt;/code&gt; ， &lt;code&gt;Irix&lt;/code&gt; 和 &lt;code&gt;AIX&lt;/code&gt; 上的tar。</target>
        </trans-unit>
        <trans-unit id="aae32a0db7b8c17096153a5cf305d70abda69477" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt;, &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt;.</source>
          <target state="translated">请注意，不支持 &lt;code&gt;GNU Extended Header&lt;/code&gt; 功能的客户端将无法读取这些档案。这样的客户端包括 &lt;code&gt;Solaris&lt;/code&gt; ， &lt;code&gt;Irix&lt;/code&gt; 和 &lt;code&gt;AIX&lt;/code&gt; 上的tar。</target>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">请注意,代码6(快速闪烁)和代码9(击穿)在ANSI X3.64和ECMA-048中指定,但大多数显示器和仿真器通常不支持,因此目前本模块不支持。ECMA-048还指定了大量的其他属性,包括字体变化、Fraktur字符、双下划线、框架、圈点和加线的一系列属性。由于这些属性都没有得到广泛的支持或有用,所以目前本模块也不支持这些属性。</target>
        </trans-unit>
        <trans-unit id="d50e349cf31b07ee4610e705d5521fb0f229097d" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">请注意,代码6(快速闪烁)和代码9(击穿)在ANSI X3.64和ECMA-048中指定,但大多数显示器和仿真器通常不支持,因此本模块不支持。ECMA-048还指定了大量的其他属性,包括字体变化、Fraktur字符、双下划线、框架、圈点和覆盖线的属性序列。由于这些属性都没有得到广泛的支持或有用,所以目前本模块也不支持这些属性。</target>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">请注意，将任意标量强制转换为纯PV可能会从中剥离有用数据。例如，如果SV是 &lt;code&gt;SvROK&lt;/code&gt; ，那么将减少引用对象的引用计数，并且可以将SV本身转换为带有包含诸如 &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; 的值的字符串缓冲区的 &lt;code&gt;SvPOK&lt;/code&gt; 标量。</target>
        </trans-unit>
        <trans-unit id="a47c04c6a9f8c8144c760b18adcdfe977bf88a30" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt;, then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，将任意标量强制转换为纯PV可能会从中剥离有用数据。例如，如果SV是 &lt;code&gt;SvROK&lt;/code&gt; ，那么将增加引用对象的引用计数，并且SV本身可以使用包含诸如 &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; 的值的字符串缓冲区转换为 &lt;code&gt;SvPOK&lt;/code&gt; 标量。</target>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">请注意，connected（）认为半开式TCP套接字处于&amp;ldquo;已连接状态&amp;rdquo;。具体来说，connected（）不能区分&lt;b&gt;ESTABLISHED&lt;/b&gt;和&lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP状态。无论哪种情况，它都返回对等地址，而不是undef。因此，通常，connected（）不能用于可靠地了解对等方是否已启动正常关机，因为在大多数情况下（请参见下文），本地TCP状态机仍处于&lt;b&gt;CLOSE-WAIT&lt;/b&gt;状态，直到本地应用程序调用shutdown（）或close （）;仅在那时，connected（）才返回undef。</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">请注意,目前一些测试脚本在并行运行时可能会失败(最明显的是</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">请注意,define_alias()将不能覆盖编码的规范名。在尝试潜在的别名之前,编码会先按规范名查找。</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">请注意,尽管存在这个opag,但只使用:base_core ops仍然可以进行内存资源攻击。</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">请注意,点(</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">请注意,由于过度的偏执,如果$Getopt::Std::STANDARD_HELP_VERSION不是true(默认为false),那么消息会被打印在STDERR上,并且在消息被打印后继续处理。这与符合标准的行为相反,强烈建议将 $Getopt::Std::STANDARD_HELP_VERSION 设置为 true。</target>
        </trans-unit>
        <trans-unit id="f123bfd592be78aee28a3c608d5e5a65fa7978a4" translate="yes" xml:space="preserve">
          <source>Note that due to how &lt;code&gt;%^H&lt;/code&gt; works, some of these utilities are only useful during the compilation phase of a perl module and relies on the internals of how perl handles references in &lt;code&gt;%^H&lt;/code&gt;.</source>
          <target state="translated">请注意，由于 &lt;code&gt;%^H&lt;/code&gt; 工作方式，其中一些实用程序仅在perl模块的编译阶段有用，并且依赖于perl处理 &lt;code&gt;%^H&lt;/code&gt; 引用的内部方式。</target>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">注意，每个 &lt;code&gt;pp_&lt;/code&gt; 函数都应返回一个指向下一个op的指针。对perl子程序（和eval块）的调用在同一runops循环中处理，并且不占用C堆栈上的额外空间。例如， &lt;code&gt;pp_entersub&lt;/code&gt; 和 &lt;code&gt;pp_entertry&lt;/code&gt; 只是将 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; 块结构推入上下文堆栈，其中包含子调用或eval之后的op地址。然后，它们返回该子块或eval块的第一个操作，因此该子块或eval的执行继续。稍后， &lt;code&gt;pp_leavesub&lt;/code&gt; 或 &lt;code&gt;pp_leavetry&lt;/code&gt; op弹出 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; ，从中检索返回op，然后将其返回。</target>
        </trans-unit>
        <trans-unit id="88c1f48b446d24b42913aa2c3b31a8759cf531cc" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt;, retrieves the return op from it, and returns it.</source>
          <target state="translated">请注意，每个 &lt;code&gt;pp_&lt;/code&gt; 函数都应返回一个指向下一个op的指针。对perl子程序（和eval块）的调用在同一个runops循环中处理，并且不占用C堆栈上的额外空间。例如， &lt;code&gt;pp_entersub&lt;/code&gt; 和 &lt;code&gt;pp_entertry&lt;/code&gt; 只是将 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; 块结构推入上下文堆栈，其中包含子调用或eval之后的op地址。然后，它们返回该子块或eval块的第一个操作，因此继续执行该子块或eval块。稍后， &lt;code&gt;pp_leavesub&lt;/code&gt; 或 &lt;code&gt;pp_leavetry&lt;/code&gt; op弹出 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; ，从中检索返回op，然后将其返回。</target>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">请注意，当您将它们称为 &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; &lt;i&gt;what（value）&lt;/i&gt;时，它们都将返回 &lt;code&gt;$self&lt;/code&gt; 。这样一来，您就可以像这样将设置属性调用链接在一起：&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">请注意,尽管SunOS和Solaris是二进制兼容的,但这些值是不同的。去想吧。</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">请注意，由于不区分大小写的 &lt;code&gt;/i&lt;/code&gt; 正则表达式匹配而导致的失败的大小写转换操作将在此警告中显示为具有 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 操作（正则表达式引擎在后台调用该操作）。</target>
        </trans-unit>
        <trans-unit id="50700c4c785fb49bbf6b2d46cdd32517f497bd69" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;fc&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">请注意，由于不区分大小写的 &lt;code&gt;/i&lt;/code&gt; 正则表达式匹配而导致的失败的大小写转换操作将在此警告中显示为具有 &lt;code&gt;fc&lt;/code&gt; 操作（这是正则表达式引擎在后台调用的内容）。</target>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">请注意，冲洗会严重降低压缩率，因此只能用于终止解压缩（使用 &lt;code&gt;Z_FINISH&lt;/code&gt; ）或要创建压缩文件时使用。</target>
        </trans-unit>
        <trans-unit id="4b30f403949fb025e96fa50a8f6344798f310af3" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt;) or when you want to create a</source>
          <target state="translated">请注意，冲洗会严重降低压缩率，因此只能用于终止解压缩（使用 &lt;code&gt;Z_FINISH&lt;/code&gt; ）或要创建压缩文件时使用。</target>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">请注意，对于控制字符（ &lt;code&gt;Gc=cc&lt;/code&gt; ），Unicode的数据文件具有字符串&amp;ldquo; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &amp;rdquo;，但是每个字符的真实名称都是空字符串。此函数返回该真实名称，即空字符串。（这些字符有名称，但它们被视为别名，而不是Name属性名称，并包含在 &lt;code&gt;Name_Alias&lt;/code&gt; 属性中。）</target>
        </trans-unit>
        <trans-unit id="f8932792e5f906f3f8b41da393da4b0b602a3cd6" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt;), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt;&quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">请注意，对于控制字符（ &lt;code&gt;Gc=cc&lt;/code&gt; ），Unicode的数据文件具有字符串&amp;ldquo; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &amp;rdquo;，但是每个字符的真实名称都是空字符串。此函数返回该真实名称，即空字符串。（这些字符有名称，但它们被视为别名，而不是Name属性名称，并包含在 &lt;code&gt;Name_Alias&lt;/code&gt; 属性中。）</target>
        </trans-unit>
        <trans-unit id="bc65a24a4a2d5395b160b7910a7ec94be07f4893" translate="yes" xml:space="preserve">
          <source>Note that for example the Series 60 2.0 VC SDK installation talks about ActivePerl build 518, which does no more (as of mid-2005) exist at the ActiveState website. The ActivePerl 5.8.4 build 810 was used successfully for compiling Perl on Symbian. The 5.6.x ActivePerls do not work.</source>
          <target state="translated">请注意,例如Series 60 2.0 VC SDK安装中提到的ActivePerl build 518,在ActiveState网站上已经不存在了(2005年中)。ActivePerl 5.8.4 build 810被成功用于在Symbian上编译Perl。5.6.x的ActivePerl不能用。</target>
        </trans-unit>
        <trans-unit id="0ed7cbcc3a273da5d5e361c4e690dfc2af7612b3" translate="yes" xml:space="preserve">
          <source>Note that for internal reasons, all precompiled regexps (&lt;code&gt;qr/.../&lt;/code&gt;) are blessed references; thus &lt;code&gt;ref()&lt;/code&gt; returns the package name string &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; on these but &lt;code&gt;reftype()&lt;/code&gt; will return the underlying C structure type of &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; in all capitals.</source>
          <target state="translated">请注意，由于内部原因，所有预编译的正则表达式（ &lt;code&gt;qr/.../&lt;/code&gt; ）都是带修饰符的引用；因此， &lt;code&gt;ref()&lt;/code&gt; 返回这些包名称字符串 &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; ，但是 &lt;code&gt;reftype()&lt;/code&gt; 将返回所有大写形式的基础C结构类型 &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">需要注意的是,对于较大的位串,使用两个参数的版本会更有效率。</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">请注意，对于更简单的测试要求，通常可以通过一次调用 &lt;code&gt;runtests&lt;/code&gt; 来替换上述代码。</target>
        </trans-unit>
        <trans-unit id="0d204c8dce6be8d36767ba5943e30dba9a432c61" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt;.</source>
          <target state="translated">请注意，对于更简单的测试要求，通常可以通过单次调用 &lt;code&gt;runtests&lt;/code&gt; 来替换上述代码。</target>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">请注意，对于 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; （无穷大且不是数字），&amp;ldquo;数字&amp;rdquo;的定义有些不寻常：字符串本身（如&amp;ldquo; Inf&amp;rdquo;）被视为数字，而其后的任何内容均被视为非数字。</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">请注意,格式会被当作昂子,每次调用write时都会被克隆(如果需要的话)。</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">请注意,冻结一个对象结构并立即解冻,实际上实现了对该结构的深度克隆。</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">请注意，从&lt;a href=&quot;../bigint&quot;&gt;Math :: BigInt&lt;/a&gt; v1.76开始，如果可能，将自动加载FastCalc。</target>
        </trans-unit>
        <trans-unit id="8d38bae54b038eb6f174267d0d214d08b91f6765" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">请注意，在大型DBM文件上使用&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;功能时，它们可能会返回巨大的列表。您可能更喜欢使用&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;函数来迭代大型DBM文件。例子：</target>
        </trans-unit>
        <trans-unit id="cded70f7d04a11712cae33c05ba272338aaac47b" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over such. Example:</source>
          <target state="translated">请注意，在大型对象（例如DBM文件）上使用&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;函数时，它们可能会返回巨大的列表。您可能更喜欢使用&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;函数来对此进行迭代。例子：</target>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">请注意，在大型DBM文件上使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 功能时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来迭代大型DBM文件。例：</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">请注意，在大型对象（如DBM文件）上使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来对此进行迭代。例：</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">请注意，在大型DBM文件上使用 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 功能时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来迭代大型DBM文件。例：</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">请注意，在大型对象（如DBM文件）上使用 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来对此进行迭代。例：</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">请注意,当对大型对象(如 DBM 文件)使用诸如 keys()和 values()等函数时,可能会返回巨大的列表。你可能更喜欢使用each()函数来遍历这样的对象。例子:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">请注意，glibc版本2.17之前的glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 等存在错误。如果程序的当前基础语言环境是UTF-8，则它们将不允许精度为 &lt;code&gt;%.s&lt;/code&gt; 的格式创建不是有效UTF-8的字符串。发生的是， &lt;code&gt;%s&lt;/code&gt; 及其操作数只是被跳过而没有任何通知。&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b12e74f81fc8b09d013b39d154bb46d47ab07cc" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">请注意，glibc版本2.17之前的glibc &lt;code&gt;printf()&lt;/code&gt; ， &lt;code&gt;sprintf()&lt;/code&gt; 等存在错误。如果程序的当前基础语言环境为UTF-8，则它们将不允许精度为 &lt;code&gt;%.s&lt;/code&gt; 的格式创建不是有效UTF-8的字符串。发生的是， &lt;code&gt;%s&lt;/code&gt; 及其操作数只是被跳过而没有任何通知。&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">请注意,globbing只会列出明确要求的目录,例如FOO/*不会列出FOO/bar/Acme-Sthg-n.nn.tar.gz。这可能被认为是一个错误,在未来的版本中可能会被修改。</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">请注意，如果 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 需要外部数据才能工作，那么没有它就无法进行子例程调用。例如，标准调试器的 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 取决于 &lt;code&gt;$DB::deep&lt;/code&gt; 变量（它定义了在强制性中断之前可以进入调试器的递归深度的级别）。如果未定义 &lt;code&gt;$DB::deep&lt;/code&gt; ，则即使 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 存在，也无法进行子例程调用。</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">请注意，如果启用了 &lt;code&gt;CanonicalName&lt;/code&gt; ，则将标准化的文件名传递给该子文件。</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">请注意，如果重新编译在 &lt;code&gt;'strict'&lt;/code&gt; 中编译的模式，例如通过插值到 &lt;code&gt;'strict'&lt;/code&gt; 之外的另一个模式，则不会再次检查其严格性。这是因为，如果它在严格条件下工作，则必须在非严格条件下工作。</target>
        </trans-unit>
        <trans-unit id="5ee9a3d19116b2071dbcf7039492ca7c1889754a" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt;, it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">请注意，如果重新编译在 &lt;code&gt;'strict'&lt;/code&gt; 内编译的模式，例如通过插值到 &lt;code&gt;'strict'&lt;/code&gt; 之外的另一个模式，则不会再次检查其严格性。这是因为，如果它在严格的条件下工作，那么必须在非严格的条件下工作。</target>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">请注意，如果字符串参数以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头，则将其视为选项。</target>
        </trans-unit>
        <trans-unit id="b48bf5ef9d46bdb5c44d53b224dcfec68d33eb04" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, it will be considered an option on itself.</source>
          <target state="translated">请注意，如果字符串参数以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头，则将其视为选项。</target>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">请注意，如果将污点字符串添加到 &lt;code&gt;@INC&lt;/code&gt; ，则会报告以下问题：</target>
        </trans-unit>
        <trans-unit id="a96ea078157000b1da678edf47d2488720c25a67" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt;, the following problem will be reported:</source>
          <target state="translated">请注意，如果将污点字符串添加到 &lt;code&gt;@INC&lt;/code&gt; ，则会报告以下问题：</target>
        </trans-unit>
        <trans-unit id="9ab97fe678be0eb16cdcbc59a7f09857930450fc" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. &lt;code&gt;chdir()&lt;/code&gt; out of the directory first before calling &lt;code&gt;cleanup()&lt;/code&gt;. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="translated">请注意，如果临时目录是当前目录，则无法将其删除。 &lt;code&gt;chdir()&lt;/code&gt; 首先移出目录，然后再调用 &lt;code&gt;cleanup()&lt;/code&gt; 。（对于在设置了CLEANUP标志时在程序退出时进行的清除，此操作会自动发生。）</target>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">注意,如果临时目录是你的当前目录,则不能删除。C</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">注意，如果使用初始化的标量变量，结果将不同： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; 禁止这种做法。</target>
        </trans-unit>
        <trans-unit id="fa54ff84091944bfa52d0352fb337bc37692f612" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt;. &lt;code&gt;use strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">请注意，如果使用初始化的标量变量，结果将有所不同： &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; 等同于 &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt; 。 &lt;code&gt;use strict 'refs'&lt;/code&gt; 禁止这种做法。</target>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">请注意，如果为单个POD文档解析了多个文件（也许是将来某个 &lt;code&gt;=include&lt;/code&gt; 指令的结果），则为每个解析的文件调用此方法。如果您希望每个文档执行一次某些初始化，则应使用&lt;b&gt;begin_pod（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">请注意，如果没有遇到错误， &lt;code&gt;$err&lt;/code&gt; 将引用一个空数组。这意味着 &lt;code&gt;$err&lt;/code&gt; 将始终以TRUE结尾；因此，您需要测试 &lt;code&gt;@$err&lt;/code&gt; 以确定是否发生错误。</target>
        </trans-unit>
        <trans-unit id="9bfefb6d862aaaa4bec0b5f0b65d69bbc80cc525" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occurred.</source>
          <target state="translated">请注意，如果没有遇到错误， &lt;code&gt;$err&lt;/code&gt; 将引用一个空数组。这意味着 &lt;code&gt;$err&lt;/code&gt; 将始终以TRUE结尾；因此，您需要测试 &lt;code&gt;@$err&lt;/code&gt; 以确定是否发生了错误。</target>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">需要注意的是,如果测试有一个尾随的计划,就不能为未计划的测试设置这个属性,因为在达到计划之前,我们不知道它是未计划的。</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">请注意，如果缓存是绑定的哈希，则 &lt;code&gt;flush_cache&lt;/code&gt; 将尝试在哈希上调用 &lt;code&gt;CLEAR&lt;/code&gt; 方法。如果没有 &lt;code&gt;CLEAR&lt;/code&gt; 方法，则将导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">请注意，如果已将文件句柄标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则将读取Unicode字符而不是字节（LENGTH，OFFSET和sysread（）的返回值使用Unicode字符）。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。请参见&lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;，&lt;a href=&quot;#open&quot;&gt;打开&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">请注意，如果已将文件句柄标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则将读取Unicode字符而不是字节（LENGTH，OFFSET和sysread（）的返回值使用Unicode字符）。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。请参见&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，&lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c93021972ce0767115d7755bbd49afcf9ee53b" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;sysread&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma.</source>
          <target state="translated">请注意，如果文件句柄已标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则 &lt;code&gt;sysread&lt;/code&gt; 将引发异常。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。请参见&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;编译指示。</target>
        </trans-unit>
        <trans-unit id="d14b0f714c8a186567b6c90a5e0bc13fd3099264" translate="yes" xml:space="preserve">
          <source>Note that if the hostname resolves to multiple address candidates, the same timeout will apply to each connection attempt individually, rather than to the operation as a whole. Further note that the timeout does not apply to the initial hostname resolve operation, if connecting by hostname.</source>
          <target state="translated">请注意,如果主机名解析到多个地址候选者,同样的超时将适用于每个连接尝试,而不是整个操作。进一步注意,如果通过主机名连接,超时时间不适用于初始主机名解析操作。</target>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">请注意,如果输入的文本是一个只读字符串(即文字),则不会尝试删除提取的文本。</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">请注意，如果平台没有可用的或未启用的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 和/或 &lt;code&gt;LC_MONETARY&lt;/code&gt; ，则哈希的相应元素将丢失。</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">需要注意的是,如果正则表达式被污染,那么当子程序的名称由污染的数据决定时,Perl会死掉而不是调用子程序。</target>
        </trans-unit>
        <trans-unit id="fe055d833210baa880117658e3debc03ef9f92ae" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，如果套接字已标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则 &lt;code&gt;recv&lt;/code&gt; 将引发异常。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。参见&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e5d364aee605b39052a767be97bf595da7e180a" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，如果套接字已标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则 &lt;code&gt;send&lt;/code&gt; 将引发异常。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。参见&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">请注意,如果PM模块的版本是一个NV(浮点数),它将被字符串化,可能会损失精度(目前砍到小数点后九位),因此它可能与XS模块的版本不匹配了。如果使用较长的版本号,建议引用$VERSION声明使其成为一个字符串。</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">请注意，如果我们和第29行之间有一个子例程调用，而我们想&lt;b&gt;单步执行&lt;/b&gt;，则可以使用' &lt;b&gt;s&lt;/b&gt; '命令，而要跳过它，则可以使用' &lt;b&gt;n&lt;/b&gt; '执行该子例程，但不能进入其中进行检查。但是，在这种情况下，我们仅继续执行第29行：</target>
        </trans-unit>
        <trans-unit id="59c2ff6ec5006b141610e96d370fba70e324be70" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;next EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;next LABEL&lt;/code&gt;.</source>
          <target state="translated">注意，如果上面有一个&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;块，即使在丢弃的行上也将执行它。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;next EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;next LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">注意，如果上面有一个 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，即使在丢弃的行上也将执行它。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">请注意，如果上面的代码中包含一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，它将仅在正则表达式丢弃的行上执行（因为重做跳过了continue块）。连续块通常用于重置行计数器或 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; 。一次性比赛：</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">注意，如果上面有一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，即使在丢弃的行上也将执行它。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d89a8bc172fcf3b8db606f977ce516e0ca56f06e" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;continue&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;m?pat?&lt;/code&gt; one-time matches:</source>
          <target state="translated">请注意，如果上面的代码中包含一个 &lt;code&gt;continue&lt;/code&gt; 块，它将仅在正则表达式丢弃的行上执行（因为重做跳过了continue块）。连续块通常用于重置行计数器或 &lt;code&gt;m?pat?&lt;/code&gt; 。一次性比赛：</target>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">请注意，如果在尚未加载&lt;a href=&quot;../threads&quot;&gt;线程&lt;/a&gt;时导入该模块，则这些功能将全部变为无操作。这样就可以编写在线程和非线程环境中都可以使用的模块。</target>
        </trans-unit>
        <trans-unit id="5fb1ed53a6e66a00d38de3c7beb368af62d0f805" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">请注意，如果在尚未加载&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;时导入此模块，则这些功能将全部变为无操作。这样就可以编写在线程和非线程环境中都可以使用的模块。</target>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">请注意，如果使用此运算符而不是在其内部进行替换，则其行为与 &lt;code&gt;(*PRUNE)&lt;/code&gt; 运算符完全相同。</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">请注意，如果使用gcc，则从Perl 5.9.5开始，将自动编译Perl核心源代码文件（位于源代码分发顶层的文件，而不是ext /下的扩展名）。 &lt;code&gt;-std=c89&lt;/code&gt; ， &lt;code&gt;-ansi&lt;/code&gt; ， &lt;code&gt;-pedantic&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 标志的选择（请参阅cflags.SH）。</target>
        </trans-unit>
        <trans-unit id="ae719f393d44a0bc8f5885617f97e53f1b2edd48" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt;, &lt;code&gt;-ansi&lt;/code&gt;, &lt;code&gt;-pedantic&lt;/code&gt;, and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">请注意，如果使用gcc，则从Perl 5.9.5开始，将自动编译Perl核心源代码文件（位于源代码分发顶层的文件，而不是ext /下的扩展名）。 &lt;code&gt;-std=c89&lt;/code&gt; ， &lt;code&gt;-ansi&lt;/code&gt; ， &lt;code&gt;-pedantic&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 标志的选择（请参阅cflags.SH）。</target>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">请注意,如果你没有安装Module::Signature,则根本不会进行签名检查。</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">请注意,如果你不打算自己构建perl,可能会欺骗EMX来截断文件名。这是不支持的,请阅读EMX文档来了解如何做。</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">请注意,如果您有</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">请注意，如果您的脚本中的字节上有第八位（例如，在字符串文字中嵌入了Latin-1），则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 会感到不满意，因为这些字节很可能不是格式正确的UTF-X。如果你想拥有在这种字节 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，你可以禁用这个编译直到结束块（或文件，如果在顶层）的 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">需要注意的是,如果你把chdir'ed放到了临时目录中,而它随后被清理了(无论是在END块中还是作为对象销毁的一部分),那么你将从File::Path::rmtree()得到一个警告。</target>
        </trans-unit>
        <trans-unit id="b2acb4728d0e1f7a70ad075cf5c70995a564c7a8" translate="yes" xml:space="preserve">
          <source>Note that if you have non-ASCII, non-UTF-8 bytes in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;use utf8&lt;/code&gt; will be unhappy. If you want to have such bytes under &lt;code&gt;use utf8&lt;/code&gt;, you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;no utf8;&lt;/code&gt;.</source>
          <target state="translated">请注意，如果脚本中包含非ASCII，非UTF-8字节（例如，字符串文字中嵌入了Latin-1），则 &lt;code&gt;use utf8&lt;/code&gt; 会感到不满意。如果要在 &lt;code&gt;use utf8&lt;/code&gt; 这些字节，则可以禁用该编译指示，直到不使用utf8结束块（或文件，如果位于顶层）为止；否则，请禁用该编译指示 &lt;code&gt;no utf8;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">请注意，如果您要查找直到运行时才知道的字符串，则可以将整个循环作为字符串和 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 进行构建，以避免始终重新编译所有模式。再加上未定义 &lt;code&gt;$/&lt;/code&gt; 作为一个记录输入整个文件，这可能会非常快，通常比诸如fgrep（1）之类的专用程序要快。以下内容在文件列表（ &lt;code&gt;@files&lt;/code&gt; ）中扫描单词列表（ &lt;code&gt;@words&lt;/code&gt; ），并打印出包含匹配项的文件的名称：</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">请注意，如果您要查找直到运行时才知道的字符串，则可以将整个循环作为字符串和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 进行构建，以避免始终重新编译所有模式。再加上未定义 &lt;code&gt;$/&lt;/code&gt; 作为一个记录输入整个文件，这可能会非常快，通常比诸如fgrep（1）之类的专用程序要快。以下内容在文件列表（ &lt;code&gt;@files&lt;/code&gt; ）中扫描单词列表（ &lt;code&gt;@words&lt;/code&gt; ），并打印出包含匹配项的文件的名称：</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">需要注意的是,如果你把一个标量的副本与一个弱引用,副本将是一个强引用。</target>
        </trans-unit>
        <trans-unit id="0e444f4b856d65b2f09fb19cd71f6f782807ee73" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">请注意，如果您想将许多Pod文档批量转换为HTML，则应该看到模块&lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">请注意，如果您想将许多Pod文档批量转换为HTML，则应该看到模块&lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">请注意，如果要启用模块注册的警告类别（例如， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ），则必须先加载此模块。</target>
        </trans-unit>
        <trans-unit id="5e4f1270136e80fe4169f2c75c88690d42981098" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;use warnings 'File::Find'&lt;/code&gt;), you must have loaded this module first.</source>
          <target state="translated">请注意，如果要启用模块注册的警告类别（例如， &lt;code&gt;use warnings 'File::Find'&lt;/code&gt; ），则必须先加载此模块。</target>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">请注意,如果你想把C-local environ数组中的任何元素传递给没有被fork/exec启动的子进程,或者没有运行C程序的子进程,你可以在当前进程中把它们 &quot;推广 &quot;为逻辑名,然后由所有子进程继承,方法是说</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">请注意，如果您使用的是Windows，甚至无法解决这个令人头疼的问题。即使Perl仿真 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ，您仍然会被卡住，因为Windows没有argc / argv风格的API。</target>
        </trans-unit>
        <trans-unit id="1aa1a6be319ce084016212a914b567d8abc1a457" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;fork()&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">请注意，如果您使用的是Windows，则甚至无法解决这个令人烦恼的问题。即使Perl仿真 &lt;code&gt;fork()&lt;/code&gt; ，您仍然会被卡住，因为Windows没有argc / argv风格的API。</target>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">请注意,如果你的分叉子系统继承了系统文件描述符,比如STDIN和STDOUT,这些文件实际上是通过管道或套接字连接的,即使你退出了,那么远程服务器(比如,CGI脚本或从远程shell启动的后台作业)也不会认为你已经完成了。你应该重新打开那些</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">请注意,在Perl 5.17.3和更早的版本中,最后三个常量也用于变量的插入式变体。</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">请注意，在5.18之前的Perl版本中， &lt;code&gt;fallback&lt;/code&gt; 键的继承不受上述规则的约束。使用第一个过载祖先中的 &lt;code&gt;fallback&lt;/code&gt; 值。在5.18中已修复此问题，以遵循通常的继承规则。</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">请注意,在一些情况下,这种翻译不能完美地传回源代码中--例如,如果循环的初始化器声明了一个my变量,那么它在循环之外就不会有正确的作用域。</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">请注意,在列表上下文中,原始输入文本(第一个参数)的内容不会以任何方式被修改。</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">请注意，在所有情况下，&amp;ldquo; E &amp;lt;whatever&amp;gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="6ce30555742bc236d7228f5681b0d8b9d5625260" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">请注意，与&lt;a href=&quot;#EXAMPLE-1&quot;&gt;&amp;ldquo;示例1&amp;rdquo;&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;&amp;ldquo;示例2&amp;rdquo;&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;&amp;ldquo;示例3&amp;rdquo;&lt;/a&gt;相反，此描述不包含实际的</target>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">注意，与&lt;a href=&quot;#EXAMPLE-1&quot;&gt;示例1&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;示例2&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;示例3相比&lt;/a&gt;，此描述不包含实际内容。</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">请注意，在此模块的较旧版本中，即使如上所述调用了实例方法， &lt;code&gt;error()&lt;/code&gt; 方法也将返回有效的全局值。此后已得到修复，并且 &lt;code&gt;Archive::Tar&lt;/code&gt; 多个实例现在具有单独的错误字符串。</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">请注意，在标量和void上下文中，此参数的值会自动重置为1（在 &lt;code&gt;-w&lt;/code&gt; 下，如果必须重置该参数，则会发出警告）。</target>
        </trans-unit>
        <trans-unit id="b672aba9889e3334f6f71797b988ee0e00c12f3a" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt;, a warning is issued if the argument has to be reset).</source>
          <target state="translated">请注意，在标量和void上下文中，此参数的值会自动重置为1（在 &lt;code&gt;-w&lt;/code&gt; 下，如果必须重置该参数，则会发出警告）。</target>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">请注意，在上述情况下， &lt;code&gt;thing($foo)&lt;/code&gt; 和 &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="312240e44caf4f031c0d90c515deeb5d10139037" translate="yes" xml:space="preserve">
          <source>Note that in the above example, tests in the first subdirectory will not be run. To run all tests in the intermediary subdirectory preceding the one the test files are in, you need to explicitly note it:</source>
          <target state="translated">注意,在上面的例子中,第一个子目录中的测试不会被运行。如果要运行测试文件所在的中间子目录中的所有测试,你需要明确地指出它。</target>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">请注意,install()没有给出有意义的返回值。参见 uptodate()。</target>
        </trans-unit>
        <trans-unit id="275e7ac15e1f8f9535995287531c3b4b0bc12858" translate="yes" xml:space="preserve">
          <source>Note that it</source>
          <target state="translated">请注意,它</target>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">请注意，任何方法（包括 &lt;code&gt;AUTOLOAD&lt;/code&gt; ）尝试重新分派任何不具有相同名称的方法都是致命错误。例如：</target>
        </trans-unit>
        <trans-unit id="4c47d269e31ad3d486ed4d3aa4e0693a8502eee1" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt;) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">请注意，任何方法（包括 &lt;code&gt;AUTOLOAD&lt;/code&gt; ）尝试重新分派任何不具有相同名称的方法都是致命错误。例如：</target>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">请注意,通常情况下,将INST_DRV和INST_TOP设置为之前构建时已经存在的路径来构建perl不是一个好主意。特别是,这可能会导致lib/ExtUtils/t/Embed.t测试出现问题,因为该测试试图构建一个测试程序,最终可能会针对已安装的perl的lib/CORE目录而不是被测试的目录构建。</target>
        </trans-unit>
        <trans-unit id="d81b2599960bdecb9620115e70e867f7359ae0c4" translate="yes" xml:space="preserve">
          <source>Note that it is illegal to have code points that are larger than what can fit in an IV on the current machine.</source>
          <target state="translated">需要注意的是,在目前的机器上,码点大于IV所能容纳的范围是违法的。</target>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">请注意,引用 __CALLER__::Roo 标识符是很重要的,因为 perl 5.8 中的一个错误会拒绝解析它并导致一个未知的错误。</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">请注意,在一个信号处理程序中访问一个文件句柄是不可取的,因为这个信号已经中断了对同一句柄的I/O操作。虽然perl至少会努力避免崩溃,但并不能保证数据的完整性;例如,一些数据可能会被丢弃或写入两次。</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">请注意，在这种情况下不必调用 &lt;code&gt;PUSHMARK&lt;/code&gt; 。这是因为</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">请注意,创建一个包含已经链接到perl中的依赖库的库是可以的。</target>
        </trans-unit>
        <trans-unit id="a2ad638116e9353f8a4dbaec6ebfef4f8d3c123f" translate="yes" xml:space="preserve">
          <source>Note that it is possible that the actions of a destructor called directly or indirectly by freeing an element of the array could cause the reference count of the array itself to be reduced (e.g. by deleting an entry in the symbol table). So it is a possibility that the AV could have been freed (or even reallocated) on return from the call unless you hold a reference to it.</source>
          <target state="translated">请注意,通过释放数组元素而直接或间接调用的析构器的行为有可能导致数组本身的引用计数减少(例如,通过删除符号表中的一个条目),因此,AV有可能在调用返回时被释放(甚至重新分配),除非你持有它的引用。所以在调用返回时,AV有可能已经被释放(甚至重新分配),除非你持有对它的引用。</target>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">请注意，有可能在多个文件中的同一包中包含 &lt;code&gt;__DATA__&lt;/code&gt; 令牌，并且编译器在给定包中遇到的最后一个 &lt;code&gt;__DATA__&lt;/code&gt; 令牌是文件句柄可访问的令牌。这也适用于 &lt;code&gt;__END__&lt;/code&gt; 和main，即，如果&amp;ldquo; main&amp;rdquo;程序具有 &lt;code&gt;__END__&lt;/code&gt; ，但是该程序&amp;ldquo;需要&amp;rdquo;（_not_&amp;ldquo; use&amp;rdquo; d）的模块具有&amp;ldquo; package main&amp;rdquo;；声明后跟一个' &lt;code&gt;__DATA__&lt;/code&gt; '，然后将 &lt;code&gt;DATA&lt;/code&gt; 文件句柄设置为访问模块中 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据，而 &lt;code&gt;__END__&lt;/code&gt; 'main'程序中__END__令牌之后的数据，因为编译器遇到了'require'd文件以后。</target>
        </trans-unit>
        <trans-unit id="7c22ec5e674939ca7dd16521f1a2590b4ddee243" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt;, but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt;', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">请注意，可能在多个文件的同一包中包含 &lt;code&gt;__DATA__&lt;/code&gt; 令牌，并且编译器在给定包中遇到的最后一个 &lt;code&gt;__DATA__&lt;/code&gt; 令牌是文件句柄可访问的令牌。这也适用于 &lt;code&gt;__END__&lt;/code&gt; 和main，即，如果&amp;ldquo; main&amp;rdquo;程序具有 &lt;code&gt;__END__&lt;/code&gt; ，但该程序&amp;ldquo;需要&amp;rdquo;（_not_&amp;ldquo; use&amp;rdquo; d）使用的模块具有&amp;ldquo; package main&amp;rdquo;；声明后跟一个' &lt;code&gt;__DATA__&lt;/code&gt; '，然后将 &lt;code&gt;DATA&lt;/code&gt; 文件句柄设置为访问模块中 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据，而 &lt;code&gt;__END__&lt;/code&gt; 'main'程序中__END__令牌之后的数据，因为编译器遇到了'require'd文件以后。</target>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">需要注意的是,可以通过用Unicode数字来指定东西,并使用转换函数来编写这些可移植的代码。</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">请注意,除了import()和unimport()方法之外,在任何地方调用overload::constant()和overload::remove_constant()函数可能是没有意义的。在这些方法中,它们可以被调用为</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">请注意,无论如何,指定这些类型的范围并不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">请注意,它只确认了最低限度的结构(以免被可能包含额外哈希项的派生类所混淆)。</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">请注意,有些线路有测试号,有些线路没有测试号,这是完全可以接受的。但是,当发现有测试号时,必须按顺序排列。以下也是一个错误。</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">注意，有可能使Perl误以为 &lt;code&gt;//&lt;/code&gt; （空的正则表达式）实际上是 &lt;code&gt;//&lt;/code&gt; （定义或运算符）。 Perl通常对此非常好，但是某些病理情况可能会触发此情况，例如 &lt;code&gt;$x///&lt;/code&gt; （是 &lt;code&gt;($x) / (//)&lt;/code&gt; 或 &lt;code&gt;$x // /&lt;/code&gt; ？）并 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; （ &lt;code&gt;print $fh(//&lt;/code&gt; 或 &lt;code&gt;print($fh //&lt;/code&gt; ？）。在所有这些示例中，Perl都将假设您的定义是-或。如果您的意思是空的正则表达式，则只需使用括号或空格来消除歧义，甚至在前缀之前加上带 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 的空正则表达式（因此 &lt;code&gt;//&lt;/code&gt; 变为 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a12f25b19f578d4ada5cb29c677b041e1603c474" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt;?) and &lt;code&gt;print $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;m&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;m//&lt;/code&gt;).</source>
          <target state="translated">注意，有可能使Perl误以为 &lt;code&gt;//&lt;/code&gt; （空正则表达式）实际上是 &lt;code&gt;//&lt;/code&gt; （定义或运算符）。 Perl通常对此非常好，但是某些病理情况可能会触发此情况，例如 &lt;code&gt;$x///&lt;/code&gt; （是 &lt;code&gt;($x) / (//)&lt;/code&gt; 或 &lt;code&gt;$x // /&lt;/code&gt; ？）并 &lt;code&gt;print $fh //&lt;/code&gt; （ &lt;code&gt;print $fh(//&lt;/code&gt; 或 &lt;code&gt;print($fh //&lt;/code&gt; ？）。在所有这些示例中，Perl都将假设您的定义为-或。如果您的意思是空的正则表达式，则只需使用括号或空格来消除歧义，甚至在前缀之前加上带 &lt;code&gt;m&lt;/code&gt; 的空正则表达式（因此 &lt;code&gt;//&lt;/code&gt; 变为 &lt;code&gt;m//&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">请注意，就像在C中一样，Perl并没有定义变量&lt;b&gt;何时&lt;/b&gt;递增或递减。您只知道它将在返回值之前或之后的某个时间完成。这也意味着在同一条语句中两次修改变量将导致未定义的行为。避免使用以下语句：</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">请注意，仅因为哈希是以该顺序初始化的，并不意味着它以该顺序出现。请参阅&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;以获取有关如何安排输出顺序的示例。</target>
        </trans-unit>
        <trans-unit id="7f5a81a69fc5b10cd51900312887345ba64586f5" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">请注意，仅因为哈希是以该顺序初始化的，并不意味着它以该顺序出现。有关如何安排输出顺序的示例，请参见&lt;a href=&quot;perlfunc#sort&quot;&gt;perlfunc中的&amp;ldquo; sort&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">请注意，像所有标点符号变量一样，当前不能在 &lt;code&gt;$^W&lt;/code&gt; 上使用my（），只能使用local（）。</target>
        </trans-unit>
        <trans-unit id="3fe7b7d8a3cbe9873ed0d90c76831403a33df538" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt;, only local().</source>
          <target state="translated">请注意，像所有标点符号变量一样，当前不能在 &lt;code&gt;$^W&lt;/code&gt; 上使用my（），而只能在local（）上使用。</target>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">请注意，宏 &lt;code&gt;ST(i)&lt;/code&gt; ， &lt;code&gt;XST_m*()&lt;/code&gt; 和 &lt;code&gt;XSRETURN*()&lt;/code&gt; 在CODE：部分和PPCODE：部分中均能很好地工作。</target>
        </trans-unit>
        <trans-unit id="590d78c14b1f30644ceca6febcb1f178361e32a4" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt;, &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">请注意，宏 &lt;code&gt;ST(i)&lt;/code&gt; ， &lt;code&gt;XST_m*()&lt;/code&gt; 和 &lt;code&gt;XSRETURN*()&lt;/code&gt; 在CODE：节和PPCODE：节中均能很好地工作。</target>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">请注意，大多数Unicode字符没有分解，因此其分解类型为 &lt;code&gt;&quot;None&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c45d58bad9499717ca648bdb916a02ec0cb0a26" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，大多数Unicode字符没有分解，因此其分解类型为 &lt;code&gt;&quot;None&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">需要注意的是,多个 &quot;前端 &quot;可以同时接入这个调试API。这是为了方便使用命令行和GUI同时调试,调试调试器等。[听起来不错,但这需要一些严肃的支持 ----GSAR]</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">请注意，&lt;b&gt;-w&lt;/b&gt;标志或 &lt;code&gt;$^W&lt;/code&gt; 都不能用于禁用/启用默认警告。在这种情况下，它们仍然是必需的。</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">请注意，并非所有 &lt;code&gt;siginfo&lt;/code&gt; 值都同时有意义（例如，某些值仅对某些信号有效），并且从Perl角度来看，并非所有值都有意义，因此您应该查阅系统的 &lt;code&gt;sigaction&lt;/code&gt; ，还可能要查阅 &lt;code&gt;siginfo&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">请注意,并非所有终端类型都支持所有属性,有些终端可能不支持这些序列中的任何一个。尤其是深色和淡色、斜体、闪烁和隐藏经常不被执行。</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">请注意,并不是所有的显示器都符合 ISO 6429 标准,甚至不符合 X3.64 标准(或者甚至正在尝试符合)。这个模块在不符合这些转义序列的显示器上将无法正常工作,例如在 Windows NT 或 Windows 2000 下的 cmd.exe、4nt.exe 和 command.com。它们可能会被忽略,或者显示为一个ESC字符和一些明显的垃圾。</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">请注意,并不是所有Perl的功能在这些环境下都能使用。这取决于</target>
        </trans-unit>
        <trans-unit id="b41fed2960927bbd3a7a4879e6c7ebbfd5148f75" translate="yes" xml:space="preserve">
          <source>Note that not all folders are defined on all versions of Windows.</source>
          <target state="translated">请注意,并非所有版本的Windows都定义了所有文件夹。</target>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">注意,并不是所有的不兼容都能找到。</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">请注意，并非所有模块都可以在所有平台上使用。有关可移植性问题的更多信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。阅读文档以查看该模块是否可以在您的系统上运行。基本上有三种类别的模块不能在所有平台上&amp;ldquo;开箱即用&amp;rdquo;地工作（有可能重叠）：</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">请注意，并非CPAN可用的所有扩展都可以在Windows环境中工作；您应在&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/上&lt;/a&gt;查看信息，然后再花太多精力在不容易构建的移植模块上。</target>
        </trans-unit>
        <trans-unit id="b09aa2530ba4d13d5bf9a219720506b2be0033b4" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">请注意，并非CPAN可用的所有扩展都可以在Windows环境中工作；您应在&lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/上&lt;/a&gt;查看信息，然后再花太多精力在不容易构建的移植模块上。</target>
        </trans-unit>
        <trans-unit id="df4084be0514f39566a9c52b9eaf1e3d0173ba9e" translate="yes" xml:space="preserve">
          <source>Note that not all platforms support disabling this option. Some, at least OpenBSD and MirBSD, will fail with &lt;code&gt;EINVAL&lt;/code&gt; if you attempt to disable it. To determine whether it is possible to disable, you may use the class method</source>
          <target state="translated">请注意，并非所有平台都支持禁用此选项。如果尝试禁用某些工具，至少是OpenBSD和MirBSD，将失败并显示 &lt;code&gt;EINVAL&lt;/code&gt; 。要确定是否可以禁用，可以使用class方法</target>
        </trans-unit>
        <trans-unit id="8b6848dffa9b06cabb4c87ddb649c3cc22a5f54c" translate="yes" xml:space="preserve">
          <source>Note that numerical precision has the same meaning as under Perl (so binary to decimal conversion follows the same rules as in Perl, which can differ to other languages). Also, your perl interpreter might expose extensions to the floating point numbers of your platform, such as infinities or NaN's - these cannot be represented in JSON, and it is an error to pass those in.</source>
          <target state="translated">请注意,数值精度与Perl下的含义相同(所以二进制到十进制的转换遵循与Perl中相同的规则,这可能与其他语言不同)。另外,你的perl解释器可能会对你的平台的浮点数字进行扩展,比如无穷大或NaN's--这些不能用JSON表示,传递这些是一个错误。</target>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">请注意,numf是由quant调用的,用于串联所有量化的数字。</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">请注意，较旧的Pod格式化程序可能无法识别八进制或十六进制数字转义符，并且许多格式化程序无法可靠地渲染255以上的字符。（某些格式化程序甚至可能不得不使用Latin-1 / CP-1252字符的折衷渲染，例如渲染 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; 只是一个普通的&amp;ldquo; e&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">需要注意的是,在Windows上,地址空间分配的粒度是64KB,因此,在Win32 Perl上设置比堆栈更小的堆栈不会节省更多的内存。</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">请注意，在输入（从字符串到数字）时，Perl接受许多形式的 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 。忽略大小写，并且可以理解特定于Win32的形式（如 &lt;code&gt;1.#INF&lt;/code&gt; )，但在输出时 &lt;code&gt;Inf&lt;/code&gt; 值标准化为Inf和 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6ea49ea44abd8799ce4dfc75293c4bfcb155f89" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">请注意，在输入（从字符串到数字）时，Perl接受许多形式的 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 。忽略大小写，并且可以理解Win32特定的格式，例如 &lt;code&gt;1.#INF&lt;/code&gt; ，但是在输出时，将值标准化为 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">请注意，在某些系统上，返回值为 &lt;code&gt;-1&lt;/code&gt; 可能意味着子进程正在自动获得。有关详细信息和其他示例，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">请注意，在某些系统上，返回值为 &lt;code&gt;-1&lt;/code&gt; 可能意味着子进程正在自动获得。有关详细信息和其他示例，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">注意,只有局部的变量变化才会被撤销。代码表达式执行的其他副作用是永久性的。因此</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">请注意,只有perl才能真正解析Perl,所以所有这样的CASE工具都有些不足,尤其是当你不像C程序员那样对Perl进行编程时。</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">注意,op_next不会被操作,节点也不会被释放,那是调用者的责任。它也不会为一个空列表等创建一个新的列表op;使用更高级别的函数,如op_append_elem()来处理。</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">请注意 pad_findlex()是递归的;它沿着 CV 链向上递归,然后向下返回,边走边添加假名条目。必须这样做,因为在 anon 原型中的假名必须在 xlow 中存储到父垫的索引。</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">请注意，当切掉不是简单变量的任何内容时，必须使用括号。这是因为 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 被解释为 &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; ，而不是您可能期望的 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 。同样， &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 被解释为 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">请注意，当切掉不是简单变量的任何内容时，必须使用括号。这是因为 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 被解释为 &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; ，而不是您可能期望的 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 。同样， &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 被解释为 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="018c1697a99aff61964cd62c6350adc2116be64d" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt;, rather than as &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;chomp $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;chomp($a), $b&lt;/code&gt; rather than as &lt;code&gt;chomp($a, $b)&lt;/code&gt;.</source>
          <target state="translated">请注意，当切掉不是简单变量的任何内容时，必须使用括号。这是因为 &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; 被解释为 &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt; ，而不是您可能期望的 &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; 。同样， &lt;code&gt;chomp $a, $b&lt;/code&gt; 被解释为 &lt;code&gt;chomp($a), $b&lt;/code&gt; 而不是 &lt;code&gt;chomp($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b290990bc28b21efbb6fc62a4d6a7e3869dd2f55" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">请注意，这段代码的某些部分是在亚当&amp;middot;肯尼迪（Adam Kennedy）的允许下从&lt;a href=&quot;YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;派生的。</target>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">请注意，这段代码的一部分是在Adam Kennedy的允许下从&lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;派生的。</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">请注意,pod翻译器应该只看以pod指令开头的段落(这使解析更容易),而编译器实际上知道寻找pod转义,甚至在段落中间。这意味着以下秘密的东西将被编译器和翻译器忽略。</target>
        </trans-unit>
        <trans-unit id="97f97f44b8a98fafc1d8a756bd8a55c77c58d9e9" translate="yes" xml:space="preserve">
          <source>Note that precision is not accuracy - binary floating point values cannot represent most decimal fractions exactly, and when converting from and to floating point, JSON::PP only guarantees precision up to but not including the least significant bit.</source>
          <target state="translated">需要注意的是,精度不是准确度--二进制浮点值不能准确地表示大多数小数点,当从浮点转换为浮点时,JSON::PP只保证精度达到但不包括最小有效位。</target>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">请注意,关于旧版本 Perl 中的 bug 的报告,尤其是那些表明你还没有测试过当前稳定版 Perl 的报告,很可能会比当前版本中的 bug 得到构建和维护 Perl 的志愿者的关注。</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">注意，将数组反转为自身（如 &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）将在任何可能的情况下保留不存在的元素。即，对于非魔术数组或具有 &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 方法的并列数组。</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">注意，将数组反转为自身（如 &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）将在任何可能的情况下保留不存在的元素。即，对于非魔术数组或具有 &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 方法的并列数组。</target>
        </trans-unit>
        <trans-unit id="cefecfaf8ad606f51bb60e49b8b1e7ead07fd207" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = reverse @a&lt;/code&gt;) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">请注意，将数组反转为自身（如 &lt;code&gt;@a = reverse @a&lt;/code&gt; ）将在任何可能的情况下保留不存在的元素。即，对于非魔术数组或具有 &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 方法的并列数组。</target>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">注意,rewinddir()在Windows上也有类似的限制,也不会强制readdir()再次读取目录。只有新打开的目录句柄才会反映目录的变化。</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">请注意,章节名称可能包含标记。例如,如果一个章节的开头是:</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">请注意,不能同时设置精度和准确度。</target>
        </trans-unit>
        <trans-unit id="2dfa6206994e5b2e572924979f052b36e73802cd" translate="yes" xml:space="preserve">
          <source>Note that several apps spew crap to stderr every time you connect, which can throw off Configure. You may need to monkeypatch the part of Configure that creates &lt;code&gt;run-ssh&lt;/code&gt; to have it discard stderr.</source>
          <target state="translated">请注意，每次您连接时，有几个应用程序会吐出垃圾到stderr，这可能会使Configure失效。您可能需要对配置文件中创建 &lt;code&gt;run-ssh&lt;/code&gt; 的部分进行猴子修补，以使其放弃stderr。</target>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">请注意,从Perl 5.10.0开始,a //也可以是</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">请注意，从Perl 5.8.1开始，单数v字符串（如 &lt;code&gt;v65&lt;/code&gt; ）不是 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符（通常用于将哈希键与哈希值分开）之前的v字符串。而是将它们解释为文字字符串（'v65'）。它们是从Perl 5.6.0到Perl 5.8.0的v弦，但是造成的混乱和破损多于好。像 &lt;code&gt;v65.66&lt;/code&gt; 和 &lt;code&gt;65.66.67&lt;/code&gt; 这样的多数字v 字符串始终始终是v字符串。</target>
        </trans-unit>
        <trans-unit id="008b6ecd9594a1f31168dc7af3eef7ef69846a54" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt;) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">请注意，自Perl 5.8.1起，单数v字符串（如 &lt;code&gt;v65&lt;/code&gt; ）不是 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符（通常用于将哈希键与哈希值分开）之前的v字符串。而是将它们解释为文字字符串（'v65'）。它们是从Perl 5.6.0到Perl 5.8.0的v弦，但是造成的混乱和破坏多于良善。像 &lt;code&gt;v65.66&lt;/code&gt; 和 &lt;code&gt;65.66.67&lt;/code&gt; 这样的多数字v字符串始终始终是v字符串。</target>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">需要注意的是,自Perl 5.16版本以来,这个功能就没有了,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">请注意，跳过空白仅适用于此构造的内部。构成初始 &lt;code&gt;(?[&lt;/code&gt; 。的结束字符之间 &lt;code&gt;])&lt;/code&gt; 之间的任何字符之间不得有任何空格。</target>
        </trans-unit>
        <trans-unit id="545af0b2b09ce2f37c97dabd56794edec8a64fad" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt;. Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">请注意，跳过空白仅适用于此构造的内部。构成首字母 &lt;code&gt;(?[&lt;/code&gt; 。的结束字符之间 &lt;code&gt;])&lt;/code&gt; 之间的任何字符之间都不能有空格。</target>
        </trans-unit>
        <trans-unit id="7426c9a1b07347627eeb1ac1cf62af6a1907ba1a" translate="yes" xml:space="preserve">
          <source>Note that some UNIX mail systems can mess with text attachments containing 'From '. This will fix them up:</source>
          <target state="translated">请注意,一些UNIX邮件系统可能会对包含 &quot;发件人 &quot;的文本附件造成混乱。这将修复它们。</target>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">请注意,有些URLs中含有十六进制ASCII码点,以克服字符或协议限制问题。例如,不是每个键盘上都有tilde字符,因此URL的形式是:。</target>
        </trans-unit>
        <trans-unit id="b0ec6733c239960d7ab748fd5e743c87866db919" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;b&gt;--release&lt;/b&gt; to the last modified date and &lt;b&gt;--date&lt;/b&gt; to the version number.</source>
          <target state="translated">请注意，有些系统 &lt;code&gt;an&lt;/code&gt; 宏观组认为该中心的页脚会修改日期，将在前面加上类似&amp;ldquo;上次修改&amp;rdquo;。如果您的目标系统是这种情况，则可能需要将&lt;b&gt;--release&lt;/b&gt;设置为上次修改日期，并将&lt;b&gt;--date&lt;/b&gt;设置为版本号。</target>
        </trans-unit>
        <trans-unit id="5782148c53cb53f800e7cc24f499baa2f09d812f" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;code&gt;release&lt;/code&gt; to the last modified date and &lt;code&gt;date&lt;/code&gt; to the version number.</source>
          <target state="translated">请注意，有些系统 &lt;code&gt;an&lt;/code&gt; 宏观组认为该中心的页脚会修改日期，将在前面加上类似&amp;ldquo;上次修改&amp;rdquo;。如果您的目标系统是这种情况，则可能需要将 &lt;code&gt;release&lt;/code&gt; 设置为上次修改日期，并将 &lt;code&gt;date&lt;/code&gt; 设置为版本号。</target>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">请注意，函数的某些类型的参数/返回值可能会导致需要手工编辑的XSUB声明/ typemap条目。这样的对象可能是无法与指针（如 &lt;code&gt;long long&lt;/code&gt; ），函数的指针或数组之间进行转换的对象。另请参见&lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;-x的局限性部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6ea1587e3db14d628357c10f80019ced4d3486b" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt;), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;&quot;LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">请注意，函数的某些类型的参数/返回值可能会导致需要手工编辑的XSUB声明/ typemap条目。这样的对象可能是无法与指针（如 &lt;code&gt;long long&lt;/code&gt; ），函数或数组的指针之间进行转换的对象。另请参见&lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;&amp;ldquo; &lt;b&gt;-x的&lt;/b&gt;局限性&amp;rdquo;部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">请注意，格式参数 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 中的空格不表示文字空格。如果您使用空格分隔数据，则可能需要 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="662d6982ca6578815a4a0f18cc0ec8305ec26773" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;unpack&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;split&lt;/code&gt; instead.</source>
          <target state="translated">请注意，用于 &lt;code&gt;unpack&lt;/code&gt; 的format参数中的空格不表示文字空格。如果您使用空格分隔数据，则可能需要 &lt;code&gt;split&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">请注意,无论指定的LIMIT是多少,拆分为空字符串的EXPR总是产生零字段。</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">请注意,从Perl 5.7.2(也就是5.8.0)和AIX 4.3或更新版本开始,Perl在所谓的运行时链接模式中使用AIX本地动态加载接口,而不是在Perl 5.6.1和更早版本中使用的模拟接口,或者AIX 4.2和更早版本中使用的模拟接口。这一改变确实破坏了与早期 Perl 版本的编译模块的向后兼容性。这一改动是为了使Perl更符合其他应用程序的要求,比如Apache/mod_perl,它们使用的是AIX本地接口。这一改动也使得 Perl 扩展中可以使用带有静态构造函数和反构造函数的 C++代码,而使用仿真接口则是不可能的。</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">请注意,从Unicode 6.1开始,许多块名都有较短的同义词。这些名称总是以新的样式给出。</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">请注意,strtol()和strtoul()可能伪装成Strtol()、Strtoul()、Atol()、Atoul()。也要避免这些。</target>
        </trans-unit>
        <trans-unit id="1f8d123671f8fe6351f73c10ea6c3fa3f4b1a51f" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are compared strictly, meaning 1 tab will not match 8 spaces.</source>
          <target state="translated">注意,制表符和空格是严格比较的,也就是说1个制表符不会匹配8个空格。</target>
        </trans-unit>
        <trans-unit id="da058756ddccf3047bc3134e13ea20e3af855473" translate="yes" xml:space="preserve">
          <source>Note that testing is finished. If no plan has been set this will generate a Plan event.</source>
          <target state="translated">注意,测试已经结束。如果没有设置计划,这将产生一个计划事件。</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="6672243740cead8683b9d1445f8ead3531c13383" translate="yes" xml:space="preserve">
          <source>Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl. The default can be overridden by setting the environment variable PERLIO to a space or colon separated list of layers, however this cannot be used to set layers that require loading modules like &lt;code&gt;:encoding&lt;/code&gt;.</source>
          <target state="translated">请注意，&amp;ldquo;默认堆栈&amp;rdquo;取决于操作系统和Perl版本，以及Perl的编译时和运行时配置。可以通过将环境变量PERLIO设置为由空格或冒号分隔的层列表来覆盖默认值，但是不能用于设置需要加载模块的层，如 &lt;code&gt;:encoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94925dc9df0f22c049d74f88d76450a9a690c2cd" translate="yes" xml:space="preserve">
          <source>Note that the 0 index of @{^CAPTURE} is equivalent to $1, the 1 index is equivalent to $2, etc.</source>
          <target state="translated">注意,@{^CAPTURE}的0指数相当于1元,1指数相当于2元,等等。</target>
        </trans-unit>
        <trans-unit id="06f90013b3209e32ef045a540920a533398fa647" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; emulation of &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">请注意，对&lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock（3）&lt;/a&gt;的&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;仿真要求打开FILEHANDLE并使其具有读取意图以使用LOCK_SH，并且要求将其打开而具有写入意图以使用LOCK_EX。</target>
        </trans-unit>
        <trans-unit id="f6fcc2fd58a5941d9e57fbe4a6f4e6ca8d35d36f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt;&lt;code&gt;select FILEHANDLE&lt;/code&gt;&lt;/a&gt; form is generally portable.</source>
          <target state="translated">请注意，&lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt; &lt;code&gt;select FILEHANDLE&lt;/code&gt; &lt;/a&gt;表单通常是可移植的。</target>
        </trans-unit>
        <trans-unit id="5879e45ce93c6c3511286267d5813593e72f0a4e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;p&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;&quot;a&quot;&lt;/code&gt;'s) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;use warnings&lt;/code&gt;; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">请注意， &lt;code&gt;&quot;a&quot;&lt;/code&gt; ， &lt;code&gt;&quot;d&quot;&lt;/code&gt; ， &lt;code&gt;&quot;l&quot;&lt;/code&gt; ， &lt;code&gt;&quot;p&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 修饰符是特殊的，因为它们只能被启用，而不能被禁用，而 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ， &lt;code&gt;&quot;d&quot;&lt;/code&gt; ， &lt;code&gt;&quot;l&quot;&lt;/code&gt; ，和 &lt;code&gt;&quot;u&quot;&lt;/code&gt; 修饰符是互斥的：指定一个取消指定其他修饰符，并且构造中最多可以出现一个（或两个 &lt;code&gt;&quot;a&quot;&lt;/code&gt; ）。因此，例如， &lt;code&gt;(?-p)&lt;/code&gt; 在 &lt;code&gt;use warnings&lt;/code&gt; 下编译时会发出警告； &lt;code&gt;(?-d:...)&lt;/code&gt; 和 &lt;code&gt;(?dl:...)&lt;/code&gt; 是致命错误。</target>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">请注意， &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%b&lt;/code&gt; （星期几和一年中的月份的缩写）不一定是三个字符宽。</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">注意， &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 前缀&lt;b&gt;不是必需的&lt;/b&gt;，但是希望扩展名可移植到Unix或OS / 2的作者应该使用前缀，因为Unix（-Unix）/ 2版本的ext（）要求使用它们。</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; 表单通常是可移植的。</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">请注意，可以使用 &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker选项将这些选项添加到MakeMaker生成的任何makefile中。</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">请注意， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 修饰符的特殊之处在于它们只能被启用，而不能被禁用，并且 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 修饰符是互斥的：指定一个取消指定其他修饰符，并且该结构中最多可以出现一个（或两个 &lt;code&gt;a&lt;/code&gt; ）。因此，例如， &lt;code&gt;(?-p)&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 下编译时会发出警告； &lt;code&gt;(?-d:...)&lt;/code&gt; 和 &lt;code&gt;(?dl:...)&lt;/code&gt; 是致命错误。</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完毕后，$ ctx对象将自动 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ，并可用于计算另一个摘要值。如果要计算摘要而不重置摘要状态，请调用$ ctx-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="ce0a012ac00944b517f4c494f69adcd759afd120" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完毕后，$ ctx对象将自动 &lt;code&gt;reset&lt;/code&gt; ，并可用于计算另一个摘要值。如果要计算摘要而不重置摘要状态，请调用$ ctx-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完后， &lt;code&gt;Digest::MD5&lt;/code&gt; 对象将自动 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ，并可用于计算另一个摘要值。如果要计算摘要而不重置摘要状态，请调用$ md5-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="30d1356fb08343a518e41acb4dd7ec7580812f65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完后， &lt;code&gt;Digest::MD5&lt;/code&gt; 对象将自动 &lt;code&gt;reset&lt;/code&gt; ，并可用于计算另一个摘要值。如果要在不重置摘要状态的情况下计算摘要，请调用$ md5-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">请注意，其中的 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">请注意， &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; 模式会使Pod :: Simple（et al）的运行速度变慢，因为＆Pod :: Simple :: DEBUG不再是常量子了，因此Pod :: Simple（et al）不会通过恒定折叠进行编译。</target>
        </trans-unit>
        <trans-unit id="20cd55dfd99c6b7ca8f8c3e96afe94485ab2aeca" translate="yes" xml:space="preserve">
          <source>Note that the API described here changed considerably in perl 5.24; prior to that, big macros like &lt;code&gt;PUSHBLOCK&lt;/code&gt; and &lt;code&gt;POPSUB&lt;/code&gt; were used; in 5.24 they were replaced by the inline static functions described below. In addition, the ordering and detail of how these macros/function work changed in many ways, often subtly. In particular they didn't handle saving the savestack and temps stack positions, and required additional &lt;code&gt;ENTER&lt;/code&gt;, &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; compared to the new functions. The old-style macros will not be described further.</source>
          <target state="translated">请注意，此处描述的API在perl 5.24中已发生了很大变化；在此之前，使用了诸如 &lt;code&gt;PUSHBLOCK&lt;/code&gt; 和 &lt;code&gt;POPSUB&lt;/code&gt; 之类的宏。在5.24中，它们被下面描述的内联静态函数取代。此外，这些宏/函数的工作顺序和详细信息通常以许多方式细微变化。特别是，它们不处理保存savestack和temps堆栈位置的问题，与新功能相比，还需要其他 &lt;code&gt;ENTER&lt;/code&gt; ， &lt;code&gt;SAVETMPS&lt;/code&gt; 和 &lt;code&gt;LEAVE&lt;/code&gt; 。旧式宏将不再赘述。</target>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">请注意，CPU秒是&lt;b&gt;最短的&lt;/b&gt;时间：CPU调度和其他操作系统因素可能会使尝试复杂化，从而花费更多时间。但是，基准测试输出还会告诉您每秒 &lt;code&gt;$code&lt;/code&gt; 运行的次数，这应该比实际花费的秒数更有趣。</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">注意,只要最后的操作是哈希或数组键查找或子程序名,EXPR可以任意复杂。</target>
        </trans-unit>
        <trans-unit id="f0084fb8a7b9ce4d56aecba3fadc51d825f62ba8" translate="yes" xml:space="preserve">
          <source>Note that the Encode implementation of GSM0338 does not implement the reuse of Latin capital letters as Greek capital letters (for example, the 0x5A is U+005A (LATIN CAPITAL LETTER Z), not U+0396 (GREEK CAPITAL LETTER ZETA).</source>
          <target state="translated">请注意,GSM0338的Encode实现并没有实现将拉丁文大写字母作为希腊文大写字母的重用(例如,0x5A是U+005A(LATIN CAPITAL LETTER Z),而不是U+0396(GREEK CAPITAL LETTER ZETA)。</target>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">注意，G_KEEPERR标志不会传播到内部评估中；这些可能仍然设置 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="997492b2704e0f5c940f0988ed8b0f1470e9f2f1" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">注意，G_KEEPERR标志不会传播到内部评估中；这些可能仍然设置 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">请注意，MAP_TARGET值*必须*带有&amp;ldquo; .exe&amp;rdquo;扩展名，否则您将不会创建&amp;ldquo; perl.exe&amp;rdquo;来替换 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8caaca0bc214aa98766a1940f6cdf2d7b3d021af" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt;.</source>
          <target state="translated">请注意，MAP_TARGET值*必须*带有&amp;ldquo; .exe&amp;rdquo;扩展名，否则您将不会创建&amp;ldquo; perl.exe&amp;rdquo;来替换 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">请注意,MD5算法已不如过去那么强大。自2005年以来,很容易产生产生相同MD5摘要的不同信息。似乎仍然很难生成产生特定摘要的电文,但对于依赖摘要来唯一识别电文的应用来说,转而采用更强的算法可能是明智之举。</target>
        </trans-unit>
        <trans-unit id="247c1a806843ed2e2d60424a5f01f9ce095fc287" translate="yes" xml:space="preserve">
          <source>Note that the MinGW build currently requires a MinGW runtime version earlier than 3.21 (check __MINGW32_MAJOR_VERSION and __MINGW32_MINOR_VERSION).</source>
          <target state="translated">请注意,MinGW构建目前需要早于3.21的MinGW运行时版本(检查__MINGW32_MAJOR_VERSION和__MINGW32_MINOR_VERSION)。</target>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">请注意， &lt;code&gt;fread&lt;/code&gt; 和 &lt;code&gt;fwrite&lt;/code&gt; 的PerlIO等效项与其C库对应项略有不同：</target>
        </trans-unit>
        <trans-unit id="b520e7f3d86206ae6fb132d75305e69c64963146" translate="yes" xml:space="preserve">
          <source>Note that the Script_Extensions property is an improved version of the Script property, and you should probably be using that instead, with the &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; function.</source>
          <target state="translated">请注意，Script_Extensions属性是Script属性的改进版本，您可能应该将其与&lt;a href=&quot;#charprop%28%29&quot;&gt;&amp;ldquo; charprop（）&amp;rdquo;&lt;/a&gt;函数一起使用。</target>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">请注意,Symbian文件系统是非常挑剔的:它强烈要求使用\而不是/。</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">请注意，上述实现将一个数组 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 替换为一个数组，这与List :: Util :: shuffle（）不同，后者需要一个列表并返回一个新的随机列表。</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">请注意,以上两个调用会非常啰嗦,因为默认情况下,可达到的内存和泄漏检查是启用的。如果你想只看到纯粹的错误,可以试试。</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">请注意，各个领域的实际含义还没有很好地标准化，不要期望任何伟大的可移植性。在 &lt;code&gt;$sysname&lt;/code&gt; 可能是操作系统的名称，该 &lt;code&gt;$nodename&lt;/code&gt; 可能是主机的名称， &lt;code&gt;$release&lt;/code&gt; 可能是操作系统的（主要）版本号， &lt;code&gt;$version&lt;/code&gt; 可能是（未成年人）版本号操作系统， &lt;code&gt;$machine&lt;/code&gt; 可能是硬件标识符。也许。</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">请注意,如果在至少1.50版本之前没有定义EU_INSTALL_ALWAYS,那么将支持别名EU_ALWAYS。请确保你使用正确的EU_INSTALL_ALWAYS。</target>
        </trans-unit>
        <trans-unit id="b57c85ca6eca16bd7229db94019acde3ad48fd66" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt; switch:</source>
          <target state="translated">请注意，分配 &lt;code&gt;$\ = $/&lt;/code&gt; 是在处理开关时完成的，因此，如果&lt;b&gt;-l&lt;/b&gt;开关后接&lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;开关，则输入记录分隔符可以与输出记录分隔符不同：</target>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">请注意，分配 &lt;code&gt;$\ = $/&lt;/code&gt; 是在处理开关时完成的，因此，如果&lt;b&gt;-l&lt;/b&gt;开关后接&lt;b&gt;-0&lt;/b&gt;开关，则输入记录分隔符可以与输出记录分隔符不同：</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">注意，反斜杠本身是特殊的。如果要匹配反斜杠，则必须用反斜杠转义反斜杠： &lt;code&gt;/\\/&lt;/code&gt; 匹配单个反斜杠。</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">请注意,返回的base64编码字符串并没有被填充为4字节长的倍数。如果你想与其他base64编码的md5摘要互操作,你可能需要在结果中附加多余的字符串&quot;==&quot;。</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">请注意,在Perl中,即使你的代码块只有一行,大括号也是必须的。不过,有一个聪明的方法可以让你的单行条件块更像英语。</target>
        </trans-unit>
        <trans-unit id="ece9838263d6bf6e2a7db9094c48c8c8ea6e66ec" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回 &lt;code&gt;NULL&lt;/code&gt; 时递减它。</target>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">请注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">请注意，如果 &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; 序列中有嵌套格式代码，则该代码可能会分成多个段。在这种情况下，在 &lt;code&gt;handle_code&lt;/code&gt; 调用handle_code之间可能会发出其他标记标签。如果 &lt;code&gt;codes_in_verbatim&lt;/code&gt; 了codes_in_verbatim选项，则逐字记录部分也是如此。</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">请注意,该效果是编译时的,一旦定义后就不可更改。但是,子程序会被传递一个单一参数,如果大小写敏感匹配生效,则该参数为0,如果无大小写匹配生效,则该参数为非零。子程序可能会根据标志的值返回不同的值,一组值将不可改变地对所有大小写敏感匹配生效,另一组值则对所有大小写不敏感匹配生效。</target>
        </trans-unit>
        <trans-unit id="82a2a038be5dc98f1cb9f3946ca4a644efda3ae0" translate="yes" xml:space="preserve">
          <source>Note that the effect of &lt;code&gt;binmode&lt;/code&gt; differs from that of the binmode() function on operating systems such as Windows and MSDOS, and is not needed to process most types of file.</source>
          <target state="translated">请注意， &lt;code&gt;binmode&lt;/code&gt; 的作用与Windows和MSDOS等操作系统上的binmode（）函数的作用不同，并且不需要处理大多数类型的文件。</target>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">请注意,在这种情况下,字符串中嵌入的单引号没有任何帮助,因为它们没有被指定为可接受的定界符,因此被视为非定界符(并被忽略)。</target>
        </trans-unit>
        <trans-unit id="1a60f273853beeeddbd8dccab4c57df4281d7707" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; implements. Most if not all systems implement &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; in terms of &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">请注意，使用&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）&lt;/a&gt;构建的仿真不提供共享锁，它要求FILEHANDLE必须以写意图打开。这些是&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）&lt;/a&gt;实现的语义。不过，即使不是全部系统，大多数（即使不是全部）系统也可以通过&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;锁定来实现&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）&lt;/a&gt;，因此，不同的语义不应吸引太多的人。</target>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">需要注意的是,用lockf(3)构建的仿真并不提供共享锁,它要求FILEHANDLE是以写的意图打开的。这些都是lockf(3)实现的语义。不过大部分系统都是用fcntl(2)锁来实现lockf(3)的,所以不同的语义应该不会影响到太多人。</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">请注意，编码本身&lt;b&gt;不是&lt;/b&gt;形式上有效的语言标签。还要注意，当前您不能从编码返回到它的编码语言标签。</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">请注意，扩展形式表示perl在内部处理此类构造的方式-该选项实际上关闭了B :: Deparse通常执行的反向翻译。另一方面，请注意 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; 与 &lt;code&gt;$x = $y&lt;/code&gt; ：前者在进行赋值之前将$ y的值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="7363f38426987fddbd769148d6ed0f8d3381792d" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt;: the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">请注意，扩展形式表示perl在内部处理此类构造的方式-该选项实际上关闭了B :: Deparse通常执行的反向翻译。另一方面，请注意 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; 与 &lt;code&gt;$x = $y&lt;/code&gt; ：前者在进行赋值之前将$ y的值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">请注意，仍然需要使用存储的路径进行提取（默认为unzip，将 &lt;code&gt;-d&lt;/code&gt; 指定为pkunzip）。但是，您需要知道在何处提取文件。您还需要手动更改</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">请注意,fcntl(2)对flock(3)的仿真要求FILEHANDLE以读意图打开,使用LOCK_SH,并要求以写意图打开,使用LOCK_EX。</target>
        </trans-unit>
        <trans-unit id="85ef7ad11abd8bc54af52a716405bd9eb2cc5233" translate="yes" xml:space="preserve">
          <source>Note that the file path is relative to &lt;code&gt;$dir&lt;/code&gt; if that is specified. This &lt;b&gt;must not&lt;/b&gt; be used directly for CPAN META &lt;code&gt;provides&lt;/code&gt;. See the &lt;code&gt;provides&lt;/code&gt; method instead.</source>
          <target state="translated">请注意，如果指定了文件路径，则相对于 &lt;code&gt;$dir&lt;/code&gt; 。这&lt;b&gt;不能&lt;/b&gt;直接用于CPAN META &lt;code&gt;provides&lt;/code&gt; 。请参阅 &lt;code&gt;provides&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">请注意,同一指定名称下的文件不会被收录两次。</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">请注意,最后的字符串可能比pvlim长7个字符。</target>
        </trans-unit>
        <trans-unit id="cd6cdc78eed59a6e15c0c2c30dcc231f761afe79" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://man.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">请注意，第一个参数是必需的。将从中解析节号，如果缺少该节号，则默认为1。第二个参数当前被忽略，因为&lt;a href=&quot;http://man.he.net&quot;&gt;man.he.net&lt;/a&gt;当前在其页面中不包含可链接的ID或锚点名称。子类链接到另一个手册页HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">请注意，第一个参数是必需的。将从中解析节号，如果缺少则默认为1。第二个参数当前被忽略，因为&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt;当前在其页面中不包含可链接的ID或锚点名称。子类链接到另一个手册页HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">需要注意的是,上面第一条返回的是一个Time::Seconds对象,所以虽然检查该对象会打印出秒数(因为重载的缘故),但也可以通过Time::Seconds API获得该三角区的分、小时、天、周和年数。</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">请注意，这里的一般模式是访问器方法使用 &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; 读取属性的值，并使用 &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; 设置属性的值。对于每个访问器，我通常只提及一种或另一种语法，据我认为您实际上最有可能使用该语法。</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">请注意，全局变量 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; 在不支持 &lt;code&gt;parent&lt;/code&gt; 方法的较旧的Perl 上未定义，在支持该方法但没有 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 的Perl上被定义为false，否则为true。</target>
        </trans-unit>
        <trans-unit id="33122f52d4f72485938536bba048d13bb9c994d8" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt;, and is true otherwise.</source>
          <target state="translated">请注意，全局变量 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; 在不支持 &lt;code&gt;parent&lt;/code&gt; 方法的较旧的Perl上未定义，在支持该方法但没有 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 的Perl上被定义为false，否则为true。</target>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">请注意，此模块中的 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 实现无法提供对压缩文件/缓冲区的真正随机访问。它通过从当前文件偏移解压缩的数据/缓冲，直到它到达未压缩的偏移参数中指定要 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。对于很小的文件，这可能是可以接受的行为。对于大文件，可能会导致无法接受的延迟。</target>
        </trans-unit>
        <trans-unit id="c2278932c41e8894955fd432303661d611324abc" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;seek&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;seek&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">请注意，此模块中的 &lt;code&gt;seek&lt;/code&gt; 实现并未提供对压缩文件/缓冲区的真正随机访问。它通过从文件/缓冲区中的当前偏移量解压缩数据直到达到在 &lt;code&gt;seek&lt;/code&gt; 参数中指定的未压缩偏移量来工作。对于很小的文件，这可能是可以接受的行为。对于大文件，可能会导致无法接受的延迟。</target>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">请注意,嵌套类的初始化器可以指定为该类的一个对象,也可以指定为对初始化器的引用,这些初始化器被传递给嵌套结构的构造函数。</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">需要注意的是,闹钟和睡眠之间的交互作用是不明确的。</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">请注意,该函数返回的反转列表可能包括非Unicode码点,即任何高于0x10FFFF的码点。Unicode属性在这些码点上没有被定义。您可能希望更改输出,使其不包含这些代码。如果返回的非空列表中还没有这个值的话,只需在它的末尾加上0x110000;如果有的话,则弹出这个值;如</target>
        </trans-unit>
        <trans-unit id="b0e71b8ea159a9c2edf24faa2295a4b51fa39394" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; for these.</source>
          <target state="translated">请注意，为 &lt;code&gt;Case_Folding&lt;/code&gt; 和 &lt;code&gt;Simple_Case_Folding&lt;/code&gt; 属性返回的反转映射不包括Turkic-locale映射。&lt;a href=&quot;#casefold%28%29&quot;&gt;为此&lt;/a&gt;使用&amp;ldquo; casefold（）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">请注意，为 &lt;code&gt;Case_Folding&lt;/code&gt; 和 &lt;code&gt;Simple_Case_Folding&lt;/code&gt; 属性返回的反转映射不包括Turkic-locale映射。&lt;a href=&quot;#casefold()&quot;&gt;为此&lt;/a&gt;使用casefold（）。</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">注意,Unicode中最大的码点是U+10FFFF。</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">请注意,最后两个项目实际上是相互竞争的项目,都是为MS Windows提供完整的gcc工具链。</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">请注意,前面的&quot;:&quot;已从文件名中删除,所以</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">注意,和普通的关联数组一样,检索到的键的顺序是明显的随机顺序。</target>
        </trans-unit>
        <trans-unit id="f7e4be377938ec5b2bd579fa7c5058874b5e3a40" translate="yes" xml:space="preserve">
          <source>Note that the line number of the error/warning may refer to the line number of the start of the paragraph in which the error/warning exists, not the line number that the error/warning is on. This bug is present in errors/warnings related to formatting codes.</source>
          <target state="translated">请注意,错误/警告的行号可能是指存在错误/警告的段落开始的行号,而不是错误/警告所在的行号。这个错误存在于与格式代码有关的错误/警告中。</target>
        </trans-unit>
        <trans-unit id="f7eb999d3e69609ef8f64d4732450cbda274eea8" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">请注意，默认情况下不打印这些行。请参阅&lt;a href=&quot;#-p&quot;&gt;&amp;ldquo; -p&amp;rdquo;&lt;/a&gt;以打印行。如果由于某种原因而无法打开由参数命名的文件，则Perl会警告您该文件，然后移至下一个文件。</target>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">请注意，默认情况下不打印行。请参阅&lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt;以打印行。如果由于某种原因而无法打开以自变量命名的文件，则Perl会警告您，然后移至下一个文件。</target>
        </trans-unit>
        <trans-unit id="b32153557293284be92deec6168f3ee23705dad2" translate="yes" xml:space="preserve">
          <source>Note that the list form of exec() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="translated">请注意,由于Win32 API CreateProcess()接受的是一个简单的字符串,而不是一个命令行参数数组,所以exec()的列表形式被模拟了。这可能会对您的代码产生安全影响。</target>
        </trans-unit>
        <trans-unit id="3f1ea4347f8d164bb526f1210c5912fa3af79feb" translate="yes" xml:space="preserve">
          <source>Note that the list form of system() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="translated">请注意,由于Win32 API CreateProcess()接受的是一个简单的字符串,而不是一个命令行参数数组,所以system()的列表形式被模拟了。这可能会对您的代码产生安全影响。</target>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">请注意,该列表没有排序。</target>
        </trans-unit>
        <trans-unit id="3e41c72d7fee1ff8c764beabf8a96c567a3b6233" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">请注意，由&lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt;的三参数版本返回的左值充当&amp;ldquo;魔术子弹&amp;rdquo;。每次分配给它时，它都会记住原始字符串的哪一部分正在被修改；例如：</target>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">请注意,三参数版本的substr()返回的l值就像一颗 &quot;魔弹&quot;;每次分配到它时,它都会记住原始字符串的哪一部分被修改;例如。</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">需要注意的是,映射是Unicode数据文件中指定的映射,要想得到最终的分解,可能需要递归应用。</target>
        </trans-unit>
        <trans-unit id="41e59b746c6a84ae0b237b2221463c64daa4df44" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively. Unicode in fact discourages use of this property except internally in implementations of the Unicode Normalization Algorithm.</source>
          <target state="translated">请注意,映射是Unicode数据文件中指定的映射,为了得到最终的分解,可能需要递归应用。事实上,Unicode不鼓励使用这个属性,除非在Unicode规范化算法的内部实现中。</target>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">请注意，最小匹配量词 &lt;code&gt;*?&lt;/code&gt; ， &lt;code&gt;+?&lt;/code&gt; 和 &lt;code&gt;??&lt;/code&gt; 似乎是嵌套的量词，但不是。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9b41b3d83f67f68a69236e54f8aeb3e828ab48b2" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">请注意，最小匹配量词 &lt;code&gt;*?&lt;/code&gt; ， &lt;code&gt;+?&lt;/code&gt; 和 &lt;code&gt;??&lt;/code&gt; 似乎是嵌套量词，但不是。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">请注意，对于指数模量小于100的数字，由 &lt;code&gt;%e&lt;/code&gt; ， &lt;code&gt;%E&lt;/code&gt; ， &lt;code&gt;%g&lt;/code&gt; 和 &lt;code&gt;%G&lt;/code&gt; 产生的科学计数法中的指数位数是系统相关的：它可以是三个或更少（零填充）有必要的）。换句话说，十进制的1.23乘以99可以是&amp;ldquo; 1.23e99&amp;rdquo;或&amp;ldquo; 1.23e099&amp;rdquo;。对于 &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%A&lt;/code&gt; 同样：指数或十六进制数字可能会浮动：特别是Perl配置选项&amp;ldquo; long double double&amp;rdquo;可能会引起意外。</target>
        </trans-unit>
        <trans-unit id="31bcb562562261f56086728520662f93907434b0" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt;: the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">请注意，对于指数模数小于100的数字，由 &lt;code&gt;%e&lt;/code&gt; ， &lt;code&gt;%E&lt;/code&gt; ， &lt;code&gt;%g&lt;/code&gt; 和 &lt;code&gt;%G&lt;/code&gt; 产生的科学计数法中的指数位数是系统相关的：它可以是三个或更少（零填充）有必要的）。换句话说，是第十个数字的1.23乘以99可以是&amp;ldquo; 1.23e99&amp;rdquo;或&amp;ldquo; 1.23e099&amp;rdquo;。对于 &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%A&lt;/code&gt; 同样：指数或十六进制数字可能会浮动：特别是Perl配置选项&amp;ldquo; long double double&amp;rdquo;可能会引起意外。</target>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">请注意，与编写扩展名的常规方法相比，仅有的两个更改是在包含Perl标头之前附加了 &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; ，然后是 &lt;code&gt;dTHX;&lt;/code&gt; 在将调用Perl API的每个函数的开始处进行声明。（您会知道哪些函数需要此函数，因为C编译器会抱怨这些函数中有未声明的标识符。）XSUB本身不需要更改，因为XS（）宏已正确定义为在隐式上下文中传递如果需要的话。</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">请注意,odmask并不影响已经编译好的代码,它只会影响任何</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">请注意，如果有选项终止符（默认为 &lt;code&gt;--&lt;/code&gt; ），也会在 &lt;code&gt;@ARGV&lt;/code&gt; 中传递该选项。</target>
        </trans-unit>
        <trans-unit id="9d140eced205e7240d0cac12aab6ec294f45d708" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt;), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">请注意，如果有选项终止符（默认为 &lt;code&gt;--&lt;/code&gt; ），也会在 &lt;code&gt;@ARGV&lt;/code&gt; 中传递该选项。</target>
        </trans-unit>
        <trans-unit id="2b99871b0f7ac49ac26656a96e644a594657e984" translate="yes" xml:space="preserve">
          <source>Note that the outer &lt;code&gt;=over&lt;/code&gt; is a block because it has no &lt;code&gt;=item&lt;/code&gt;s but still has content: the inner &lt;code&gt;=over&lt;/code&gt;. The inner &lt;code&gt;=over&lt;/code&gt;, in turn, is completely empty, and is treated as such.</source>
          <target state="translated">请注意，外部 &lt;code&gt;=over&lt;/code&gt; 是一个块，因为它没有 &lt;code&gt;=item&lt;/code&gt; ,但仍然具有内容：内部 &lt;code&gt;=over&lt;/code&gt; 。内部 &lt;code&gt;=over&lt;/code&gt; 则完全是空的，因此被视为空。</target>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">请注意， &lt;code&gt;(?=regexp)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; 中的括号是不捕获的，因为它们是零宽度的断言。因此，在第二个正则表达式中，捕获的子字符串是整个正则表达式本身的子字符串。先行 &lt;code&gt;(?=regexp)&lt;/code&gt; 可以匹配任意正则表达式，但后向 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 仅适用于固定宽度（即固定长度的字符）的正则表达式。因此 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; 可以，但 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; 则不行。先行断言和后向断言的取反版本分别由 &lt;code&gt;(?!regexp)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; 表示。如果正则表达式可以</target>
        </trans-unit>
        <trans-unit id="b450a76f799fbd2000fb736a0e284dee87f232b7" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in these are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead can match arbitrary regexps, but lookbehind prior to 5.30 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width,</source>
          <target state="translated">请注意，由于这些括号是零宽度的断言，因此它们中的括号是不可捕获的。因此，在第二个正则表达式中，捕获的子字符串是整个正则表达式本身的子字符串。先行可以匹配任意 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; ，但在5.30之前的后向查找（？&amp;lt;= fixed-regexp）仅适用于固定宽度的正则表达式，</target>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">请注意，emacs的perl模式将适合 &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; （单引号），并且会使缩进和突出显示混乱。无论如何，您可能在新的Perl代码中使用了 &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; ，所以这不应该成为问题。</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">注意,占有式定语修饰语不能与非贪婪式修饰语结合。因为这样就没有意义了。请考虑下面的等价表。</target>
        </trans-unit>
        <trans-unit id="05a31604712dc06b57292f7d6e6baf36004c8881" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">注意,占有式定语修饰词不能与非贪婪式修饰词结合。因为这样就没有意义了。请考虑下面的等价表。</target>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">请注意，该过程将针对使用的每个文件继续增长。另外，可能存在 &lt;code&gt;AUTOLOAD&lt;/code&gt; ed子例程和其他条件，这些条件会导致Perl的符号表增长。您可能需要添加一些逻辑来跟踪进程的大小，或者在一定数量的请求后重新启动自身，以确保将内存消耗降至最低。您还希望尽可能使用&lt;a href=&quot;functions/my&quot;&gt;我&lt;/a&gt;的变量。</target>
        </trans-unit>
        <trans-unit id="19133e9511ee15654168135f8179ad57c8de3d7c" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt;ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;perlfunc#my&quot;&gt;&quot;my&quot; in perlfunc&lt;/a&gt; whenever possible.</source>
          <target state="translated">请注意，该过程将针对使用的每个文件继续增长。另外，可能存在 &lt;code&gt;AUTOLOAD&lt;/code&gt; ed子例程和其他导致Perl符号表增长的条件。您可能想要添加一些逻辑来跟踪进程的大小，或者在一定数量的请求后重新启动自身，以确保将内存消耗降至最低。您还希望尽可能&lt;a href=&quot;perlfunc#my&quot;&gt;在perlfunc中&lt;/a&gt;使用&amp;ldquo; my&amp;rdquo;来限定变量的范围。</target>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">请注意,算法的属性会随着时间的推移而改变,因为算法的分析和机器的增长速度越来越快。例如,如果你的应用程序依赖于 &quot;不可能 &quot;为不同的消息生成相同的摘要,那么明智的做法是,随着所使用的算法越来越弱,可以很容易地插入更强的算法。使用这里记录的接口应该可以使以后改变算法变得容易。</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">请注意,以&quot;_&quot;开头的键对 _AUTO 有免疫力的原因并不是因为下划线字符有什么神奇之处 --我只是想有一种方法让大多数词库键都可以自动,除了少数几个,我随意决定使用一个前导下划线作为信号来区分这几个。</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">注意，所述 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 受隐式范围约束。结果，任何新引入的词法变量或任何修改的捕获缓冲区内容在评估之后都会丢失。调试器是学习Perl的一个很好的环境，但是如果您交互式地尝试使用应该在相同范围内的材料，则将其放在一行中。</target>
        </trans-unit>
        <trans-unit id="471933a1768d0ec6bc98ec34dbc5facf0b071a6f" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;eval&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">注意，所述 &lt;code&gt;eval&lt;/code&gt; 受隐式范围的约束。结果，在eval之后，任何新引入的词法变量或任何修改的捕获缓冲区内容都会丢失。调试器是学习Perl的一个很好的环境，但是如果您交互地尝试使用应该在相同范围内的材料，则将其放在一行中。</target>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">请注意,传递给</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">请注意，源代码是作为单个字符串传递的，因此任何使用 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 检测行边界的正则表达式都需要 &lt;code&gt;/m&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="262f4baab34cdad3f12b64cb0a920818da7a10be" translate="yes" xml:space="preserve">
          <source>Note that the spaces are required around the &lt;code&gt;SVf&lt;/code&gt; in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="translated">请注意，如果代码是用C ++编译的，则 &lt;code&gt;SVf&lt;/code&gt; 周围必须有空格，以保持其标准的一致性。</target>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">请注意，特殊变量 &lt;code&gt;$^N&lt;/code&gt; 在代码块中特别有用，可以捕获变量中子匹配的结果，而不必跟踪嵌套括号的数量。例如：</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">请注意，指定的 &lt;code&gt;fail&lt;/code&gt; 行为也适用于嵌套标签。</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">需要注意的是,指定的定界符会自动变成quotemeta'd。</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">请注意，在 &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; 为true 的块中使用 &lt;code&gt;POPs&lt;/code&gt; 弹出堆栈。这是必要的，因为每当</target>
        </trans-unit>
        <trans-unit id="710a5c79e66bbfbe96fbdcb6dc7413e03b66071c" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">请注意，在 &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; 为true的块中使用 &lt;code&gt;POPs&lt;/code&gt; 弹出堆栈。这是必要的，因为每当</target>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">请注意,无穷大的字符串化形式在不同的平台上有所不同:例如,它可以是任何一个</target>
        </trans-unit>
        <trans-unit id="e2587b73a26222076539535f74b276c7c807272c" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">请注意，此处的语法为 &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt; ，而不是 &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt; 。换句话说，在代码表达式的情况下，我们不需要在条件周围加上多余的括号。</target>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">请注意，此处的语法为 &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; ，而不是 &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; 。换句话说，在代码表达式的情况下，我们不需要在条件周围加上多余的括号。</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">请注意， &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中的标签名称没有以&amp;ldquo;：&amp;rdquo; 开头。</target>
        </trans-unit>
        <trans-unit id="6d0f8cfa5599a4759e632a786adcd5ca20b3cfca" translate="yes" xml:space="preserve">
          <source>Note that the third argument to &lt;code&gt;open&lt;/code&gt; is a string containing the program name (&lt;code&gt;sort&lt;/code&gt;) plus all its arguments: in this case, &lt;code&gt;-u&lt;/code&gt; to specify unqiue sort, and then a fileglob specifying the files to sort. The resulting filehandle &lt;code&gt;$sort_fh&lt;/code&gt; works just like a read-only (&lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;) filehandle, and your program can subsequently read data from it as if it were opened onto an ordinary, single file.</source>
          <target state="translated">请注意， &lt;code&gt;open&lt;/code&gt; 的第三个参数是一个包含程序名称（ &lt;code&gt;sort&lt;/code&gt; ）及其所有参数的字符串：在这种情况下， &lt;code&gt;-u&lt;/code&gt; 指定unqiue sort，然后是一个fileglob，指定要排序的文件。生成的文件句柄 &lt;code&gt;$sort_fh&lt;/code&gt; 工作方式类似于只读（ &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ）文件句柄，您的程序随后可以从中读取数据，就像将其打开到普通的单个文件一样。</target>
        </trans-unit>
        <trans-unit id="74bef6f0ef3eec50d14d3b84a1a8afd14c67d76b" translate="yes" xml:space="preserve">
          <source>Note that the third argument, specifying the command that we wish to pipe to, sets up &lt;code&gt;cat&lt;/code&gt; to redirect its output via that &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; symbol into the file &lt;code&gt;numbered.txt&lt;/code&gt;. This can start to look a little tricky, because that same symbol would have meant something entirely different had it showed it in the second argument to &lt;code&gt;open&lt;/code&gt;! But here in the third argument, it's simply part of the shell command that Perl will open the pipe into, and Perl itself doesn't invest any special meaning to it.</source>
          <target state="translated">请注意，第三个参数（指定了我们希望通过其传递的命令）设置了 &lt;code&gt;cat&lt;/code&gt; ,以将其输出通过该 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 符号重定向到文件 &lt;code&gt;numbered.txt&lt;/code&gt; 。这看起来可能有点棘手，因为如果在 &lt;code&gt;open&lt;/code&gt; 的第二个参数中显示相同的符号，则该符号将意味着完全不同的东西。但是在第三个参数中，这只是Perl将打开管道的shell命令的一部分，并且Perl本身并没有对其赋予任何特殊含义。</target>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">请注意,后面的斜杠是必须的。这将导致配置运行时出现一些无害的警告。</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">需要注意的是,受限操作的陷阱并不是原子性的:如</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">请注意，连字符两侧的两个字符不一定都是字母或数字。尽管不建议使用任何字符，但都可以。 &lt;code&gt;['-?]&lt;/code&gt; 包含一系列字符，但是大多数人不知道这意味着什么字符。此外，如果代码必须在使用不同字符集的平台（例如EBCDIC）上运行，则这些范围可能导致可移植性问题。</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">请注意，用户的参数也作为列表传递到插件的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 函数，例如：</target>
        </trans-unit>
        <trans-unit id="b14ba3e78a188703ed0553b34c3137fe88a72a21" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;import()&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">请注意，用户的参数也作为列表传递给插件的 &lt;code&gt;import()&lt;/code&gt; 函数，例如：</target>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">请注意，每次执行 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时都会解析该值。如果省略EXPR，则求值 &lt;code&gt;$_&lt;/code&gt; 。此格式通常用于将EXPR文本的解析和后续执行延迟到运行时。</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">请注意，每次执行 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时都会解析该值。如果省略EXPR，则求值 &lt;code&gt;$_&lt;/code&gt; 。此格式通常用于将EXPR文本的解析和后续执行延迟到运行时。</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">请注意， &lt;code&gt;RV&lt;/code&gt; 的值与我们对$ b进行字符串化时看到的数字一致。IV（）内的地址是保存 &lt;code&gt;SV&lt;/code&gt; 当前状态的 &lt;code&gt;X***&lt;/code&gt; 结构的地址。该地址在SV的生命周期内可能会更改。</target>
        </trans-unit>
        <trans-unit id="66bc2a839853392e6ca68b6e60b0dadd045339b5" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt;. This address may change during lifetime of an SV.</source>
          <target state="translated">请注意， &lt;code&gt;RV&lt;/code&gt; 的值与我们对$ b进行字符串化处理时看到的数字一致。IV（）内的地址是保存 &lt;code&gt;SV&lt;/code&gt; 当前状态的 &lt;code&gt;X***&lt;/code&gt; 结构的地址。该地址在SV的生命周期内可能会更改。</target>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">请注意,这些值不会被复制,这意味着修改这些值会修改哈希的内容。</target>
        </trans-unit>
        <trans-unit id="ebcf1c39304e5cedc9f3bd9f293f7823399a8398" translate="yes" xml:space="preserve">
          <source>Note that the values for the</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">请注意，在编译正则表达式时，变量 &lt;code&gt;$z0&lt;/code&gt; 和 &lt;code&gt;$z1&lt;/code&gt; 不会被替换，就像代码表达式之外的普通变量一样。而是，在perl编译包含文字正则表达式模式的代码的同时，将整个代码块解析为perl代码。</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">注意,有不同的 &quot;长双倍&quot;。Perl会使用编译器所拥有的任何东西。</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">请注意，对于 &lt;code&gt;$0&lt;/code&gt; 的最大长度，存在特定于平台的限制。在最极端的情况下，它可能仅限于原始 &lt;code&gt;$0&lt;/code&gt; 占用的空间。</target>
        </trans-unit>
        <trans-unit id="3ee80c0ec2ca365e28a84cac33edad0345d62e8d" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt;. In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="translated">请注意，对于 &lt;code&gt;$0&lt;/code&gt; 的最大长度，存在特定于平台的限制。在最极端的情况下，它可能仅限于原始 &lt;code&gt;$0&lt;/code&gt; 占用的空间。</target>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">请注意，有很多事情不受当前语言环境的影响。任何文字字符都是给定平台的本机字符。因此，&amp;ldquo; A&amp;rdquo;表示在ASCII平台上的代码点65和EBCDIC上的193。如果该语言环境甚至具有&amp;ldquo; A&amp;rdquo;，则在该语言环境中它可能是也可能不是&amp;ldquo; A&amp;rdquo;。同样，特定字符的所有转义序列（例如 &lt;code&gt;\n&lt;/code&gt; 始终表示平台的本机字符。例如，这意味着正则表达式中的 &lt;code&gt;\N&lt;/code&gt; （每个字符，但换行符）都适用于平台字符集。</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">请注意，没有 &lt;code&gt;unlock()&lt;/code&gt; 函数-解锁变量的唯一方法是允许其超出范围。</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">请注意，不能保证 &lt;code&gt;SvPV()&lt;/code&gt; 的返回值等于 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 或 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 包含有效数据，或者对 &lt;code&gt;SvPV(sv)&lt;/code&gt; 的连续调用每次都将返回相同的指针值。这是由于处理重载和&amp;ldquo;写时复制&amp;rdquo;之类的方式造成的。在这些情况下，返回值可能指向临时缓冲区或类似缓冲区。如果您绝对需要SvPVX字段有效（例如，如果您打算写入该字段），请参见&lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7173a3e77270e17008cce0d5bec933c84a84832b" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt;, or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the &lt;code&gt;SvPVX&lt;/code&gt; field to be valid (for example, if you intend to write to it), then see &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，不能保证 &lt;code&gt;SvPV()&lt;/code&gt; 的返回值等于 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 或 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 包含有效数据，或者对 &lt;code&gt;SvPV(sv)&lt;/code&gt; 的连续调用每次都将返回相同的指针值。这是由于处理超载和写时复制之类的方式造成的。在这些情况下，返回值可能指向临时缓冲区或类似缓冲区。如果您绝对需要 &lt;code&gt;SvPVX&lt;/code&gt; 字段有效（例如，如果您打算写入该字段），请参见 &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">请注意，不再需要导入Tie :: Cycle模块-Attribute :: Handlers会自动进行处理。您甚至可以通过将参数附加到类名，将参数传递给模块的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。例如：</target>
        </trans-unit>
        <trans-unit id="7c645ae5150cd4da2a80be90839d213441cd9479" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;import&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">请注意，不再需要导入Tie :: Cycle模块-Attribute :: Handlers会自动进行处理。您甚至可以将参数附加到类名称中，从而将其传递给模块的 &lt;code&gt;import&lt;/code&gt; 子例程。例如：</target>
        </trans-unit>
        <trans-unit id="0baced4cf34e750c502cd9ad3044c3426673e61e" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the &lt;code&gt;File::Temp&lt;/code&gt; object. The object itself acts as a filehandle. The object isa &lt;code&gt;IO::Handle&lt;/code&gt; and isa &lt;code&gt;IO::Seekable&lt;/code&gt; so all those methods are available.</source>
          <target state="translated">请注意，没有方法可以从 &lt;code&gt;File::Temp&lt;/code&gt; 对象获取文件句柄。对象本身充当文件句柄。对象isa &lt;code&gt;IO::Handle&lt;/code&gt; 和isa &lt;code&gt;IO::Seekable&lt;/code&gt; 因此所有这些方法均可用。</target>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">请注意，没有方法可以从C &amp;lt;：temp&amp;gt;对象获取文件句柄。对象本身充当文件句柄。对象isa C &amp;lt;：handle&amp;gt;和isa C &amp;lt;：seekable&amp;gt;，因此所有这些方法均可用。</target>
        </trans-unit>
        <trans-unit id="d7964282b8c77ed0956498c86928309abbe4d836" translate="yes" xml:space="preserve">
          <source>Note that there is no validation to confirm that the handle is a handle or something that can act like one. Passing something that isn't a handle will cause a exception when trying to read from it. The &lt;code&gt;filename&lt;/code&gt; argument is mandatory or undef will be returned.</source>
          <target state="translated">请注意，没有验证可以确认手柄是手柄还是可以像手柄一样的东西。尝试传递非句柄的内容时会导致异常。该 &lt;code&gt;filename&lt;/code&gt; 参数是强制性的还是民主基金将被退回。</target>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">请注意，定义给定类的多个子类没有错。这既常见又安全。例如，我们可以定义 &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; 和 &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; 类来区分不同类型的mp3文件。</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">请注意,这些配置选项仅用于生成</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">请注意,这些功能与*nix兼容,与94-95年的老端口不兼容。优先级是绝对的,从 32 到 -95,越低越快。0是默认的优先级。</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">请注意，这些函数使用 &lt;code&gt;SV*&lt;/code&gt; 键，从而简化了处理哈希结构的扩展代码的编写。这些功能还允许传递 &lt;code&gt;SV*&lt;/code&gt; 键来 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 功能，而不必强迫您对键进行字符串化（与之前的一组功能不同）。</target>
        </trans-unit>
        <trans-unit id="7cd84224dc690f45347275d943903d70df26fb0c" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;tie&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">请注意，这些函数使用 &lt;code&gt;SV*&lt;/code&gt; 键，从而简化了处理哈希结构的扩展代码的编写。这些功能还允许传递 &lt;code&gt;SV*&lt;/code&gt; 键来 &lt;code&gt;tie&lt;/code&gt; 功能，而不必强迫您对键进行字符串化（与之前的一组功能不同）。</target>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">请注意,这些宏只会在</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">需要注意的是,这些问题不应该阻碍实验,因为它们影响小程序的概率很低。</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">请注意,这些例程是</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">请注意,这些统计数据只是摘要。实际性能将取决于访问散列的真实命中率/失误率。如果你关注命中率,建议你使用以下方法来 &quot;放大 &quot;你的哈希值。</target>
        </trans-unit>
        <trans-unit id="614e9c1a8e14a9fc6d986754f7def273a10af2f8" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag is set), as in both cases, 0 is returned, and, depending on the malformation, &lt;code&gt;retlen&lt;/code&gt; may be set to 1. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;s&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt;; if not, the input had an error. Or you can use &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，此API需要在成功解码 &lt;code&gt;NUL&lt;/code&gt; 字符和错误返回（除非设置了 &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; 标志）之间进行歧义处理，因为在两种情况下，都将返回0，并且根据 &lt;code&gt;retlen&lt;/code&gt; 不同，retlen可能设置为1。归零后，消除歧义，看看 &lt;code&gt;s&lt;/code&gt; 的第一个字节是否也为0。如果是这样，则输入为 &lt;code&gt;NUL&lt;/code&gt; ；否则为0。如果不是，则输入有错误。或者，您可以使用 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">请注意，此API需要在成功解码 &lt;code&gt;NUL&lt;/code&gt; 字符和错误返回（除非设置了UTF8_CHECK_ONLY标志）之间进行歧义处理，因为在两种情况下均返回0。为了消除歧义，返回零时，请查看 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 的第一个字节是否也为0。如果是这样，则输入为 &lt;code&gt;NUL&lt;/code&gt; ; 如果不是，则输入有错误。</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">需要注意的是,现在当我们不产生以下问题时,这个问题就不那么严重了</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">请注意,这种行为与1.00版本的安全模块不同,在1.00版本中,根模块可以用来改变命名空间。该功能已被撤销,有待深入考虑。</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">请注意,转义换行的业务是特定于在调试器中输入的交互式命令。</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">请注意，该类还提供（但不导出）功能Pod :: Simple :: HTMLBatch :: go。这基本上只是 &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 的快捷方式。从命令行进行调用很方便。</target>
        </trans-unit>
        <trans-unit id="f83d5136d4b8e93ddca0e990f1293f696287db16" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt;. It's meant to be handy for calling from the command line.</source>
          <target state="translated">请注意，该类还提供（但不导出）功能Pod :: Simple :: HTMLBatch :: go。这基本上只是 &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 的快捷方式。从命令行进行调用很方便。</target>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">请注意,这不会*崩溃</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">请注意,这并不尊重任何可能生效的locale;它根据平台的本地字符集进行匹配。</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">请注意,这个例子显示了词库的值,而其他例子没有显示(因为它们只在编译时显示)。</target>
        </trans-unit>
        <trans-unit id="750194633912e1b1b2810b4a6624c08076cb7c4d" translate="yes" xml:space="preserve">
          <source>Note that this feature is currently &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt;; using it yields a warning in the &lt;code&gt;experimental::regex_sets&lt;/code&gt; category.</source>
          <target state="translated">请注意，此功能目前处于&lt;a href=&quot;perlpolicy#experimental&quot;&gt;试验阶段&lt;/a&gt;；使用它会在 &lt;code&gt;experimental::regex_sets&lt;/code&gt; 类别中产生警告。</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">需要注意的是,这个函数不会</target>
        </trans-unit>
        <trans-unit id="770403ff8ad9becd7464272640adcfe95f14a6a1" translate="yes" xml:space="preserve">
          <source>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single &lt;code&gt;0&lt;/code&gt; is accepted, but not &lt;code&gt;00&lt;/code&gt; nor &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;002&lt;/code&gt;,</source>
          <target state="translated">请注意，对于UV溢出或前导零的输入，此函数返回FALSE。因此一个单一的 &lt;code&gt;0&lt;/code&gt; 被接受，但不是 &lt;code&gt;00&lt;/code&gt; 也不 &lt;code&gt;01&lt;/code&gt; ， &lt;code&gt;002&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">请注意,这个线束是</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">请注意,这个哈希值不包括数字(如 &quot;64 &quot;或 &quot;x981c&quot;)。</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">请注意，这是从 &lt;code&gt;1.36&lt;/code&gt; 版开始的向后不兼容的更改。</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">注意,这是一个单利运算符,而不是列表运算符。</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">请注意,这是一个实验性的功能,可能会在未来的 Perl 版本中被修改或删除。</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">需要注意的是,一般来说,这种情况不可能出现在那些遗产比较可疑的贝壳上,因为理论上来说,这些贝壳是不存在的。</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">请注意，这与 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; ，后者开始一个新的调度，该调度仅限于搜索当前类的祖先。 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 可以回退当前类-在 &lt;code&gt;$self&lt;/code&gt; 其他祖先中寻找合适的方法-而 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 不能。</target>
        </trans-unit>
        <trans-unit id="511522d55453b336eeec0192506af6b8fb160bde" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt;, which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">请注意，这与 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; ，后者开始了一个新的调度，该调度仅限于搜索当前类的祖先。 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 可以回退当前类-在 &lt;code&gt;$self&lt;/code&gt; 其他祖先中寻找合适的方法-而 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 不能。</target>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">请注意，这是罕见的情况下，你不能使用相同的模板为一个 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 不能确定一个重复计数 &lt;code&gt;()&lt;/code&gt; -group。</target>
        </trans-unit>
        <trans-unit id="31c689cdab9ea9a66fe06d7827f40cae99aad3e2" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; because &lt;code&gt;pack&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt;-group.</source>
          <target state="translated">请注意，这是罕见的情况下，你不能使用相同的模板为一个 &lt;code&gt;pack&lt;/code&gt; ，并 &lt;code&gt;unpack&lt;/code&gt; ，因为 &lt;code&gt;pack&lt;/code&gt; 不能确定一个重复计数 &lt;code&gt;()&lt;/code&gt; -group。</target>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">请注意,这是</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">请注意,这并不是一个真正意义上的英文单词,它只是连续的非空格字符的块。</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">请注意，此问题排除了许多Macintosh特定的CPAN模块（ &lt;code&gt;Mac::*&lt;/code&gt; ）的构建，因为所需的Apple框架不提供PPC64支持。同样，从Fink或Darwinports下载的文件也不可能提供64位支持。必须使用适当的编译器和链接器标志从源代码重建库。有关更多信息，请参阅Apple的</target>
        </trans-unit>
        <trans-unit id="e01d7922e9382b1372af232c43cd56d7c9562fcf" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt;), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">请注意，此问题排除了许多Macintosh特定的CPAN模块（ &lt;code&gt;Mac::*&lt;/code&gt; ）的构建，因为所需的Apple框架不提供PPC64支持。同样，从Fink或Darwinports下载的文件也不可能提供64位支持。必须使用适当的编译器和链接器标志从源代码重建库。有关更多信息，请参阅Apple的</target>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">请注意,最后这个例子是</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">请注意,这意味着Perl希望其他软件也能以同样的方式工作:如果Perl一直认为STDIN应该是UTF-8,但从其他命令中传来的STDIN却不是UTF-8,那么Perl很可能会抱怨UTF-8格式错误。</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">请注意，这意味着内部模式无法引用外部定义的捕获组。（代码块本身可以使用 &lt;code&gt;$1&lt;/code&gt; 等来引用封闭模式的捕获组。）因此，尽管</target>
        </trans-unit>
        <trans-unit id="75120e6f9c48966777ee766b66dc5e5bb92f00ed" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt;,</source>
          <target state="translated">请注意，这意味着内部模式无法引用外部定义的捕获组。（代码块本身可以使用 &lt;code&gt;$1&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="d85a4e8b339d0e328effdd49337132425d3cb1dc" translate="yes" xml:space="preserve">
          <source>Note that this method considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, it does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than &lt;code&gt;undef&lt;/code&gt;, in either case. Thus, in general, it cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls &lt;a href=&quot;IO::Socket#shutdown&quot;&gt;&quot;shutdown&quot; in IO::Socket&lt;/a&gt; or &lt;code&gt;close&lt;/code&gt;. Only at that point does this function return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">请注意，此方法将半开的TCP套接字视为&amp;ldquo;处于连接状态&amp;rdquo;。具体来说，它不会区分&lt;b&gt;ESTABLISHED&lt;/b&gt;和&lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP状态。无论哪种情况，它都返回对等地址，而不是 &lt;code&gt;undef&lt;/code&gt; 。因此，通常，它不能用于可靠地了解对等方是否已启动正常关机，因为在大多数情况下（请参见下文），本地TCP状态机保持&lt;b&gt;CLOSE-WAIT&lt;/b&gt;状态，直到本地应用程序&lt;a href=&quot;IO::Socket#shutdown&quot;&gt;在IO中&lt;/a&gt;调用&amp;ldquo;关机&amp;rdquo;为止：：套接字或 &lt;code&gt;close&lt;/code&gt; 。仅在那时，此函数才返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">请注意，此方法不会像 &lt;code&gt;on the fly&lt;/code&gt; 那样即时编写；在写出归档文件之前，它仍然将所有文件读入内存。如果有问题，请查阅下面的常见问题解答。</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">请注意,这个方法只是返回以'#'开头的注释。</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">请注意，这仅影响大多数算术和关系&lt;b&gt;运算符如何&lt;/b&gt;处理其操作数和结果，&lt;b&gt;而不影响&lt;/b&gt;如何处理所有数字。具体来说， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 其效果是，在计算算术运算符（+，-，*，/，％，+ =，-=，* =，/ =，％=和一元减）的结果之前，比较运算符（&amp;lt;，&amp;lt; =，&amp;gt;，&amp;gt; =，==，！=，&amp;lt;=&amp;gt;）和按位运算符（|，＆，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，| =，＆=，^ =，&amp;lt;&amp;lt; =，&amp;gt;&amp;gt; =），操作数的小数部分将被截断（或取整），结果的小数部分也将被截断。另外，操作数和结果的范围限于熟悉的二进制补码整数，即32位体系结构上的-（2 ** 31）..（2 ** 31-1）和-（2 ** 63）..（2 ** 63-1）在64位架构上。例如，此代码</target>
        </trans-unit>
        <trans-unit id="444b0c1a203433a23ae5410357a56dc9fd46182a" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;use integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">请注意，这仅影响大多数算术和关系&lt;b&gt;运算符如何&lt;/b&gt;处理其操作数和结果，&lt;b&gt;而不影响&lt;/b&gt;如何处理所有数字。具体来说， &lt;code&gt;use integer;&lt;/code&gt; 其效果是，在计算算术运算符（+，-，*，/，％，+ =，-=，* =，/ =，％=和一元减）的结果之前，比较运算符（&amp;lt;，&amp;lt; =，&amp;gt;，&amp;gt; =，==，！=，&amp;lt;=&amp;gt;）和按位运算符（|，＆，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，| =，＆=，＆=，^ =，&amp;lt;&amp;lt; =，&amp;gt;&amp;gt; =），则操作数的小数部分将被截断（或取整），结果的小数部分也将被截断。此外，操作数和结果的范围限于熟悉的二进制补码整数，即32位体系结构上的-（2 ** 31）..（2 ** 31-1）和-（2 ** 63）..（2 ** 63-1）在64位架构上。例如，这段代码</target>
        </trans-unit>
        <trans-unit id="ed01a3c9fe729c5926b4311c21dc0630e4d43559" translate="yes" xml:space="preserve">
          <source>Note that this option alone doesn't cause any debugging information to be output. What it does is stop the normal suppression of execution-related debugging information during the matching portion of the compilation of wildcards. You also have to specify which execution debugging information you want, such as by also including the EXECUTE option.</source>
          <target state="translated">请注意,这个选项本身并不会导致任何调试信息被输出,它所做的是在编译通配符的匹配部分停止正常的抑制与执行相关的调试信息。它所做的是在编译通配符的匹配部分停止正常抑制与执行相关的调试信息。你还必须指定你想要的执行调试信息,比如还包括EXECUTE选项。</target>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">请注意,这个选项在一次转换多个 POD 文件时可能没有用。Unix 命令的手册页的惯例是,即使命令不是大写的,手册页的标题也应该是全大写的。</target>
        </trans-unit>
        <trans-unit id="23d0291a11d0e9160102c369e2e83afde2d6c5ee" translate="yes" xml:space="preserve">
          <source>Note that this option only works with Perl 5.8.4 or better.</source>
          <target state="translated">注意,这个选项只适用于Perl 5.8.4或更高版本。</target>
        </trans-unit>
        <trans-unit id="898ae211ecf9d9481d220ef526611f5faf15a726" translate="yes" xml:space="preserve">
          <source>Note that this section does not document what</source>
          <target state="translated">请注意,本节不记录什么</target>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回一个AV*时,这个类型映射不会递减引用次数。也请参见:T_AVREF_REFCOUNT_FIXED。</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回一个HV*时,这个类型图不会递减引用数。也请参见......T_HVREF_REFCOUNT_FIXED。T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回对SV*的引用时,这个类型图不会递减引用计数。也请参见......T_SVREF_REFCOUNT_FIXED。T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">请注意，此变量是在Perl 5.14.0中添加的。如果要在旧版本的Perl上检测全局销毁阶段，则可以使用CPAN上的 &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">请注意这个版本号与Storable模块本身的版本号不同。例如Storable v0.7创建文件的格式是v2.0,Storable v2.15创建文件的格式是v2.7。文件格式的版本号只有在增加了一些会使旧版本模块混淆的功能时才会递增。</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">请注意,这将不适用于因缺少依赖性而导致测试失败的发行版。另外,使用 &quot;强制 &quot;可以不考虑历史记录而运行测试。</target>
        </trans-unit>
        <trans-unit id="4bcf77d3862c68d316c827809d40fa450ae96c79" translate="yes" xml:space="preserve">
          <source>Note that this will not work on uninstalled perls when called with &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt;, but it works when that path is in &lt;code&gt;$PERL5LIB&lt;/code&gt; or in &lt;code&gt;$PERL5OPT&lt;/code&gt;, as paths passed using &lt;code&gt;-I&lt;/code&gt; are not known when the &lt;code&gt;-V&lt;/code&gt; information is collected.</source>
          <target state="translated">请注意，当使用 &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt; 调用时，这在卸载的perls上将不起作用，但是当该路径在 &lt;code&gt;$PERL5LIB&lt;/code&gt; 或 &lt;code&gt;$PERL5OPT&lt;/code&gt; ，它将起作用，因为使用 &lt;code&gt;-I&lt;/code&gt; 传递的路径在何时不知道在 &lt;code&gt;-V&lt;/code&gt; 信息被收集。</target>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">请注意,这将产生类似的东西,但它更难读。</target>
        </trans-unit>
        <trans-unit id="b8bf897da733e3c7fd8c9b9e480c0bb39918d58f" translate="yes" xml:space="preserve">
          <source>Note that this works only when you &lt;code&gt;decode&lt;/code&gt;. You can set incompatible boolean objects (like &lt;a href=&quot;boolean&quot;&gt;boolean&lt;/a&gt;), but when you &lt;code&gt;encode&lt;/code&gt; a data structure with such boolean objects, you still need to enable &lt;code&gt;convert_blessed&lt;/code&gt; (and add a &lt;code&gt;TO_JSON&lt;/code&gt; method if necessary).</source>
          <target state="translated">请注意，这仅在 &lt;code&gt;decode&lt;/code&gt; 。您可以设置不兼容的布尔对象（如&lt;a href=&quot;boolean&quot;&gt;boolean&lt;/a&gt;），但是当使用此类布尔对象 &lt;code&gt;encode&lt;/code&gt; 数据结构进行编码时，仍然需要启用 &lt;code&gt;convert_blessed&lt;/code&gt; （必要时添加 &lt;code&gt;TO_JSON&lt;/code&gt; 方法）。</target>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">请注意，要创建Bzip2内容，必须安装模块 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">请注意，要创建Bzip2内容，必须安装模块 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 。如果在 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 不可用时尝试创建Bzip2内容，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">请注意，要创建LZMA内容，必须安装模块 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">请注意，要创建Lzma内容，必须安装模块 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 。如果在 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 不可用时尝试创建Lzma内容，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">请注意,要删除断点,请使用'B'。</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">请注意，终止选项处理仍需要双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d940f3704d17dd3194fc775422b4ac6a56659d1f" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">请注意，终止选项处理仍需要使用双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">请注意,将此属性转为true不会抑制一两种关于很少发生的不可恢复的错误的抱怨。</target>
        </trans-unit>
        <trans-unit id="8c769b2bb4c9d14e0051897b1dc06f73914041f2" translate="yes" xml:space="preserve">
          <source>Note that under &lt;code&gt;/i&lt;/code&gt;, a few single characters match two or three other characters. This makes them variable length, and the 255 length applies to the maximum number of characters in the match. For example &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; matches the sequence &lt;code&gt;&quot;ss&quot;&lt;/code&gt;. Your lookbehind assertion could contain 127 Sharp S characters under &lt;code&gt;/i&lt;/code&gt;, but adding a 128th would generate a compilation error, as that could match 256 &lt;code&gt;&quot;s&quot;&lt;/code&gt; characters in a row.</source>
          <target state="translated">请注意，在 &lt;code&gt;/i&lt;/code&gt; 下，一些单个字符与另外两个或三个字符匹配。这使它们的长度可变，并且255的长度适用于匹配中的最大字符数。例如， &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; 与序列 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 匹配。您的后置断言可以在 &lt;code&gt;/i&lt;/code&gt; 下包含127个Sharp S字符，但是添加第128个字符将产生编译错误，因为该错误可以连续匹配256个 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="0b40c66bbd4f3571d75ea521000a6cee32083010" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; depends on the &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; C library function. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the &lt;a href=&quot;posix#open&quot;&gt;&lt;code&gt;POSIX::open&lt;/code&gt;&lt;/a&gt; function. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">请注意，在低于5.8.0的Perls下，&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;取决于&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt; C库函数。在许多Unix系统上，当文件描述符超过某个值（通常为255 &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;）时&lt;/a&gt;，已知fdopen（3）会失败。如果您需要的文件描述符超过此值，请考虑使用&lt;a href=&quot;posix#open&quot;&gt; &lt;code&gt;POSIX::open&lt;/code&gt; &lt;/a&gt;函数。对于Perls 5.8.0和更高版本，（通常）PerlIO是默认设置。</target>
        </trans-unit>
        <trans-unit id="81f7379eb3bd6961a9d597915f1b15a614c4f1c6" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">请注意，在低于5.8.0的Perls中，Perl使用标准C库的&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt;来实现 &lt;code&gt;=&lt;/code&gt; 功能。在许多Unix系统上，当文件描述符超过某个值（通常为255 &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;）&lt;/a&gt;时，fdopen（3）失败。对于Perls 5.8.0和更高版本，（通常）PerlIO是默认值。</target>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">请注意，在低于5.8.0的Perls中，Perl使用标准C库的fdopen（）来实现 &lt;code&gt;=&lt;/code&gt; 功能。在许多Unix系统上，当文件描述符超过某个值（通常为255）时，fdopen（）失败。对于Perls 5.8.0和更高版本，（通常）PerlIO是默认值。</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">请注意,在Win32下</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">请注意,在bigint下,结果会被截断为一个整数。</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">请注意，在某些系统（例如OS / 2）下，可能会有不同类型的Perl可执行文件，其中一些可能支持fork，而有些则不支持。尝试将调用Perl的名称更改为 &lt;code&gt;perl_&lt;/code&gt; ， &lt;code&gt;perl__&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="beba1d81b386ec1f5c90abc173f3ea4f03db2d8a" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt;, &lt;code&gt;perl__&lt;/code&gt;, and so on.</source>
          <target state="translated">请注意，在某些系统（例如OS / 2）下，可能会有不同类型的Perl可执行文件，其中一些可能支持fork，而有些则不支持。尝试将调用Perl的名称更改为 &lt;code&gt;perl_&lt;/code&gt; ， &lt;code&gt;perl__&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">请注意,不幸的是,上述常量都不能保证在特定平台上可用。为了安全起见,你可以用这样的评价来包装导入。</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">请注意，与 &lt;code&gt;\s&lt;/code&gt; （以及 &lt;code&gt;\d&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; ）不同， &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 始终匹配相同的字符，而不考虑其他因素，例如有效的语言环境或源字符串是否为UTF-8格式。</target>
        </trans-unit>
        <trans-unit id="d708883d1ad8d31236c3f53f155ad26ec2c29df3" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt;), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">请注意，与 &lt;code&gt;\s&lt;/code&gt; （以及 &lt;code&gt;\d&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; ）不同， &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 始终匹配相同的字符，而无需考虑其他因素，例如有效的语言环境或源字符串是否为UTF-8格式。</target>
        </trans-unit>
        <trans-unit id="772ce79a861dd3251a8090941fe7f7a3f1e9ae60" translate="yes" xml:space="preserve">
          <source>Note that unlike most other regex magic variables there is no single letter equivalent to &lt;code&gt;@{^CAPTURE}&lt;/code&gt;.</source>
          <target state="translated">请注意，与大多数其他正则表达式魔术变量不同，没有等效于 &lt;code&gt;@{^CAPTURE}&lt;/code&gt; 单个字母。</target>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">请注意,1.00版本的安全模块支持第二个可选参数MASK。该功能已被撤销,等待更深入的考虑。使用下面描述的允许和拒绝方法。</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">请注意，我们现在必须通过循环值作为数组引用，由于 &lt;code&gt;autotie&lt;/code&gt; 机构传递 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的参数作为一个列表的列表（如在铁::无论例子），</target>
        </trans-unit>
        <trans-unit id="5b3c2527a47a822b83bab8f40e829ac7eb6aa7b2" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;tie&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">请注意，我们现在必须通过循环值作为数组引用，由于 &lt;code&gt;autotie&lt;/code&gt; 机构传递 &lt;code&gt;tie&lt;/code&gt; 的参数作为一个列表的列表（如在铁::无论例子），</target>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">请注意，当指定一种不包括所有类别的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式时，Perl会忽略排除的类别。</target>
        </trans-unit>
        <trans-unit id="5b47f718523df526f757f6266d1dae38d1cc63ec" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;use locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">请注意，当指定一种不包括所有类别的 &lt;code&gt;use locale&lt;/code&gt; 形式时，Perl会忽略排除的类别。</target>
        </trans-unit>
        <trans-unit id="a50a1c7dfac9f6431a51ba8239dc629a049684b8" translate="yes" xml:space="preserve">
          <source>Note that when a module installs from CPAN to a core library directory rather than the site library directories, the user gains no protection from having installed it.</source>
          <target state="translated">请注意,当一个模块从CPAN安装到核心库目录而不是站点库目录时,用户不会因为安装了它而获得保护。</target>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">请注意，当输出到禁用流模式的文件（ &lt;code&gt;Stream&lt;/code&gt; 为0）时，输出文件必须是可搜索的。</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">请注意，与该模块一起构建zlib源时，应忽略 &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 标志（位24、25和26）。</target>
        </trans-unit>
        <trans-unit id="726c87af26a5b86094bbbbcff91a0a7370ca0001" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;sprintf&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">请注意，与该模块一起构建zlib源时，应忽略 &lt;code&gt;sprintf&lt;/code&gt; 标志（位24、25和26）。</target>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">需要注意的是,当只有一个章节参数时,URL将仅仅是当前文档中一个章节的链接。</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">需要注意的是,当在Win32的默认构建配置中使用perl时(特别是当perl用PERL_IMPLICIT_SYS构建时),每个perl解释器都会维护自己的环境副本,只有主解释器会更新strftime看到的进程环境。</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">请注意，在Linux中使用线程时，这&lt;b&gt;不是&lt;/b&gt;退出线程的好方法，因为在Linux中，进程和线程是一回事（请注意：虽然在2003年初是这种情况，但有些项目正在进行使用Linux中的更多POSIXly语义）。如果不想从线程返回，请分离线程。</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">请注意，当您传递文件句柄时，压缩参数将被忽略，因为所有文件都将逐字打印到您的文件句柄中。如果希望使用文件句柄启用压缩，请改用 &lt;code&gt;IO::Zlib&lt;/code&gt; 或 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 文件句柄。</target>
        </trans-unit>
        <trans-unit id="3ec13b11833cba251c4e9511d82658d6fc77550f" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or &lt;code&gt;IO::Compress::Xz&lt;/code&gt; filehandle instead.</source>
          <target state="translated">请注意，当您传递文件句柄时，压缩参数将被忽略，因为所有文件都将逐字打印到您的文件句柄中。如果希望使用文件句柄启用压缩，请改用 &lt;code&gt;IO::Zlib&lt;/code&gt; ， &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 或 &lt;code&gt;IO::Compress::Xz&lt;/code&gt; 文件句柄。</target>
        </trans-unit>
        <trans-unit id="870efa0c38496f8567ab5707b290598c28081f5a" translate="yes" xml:space="preserve">
          <source>Note that where possible, values should be saved in the context struct rather than on the save stack; it's much faster that way.</source>
          <target state="translated">请注意,在可能的情况下,应该将值保存在上下文结构中,而不是保存在保存堆栈中,这样会快很多。</target>
        </trans-unit>
        <trans-unit id="bbf20737dd41f077e46c31d590a5ed13707c1390" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">请注意，在信号（例如SIGALRM）发出信号后，&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;是否重新启动取决于实现。参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;上的便携笔记&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在信号（例如SIGALRM）发出信号后， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 是否重新启动取决于实现。参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;上的便携笔记 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在信号（例如SIGALRM）发出信号后， &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 是否重新启动取决于实现。参见&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;上的便携笔记 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">请注意，尽管 &lt;code&gt;prove&lt;/code&gt; 接受测试（或要测试的事物）列表，但是 &lt;code&gt;new&lt;/code&gt; 具有一组相当丰富的参数。您可能需要仔细阅读此代码，以了解如何使用它们。</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">需要注意的是,虽然上述类别体系目前是严格的等级制度,但不应该假设。</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">需要注意的是,虽然线程本身是独立的执行线程,除非明确共享,否则Perl数据是线程私有的,但线程可以影响进程范围的状态,影响所有的线程。</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">请注意,虽然我们使用了一个漂亮的小脚本来获得这个值,但没有一个简单的方法来实现</target>
        </trans-unit>
        <trans-unit id="91f5f2f1e7150921d4bad701418dc42005b9e8df" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">请注意，在带括号的列表中，&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;可以用作虚拟占位符，例如，跳过初始值的分配：</target>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">请注意，在带括号的列表中， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符，例如，跳过初始值的分配：</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">请注意，在带括号的列表中， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符，例如，跳过初始值的分配：</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">请注意,在上述所有情况下,您可以通过检查&quot;=over&quot;...&quot;=back &quot;命令后的第一段(非&quot;=cut&quot;,非&quot;=pod&quot;)Pod段来确定哪种类型。&quot;=back&quot;,通过检查&quot;=over &quot;命令后的第一个(非&quot;=cut&quot;,非&quot;=pod&quot;)Pod段。</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">请注意,写是</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">请注意,您</target>
        </trans-unit>
        <trans-unit id="f571df233f4fa852ab6d69ef3a354636c953afea" translate="yes" xml:space="preserve">
          <source>Note that you &lt;b&gt;must&lt;/b&gt; quote the version when writing an alpha Decimal version. The stringified form of Decimal versions will always be the same string that was used to initialize the version object.</source>
          <target state="translated">请注意，编写Alpha十进制版本时&lt;b&gt;必须&lt;/b&gt;引用该版本。十进制版本的字符串化形式将始终与用于初始化版本对象的字符串相同。</target>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">请注意，您始终必须重新抛出已捕获的异常。使用这些宏，不可能只捕获异常并忽略它。如果必须忽略该异常，则必须使用 &lt;code&gt;call_*&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">请注意，您也可以在单个 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 中应用两个或多个相同类型的过滤器。例如，这是一个仅在正则表达式中应用的简单宏预处理程序，并带有最终的调试过程，可打印出最终的源代码：</target>
        </trans-unit>
        <trans-unit id="2ed5dd8db2d6301ae073b216ad36ce2358ae0947" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt;. For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">请注意，您也可以在单个 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 中应用两个或多个相同类型的过滤器。例如，这是一个仅在正则表达式中应用的简单宏预处理程序，并带有最终的调试过程，可打印出最终的源代码：</target>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">请注意，您还可以将 &lt;code&gt;batch_convert&lt;/code&gt; 作为类方法调用，如下所示：</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">请注意,您也可以使用:</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">请注意，您目前可以&lt;b&gt;不&lt;/b&gt;传递 &lt;code&gt;gzip&lt;/code&gt; 压缩的文件句柄，这是不符合开 &lt;code&gt;IO::Zlib&lt;/code&gt; ，一个 &lt;code&gt;bzip2&lt;/code&gt; 的压缩文件句柄，这是不符合开 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; ，也不包含完整的存档信息的字符串（压缩或未压缩）。这些功能虽然值得，但目前尚未实现。请参阅&amp;ldquo; &lt;code&gt;TODO&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="36599b3f8142ec45ea2057810c7d1951232a084e" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt;, a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt;, a &lt;code&gt;xz&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt;, nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">请注意，您目前可以&lt;b&gt;不&lt;/b&gt;传递 &lt;code&gt;gzip&lt;/code&gt; 压缩的文件句柄，这是不符合开 &lt;code&gt;IO::Zlib&lt;/code&gt; ，一个 &lt;code&gt;bzip2&lt;/code&gt; 的压缩文件句柄，这是不符合开 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; ，一个 &lt;code&gt;xz&lt;/code&gt; 压缩文件句柄，这是不符合开业 &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt; 或包含完整存档信息（压缩或未压缩）的字符串。这些功能虽然值得，但目前尚未实现。请参阅&amp;ldquo; &lt;code&gt;TODO&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="80d20f2cbb1dd523835c53fe8971ba143f49fe81" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="translated">注意，您可以定义自己的属性。请参见&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode中的&amp;ldquo;用户定义的字符属性&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">注意，您可以定义自己的属性。请参见&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode中的用户定义字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">请注意，您可以通过URL链接与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; 匹配来区分其他链接。因此 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; 是URL，但 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; 不是URL 。</target>
        </trans-unit>
        <trans-unit id="64a115a0f7c10604758c941480143a80f74b2845" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt;. So &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">请注意，您可以通过URL链接与 &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt; 匹配来区分其他链接。因此 &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; 是URL，而 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; 不是URL 。</target>
        </trans-unit>
        <trans-unit id="b5601b7465138e046c297f9bd7f032a15e613deb" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using &lt;code&gt;binmode()&lt;/code&gt;.</source>
          <target state="translated">请注意，您也可以使用 &lt;code&gt;binmode()&lt;/code&gt; 来修改File :: Temp打开的文件的编码。</target>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">需要注意的是,你也可以通过使用C语言修改File::Temp打开的文件编码。</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">请注意，您可以使用 &lt;code&gt;ls&lt;/code&gt; 命令来列出此路径。</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">请注意,你可以用它来嵌套 &quot;todo &quot;测试。</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">请注意,如果你使用的是安全信号,你就不能可靠地阻断或解除阻断来自其自身信号处理程序的信号。其他信号可以被可靠地阻断或解除阻断。</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">需要注意的是,不能仅根据</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">请注意,你不能显式地解锁一个变量;你只能等待锁退出范围。这可以通过将变量锁定在一个块中来实现。</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">请注意，您无法使用以下命令测试&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; -ness&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="46d548823c2cd0fd3c7dcc027abf5e4fd2f7c713" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt;-ness&quot; with</source>
          <target state="translated">请注意，您不能测试&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; -ness&amp;rdquo;与</target>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">请注意,您不能在 @EXPORT 或 @EXPORT_OK 中使用标签。</target>
        </trans-unit>
        <trans-unit id="c1c43451d9784c36057c8528c7269957014b039f" translate="yes" xml:space="preserve">
          <source>Note that you do not have to use wildcards. You can specify explicitly which subdirectories to run tests in:</source>
          <target state="translated">请注意,你不必使用通配符。你可以明确地指定要运行测试的子目录。</target>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">请注意,你没有(重新)指定方法名。它迫使你总是使用与你开始使用的方法相同的方法名。</target>
        </trans-unit>
        <trans-unit id="1110cd59b64cb9b7410432e108a9ed2c0c79bda1" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; yourself since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">请注意，您无法使用 &lt;code&gt;ARGV&lt;/code&gt; 文件句柄以这种方式处理&lt;a href=&quot;#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;错误。在这种情况下，由于&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; 对&lt;/a&gt; &lt;code&gt;ARGV&lt;/code&gt; 的处理方式不同，因此您必须自己打开&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; 的&lt;/a&gt;每个元素。</target>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">请注意，使用 &lt;code&gt;ARGV&lt;/code&gt; 文件句柄无法以这种方式处理 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 错误。在这种情况下，由于 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;ARGV&lt;/code&gt; 的处理方式不同，因此您必须自己打开 &lt;code&gt;@ARGV&lt;/code&gt; 的每个元素。</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">请注意，使用 &lt;code&gt;ARGV&lt;/code&gt; 文件句柄无法以这种方式处理 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 错误。在这种情况下，由于 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;ARGV&lt;/code&gt; 的处理方式不同，因此您必须自己打开 &lt;code&gt;@ARGV&lt;/code&gt; 的每个元素。</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">请注意,除了用于输出的短语外,你可能还有一些东西存储在词典中:例如,如果你的程序从键盘上接受输入,问一个&quot;(Y/N)&quot;的问题,你可能需要知道 &quot;Y[es]/N[o]&quot;在任何语言中的等价物是什么。你可能还需要知道答案 &quot;y &quot;和 &quot;n &quot;的等价物是什么。你可以将这些信息存储在词典中(比如说,在&quot;~answer_y &quot;和&quot;~answer_n &quot;这两个键下,长的形式是&quot;~answer_yes &quot;和&quot;~answer_no&quot;,其中&quot;~&quot;只是一个临时字符,目的是向程序员/翻译人员表明这些不是用于输出的短语)。</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">请注意，您可以在目录列表中混合使用目录和（非目录）文件，以通过 &lt;code&gt;wanted()&lt;/code&gt; 函数进行搜索。</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">请注意，如果您想翻译编码甚至脚本，在某些情况下用&amp;ldquo; after method&amp;rdquo; 覆盖 &lt;code&gt;maketext&lt;/code&gt; 方法可能会很有用：</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">请注意,您必须为 $new_name 指定一个 Unix 路径,因为根据 tar 标准,存档中的所有文件都必须是 Unix 路径。</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">请注意,您需要安装Module::Signature模块才能执行此操作。</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">请注意,你应该加载这个模块</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">请注意，由于 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 会捕获其他致命错误，因此对于确定是否实现了特定功能（例如 &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ）非常有用。这也是Perl的异常捕获机制，使用die运算符引发异常。</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">请注意，由于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 会捕获其他致命错误，因此对于确定是否实现了特定功能（例如 &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ）非常有用。这也是Perl的异常捕获机制，使用die运算符引发异常。</target>
        </trans-unit>
        <trans-unit id="891df8b540bc28be318d138e0d3e28e333361aa1" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;eval&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; operator is used to raise exceptions.</source>
          <target state="translated">请注意，由于 &lt;code&gt;eval&lt;/code&gt; 会捕获其他致命错误，因此对于确定是否实现了特定功能（例如&lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt; &lt;code&gt;symlink&lt;/code&gt; &lt;/a&gt;）非常有用。这也是Perl的异常捕获机制，使用&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;运算符引发异常。</target>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">注意，由于 &lt;code&gt;Cycle&lt;/code&gt; 属性在 &lt;code&gt;$data&lt;/code&gt; 变量中接收其参数，因此，如果给该属性一个参数列表，则 &lt;code&gt;$data&lt;/code&gt; 将由一个数组引用组成；否则，它将直接由单个参数组成。由于Tie :: Cycle要求将其循环值作为数组引用传递，因此这意味着我们需要将非数组引用参数包装在数组构造函数中：</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">请注意，出于历史兼容性，还可以使用 &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 代替 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb52146528e00d45c6657da7bafa7f9366f782d" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt;.</source>
          <target state="translated">请注意，出于历史兼容性，还可以使用 &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 代替 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">请注意，如果启用了选项 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 以及auto_abbrev，则可能的参数和选项设置为：</target>
        </trans-unit>
        <trans-unit id="49deca6d624d23372bddba3920f15c27d6789299" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt;, and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">请注意，如果启用了选项 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 以及auto_abbrev，则可能的参数和选项设置为：</target>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">请注意,如果您希望以非交互方式运行Configure(详见INSTALL文档),要让它选择正确的提示文件,您需要在Configure命令行中提供参数-Dhintfile=riscos。</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">需要注意的是，如果你的代码是在推荐的运行 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; 编译，您将需要声明这些包变量 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="399039fd0a4c09c727bec9d6e24cc011d4967d80" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;use strict vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;our&lt;/code&gt;:</source>
          <target state="translated">需要注意的是，如果你的代码是在推荐的运行 &lt;code&gt;use strict vars&lt;/code&gt; 编译，您将需要声明这些包变量 &lt;code&gt;our&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">请注意，与 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;unless&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; 语句始终求值为空列表时，失败。</target>
        </trans-unit>
        <trans-unit id="b41c93e43651e0e37405584834ec3d27a0bc44f8" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">请注意，与 &lt;code&gt;if&lt;/code&gt; 和if &lt;code&gt;unless&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; 语句始终求值为空列表时，失败。</target>
        </trans-unit>
        <trans-unit id="afd6a1e156c7625206e1247c798d73aecaea5a68" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-hexadecimal up to the ending brace is ignored.</source>
          <target state="translated">请注意,在大括号内,从第一个非十六进制开始的每一个字符到最后的大括号都会被忽略。</target>
        </trans-unit>
        <trans-unit id="903c4c2bcdceef7b085f257005c8eb256d0f0ea7" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-octal up to the ending brace is ignored.</source>
          <target state="translated">请注意,在大括号内,从第一个非八进制开始的每一个字符到最后的大括号都会被忽略。</target>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">注意</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">注意 &lt;code&gt;!&lt;/code&gt; 之后 &lt;code&gt;l&lt;/code&gt; ：我们要确保打包一个长整数，因为它是由C编译器编译的。即使在现在，它也仅适用于编译器按上述方式对齐的平台。而且某个地方的人有一个平台却没有。[可能是Cray，其中 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 均为8个字节。:-)]</target>
        </trans-unit>
        <trans-unit id="0e14a4a995907061486f3bd76c1f023bc121f4f5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt;: We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt;s, &lt;code&gt;int&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt;s are all 8 bytes. :-)]</source>
          <target state="translated">注意 &lt;code&gt;!&lt;/code&gt; 之后 &lt;code&gt;l&lt;/code&gt; ：我们要确保打包一个长整数，因为它是由C编译器编译的。甚至现在，它也仅适用于编译器按上述方式对齐内容的平台。而且某个地方的人有一个平台却没有。[可能是Cray，其中 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 均为8个字节。:-)]</target>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">请注意，上面的 &lt;code&gt;$]&lt;/code&gt; 不是文字。替换要 &lt;code&gt;5.6.0&lt;/code&gt; 该条目的任何版本的perl，例如5.6.0。与Windows一样，路径必须用分号分隔。</target>
        </trans-unit>
        <trans-unit id="99261696a47484abd841ec0d1ec91dfef269c276" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt;. Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">请注意，上面的 &lt;code&gt;$]&lt;/code&gt; 不是文字。替换要 &lt;code&gt;5.6.0&lt;/code&gt; 该条目的任何版本的perl，例如5.6.0。与Windows一样，路径必须用分号分隔。</target>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; 表达式被 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; 包围。其背后的思想与使 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate' 的经典习语相同：</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">请注意 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; s：自动生成会导致标准运算符的方法不变，例如 &lt;code&gt;-&lt;/code&gt; ，该标准运算符不会更改其两个操作数（用于实现更改操作数的运算符（&amp;ldquo; mutators&amp;rdquo;：此处为 &lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;-=&lt;/code&gt; ），Perl将undef作为第三个参数传递。这仍然被评估为FALSE，这与操作数没有被交换的事实相一致，但是在这些情况下，子例程有机会改变其行为。</target>
        </trans-unit>
        <trans-unit id="200da24930e3f664e651210aeef65207c51b5b78" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;tr//&lt;/code&gt; expression is surrounded by &lt;code&gt;qq{}&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;tr///&lt;/code&gt; 'interpolate':</source>
          <target state="translated">请注意， &lt;code&gt;tr//&lt;/code&gt; 表达式被 &lt;code&gt;qq{}&lt;/code&gt; 包围。其背后的思想与使 &lt;code&gt;tr///&lt;/code&gt; 'interpolate'的经典习语相同：</target>
        </trans-unit>
        <trans-unit id="8c7ea810ebe5fef24b0b382427a65305a168d9de" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;undef&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt;, being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt;), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">请注意 &lt;code&gt;undef&lt;/code&gt; ：在自动生成的情况下，标准操作符的方法不会更改其两个操作数中的任何一个，例如 &lt;code&gt;-&lt;/code&gt; ，用于实现更改操作数的操作符（&amp;ldquo; mutators&amp;rdquo;：此处， &lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;-=&lt;/code&gt; ），Perl将undef传递为第三个参数。这仍然被评估为FALSE，这与操作数没有被交换的事实相一致，但是在这些情况下，子例程有机会改变其行为。</target>
        </trans-unit>
        <trans-unit id="db05bb20e1742aeb610b95cb1ced4c32c7213bb5" translate="yes" xml:space="preserve">
          <source>Note the API instability warning in &lt;a href=&quot;#setpayload&quot;&gt;&quot;setpayload&quot;&lt;/a&gt;.</source>
          <target state="translated">注意&lt;a href=&quot;#setpayload&quot;&gt;&amp;ldquo; setpayload&amp;rdquo;中&lt;/a&gt;的API不稳定警告。</target>
        </trans-unit>
        <trans-unit id="08c6b44fb15bcf48412bfa33391fc2030093296e" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; to do the reverse.</source>
          <target state="translated">请注意，LIST是整个前面的前缀，而不是一次一个元素，因此，这些前面的元素保持相同的顺序。使用&lt;a href=&quot;#reverse-LIST&quot;&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/a&gt;进行反向。</target>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">请注意，LIST是整个前面的前缀，而不是一次一个元素，因此，前面的元素保持相同的顺序。使用 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 进行反向。</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">请注意，LIST是整个前面的前缀，而不是一次一个元素，因此，前面的元素保持相同的顺序。使用 &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 进行反向。</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">注意对PERL_SET_CONTEXT()的调用。这些调用对于初始化全局状态是必要的,因为全局状态可以跟踪在运行它的特定进程或线程上哪个解释器是 &quot;当前 &quot;解释器。如果你有一个以上的解释器,并且以交错的方式在两个解释器上进行perl API调用,那么应该始终使用它。</target>
        </trans-unit>
        <trans-unit id="b5b392e74eb48b0aee9cb28bffd1d6dc73cfac7a" translate="yes" xml:space="preserve">
          <source>Note the early capture of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;old_ss_ix&lt;/code&gt;, which is later passed as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;. In the case of &lt;code&gt;pp_entersub&lt;/code&gt;, this is because, although most values needing saving are stored in fields of the context struct, an extra value needs saving only when the debugger is running, and it doesn't make sense to bloat the struct for this rare case. So instead it is saved on the savestack. Since this value gets calculated and saved before the context is pushed, it is necessary to pass the old value of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;cx_pushblock&lt;/code&gt;, to ensure that the saved value gets freed during scope exit. For most users of &lt;code&gt;cx_pushblock&lt;/code&gt;, where nothing needs pushing on the save stack, &lt;code&gt;PL_savestack_ix&lt;/code&gt; is just passed directly as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;.</source>
          <target state="translated">注意将 &lt;code&gt;PL_savestack_ix&lt;/code&gt; 早期捕获到 &lt;code&gt;old_ss_ix&lt;/code&gt; 中，然后将其作为arg传递给 &lt;code&gt;cx_pushblock&lt;/code&gt; 。就 &lt;code&gt;pp_entersub&lt;/code&gt; 而言，这是因为，尽管大多数需要保存的值都存储在上下文结构的字段中，但只有在调试器运行时才需要保存一个额外的值，因此对于这种罕见的情况而言，膨胀结构是没有意义的案子。因此，它被保存在保存堆栈中。由于此值是在推送上下文之前计算并保存的，因此有必要将 &lt;code&gt;PL_savestack_ix&lt;/code&gt; 的旧值传递给 &lt;code&gt;cx_pushblock&lt;/code&gt; ，以确保在范围退出时释放保存的值。对于 &lt;code&gt;cx_pushblock&lt;/code&gt; 的大多数用户，不需要将任何内容压入保存堆栈， &lt;code&gt;PL_savestack_ix&lt;/code&gt; 只是作为arg直接传递给 &lt;code&gt;cx_pushblock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86c788344d48bbaf6f108e51a7241322de827d97" translate="yes" xml:space="preserve">
          <source>Note the emphasis on bytes: even if the filehandle has been set to operate on characters (for example using the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I/O layer), the &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; family of functions use byte offsets, not character offsets, because seeking to a character offset would be very slow in a UTF-8 file.</source>
          <target state="translated">请注意对字节的强调：即使已将文件句柄设置为对字符进行操作（例如，使用 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I / O层），&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek&lt;/code&gt; &lt;/a&gt;系列函数也使用字节偏移量，而不是字符偏移量，因为在UTF-8文件中查找字符偏移量将非常慢。</target>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">请注意上面几个字节条目前用 &quot;*&quot;标记的空白。这些空白是由合法的UTF-8避免使用非最短编码造成的:从技术上讲,可以用不同的方式对一个代码点进行UTF-8-encode,但这是被明确禁止的,应该始终使用最短的编码(Perl也是这样做的)。</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">注意分号。除了内部代码没有立即执行之外， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 与其说是运算符，不如说是声明，就像 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 。（但是，无论您执行该特定行多少次（除非您处于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; ），$ coderef仍将引用</target>
        </trans-unit>
        <trans-unit id="ba98181394143476434b95cb278177df7d3eab51" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;sub {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;do{}&lt;/code&gt; or &lt;code&gt;eval{}&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">注意分号。除了内部代码没有立即执行之外， &lt;code&gt;sub {}&lt;/code&gt; 与其说是运算符，不如说是声明符，就像 &lt;code&gt;do{}&lt;/code&gt; 或 &lt;code&gt;eval{}&lt;/code&gt; 。（但是，无论您执行该特定行多少次（除非您处于 &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt; ），$ coderef仍将引用</target>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">注意以下两种形式。</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">注意在上一个示例中使用 &lt;code&gt;$&lt;/code&gt; 代替 &lt;code&gt;\&lt;/code&gt; 。与&lt;b&gt;sed&lt;/b&gt;不同，我们使用\ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="774d755cbcc9927f9bd666b04c889ec17f9ec2e7" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;code&gt;Minimal&lt;/code&gt; option in the code above. When using gzip for Content-Encoding you should</source>
          <target state="translated">请注意，上面的代码中使用了 &lt;code&gt;Minimal&lt;/code&gt; 选项。使用gzip进行内容编码时，您应该</target>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">注意这里有两个不同的步骤。1)你必须创建Wild.pm并把它放在你的perl lib目录下.2)你需要设置PERL5OPT环境变量。如果你想让argv扩展为默认值,只要在你的默认启动环境中设置PERL5OPT即可。</target>
        </trans-unit>
        <trans-unit id="3aa39411508c2033438cf708df8c04c8a846a8d6" translate="yes" xml:space="preserve">
          <source>Note there is a distinction between a capture buffer which matches the empty string a capture buffer which is optional. Eg, &lt;code&gt;(x?)&lt;/code&gt; and &lt;code&gt;(x)?&lt;/code&gt; The latter may be undef, the former not.</source>
          <target state="translated">注意，与空字符串匹配的捕获缓冲区与可选的捕获缓冲区之间是有区别的。例如 &lt;code&gt;(x?)&lt;/code&gt; 和 &lt;code&gt;(x)?&lt;/code&gt; 后者可能是不确定的，前者可能不是。</target>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">请注意，出于性能原因，此接口比 &lt;code&gt;gv_stashpvn&lt;/code&gt; 更为可取。</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">请注意,这是0级补丁的当前值,随时可能发生变化。</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">需要注意的是,这也可能会触发以下结构,如。</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">请注意,此举使得\x{D800}-\x{DFFF}变成了一个禁区,但perl并不禁止使用这个范围内的字符。对perl来说,从x{0000_0000}到x{ffff_ffff}的每一个字符。(*)是</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">注意仍在使用Perl 5.18或更早版本的用户：使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 将减慢程序中&lt;b&gt;所有&lt;/b&gt;正则表达式的使用。请向&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;查询 &lt;code&gt;@-&lt;/code&gt; 以查看不会导致变慢的等效表达式。参见&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt;。从Perl 5.10开始，还可以使用等效变量 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，但是要定义它们，则必须在 &lt;code&gt;/p&lt;/code&gt; （preserve）中指定修饰符。正则表达式。在Perl 5.20中，使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 没有速度差异。</target>
        </trans-unit>
        <trans-unit id="58f853df3fafdf36ed80cd1751e4f069c0f1707d" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">注意仍在使用Perl 5.18或更早版本的用户：使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 将减慢程序中&lt;b&gt;所有&lt;/b&gt;正则表达式的使用。请向&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;查询 &lt;code&gt;@-&lt;/code&gt; 以查看不会导致速度变慢的等效表达式。另请参见&lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt;。从Perl 5.10开始，还可以使用等效变量 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，但是要定义它们，则必须在 &lt;code&gt;/p&lt;/code&gt; （preserve）中指定修饰符。正则表达式。在Perl 5.20中，使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 没有速度差异。</target>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">还请注意,当在一个regex上使用/x修饰符时,任何包含当前模式定界符的注释都会导致regex立即终止。换句话说</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">但是,请注意,&quot;=begin&quot;。</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">但请注意,(与大多数其他OO语言不同)Perl并没有以任何方式确保或强制封装。如果你想让对象真正</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">但是请注意，格式代码和Z &amp;lt;&amp;gt;可以出现在L &amp;lt;...&amp;gt;的任何部分（即</target>
        </trans-unit>
        <trans-unit id="1ced7964eb00ec0017dbaa24226307b98c43e3bb" translate="yes" xml:space="preserve">
          <source>Note, however, that sometimes the Pod events aren't processed in exactly the same order as the code lines are -- i.e., if you have a file with Pod, then code, then more Pod, sometimes the code will be processed (via whatever you have code_handler call) before the all of the preceding Pod has been processed.</source>
          <target state="translated">但是,请注意,有时Pod事件的处理顺序与代码行的处理顺序并不完全相同--也就是说,如果你的文件中有Pod,然后是代码,然后是更多的Pod,有时代码会在前面所有的Pod被处理之前被处理(通过你的code_handler调用)。</target>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">但请注意,这并不总是适用于引用Perl代码。</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">但是,请注意,这限制了某些值的本地化;例如,以下语句在 perl 5.10.0 时死机,出现错误</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">请注意，顺便说一句，每个组中的项目用逗号分隔，而不是 &lt;code&gt;/\s*,\s*/&lt;/code&gt; -分隔。也就是说，您可能期望此支架组：</target>
        </trans-unit>
        <trans-unit id="c6f16890b60d4dbdb1b39ad263c84c7dffbf2eae" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt;-separated. That is, you might expect that this bracket group:</source>
          <target state="translated">请注意，顺便说一句，每个组中的项目用逗号分隔，而不是 &lt;code&gt;/\s*,\s*/&lt;/code&gt; -分隔。也就是说，您可能期望此支架组：</target>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">注意，可能未指定模块的版本，其值是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此，如果要测试的是，则使用 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0424f392af8ee6773275c7a49c920c35add5c370" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;undef&lt;/code&gt;, so use &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">请注意，可能未指定模块的版本，其值是 &lt;code&gt;undef&lt;/code&gt; ，因此，如果要测试的内容，请使用 &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48e4009ec57ba2c9432c9aea5b719c678f3436d3" translate="yes" xml:space="preserve">
          <source>Note, prior to 5.25 this function returned what is now returned by the hv_bucket_ratio() function.</source>
          <target state="translated">注意,在5.25之前,这个函数返回的是现在的函数 hv_bucket_ratio()。</target>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">请注意，从Perl 5.18开始，名称 &lt;code&gt;BELL&lt;/code&gt; 指的是Unicode字符U + 1F514，而不是传统的U + 0007。对于后者，请使用 &lt;code&gt;ALERT&lt;/code&gt; 或 &lt;code&gt;BEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610f3ee797f1ad4a61eeefe27944e6e308608f88" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt;.</source>
          <target state="translated">请注意，从Perl 5.18开始，名称 &lt;code&gt;BELL&lt;/code&gt; 指的是Unicode字符U + 1F514，而不是传统的U + 0007。对于后者，请使用 &lt;code&gt;ALERT&lt;/code&gt; 或 &lt;code&gt;BEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">注意,在这两种情况下,tilde的扩展都是由MakeMaker完成的,而不是perl默认的,也不是由make完成的。</target>
        </trans-unit>
        <trans-unit id="557c3756e4a3c96fb446dffbb0c22ffbb956fd7d" translate="yes" xml:space="preserve">
          <source>Note, there is a limitation of this technique. Some compression file formats store extra information along with the compressed data payload. For example, gzip can optionally store the original filename and Zip stores a lot of information about the original file. If the original compressed file contains any of this extra information, it will not be transferred to the new compressed file using the technique above.</source>
          <target state="translated">注意,这种技术有一个局限性。一些压缩文件格式会在压缩数据有效载荷的同时存储额外的信息。例如,gzip可以选择存储原始文件名,Zip存储了很多关于原始文件的信息。如果原始压缩文件包含任何这些额外信息,那么使用上述技术将不会传输到新的压缩文件中。</target>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下， &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 不会导入这些常量。</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下，这些常量不是由 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 导入的。</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下， &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 不会导入这些常量。</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下，这些常量不是由 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 导入的。</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">注意，出于性能原因，强烈建议在可能的 &lt;code&gt;gv_stashpvn&lt;/code&gt; 下使用 &lt;code&gt;gv_stashsv&lt;/code&gt; 代替gv_stashpvn。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="04e9999aa448d4f7736e19660c8cdd3fdd576ad9" translate="yes" xml:space="preserve">
          <source>Note: 'pinyin' is Han in Latin, 'zhuyin' is Han in Bopomofo.</source>
          <target state="translated">注:'拼音'是拉丁语中的汉字,'zhuyin'是波波摩佛语中的汉字。</target>
        </trans-unit>
        <trans-unit id="4cdcc6395bb5bb305f89c21276194ad5f5be7723" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; on directories is not supported on many operating systems. Use &lt;a href=&quot;#rmdir-FILENAME&quot;&gt;&lt;code&gt;rmdir&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注意：除非您是超级用户，并且&lt;b&gt;-U&lt;/b&gt;标志提供给Perl，否则&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;不会尝试删除目录。即使满足这些条件，也要警告取消目录链接可能会损坏文件系统。最后，许多操作系统不支持在目录上使用&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;。请改用&lt;a href=&quot;#rmdir-FILENAME&quot;&gt; &lt;code&gt;rmdir&lt;/code&gt; &lt;/a&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注意：除非您是超级用户，并且&lt;b&gt;-U&lt;/b&gt;标志提供给Perl，否则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会尝试删除目录。即使满足这些条件，也要警告取消目录链接可能会损坏文件系统。最后，许多操作系统不支持在目录上使用 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 。请改用 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">注意：在此示例中不需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ： &lt;code&gt;strftime()&lt;/code&gt; 是POSIX函数，它使用标准的系统提供的 &lt;code&gt;libc&lt;/code&gt; 函数，该函数始终遵循当前的 &lt;code&gt;LC_TIME&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">注意：在某些示例中未显示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，因为它不是必需的： &lt;code&gt;strcoll()&lt;/code&gt; 和 &lt;code&gt;strxfrm()&lt;/code&gt; 是POSIX函数，它们使用标准的系统提供的 &lt;code&gt;libc&lt;/code&gt; 函数，这些函数始终遵循当前的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注意：除非您是超级用户，并且&lt;b&gt;-U&lt;/b&gt;标志提供给Perl，否则 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会尝试删除目录。即使满足这些条件，也要警告取消目录链接可能会损坏文件系统。最后，许多操作系统不支持在目录上使用 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 。请改用 &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">注意： &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 将在图层中搜索一个stdio图层。如果找不到，它将调用 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 生成一个新的stdio &lt;code&gt;FILE&lt;/code&gt; 。如果需要，请仅致电 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="724e5762fee6d350a318fc2fb4b30294baaefc44" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt;. Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">注意： &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 将在图层中搜索一个stdio图层。如果找不到，它将调用 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 生成一个新的stdio &lt;code&gt;FILE&lt;/code&gt; 。如果需要，请仅致电 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09f6afd463560b84ea6b975b1be869772594ae4f" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">注意：在此示例中不需要 &lt;code&gt;use locale&lt;/code&gt; ： &lt;code&gt;strftime()&lt;/code&gt; 是POSIX函数，它使用系统提供的标准 &lt;code&gt;libc&lt;/code&gt; 函数，该函数始终遵循当前的 &lt;code&gt;LC_TIME&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="90f06e6aec634d9ac607b849e5f22d774716a195" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">注意：在某些示例中未显示 &lt;code&gt;use locale&lt;/code&gt; ，因为它不是必需的： &lt;code&gt;strcoll()&lt;/code&gt; 和 &lt;code&gt;strxfrm()&lt;/code&gt; 是POSIX函数，它们使用标准的系统提供的 &lt;code&gt;libc&lt;/code&gt; 函数，这些函数始终遵循当前的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">注意：要小心，不要修改 &lt;code&gt;@_&lt;/code&gt; 你打电话export_to_level前在所有-或使用你的包的人会变得非常不明原因的结果！</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注:在5.21.0之前,&quot;缺失 &quot;词汇警告类别在内部被定义为与 &quot;未初始化 &quot;类别相同。现在,它是一个独立的顶级类别。</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注:在 Perl 5.8.0 之前,词汇警告类 &quot;deprecated &quot;是 &quot;syntax &quot;类的一个子类。现在,它是一个独立的顶级类别。</target>
        </trans-unit>
        <trans-unit id="d209ffe48badd4b3ce623fe1073da3a9d734affc" translate="yes" xml:space="preserve">
          <source>Note: Between XSUB and pure Perl, there is an incompatibility about the interpretation of &lt;code&gt;$code_point&lt;/code&gt; as a decimal number. XSUB converts &lt;code&gt;$code_point&lt;/code&gt; to an unsigned integer, but pure Perl does not. Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt;.</source>
          <target state="translated">注意：在XSUB和纯Perl之间，将 &lt;code&gt;$code_point&lt;/code&gt; 解释为十进制数是不兼容的。XSUB将 &lt;code&gt;$code_point&lt;/code&gt; 转换为无符号整数，但纯Perl则不会。不要在 &lt;code&gt;$code_point&lt;/code&gt; 使用浮点或负号。</target>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">注意：请勿在 &lt;code&gt;$code_point&lt;/code&gt; 使用浮点或负号。</target>
        </trans-unit>
        <trans-unit id="668a585af93a214a0b5974e95d57e4c940a86f77" translate="yes" xml:space="preserve">
          <source>Note: Due to XS issues the block passed may be able to access the outer @_ directly. This is not intentional and will break under debugger.</source>
          <target state="translated">注意:由于XS的问题,传递的块可能会直接访问外部的@_。这不是故意的,在调试器下会被破坏。</target>
        </trans-unit>
        <trans-unit id="3b7d3334d006afa6b870b1e3ad78d323bdbd6bec" translate="yes" xml:space="preserve">
          <source>Note: Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:每个类都有自己的globals,从Math::BigInt中分离出来,但可以将Math::BigInt子类化,并使子类的globals别名为Math::BigInt的globals。</target>
        </trans-unit>
        <trans-unit id="ccd381c6324e161a3ae5c4a254351b2b3b48d1d8" translate="yes" xml:space="preserve">
          <source>Note: Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:每个类都有自己的与Math::BigInt分开的globals,但可以将Math::BigInt子类化,并使子类的globals与Math::BigInt的globals别名。</target>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">注:FCC是唯一的,以及四种标准化形式(NF*)。</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">注意：FCD并不总是唯一的，因此复数形式可能彼此等效。 &lt;code&gt;FCD()&lt;/code&gt; 将返回这些等效形式之一。</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">注意：对于某些扩展，Dave Beazley的SWIG系统可能为创建扩展粘合代码提供了更为方便的机制。有关更多信息，请参见&lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">注意:从Mac OS X 10.6 &quot;Snow Leopard &quot;开始,Apple只支持基于Intel的硬件。这意味着你可以安全地跳过这一节,除非你有一台在ppc上运行的旧苹果电脑,或者希望创建一个向后兼容的perl二进制文件。</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">注意：如果字符串不在FCD中，则不能在FCC中。因此， &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; 应该返回 &lt;code&gt;NO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c308958e09dd00a6a549fa78fd5e059fbed4455" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="translated">注意：如果字符串不在FCD中，则它一定不能在FCC中。因此， &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; 应该返回 &lt;code&gt;NO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">注意：如果启用 &lt;code&gt;Sparseseen&lt;/code&gt; ，则您不能依赖所看到的哈希的内容，因为它的内容将是实现细节！</target>
        </trans-unit>
        <trans-unit id="9f446264c9bfae66320393c5089f48ed5b46e500" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt;, then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">注意：如果启用 &lt;code&gt;Sparseseen&lt;/code&gt; ，那么您一定不能依赖所看到的哈希的内容，因为它的内容将是实现细节！</target>
        </trans-unit>
        <trans-unit id="5da841189af3f04f4eb088d72b96bc951d2d81fc" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注意：许多人倾向于过度使用已&lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt;，然后惊讶地发现数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; （零长度字符串）实际上是已定义的值。例如，如果您说</target>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注意：许多人倾向于过度使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ，然后惊讶地发现数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; （零长度字符串）实际上是定义的值。例如，如果您说</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注意：许多人倾向于过度使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ，然后惊讶地发现数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; （零长度字符串）实际上是定义的值。例如，如果您说</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">注意：Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 函数返回四个值，以秒为单位。</target>
        </trans-unit>
        <trans-unit id="4f4979746c04c5a2101a3a8cfcb2e0ca83bb94c8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;times()&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">注意：Perl的内置 &lt;code&gt;times()&lt;/code&gt; 函数返回四个值，以秒为单位。</target>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">注:有些人把这一点标点符号俗称为 &quot;呀呀呀 &quot;或 &quot;三点&quot;,但它的真正名称其实是一个省略号。</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">注意:从CPAN下载的某些模块可能需要NetWare相关的API才能在NetWare上构建。然而,其他模块可能会根据模块的类型,在有或没有细微改动的情况下顺利构建。</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">注意：在通过DEC的DFS访问的文件上使用文件访问测试（ &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; ）时，某些站点报告了问题。具体来说，由于DFS当前不提供对远程卷上文件的扩展文件标头的访问，因此尝试检查ACL失败，并且文件测试将使用 &lt;code&gt;$!&lt;/code&gt; 返回false 。指示该文件不存在。您可以在这些文件上使用 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ，因为它仅检查基于UIC的保护，然后手动检查C编译器的定义的相应位</target>
        </trans-unit>
        <trans-unit id="31012ee5baab20630d192eb344f3fbf19e1f0ce3" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;stat&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">注意：在通过DEC的DFS访问的文件上使用文件访问测试（ &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; ）时，某些站点报告了问题。具体来说，由于DFS当前不提供对远程卷上文件的扩展文件头的访问，因此尝试检查ACL失败，并且文件测试将使用 &lt;code&gt;$!&lt;/code&gt; 返回false ！指示该文件不存在。您可以在这些文件上使用 &lt;code&gt;stat&lt;/code&gt; ，因为这只会检查基于UIC的保护，然后手动检查C编译器定义的适当位</target>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">注意：一些供应商提供 &lt;code&gt;strtod()&lt;/code&gt; 和 &lt;code&gt;strtol()&lt;/code&gt; ,但不提供 &lt;code&gt;strtoul()&lt;/code&gt; 。其他确实提供 &lt;code&gt;strtoul()&lt;/code&gt; 的供应商将&amp;ldquo; -1&amp;rdquo;解析为有效值。</target>
        </trans-unit>
        <trans-unit id="09354bfd47c342dd837df1ad765f45f04db5692c" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt;. Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">注意：一些供应商提供 &lt;code&gt;strtod()&lt;/code&gt; 和 &lt;code&gt;strtol()&lt;/code&gt; ,但不提供 &lt;code&gt;strtoul()&lt;/code&gt; 。其他确实提供 &lt;code&gt;strtoul()&lt;/code&gt; 的供应商将&amp;ldquo; -1&amp;rdquo;解析为有效值。</target>
        </trans-unit>
        <trans-unit id="f41fee180b1c4bc188eb2c171834172ecd8c3be5" translate="yes" xml:space="preserve">
          <source>Note: The functions with names ending in &lt;code&gt;_at_level&lt;/code&gt; were added in Perl 5.28.</source>
          <target state="translated">注意：名称以 &lt;code&gt;_at_level&lt;/code&gt; 结尾的函数已添加到Perl 5.28中。</target>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">注意：迭代器（ &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ）和文件测试（ &lt;code&gt;'-X'&lt;/code&gt; ）正常运行：如果操作数不是受祝福的glob或IO引用，则将其转换为字符串（使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 方法'， &lt;code&gt;'0+'&lt;/code&gt; 或 &lt;code&gt;'bool'&lt;/code&gt; ）解释为glob或文件名。</target>
        </trans-unit>
        <trans-unit id="e872c50dbea2dd944dd1795cb2d6b5ca0cb3d48d" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt;) and file test (&lt;code&gt;'-X'&lt;/code&gt;) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, or &lt;code&gt;'bool'&lt;/code&gt;) to be interpreted as a glob or filename.</source>
          <target state="translated">注意：迭代器（ &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ）和文件测试（ &lt;code&gt;'-X'&lt;/code&gt; ）正常工作：如果操作数不是blob或IO引用，则将其转换为字符串（使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 方法'， &lt;code&gt;'0+'&lt;/code&gt; 或 &lt;code&gt;'bool'&lt;/code&gt; ）解释为glob或文件名。</target>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">注意:关键字'lib'会在请求的库不能被加载时发出警告。要抑制警告,请使用'try'代替。</target>
        </trans-unit>
        <trans-unit id="9be19f662c327b39a0c7dc7dd26cac18cf3a2650" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="translated">注意：可以始终在&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;上找到此规范的最新稳定版本，以及最新的开发版本（其中可能包含不符合要求的内容）始终可以在&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;上找到稳定版本。</target>
        </trans-unit>
        <trans-unit id="6d7df03e2ca7476b6f129d5fb49ca21db5f16ee3" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version) can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="translated">注意：可以始终在&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;上找到此规范的最新稳定版本，以及最新的开发版本（其中可能包含不符合要求的内容）进入稳定版本），可以始终在&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;上找到。</target>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 退货清单源自您当前的perl和您的当前安装。</target>
        </trans-unit>
        <trans-unit id="79a0d5348f570c35ca9be395234112a023471f03" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;require&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">注意： &lt;code&gt;require&lt;/code&gt; 退货清单源自您当前的perl和您的当前安装。</target>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">注意：对于可以容纳一个字节的代码点使用区域设置规则的策略，对于不能容纳这些代码点的代码点使用Unicode规则的策略并非统一适用。v5.12之前的版本有点偶然。在v5.12中，除了括号中的字符类外，它相当一致地应用于正则表达式匹配；在v5.14中，它已扩展到所有正则表达式匹配项；并在v5.16中执行 &lt;code&gt;\L&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 之类的框操作。为了进行排序，到目前为止，在所有发行版中，系统的 &lt;code&gt;strxfrm()&lt;/code&gt; 函数都将被调用，并且所做的就是您得到的。</target>
        </trans-unit>
        <trans-unit id="131995001a6829f0723ee9a84a7ecc32cd05fa54" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;uc()&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get. Starting in v5.26, various bugs are fixed with the way perl uses this function.</source>
          <target state="translated">注意：对于可以容纳一个字节的代码点使用区域设置规则的策略，对于不能容纳这些代码点的代码点使用Unicode规则的策略并非统一适用。 v5.12之前的版本有些杂乱无章；在v5.12中，除了括号中的字符类外，它相当一致地应用于正则表达式匹配；在v5.14中，它已扩展到所有正则表达式匹配项；在v5.16中执行 &lt;code&gt;\L&lt;/code&gt; 和 &lt;code&gt;uc()&lt;/code&gt; 之类的框操作。为了进行排序，到目前为止，在所有发行版中，系统的 &lt;code&gt;strxfrm()&lt;/code&gt; 函数都将被调用，并且所做的就是您得到的。从v5.26开始，perl使用此功能的方式修复了各种错误。</target>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">注意:这个功能是在5.57版本的Exporter中引入的,与perl 5.8.3一起发布。</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; 。除了 &lt;code&gt;U+FFFE&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="287eea86bd8ed6619f824147ed2c55a69584e9bd" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; 。除 &lt;code&gt;U+FFFE&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; 。除 &lt;code&gt;U+FFFF&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="7fc676f4776bf9d00f6e8ce3ee423f9f2208472e" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; 。除了 &lt;code&gt;U+FFFF&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">注意:只有当你运行zlib 1.0.6或更高版本时,此方法才可用。</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">注意：从Math :: BigInt 1.78版本开始需要此方法，但是所需的API版本号没有增加，因此有些较旧的库支持API版本1，但不支持 &lt;code&gt;_as_oct()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">注意:这需要安装Math::BigInt::GMP。</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">注意：当$ FTP_PASSIVE为true时， &lt;code&gt;ncftp&lt;/code&gt; 将不用于获取文件，因为只能为此二进制文件以交互方式设置被动模式</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">注意：在列表上下文中调用时，gistime返回的最后一个值$ isdst始终为 &lt;code&gt;0&lt;/code&gt; 。GMT中没有夏令时。</target>
        </trans-unit>
        <trans-unit id="16d88e8a12adc9d5938fa24b2acb9b6eac47525d" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt;. There is no Daylight Saving Time in GMT.</source>
          <target state="translated">注意：在列表上下文中调用时，gistime返回的最后一个值$ isdst始终为 &lt;code&gt;0&lt;/code&gt; 。GMT中没有夏令时。</target>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意：也可以用于&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat之&lt;/a&gt;类的子类。每个类都有与Math :: BigInt分开的全局变量，但是可以将Math :: BigInt子类化，并将子类别名的全局变量替换为Math :: BigInt的别名。</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:对Math::BigFloat这样的子类也有效。每个类都有自己的 globals,与 Math::BigInt 分隔开来,但也可以将 Math::BigInt 子类化,并使子类的 globals 与 Math::BigInt 的 globals 别名。</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">注意:你必须修改你的man.conf文件来搜索/ade/lib/perl5/man/man3目录下的manpages,否则将找不到perl库的man页。</target>
        </trans-unit>
        <trans-unit id="c7379f095d2d22d8a649d49142d79afd3489318b" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">注意：您可能想使用&lt;a href=&quot;#accuracy%28%29&quot;&gt;&amp;ldquo; accuracy（）&amp;rdquo;&lt;/a&gt;代替。使用&lt;a href=&quot;#accuracy%28%29&quot;&gt;&amp;ldquo; accuracy（）&amp;rdquo;&lt;/a&gt;设置每个结果应具有的位数，使用&lt;a href=&quot;#precision%28%29&quot;&gt;&amp;ldquo; precision（）&amp;rdquo;&lt;/a&gt;设置舍入的位置！</target>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">注意：您可能想改用&lt;a href=&quot;#accuracy()&quot;&gt;precision（）&lt;/a&gt;。随着&lt;a href=&quot;#accuracy()&quot;&gt;精度（）&lt;/a&gt;设置每个结果应具有的位数，用&lt;a href=&quot;#precision()&quot;&gt;精密（）&lt;/a&gt;你的地方设置在哪里轮！</target>
        </trans-unit>
        <trans-unit id="d6d84b096f34f15c07402e918e2379728ec1301e" translate="yes" xml:space="preserve">
          <source>Note: choosing anyhing but 'yes' for this option will need Devel::DistnameInfo being installed for taking effect.</source>
          <target state="translated">注意:选择 &quot;是 &quot;以外的任何选项都需要安装Devel::DistnameInfo才能生效。</target>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling&lt;/code&gt; 也将禁用 &lt;code&gt;bundling_override&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec5d46114c3638c4121c26c4c917e18fe48cdbc0" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt;.</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling&lt;/code&gt; 也将禁用 &lt;code&gt;bundling_override&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling_override&lt;/code&gt; 也会禁用 &lt;code&gt;bundling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b2b48dd6d444bef92ae0ebb4e15997ba10818fb" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt;.</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling_override&lt;/code&gt; 也将禁用 &lt;code&gt;bundling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case&lt;/code&gt; 也将禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57bf189846e7e76bf8482fb5e477ff8f8dfe7b29" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt;.</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case&lt;/code&gt; 也将禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 也会同时禁用 &lt;code&gt;ignore_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1946def9c6cdf88287ce6da335562aa361a54824" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt;.</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 也会同时禁用 &lt;code&gt;ignore_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">注：如果 &lt;code&gt;applypatch&lt;/code&gt; 安装程序和 &lt;code&gt;CPAN::Config&lt;/code&gt; 知道它&lt;b&gt;和&lt;/b&gt;补丁被写入 &lt;code&gt;makepatch&lt;/code&gt; 程序，然后 &lt;code&gt;CPAN.pm&lt;/code&gt; 让 &lt;code&gt;applypatch&lt;/code&gt; 应用补丁。无论 &lt;code&gt;makepatch&lt;/code&gt; 和 &lt;code&gt;applypatch&lt;/code&gt; 可从CPAN在 &lt;code&gt;JV/makepatch-*&lt;/code&gt; 分布。</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">注意:如果计算成本很高,或者哈希有很多元素,你可能想看看Schwartzian变换来缓存计算结果。</target>
        </trans-unit>
        <trans-unit id="29df041b4a10cf81a3e0b4f7f89bd122aed969f0" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">注意：在大多数情况下，尤其是&lt;a href=&quot;#Copy-Constructor&quot;&gt;&amp;ldquo;复制构造函数&amp;rdquo;&lt;/a&gt;，这不太可能是适当的行为。</target>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">注意：在大多数情况下，尤其是&lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;，这不太合适。</target>
        </trans-unit>
        <trans-unit id="1b33df475ae354b7fb1f3b9c4cafb1584ab7a3e6" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt;).</source>
          <target state="translated">注意：可以通过将 &lt;code&gt;fallback&lt;/code&gt; 设置为FALSE来禁用本节中描述的行为（请参阅&lt;a href=&quot;#fallback&quot;&gt;&amp;ldquo; fallback&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">注意：可以通过将 &lt;code&gt;fallback&lt;/code&gt; 设置为FALSE 来禁用本节中描述的行为（请参见&lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="62b2ca1948759ac7f684eceb704736b180023c07" translate="yes" xml:space="preserve">
          <source>Note: the exact nature of the fancy specifications like &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; is subject to change. Advance notice will be given here. The simple specifications like &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; will not change in format.</source>
          <target state="translated">注意：精美规格的确切性质，例如 &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; 可能会发生变化。提前通知将在这里给出。诸如 &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; 类的简单规范将不会更改格式。</target>
        </trans-unit>
        <trans-unit id="11ca88f5d5dc89450fb8556231f6b8efe29797ea" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;.</source>
          <target state="translated">注意：上一段描述了Perl基于标量为对象自动生成副本构造函数时发生的情况。对于其他情况，请参见&lt;a href=&quot;#Copy-Constructor&quot;&gt;&amp;ldquo;复制构造函数&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">注意：上一段描述了Perl基于标量自动为对象生成副本构造函数时发生的情况。对于其他情况，请参见&lt;a href=&quot;#Copy-Constructor&quot;&gt;复制构造函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">注意:这个配置变量已经过时了,并将在未来的CPAN.pm版本中被移除。它将被$LANG和$LC_*环境变量系列的约定所取代。</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">注意:这个功能还处于alpha状态,在CPAN.pm的未来版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="fb52a79f4bb85f30f68ef37f28e8e379caceb4dc" translate="yes" xml:space="preserve">
          <source>Note: this function has not been specified by POSIX since 1990 and is included only for backwards compatibility. New code should use &lt;a href=&quot;perlfunc#getlogin&quot;&gt;&lt;code&gt;getlogin()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注意：此功能自1990年以来未由POSIX指定，仅出于向后兼容的目的而包含此功能。新代码应改用&lt;a href=&quot;perlfunc#getlogin&quot;&gt; &lt;code&gt;getlogin()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">注意:这是套接字函数家族的一个新成员,所以所有系统可能还不支持。如果系统不支持,试图使用此方法将中止程序。</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">注意:当use_sqlite开启且SQLLite正在运行时,不使用该机制。</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">注意:这种设置配置变量的方法往往比manpage提供了更多关于变量功能的解释。</target>
        </trans-unit>
        <trans-unit id="56d243ce60967f77fdfcf106f1d4d7d0a8b3112b" translate="yes" xml:space="preserve">
          <source>Note: using a static or global variable to store the SV isn't thread-safe. You can either use the &lt;code&gt;MY_CXT&lt;/code&gt; mechanism documented in &lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;&quot;Safely Storing Static Data in XS&quot; in perlxs&lt;/a&gt; which is fast, or store the values in perl global variables, using get_sv(), which is much slower.</source>
          <target state="translated">注意：使用静态或全局变量存储SV并不是线程安全的。您可以使用快速的 &lt;code&gt;MY_CXT&lt;/code&gt; 中&lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;&amp;ldquo;安全地在XS中存储静态数据&amp;rdquo;中&lt;/a&gt;记录的MY_CXT机制，也可以使用慢得多的get_sv（）将值存储在perl全局变量中。</target>
        </trans-unit>
        <trans-unit id="532592c5b33f1b1b988a3bcb06f60ee822f44348" translate="yes" xml:space="preserve">
          <source>Note: when this field is true, post-configuration prerequisites are not guaranteed to bear any relation whatsoever to those stated in the metadata, and relying on them doing so is an error. See also &lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;&quot;Prerequisites for dynamically configured distributions&quot;&lt;/a&gt; in the implementors' notes.</source>
          <target state="translated">注意：当此字段为true时，则不保证配置后的前提条件与元数据中所述的条件具有任何关系，并且依靠它们这样做是错误的。另请参阅实施者说明中的&lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;&amp;ldquo;动态配置发行版的先决条件&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">注意:你可以在gdb部分定义最多20个转换快捷方式。</target>
        </trans-unit>
        <trans-unit id="1f83b80ea2831e263f522f29c3cbd52e6213eb57" translate="yes" xml:space="preserve">
          <source>Noted explicit support for 'perl' in prerequisites</source>
          <target state="translated">注意到在先决条件中明确支持 &quot;perl&quot;。</target>
        </trans-unit>
        <trans-unit id="8922b61958be2a8d272cbf3db875ad134d3a3576" translate="yes" xml:space="preserve">
          <source>Noted that the &lt;a href=&quot;#distribution_type&quot;&gt;&quot;distribution_type&quot;&lt;/a&gt; field is basically meaningless, and shouldn't really be used.</source>
          <target state="translated">请注意，&lt;a href=&quot;#distribution_type&quot;&gt;&amp;ldquo; distribution_type&amp;rdquo;&lt;/a&gt;字段基本上是没有意义的，因此不应真正使用。</target>
        </trans-unit>
        <trans-unit id="03baeca66519780c80b0846ea1bac63e81b58e40" translate="yes" xml:space="preserve">
          <source>Notepad++</source>
          <target state="translated">Notepad++</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Compress::Zlib第1版用户须知。</target>
        </trans-unit>
        <trans-unit id="60a645effd583025acef3ba80266a7c7168ec1f6" translate="yes" xml:space="preserve">
          <source>Notes on 64-bit Windows</source>
          <target state="translated">64位Windows的注意事项</target>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">实施Pod处理器的注意事项</target>
        </trans-unit>
        <trans-unit id="8f983f019ad00a2df5935875ac129acc0e4daab6" translate="yes" xml:space="preserve">
          <source>Notes, typically rendered to STDOUT.</source>
          <target state="translated">注释,一般呈现为STDOUT。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">虚空背景下什么都没有(显然)。</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">没有任何记载。</target>
        </trans-unit>
        <trans-unit id="59fb6d9ec5289836c61476dab6f50fac2154944a" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. The following tags can be used to have large sets of symbols exported: &lt;code&gt;&quot;:Func&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt;, &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt;.</source>
          <target state="translated">默认情况下，不导出任何内容。以下标记可用于导出大量符号： &lt;code&gt;&quot;:Func&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt; &amp;ldquo;：FILE_SHARE_&amp;rdquo; &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt; &amp;ldquo;：FILE_TYPE_&amp;rdquo; &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt; &amp;ldquo;：FS_&amp;rdquo; &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt; &amp;ldquo;：FSCTL_&amp;rdquo; &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt; &amp;ldquo;：HANDLE_FLAG_&amp;rdquo; &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt; &amp;ldquo;：IOCTL_STORAGE_&amp;rdquo; &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt; &amp;ldquo;：IOCTL_DISK_&amp;rdquo; &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt; &amp;ldquo;：MEDIA_TYPE&amp;rdquo; &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; &amp;ldquo;：MOVEFILE_&amp;rdquo; &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt; ， &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt; &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt; &amp;rdquo;，&amp;ldquo;：SEM_&amp;rdquo;和 &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e7b42ab74a17af97a37c506518ea42d6cc1e569" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. You must specify which methods to import, or use the ':ALL' tag.</source>
          <target state="translated">默认情况下,没有任何方法被导出。您必须指定要导入的方法,或者使用':ALL'标签。</target>
        </trans-unit>
        <trans-unit id="b2dc97487d39ef5241bb9dbe74fe894c19016958" translate="yes" xml:space="preserve">
          <source>Nothing is exported. Use fully qualified variable names.</source>
          <target state="translated">没有任何东西被导出。使用完全限定的变量名。</target>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">这里没有什么太不寻常的地方。如果你有可用的交叉编译器,你可以很容易地做到这一点;当以 Solaris x86 为目标时,通常的 Configure 调用看起来像这样。</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">没有任何作用--死。</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">还请注意,警告是在第一次使用对象的那一行报告的。</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">还要注意下面的 &lt;code&gt;grok_bin&lt;/code&gt; ， &lt;code&gt;grok_hex&lt;/code&gt; 和 &lt;code&gt;grok_oct&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="49ebd14076be592270a5d4f9b224fa4d4b89d099" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt;, and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">还要注意下面的 &lt;code&gt;grok_bin&lt;/code&gt; ， &lt;code&gt;grok_hex&lt;/code&gt; 和 &lt;code&gt;grok_oct&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">注意这里的LEN是10。(在你的平台上可能会有所不同。)将字符串的长度延长到小于10的长度,然后进行替换。</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">请注意,&quot;private &quot;这个值在任何时候都不会被打印出来。这是因为 $var 只有在 lexical()函数的块中才有这个值,而且它被隐藏在被调用的子程序中。</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">请注意 &lt;code&gt;globmap&lt;/code&gt; 的两个参数如何都是由&amp;lt;&amp;gt;分隔的字符串。这样做是为了使它们看起来更像文件文件-只是语法糖，但是当您希望字符串在视觉上与众不同时，它可以派上用场。封闭的&amp;lt;&amp;gt;是可选的，因此您不必使用它们-实际上，globmap要做的第一件事就是删除这些定界符（如果存在）。</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">注意， &lt;code&gt;new&lt;/code&gt; 构造函数的返回值如何在 &lt;code&gt;while&lt;/code&gt; 循环中用作文件句柄？那就是所谓的</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">请注意，第二个替换在遇到&amp;ldquo; y&amp;rdquo;后如何立即停止匹配。该 &lt;code&gt;*?&lt;/code&gt; 量词有效地告诉正则表达式引擎尽快找到一个匹配项，并将控制权传递给下一行中的任何内容，就像玩马铃薯一样。</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">请注意，此（无原型）函数如何不在乎它是传递实标量还是数组。Perl将所有参数视为 &lt;code&gt;@_&lt;/code&gt; 中的一个大而长且平坦的参数列表。这是Perl的简单参数传递风格的一个亮点。该 &lt;code&gt;upcase()&lt;/code&gt; 函数将很好地工作良好，没有改变 &lt;code&gt;upcase()&lt;/code&gt; 的定义，即使我们给它这样的事情：</target>
        </trans-unit>
        <trans-unit id="8e53ec417cfc4ffd2c3f588c8323f91d879ae5ac" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt;. This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">请注意，此（无原型）函数如何不在乎它是通过实标量还是数组传递的。Perl将所有参数视为 &lt;code&gt;@_&lt;/code&gt; 中的一个大而长的平面参数列表。这是Perl的简单参数传递风格的一个亮点。该 &lt;code&gt;upcase()&lt;/code&gt; 函数将很好地工作良好，没有改变 &lt;code&gt;upcase()&lt;/code&gt; 的定义，即使我们给它这样的事情：</target>
        </trans-unit>
        <trans-unit id="0b9d5a5851dd2e8a235f599f76ec00c3eeb19104" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;&quot;*&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，&amp;ldquo; hello&amp;rdquo;仅打印一次，因为当Perl看到最外面的 &lt;code&gt;(?:)*&lt;/code&gt; 的第六次迭代与零长度的字符串匹配时，它将停止 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">请注意，&amp;ldquo; hello&amp;rdquo;仅打印一次，因为当Perl看到最外面的 &lt;code&gt;(?:)*&lt;/code&gt; 的第六次迭代与零长度的字符串匹配时，它将停止 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">注意，在上面的代码中， &lt;code&gt;Dump()&lt;/code&gt; 仅打印元素10到13。以下代码将打印所有元素。</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">请注意，使用文件全局模​​式 &lt;code&gt;*.tar.gz&lt;/code&gt; 来匹配 &lt;code&gt;.tar.gz&lt;/code&gt; 文件，然后在替代文件中使用了非常相似的正则表达式来创建新文件名。</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">注意,由于默认的行为是在输入时如果没有默认层就不做任何转换,所以很容易误写代码,通过反复编码数据来不断扩充文件。</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">请注意，两次使用 &lt;code&gt;put&lt;/code&gt; 方法时，都使用变量 &lt;code&gt;$i&lt;/code&gt; 而不是文字值本身来指定记录索引。这是因为 &lt;code&gt;put&lt;/code&gt; 将通过该参数返回插入行的记录号。</target>
        </trans-unit>
        <trans-unit id="f8652fa23a6a85d8694e8c330d3634e47750ae09" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt;, rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">注意，两次使用 &lt;code&gt;put&lt;/code&gt; 方法时，都使用变量 &lt;code&gt;$i&lt;/code&gt; 而不是文字值本身来指定记录索引。这是因为 &lt;code&gt;put&lt;/code&gt; 将通过该参数返回插入行的记录号。</target>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">请注意,在这些新的测试用例中,传递给 round 的参数是一个标量变量。你可能想知道是否可以对常量或文字进行舍入。为了看看会发生什么,暂时在Mytest.t中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">注意，必须定义变量 &lt;code&gt;ax&lt;/code&gt; 。这是因为 &lt;code&gt;ST&lt;/code&gt; 宏期望它存在。如果我们在XSUB中，则不必定义 &lt;code&gt;ax&lt;/code&gt; ，因为已经为我们定义了斧头。</target>
        </trans-unit>
        <trans-unit id="785ded97619f1dd92d03821ef64bfb7475388f4f" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt;. This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">注意，必须定义变量 &lt;code&gt;ax&lt;/code&gt; 。这是因为 &lt;code&gt;ST&lt;/code&gt; 宏期望它存在。如果我们在XSUB中，则不必定义 &lt;code&gt;ax&lt;/code&gt; ，因为已经为我们定义了斧头。</target>
        </trans-unit>
        <trans-unit id="5a57f1413b4aba3b4429663d2d0603ce91191839" translate="yes" xml:space="preserve">
          <source>Notice that most of the metacharacters lose their special meaning when they occur in a bracketed character class, except &lt;code&gt;&quot;^&quot;&lt;/code&gt; has a different meaning when it is at the beginning of such a class. And &lt;code&gt;&quot;-&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt; are metacharacters only at restricted positions within bracketed character classes; while &lt;code&gt;&quot;}&quot;&lt;/code&gt; is a metacharacter only when closing a special construct started by &lt;code&gt;&quot;{&quot;&lt;/code&gt;.</source>
          <target state="translated">请注意，大多数元字符出现在方括号字符类中时会失去其特殊含义，只是 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 在此类字符集的开头具有不同的含义。而 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;]&quot;&lt;/code&gt; 是仅位于方括号字符类中受限位置的元字符；而 &lt;code&gt;&quot;}&quot;&lt;/code&gt; 仅在关闭以 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 开头的特殊构造时才是元字符。</target>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">请注意,只有仅有遗留代码点的字元(字符串或正则表达式)才会受到影响:如果你把数据混合在一起,像这样</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">请注意，核心 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 可能会舍入而不是截断。这意味着核心 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 可能比 &lt;code&gt;gettimeofday()&lt;/code&gt; 和 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 晚一秒报告时间。</target>
        </trans-unit>
        <trans-unit id="786dfe37f34edb4a05a168a69eef1c7edef1b6b6" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;time()&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;time()&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt;.</source>
          <target state="translated">请注意，核心 &lt;code&gt;time()&lt;/code&gt; 可能会四舍五入而不是被截断。这意味着核心 &lt;code&gt;time()&lt;/code&gt; 可能比 &lt;code&gt;gettimeofday()&lt;/code&gt; 和 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 晚一秒报告时间。</target>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">请注意，最终匹配将匹配 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;p&lt;/code&gt; ，而没有 &lt;code&gt;\G&lt;/code&gt; 锚的匹配将完成。另请注意，最终比赛并未更新 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 仅在 &lt;code&gt;/g&lt;/code&gt; 匹配项上更新。如果最终匹配确实匹配 &lt;code&gt;p&lt;/code&gt; ，那么最好是您运行的是Perl的旧版本（低于5.6.0版）。</target>
        </trans-unit>
        <trans-unit id="6288f2ae31ab09194ff1161b00b4b9878a3f7850" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;q&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt;, which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;pos&lt;/code&gt;. &lt;code&gt;pos&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt;, it's a good bet that you're running an ancient (pre-5.6.0) version of Perl.</source>
          <target state="translated">请注意，最终匹配将匹配 &lt;code&gt;q&lt;/code&gt; 而不是 &lt;code&gt;p&lt;/code&gt; ，而没有 &lt;code&gt;\G&lt;/code&gt; 锚的匹配将完成。另请注意，最终比赛并未更新 &lt;code&gt;pos&lt;/code&gt; 。 &lt;code&gt;pos&lt;/code&gt; 仅在 &lt;code&gt;/g&lt;/code&gt; 匹配项上更新。如果最终匹配确实匹配 &lt;code&gt;p&lt;/code&gt; ，那么最好运行的是Perl的较早版本（低于5.6.0）。</target>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">请注意，外括号类型已更改，因此我们的访问语法也已更改。那是因为与C不同，在Perl中，您不能自由地交换数组及其引用。 $ ref_to_AoA是对数组的引用，而@AoA是适当的数组。同样， &lt;code&gt;$AoA[2]&lt;/code&gt; 不是数组，而是数组ref。那么你怎么能写这些：</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">请注意,程序员必须提供必要的C代码,以使真正的rpcb_gettime()函数被调用,并使返回值正确地放在参数栈中。</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">请注意，如果您查看的是平坦的世界地图，那么得出的方向可能会有些出乎意料：在这样的地图投影中，大圆圈通常看起来并不是最短的路线-例如，从欧洲或北美到亚洲的最短路线确实经常越过极地地区。 （常见的墨卡托投影没有&lt;b&gt;将&lt;/b&gt;大圆显示为直线：墨卡托投影中的直线是恒定方位线。）</target>
        </trans-unit>
        <trans-unit id="f84d61c644ea07e321b7e96f57efe6473acd064c" translate="yes" xml:space="preserve">
          <source>Notice that the standard utility methods of &lt;code&gt;Locale::Maketext&lt;/code&gt; are irremediably limited because they could not aim to do everything that could be expected from them in different languages, cultures and applications. So extending &lt;code&gt;numf&lt;/code&gt;, &lt;code&gt;quant&lt;/code&gt;, and &lt;code&gt;sprintf&lt;/code&gt; is natural as soon as your needs exceed what the standard ones do.</source>
          <target state="translated">请注意， &lt;code&gt;Locale::Maketext&lt;/code&gt; 的标准实用程序方法受到了不可挽回的限制，因为它们无法以不同的语言，文化和应用程序来完成期望的所有操作。因此，只要您的需求超出标准需求，就可以自然地扩展 &lt;code&gt;numf&lt;/code&gt; ， &lt;code&gt;quant&lt;/code&gt; 和 &lt;code&gt;sprintf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">请注意，这也会影响 &lt;code&gt;display_format&lt;/code&gt; 方法的返回值：在列表上下文中，将返回整个参数哈希值，而不仅仅是样式参数值。如果您一直在列表上下文中调用 &lt;code&gt;display_format&lt;/code&gt; 方法，则可能与早期版本不兼容。</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">请注意，此示例与上一示例的不同之处仅在于其引用计数。将此与下一个示例进行比较，在下一个示例中，我们转储 &lt;code&gt;$b&lt;/code&gt; 而不是 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5817d7016f97dd4bc8025a72366ab7b19c39f5b7" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="translated">请注意，此示例仅在参考计数方面与之前的示例有所不同。将此与下一个示例进行比较，在下一个示例中，我们转储 &lt;code&gt;$b&lt;/code&gt; 而不是 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;env&lt;/code&gt; 指针。通常将 &lt;code&gt;env&lt;/code&gt; 作为最终参数传递给 &lt;code&gt;perl_parse&lt;/code&gt; ，此处的env被 &lt;code&gt;NULL&lt;/code&gt; 取代，这意味着将使用当前环境。</target>
        </trans-unit>
        <trans-unit id="930214e71214bfe57e424495f1f5252084b336e6" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt;, which means that the current environment will be used.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;env&lt;/code&gt; 指针。通常将 &lt;code&gt;env&lt;/code&gt; 作为最终参数传递给 &lt;code&gt;perl_parse&lt;/code&gt; ，此处的env被 &lt;code&gt;NULL&lt;/code&gt; 取代，这意味着将使用当前环境。</target>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_c&lt;/code&gt; 不等于 &lt;code&gt;$rho_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a5cef6aa9527100171d0d0994226a5b838b3bc" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt;.</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_c&lt;/code&gt; 不等于 &lt;code&gt;$rho_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_s&lt;/code&gt; 不等于 &lt;code&gt;$rho_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01c82dfb0bcf881d438ecf1364082366f27c8820" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt;.</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_s&lt;/code&gt; 不等于 &lt;code&gt;$rho_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">请注意，您可以选择使用 &lt;code&gt;sv_setpvn&lt;/code&gt; ， &lt;code&gt;newSVpvn&lt;/code&gt; 或 &lt;code&gt;newSVpv&lt;/code&gt; 来指定要分配的字符串的长度，也可以允许Perl通过使用 &lt;code&gt;sv_setpv&lt;/code&gt; 或将0指定为 &lt;code&gt;newSVpv&lt;/code&gt; 的第二个参数来计算长度。但是请注意，Perl将通过使用 &lt;code&gt;strlen&lt;/code&gt; 来确定字符串的长度，该长度取决于以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾且不包含NUL的字符串。</target>
        </trans-unit>
        <trans-unit id="8388abb49037aa7a9750fb22bcb53bb337bbb687" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt;, &lt;code&gt;newSVpvn&lt;/code&gt;, or &lt;code&gt;newSVpv&lt;/code&gt;, or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt;. Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt;, which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">请注意，您可以选择使用 &lt;code&gt;sv_setpvn&lt;/code&gt; ， &lt;code&gt;newSVpvn&lt;/code&gt; 或 &lt;code&gt;newSVpv&lt;/code&gt; 来指定要分配的字符串的长度，或者可以允许Perl通过使用 &lt;code&gt;sv_setpv&lt;/code&gt; 或将0指定为 &lt;code&gt;newSVpv&lt;/code&gt; 的第二个参数来计算长度。但是请注意，Perl将使用 &lt;code&gt;strlen&lt;/code&gt; 来确定字符串的长度，该长度取决于以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾且不包含NUL的字符串。</target>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">注意 &lt;code&gt;OBJECT&lt;/code&gt; 属性。MakeMaker在以下位置生成以下变量</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">注意 &lt;code&gt;_&lt;/code&gt; 在上述 &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; ：该 &lt;code&gt;_&lt;/code&gt; 是一个神奇文件句柄，用于缓存来自前面的信息 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; ，或filetest。</target>
        </trans-unit>
        <trans-unit id="3649b7d5b5ec60ffba14ae21c7b1c2a9a411dd9a" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;int(-M _)&lt;/code&gt;: the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;lstat()&lt;/code&gt;, or filetest.</source>
          <target state="translated">注意 &lt;code&gt;_&lt;/code&gt; 在上述 &lt;code&gt;int(-M _)&lt;/code&gt; ：该 &lt;code&gt;_&lt;/code&gt; 是一个神奇文件句柄，用于缓存来自前面的信息 &lt;code&gt;stat()&lt;/code&gt; ， &lt;code&gt;lstat()&lt;/code&gt; 或filetest。</target>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Move&lt;/code&gt; 参数的顺序与 &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;memmove&lt;/code&gt; 中使用的顺序不同。</target>
        </trans-unit>
        <trans-unit id="4cfb16d57b3fc1899ca35729db416deb1a5fcf6d" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Move&lt;/code&gt; 参数的顺序与 &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;memmove&lt;/code&gt; 中使用的顺序不同。</target>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">注意最后两个:你有一个未定义的值,但有一个定义的键!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">注意这两行用&amp;ldquo; XXXXX&amp;rdquo;注释。如果检查类型映射文件（或部分）的第一部分，您会看到双精度类型为T_DOUBLE。在类型映射的INPUT部分中，通过在某个对象上调用例程SvNV，然后将其强制转换为double，然后将其分配给变量arg，来将变量T_DOUBLE分配给变量arg。类似地，在OUTPUT部分中，一旦arg具有最终值，则将其传递到sv_setnv函数，再传递回调用子例程。这两种功能在&lt;a href=&quot;perlguts&quot;&gt;perlguts中&lt;/a&gt;进行了解释；我们稍后将在参数堆栈的部分中进一步讨论&amp;ldquo; ST（0）&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">请注意使用GV_ADD作为第二个参数。现在可以使用适合数据类型的例程来设置新变量。</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">请注意这些示例中的空白。此构造始终在其中启用 &lt;code&gt;/x&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="319e2b5eaf07860409d97b11c5611e8f5cc65281" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/xx&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">请注意这些示例中的空白。此构造始终在其中启用 &lt;code&gt;/xx&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="2dd6270a12f8b7eb8c9c200a3723ca7a45c46729" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">注意，我们使用 &lt;code&gt;Perl_pp_add&lt;/code&gt; 而不是 &lt;code&gt;pp_add&lt;/code&gt; -请参阅perlguts中的&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&amp;ldquo;内部函数&amp;rdquo;&lt;/a&gt;。有了断点，我们可以运行我们的程序：</target>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">注意，我们使用 &lt;code&gt;Perl_pp_add&lt;/code&gt; 而不是 &lt;code&gt;pp_add&lt;/code&gt; -请参阅perlguts中的&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;内部函数&lt;/a&gt;。有了断点，我们可以运行程序：</target>
        </trans-unit>
        <trans-unit id="49e7942c0e9764eb733db50ae6c6f21e34cbe873" translate="yes" xml:space="preserve">
          <source>Notify an according IPv6 MTU.</source>
          <target state="translated">通知一个根据IPv6 MTU。</target>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">Notify用于请求交付状态通知(DSN),但您的SMTP/ESMTP服务可能不会尊重这一请求,这取决于其版本和您网站的SMTP配置。</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">通知服务器,当前的消息应该被发送到所有给定的地址。每个地址都会作为一个单独的命令发送到服务器。如果任何一个地址的发送失败,那么这个过程就会被中止,并且会有一个叫做 &quot;S &quot;的命令。</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare 从 File::Spec::Win32 继承了其 File::Spec 行为。</target>
        </trans-unit>
        <trans-unit id="f596d3f268eaea786d51ab55e3200ab8fc6af9a4" translate="yes" xml:space="preserve">
          <source>November 13, 2003</source>
          <target state="translated">2003年11月13日</target>
        </trans-unit>
        <trans-unit id="c0ef706a9203ebb1532a39a12c049758f080c8c3" translate="yes" xml:space="preserve">
          <source>November 16, 2003</source>
          <target state="translated">2003年11月16日</target>
        </trans-unit>
        <trans-unit id="7c0d9da26bf041d32a0675226f59b963b86e2fb7" translate="yes" xml:space="preserve">
          <source>November 2006</source>
          <target state="translated">2006年11月</target>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">2007 年 11 月;作者:Christophe Grosjean:使 cmpthese 和 timestr 计算时间与样式参数一致,默认为 'all' 而不是 'noc' 了。</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">现在 &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; 总是20加上您传递的$ n，而 &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; 总是555加上传递的$ n。闭包中的$ addpiece会缠住。</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">现在， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; 可以在常量正则表达式（即没有任何运行时变量插值的表达式）中启用新的转义。如&lt;a href=&quot;overload&quot;&gt;重载中所述&lt;/a&gt;，此转换将仅对正则表达式的文字部分起作用。对于 &lt;code&gt;\Y|$re\Y|&lt;/code&gt; 此正则表达式的变量部分需要进行显式转换（但仅当应在$ re中启用 &lt;code&gt;\Y|&lt;/code&gt; 的特殊含义时）：</target>
        </trans-unit>
        <trans-unit id="fade66a80437ba60181e3ddce42855f68a77521c" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;use customre&lt;/code&gt; enables the new escape in constant regular expressions,</source>
          <target state="translated">现在， &lt;code&gt;use customre&lt;/code&gt; 在常量正则表达式中启用新的转义，</target>
        </trans-unit>
        <trans-unit id="b01a23641a218b7388c86b594decd3175ef90f36" translate="yes" xml:space="preserve">
          <source>Now I can run my tests like this</source>
          <target state="translated">现在我可以像这样运行我的测试</target>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">现在我将创建一个C程序。</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">现在，所有这些不同的功能似乎都独立存在。您可以调用red（），RED（），blue（），BLUE（），green（）等。此技术可节省编译时间和内存使用，并且不易出错，因为语法检查发生在编译时间。为了创建适当的闭包，匿名子例程中的所有变量都必须是词法，这一点至关重要。这就是 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on循环迭代变量的原因。</target>
        </trans-unit>
        <trans-unit id="fabedd5297cac1df38e4fa79abf11492e74b2a01" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;my&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">现在，所有这些不同的功能似乎都独立存在。您可以调用red（），RED（），blue（），BLUE（），green（）等。由于语法检查发生在编译时间。为了创建适当的闭包，匿名子例程中的任何变量都必须是词法，这一点至关重要。这就是 &lt;code&gt;my&lt;/code&gt; on循环迭代变量的原因。</target>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">现在你要做的就是让。</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">现在举一个使用G_EVAL的例子。下面是一个Perl子程序,它计算2个参数的差值。如果计算结果是负数,子程序就会调用</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">现在由尼尔&amp;middot;鲍尔斯（Neil Bowers）维护&amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">现在在几条线上建立一个on-the-fly对象(注意反斜杠)。</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">现在改成调用一个Perl子程序,而不是</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">现在检查 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; 是否对某些 &lt;code&gt;$n&lt;/code&gt; 是正确的。</target>
        </trans-unit>
        <trans-unit id="10a01ad64127827e39a88ed3009004d810d71655" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;vec($read,$n,1)&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt;.</source>
          <target state="translated">现在检查 &lt;code&gt;vec($read,$n,1)&lt;/code&gt; 是否对某些 &lt;code&gt;$n&lt;/code&gt; 是正确的。</target>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">现在到了聪明的地方。分类帐中仅是收入而非支出的行可能会在第46列结束。因此，我们不想告诉 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 模式&lt;b&gt;需要&lt;/b&gt;再找到12个字符；我们只会说&amp;ldquo;如果还有什么，那就把它拿走&amp;rdquo;。您可能会从正则表达式中猜到，这就是 &lt;code&gt;*&lt;/code&gt; 的含义：&amp;ldquo;使用剩余的所有内容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="2aed8f2583a2025408738c1655ec69d76cbf4265" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;unpack&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">现在到了聪明的一面。分类帐中仅是收入而非支出的行可能会在第46列结束。因此，我们不想告诉我们的 &lt;code&gt;unpack&lt;/code&gt; 模式，我们&lt;b&gt;需要&lt;/b&gt;再找到12个字符。我们只是说&amp;ldquo;如果还有什么，那就把它拿走&amp;rdquo;。您可能会从正则表达式中猜到，这就是 &lt;code&gt;*&lt;/code&gt; 的含义：&amp;ldquo;使用剩余的所有内容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3043847bd2200864abd83a13618a02dee8ec6266" translate="yes" xml:space="preserve">
          <source>Now commit your change locally:</source>
          <target state="translated">现在在本地提交你的变化。</target>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">现在编译这个程序(我把它称为</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">现在编译。</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">现在考虑带指数的浮点数。这里的关键观察是</target>
        </trans-unit>
        <trans-unit id="6e69790285fa3d81bdaeedc9a045cae201d21c12" translate="yes" xml:space="preserve">
          <source>Now consider what the code looks like without &lt;code&gt;InputLength&lt;/code&gt;</source>
          <target state="translated">现在考虑没有 &lt;code&gt;InputLength&lt;/code&gt; 的代码是什么样的</target>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">现在编辑 Mytest2.t 脚本,将测试次数改为 &quot;4&quot;,并在脚本末尾添加以下几行。</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">现在来看一个处理Perl子程序返回的项目的例子。</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">现在进行更复杂的操作： &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">现在，如果$ baz这样重载，则 &lt;code&gt;$baz&lt;/code&gt; 是对中间数组的引用的引用，该中间数组保留对实际数组和访问哈希的引用。访问哈希的tie（）ing对象是对实际数组的引用，因此</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">现在，如果我们看到一个 &lt;code&gt;U&lt;/code&gt; 出现在字符串的开头，则打开输出SV &lt;code&gt;cat&lt;/code&gt; 的 &lt;code&gt;UTF8&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="5914acd073f333e4c23a4d84f2aa14b4552e8013" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt;:</source>
          <target state="translated">现在，如果我们看到一个 &lt;code&gt;U&lt;/code&gt; 出现在字符串的开头，则打开输出SV &lt;code&gt;cat&lt;/code&gt; 的 &lt;code&gt;UTF8&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">现在inner()只能从 outer()内部调用,因为匿名子程序的临时赋值。但是当它这样做的时候,在调用 outer 的时候,它可以从 outer()的作用域中正常访问词法变量 $x。</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">现在是建立静态链接的可执行文件的时候了。</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">现在发出一个所有 Perl Mongers 都喜欢的命令。</target>
        </trans-unit>
        <trans-unit id="5afbbbcc6562eb3dd44ab3aeee5e6e877aac172d" translate="yes" xml:space="preserve">
          <source>Now it always returns &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="translated">现在，它始终返回 &lt;code&gt;NOT_IN_PAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">现在看起来真的像二维数组了!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">现在是时候把你的数据结构打印出来了。你要怎么做呢?如果你只想要其中一个元素,这很简单。</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">现在只要输入任何合法的Perl代码,就会立即被评估。你还可以检查符号表,获取堆栈回溯,检查变量值,设置断点,以及其他典型的符号调试器中的操作。</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">现在让我们为我们的扩展添加一个子程序,它将接受一个单一的数字参数作为输入,如果数字是偶数则返回1,如果数字是奇数则返回0。</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">现在让我们继续表演吧!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">现在让我们看一下 &lt;code&gt;pp_pack&lt;/code&gt; ：将模式放入 &lt;code&gt;pat&lt;/code&gt; ，然后遍历该模式，将每个格式字符依次转换为 &lt;code&gt;datum_type&lt;/code&gt; 。然后，对于每个可能的格式字符，我们将模式中的其他参数（字段宽度，星号等）吞下，并将下一个输入的块转换为指定的格式，并将其添加到输出SV &lt;code&gt;cat&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="72fe90f904deeeb9bda4270aff1109f958440f65" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt;: we take a pattern into &lt;code&gt;pat&lt;/code&gt;, and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt;. Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">现在让我们看一下 &lt;code&gt;pp_pack&lt;/code&gt; ：将一个模式放入 &lt;code&gt;pat&lt;/code&gt; ，然后遍历该模式，将每个格式字符依次转换为 &lt;code&gt;datum_type&lt;/code&gt; 。然后，对于每个可能的格式字符，我们将模式中的其他参数（字段宽度，星号等）吞下，并将下一个输入的块转换为指定的格式，并将其添加到输出SV &lt;code&gt;cat&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">现在让我们做一个稍微复杂的例子。这次我们要调用Perl子例程 &lt;code&gt;LeftString&lt;/code&gt; ，它将带有 2个参数-一个字符串（$ s）和一个整数（$ n）。该子例程将只打印字符串的前$ n个字符。</target>
        </trans-unit>
        <trans-unit id="a1cd28db828b3965b5fb8cb34a20f3c4db616851" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt;, which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">现在让我们做一个稍微复杂的例子。这次我们要调用Perl子例程 &lt;code&gt;LeftString&lt;/code&gt; ，它将带有2个参数-一个字符串（$ s）和一个整数（$ n）。该子例程将只打印字符串的前$ n个字符。</target>
        </trans-unit>
        <trans-unit id="bf057ced369b422ce2c543343cfe6f097b71cc60" translate="yes" xml:space="preserve">
          <source>Now let's see what happens when you try to decode from ISO-2022-JP and the buffer ends in the middle of a character.</source>
          <target state="translated">现在让我们来看看当你试图从ISO-2022-JP解码时,缓冲区在一个字符的中间结束会发生什么。</target>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">现在让我们尝试一个更困难的模式。我们将添加一个量词，因此现在有了模式 &lt;code&gt;/foo+/&lt;/code&gt; 。我们将看到， &lt;code&gt;regbranch()&lt;/code&gt; 调用 &lt;code&gt;regpiece()&lt;/code&gt; 的两倍。</target>
        </trans-unit>
        <trans-unit id="364c0b15409d7672a94bf5ecd988b5c8a1f0315d" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt;. We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">现在，让我们尝试一个更困难的模式。我们将添加一个量词，所以现在有了模式 &lt;code&gt;/foo+/&lt;/code&gt; 。我们将看到 &lt;code&gt;regbranch()&lt;/code&gt; 调用了 &lt;code&gt;regpiece()&lt;/code&gt; 两次。</target>
        </trans-unit>
        <trans-unit id="d4cb79a776cb969edc30e88cc6131bd19fb97fb3" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl 5 Porters.</source>
          <target state="translated">现在由Perl 5 Porters维护。</target>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">现在由Perl5 Porters维护。</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">现在$ c的数值为5。 &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; $ c的数值变为13。要使模块的用户绝缘，请添加方法</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">现在我们可以使用数组和哈希语法来访问一个对象。</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">现在我们可以将脚本的最后一行改为</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">现在可以通过以下方式完成脚本</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">现在执行与之前相同的步骤,从Makefile.PL文件生成一个Makefile,并运行make。</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">现在进程 &quot;A &quot;更新了数据库,并恰好改变了初始缓冲区中的一些数据。进程 &quot;A &quot;终止,将所有缓存数据冲到磁盘上,并释放数据库锁。此时磁盘上的数据库将正确反映进程 &quot;A &quot;所做的更改。</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">现在重新运行使重建我们新的共享库。</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">现在运行</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">现在在顶层的Makefile.PL上运行perl。注意它也在mylib目录下创建了一个Makefile。运行make,看它是否会cd到mylib目录下,然后在那里也运行make。</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">现在跑。</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">现在假设我们有一个以上的解释器实例同时运行。这是可行的，但 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 在构建perl时使用了Configure选项 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 或选项-Dusethreads -Duseithreads。默认情况下，启用这些Configure选项之一 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 每个解释器全局变量PL_perl_destruct_level设置为 &lt;code&gt;1&lt;/code&gt; ，以便自动进行彻底清除并正确初始化解释器变量。即使您不打算同时运行两个或多个解释器，而是要顺序运行它们，如上例所示，建议您使用 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 来构建perl 选项，否则在连续运行之间可能无法正确初始化某些解释器变量，并且您的应用程序可能崩溃。</target>
        </trans-unit>
        <trans-unit id="f1903abcbcbb8a74636f09d2f5f2bcae4b5c5eed" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">现在假设我们有多个运行在同一时间的解释器实例。这是可行的，但 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 在构建perl时使用了Configure选项 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 或选项-Dusethreads -Duseithreads。默认情况下，启用这些Configure选项之一 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 每个解释器全局变量PL_perl_destruct_level设置为 &lt;code&gt;1&lt;/code&gt; ，以便自动进行彻底清除并正确初始化解释器变量。即使您不打算同时运行两个或多个解释器，而是要顺序运行它们，如上例所示，建议您使用 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 来构建perl 选项，否则可能无法在连续运行之间正确初始化某些解释器变量，并且您的应用程序可能会崩溃。</target>
        </trans-unit>
        <trans-unit id="e49fb62e1176de7722979d95af388dc41f0ee3b3" translate="yes" xml:space="preserve">
          <source>Now switch back to blead and merge your smoke-me branch into it:</source>
          <target state="translated">现在切换回blead,把你的smoke-me分支合并进去。</target>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">现在看看你当前的目录。它看起来应该是这样的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
