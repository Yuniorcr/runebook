<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5ce2bae285dbd09666d07f99e460e4eebea8c753" translate="yes" xml:space="preserve">
          <source>This method uses &lt;code&gt;commands_quote&lt;/code&gt; to determine the correct quote. If &lt;code&gt;commands_quote&lt;/code&gt; is a space, no quoting will take place.</source>
          <target state="translated">此方法使用 &lt;code&gt;commands_quote&lt;/code&gt; 确定正确的报价。如果 &lt;code&gt;commands_quote&lt;/code&gt; 是一个空格，则不会进行任何引用。</target>
        </trans-unit>
        <trans-unit id="475ff388d47d9ff8c537b04d4cf8fd2786ec177c" translate="yes" xml:space="preserve">
          <source>This method was added in v0.20 of Math::BigRat (May 2007).</source>
          <target state="translated">这个方法是在 Math::BigRat 的 v0.20 中添加的(2007 年 5 月)。</target>
        </trans-unit>
        <trans-unit id="a9fdbef062f1e260e975ac993cde1b7e7c35b43d" translate="yes" xml:space="preserve">
          <source>This method was added in v0.22 of Math::BigRat (April 2008).</source>
          <target state="translated">这个方法是在 Math::BigRat 的 v0.22 中添加的(2008 年 4 月)。</target>
        </trans-unit>
        <trans-unit id="4f274a73d8190736635c257c7c7cb3e3c0fe18c0" translate="yes" xml:space="preserve">
          <source>This method was added in v1.82 of Math::BigInt (April 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.82版本(2007年4月)中加入的。</target>
        </trans-unit>
        <trans-unit id="892100fd26e628f38d9cdb9d5d762a8a6ee16072" translate="yes" xml:space="preserve">
          <source>This method was added in v1.84 of Math::BigInt (April 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.84版本(2007年4月)中加入的。</target>
        </trans-unit>
        <trans-unit id="def53de6390772e9ab517671e2de82585ed2894d" translate="yes" xml:space="preserve">
          <source>This method was added in v1.87 of Math::BigInt (June 2007).</source>
          <target state="translated">这个方法是在Math::BigInt的v1.87版本(2007年6月)中加入的。</target>
        </trans-unit>
        <trans-unit id="e5821a661d4054cf93a3f0baee35e1a4e8ee9c19" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 函数时将调用此方法。</target>
        </trans-unit>
        <trans-unit id="33be8d090d52cdf9ebec70873885856aba821ff5" translate="yes" xml:space="preserve">
          <source>This method will be called when the &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; function is called.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 函数时将调用此方法。</target>
        </trans-unit>
        <trans-unit id="07abfda6230642bdc24b2988efac200062ab0904" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is closed via the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 函数关闭句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="8c952116674febc1216a1fb0e4796db40ca65ad8" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is read from via the &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 函数从中读取句柄时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="53bcf4b7992a6d18135efe380f6cf616566ace5a" translate="yes" xml:space="preserve">
          <source>This method will be called when the handle is written to via the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数将句柄写入时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="2f7eb1cf0cb3798f7407e75f4a0686ab61a556fd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied array is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something and the value we're trying to put there.</source>
          <target state="translated">每当绑定数组中的一个元素被设置(写入)时,这个方法就会被触发。它在自引用之外还需要两个参数:我们试图存储某些东西的索引和我们试图放在那里的值。</target>
        </trans-unit>
        <trans-unit id="fef1865fb35cee1965cbfbe2864d43cfb61253d3" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is accessed (read). It takes one argument beyond its self reference: the key whose value we're trying to fetch.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定哈希中的元素时被触发。它除了自身引用之外,还需要一个参数:我们试图获取其值的键。</target>
        </trans-unit>
        <trans-unit id="6ff0eaa0013ee12dae761b1f3a38cc41d40d71c7" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an element in the tied hash is set (written). It takes two arguments beyond its self reference: the index at which we're trying to store something, and the value we're trying to put there.</source>
          <target state="translated">每次设置(写入)绑定哈希中的元素时,这个方法都会被触发。它需要两个参数,除了它的自引用之外,还需要两个参数:我们试图存储某些东西的索引,以及我们试图放在那里的值。</target>
        </trans-unit>
        <trans-unit id="f154ed5d9dede0079ff14f755f8d64da0b6d8569" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time an individual element the tied array is accessed (read). It takes one argument beyond its self reference: the index whose value we're trying to fetch.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定数组中的单个元素时被触发。它需要一个参数:我们试图获取其值的索引。</target>
        </trans-unit>
        <trans-unit id="ce4bdb5814566177219471512f35e981a551516b" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; functions. Beyond its self reference it also expects the list that was passed to the print function.</source>
          <target state="translated">每次使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say()&lt;/a&gt;&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递到打印功能的列表。</target>
        </trans-unit>
        <trans-unit id="46e361c76a8fe326ef26947ed7b27ef6314ab7da" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied handle is printed to with the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; function. Beyond its self reference it also expects the format and list that was passed to the printf function.</source>
          <target state="translated">每次使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 函数将绑定的句柄打印到此方法时，都会触发此方法。除了自引用之外，它还期望传递给printf函数的格式和列表。</target>
        </trans-unit>
        <trans-unit id="4d2309a54c3a525e60bc8a57c49ad44a6f62e89e" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is accessed (read). It takes no arguments beyond its self reference, which is the object representing the scalar we're dealing with. Because in this case we're using just a SCALAR ref for the tied scalar object, a simple $$self allows the method to get at the real value stored there. In our example below, that real value is the process ID to which we've tied our variable.</source>
          <target state="translated">这个方法将在每次访问(读取)绑定变量时被触发。除了self引用之外,它不需要任何参数,self引用是代表我们正在处理的标量的对象。因为在本例中,我们对绑定的标量对象只使用了一个SCALAR ref,一个简单的$$self就可以让这个方法获得存储在那里的实际值。在下面的例子中,这个实际值就是我们绑定变量的进程ID。</target>
        </trans-unit>
        <trans-unit id="074aba193a7d4ab7fc2d92f3649243f7a2526fbd" translate="yes" xml:space="preserve">
          <source>This method will be triggered every time the tied variable is set (assigned). Beyond its self reference, it also expects one (and only one) argument: the new value the user is trying to assign. Don't worry about returning a value from STORE; the semantic of assignment returning the assigned value is implemented with FETCH.</source>
          <target state="translated">这个方法将在每次设置(分配)绑定变量时被触发。除了它的自引用之外,它还期待一个(也只有一个)参数:用户试图赋值的新值。不用担心从store中返回一个值,赋值返回赋值的语义是用FETCH实现的。</target>
        </trans-unit>
        <trans-unit id="a70c828d5225a812501600b7ba6a4a618714e8ab" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; occurs. This can be useful if the class needs to know when no further calls will be made. (Except DESTROY of course.) See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below for more details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 时将触发此方法。如果该类需要知道什么时候不再进行调用，这将很有用。（当然，除了DESTROY除外。）有关更多详细信息，请参见&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的Unt Gotcha&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6dadf6ee9215d45834b1ebd72a2a25ea540b456" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with other object classes, such a method is seldom necessary, because Perl deallocates its moribund object's memory for you automatically--this isn't C++, you know. We'll use a DESTROY method here for debugging purposes only.</source>
          <target state="translated">当绑定的变量需要被销毁时,这个方法将被触发。和其他对象类一样,这样的方法很少是必要的,因为Perl会自动为你重新分配它那奄奄一息的对象的内存--这不是C++,你知道的。我们在这里使用 DESTROY 方法只是为了调试的目的。</target>
        </trans-unit>
        <trans-unit id="aba37b5cce6ea3c8466dd8e8d0896cfdf208ff19" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the tied variable needs to be destructed. As with the scalar tie class, this is almost never needed in a language that does its own garbage collection, so this time we'll just leave it out.</source>
          <target state="translated">当绑定变量需要被销毁时,这个方法将被触发。和标量绑定类一样,在自带垃圾收集功能的语言中几乎不需要这个方法,所以这次我们就不说了。</target>
        </trans-unit>
        <trans-unit id="1a30c4c1dc9863704c12fdf1f1b5872e08e0156b" translate="yes" xml:space="preserve">
          <source>This method will be triggered when the user is going to iterate through the hash, such as via a keys() or each() call.</source>
          <target state="translated">当用户要对哈希进行迭代时,比如通过 keys()或 each()调用,这个方法将被触发。</target>
        </trans-unit>
        <trans-unit id="241be65c4fe89a7db745cd5e6028ee4cea0a4bd5" translate="yes" xml:space="preserve">
          <source>This method will do a file transfer between two remote ftp servers. If &lt;code&gt;DEST_FILE&lt;/code&gt; is omitted then the leaf name of &lt;code&gt;SRC_FILE&lt;/code&gt; will be used.</source>
          <target state="translated">此方法将在两个远程ftp服务器之间进行文件传输。如果 &lt;code&gt;DEST_FILE&lt;/code&gt; 省略随后的叶名 &lt;code&gt;SRC_FILE&lt;/code&gt; 将被使用。</target>
        </trans-unit>
        <trans-unit id="714241362af6626714a493d5da28a5f3831d1838" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the interior sequence's text.</source>
          <target state="translated">本方法将获取/设置内部序列文本的对应解析树。</target>
        </trans-unit>
        <trans-unit id="81f73213adc2e84a3c6f2373dbd483c50f803f34" translate="yes" xml:space="preserve">
          <source>This method will get/set the corresponding parse-tree of the paragraph's text.</source>
          <target state="translated">本方法将获取/设置该段文字对应的解析树。</target>
        </trans-unit>
        <trans-unit id="e9978ed2996dd9bcc230654360a798a867715edb" translate="yes" xml:space="preserve">
          <source>This method will read the named file and deserialize it to a data structure, determining whether it should be JSON or YAML based on the filename. The file will be read using the &quot;:utf8&quot; IO layer.</source>
          <target state="translated">这个方法将读取命名的文件,并将其反序列化为一个数据结构,根据文件名决定它应该是JSON还是YAML。该文件将使用&quot;:utf8 &quot;IO层读取。</target>
        </trans-unit>
        <trans-unit id="b67738b0ceee5f0e621228df6d40624bf3ba896e" translate="yes" xml:space="preserve">
          <source>This method will reset the deflation object &lt;code&gt;$d&lt;/code&gt; . It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; has returned &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">此方法将重置通缩对象 &lt;code&gt;$d&lt;/code&gt; 。当您压缩多个数据流并且要使用同一对象压缩每个数据流时，可以使用它。仅在成功刷新了先前的数据流后，即对 &lt;code&gt;$d-&amp;gt;flush(Z_FINISH)&lt;/code&gt; 的调用返回 &lt;code&gt;Z_OK&lt;/code&gt; 时，才应使用它。</target>
        </trans-unit>
        <trans-unit id="c896817c407b0236207a4f8181caaf53efac5199" translate="yes" xml:space="preserve">
          <source>This method will reset the inflation object &lt;code&gt;$i&lt;/code&gt; . It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.</source>
          <target state="translated">该方法将重置通胀对象 &lt;code&gt;$i&lt;/code&gt; 。当您解压缩多个数据流并希望使用同一对象解压缩每个数据流时，可以使用它。</target>
        </trans-unit>
        <trans-unit id="c910df5717be7f7845368e614ada212ccc95c585" translate="yes" xml:space="preserve">
          <source>This method will return a &lt;a href=&quot;result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object representing the current line of TAP.</source>
          <target state="translated">此方法将返回表示&lt;a href=&quot;result&quot;&gt;TAP&lt;/a&gt;当前行的TAP :: Parser :: Result对象。</target>
        </trans-unit>
        <trans-unit id="94dd0495b55dbb9479c740e8c7707434102ef2b3" translate="yes" xml:space="preserve">
          <source>This method will return the</source>
          <target state="translated">本方法将返回</target>
        </trans-unit>
        <trans-unit id="64b72f6b7b9c90292fdf0c07acf00371c342b31f" translate="yes" xml:space="preserve">
          <source>This method will return the corresponding text of the paragraph.</source>
          <target state="translated">本方法将返回该段对应的文字。</target>
        </trans-unit>
        <trans-unit id="eb400e4423b1637ce4c15ebb34457f31a6dff2be" translate="yes" xml:space="preserve">
          <source>This method, also added in 5.22, returns the ID of the outer padlist.</source>
          <target state="translated">这个方法也是在5.22中加入的,返回外挂表的ID。</target>
        </trans-unit>
        <trans-unit id="4592c3f20e832c80ee7755d708e2fc413aad3a8b" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns an ID shared by clones of the same padlist.</source>
          <target state="translated">这个方法,在5.22中引入,返回同一个padlist的克隆共享的ID。</target>
        </trans-unit>
        <trans-unit id="9809e060290c8d05a80c630d780720e4ef068203" translate="yes" xml:space="preserve">
          <source>This method, introduced in 5.22, returns the B::PADNAMELIST. It is equivalent to &lt;code&gt;ARRAYelt&lt;/code&gt; with a 0 argument.</source>
          <target state="translated">在5.22中引入的此方法返回B :: PADNAMELIST。它等效于参数为0的 &lt;code&gt;ARRAYelt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29b87abd8043418845a4e29d3099fa81c542084b" translate="yes" xml:space="preserve">
          <source>This model is also handy for a form of recursive programming where, rather than having a subroutine call itself, it instead creates another thread. Prime and Fibonacci generators both map well to this form of the pipeline model. (A version of a prime number generator is presented later on.)</source>
          <target state="translated">这种模型对于递归编程的形式也很方便,在这种情况下,不是让一个子程序调用自己,而是创建另一个线程。质数发生器和斐波那契发生器都可以很好地映射到这种形式的流水线模型中。后面会介绍一个质数发生器的版本)。</target>
        </trans-unit>
        <trans-unit id="30009f920550802cc665953dfad42c7d9264746f" translate="yes" xml:space="preserve">
          <source>This model is common in GUI and server programs, where a main thread waits for some event and then passes that event to the appropriate worker threads for processing. Once the event has been passed on, the boss thread goes back to waiting for another event.</source>
          <target state="translated">这种模式在GUI和服务器程序中很常见,一个主线程等待某个事件,然后将该事件传递给相应的工作线程进行处理。一旦事件传递完毕,主线程就会回到等待另一个事件。</target>
        </trans-unit>
        <trans-unit id="b15bc8cde549f860c8eb7d12b3582c3e0ea39cf3" translate="yes" xml:space="preserve">
          <source>This model is particularly useful if the system running the program will distribute multiple threads across different processors. It can also be useful in ray tracing or rendering engines, where the individual threads can pass on interim results to give the user visual feedback.</source>
          <target state="translated">如果运行程序的系统会将多个线程分布在不同的处理器上,这种模式就特别有用。它在光线追踪或渲染引擎中也很有用,各个线程可以传递临时结果,给用户以视觉反馈。</target>
        </trans-unit>
        <trans-unit id="a46d487d5e105c40547660dc27acaa14d80672b3" translate="yes" xml:space="preserve">
          <source>This model makes the most sense if you have multiple processors so two or more threads will be executing in parallel, though it can often make sense in other contexts as well. It tends to keep the individual tasks small and simple, as well as allowing some parts of the pipeline to block (on I/O or system calls, for example) while other parts keep going. If you're running different parts of the pipeline on different processors you may also take advantage of the caches on each processor.</source>
          <target state="translated">如果你有多个处理器,所以两个或更多的线程将并行执行,这种模式是最有意义的,尽管它通常在其他情况下也有意义。它倾向于保持单个任务小而简单,以及允许管道的某些部分阻塞(例如,在I/O或系统调用上),而其他部分继续进行。如果你在不同的处理器上运行管道的不同部分,你也可以利用每个处理器上的缓存。</target>
        </trans-unit>
        <trans-unit id="ca5c3fc9e826014a4bf6c25dd9dfaa294e403640" translate="yes" xml:space="preserve">
          <source>This modifier is automatically selected by default when none of the others are, so yet another name for it is &quot;Default&quot;.</source>
          <target state="translated">当其他修饰符都没有的时候,这个修饰符会被默认自动选择,所以它的另一个名字是 &quot;默认&quot;。</target>
        </trans-unit>
        <trans-unit id="7d496a068117111419859bc00c9612b716988f03" translate="yes" xml:space="preserve">
          <source>This modifier is useful for people who only incidentally use Unicode, and who do not wish to be burdened with its complexities and security concerns.</source>
          <target state="translated">这个修饰符对于那些只是偶然使用Unicode的人来说很有用,他们不希望被Unicode的复杂性和安全问题所困扰。</target>
        </trans-unit>
        <trans-unit id="0e5335d13a0034ff0e79330d63821913e0ac8c3f" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'unicode_strings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; (or higher), but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use VERSION&lt;/a&gt;&lt;/code&gt; （或更高版本）将此修饰符指定为默认值，但是请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e12be54768ee3b0c57bff3f17db521cb0aa4207" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , but see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 可以将此修饰符指定为默认值，但是请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7947231e9d8ba8a56b871805ba4f83e34edd5a3b" translate="yes" xml:space="preserve">
          <source>This modifier may be specified to be the default by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; . If you do so, you may actually have occasion to use the &lt;code&gt;/u&lt;/code&gt; modifier explicitly if there are a few regular expressions where you do want full Unicode rules (but even here, it's best if everything were under feature &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; , along with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ). Also see &lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect?&lt;/a&gt;.</source>
          <target state="translated">可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/a'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; 将此修饰符指定为默认值。如果这样做的话，如果确实有一些需要完整的Unicode规则的正则表达式，那么实际上可能有机会显式地使用 &lt;code&gt;/u&lt;/code&gt; 修饰符（但是即使在这里，最好将所有内容都放在功能 &lt;code&gt;&quot;unicode_strings&quot;&lt;/code&gt; ，以及 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/aa'&lt;/code&gt; ）。另请参见&lt;a href=&quot;#Which-character-set-modifier-is-in-effect%3f&quot;&gt;哪个字符集修饰符有效？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="612208176f5e5f15f70f9fe87ffb9885ed3fb4f8" translate="yes" xml:space="preserve">
          <source>This modifier means to use the &quot;Default&quot; native rules of the platform except when there is cause to use Unicode rules instead, as follows:</source>
          <target state="translated">这个修饰词的意思是使用平台的 &quot;默认 &quot;本地规则,除非有理由使用Unicode规则,如下所示。</target>
        </trans-unit>
        <trans-unit id="749227e1bbfa4aaec7c32f6b70520da88bebf428" translate="yes" xml:space="preserve">
          <source>This modifier stands for ASCII-restrict (or ASCII-safe). This modifier, unlike the others, may be doubled-up to increase its effect.</source>
          <target state="translated">这个修饰符代表ASCII-restrict(或ASCII-safe)。与其他修饰符不同的是,这个修饰符可以双倍放大以增加其效果。</target>
        </trans-unit>
        <trans-unit id="fa6de4fa0b87cce4f41c3c3e6b2f399a24f53e8f" translate="yes" xml:space="preserve">
          <source>This module abstracts and provides all of the hooks into Perl internal debugging functionality, so that various implementations of Perl debuggers (or packages that want to simply get at the &quot;privileged&quot; debugging data) can all benefit from the development of this common code. Currently used by Swat, the perl/Tk GUI debugger.</source>
          <target state="translated">这个模块抽象并提供了所有进入Perl内部调试功能的钩子,因此各种Perl调试器的实现(或者是想简单获取 &quot;特权 &quot;调试数据的包)都可以从这个通用代码的开发中获益。目前perl/Tk GUI调试器Swat使用。</target>
        </trans-unit>
        <trans-unit id="6875f545409eef33a68dd7123f3a8648204e39c4" translate="yes" xml:space="preserve">
          <source>This module allows one to set this attribute on a subroutine that is already defined. For Perl subroutines (XSUBs are fine), it may or may not do what you want, depending on the code inside the subroutine, with details subject to change in future Perl versions. You may run into problems with lvalue context not being propagated properly into the subroutine, or maybe even assertion failures. For this reason, a warning is emitted if warnings are enabled. In other words, you should only do this if you really know what you are doing. You have been warned.</source>
          <target state="translated">这个模块允许人们在已经定义好的子程序上设置这个属性。对于Perl子程序(XSUBs也可以),它可能会做你想要的,也可能不会做,这取决于子程序内部的代码,细节在未来的Perl版本中可能会改变。你可能会遇到lvalue上下文不能正确传播到子程序中的问题,甚至可能是断言失败。因此,如果启用了警告,就会发出警告。换句话说,只有在你真正知道自己在做什么的情况下,你才应该这样做。你已经被警告了。</target>
        </trans-unit>
        <trans-unit id="a965ba5c24e8c32086e33820dca8017e296c7bac" translate="yes" xml:space="preserve">
          <source>This module also adds a stack trace to the error message when perl dies. This is useful for pinpointing what caused the death. The &lt;b&gt;-traceonly&lt;/b&gt; (or just &lt;b&gt;-t&lt;/b&gt;) flag turns off the explanations of warning messages leaving just the stack traces. So if your script is dieing, run it again with</source>
          <target state="translated">当perl死掉时，该模块还将堆栈跟踪添加到错误消息中。这对于查明造成死亡的原因很有用。所述&lt;b&gt;-traceonly&lt;/b&gt;（或只是&lt;b&gt;-t&lt;/b&gt;）标志关闭只留下栈跟踪警告消息的解释。因此，如果您的脚本即将死机，请使用</target>
        </trans-unit>
        <trans-unit id="8f7fb6f3dfdd280d1b2872ffca7de6a38c89ca71" translate="yes" xml:space="preserve">
          <source>This module also provides a function &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; that returns true iff the language tag is syntactically valid and is for general use (like &quot;fr&quot; or &quot;fr-ca&quot;, below). That is, it returns false for tags that are syntactically invalid and for tags, like &quot;aus&quot;, that are listed in brackets below. This function is not exported.</source>
          <target state="translated">该模块还提供了一个函数 &lt;code&gt;I18N::LangTags::List::is_decent( &lt;i&gt;langtag&lt;/i&gt; )&lt;/code&gt; ，如果该语言标记在语法上有效且可以通用（如下面的&amp;ldquo; fr&amp;rdquo;或&amp;ldquo; fr-ca&amp;rdquo; ），则返回true。也就是说，对于语法无效的标记和下面括号中列出的标记（例如&amp;ldquo; aus&amp;rdquo;），它返回false。此功能未导出。</target>
        </trans-unit>
        <trans-unit id="35c9fcef6d8c497b285988252e5e12636887688f" translate="yes" xml:space="preserve">
          <source>This module and its competitor, the CPANPLUS module, are both much cooler than the other. CPAN.pm is older. CPANPLUS was designed to be more modular, but it was never intended to be compatible with CPAN.pm.</source>
          <target state="translated">这个模块和它的竞争对手CPANPLUS模块,都比对方酷多了。CPAN.pm比较老。CPANPLUS的设计是为了更加模块化,但它从未打算与CPAN.pm兼容。</target>
        </trans-unit>
        <trans-unit id="784f2f639e9afabf2dc275e208777379339cfa1d" translate="yes" xml:space="preserve">
          <source>This module attempts to be squeaky clean w.r.t &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; and when warnings are enabled.</source>
          <target state="translated">该模块试图 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;严格的标准；以及启用警告时。</target>
        </trans-unit>
        <trans-unit id="004ba23e4c1d9e020129a075fb1542d515c8beb8" translate="yes" xml:space="preserve">
          <source>This module by Jos Boumans &amp;lt;kane@cpan.org&amp;gt;.</source>
          <target state="translated">该模块由Jos Boumans &amp;lt;kane@cpan.org&amp;gt;提供。</target>
        </trans-unit>
        <trans-unit id="3512e67f1197d03fbeb001853d009060532cfa22" translate="yes" xml:space="preserve">
          <source>This module can build the C portions of Perl modules by invoking the appropriate compilers and linkers in a cross-platform manner. It was motivated by the &lt;code&gt;Module::Build&lt;/code&gt; project, but may be useful for other purposes as well. However, it is</source>
          <target state="translated">通过以跨平台方式调用适当的编译器和链接器，此模块可以构建Perl模块的C部分。它是由 &lt;code&gt;Module::Build&lt;/code&gt; 项目驱动的，但也可能对其他目的有用。但是，这是</target>
        </trans-unit>
        <trans-unit id="26eefbe0903fb2ede95e48daeed0c357506e5da6" translate="yes" xml:space="preserve">
          <source>This module can provoke sizeable inefficiencies for regular expressions, due to unfortunate implementation details. If performance matters in your application and you don't need $PREMATCH, $MATCH, or $POSTMATCH, try doing</source>
          <target state="translated">由于不幸的实现细节,这个模块可能会对正则表达式造成相当大的低效率。如果您的应用程序的性能很重要,而且您不需要 $PREMATCH、$MATCH 或 $POSTMATCH,请尝试做以下操作</target>
        </trans-unit>
        <trans-unit id="5e29d99feceeb44433f425fbac43b49ef593d502" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种风格：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls版本没有。您可以通过查看 &lt;code&gt;$Text::Tabs::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Pers 是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="febd1d0bc1aeb9c9dc580b98ecebabe324968f11" translate="yes" xml:space="preserve">
          <source>This module comes in two flavors: one for modern perls (5.10 and above) and one for ancient obsolete perls. The version for modern perls has support for Unicode. The version for old perls does not. You can tell which version you have installed by looking at &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; : it is &lt;code&gt;old&lt;/code&gt; for obsolete perls and &lt;code&gt;modern&lt;/code&gt; for current perls.</source>
          <target state="translated">该模块有两种风格：一种用于现代Perls（5.10及更高版本），一种用于古代过时的Perl。现代perls的版本支持Unicode。旧的perls版本没有。您可以通过查看 &lt;code&gt;$Text::Wrap::SUBVERSION&lt;/code&gt; 来确定已安装的版本：对于过时的Perls 是 &lt;code&gt;old&lt;/code&gt; 版本，对于当前的Pers是 &lt;code&gt;modern&lt;/code&gt; 版本。</target>
        </trans-unit>
        <trans-unit id="d14a28688b621d987b1f8fc9e23815cd4abf0ed8" translate="yes" xml:space="preserve">
          <source>This module contains a good example of how to use tie to implement a cache and an example of how to make a tied variable readonly to those outside of it.</source>
          <target state="translated">这个模块包含了一个很好的如何使用 tie 来实现缓存的例子,以及一个如何让绑定的变量对其外的人只读的例子。</target>
        </trans-unit>
        <trans-unit id="d311a4e7a3db9109ca676b3552f311797aef79ac" translate="yes" xml:space="preserve">
          <source>This module contains methods to test the reachability of remote hosts on a network. A ping object is first created with optional parameters, a variable number of hosts may be pinged multiple times and then the connection is closed.</source>
          <target state="translated">本模块包含了测试网络上远程主机的可到达性的方法。首先创建一个带有可选参数的ping对象,可以多次ping不同数量的主机,然后关闭连接。</target>
        </trans-unit>
        <trans-unit id="0e0177cabfcfd905cc13252e41134159a6c784e5" translate="yes" xml:space="preserve">
          <source>This module deals with a lot of system dependencies and has quite a few architecture specific &lt;code&gt;if&lt;/code&gt; s in the code.</source>
          <target state="translated">该模块处理许多系统依赖性，并且在代码中具有许多特定于体系结构的 &lt;code&gt;if&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="048af0729c3efd4457ee6a9d255333490a26b61d" translate="yes" xml:space="preserve">
          <source>This module defines a standard</source>
          <target state="translated">本模块定义了一个标准的</target>
        </trans-unit>
        <trans-unit id="ccc077b805dfb6d70b724e9bdd6fb4fe5347a6c3" translate="yes" xml:space="preserve">
          <source>This module defines one public function, &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; . This function is not exported (nor is even exportable), and it takes no parameters.</source>
          <target state="translated">此模块定义一个公共函数 &lt;code&gt;I18N::LangTags::Detect::detect()&lt;/code&gt; 。此函数不会导出（甚至也无法导出），并且不带任何参数。</target>
        </trans-unit>
        <trans-unit id="d9f93c560d9ab4f740a2b97f280df75095aa9c1e" translate="yes" xml:space="preserve">
          <source>This module defines some basic input objects used by &lt;b&gt;Pod::Parser&lt;/b&gt; when reading and parsing POD text from an input source. The following objects are defined:</source>
          <target state="translated">该模块定义了从输入源读取和解析POD文本时&lt;b&gt;Pod :: Parser&lt;/b&gt;使用的一些基本输入对象。定义了以下对象：</target>
        </trans-unit>
        <trans-unit id="5588b6a383faab0057a18646001f16348459eef2" translate="yes" xml:space="preserve">
          <source>This module defines three public functions, &lt;code&gt;plan(...)&lt;/code&gt; , &lt;code&gt;ok(...)&lt;/code&gt; , and &lt;code&gt;skip(...)&lt;/code&gt; . By default, all three are exported by the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; statement.</source>
          <target state="translated">这个模块定义了三个公共函数， &lt;code&gt;plan(...)&lt;/code&gt; ， &lt;code&gt;ok(...)&lt;/code&gt; 和 &lt;code&gt;skip(...)&lt;/code&gt; 。默认情况下，这三个都通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Test;&lt;/code&gt; 导出；声明。</target>
        </trans-unit>
        <trans-unit id="0d26bb4e43183e0559ebca4dee112bd3a0d0b364" translate="yes" xml:space="preserve">
          <source>This module encapsulates reading &lt;a href=&quot;../cpan&quot;&gt;Distroprefs&lt;/a&gt; and matching them against CPAN distributions.</source>
          <target state="translated">该模块封装了读取&lt;a href=&quot;../cpan&quot;&gt;Distroprefs&lt;/a&gt;并将其与CPAN分布进行匹配的功能。</target>
        </trans-unit>
        <trans-unit id="0c9dfd5842361144dbb1663f5f104740841b03d0" translate="yes" xml:space="preserve">
          <source>This module ensures that all data written to the DBM file is null terminated. This is useful when you have a perl script that needs to interoperate with a DBM file that a C program also uses. A fairly common issue is for the C application to include the terminating null in a string when it writes to the DBM file. This filter will ensure that all data written to the DBM file can be read by the C application.</source>
          <target state="translated">这个模块确保所有写入DBM文件的数据都是空结束的。当你有一个perl脚本需要与一个C程序也使用的DBM文件进行交互时,这个模块是非常有用的。一个相当常见的问题是,当C程序向DBM文件写入数据时,会在一个字符串中包含终止的null。这个过滤器将确保所有写入DBM文件的数据可以被C程序读取。</target>
        </trans-unit>
        <trans-unit id="cd7e8d1d3170c6e8daec0f86fc59011732a6349b" translate="yes" xml:space="preserve">
          <source>This module exports convenience functions for all of the class methods provided by File::Spec.</source>
          <target state="translated">该模块为File::Spec提供的所有类方法输出方便函数。</target>
        </trans-unit>
        <trans-unit id="225bff521140d6082b4081701a5c9f07eb77dbdc" translate="yes" xml:space="preserve">
          <source>This module exports exactly one function, &lt;code&gt;memoize&lt;/code&gt; . The rest of the functions in this package are None of Your Business.</source>
          <target state="translated">该模块仅输出一个功能，即 &lt;code&gt;memoize&lt;/code&gt; 。该软件包中的其余功能与您无关。</target>
        </trans-unit>
        <trans-unit id="b53f8e98717e2df0ba097b4ab532a6f74e551ea4" translate="yes" xml:space="preserve">
          <source>This module exports two functions by default, &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; .</source>
          <target state="translated">默认情况下，此模块导出两个函数 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d62e7ee6ec8e2b5b39029ab7ee6ccd36cf4dfeb9" translate="yes" xml:space="preserve">
          <source>This module extends the terse diagnostics normally emitted by both the perl compiler and the perl interpreter (from running perl with a -w switch or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ), augmenting them with the more explicative and endearing descriptions found in &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;. Like the other pragmata, it affects the compilation phase of your program rather than merely the execution phase.</source>
          <target state="translated">该模块扩展了perl编译器和perl解释器通常发出的简洁诊断（通过使用-w开关运行perl或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ），并在&lt;a href=&quot;perldiag&quot;&gt;perldiag中&lt;/a&gt;提供了更详尽和有趣的描述，以增强它们的功能。像其他实用程序一样，它会影响程序的编译阶段，而不仅仅是执行阶段。</target>
        </trans-unit>
        <trans-unit id="3ec683936a1587c1835f23fd06a510bf338b7e80" translate="yes" xml:space="preserve">
          <source>This module has been deprecated since perl v5.18. See &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; and &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;.</source>
          <target state="translated">从perl v5.18开始不推荐使用此模块。见&lt;a href=&quot;#DESCRIPTION&quot;&gt;描述&lt;/a&gt;和&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2117e00acdbd9807a78cbd1ea4a675762026720f" translate="yes" xml:space="preserve">
          <source>This module has two interfaces, one through color() and colored() and the other through constants. It also offers the utility functions uncolor(), colorstrip(), colorvalid(), and coloralias(), which have to be explicitly imported to be used (see &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;).</source>
          <target state="translated">这个模块有两个接口，一个通过color（）和colored（），另一个通过常量。它还提供了实用函数uncolor（），colorstrip（），colorvalid（）和coloralias（），必须显式导入才能使用它们（请参见&lt;a href=&quot;#SYNOPSIS&quot;&gt;提要&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b510432f8750d5bbad1de7af5fced7b88ef44df" translate="yes" xml:space="preserve">
          <source>This module implements China-based Chinese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">该模块实现了基于中国的中文字符编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="18f94573bd55ebab6dfdf33a299319140ec5bdab" translate="yes" xml:space="preserve">
          <source>This module implements Japanese charset encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了日语的字符集编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="85a823a7495a5d305f8dfc87daf3a9452bf40405" translate="yes" xml:space="preserve">
          <source>This module implements Korean charset encodings. Encodings supported are as follows.</source>
          <target state="translated">该模块实现了韩文字符集编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="1ac6b792bfff4da11b88119131c465048e55ab98" translate="yes" xml:space="preserve">
          <source>This module implements RFC 2047 Mime Header Encoding. There are 3 variant encoding names; &lt;code&gt;MIME-Header&lt;/code&gt; , &lt;code&gt;MIME-B&lt;/code&gt; and &lt;code&gt;MIME-Q&lt;/code&gt; . The difference is described below</source>
          <target state="translated">此模块实现RFC 2047 Mime标头编码。有3种变体编码名称； &lt;code&gt;MIME-Header&lt;/code&gt; ， &lt;code&gt;MIME-B&lt;/code&gt; 和 &lt;code&gt;MIME-Q&lt;/code&gt; 。区别描述如下</target>
        </trans-unit>
        <trans-unit id="fd2c9a90ea8e309e706421846f519bfe977d609d" translate="yes" xml:space="preserve">
          <source>This module implements UTF-7 encoding documented in RFC 2152. UTF-7, as its name suggests, is a 7-bit re-encoded version of UTF-16BE. It is designed to be MTA-safe and expected to be a standard way to exchange Unicoded mails via mails. But with the advent of UTF-8 and 8-bit compliant MTAs, UTF-7 is hardly ever used.</source>
          <target state="translated">这个模块实现了RFC 2152中记载的UTF-7编码。UTF-7,顾名思义,是UTF-16BE的7位重编码版本。它被设计成MTA安全的,并被期望成为通过邮件交换Unicoded邮件的标准方式。但随着UTF-8和8位兼容MTA的出现,UTF-7几乎没有被使用过。</target>
        </trans-unit>
        <trans-unit id="6a778bf541b175d3967361a621a9111e411a3873" translate="yes" xml:space="preserve">
          <source>This module implements a PerlIO layer that works on files encoded in the quoted-printable format. It will decode from quoted-printable while reading from a handle, and it will encode as quoted-printable while writing to a handle.</source>
          <target state="translated">这个模块实现了一个PerlIO层,它可以处理以quoted-printable格式编码的文件。当从一个句柄读取时,它将从quoted-printable解码,当向一个句柄写入时,它将编码为quoted-printable。</target>
        </trans-unit>
        <trans-unit id="ed550b03d65e4b729769320dd5e86c30fc421672" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the POP3 protocol, enabling a perl5 application to talk to POP3 servers. This documentation assumes that you are familiar with the POP3 protocol described in RFC1939.</source>
          <target state="translated">这个模块实现了一个POP3协议的客户端接口,使perl5应用程序能够与POP3服务器对话。本文档假定您熟悉RFC1939中描述的POP3协议。</target>
        </trans-unit>
        <trans-unit id="f3343630b02b7f19c2e9f15e0bc9d4d62bafd5e3" translate="yes" xml:space="preserve">
          <source>This module implements a client interface to the SMTP and ESMTP protocol, enabling a perl5 application to talk to SMTP servers. This documentation assumes that you are familiar with the concepts of the SMTP protocol described in RFC821.</source>
          <target state="translated">这个模块实现了SMTP和ESMTP协议的客户端接口,使perl5应用程序能够与SMTP服务器对话。本文档假定您熟悉RFC821中描述的SMTP协议的概念。</target>
        </trans-unit>
        <trans-unit id="208a0fbb6b2b9365a0b457c6e7c2a20c4ee8bdbb" translate="yes" xml:space="preserve">
          <source>This module implements all Character Encoding Schemes of Unicode that are officially documented by Unicode Consortium (except, of course, for UTF-8, which is a native format in perl).</source>
          <target state="translated">这个模块实现了Unicode联盟官方文档中的所有Unicode字符编码方案(当然,UTF-8除外,它是perl中的本地格式)。</target>
        </trans-unit>
        <trans-unit id="4a5fc149cac5c063339467ffcf19fbcbdd274ebc" translate="yes" xml:space="preserve">
          <source>This module implements symbol and dingbats encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了符号和丁巴特的编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="91d2629cfba9471ae750b605c30149641a050967" translate="yes" xml:space="preserve">
          <source>This module implements the Windows-specific parts of ExtUtils::CBuilder. Most of the Windows-specific stuff has to do with compiling and linking C code. Currently we support the 3 compilers perl itself supports: MSVC, BCC, and GCC.</source>
          <target state="translated">这个模块实现了ExtUtils::CBuilder的Windows专用部分。大部分Windows专用的东西都与编译和链接C代码有关。目前我们支持perl本身所支持的3个编译器:MSVC、BCC和GCC。MSVC,BCC,和 GCC.</target>
        </trans-unit>
        <trans-unit id="f9fa4e0ad3f8d3bc6d28f8c2e962b8d03cb9cfa8" translate="yes" xml:space="preserve">
          <source>This module implements tradition Chinese charset encodings as used in Taiwan and Hong Kong. Encodings supported are as follows.</source>
          <target state="translated">这个模块实现了台湾和香港地区使用的传统中文字符编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="6d3abe1f6aae133c8268ef4a9c7e2b3f247e4b85" translate="yes" xml:space="preserve">
          <source>This module implements various EBCDIC-Based encodings. Encodings supported are as follows.</source>
          <target state="translated">本模块实现了各种基于EBCDIC的编码。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="71223016b72a87a85df3e296ab0f30c149dbcfa6" translate="yes" xml:space="preserve">
          <source>This module implements various single byte encodings. For most cases it uses \x80-\xff (upper half) to map non-ASCII characters. Encodings supported are as follows.</source>
          <target state="translated">这个模块实现了各种单字节编码。在大多数情况下,它使用\x80-\xff(上半部分)来映射非ASCII字符。支持的编码如下。</target>
        </trans-unit>
        <trans-unit id="cc2e021c9aa08753ca094f4f9555269ba3008c18" translate="yes" xml:space="preserve">
          <source>This module inherits from &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; , so any functionality not implemented here will be implemented there. The interfaces are defined by the &lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils::CBuilder&lt;/a&gt; documentation.</source>
          <target state="translated">该模块继承自 &lt;code&gt;ExtUtils::CBuilder::Base&lt;/code&gt; ，因此此处未实现的任何功能都将在此处实现。接口由&lt;a href=&quot;../../cbuilder&quot;&gt;ExtUtils :: CBuilder&lt;/a&gt;文档定义。</target>
        </trans-unit>
        <trans-unit id="19da1ff10a7249eedb446c4c19eb17fbb02bae8e" translate="yes" xml:space="preserve">
          <source>This module internally uses the epoch seconds system that is provided via the perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; function and supported by &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该模块在内部使用通过perl &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 函数提供并由 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 支持的纪元秒制。</target>
        </trans-unit>
        <trans-unit id="458e3aac1c45af194716db0ddfa546c2e44d1b98" translate="yes" xml:space="preserve">
          <source>This module is a &quot;pure virtual base class&quot;--it has nothing of its own. It's just there to inherit from one of the various DBM packages. It prefers ndbm for compatibility reasons with Perl 4, then Berkeley DB (See &lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;), GDBM, SDBM (which is always there--it comes with Perl), and finally ODBM. This way old programs that used to use NDBM via dbmopen() can still do so, but new ones can reorder @ISA:</source>
          <target state="translated">该模块是一个&amp;ldquo;纯虚拟基类&amp;rdquo;，它没有自己的功能。它只是从各种DBM软件包之一继承而来的。由于与Perl 4的兼容性原因，它更喜欢ndbm，然后选择Berkeley DB（请参阅&lt;a href=&quot;db_file&quot;&gt;DB_File&lt;/a&gt;），GDBM，SDBM（始终存在-Perl随附），最后选择ODBM。这样，以前通过dbmopen（）使用NDBM的旧程序仍然可以这样做，但是新程序可以对@ISA重新排序：</target>
        </trans-unit>
        <trans-unit id="1c04eeff8ead05e06a53857583cc861707b5c717" translate="yes" xml:space="preserve">
          <source>This module is a simple wrapper around &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt;, designed to alleviate the need of creating</source>
          <target state="translated">该模块是&lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt;的简单包装，旨在减轻创建的需要。</target>
        </trans-unit>
        <trans-unit id="e16f5e2a01129069277c30d3b7f3daee0fb1dd1b" translate="yes" xml:space="preserve">
          <source>This module is an implementation of Unicode Technical Standard #10 (a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).</source>
          <target state="translated">这个模块是Unicode技术标准#10 (a.k.a.UTS #10)-Unicode Collation Algorithm (a.k.a.UCA)的实现。</target>
        </trans-unit>
        <trans-unit id="c1b7492744c579fc1d9bfb8835d90982b09e7c1d" translate="yes" xml:space="preserve">
          <source>This module is an outgrowth of the &lt;code&gt;Module::Build&lt;/code&gt; project, to which there have been many contributors. Notably, Randy W. Sims submitted lots of code to support 3 compilers on Windows and helped with various other platform-specific issues. Ilya Zakharevich has contributed fixes for OS/2; John E. Malmberg and Peter Prymmer have done likewise for VMS.</source>
          <target state="translated">该模块是 &lt;code&gt;Module::Build&lt;/code&gt; 项目的产物，已经有许多贡献者。值得注意的是，Randy W. Sims提交了许多代码来支持Windows上的3个编译器，并帮助解决了其他各种特定于平台的问题。Ilya Zakharevich提供了OS / 2的修复程序。John E. Malmberg和Peter Prymmer也为VMS做过同样的事情。</target>
        </trans-unit>
        <trans-unit id="1f5ba4ee559ca9f1454b4c1a05d7f38b94f36610" translate="yes" xml:space="preserve">
          <source>This module is based on a Perl 4 library, timelocal.pl, that was included with Perl 4.036, and was most likely written by Tom Christiansen.</source>
          <target state="translated">这个模块是基于Perl 4.036中包含的Perl 4库timelocal.pl,很可能是由Tom Christiansen编写的。</target>
        </trans-unit>
        <trans-unit id="4cbc64a6620dfb67500a67bd41b8098f113352da" translate="yes" xml:space="preserve">
          <source>This module is by no means trying to be a complete testing system. It's just to get you started. Once you're off the ground its recommended you look at &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;.</source>
          <target state="translated">此模块绝不是要成为一个完整的测试系统。只是为了让您入门。一旦您动手了，建议您看一下&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2753244f46b0ce153d304706dfb95e861d35abaf" translate="yes" xml:space="preserve">
          <source>This module is copyright (C) Charles Bailey, Tim Bunce and David Landgren 1995-2013. All rights reserved.</source>
          <target state="translated">本模块的版权归Charles Bailey,Tim Bunce和David Landgren 1995-2013所有。保留所有权利。</target>
        </trans-unit>
        <trans-unit id="c3dc79528e0a53341f5f1a2385863e6d0f321326" translate="yes" xml:space="preserve">
          <source>This module is copyright (c) 2002 - 2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;. All rights reserved.</source>
          <target state="translated">该模块的版权（c）2002-2009 Jos Boumans &amp;lt;kane@cpan.org&amp;gt;。版权所有。</target>
        </trans-unit>
        <trans-unit id="e106aa2d7581dc33a3d1c862720a197c581da1e6" translate="yes" xml:space="preserve">
          <source>This module is designed to support operations commonly performed on file specifications (usually called &quot;file names&quot;, but not to be confused with the contents of a file, or Perl's file handles), such as concatenating several directory and file names into a single path, or determining whether a path is rooted. It is based on code directly taken from MakeMaker 5.17, code written by Andreas K&amp;ouml;nig, Andy Dougherty, Charles Bailey, Ilya Zakharevich, Paul Schinder, and others.</source>
          <target state="translated">此模块旨在支持通常对文件规范执行的操作（通常称为&amp;ldquo;文件名&amp;rdquo;，但不要与文件内容或Perl的文件句柄相混淆），例如将多个目录和文件名串联到单个路径中，或确定路径是否植根。它基于直接取自MakeMaker 5.17的代码，AndreasK&amp;ouml;nig，Andy Dougherty，Charles Bailey，Ilya Zakharevich，Paul Schinder等编写的代码。</target>
        </trans-unit>
        <trans-unit id="b88b2f05f3eb8f5317475c544c0d41c821542019" translate="yes" xml:space="preserve">
          <source>This module is designed to work with &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. To make the Base64 transcoder example above really work, you could write a module like this:</source>
          <target state="translated">该模块旨在与&lt;a href=&quot;encoding&quot;&gt;Encode :: Encoding一起使用&lt;/a&gt;。为了使上面的Base64转码器示例真正起作用，您可以编写如下模块：</target>
        </trans-unit>
        <trans-unit id="3eaa300076a46b36258692823afcaf30f3da1dac" translate="yes" xml:space="preserve">
          <source>This module is experimental, and may contain bugs. Please report bugs to the address below.</source>
          <target state="translated">这个模块是实验性的,可能会有bug。请将错误报告到以下地址。</target>
        </trans-unit>
        <trans-unit id="df5a318ad47ed1cb98fcceb8a257ad12588cd0fd" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件,你可以在与Perl本身相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="0fdd885419be85bc33964005f90fc4cadf3fdd76" translate="yes" xml:space="preserve">
          <source>This module is free software, you may distribute it under the same terms as Perl.</source>
          <target state="translated">这个模块是自由软件,你可以在与Perl相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="922385d4cd422695e010d41aeec2d5c5dffbe730" translate="yes" xml:space="preserve">
          <source>This module is free software. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件。它可以在与Perl本身相同的条款下使用、重新分配和/或修改。</target>
        </trans-unit>
        <trans-unit id="8713cb7bfbc646a13e38df90a39fe040d945517a" translate="yes" xml:space="preserve">
          <source>This module is free software. You may distribute it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是免费软件。你可以在与Perl本身相同的条款下发布它。</target>
        </trans-unit>
        <trans-unit id="870a9546afdd84e9a3a4ff38074b2ee21c55579d" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="c0830e7b6d0dd0580741b7e45292c09ed7c6c8d7" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">该模块是免费软件；您可以按照与Perl本身相同的条款重新分发和/或修改它。参见&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3300a405455959dd665a3badfe243e6fa30c2626" translate="yes" xml:space="preserve">
          <source>This module is free software; you can redistribute it or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个模块是自由软件;你可以在与Perl本身相同的条件下重新发布或修改它。</target>
        </trans-unit>
        <trans-unit id="428130d7bad8c548e3890e11a89bef5821bc3665" translate="yes" xml:space="preserve">
          <source>This module is just a translation of the C</source>
          <target state="translated">这个模块只是对C</target>
        </trans-unit>
        <trans-unit id="53d4261ed48fcbc4558e06b2e6b719f698501a77" translate="yes" xml:space="preserve">
          <source>This module is just for testing expiration semantics. It's not a very good example of how to write an expiration module.</source>
          <target state="translated">这个模块只是用来测试到期语义的。这不是一个很好的例子,如何写一个到期模块。</target>
        </trans-unit>
        <trans-unit id="f745572f29549c61507fb4f34a61c7a87abbc5ec" translate="yes" xml:space="preserve">
          <source>This module is managed in an open GitHub repository, &lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/&lt;/a&gt;. Feel free to fork and contribute, or to clone &lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git://github.com/theory/pod-simple.git&lt;/a&gt; and send patches!</source>
          <target state="translated">该模块在开放的GitHub存储库&lt;a href=&quot;https://github.com/theory/pod-simple/&quot;&gt;https://github.com/theory/pod-simple/中进行管理&lt;/a&gt;。随意分叉和贡献，或克隆&lt;a href=&quot;git://github.com/theory/pod-simple.git&quot;&gt;git：//github.com/theory/pod-simple.git&lt;/a&gt;并发送补丁！</target>
        </trans-unit>
        <trans-unit id="7d0ab6711ea5063095e0e85b171ef73740045783" translate="yes" xml:space="preserve">
          <source>This module is not compatible with Unix &lt;code&gt;compress&lt;/code&gt; .</source>
          <target state="translated">该模块与Unix &lt;code&gt;compress&lt;/code&gt; 不兼容。</target>
        </trans-unit>
        <trans-unit id="d1c6a1686a9e6172b47ee3f5d419b358b2cc40a5" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Compress modules.</source>
          <target state="translated">这个模块不打算直接用于应用程序代码中,它的唯一目的是被IO::Compress模块子类化。它的唯一目的是被IO::Compress模块子类化。</target>
        </trans-unit>
        <trans-unit id="0f3671c101f1cebdeab0ce875c68fe36c60360d8" translate="yes" xml:space="preserve">
          <source>This module is not intended for direct use in application code. Its sole purpose is to be sub-classed by IO::Uncompress modules.</source>
          <target state="translated">这个模块不打算直接用于应用程序代码中,它的唯一目的是被IO::Uncompress模块子类化。它的唯一目的是被IO::Uncompress模块子类化。</target>
        </trans-unit>
        <trans-unit id="7164bd2152d2e3839e89dbfa3b86eaa11bce3dbe" translate="yes" xml:space="preserve">
          <source>This module is part of the Time::Piece distribution. It allows the user to find out the number of minutes, hours, days, weeks or years in a given number of seconds. It is returned by Time::Piece when you delta two Time::Piece objects.</source>
          <target state="translated">这个模块是Time::Piece分布的一部分,它允许用户在给定的秒数中找出分钟、小时、天、周或年的数量。它允许用户在给定的秒数中找出分钟、小时、天、周或年的数量。当你把两个Time::Piece对象进行三角运算时,Time::Piece会返回这个模块。</target>
        </trans-unit>
        <trans-unit id="22df619b80747d338bb7c64e8fdc1d4aef53ad12" translate="yes" xml:space="preserve">
          <source>This module is part of the core Perl distribution and is also maintained for CPAN by Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;.</source>
          <target state="translated">该模块是Perl核心发行版的一部分，并且由Jonathan Stowe &amp;lt;jns@gellyfish.co.uk&amp;gt;维护，用于CPAN。</target>
        </trans-unit>
        <trans-unit id="194bd926549ad2d7bd7a1e89514e8690d0700ec1" translate="yes" xml:space="preserve">
          <source>This module is released under the same terms as Perl itself.</source>
          <target state="translated">这个模块是在与Perl本身相同的条件下发布的。</target>
        </trans-unit>
        <trans-unit id="9e7d44a3d58cea8a100de62304c29f63b460d560" translate="yes" xml:space="preserve">
          <source>This module is still in beta. Cygwin-knowledgeable folks are invited to offer patches and suggestions.</source>
          <target state="translated">该模块仍处于测试阶段。我们邀请熟悉Cygwin的人提供补丁和建议。</target>
        </trans-unit>
        <trans-unit id="f3a7ded1d62af46df9b70aea1e61bb63a4d5e250" translate="yes" xml:space="preserve">
          <source>This module is used by &lt;code&gt;h2xs&lt;/code&gt; to write the file</source>
          <target state="translated">&lt;code&gt;h2xs&lt;/code&gt; 使用此模块写入文件</target>
        </trans-unit>
        <trans-unit id="a7926bd29bba2324b3fe7c588f46c743752e1304" translate="yes" xml:space="preserve">
          <source>This module is used for running batch-conversions of a lot of HTML documents</source>
          <target state="translated">该模块用于运行大量的HTML文档的批量转换。</target>
        </trans-unit>
        <trans-unit id="839a2e768fddb8f7898e0f04347e52df5765427a" translate="yes" xml:space="preserve">
          <source>This module is used internally as a base class by Time::localtime And Time::gmtime functions. It creates a Time::tm struct object which is addressable just like's C's tm structure from</source>
          <target state="translated">这个模块在内部被Time::localtime和Time::gmtime函数用作基类。它创建了一个Time::tm结构对象,这个结构对象就像C语言的tm结构一样,可以从</target>
        </trans-unit>
        <trans-unit id="07f553b400d2280f304688df200f5b35ef787f6a" translate="yes" xml:space="preserve">
          <source>This module is used to implement the special hashes &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , but it can be used to tie other variables as you choose.</source>
          <target state="translated">该模块用于实现特殊的哈希 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; ，但可以根据需要绑定其他变量。</target>
        </trans-unit>
        <trans-unit id="1910d98cb0d7696e9377a9fe44d03beb3d7a9af8" translate="yes" xml:space="preserve">
          <source>This module is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">当与一个C/C++应用程序进行交互时,这个模块被用于使用C int作为DBM文件中的键和/或值。</target>
        </trans-unit>
        <trans-unit id="d8aa8f33e315204f28ac3fdb706ab3fb362c4d36" translate="yes" xml:space="preserve">
          <source>This module is useful for people who are writing their own back end, or who are learning about the Perl internals. It's not useful to the average programmer.</source>
          <target state="translated">这个模块对于正在编写自己的后端,或者正在学习Perl内部的人很有用。对普通程序员来说,它没有用处。</target>
        </trans-unit>
        <trans-unit id="422eedc66ca57180bd78963179219d9ec2d2c3fd" translate="yes" xml:space="preserve">
          <source>This module is very unusual as overloaded modules go: it does not provide any usual overloaded operators, instead it provides an implementation for &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;. In this example the &lt;code&gt;nomethod&lt;/code&gt; subroutine returns an object which encapsulates operations done over the objects: &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['n', 3]&lt;/code&gt; , &lt;code&gt;2 +
symbolic-&amp;gt;new(3)&lt;/code&gt; contains &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; .</source>
          <target state="translated">随着重载模块的发展，该模块非常不寻常：它不提供任何常用的重载运算符，而是提供了&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;的实现。在此示例中， &lt;code&gt;nomethod&lt;/code&gt; 子例程返回一个对象，该对象封装了对对象执行的操作： &lt;code&gt;symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['n', 3]&lt;/code&gt; ， &lt;code&gt;2 + symbolic-&amp;gt;new(3)&lt;/code&gt; 包含 &lt;code&gt;['+', 2, ['n', 3]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4c8914133b0b2bfc077d6c38150d307c0367148" translate="yes" xml:space="preserve">
          <source>This module looks for several environment variables, including REQUEST_METHOD, HTTP_ACCEPT_LANGUAGE, LANGUAGE, LC_ALL, LC_MESSAGES, and LANG.</source>
          <target state="translated">这个模块寻找几个环境变量,包括REQUEST_METHOD、HTTP_ACCEPT_LANGUAGE、LANGUAGE、LC_ALL、LC_MESSAGES和LANG。</target>
        </trans-unit>
        <trans-unit id="0ac738d7d9941c37feb5165dcbb5c6ab9416052c" translate="yes" xml:space="preserve">
          <source>This module may change to use a different pod-to-nroff formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">这个模块将来可能会改变使用不同的pod-to-nroffformatter类,这可能会改变支持的选项。</target>
        </trans-unit>
        <trans-unit id="76f27fbed99d6c60d342c39616884795be44e886" translate="yes" xml:space="preserve">
          <source>This module may change to use a different text formatter class in the future, and this may change what options are supported.</source>
          <target state="translated">这个模块将来可能会改变使用不同的文本格式化类,这可能会改变支持的选项。</target>
        </trans-unit>
        <trans-unit id="94ae7d6ead04954a6412192772bd33bb7b8d4073" translate="yes" xml:space="preserve">
          <source>This module mediates between some version that perl sees in a package and the version that is published by the CPAN indexer.</source>
          <target state="translated">这个模块介于perl在软件包中看到的一些版本和CPAN索引器发布的版本之间。</target>
        </trans-unit>
        <trans-unit id="c80cea19736436ea3f987c3515d4cecb255844b4" translate="yes" xml:space="preserve">
          <source>This module needs Compress::Zlib.</source>
          <target state="translated">这个模块需要 Compress::Zlib。</target>
        </trans-unit>
        <trans-unit id="a8a13e816f80341d5aa494b1b85b44f3bab37b43" translate="yes" xml:space="preserve">
          <source>This module needs Perl5.005 or better.</source>
          <target state="translated">该模块需要Perl5.005或更高版本。</target>
        </trans-unit>
        <trans-unit id="2b02becbf011b5e3018f1c6556299552bd0354bc" translate="yes" xml:space="preserve">
          <source>This module needs the Encode module.</source>
          <target state="translated">这个模块需要Encode模块。</target>
        </trans-unit>
        <trans-unit id="9ccf2db8e0457ff61f46dc8eef8b595c0400ca84" translate="yes" xml:space="preserve">
          <source>This module needs to have been built with zlib 1.2.1 or better to work. A fatal error will be thrown if &lt;code&gt;Merge&lt;/code&gt; is used with an older version of zlib.</source>
          <target state="translated">必须使用zlib 1.2.1或更高版本构建此模块才能使用。如果将 &lt;code&gt;Merge&lt;/code&gt; 与较早版本的zlib一起使用，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="7cdcfb5298a84fa590094f08e92147e6cb58d161" translate="yes" xml:space="preserve">
          <source>This module offers a single utility function, &lt;code&gt;findsym()&lt;/code&gt; .</source>
          <target state="translated">该模块提供单个实用程序函数 &lt;code&gt;findsym()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd94e0e36732e7bf036abc385f751fb424ec5ec9" translate="yes" xml:space="preserve">
          <source>This module only provides a single function, parselink(), which takes the text of an L&amp;lt;&amp;gt; formatting code and parses it. It returns the anchor text for the link (if any was given), the anchor text possibly inferred from the name and section, the name or URL, the section if any, and the type of link. The type will be one of &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;pod&lt;/code&gt; , or &lt;code&gt;man&lt;/code&gt; , indicating a URL, a link to a POD page, or a link to a Unix manual page.</source>
          <target state="translated">该模块仅提供一个函数parselink（），该函数接受L &amp;lt;&amp;gt;格式代码的文本并进行解析。它返回链接的锚文本（如果给出了锚文本），可能从名称和节，名称或URL，节（如果有）以及链接类型推断出的锚文本。类型将是 &lt;code&gt;url&lt;/code&gt; ， &lt;code&gt;pod&lt;/code&gt; 或 &lt;code&gt;man&lt;/code&gt; 之一，指示URL，指向POD页面的链接或指向Unix手册页面的链接。</target>
        </trans-unit>
        <trans-unit id="3d4bf504a913c2345fd7fde3fd0264ab90a67f31" translate="yes" xml:space="preserve">
          <source>This module overloads two operators, stringify (&quot;&quot;) and numify (0+).</source>
          <target state="translated">这个模块重载了两个操作符,stringify(&quot;&quot;)和numify(0+)。</target>
        </trans-unit>
        <trans-unit id="d52e08497f6544c9fedb6034ea4aa6706f4c4317" translate="yes" xml:space="preserve">
          <source>This module predefines the methods below:</source>
          <target state="translated">本模块预先定义了以下方法。</target>
        </trans-unit>
        <trans-unit id="af4cffa0841bdd7591fb2ce3aa6ee9b4fc1581e2" translate="yes" xml:space="preserve">
          <source>This module presumes that all packages on CPAN</source>
          <target state="translated">本模块假定CPAN上的所有包都是</target>
        </trans-unit>
        <trans-unit id="50019593ee938407217545d40776fee521fc69e2" translate="yes" xml:space="preserve">
          <source>This module prints the contents of the parse tree, but without as much information as &lt;a href=&quot;debug&quot;&gt;B::Debug&lt;/a&gt;. For comparison, &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; produced 96 lines of output from B::Debug, but only 6 from B::Terse.</source>
          <target state="translated">这个模块输出解析树的内容，但是没有&lt;a href=&quot;debug&quot;&gt;B :: Debug的信息&lt;/a&gt;。为了进行比较，请 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; &quot;Hello, world.&quot;&lt;/code&gt; 从B :: Debug产生了96行输出，但从B :: Terse仅产生了6行。</target>
        </trans-unit>
        <trans-unit id="478ba76e6bcddb62163ef813460ff3c7881b3c2c" translate="yes" xml:space="preserve">
          <source>This module provide 3 convenience functions to calculate the digest of files. The following functions are provided:</source>
          <target state="translated">本模块提供3个方便的函数来计算文件的摘要。提供了以下功能。</target>
        </trans-unit>
        <trans-unit id="b0083752d49808e75aaa209a550d644242bd0980" translate="yes" xml:space="preserve">
          <source>This module provide a convenient way to create directories of arbitrary depth and to delete an entire directory subtree from the filesystem.</source>
          <target state="translated">该模块提供了一种方便的方法来创建任意深度的目录,并从文件系统中删除整个目录子树。</target>
        </trans-unit>
        <trans-unit id="b6054fa3fccb1f634d2e293413bd446f27771c13" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of bzip2 files/buffers.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="729eaec16403ec99e135cb527b2c362360b4f51e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1950.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1950的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="003753405c286c7fe622e166edd07fb3084e88a1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1951.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1951的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="450a22809e6b641290e567e29533943a53385d76" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that conform to RFC 1952.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取符合RFC 1952的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="84795f8eb8a320fda32e6f1d9e107bd19023949a" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed in a number of formats that use the zlib compression library.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取使用zlib压缩库的各种格式的压缩文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="8e71e73c8ba4d3b122b4773810a5bebea41be94e" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of files/buffers that have been compressed with a variety of compression libraries.</source>
          <target state="translated">这个模块提供了一个Perl接口,允许读取用各种压缩库压缩过的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="2c4e9ced7b139b449826926366ef08ab126e2617" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows the reading of zlib files/buffers.</source>
          <target state="translated">该模块提供了一个Perl接口,允许读取zlib文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="bb765e95103323750609fe94be953d11119327d1" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing bzip2 compressed data to files or buffer.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将bzip2压缩数据写入文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="f21907b6980e5b1e79e7f9b10f3d5f2a64818f33" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1950.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1950中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="da5ecc8ed3afbcb78fee4753b59d94b3fd278392" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1951.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1951中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="4dad75c362e8d8f7864bd95ffad74f285ca796dd" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing compressed data to files or buffer as defined in RFC 1952.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将压缩数据写入RFC 1952中定义的文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="776878df4a774de7ed832c7c095295fe08ea92ae" translate="yes" xml:space="preserve">
          <source>This module provides a Perl interface that allows writing zip compressed data to files or buffer.</source>
          <target state="translated">该模块提供了一个Perl接口,允许将zip压缩数据写入文件或缓冲区。</target>
        </trans-unit>
        <trans-unit id="122a388521f8308fb94e1159722c14bed6d323e8" translate="yes" xml:space="preserve">
          <source>This module provides a function &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; that takes a language tag (see &lt;a href=&quot;../langtags&quot;&gt;I18N::LangTags&lt;/a&gt;) and returns the best attempt at an English name for it, or undef if it can't make sense of the tag.</source>
          <target state="translated">该模块提供了一个函数 &lt;code&gt;I18N::LangTags::List::name( &lt;i&gt;langtag&lt;/i&gt; ) &lt;/code&gt; ，该函数带有一个语言标记（请参见&lt;a href=&quot;../langtags&quot;&gt;I18N :: LangTags&lt;/a&gt;），并以英语名称返回最佳尝试，如果不能，则返回undef标签的意义。</target>
        </trans-unit>
        <trans-unit id="96823924a180df110252f785d7a14a45c7a178c6" translate="yes" xml:space="preserve">
          <source>This module provides a variety of constants, structure manipulators and other functions related to socket-based networking. The values and functions provided are useful when used in conjunction with Perl core functions such as socket(), setsockopt() and bind(). It also provides several other support functions, mostly for dealing with conversions of network addresses between human-readable and native binary forms, and for hostname resolver operations.</source>
          <target state="translated">这个模块提供了各种常量、结构操纵器和其他与基于socket的网络有关的函数。所提供的值和函数在与socket()、setockopt()和bind()等Perl核心函数结合使用时非常有用。它还提供了其他一些支持函数,主要用于处理网络地址在人可读和本地二进制形式之间的转换,以及用于主机名解析器操作。</target>
        </trans-unit>
        <trans-unit id="c14c6338e762c52ff6d582916956b99716820151" translate="yes" xml:space="preserve">
          <source>This module provides aliases for the built-in variables whose names no one seems to like to read. Variables with side-effects which get triggered just by accessing them (like $0) will still be affected.</source>
          <target state="translated">这个模块为内置变量提供了别名,这些变量的名字似乎没有人喜欢读。有副作用的变量,只要访问它们就会被触发(比如$0),它们仍然会受到影响。</target>
        </trans-unit>
        <trans-unit id="db82fd21a4c838f2cb867e238f620528a9b4e06a" translate="yes" xml:space="preserve">
          <source>This module provides an interface that allows filters to be applied to tied Hashes associated with DBM files. It builds on the DBM Filter hooks that are present in all the *DB*_File modules included with the standard Perl source distribution from version 5.6.1 onwards. In addition to the *DB*_File modules distributed with Perl, the BerkeleyDB module, available on CPAN, supports the DBM Filter hooks. See &lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt; for more details on the DBM Filter hooks.</source>
          <target state="translated">该模块提供了一个接口，该接口允许将过滤器应用于与DBM文件关联的绑定哈希。它建立在DBM筛选器挂钩上，该挂钩存在于从5.6.1版开始的标准Perl源代码发行版随附的所有* DB * _File模块中。除了与Perl一起发行的* DB * _File模块外，CPAN上可用的BerkeleyDB模块还支持DBM过滤器挂钩。有关DBM筛选器挂钩的更多详细信息，请参见&lt;a href=&quot;perldbmfilter&quot;&gt;perldbmfilter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5d483b4b377e197aedecfe9fa15f04f3c6c2c95" translate="yes" xml:space="preserve">
          <source>This module provides functions for determining the pathname of the current working directory. It is recommended that getcwd (or another *cwd() function) be used in</source>
          <target state="translated">本模块提供了确定当前工作目录路径名的函数,建议在工作中使用getcwd(或其他*cwd()函数)。建议在本模块中使用getcwd(或其他*cwd()函数)。</target>
        </trans-unit>
        <trans-unit id="37033effa06ce25f227ce23dc6a9e45e7efa61d9" translate="yes" xml:space="preserve">
          <source>This module provides functions that are the inverse of built-in perl functions &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. They accept a date as a six-element array, and return the corresponding &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; value in seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix, for example). This value can be positive or negative, though POSIX only requires support for positive values, so dates before the system's epoch may not work on all operating systems.</source>
          <target state="translated">该模块提供的功能与内置的perl函数 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 相反。它们接受日期作为六元素数组，并返回自系统纪元（例如，Unix上的GMT，1970年1月1日，午夜 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time(2)&lt;/a&gt;&lt;/code&gt; 以来的相应time（2）值（以秒为单位）。尽管POSIX仅要求支持正值，但该值可以是正值或负值，因此系统纪元之前的日期可能不适用于所有操作系统。</target>
        </trans-unit>
        <trans-unit id="d1ece64b49e28f99121f72eab284aec43cb55951" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the base64 encoding specified in RFC 2045 -</source>
          <target state="translated">这个模块提供了将字符串编码和解码为RFC 2045------------------------------------------------的base64编码的功能。</target>
        </trans-unit>
        <trans-unit id="990d143d4bc42dc7eed0bcd6394bda54ff57474f" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode and decode strings into and from the quoted-printable encoding specified in RFC 2045 -</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4de2f96f0939e0587055f3524c8f314354960c" translate="yes" xml:space="preserve">
          <source>This module provides methods for array-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie an array to a package. The basic &lt;b&gt;Tie::Array&lt;/b&gt; package provides stub &lt;code&gt;DESTROY&lt;/code&gt; , and &lt;code&gt;EXTEND&lt;/code&gt; methods that do nothing, stub &lt;code&gt;DELETE&lt;/code&gt; and &lt;code&gt;EXISTS&lt;/code&gt; methods that croak() if the delete() or exists() builtins are ever called on the tied array, and implementations of &lt;code&gt;PUSH&lt;/code&gt; , &lt;code&gt;POP&lt;/code&gt; , &lt;code&gt;SHIFT&lt;/code&gt; , &lt;code&gt;UNSHIFT&lt;/code&gt; , &lt;code&gt;SPLICE&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; in terms of basic &lt;code&gt;FETCH&lt;/code&gt; , &lt;code&gt;STORE&lt;/code&gt; , &lt;code&gt;FETCHSIZE&lt;/code&gt; , &lt;code&gt;STORESIZE&lt;/code&gt; .</source>
          <target state="translated">该模块提供了用于数组绑定类的方法。有关将数组绑定到包所需的功能列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本&lt;b&gt;领带::阵列&lt;/b&gt;封装提供存根 &lt;code&gt;DESTROY&lt;/code&gt; 和 &lt;code&gt;EXTEND&lt;/code&gt; 什么也不做，存根方法 &lt;code&gt;DELETE&lt;/code&gt; 和 &lt;code&gt;EXISTS&lt;/code&gt; 的方法是呱呱叫（）如果删除（）或存在（）内建曾经被称为绑阵列上，并且实现 &lt;code&gt;PUSH&lt;/code&gt; ， &lt;code&gt;POP&lt;/code&gt; ， &lt;code&gt;SHIFT&lt;/code&gt; ， &lt;code&gt;UNSHIFT&lt;/code&gt; ， &lt;code&gt;SPLICE&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 在基本 &lt;code&gt;FETCH&lt;/code&gt; ， &lt;code&gt;STORE&lt;/code&gt; ， &lt;code&gt;FETCHSIZE&lt;/code&gt; 方面， &lt;code&gt;STORESIZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a02a6b6db2368ef791da2effa9e60fac9461270d" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for handle-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a handle to a package. The basic &lt;b&gt;Tie::Handle&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHANDLE&lt;/code&gt; , &lt;code&gt;PRINT&lt;/code&gt; , &lt;code&gt;PRINTF&lt;/code&gt; and &lt;code&gt;GETC&lt;/code&gt; .</source>
          <target state="translated">该模块为句柄绑定类提供了一些骨架方法。有关将句柄绑定到包所需的功能列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Handle&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHANDLE&lt;/code&gt; ， &lt;code&gt;PRINT&lt;/code&gt; ， &lt;code&gt;PRINTF&lt;/code&gt; 和 &lt;code&gt;GETC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1739e1ebdefff1631d8440f9ca833c6b68c52a" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for hash-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in order to tie a hash to a package. The basic &lt;b&gt;Tie::Hash&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIEHASH&lt;/code&gt; , &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;CLEAR&lt;/code&gt; . The &lt;b&gt;Tie::StdHash&lt;/b&gt; and &lt;b&gt;Tie::ExtraHash&lt;/b&gt; packages provide most methods for hashes described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). They cause tied hashes to behave exactly like standard hashes, and allow for selective overwriting of methods. &lt;b&gt;Tie::Hash&lt;/b&gt; grandfathers the &lt;code&gt;new&lt;/code&gt; method: it is used if &lt;code&gt;TIEHASH&lt;/code&gt; is not defined in the case a class forgets to include a &lt;code&gt;TIEHASH&lt;/code&gt; method.</source>
          <target state="translated">该模块提供了一些用于哈希绑定类的骨架方法。请参阅&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;，以获取将散列绑定到程序包所需的功能列表。基本的&lt;b&gt;Tie :: Hash&lt;/b&gt;包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIEHASH&lt;/code&gt; ， &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;CLEAR&lt;/code&gt; 。该&lt;b&gt;帖:: StdHash&lt;/b&gt;和&lt;b&gt;领带:: ExtraHash&lt;/b&gt;包提供用于描述哈希大多数方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;（例外是 &lt;code&gt;UNTIE&lt;/code&gt; 和 &lt;code&gt;DESTROY&lt;/code&gt; ）。它们导致绑定哈希的行为与标准哈希完全相同，并允许方法的选择性覆盖。&lt;b&gt;领带::哈希&lt;/b&gt;祖父 &lt;code&gt;new&lt;/code&gt; 方法：如果 &lt;code&gt;TIEHASH&lt;/code&gt; 未包含 &lt;code&gt;TIEHASH&lt;/code&gt; 方法的情况下未定义TIEHASH，则使用此方法。</target>
        </trans-unit>
        <trans-unit id="4010b9458f00ef557ee377f021a5154f08e74c91" translate="yes" xml:space="preserve">
          <source>This module provides some skeletal methods for scalar-tying classes. See &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; for a list of the functions required in tying a scalar to a package. The basic &lt;b&gt;Tie::Scalar&lt;/b&gt; package provides a &lt;code&gt;new&lt;/code&gt; method, as well as methods &lt;code&gt;TIESCALAR&lt;/code&gt; , &lt;code&gt;FETCH&lt;/code&gt; and &lt;code&gt;STORE&lt;/code&gt; . The &lt;b&gt;Tie::StdScalar&lt;/b&gt; package provides all the methods specified in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;. It inherits from &lt;b&gt;Tie::Scalar&lt;/b&gt; and causes scalars tied to it to behave exactly like the built-in scalars, allowing for selective overloading of methods. The &lt;code&gt;new&lt;/code&gt; method is provided as a means of grandfathering, for classes that forget to provide their own &lt;code&gt;TIESCALAR&lt;/code&gt; method.</source>
          <target state="translated">该模块为标量绑定类提供了一些骨架方法。有关将标量与包绑定所需的功能的列表，请参见&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。基本的&lt;b&gt;Tie :: Scalar&lt;/b&gt;软件包提供了一种 &lt;code&gt;new&lt;/code&gt; 方法，以及方法 &lt;code&gt;TIESCALAR&lt;/code&gt; ， &lt;code&gt;FETCH&lt;/code&gt; 和 &lt;code&gt;STORE&lt;/code&gt; 。该&lt;b&gt;帖:: StdScalar&lt;/b&gt;包提供了全部规定的方法&lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;。它继承自&lt;b&gt;Tie :: Scalar&lt;/b&gt;并导致与其绑定的标量的行为与内置标量完全相同，从而允许方法的选择性重载。该 &lt;code&gt;new&lt;/code&gt; 方法作为祖父的一种手段，对于忘记提供自己的类 &lt;code&gt;TIESCALAR&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="45a6ced9686dd2822231048fa2c17a6218884f07" translate="yes" xml:space="preserve">
          <source>This module provides the ability to use references as hash keys if you first &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; the hash variable to this module. Normally, only the keys of the tied hash itself are preserved as references; to use references as keys in hashes-of-hashes, use Tie::RefHash::Nestable, included as part of Tie::RefHash.</source>
          <target state="translated">如果您首先 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 哈希变量绑定到此模块，则此模块提供了将引用用作哈希键的功能。通常，只有绑定哈希表本身的键才保留为引用。要将引用用作哈希表中的键，请使用Tie :: RefHash :: Nestable（包含在Tie :: RefHash中）。</target>
        </trans-unit>
        <trans-unit id="ebae6f4a623ce67e5227c5968ced52d6ec8a379b" translate="yes" xml:space="preserve">
          <source>This module provides things that are useful in decoding Pod E&amp;lt;...&amp;gt; sequences. Presumably, it should be used only by Pod parsers and/or formatters.</source>
          <target state="translated">该模块提供了在解码Pod E &amp;lt;...&amp;gt;序列时有用的功能。据推测，它只能由Pod解析器和/或格式化程序使用。</target>
        </trans-unit>
        <trans-unit id="0b9bdfe8079862de56a9be28719c20253e80c566" translate="yes" xml:space="preserve">
          <source>This module provides thread-safe FIFO queues that can be accessed safely by any number of threads.</source>
          <target state="translated">该模块提供了线程安全的FIFO队列,可以被任何数量的线程安全访问。</target>
        </trans-unit>
        <trans-unit id="c893e4865fad5c4ebef15f59be14ed58305bf748" translate="yes" xml:space="preserve">
          <source>This module provides you with objects that will collate according to your national character set, provided that the POSIX setlocale() function is supported on your system.</source>
          <target state="translated">这个模块为你提供了根据你的国家字符集整理的对象,只要你的系统支持POSIX setlocale()函数。</target>
        </trans-unit>
        <trans-unit id="3c80ba9c5ba8104333b035c434045b2d217f883f" translate="yes" xml:space="preserve">
          <source>This module provides you with the framework to write</source>
          <target state="translated">本模块为您提供了一个框架来编写</target>
        </trans-unit>
        <trans-unit id="a42cca3ae2e3ec2aed33868679dacb4f08255f28" translate="yes" xml:space="preserve">
          <source>This module replaces the standard &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; functions with implementations that return objects. It does so in a backwards compatible manner, so that using localtime/gmtime in the way documented in perlfunc will still return what you expect.</source>
          <target state="translated">该模块用返回对象的实现替换了标准的 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 函数。它以向后兼容的方式进行操作，因此以perlfunc中记录的方式使用localtime / gmtime仍会返回您期望的结果。</target>
        </trans-unit>
        <trans-unit id="a5bdc953dcd00c8d1fe5956d84a4a3e6df9745fe" translate="yes" xml:space="preserve">
          <source>This module should implement a method named &lt;code&gt;new&lt;/code&gt; that returns an object with two methods: &lt;code&gt;IN&lt;/code&gt; and &lt;code&gt;OUT&lt;/code&gt; . These should return filehandles to use for debugging input and output correspondingly. The &lt;code&gt;new&lt;/code&gt; method should inspect an argument containing the value of &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; at startup, or &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; otherwise. This file is not inspected for proper ownership, so security hazards are theoretically possible.</source>
          <target state="translated">该模块应实现一个名为 &lt;code&gt;new&lt;/code&gt; 的方法，该方法使用两种方法返回对象： &lt;code&gt;IN&lt;/code&gt; 和 &lt;code&gt;OUT&lt;/code&gt; 。这些应返回文件句柄以用于相应地调试输入和输出。该 &lt;code&gt;new&lt;/code&gt; 方法应该检查包含的值的参数 &lt;code&gt;$ENV{PERLDB_NOTTY}&lt;/code&gt; 在启动时，或 &lt;code&gt;&quot;$ENV{HOME}/.perldbtty$$&quot;&lt;/code&gt; 否则。不会检查此文件的所有权，因此从理论上讲可能存在安全隐患。</target>
        </trans-unit>
        <trans-unit id="6a41ba09a40a54e49a9ee3baae88659ee7ff44a3" translate="yes" xml:space="preserve">
          <source>This module simplifies the task of writing test files for Perl modules, such that their output is in the format that &lt;a href=&quot;test/harness&quot;&gt;Test::Harness&lt;/a&gt; expects to see.</source>
          <target state="translated">该模块简化了为Perl模块编写测试文件的任务，从而使它们的输出采用&lt;a href=&quot;test/harness&quot;&gt;Test :: Harness&lt;/a&gt;期望的格式。</target>
        </trans-unit>
        <trans-unit id="11c0f42159d2cd738d87f4668e591361666ef5d1" translate="yes" xml:space="preserve">
          <source>This module supplies line breaking conformant with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX#14 Unicode Line Breaking Algorithm&lt;/a&gt;.</source>
          <target state="translated">该模块提供符合&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr14&quot;&gt;UAX＃14 Unicode&lt;/a&gt;换行算法的换行。</target>
        </trans-unit>
        <trans-unit id="7362dd1991fb64d8e60d1766b453419474c1d7a8" translate="yes" xml:space="preserve">
          <source>This module supports dual-valued variables created using &lt;code&gt;dualvar()&lt;/code&gt; from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;. However, while &lt;code&gt;$!&lt;/code&gt; acts like a dualvar, it is implemented as a tied SV. To propagate its value, use the follow construct, if needed:</source>
          <target state="translated">该模块支持使用创建的双值变量 &lt;code&gt;dualvar()&lt;/code&gt; 从&lt;a href=&quot;../scalar/util&quot;&gt;标量::的Util&lt;/a&gt;。但是，虽然 &lt;code&gt;$!&lt;/code&gt; 就像doublevar一样，它实现为绑定的SV。要传播其值，请根据需要使用以下构造：</target>
        </trans-unit>
        <trans-unit id="4a9a2cc7b64dab0e46b52256bb4b3682e797fe2a" translate="yes" xml:space="preserve">
          <source>This module supports the sharing of the following data types only: scalars and scalar refs, arrays and array refs, and hashes and hash refs.</source>
          <target state="translated">该模块仅支持以下数据类型的共享:标量和标量参考,数组和数组参考,以及哈希和哈希参考。</target>
        </trans-unit>
        <trans-unit id="a0c98feb7e76c5e1cd4d46ac2f59afc0263d11ba" translate="yes" xml:space="preserve">
          <source>This module takes the existing &lt;code&gt;File::Glob&lt;/code&gt; module as a starting point and extends it to allow new filenames to be derived from the files matched by &lt;code&gt;File::Glob&lt;/code&gt; .</source>
          <target state="translated">该模块以现有的 &lt;code&gt;File::Glob&lt;/code&gt; 模块为起点，并将其扩展为允许从 &lt;code&gt;File::Glob&lt;/code&gt; 匹配的文件中派生新的文件名。</target>
        </trans-unit>
        <trans-unit id="a954cd9e0b1a91ff11e964474367fdd384bdca9c" translate="yes" xml:space="preserve">
          <source>This module tells its users that functions in the FOOBAR package are to be autoloaded from after the &lt;code&gt;__DATA__&lt;/code&gt; token. See also &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt;.</source>
          <target state="translated">该模块告诉其用户FOOBAR软件包中的功能将从 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后自动加载。另请参见&lt;a href=&quot;perlsub#Autoloading&quot;&gt;perlsub中的自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="939a336b2bb3143f369fbb6ba3a4974db4ff7afa" translate="yes" xml:space="preserve">
          <source>This module uses POSIX::setlocale(). The basic collation conversion is done by strxfrm() which terminates at NUL characters being a decent C routine. collate_xfrm() handles embedded NUL characters gracefully.</source>
          <target state="translated">这个模块使用POSIX::setlocale()。collate_xfrm()优雅地处理了嵌入的NUL字符。</target>
        </trans-unit>
        <trans-unit id="3d7e780fb3434a21970906d8c1e16da4e1e4c306" translate="yes" xml:space="preserve">
          <source>This module uses Term::Cap to retrieve the formatting escape sequences for the current terminal, and falls back on the ECMA-48 (the same in this regard as ANSI X3.64 and ISO 6429, the escape codes also used by DEC VT100 terminals) if the bold, underline, and reset codes aren't set in the termcap information.</source>
          <target state="translated">该模块使用 Term::Cap 来检索当前终端的格式化转义序列,如果在 termcap 信息中没有设置粗体、下划线和复位代码,则回落到 ECMA-48(在这方面与 ANSI X3.64 和 ISO 6429 相同,DEC VT100 终端也使用这些转义代码)。</target>
        </trans-unit>
        <trans-unit id="058e434497d0f41de20212a7e71136f58de19c26" translate="yes" xml:space="preserve">
          <source>This module uses the Encode module.</source>
          <target state="translated">本模块使用Encode模块。</target>
        </trans-unit>
        <trans-unit id="f4b71953fa4633537c604ac518e043ed458e0579" translate="yes" xml:space="preserve">
          <source>This module was conceived while talking with Tony Bowden in his kitchen one night about the problems I was having writing some really complicated feature into the new Testing module. He observed that the main problem is not dealing with these edge cases but that people hate to write tests &lt;b&gt;at all&lt;/b&gt;. What was needed was a dead simple module that took all the hard work out of testing and was really, really easy to learn. Paul Johnson simultaneously had this idea (unfortunately, he wasn't in Tony's kitchen). This is it.</source>
          <target state="translated">这个模块是在晚上与Tony Bowden在他的厨房里谈论有关我正在向新的Testing模块中编写一些非常复杂的功能的问题时构思的。他观察到，主要问题不是处理这些极端情况，而是人们&lt;b&gt;根本&lt;/b&gt;不愿意编写测试。所需要的是一个简单而又简单的模块，它消除了测试中的所有辛苦工作，并且非常容易上手。保罗&amp;middot;约翰逊与此同时想到了这个（不幸的是，他不在托尼的厨房里）。就是这个。</target>
        </trans-unit>
        <trans-unit id="44e053a287d50cc7ccc07846fa0cd204c00c77bf" translate="yes" xml:space="preserve">
          <source>This module was forked from &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; to remove the cruft that had accumulated in it.</source>
          <target state="translated">该模块是从&lt;a href=&quot;base&quot;&gt;基座&lt;/a&gt;上分叉的，以除去积累在其中的碎屑。</target>
        </trans-unit>
        <trans-unit id="415f859ceb0027d691de683de60a6caa41bf897e" translate="yes" xml:space="preserve">
          <source>This module was introduced with Perl 5.004_04.</source>
          <target state="translated">这个模块是在Perl 5.004_04中引入的。</target>
        </trans-unit>
        <trans-unit id="d78d05cb96bc7dd60c1272000024e5786c3b344f" translate="yes" xml:space="preserve">
          <source>This module was originally maintained in Perl core by the Perl 5 Porters.</source>
          <target state="translated">这个模块最初是由Perl 5 Porters在Perl核心中维护的。</target>
        </trans-unit>
        <trans-unit id="d496390246382aaea7191d7bd504a81ceae75b9b" translate="yes" xml:space="preserve">
          <source>This module was written by Paul Marquess,</source>
          <target state="translated">本模块由Paul Marquess编写。</target>
        </trans-unit>
        <trans-unit id="db6bc597ca48fae1b90746fab4916cd0188777f9" translate="yes" xml:space="preserve">
          <source>This module will arrange for the following methods to be available via the object returned from the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">该模块将安排以下方法，这些方法可以通过 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用返回的对象使用。</target>
        </trans-unit>
        <trans-unit id="2764651445501a5ce090459b163069724d513467" translate="yes" xml:space="preserve">
          <source>This module will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">该模块将确保所有写入DBM的数据都以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="d4e571c7af10e51826ae47ab8231a6af4b7edd1a" translate="yes" xml:space="preserve">
          <source>This module will have no effect unless Term::ANSIColor is installed.</source>
          <target state="translated">除非安装了Term::ANSIColor,否则该模块不会有任何效果。</target>
        </trans-unit>
        <trans-unit id="bc002eb3536b764cc0a1a4a051dbfbb6d0617a7a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getgrent(), getgruid(), and getgrnam() functions, replacing them with versions that return &quot;User::grent&quot; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的getgrent()、getgruid()和getgrnam()函数,用返回 &quot;User::grent &quot;对象的版本代替。这个对象有一些方法,从C的passwd结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1581c51cdf9361d52e5059029b51bf081eb34a2a" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gethostbyname() and gethostbyaddr() functions, replacing them with versions that return &quot;Net::hostent&quot; objects. This object has methods that return the similarly named structure field name from the C's hostent structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的gethostbyname()和gethostbyaddr()函数,用返回 &quot;Net::hostent &quot;对象的版本代替。这个对象的方法是从C的hostent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1cf48308305a0353920dde6f36f9628e64db01d0" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getnetbyname() and getnetbyaddr() functions, replacing them with versions that return &quot;Net::netent&quot; objects. This object has methods that return the similarly named structure field name from the C's netent structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的getnetbyname()和getnetbyaddr()函数,用返回 &quot;Net::netent &quot;对象的版本代替。这个对象的方法可以从C的netent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="63eeed3630a3c131f9be311caba9fa2bc27d9b47" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getprotoent(), getprotobyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::protoent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's protoent structure from</source>
          <target state="translated">这个模块的默认输出覆盖了核心的getprotoent()、getprotobyname()和getnetbyport()函数,用返回 &quot;Net::protoent &quot;对象的版本来代替它们。它们取默认的第二个参数为 &quot;tcp&quot;。这个对象的方法,从C的protoent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="4107e545f5b1cf8c8a8164c3254d8e830266adf1" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getpwent(), getpwuid(), and getpwnam() functions, replacing them with versions that return &lt;code&gt;User::pwent&lt;/code&gt; objects. This object has methods that return the similarly named structure field name from the C's passwd structure from</source>
          <target state="translated">该模块的默认导出覆盖了核心getpwent（），getpwuid（）和getpwnam（）函数，并用返回 &lt;code&gt;User::pwent&lt;/code&gt; 对象的版本替换了它们。该对象具有从C的passwd结构返回类似名称的结构字段名称的方法，</target>
        </trans-unit>
        <trans-unit id="10fb02d2375c44b6670d64106c1e02dfe50c1c6b" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core getservent(), getservbyname(), and getnetbyport() functions, replacing them with versions that return &quot;Net::servent&quot; objects. They take default second arguments of &quot;tcp&quot;. This object has methods that return the similarly named structure field name from the C's servent structure from</source>
          <target state="translated">这个模块的默认输出覆盖了核心的getervent()、getervbyname()和getnetbyport()函数,用返回 &quot;Net::servent &quot;对象的版本来代替它们。它们取默认的第二个参数为 &quot;tcp&quot;。这个对象的方法从C的servent结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="7599d7934dafe0542e5b1a0c799f665df33f32e3" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core gmtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的gmtime()函数,用一个返回 &quot;Time::tm &quot;对象的版本代替。这个对象有一些方法,可以从C的tm结构中返回类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="1c7368710f29f58e692e516e823ad1d056f89a07" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core localtime() function, replacing it with a version that returns &quot;Time::tm&quot; objects. This object has methods that return the similarly named structure field name from the C's tm structure from</source>
          <target state="translated">这个模块的默认导出覆盖了核心的localtime()函数,用一个返回 &quot;Time::tm &quot;对象的版本代替。这个对象有一些方法可以返回C的tm结构中的类似名称的结构字段名,从</target>
        </trans-unit>
        <trans-unit id="d73f3c14e45154d8cf626f7be1ef9892237475eb" translate="yes" xml:space="preserve">
          <source>This module's default exports override the core stat() and lstat() functions, replacing them with versions that return &quot;File::stat&quot; objects. This object has methods that return the similarly named structure field name from the stat(2) function; namely, dev, ino, mode, nlink, uid, gid, rdev, size, atime, mtime, ctime, blksize, and blocks.</source>
          <target state="translated">这个模块的默认导出覆盖了核心的 stat()和 lstat()函数,用返回 &quot;File::stat &quot;对象的版本代替。这个对象有从 stat(2)函数中返回类似名称的结构字段名的方法;即dev、ino、mode、nlink、uid、gid、rdev、size、atime、mtime、ctime、blksize和block。</target>
        </trans-unit>
        <trans-unit id="cd05da270956b31cc43582962e51390407dca252" translate="yes" xml:space="preserve">
          <source>This module, when inherited by a package, allows that package's class to define attribute handler subroutines for specific attributes. Variables and subroutines subsequently defined in that package, or in packages derived from that package may be given attributes with the same names as the attribute handler subroutines, which will then be called in one of the compilation phases (i.e. in a &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; block). (&lt;code&gt;UNITCHECK&lt;/code&gt; blocks don't correspond to a global compilation phase, so they can't be specified here.)</source>
          <target state="translated">该模块在被包继承时，允许该包的类为特定属性定义属性处理程序子例程。随后在该程序包中或从该程序包派生的程序包中定义的变量和子例程可以被赋予与属性处理程序子例程相同名称的属性，然后将在编译阶段之一（即，在 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 中)进行调用。，或 &lt;code&gt;END&lt;/code&gt; 块）。 （ &lt;code&gt;UNITCHECK&lt;/code&gt; 块不对应于全局编译阶段，因此无法在此处指定。）</target>
        </trans-unit>
        <trans-unit id="d4b82d477760eacd25bf3c70a5e788527be511b5" translate="yes" xml:space="preserve">
          <source>This modules handles the BOM as follows.</source>
          <target state="translated">该模块处理BOM的方法如下。</target>
        </trans-unit>
        <trans-unit id="3973d4b3df1b4f6e4e1a4578c3854df16aa9cfcc" translate="yes" xml:space="preserve">
          <source>This name should be as descriptive, accurate, and complete as possible. Avoid any risk of ambiguity. Always try to use two or more whole words. Generally the name should reflect what is special about what the module does rather than how it does it. Please use nested module names to group informally or categorize a module. There should be a very good reason for a module not to have a nested name. Module names should begin with a capital letter.</source>
          <target state="translated">这个名称应尽可能地描述性、准确性和完整性。避免任何含糊不清的风险。尽量使用两个或两个以上的整数词。一般来说,名称应该反映出该模块的特殊之处,而不是它是如何做的。请使用嵌套的模块名称来对模块进行非正式的分组或分类。一个模块不使用嵌套的名称应该有一个很好的理由。模块名称应该以大写字母开头。</target>
        </trans-unit>
        <trans-unit id="64f3b2bdf54de52b80ace773443b078978c32943" translate="yes" xml:space="preserve">
          <source>This newer style is consistent with the values of other Unicode properties. To preserve backward compatibility, all the functions in Unicode::UCD that return block names (except as noted) return the old-style ones. &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; returns the new-style and can be used to convert from old-style to new-style:</source>
          <target state="translated">这种较新的样式与其他Unicode属性的值一致。为了保持向后兼容性，Unicode :: UCD中所有返回块名称（除非另有说明）的函数均返回旧样式。&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;返回新样式，可用于从旧样式转换为新样式：</target>
        </trans-unit>
        <trans-unit id="00215ed790925e9c90e37af405255e37b3a2b3c0" translate="yes" xml:space="preserve">
          <source>This normalizer function will store scalar context return values in the disk file under keys that begin with &lt;code&gt;S:&lt;/code&gt; , and list context return values under keys that begin with &lt;code&gt;L:&lt;/code&gt; .</source>
          <target state="translated">此规范化函数将标量上下文返回值存储在磁盘文件中以 &lt;code&gt;S:&lt;/code&gt; 开头的键下，并列出上下文返回值在以 &lt;code&gt;L:&lt;/code&gt; 开头的键下。</target>
        </trans-unit>
        <trans-unit id="af82ed0821cc193322bac301a4efb5cd0be9cd17" translate="yes" xml:space="preserve">
          <source>This normally doesn't happen at the Perl level unless a variable is undef'ed or the last variable holding a reference to it is changed or overwritten. At the internal level, however, reference counts can be manipulated with the following macros:</source>
          <target state="translated">通常在Perl中不会发生这种情况,除非一个变量未被定义,或者最后一个持有引用的变量被改变或覆盖。然而,在内部层面上,引用计数可以通过下面的宏来操作。</target>
        </trans-unit>
        <trans-unit id="781831a4fcab5b31277395d81bbf01ada61ab8de" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_REVISION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_REVISION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="0c3631049473f76e2dd0f9b657a8b5bb99ef0ce8" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_SUBVERSION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="74feee9a515674df1fbf3fa550f4ebde2a393edc" translate="yes" xml:space="preserve">
          <source>This number describes the earliest compatible &lt;code&gt;PERL_VERSION&lt;/code&gt; of Perl (&lt;code&gt;compatibility&lt;/code&gt; here being defined as sufficient</source>
          <target state="translated">此数字描述了Perl 的最早兼容 &lt;code&gt;PERL_VERSION&lt;/code&gt; （此处将 &lt;code&gt;compatibility&lt;/code&gt; 定义为足够</target>
        </trans-unit>
        <trans-unit id="3daf144ec9102bb41c4b3e85d9d925806042ef77" translate="yes" xml:space="preserve">
          <source>This object corresponds to a tree of parsed POD text. As POD text is scanned from left to right, it is parsed into an ordered list of text-strings and &lt;b&gt;Pod::InteriorSequence&lt;/b&gt; objects (in order of appearance). A &lt;b&gt;Pod::ParseTree&lt;/b&gt; object corresponds to this list of strings and sequences. Each interior sequence in the parse-tree may itself contain a parse-tree (since interior sequences may be nested).</source>
          <target state="translated">该对象对应于已解析的POD文本树。从左向右扫描POD文本时，会将其解析为文本字符串和&lt;b&gt;Pod :: InteriorSequence&lt;/b&gt;对象（按出现顺序）的有序列表。一个&lt;b&gt;波德::分析树&lt;/b&gt;对象所对应的字符串和序列名单。解析树中的每个内部序列本身都可以包含一个解析树（因为内部序列可以嵌套）。</target>
        </trans-unit>
        <trans-unit id="c65aad4d731c650bf589bf8e7d6030572457b243" translate="yes" xml:space="preserve">
          <source>This object model leads to a tight coupling between subclasses. If one class wants to inherit from another (and both classes access object data), the classes must agree about implementation details. Inheritance can only be used among classes that are maintained together, in a single source or not.</source>
          <target state="translated">这种对象模型导致了子类之间的紧密耦合。如果一个类想从另一个类继承(并且两个类都访问对象数据),那么两个类必须就实现细节达成一致。继承只能在一起维护的类之间使用,无论是否在一个源中。</target>
        </trans-unit>
        <trans-unit id="75906e4fa98bc1c55561b974f97399cf50b738ce" translate="yes" xml:space="preserve">
          <source>This obviously matches, but in the process of matching, the subexpression &lt;code&gt;a*&lt;/code&gt; first grabbed the &lt;code&gt;a&lt;/code&gt; . Doing so, however, wouldn't allow the whole regexp to match, so after backtracking, &lt;code&gt;a*&lt;/code&gt; eventually gave back the &lt;code&gt;a&lt;/code&gt; and matched the empty string. Here, what &lt;code&gt;a*&lt;/code&gt; matched was</source>
          <target state="translated">这显然是匹配的，但是在匹配过程中，子表达式 &lt;code&gt;a*&lt;/code&gt; 首先抓取了 &lt;code&gt;a&lt;/code&gt; 。但是，这样做将不允许整个正则表达式匹配，因此在回溯之后， &lt;code&gt;a*&lt;/code&gt; 最终会返回 &lt;code&gt;a&lt;/code&gt; 并匹配空字符串。在这里， &lt;code&gt;a*&lt;/code&gt; 匹配的是</target>
        </trans-unit>
        <trans-unit id="ce31346ef13bdd3b410f6693045b75e1d727f213" translate="yes" xml:space="preserve">
          <source>This one works differently from normal strings:</source>
          <target state="translated">这个和普通的手串工作原理不同。</target>
        </trans-unit>
        <trans-unit id="8dceabe6741f9e9be624acb0758d7a05df91f7b1" translate="yes" xml:space="preserve">
          <source>This operates as above, but the &lt;code&gt;Filter&lt;/code&gt; argument with a non-zero value causes the entire script, and not just literals, to be translated from the encoding into UTF-8. This allows identifiers in the source to be in that encoding as well. (Problems may occur if the encoding is not a superset of ASCII; imagine all your semi-colons being translated into something different.) One can use this form to make</source>
          <target state="translated">此操作如上所述，但是具有非零值的 &lt;code&gt;Filter&lt;/code&gt; 参数导致整个脚本（不只是文字）从编码转换为UTF-8。这也允许源中的标识符也采用该编码。（如果编码不是ASCII的超集，则可能会出现问题；想像一下您所有的分号都被翻译成其他不同的东西了。）</target>
        </trans-unit>
        <trans-unit id="bafbb273ef65724f67929789d4cf1821d369332e" translate="yes" xml:space="preserve">
          <source>This operator changes only the modification time of the file (VMS revision date) on ODS-2 volumes and ODS-5 volumes without access dates enabled. On ODS-5 volumes with access dates enabled, the true access time is modified.</source>
          <target state="translated">该操作者只改变ODS-2卷和ODS-5卷上未启用访问日期的文件修改时间(VMS修改日期)。在启用访问日期的ODS-5卷上,真正的访问时间被修改。</target>
        </trans-unit>
        <trans-unit id="ffba20ee3390ab6f7cdbeb9ab15cfb5e9016cca0" translate="yes" xml:space="preserve">
          <source>This operator is also handy for inverting a hash, although there are some caveats. If a value is duplicated in the original hash, only one of those can be represented as a key in the inverted hash. Also, this has to unwind one hash and build a whole new one, which may take some time on a large hash, such as from a DBM file.</source>
          <target state="translated">这个运算符对于反转哈希也很方便,不过也有一些注意事项。如果一个值在原始哈希中是重复的,那么在倒置的哈希中只能用其中一个来表示。另外,这必须解开一个哈希值,并建立一个全新的哈希值,这在一个大的哈希值上可能会花费一些时间,比如从一个DBM文件中提取。</target>
        </trans-unit>
        <trans-unit id="0b8267c16c345a02931d07745eab202ccd1416fa" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;../file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">该操作符使用标准 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现。有关详细信息，请参见&lt;a href=&quot;../file/glob&quot;&gt;File :: Glob&lt;/a&gt;，包括 &lt;code&gt;bsd_glob&lt;/code&gt; ，它不将空格视为模式分隔符。</target>
        </trans-unit>
        <trans-unit id="157d8ec0928a934391402a13da061adc37466e6a" translate="yes" xml:space="preserve">
          <source>This operator is implemented using the standard &lt;code&gt;File::Glob&lt;/code&gt; extension. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for details, including &lt;code&gt;bsd_glob&lt;/code&gt; which does not treat whitespace as a pattern separator.</source>
          <target state="translated">该操作符使用标准 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现。有关详细信息，请参见&lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt;，包括 &lt;code&gt;bsd_glob&lt;/code&gt; ，它不将空格视为模式分隔符。</target>
        </trans-unit>
        <trans-unit id="a18ef89c767fe3092cd7cbf7617a73212c9cedcd" translate="yes" xml:space="preserve">
          <source>This operator is implemented via the &lt;code&gt;File::Glob&lt;/code&gt; extension on most platforms. See &lt;a href=&quot;file/glob&quot;&gt;File::Glob&lt;/a&gt; for portability information.</source>
          <target state="translated">在大多数平台上，该操作符都是通过 &lt;code&gt;File::Glob&lt;/code&gt; 扩展名实现的。有关可移植性信息，请参见&lt;a href=&quot;file/glob&quot;&gt;File :: Glob&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f61ddb296f9de510c527089fa0d0e6f18a12bcc4" translate="yes" xml:space="preserve">
          <source>This operator quotes (and possibly compiles) its</source>
          <target state="translated">这个运算符引用(也可能是编译)它的</target>
        </trans-unit>
        <trans-unit id="00bfef75bba78bb67546c7867c9c5ceacd8cc589" translate="yes" xml:space="preserve">
          <source>This option allow the filename field in the zip header to be modified before it is written to the zip file.</source>
          <target state="translated">这个选项允许在压缩文件写入之前修改压缩文件头的文件名。</target>
        </trans-unit>
        <trans-unit id="31a1073c0be295447c4fa6a92df15986893583ac" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何输入或输出数据流 &lt;code&gt;anyinflate&lt;/code&gt; 是文件句柄。</target>
        </trans-unit>
        <trans-unit id="f9285c30af9b4fbbee720f406a006d97f4010015" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;anyuncompress&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何以文件句柄 &lt;code&gt;anyuncompress&lt;/code&gt; 输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="e84a1d77a7ad064325b540c87fc270941af6172d" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bunzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件处理程序 &lt;code&gt;bunzip2&lt;/code&gt; 的任何输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="991318af65c036237347589558cc5bbc7b747313" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;bzip2&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件句柄到 &lt;code&gt;bzip2&lt;/code&gt; 的任何输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="e3937b065e9e10f42a614e20da537cf76f206b09" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;deflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于所有要 &lt;code&gt;deflate&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="7597a37aa86998ead804f6646d406a8232322d5c" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gunzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于文件句柄的所有输入或输出到 &lt;code&gt;gunzip&lt;/code&gt; 的数据流。</target>
        </trans-unit>
        <trans-unit id="3b1d88507893c4f30c1f99b3dd08ad9bcc7749d4" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;gzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何输入或输出数据流 &lt;code&gt;gzip&lt;/code&gt; 的是文件句柄。</target>
        </trans-unit>
        <trans-unit id="197d2e92c12a668b61b45cede98ce89082acf98a" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;inflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要 &lt;code&gt;inflate&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="11085e39e2558052d844319712c721f6cf03a406" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawdeflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要作为文件句柄进行 &lt;code&gt;rawdeflate&lt;/code&gt; 的输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="5edfb063fb42d1f72af8e3277ad4716ba885c487" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;rawinflate&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何 &lt;code&gt;rawinflate&lt;/code&gt; 的文件句柄输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="8b0f73e1567ccae83577dd7200eae7bda2188288" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;unzip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于任何要 &lt;code&gt;unzip&lt;/code&gt; 输入或输出数据流，即文件句柄。</target>
        </trans-unit>
        <trans-unit id="295f0cfd4ded98b9574af22ae3b9d33935ef4669" translate="yes" xml:space="preserve">
          <source>This option applies to any input or output data streams to &lt;code&gt;zip&lt;/code&gt; that are filehandles.</source>
          <target state="translated">此选项适用于所有作为文件句柄的 &lt;code&gt;zip&lt;/code&gt; 输入或输出数据流。</target>
        </trans-unit>
        <trans-unit id="2812ec45ee9aa481cedeafcd91c6fd310ce87a63" translate="yes" xml:space="preserve">
          <source>This option can be used when there is useful information immediately following the compressed data stream, and you don't know the length of the compressed data stream.</source>
          <target state="translated">当压缩数据流之后紧接着有有用的信息,而你又不知道压缩数据流的长度时,可以使用这个选项。</target>
        </trans-unit>
        <trans-unit id="96e75df71c1bf6e90ec730c6cdd32614d5b40bf0" translate="yes" xml:space="preserve">
          <source>This option can be useful when the compressed data is embedded in another file/data structure and it is not possible to work out where the compressed data begins without having to read the first few bytes. If this is the case, the uncompression can be</source>
          <target state="translated">当压缩的数据被嵌入到另一个文件/数据结构中,如果不读取前几个字节,就不可能找出压缩数据的起点时,这个选项就很有用。在这种情况下,解压缩可以是</target>
        </trans-unit>
        <trans-unit id="ae71b12d470fda92f5396caeec200106ff4f6bc5" translate="yes" xml:space="preserve">
          <source>This option can be useful when you are processing compressed data that is embedded in another file/buffer. In this case the data that immediately follows the compressed stream will be left in the input buffer.</source>
          <target state="translated">当你在处理嵌入在另一个文件/缓冲区中的压缩数据时,这个选项很有用。在这种情况下,紧接着压缩流的数据将被留在输入缓冲区中。</target>
        </trans-unit>
        <trans-unit id="05c5aace4afdf3704689266ed36cfe4a30bb343e" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values as if the environment variable POSIXLY_CORRECT had been set.</source>
          <target state="translated">这个选项会使所有的配置选项重置为默认值,就像设置了环境变量POSIXLY_CORRECT一样。</target>
        </trans-unit>
        <trans-unit id="0bb7609607b04e591708c21193516c45ee13b415" translate="yes" xml:space="preserve">
          <source>This option causes all configuration options to be reset to their default values.</source>
          <target state="translated">该选项将使所有配置选项重置为默认值。</target>
        </trans-unit>
        <trans-unit id="96a82215c08e826a1eb80ae96999f098e98a4ee7" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">此选项控制如何通过 &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; 和 &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; 方法将数据写入输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="c90b7070ba70482f3b4e42afba1dbe1ff165436c" translate="yes" xml:space="preserve">
          <source>This option controls how data is written to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">此选项控制如何通过 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 方法将数据写入输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="59041bc47f2bcbc25e18c7446422e8f7a244ca3a" translate="yes" xml:space="preserve">
          <source>This option controls the &quot;external file attributes&quot; field in the central header of the zip file. This is a 4 byte field.</source>
          <target state="translated">这个选项控制了压缩文件中心头的 &quot;外部文件属性 &quot;字段。这是一个4字节的字段。</target>
        </trans-unit>
        <trans-unit id="fe53ff997f22ee3b8e3b5b499037b30213ed7a2b" translate="yes" xml:space="preserve">
          <source>This option controls what the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method does with uncompressed data.</source>
          <target state="translated">此选项控制 &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 方法对未压缩数据的处理方式。</target>
        </trans-unit>
        <trans-unit id="2fd5bc077a448b0ac8688176c0355190f56eee1f" translate="yes" xml:space="preserve">
          <source>This option controls whether the extra checks defined below are used when carrying out the decompression. When Strict is on, the extra tests are carried out, when Strict is off they are not.</source>
          <target state="translated">这个选项控制在进行减压时是否使用下面定义的额外检查。当Strict开启时,会进行额外的检查,当Strict关闭时,则不会进行额外的检查。</target>
        </trans-unit>
        <trans-unit id="e8f91b605f96e49eba45a2533f216bb9aa5630d4" translate="yes" xml:space="preserve">
          <source>This option controls whether the filename field in the zip header is</source>
          <target state="translated">这个选项可以控制zip头中的文件名字段是否是</target>
        </trans-unit>
        <trans-unit id="c9ccbe84ff4c87c8d1938d3fb3bc36c35924a163" translate="yes" xml:space="preserve">
          <source>This option controls whether the zip file/buffer output is created in streaming mode.</source>
          <target state="translated">该选项控制是否在流媒体模式下创建zip文件/缓冲区输出。</target>
        </trans-unit>
        <trans-unit id="25df283cc49b2b02eee383b551fc895c82bca588" translate="yes" xml:space="preserve">
          <source>This option defaults to 1.</source>
          <target state="translated">此选项默认为1。</target>
        </trans-unit>
        <trans-unit id="34b650f76678c6a01e22f15770dea69e53718082" translate="yes" xml:space="preserve">
          <source>This option defaults to 4096.</source>
          <target state="translated">这个选项的默认值是4096。</target>
        </trans-unit>
        <trans-unit id="d5f2929171736f86edabd8e4e81e6b76f585f308" translate="yes" xml:space="preserve">
          <source>This option defaults to &lt;b&gt;false&lt;/b&gt;.</source>
          <target state="translated">此选项默认为&lt;b&gt;false&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0fe4b53be5e0e4b306e7b8817dee109e7d56e3b6" translate="yes" xml:space="preserve">
          <source>This option defaults to false.</source>
          <target state="translated">该选项默认为false。</target>
        </trans-unit>
        <trans-unit id="3c17c5d6de4659d46fac1329201d45aebab6728c" translate="yes" xml:space="preserve">
          <source>This option defaults to off.</source>
          <target state="translated">该选项默认为关闭。</target>
        </trans-unit>
        <trans-unit id="5b6fb11ab3c3f09a5247ca571c81e532a6439637" translate="yes" xml:space="preserve">
          <source>This option defaults to true.</source>
          <target state="translated">该选项默认为 &quot;true&quot;。</target>
        </trans-unit>
        <trans-unit id="a49b3dde1d982fff6659af9dbc370e4c81b2a251" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly three elements: &lt;code&gt;$atime&lt;/code&gt; , &lt;code&gt;mtime&lt;/code&gt; and &lt;code&gt;$ctime&lt;/code&gt; . These correspond to the last access time, last modification time and creation time respectively.</source>
          <target state="translated">该选项期望一个数组引用完全包含三个元素： &lt;code&gt;$atime&lt;/code&gt; ， &lt;code&gt;mtime&lt;/code&gt; 和 &lt;code&gt;$ctime&lt;/code&gt; 。这些分别对应于最后访问时间，最后修改时间和创建时间。</target>
        </trans-unit>
        <trans-unit id="d7b61a9548815335c12044934c6edf6afc0fade2" translate="yes" xml:space="preserve">
          <source>This option expects an array reference with exactly two elements: &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . These values correspond to the numeric User ID (UID) and Group ID (GID) of the owner of the files respectively.</source>
          <target state="translated">该选项期望一个数组引用具有两个元素： &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 。这些值分别对应于文件所有者的数字用户ID（UID）和组ID（GID）。</target>
        </trans-unit>
        <trans-unit id="f5e3123268242816c97985ddf2abce0d046136ba" translate="yes" xml:space="preserve">
          <source>This option is a no-op.</source>
          <target state="translated">这个选项是一个无选项。</target>
        </trans-unit>
        <trans-unit id="1144456033d4b378e77675f24087a7a175d1be93" translate="yes" xml:space="preserve">
          <source>This option is case-insensitive.</source>
          <target state="translated">此选项不区分大小写。</target>
        </trans-unit>
        <trans-unit id="2511f05b6374c7879cb361cf57c595c2e2f72590" translate="yes" xml:space="preserve">
          <source>This option is checked when you write out the tarfile using &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;create_archive&lt;/code&gt; .</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;create_archive&lt;/code&gt; 写入 tarfile时，将选中此选项。</target>
        </trans-unit>
        <trans-unit id="1b2a2a4f5928dc68068bb78c6282de092775a8e0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default.</source>
          <target state="translated">该选项默认为启用。</target>
        </trans-unit>
        <trans-unit id="4549d37c19966c81c9e8c6bc7457a6a5da6fd6d3" translate="yes" xml:space="preserve">
          <source>This option is mostly used when reading from a filehandle, in which case the file pointer will be left pointing to the first byte directly after the compressed data stream.</source>
          <target state="translated">这个选项主要用于从文件柄读取时,在这种情况下,文件指针将直接指向压缩数据流后的第一个字节。</target>
        </trans-unit>
        <trans-unit id="da3c768aaf3f5e035f976487f87837b11b5b30c6" translate="yes" xml:space="preserve">
          <source>This option is no longer supported. It is still documented only to aid in the debugging of old programs that use it. Old programs should be converted to use the &lt;code&gt;HASH&lt;/code&gt; option instead.</source>
          <target state="translated">不再支持此选项。它仍然被记录只是为了帮助调试使用它的旧程序。应将旧程序转换为使用 &lt;code&gt;HASH&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="a4a6ba823380e81c3792a98e87160d5e375b14e6" translate="yes" xml:space="preserve">
          <source>This option is obscure and discouraged.</source>
          <target state="translated">这个方案晦涩难懂,不鼓励。</target>
        </trans-unit>
        <trans-unit id="c86f3c4424a2a7c5541c3bc97e781d1a1d2bf31e" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_BZIP2. It is ignored otherwise.</source>
          <target state="translated">仅当 &lt;code&gt;Method&lt;/code&gt; 为ZIP_CM_BZIP2时，此选项才有效。否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="e287076e946d3a88fdf8e217ada09ffe773941d3" translate="yes" xml:space="preserve">
          <source>This option is only valid if the &lt;code&gt;Method&lt;/code&gt; is ZIP_CM_LZMA. It is ignored otherwise.</source>
          <target state="translated">仅当 &lt;code&gt;Method&lt;/code&gt; 为ZIP_CM_LZMA时，此选项才有效。否则将被忽略。</target>
        </trans-unit>
        <trans-unit id="e47f433c8815bcca005cf8fc1f8f226523161029" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyInflate对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="4c7afb5a8e42acbe0e34fc5f5b8fc4326a8529d5" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::AnyUncompress object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: AnyUncompress对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="4c90c6efe9d75228bc8980202147dbd8e5b1d098" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Bunzip2 object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Bunzip2对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="1a0451d52242cab341bf29b753116dd306cc10b7" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Gunzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Gunzip对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="c6cccd64b3f769d6fde655234d1c117fd17fbdc4" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Inflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Inflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="a026bdcb25c56dbca754467a3829013c39db31ac" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::RawInflate object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: RawInflate对象，就会导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="f4a3d8b2fb37fa80663bb31ac23a1f0cc61d52e6" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$input&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the file being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the IO::Uncompress::Unzip object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$input&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定且值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁IO :: Uncompress :: Unzip对象，将导致文件关闭。</target>
        </trans-unit>
        <trans-unit id="a47e1179435d09c1507a883d5e990db962771a45" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="97fb53611300748a1b7f47bb19f220d7d3bb2490" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且该值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="258816e7ba3830736405fb29e1fd5aa78fa1b61a" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，则该值为true，一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="33f553ec8eed6ca2655d0af84e094c777ea4ac37" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="29176bb9d55bdad6e9210947b4806edcc6d975b2" translate="yes" xml:space="preserve">
          <source>This option is only valid when the &lt;code&gt;$output&lt;/code&gt; parameter is a filehandle. If specified, and the value is true, it will result in the &lt;code&gt;$output&lt;/code&gt; being closed once either the &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; method is called or the &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object is destroyed.</source>
          <target state="translated">仅当 &lt;code&gt;$output&lt;/code&gt; 参数为文件句柄时，此选项才有效。如果指定了该值，并且其值为true，则一旦调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 方法或销毁 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 对象，将导致 &lt;code&gt;$output&lt;/code&gt; 关闭。</target>
        </trans-unit>
        <trans-unit id="f4da7e81811658139a241d2fcf49caaf6fc6d794" translate="yes" xml:space="preserve">
          <source>This option is significantly slower than the other one.</source>
          <target state="translated">这个方案比另一个方案要慢很多。</target>
        </trans-unit>
        <trans-unit id="43ce55b0c5bee0085af75b3bb5923ccf3a65b644" translate="yes" xml:space="preserve">
          <source>This option is used to compress input data and append it to an existing compressed data stream in &lt;code&gt;$output&lt;/code&gt; . The end result is a single compressed data stream stored in &lt;code&gt;$output&lt;/code&gt; .</source>
          <target state="translated">此选项用于压缩输入数据并将其附加到 &lt;code&gt;$output&lt;/code&gt; 现有的压缩数据流中。最终结果是存储在 &lt;code&gt;$output&lt;/code&gt; 的单个压缩数据流。</target>
        </trans-unit>
        <trans-unit id="c905ba8910d975a79e749c35e513e95ca43f84ed" translate="yes" xml:space="preserve">
          <source>This option means that you want to limit the results just to items whose podnames match the given glob/wildcard expression. For example, you might limit your search to just &quot;LWP::*&quot;, to search only for modules starting with &quot;LWP::*&quot; (but not including the module &quot;LWP&quot; itself); or you might limit your search to &quot;LW*&quot; to see only modules whose (full) names begin with &quot;LW&quot;; or you might search for &quot;*Find*&quot; to search for all modules with &quot;Find&quot; somewhere in their full name. (You can also use &quot;?&quot; in a glob expression; so &quot;DB?&quot; will match &quot;DBI&quot; and &quot;DBD&quot;.)</source>
          <target state="translated">这个选项的意思是,你想把搜索结果限制在podnames符合给定的glob/wildcard表达式的项目上。例如,您可以将搜索结果限制为 &quot;LWP::*&quot;,只搜索以 &quot;LWP::*&quot;开头的模块(但不包括 &quot;LWP &quot;模块本身);或者您可以将搜索结果限制为 &quot;LW*&quot;。(但不包括模块 &quot;LWP &quot;本身);或者您可以将搜索范围限制为 &quot;LW*&quot;,只看到全名以 &quot;LW &quot;开头的模块;或者您可以搜索 &quot;*Find*&quot;,以搜索所有全名中带有 &quot;Find &quot;的模块。(您也可以在 glob 表达式中使用&quot;?&quot;;所以 &quot;DB? &quot;将匹配 &quot;DBI &quot;和 &quot;DBD&quot;)。</target>
        </trans-unit>
        <trans-unit id="20360642d3c9e99dc2a287f8242c272ca5705a34" translate="yes" xml:space="preserve">
          <source>This option says to instead output literal UTF-8 characters. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">这个选项说,而是输出UTF-8字样的字符。如果你的*roff实现能够处理它,这是最好的输出格式,可以避免包含非ASCII字符的文档损坏。但是,要注意的是,许多实现并不支持使用UTF-8字符的*roff源码,甚至可能导致segfaults和其他不良行为。</target>
        </trans-unit>
        <trans-unit id="198821065f8114e37c282b1dc5e2e1e562fb79c1" translate="yes" xml:space="preserve">
          <source>This option takes a parameter that must be a reference to a sub. On entry to the sub the &lt;code&gt;$_&lt;/code&gt; variable will contain the name to be filtered. If no filename is available &lt;code&gt;$_&lt;/code&gt; will contain an empty string.</source>
          <target state="translated">此选项采用的参数必须是对子项的引用。在进入子目录时， &lt;code&gt;$_&lt;/code&gt; 变量将包含要过滤的名称。如果没有可用的文件名， &lt;code&gt;$_&lt;/code&gt; 将包含一个空字符串。</target>
        </trans-unit>
        <trans-unit id="3c97397612f397cc9803106ff617ed57fcd7bbdd" translate="yes" xml:space="preserve">
          <source>This option was introduced to let you easily customize which</source>
          <target state="translated">这个选项的引入是为了让您轻松地定制哪些</target>
        </trans-unit>
        <trans-unit id="478ef92f533a2a64ed38715adae3641923596540" translate="yes" xml:space="preserve">
          <source>This option will uncompress the contents of &lt;code&gt;$string&lt;/code&gt; before processing the input file/buffer.</source>
          <target state="translated">此选项将在处理输入文件/缓冲区之前解压缩 &lt;code&gt;$string&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="94e79c8cc707f4d220ebc5676b2e7c094b43e26e" translate="yes" xml:space="preserve">
          <source>This option, if set to a true value, suppresses the URL when anchor text is given, so this example would be formatted as just &lt;code&gt;foo&lt;/code&gt; . This can produce less cluttered output in cases where the URLs are not particularly important.</source>
          <target state="translated">如果将此选项设置为true值，则在给出锚文本时将禁止显示URL，因此此示例的格式将仅为 &lt;code&gt;foo&lt;/code&gt; 。在URL不是特别重要的情况下，这可以减少混乱的输出。</target>
        </trans-unit>
        <trans-unit id="d73e8a9fe84394bb733d349d80f809abc0c71549" translate="yes" xml:space="preserve">
          <source>This overload was introduced in Perl 5.12.</source>
          <target state="translated">这个重载是在Perl 5.12中引入的。</target>
        </trans-unit>
        <trans-unit id="80f1948b993b572ddd0ded00367d4480f0e1a9dd" translate="yes" xml:space="preserve">
          <source>This overrides all the default install locations. Man pages, libraries, scripts, etc... MakeMaker will try to make an educated guess about where to place things under the new PREFIX based on your Config defaults. Failing that, it will fall back to a structure which should be sensible for your platform.</source>
          <target state="translated">这将覆盖所有默认的安装位置。Man pages,libraries,scripts,etc...。MakeMaker会根据你的Config默认值来猜测新的Prefix的位置。如果做不到这一点,它将回到一个对你的平台来说应该是合理的结构。</target>
        </trans-unit>
        <trans-unit id="444e5337bdc60ac371985ae433717f80c0fb2273" translate="yes" xml:space="preserve">
          <source>This overrides the default behavior of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside the newly created thread only.</source>
          <target state="translated">这将仅覆盖新创建的线程内 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 的默认行为。</target>
        </trans-unit>
        <trans-unit id="519b8612e911f1f56d7cf335d416b8b3e0b034ae" translate="yes" xml:space="preserve">
          <source>This package allows a tied hash to autoload its values on the first access, and to use the cached value on the following accesses.</source>
          <target state="translated">这个包允许绑定哈希在第一次访问时自动加载其值,并在随后的访问中使用缓存的值。</target>
        </trans-unit>
        <trans-unit id="52216942838934faafa12f993b9e33de2dc6a37f" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since perl 5.001. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">这个软件包从perl 5.001开始就是perl核心的一部分。它已经单独发布到CPAN中,所以老版本的安装可以从错误修复中受益。</target>
        </trans-unit>
        <trans-unit id="a2c6b0ed0d74189431901579ee94937bb8d4ce64" translate="yes" xml:space="preserve">
          <source>This package has been part of the perl core since the first release of perl5. It has been released separately to CPAN so older installations can benefit from bug fixes.</source>
          <target state="translated">自 perl5 的第一个版本发布以来,这个软件包一直是 perl 核心的一部分。它已经单独发布到CPAN中,所以老版本的安装可以从错误修复中受益。</target>
        </trans-unit>
        <trans-unit id="8604a04f6b263dfa751e272224470b230a03d1e8" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core.</source>
          <target state="translated">这个软件包的版权和许可证与perl核心相同。</target>
        </trans-unit>
        <trans-unit id="5b6805fe29e54bd4efe3c6b5cfa333a68b6dd7e7" translate="yes" xml:space="preserve">
          <source>This package has the same copyright and license as the perl core:</source>
          <target state="translated">这个软件包的版权和许可证与perl核心相同。</target>
        </trans-unit>
        <trans-unit id="3dd0926d44817739b9d6d9f6b9c878553eedc873" translate="yes" xml:space="preserve">
          <source>This package has the same functionality as CPAN.pm, but tries to prevent the usage of compiled extensions during its own execution. Its primary purpose is a rescue in case you upgraded perl and broke binary compatibility somehow.</source>
          <target state="translated">这个包的功能和CPAN.pm一样,但是试图防止在自己的执行过程中使用编译后的扩展。它的主要目的是在你升级perl并破坏了二进制兼容性的情况下进行拯救。</target>
        </trans-unit>
        <trans-unit id="5ec260b88b13584e3875f1a95d421c8de3085165" translate="yes" xml:space="preserve">
          <source>This package is free software and is provided &quot;as is&quot; without express or implied warranty. It may be used, redistributed and/or modified under the same terms as Perl itself.</source>
          <target state="translated">本软件包是免费软件,按 &quot;原样 &quot;提供,不做任何明示或暗示的保证。它可以在与Perl本身相同的条款下使用、重新分配和/或修改。</target>
        </trans-unit>
        <trans-unit id="8d169e6cde7a05a46328dee15bc92ea9fbd31c5a" translate="yes" xml:space="preserve">
          <source>This package is just a front end to some other packages. It's a stub to set up a common interface to the various ReadLine implementations found on CPAN (under the &lt;code&gt;Term::ReadLine::*&lt;/code&gt; namespace).</source>
          <target state="translated">该软件包只是其他一些软件包的前端。为CPAN上的各种ReadLine实现（在 &lt;code&gt;Term::ReadLine::*&lt;/code&gt; 名称空间下）建立通用接口是一个存根。</target>
        </trans-unit>
        <trans-unit id="ce76c6c4371370495517baf3705b461101fff8c7" translate="yes" xml:space="preserve">
          <source>This package is meant as a base of Pod::Perldoc formatters, like &lt;a href=&quot;totext&quot;&gt;Pod::Perldoc::ToText&lt;/a&gt;, &lt;a href=&quot;toman&quot;&gt;Pod::Perldoc::ToMan&lt;/a&gt;, etc.</source>
          <target state="translated">该软件包是Pod :: Perldoc格式化程序的基础，例如&lt;a href=&quot;totext&quot;&gt;Pod :: Perldoc :: ToText&lt;/a&gt;，&lt;a href=&quot;toman&quot;&gt;Pod :: Perldoc :: ToMan&lt;/a&gt;等。</target>
        </trans-unit>
        <trans-unit id="9180a230452e68871f0598e03ac17371f08687f4" translate="yes" xml:space="preserve">
          <source>This package is still a work in progress. ;-)</source>
          <target state="translated">这个包还在开发中;-)</target>
        </trans-unit>
        <trans-unit id="5132ab88c97f356a0cb81785c11fd445555c2f78" translate="yes" xml:space="preserve">
          <source>This package lets you create and manipulate complex numbers. By default,</source>
          <target state="translated">这个软件包可以让你创建和操作复杂的数字。默认情况下。</target>
        </trans-unit>
        <trans-unit id="0502ae210c839a0d5612b4c49c9ee0a00914b58d" translate="yes" xml:space="preserve">
          <source>This packs &lt;code&gt;3*@buffer&lt;/code&gt; bytes, but it turns out that the size of &lt;code&gt;buffer_t&lt;/code&gt; is four times &lt;code&gt;BUFLEN&lt;/code&gt; ! The moral of the story is that the required alignment of a structure or array is propagated to the next higher level where we have to consider padding</source>
          <target state="translated">这组 &lt;code&gt;3*@buffer&lt;/code&gt; 的字节，但事实证明，大小 &lt;code&gt;buffer_t&lt;/code&gt; 四倍 &lt;code&gt;BUFLEN&lt;/code&gt; ！这个故事的寓意是，将结构或数组的所需对齐方式传播到了我们必须考虑填充的下一个更高层次</target>
        </trans-unit>
        <trans-unit id="946e326f892b4b8b1ddce244173724cf9a7d1bb8" translate="yes" xml:space="preserve">
          <source>This page covers the very basics of understanding, creating and using regular expressions ('regexes') in Perl.</source>
          <target state="translated">本页介绍了如何理解、创建和使用Perl中的正则表达式('regexes')的基础知识。</target>
        </trans-unit>
        <trans-unit id="dce9886ab9b0a9a0def511caa51f7fe80e84aea2" translate="yes" xml:space="preserve">
          <source>This page describes the syntax of regular expressions in Perl.</source>
          <target state="translated">本页介绍Perl中正则表达式的语法。</target>
        </trans-unit>
        <trans-unit id="317e90a756283c2e548a97a6d078f31d1baf3825" translate="yes" xml:space="preserve">
          <source>This page provides a basic tutorial on understanding, creating and using regular expressions in Perl. It serves as a complement to the reference page on regular expressions &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;. Regular expressions are an integral part of the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operators and so this tutorial also overlaps with &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt; and &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">该页面提供了有关在Perl中理解，创建和使用正则表达式的基础教程。它是对正则表达式&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;的参考页的补充。正则表达式是 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 运算符的组成部分，因此本教程&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;在perlop&lt;/a&gt;和&lt;a href=&quot;functions/split&quot;&gt;split中&lt;/a&gt;也与Regexp Quote-Like运算符重叠。</target>
        </trans-unit>
        <trans-unit id="5dd11d6815b6bbd5757b2908c5f7f36d9fc65ef7" translate="yes" xml:space="preserve">
          <source>This parameter allows additional metadata to be stored in the ExtraField in the gzip header. An RFC 1952 compliant ExtraField consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">该参数允许在gzip头的ExtraField中存储额外的元数据。符合RFC 1952标准的ExtraField由零个或多个子字段组成。每个子字段由一个两个字节的头和子字段数据组成。</target>
        </trans-unit>
        <trans-unit id="6c5f89c77abee951f08c51fc642a03fa6b870eac" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of a bit in the zip central header. It is used to signal that the data stored in the zip file/buffer is probably text.</source>
          <target state="translated">这个参数控制了zip中央头的一个位的设置。它用来提示存储在zip文件/缓冲区中的数据大概是文本。</target>
        </trans-unit>
        <trans-unit id="f7ab5c8a3bc9a88a9534a62193fcda4a2a345ca3" translate="yes" xml:space="preserve">
          <source>This parameter controls the setting of the FLG.FTEXT bit in the gzip header. It is used to signal that the data stored in the gzip file/buffer is probably text.</source>
          <target state="translated">这个参数控制gzip头中FLG.FTEXT位的设置。它用来表示存储在gzip文件/缓冲区中的数据可能是文本。</target>
        </trans-unit>
        <trans-unit id="1d135fdd7e0c9609625dc055c076f0bab706088f" translate="yes" xml:space="preserve">
          <source>This parameter defaults to 0.</source>
          <target state="translated">此参数默认为0。</target>
        </trans-unit>
        <trans-unit id="a954f8a244020c9f424e9822cfad5459a2f5fec4" translate="yes" xml:space="preserve">
          <source>This parameter is ignored.</source>
          <target state="translated">该参数被忽略。</target>
        </trans-unit>
        <trans-unit id="3095070e85d1a1b0788b86dc1c47569b11d0ecb4" translate="yes" xml:space="preserve">
          <source>This parameter is used to specify the ambient pragmas which are stored in the special hash %^H.</source>
          <target state="translated">这个参数用于指定存储在特殊哈希%^H中的环境语法。</target>
        </trans-unit>
        <trans-unit id="e57f8e4024e58b80873e8cbfaa23d47d4d596bfc" translate="yes" xml:space="preserve">
          <source>This parameter works like &lt;code&gt;overrideCJK&lt;/code&gt; , so see there for examples.</source>
          <target state="translated">此参数的工作方式类似于 &lt;code&gt;overrideCJK&lt;/code&gt; ，因此请参见示例。</target>
        </trans-unit>
        <trans-unit id="ac9494fe5df3170e77a2748f1c2b29eb01128b21" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &lt;code&gt;(?!)&lt;/code&gt;, but easier to read. In fact, &lt;code&gt;(?!)&lt;/code&gt; gets optimised into &lt;code&gt;(*FAIL)&lt;/code&gt; internally.</source>
          <target state="translated">此模式不匹配，并且总是失败。它可以用来迫使引擎后退。它等效于 &lt;code&gt;(?!)&lt;/code&gt; ，但更易于阅读。实际上， &lt;code&gt;(?!)&lt;/code&gt; &lt;code&gt;(*FAIL)&lt;/code&gt; 内部被优化为（* FAIL）。</target>
        </trans-unit>
        <trans-unit id="9d7331a8c75f2ab7015003fc1a186b402d4f4b0f" translate="yes" xml:space="preserve">
          <source>This pattern matches nothing and causes the end of successful matching at the point at which the &lt;code&gt;(*ACCEPT)&lt;/code&gt; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &lt;code&gt;(??{})&lt;/code&gt; , only the innermost pattern is ended immediately.</source>
          <target state="translated">此模式不匹配任何内容，并导致在遇到 &lt;code&gt;(*ACCEPT)&lt;/code&gt; 模式时成功匹配结束，而不管字符串中实际上是否还有更多要匹配的内容。当在嵌套模式（例如递归）中或在通过 &lt;code&gt;(??{})&lt;/code&gt; 动态生成的子模式中时，仅最里面的模式立即结束。</target>
        </trans-unit>
        <trans-unit id="19f045887dd160fbc7bf52fef1325dee9e3b92d8" translate="yes" xml:space="preserve">
          <source>This perl distribution comes with a tremendous amount of documentation. To add these to the built-in manuals that come with Plan 9, from /sys/src/cmd/perl/5.00301 (adjust version appropriately) run:</source>
          <target state="translated">这个perl发行版自带了大量的文档。要将这些文件添加到Plan 9的内置手册中,请从/sys/src/cmd/perl/5.00301(适当调整版本)运行。</target>
        </trans-unit>
        <trans-unit id="faaee2dbff571e442cc459d64235bf7e75251410" translate="yes" xml:space="preserve">
          <source>This phase is not called &quot;BEGIN&quot; to avoid confusion with &lt;code&gt;BEGIN&lt;/code&gt; -blocks, as those are executed during compile-time of any compilation unit, not just the top-level program. A new, localised compile-time entered at run-time, for example by constructs as &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; are not global interpreter phases, and therefore aren't reflected by &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; .</source>
          <target state="translated">为了避免与 &lt;code&gt;BEGIN&lt;/code&gt; 块混淆，此阶段不称为&amp;ldquo; BEGIN&amp;rdquo; ，因为这些块在任何编译单元（而不仅仅是顶层程序）的编译期间执行。在运行时（例如，通过 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;use SomeModule&quot;&lt;/code&gt; 的构造）输入的新的本地化编译时不是全局解释器阶段，因此不会被 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; 反映。</target>
        </trans-unit>
        <trans-unit id="38d412691b698918f3fb521b6c5dd0a3a033324a" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the &quot;less&quot; pager and prints &quot;bar&quot; on the console:</source>
          <target state="translated">这将 &quot;foo &quot;管到 &quot;少 &quot;的寻呼机,并在控制台上打印 &quot;bar&quot;。</target>
        </trans-unit>
        <trans-unit id="aa4d6fbd955f7e5cef0d107f07af92fd7a485df2" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo&quot; to the pager and writes &quot;bar&quot; in the file &quot;blurch&quot;:</source>
          <target state="translated">这将 &quot;foo &quot;管到寻呼机,并将 &quot;bar &quot;写入文件 &quot;blurch &quot;中。</target>
        </trans-unit>
        <trans-unit id="f5e952eb46ee9ecbd24ef00bffe49334d2cc3dad" translate="yes" xml:space="preserve">
          <source>This pipes &quot;foo\nbar\n&quot; to the less pager:</source>
          <target state="translated">这管 &quot;foo/nbarbar/n &quot;的少呼机。</target>
        </trans-unit>
        <trans-unit id="9ef24b3495020011602b2e6eab8942a1d3d9b7c9" translate="yes" xml:space="preserve">
          <source>This port can also be built on IA64/AMD64 using:</source>
          <target state="translated">这个 port 也可以在 IA64/AMD64 上使用。</target>
        </trans-unit>
        <trans-unit id="ca794b2a97ff2f3e9f3ab8b1358dfca57eef50e2" translate="yes" xml:space="preserve">
          <source>This port currently supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites.</source>
          <target state="translated">此 port 目前支持 MakeMaker (用于为 perl 建立扩展的一组模块)。因此,您应该能够联编和安装 CPAN 站点中的大多数扩展。</target>
        </trans-unit>
        <trans-unit id="da8d54e517da55f89f98bd5f4b007e4f6e30203a" translate="yes" xml:space="preserve">
          <source>This port fully supports MakeMaker (the set of modules that is used to build extensions to perl). Therefore, you should be able to build and install most extensions found in the CPAN sites. See &lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Usage Hints for Perl on Windows&lt;/a&gt; below for general hints about this.</source>
          <target state="translated">此端口完全支持MakeMaker（用于构建perl扩展的模块集）。因此，您应该能够构建和安装在CPAN站点中找到的大多数扩展。有关此方面的一般提示，请参见下面的&lt;a href=&quot;#Usage-Hints-for-Perl-on-Windows&quot;&gt;Windows Perl使用提示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca5da1d69d15505d5dfe7b2200728b9e2a69857" translate="yes" xml:space="preserve">
          <source>This port of Perl also uses Unix-epoch date values internally. As long as you are dealing with ASCII character string representations of dates, this should not be an issue. The supported epoch is January 1, 1980 to January 17, 2038.</source>
          <target state="translated">这个 Perl 的 port 也在内部使用了 Unix-epoch 日期值。只要您使用的是 ASCII 字符串表示的日期,就不会有问题。支持的年代是 1980 年 1 月 1 日至 2038 年 1 月 17 日。</target>
        </trans-unit>
        <trans-unit id="3b59478e1d9adc5bbc9ae74efe6d7c2a8e595477" translate="yes" xml:space="preserve">
          <source>This port of Perl version 5 prefers Unix-style, slash-separated pathnames over OpenVOS-style greater-than-separated pathnames. OpenVOS-style pathnames should work in most contexts, but if you have trouble, replace all greater-than characters by slash characters. Because the slash character is used as a pathname delimiter, Perl cannot process OpenVOS pathnames containing a slash character in a directory or file name; these must be renamed.</source>
          <target state="translated">这个Perl第5版的移植版本更倾向于使用Unix风格的、以斜线分隔的路径名,而不是OpenVOS风格的大于分隔的路径名。OpenVOS 风格的路径名在大多数情况下都可以使用,但如果您遇到了问题,可以用斜线字符来代替所有的大于字符。由于斜线字符被用作路径名的分隔符,Perl 无法处理目录或文件名中包含斜线字符的 OpenVOS 路径名;这些路径名必须重新命名。</target>
        </trans-unit>
        <trans-unit id="5661c31774bac29706eeedad5ca0b82e3ef23fed" translate="yes" xml:space="preserve">
          <source>This port was originally contributed by Gary Ng around 5.003_24, and borrowed from the Hip Communications port that was available at the time. Various people have made numerous and sundry hacks since then.</source>
          <target state="translated">这个端口最初是由Gary Ng在5.003_24左右贡献的,借鉴了当时的Hip Communications端口。从那以后,不同的人做了许多各种各样的黑客。</target>
        </trans-unit>
        <trans-unit id="791faea88ef9fd32067c73f960fb805edbc087f6" translate="yes" xml:space="preserve">
          <source>This port will support dynamic loading, but it is not selected by default. If you would like to experiment with dynamic loading then be sure to specify -Dusedl in the arguments to the Configure script. See the comments in hints/os390.sh for more information on dynamic loading. If you build with dynamic loading then you will need to add the $archlibexp/CORE directory to your LIBPATH environment variable in order for perl to work. See the config.sh file for the value of $archlibexp. If in trying to use Perl you see an error message similar to:</source>
          <target state="translated">这个 port 将支持动态加载,但默认情况下并没有选择它。如果您想尝试使用动态加载,请务必在配置脚本的参数中指定 -Dusedl。请参阅 hints/os390.sh 中的注释以获得更多关于动态加载的信息。如果你使用动态加载,那么你需要将 $archlibexp/CORE 目录添加到你的 LIBPATH 环境变量中,以便 perl 工作。请参阅config.sh文件以了解$archlibexp的值。如果在尝试使用Perl时看到类似的错误信息。</target>
        </trans-unit>
        <trans-unit id="66e0b9c8e30e0b67210d260345f05889e99ff243" translate="yes" xml:space="preserve">
          <source>This pragma allows overloading of Perl's operators for a class. To overload built-in functions, see &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt; instead.</source>
          <target state="translated">这种语用允许Perl的运算符重载一个类。要重载内置函数，请参阅&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;替代在perlsub中覆盖内置函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca794d61d2dfe5a76e1bb77807f394d0b2d09964" translate="yes" xml:space="preserve">
          <source>This pragma allows you to declare constants at compile-time.</source>
          <target state="translated">这个pragma允许你在编译时声明常量。</target>
        </trans-unit>
        <trans-unit id="2c01b8b1ad50eec7e989d0f266d4a4fc89f5d88b" translate="yes" xml:space="preserve">
          <source>This pragma allows you to lexically disable or enable overloading.</source>
          <target state="translated">这个pragma允许你用词法禁用或启用超载。</target>
        </trans-unit>
        <trans-unit id="c428d7745a523c21e13cd202bfe44587bda59ff5" translate="yes" xml:space="preserve">
          <source>This pragma also affects encoding of the 0x80..0xFF code point range: normally characters in that range are left as eight-bit bytes (unless they are combined with characters with code points 0x100 or larger, in which case all characters need to become UTF-8 encoded), but if the &lt;code&gt;encoding&lt;/code&gt; pragma is present, even the 0x80..0xFF range always gets UTF-8 encoded.</source>
          <target state="translated">此编译指示还会影响0x80..0xFF代码点范围的编码：通常该范围内的字符保留为八位字节（除非它们与代码点为0x100或更大的字符组合在一起，在这种情况下，所有字符都必须变为UTF -8编码），但是如果存在 &lt;code&gt;encoding&lt;/code&gt; 编译指示，则即使0x80..0xFF范围也始终获得UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="cd54481ef89d3dcd2f0d998cbd0de47400ae94c4" translate="yes" xml:space="preserve">
          <source>This pragma arranges for all inputs from files to be translated into Unicode from the current locale as specified in the environment (see &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;), and all outputs to files to be translated back into the locale. (See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;). On a per-filehandle basis, you can instead use the &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO::locale&lt;/a&gt; module, or the &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode::Locale&lt;/a&gt; module, both available from CPAN. The latter module also has methods to ease the handling of &lt;code&gt;ARGV&lt;/code&gt; and environment variables, and can be used on individual strings. If you know that all your locales will be UTF-8, as many are these days, you can use the &lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt; command line switch.</source>
          <target state="translated">此编译指示将文件中的所有输入从环境中指定的当前语言环境转换为Unicode（请参阅&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;），并将文件的所有输出转换回语言环境。 （请参阅&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;）。在每个文件句柄的基础上，您可以改用&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::locale&quot;&gt;PerlIO :: locale&lt;/a&gt;模块或&lt;a href=&quot;http://search.cpan.org/perldoc/Encode::Locale&quot;&gt;Encode :: Locale&lt;/a&gt;模块，这两个都可以从CPAN获得。后一个模块还具有简化 &lt;code&gt;ARGV&lt;/code&gt; 和环境变量处理的方法，并且可以在单个字符串上使用。如果您知道所有语言环境都将是UTF-8，那么现在可以使用&lt;a href=&quot;perlrun#-C&quot;&gt;-C&lt;/a&gt;命令行开关。</target>
        </trans-unit>
        <trans-unit id="34db7e44f64dc2e33987c7fbd44c07e44789bfa8" translate="yes" xml:space="preserve">
          <source>This pragma dates from the days when UTF-8-enabled editors were uncommon. But that was long ago, and the need for it is greatly diminished. That, coupled with the fact that it doesn't work with threads, along with other problems, (see &lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;) have led to its being deprecated. It is planned to remove this pragma in a future Perl version. New code should be written in UTF-8, and the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma used instead (see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; for details). Old code should be converted to UTF-8, via something like the recipe in the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; (though this simple approach may require manual adjustments afterwards).</source>
          <target state="translated">这种语用可追溯到启用UTF-8的编辑器罕见的日子。但这是很久以前的事，对它的需求已大大减少。这样，再加上它不能与线程一起使用，以及其他问题（请参阅&lt;a href=&quot;#BUGS&quot;&gt;BUGS&lt;/a&gt;），导致其已被弃用。计划在将来的Perl版本中删除此杂注。新代码应使用UTF-8编写，而应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma代替（有关详细信息，请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;和&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;）。旧代码应转换为UTF-8，通过类似的配方&lt;a href=&quot;#SYNOPSIS&quot;&gt;概要&lt;/a&gt;（尽管这种简单的方法可能需要手动调整之后）。</target>
        </trans-unit>
        <trans-unit id="4adb9dc70f3c9381053e6cf64fee4c07c531fe57" translate="yes" xml:space="preserve">
          <source>This pragma doesn't affect I/O. Nor does it change the internal representation of strings, only their interpretation. There are still several places where Unicode isn't fully supported, such as in filenames.</source>
          <target state="translated">这个pragma不影响I/O。它也不会改变字符串的内部表示,只是改变它们的解释。还有一些地方没有完全支持Unicode,比如在文件名中。</target>
        </trans-unit>
        <trans-unit id="d0a1053bcb46765bc08bab8c76c7daf170b6ab41" translate="yes" xml:space="preserve">
          <source>This pragma doesn't work well with &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; because PerlIO does not get along very well with it. When &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; contains non-ASCII characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.</source>
          <target state="translated">这种编译指示不适用于 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 因为PerlIO不能很好地与它相处。当 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 包含非ASCII字符时，它会打印出有趣的文字或显示&amp;ldquo;宽字符警告&amp;rdquo;。要了解它，请尝试下面的代码。</target>
        </trans-unit>
        <trans-unit id="842309da32a571cffd281160b3136685717f49db" translate="yes" xml:space="preserve">
          <source>This pragma first appeared in Perl v5.8.0. It has been enhanced in later releases as specified above.</source>
          <target state="translated">这个pragma最早出现在Perl v5.8.0中。在后来的版本中,它已经按照上述规定得到了加强。</target>
        </trans-unit>
        <trans-unit id="ea296547782279e5c0e53a333818543fc8821038" translate="yes" xml:space="preserve">
          <source>This pragma is used to enable a Perl script to be written in encodings that aren't strictly ASCII nor UTF-8. It translates all or portions of the Perl program script from a given encoding into UTF-8, and changes the PerlIO layers of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; to the encoding specified.</source>
          <target state="translated">使用此编译指示可以使Perl脚本以严格不是ASCII或UTF-8的编码来编写。它将全部或部分Perl程序脚本从给定编码转换为UTF-8，并将 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;STDOUT&lt;/code&gt; 的PerlIO层更改为指定的编码。</target>
        </trans-unit>
        <trans-unit id="b2499dd223fe6da7fc3aa8e53b4286111a638895" translate="yes" xml:space="preserve">
          <source>This pragma lets you switch to the &quot;C3&quot; resolution order. In simple terms, &quot;C3&quot; order ensures that shared parent classes are never searched before child classes, so Perl will now search: &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt;&lt;code&gt;MaternalGrandparent&lt;/code&gt; , and finally &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; . Note however that this is not &quot;breadth-first&quot; searching: All the &lt;code&gt;Father&lt;/code&gt; ancestors (except the common ancestor) are searched before any of the &lt;code&gt;Mother&lt;/code&gt; ancestors are considered.</source>
          <target state="translated">此实用程序可让您切换到&amp;ldquo; C3&amp;rdquo;分辨率顺序。简单来说，&amp;ldquo;C3&amp;rdquo;为了确保共享父类从不子类之前搜索，这样的Perl现在搜索： &lt;code&gt;Child&lt;/code&gt; ， &lt;code&gt;Father&lt;/code&gt; ， &lt;code&gt;PaternalGrandparent&lt;/code&gt; ， &lt;code&gt;Mother&lt;/code&gt; &lt;code&gt;MaternalGrandparent&lt;/code&gt; ，最后 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 。但是请注意，这不是&amp;ldquo;先行搜索&amp;rdquo;：在考虑任何 &lt;code&gt;Mother&lt;/code&gt; 祖先之前，将搜索所有 &lt;code&gt;Father&lt;/code&gt; 祖先（公共祖先除外）。</target>
        </trans-unit>
        <trans-unit id="2063e0ed31e4ca83c59af99843b134e51c1d67ca" translate="yes" xml:space="preserve">
          <source>This pragma reflects early attempts to incorporate Unicode into perl and has since been superseded. It breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), and use of this module for anything other than debugging purposes is strongly discouraged. If you feel that the functions here within might be useful for your application, this possibly indicates a mismatch between your mental model of Perl Unicode and the current reality. In that case, you may wish to read some of the perl Unicode documentation: &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;, &lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;.</source>
          <target state="translated">这种实用性反映了将Unicode整合到perl中的早期尝试，此后已被取代。它破坏了封装（即，暴露了perl可执行文件当前如何存储字符串的内幕），并且强烈建议不要将此模块用于除调试目的以外的其他用途。如果您认为其中的功能可能对您的应用程序有用，则可能表明您的Perl Unicode心理模型与当前现实不匹配。在这种情况下，您可能希望阅读一些perl Unicode文档：&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;，&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;，&lt;a href=&quot;perlunifaq&quot;&gt;perlunifaq&lt;/a&gt;和&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ef074ee97cc67ce380e960a125c4b931d1340ce" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to change the behaviour of the filetest permission operators, &lt;code&gt;-r&lt;/code&gt;&lt;code&gt;-w&lt;/code&gt;&lt;code&gt;-x&lt;/code&gt;&lt;code&gt;-R&lt;/code&gt;&lt;code&gt;-W&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">此实用程序指示编译器更改filetest许可权运算符 &lt;code&gt;-r&lt;/code&gt; &lt;code&gt;-w&lt;/code&gt; &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;-R&lt;/code&gt; &lt;code&gt;-W&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; 的行为（请参阅&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="221ed9ae1b0c79e2438890e0d6c973d357078c4b" translate="yes" xml:space="preserve">
          <source>This pragma tells the compiler to enable (or disable) the use of POSIX locales for built-in operations (for example, LC_CTYPE for regular expressions, LC_COLLATE for string comparison, and LC_NUMERIC for number formatting). Each &quot;use locale&quot; or &quot;no locale&quot; affects statements to the end of the enclosing BLOCK.</source>
          <target state="translated">这个pragma告诉编译器启用(或禁用)内置操作的POSIX locale(例如,LC_CTYPE用于正则表达式,LC_COLLATE用于字符串比较,LC_NUMERIC用于数字格式化)。每一个 &quot;使用locale &quot;或 &quot;不使用locale &quot;都会影响到括号BLOCK末尾的语句。</target>
        </trans-unit>
        <trans-unit id="e609830a837e5307b3fb39be2d58dc9501e3994d" translate="yes" xml:space="preserve">
          <source>This pragma was created so you can explicitly tell Perl that operations executed within its scope are to use Unicode rules. More operations are affected with newer perls. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;.</source>
          <target state="translated">创建此编译指示是为了让您可以明确告诉Perl在其范围内执行的操作将使用Unicode规则。更多的操作会受到更新的Perl的影响。请参阅&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode错误&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="700e6f2388b406cbe201cbb98323ed5f25c8d4b4" translate="yes" xml:space="preserve">
          <source>This pragma works just like the &lt;code&gt;strict&lt;/code&gt; pragma. This means that the scope of the warning pragma is limited to the enclosing block. It also means that the pragma setting will not leak across files (via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;). This allows authors to independently define the degree of warning checks that will be applied to their module.</source>
          <target state="translated">此实用程序的工作原理与 &lt;code&gt;strict&lt;/code&gt; 实用程序一样。这意味着警告语用范围仅限于封闭块。这也意味着编译指示设置不会在文件之间泄漏（通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; ）。这使作者可以独立定义将应用于其模块的警告检查的程度。</target>
        </trans-unit>
        <trans-unit id="30a2879d5d48273acab2ab3a9f22c1edf08032e3" translate="yes" xml:space="preserve">
          <source>This prints</source>
          <target state="translated">此印刷品</target>
        </trans-unit>
        <trans-unit id="b6e212e7ef6ac1844cda369639e0440d069cad8b" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; into the file &quot;blurch&quot;:</source>
          <target state="translated">这将打印 &quot;bar &quot;并将 &quot;foo &quot;写入文件 &quot;blurch &quot;中。</target>
        </trans-unit>
        <trans-unit id="d54bfbbae93113b4950fc2d869fb4754b9ce7e99" translate="yes" xml:space="preserve">
          <source>This prints &quot;bar&quot; and writes &quot;foo&quot; to the file &quot;blurch&quot;:</source>
          <target state="translated">这将打印 &quot;bar &quot;并将 &quot;foo &quot;写入文件 &quot;blurch&quot;。</target>
        </trans-unit>
        <trans-unit id="efd4b33e8216cea60a6219dc7e5bd98ac5e87040" translate="yes" xml:space="preserve">
          <source>This prints &quot;foo&quot; (&quot;bar&quot; disappears into nowhereland):</source>
          <target state="translated">这样就会打印出 &quot;foo&quot;(&quot;bar &quot;消失在nowhereland)。</target>
        </trans-unit>
        <trans-unit id="41ff0d603c865bec8366dedecbae0223cb1c3622" translate="yes" xml:space="preserve">
          <source>This prints &lt;code&gt;2.7&lt;/code&gt; .</source>
          <target state="translated">打印 &lt;code&gt;2.7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb91200cd90a472a1ae9cb007ac03043f56be426" translate="yes" xml:space="preserve">
          <source>This prints out the name and version of all modules used and then exits.</source>
          <target state="translated">这将打印出所有使用的模块的名称和版本,然后退出。</target>
        </trans-unit>
        <trans-unit id="f686232da2ac609974851dce432c4e1340ec7365" translate="yes" xml:space="preserve">
          <source>This prints out your environment like the printenv(1) program, but in a different order:</source>
          <target state="translated">这和 printenv(1)程序一样可以打印出你的环境,但顺序不同。</target>
        </trans-unit>
        <trans-unit id="04d447d63dbf460d4723e288297a46d354df3e2a" translate="yes" xml:space="preserve">
          <source>This prints two doublequotes:</source>
          <target state="translated">这样可以打印出两个双引号。</target>
        </trans-unit>
        <trans-unit id="345205710c1209079bdf05b4d146f25fe0a01f36" translate="yes" xml:space="preserve">
          <source>This prints:</source>
          <target state="translated">这个指纹。</target>
        </trans-unit>
        <trans-unit id="d21d1db17e4be9e2f5e50a54879f0a7c98d4455f" translate="yes" xml:space="preserve">
          <source>This probably isn't as useful as you might think. Normally, you shouldn't need to.</source>
          <target state="translated">这可能没有你想象的那么有用。通常情况下,你不应该需要这样做。</target>
        </trans-unit>
        <trans-unit id="341bfd19674c6dfeba3ffe584bfdf82c2776cb1e" translate="yes" xml:space="preserve">
          <source>This probably makes more sense for a human: enter a block, start a statement. Get the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; , and add them together. Find &lt;code&gt;$a&lt;/code&gt; , and assign one to the other. Then leave.</source>
          <target state="translated">这对人类可能更有意义：输入一个块，开始一个语句。获取 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值，并将它们加在一起。找到 &lt;code&gt;$a&lt;/code&gt; ，并将一个分配给另一个。然后离开。</target>
        </trans-unit>
        <trans-unit id="d9d98988085b44026120bb435150bffabf68b9c3" translate="yes" xml:space="preserve">
          <source>This probably sounds a bit more confusing than it really is, so let's go through this program piece by piece and see what it does. (For those of you who might be trying to remember exactly what a prime number is, it's a number that's only evenly divisible by itself and 1.)</source>
          <target state="translated">这可能听起来比实际情况更让人困惑,所以让我们逐一看一下这个程序,看看它的作用。(对于那些可能试图记住什么是质数的人来说,它是一个只能被它自己和1偶数分割的数字。)</target>
        </trans-unit>
        <trans-unit id="e016023303c59d801c6e740a285fec3afa4a6473" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference lexical subroutines in outer subroutines are created, they are automatically rebound to the current values of such lexical subs.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。当创建引用外部子例程中的词法子例程的内部匿名子例程时，它们将自动反弹到此类词法子例程的当前值。</target>
        </trans-unit>
        <trans-unit id="b60e9bed0f73061b937a8fe5fecd9ad0d49454e0" translate="yes" xml:space="preserve">
          <source>This problem can usually be solved by making the inner subroutine anonymous, using the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; syntax. When inner anonymous subs that reference variables in outer subroutines are created, they are automatically rebound to the current values of such variables.</source>
          <target state="translated">通常可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 语法使内部子例程匿名来解决此问题。当创建引用外部子例程中变量的内部匿名子例程时，它们将自动反弹到此类变量的当前值。</target>
        </trans-unit>
        <trans-unit id="30e5c26de90551718f152502391c103ab788e07b" translate="yes" xml:space="preserve">
          <source>This problem usually involves one of the Perl built-ins that has the same name a Unix command that uses octal numbers as arguments on the command line. In this example, &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; on the command line knows that its first argument is octal because that's what it does:</source>
          <target state="translated">此问题通常涉及与Unix命令同名的Perl内置程序之一，该命令使用八进制数字作为命令行上的参数。在此示例中，命令行上的 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 知道其第一个参数是八进制的，因为这就是它的作用：</target>
        </trans-unit>
        <trans-unit id="78b6c2ab73ee787f434ee0ce1c24dc74fd9f5055" translate="yes" xml:space="preserve">
          <source>This problem was fixed in perl 5.004_05, so preventing it means upgrading your version of perl. ;)</source>
          <target state="translated">这个问题在perl 5.004_05中已经被修复了,所以要防止这个问题就需要升级你的perl版本。)</target>
        </trans-unit>
        <trans-unit id="149ef363e988711abf3a930d8381275df0baf405" translate="yes" xml:space="preserve">
          <source>This processes the lines in &lt;code&gt;@lines&lt;/code&gt; (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; are allowed). The final &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is used to indicate the end of document being parsed.</source>
          <target state="translated">这将处理 &lt;code&gt;@lines&lt;/code&gt; 中的行（每个列表项必须为已定义的值，并且必须仅包含一行内容-因此不允许使用诸如 &lt;code&gt;&quot;foo\nbar&quot;&lt;/code&gt; 类的项）。最终的 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 用于指示要解析的文档的结尾。</target>
        </trans-unit>
        <trans-unit id="6c20dce79362eb3c48b58c8e5bc86aad6133c323" translate="yes" xml:space="preserve">
          <source>This produces a patch based on the difference between blead and your current branch. It's important to make sure that blead is up to date before producing the diff, that's why we call &lt;code&gt;git pull&lt;/code&gt; first.</source>
          <target state="translated">这将根据blead和您当前分支之间的差异生成一个补丁。在生成差异之前，确保blead是最新的很重要，这就是为什么我们首先调用 &lt;code&gt;git pull&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="5a3bf030e7bf490188072c702d468c0925c814bb" translate="yes" xml:space="preserve">
          <source>This produces the Perl docs online book &lt;code&gt;perl.INF&lt;/code&gt; . Install in on &lt;code&gt;BOOKSHELF&lt;/code&gt; path.</source>
          <target state="translated">这将产生Perl docs在线图书 &lt;code&gt;perl.INF&lt;/code&gt; 。在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 路径中安装。</target>
        </trans-unit>
        <trans-unit id="2c9c734dac073d3001ca1ea5f8fa8cfb8daa173b" translate="yes" xml:space="preserve">
          <source>This program is Copyright 1990,2015 by Johan Vromans. This program is free software; you can redistribute it and/or modify it under the terms of the Perl Artistic License or the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.</source>
          <target state="translated">本程序版权归Johan Vromans所有,1990,2015。本程序是自由软件;您可以在Perl Artistic License或自由软件基金会发布的GNU通用公共许可证(GNU General Public License)的条款下重新发布和/或修改它;该许可证的第2版或(由您选择)任何更新的版本。</target>
        </trans-unit>
        <trans-unit id="26f7f8dba51ed564d4c376a299ad1ccb7d59f62d" translate="yes" xml:space="preserve">
          <source>This program is designed to help you generate and send bug reports (and thank-you notes) about perl5 and the modules which ship with it.</source>
          <target state="translated">这个程序是用来帮助你生成和发送关于perl5和它的模块的错误报告(和感谢信)。</target>
        </trans-unit>
        <trans-unit id="2cac2059d04ed459899445fb7d4adafed92ceb31" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</source>
          <target state="translated">本程序发布的目的是希望它是有用的,但没有任何保证,甚至没有默示的适销性或适合特定用途的保证。更多细节请参见GNU通用公共许可证。</target>
        </trans-unit>
        <trans-unit id="d8761e66f0aa0865d7b8a0fad53a385acc12de1d" translate="yes" xml:space="preserve">
          <source>This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">本程序发布的目的是希望它是有用的,但不作任何保证,甚至不对适销性或特定用途的适用性作默示保证。</target>
        </trans-unit>
        <trans-unit id="2b736eab48b8800afefb519e32bdf619448f2254" translate="yes" xml:space="preserve">
          <source>This program is distributed under the Artistic License.</source>
          <target state="translated">本程序采用Artistic License发布。</target>
        </trans-unit>
        <trans-unit id="d1d0a6a12423ce6569360d8955fb54c14fc9d18b" translate="yes" xml:space="preserve">
          <source>This program is distributed under the same terms as perl itself. See &lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt; or &lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt; for more info on that.</source>
          <target state="translated">该程序以与perl本身相同的术语分发。有关更多信息，请参见&lt;a href=&quot;http://perl.org/&quot;&gt;http://perl.org/&lt;/a&gt;或&lt;a href=&quot;http://cpan.org/&quot;&gt;http://cpan.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c09da468beec666c3faa34069fc9e34aec608126" translate="yes" xml:space="preserve">
          <source>This program is easy to understand. &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; is the standard way to invoke a perl program from the shell. &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; saves the first command line argument as the regexp to be used, leaving the rest of the command line arguments to be treated as files. &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loops over all the lines in all the files. For each line, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; prints the line if the regexp matches the line. In this line, both &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;/$regexp/&lt;/code&gt; use the default variable &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">这个程序很容易理解。 &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; 是从shell调用perl程序的标准方法。 &lt;code&gt;$regexp = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 将第一个命令行参数保存为要使用的regexp，其余命令行参数则视为文件。 &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; 循环遍历所有文件中的所有行。对于每行， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; if /$regexp/;&lt;/code&gt; ，则&lt;a href=&quot;functions/print&quot;&gt;打印&lt;/a&gt;；如果正则表达式匹配该行，则打印该行。在此行中， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;/$regexp/&lt;/code&gt; 隐式使用默认变量 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3f9820f4fcf840eefdc1fac524d68220274e583" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself</source>
          <target state="translated">本程序是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="46aefc944a8368be1c5041bb6eeeeb6f411fe967" translate="yes" xml:space="preserve">
          <source>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">这个程序是自由软件;你可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="eda486acda27bdf9cd66949e1266b5a78cb661d8" translate="yes" xml:space="preserve">
          <source>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">本程序是自由软件;您可以在与Perl本身相同的条款下重新发布它和/或修改它。</target>
        </trans-unit>
        <trans-unit id="49a9ebce432bc6f7a5abfa1673ae23d082772d50" translate="yes" xml:space="preserve">
          <source>This program is maintained by the Perl 5 Porters. The CPAN distribution is maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;</source>
          <target state="translated">该程序由Perl 5 Porters维护。CPAN分布由S&amp;eacute;bastienAperghis-Tramoni &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d98f469a4bef1492cbd51567cf72d3226f5fb0a1" translate="yes" xml:space="preserve">
          <source>This program provides an easy way to send a thank-you message back to the authors and maintainers of perl. It's just</source>
          <target state="translated">这个程序提供了一个简单的方法来给perl的作者和维护者发送感谢信息。它只是</target>
        </trans-unit>
        <trans-unit id="474e6c18a35ba4d4e6ef7db0a92aa1f2c8019fc7" translate="yes" xml:space="preserve">
          <source>This program uses the pipeline model to generate prime numbers. Each thread in the pipeline has an input queue that feeds numbers to be checked, a prime number that it's responsible for, and an output queue into which it funnels numbers that have failed the check. If the thread has a number that's failed its check and there's no child thread, then the thread must have found a new prime number. In that case, a new child thread is created for that prime and stuck on the end of the pipeline.</source>
          <target state="translated">这个程序使用管道模型来生成质数。管道中的每一个线程都有一个输入队列,用来输入要检查的数字,一个它负责的质数,以及一个输出队列,将检查失败的数字漏入其中。如果该线程有一个未能通过检查的数字,而且没有子线程,那么该线程一定是找到了一个新的质数。在这种情况下,将为该质数创建一个新的子线程,并卡在流水线的末端。</target>
        </trans-unit>
        <trans-unit id="9bd07d758efadc42857a5a0bab51cd8a077edefd" translate="yes" xml:space="preserve">
          <source>This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &lt;code&gt;...&lt;/code&gt; , it will also print the &quot;Baz&quot; line.</source>
          <target state="translated">该程序将仅打印包含&amp;ldquo; Bar&amp;rdquo;的行。如果将范围运算符更改为 &lt;code&gt;...&lt;/code&gt; ，则还将打印&amp;ldquo; Baz&amp;rdquo;行。</target>
        </trans-unit>
        <trans-unit id="f91a32c34a450fa3aaeea5e09b4bf9753a0de2ef" translate="yes" xml:space="preserve">
          <source>This program will probably hang until you kill it. The only way it won't hang is if one of the two threads acquires both locks first. A guaranteed-to-hang version is more complicated, but the principle is the same.</source>
          <target state="translated">这个程序可能会挂起,直到你杀死它。唯一不会挂起的方法是两个线程中的一个先获得两个锁。保证挂起的版本比较复杂,但原理是一样的。</target>
        </trans-unit>
        <trans-unit id="5342717fe0bceba26cbcb8fb4ec4c851e52a537d" translate="yes" xml:space="preserve">
          <source>This project was originated by the late Nick Ing-Simmons and later maintained by Dan Kogai</source>
          <target state="translated">该项目由已故的Nick Ing-Simmons发起,后来由Dan Kogai维护。</target>
        </trans-unit>
        <trans-unit id="d353efbbda92520a2429ad4f8535f649667e5952" translate="yes" xml:space="preserve">
          <source>This property is always written in the compound form. For example, &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; matches characters that are normally written right to left. Unlike the &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; property, this property can have more values added in a future Unicode release. Those listed above comprised the complete set for many Unicode releases, but others were added in Unicode 6.3; you can always find what the current ones are in in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. And &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; describes how to use them.</source>
          <target state="translated">此属性始终以复合形式编写。例如， &lt;code&gt;\p{Bidi_Class:R}&lt;/code&gt; 匹配通常从右到左书写的字符。与 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 属性不同，此属性可以在将来的Unicode版本中添加更多值。上面列出的内容构成了许多Unicode版本的完整集，但其他内容是在Unicode 6.3中添加的；您总是可以在&lt;a href=&quot;perluniprops&quot;&gt;perluniprops中&lt;/a&gt;找到当前的内容。而&lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt;介绍了如何使用它们。</target>
        </trans-unit>
        <trans-unit id="9d34b69b565209c628e5e765cbc6639e949afb7e" translate="yes" xml:space="preserve">
          <source>This property is used when you need to know in what Unicode version(s) a character is.</source>
          <target state="translated">当你需要知道一个字符的Unicode版本时,就会用到这个属性。</target>
        </trans-unit>
        <trans-unit id="ba740c0026c45f2093377326c9e21d5c765b2b70" translate="yes" xml:space="preserve">
          <source>This provides access to most of the Win32 GUI widgets from Perl. Obviously, it only runs under Win32, and uses native widgets. The Perl interface doesn't really follow the C interface: it's been made more Perlish, and the documentation is pretty good. More advanced stuff may require familiarity with the C Win32 APIs, or reference to MSDN.</source>
          <target state="translated">它提供了从Perl中访问大多数Win32 GUI widget的机会。很明显,它只在Win32下运行,并且使用本地的widget。Perl界面并没有真正遵循C界面:它被做得更像Perlish,而且文档非常好。更高级的东西可能需要熟悉C Win32 APIs,或者参考MSDN。</target>
        </trans-unit>
        <trans-unit id="05ed7360b5662052cf8df531a4821820675f5a90" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file.</source>
          <target state="translated">这提供了一种替代方法来指定要从扩展中导出的函数名称。它的值是对扩展要导出的函数名数组的引用。这些名称将不加修改地传递到链接器选项文件中。</target>
        </trans-unit>
        <trans-unit id="b6d4501c0d8df55386bc41a04cfb00e365ded86e" translate="yes" xml:space="preserve">
          <source>This provides an alternate means to specify function names to be exported from the extension. Its value is a reference to an array of function names to be exported by the extension. These names are passed through unaltered to the linker options file. Specifying a value for the FUNCLIST attribute suppresses automatic generation of the bootstrap function for the package. To still create the bootstrap name you have to specify the package name in the DL_FUNCS hash:</source>
          <target state="translated">这提供了一种替代方法来指定要从扩展中导出的函数名称。它的值是对扩展要导出的函数名数组的引用。这些名称将不加修改地传递到链接器选项文件中。为FUNCLIST属性指定一个值会抑制包的引导函数的自动生成。为了继续创建引导名,你必须在DL_FUNCS哈希中指定包名。</target>
        </trans-unit>
        <trans-unit id="e5949eb8258f363515432b75a3130bd3950de7ae" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt; when run with multiple &lt;a href=&quot;../../harness#jobs&quot;&gt;jobs in TAP::Harness&lt;/a&gt;.</source>
          <target state="translated">当&lt;a href=&quot;../../harness#jobs&quot;&gt;在TAP :: Harness中&lt;/a&gt;有多个作业运行时，这将为&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供面向控制台的输出格式。</target>
        </trans-unit>
        <trans-unit id="9181d13c6755b2d2d5fcc68549a86008e0459f52" translate="yes" xml:space="preserve">
          <source>This provides console orientated output formatting for TAP::Harness.</source>
          <target state="translated">这为TAP::Harness提供了面向控制台的输出格式。</target>
        </trans-unit>
        <trans-unit id="d034d371e8adbdcae6dcc8b5f1035f643b009166" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for &lt;a href=&quot;../../harness&quot;&gt;TAP::Harness&lt;/a&gt;. It is particularly important when running with parallel tests, as it ensures that test results are not interleaved, even when run verbosely.</source>
          <target state="translated">这为&lt;a href=&quot;../../harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供了面向文件的输出格式。在并行测试中运行时，这一点尤其重要，因为即使在冗长的运行中，它也可以确保测试结果不会交错。</target>
        </trans-unit>
        <trans-unit id="be3613f62ba727bb8044f064f871c5a2ffe96d89" translate="yes" xml:space="preserve">
          <source>This provides file orientated output formatting for TAP::Harness.</source>
          <target state="translated">这为TAP::Harness提供了面向文件的输出格式。</target>
        </trans-unit>
        <trans-unit id="e79f6eddf4d757dda9eee150d598652b5e165fe6" translate="yes" xml:space="preserve">
          <source>This provides the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token that returns a reference to the current subroutine or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; outside of a subroutine.</source>
          <target state="translated">这提供了 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; 令牌，该令牌返回对当前子例程的引用或在子例程外部的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="224c6e548e4884dfbdfe2ac071bf15dda7c825fc" translate="yes" xml:space="preserve">
          <source>This puts the executables in f:/perllib/bin. Manually move them to the &lt;code&gt;PATH&lt;/code&gt; , manually move the built</source>
          <target state="translated">这会将可执行文件放在f：/ perllib / bin中。手动将其移动到 &lt;code&gt;PATH&lt;/code&gt; ，手动将已构建的</target>
        </trans-unit>
        <trans-unit id="d9a0cac7b723579ba6e539b4576a4997c5b49e8f" translate="yes" xml:space="preserve">
          <source>This read-only variable contains a reference to the last-read filehandle. This is set by &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. This is the same handle that &lt;code&gt;$.&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without arguments use. It is also the handle used when Perl appends &quot;, &amp;lt;STDIN&amp;gt; line 1&quot; to an error or warning message.</source>
          <target state="translated">该只读变量包含对最后读取的文件句柄的引用。这是由 &lt;code&gt;&amp;lt;HANDLE&amp;gt;&lt;/code&gt; 设置的， &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。这与 &lt;code&gt;$.&lt;/code&gt; 相同。并在不使用参数的情况下 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 。它也是Perl在错误或警告消息后附加&amp;ldquo; &amp;lt;STDIN&amp;gt;第1行&amp;rdquo;的句柄。</target>
        </trans-unit>
        <trans-unit id="2e9c374af25573cbb8a011c91df0b5de175403d9" translate="yes" xml:space="preserve">
          <source>This reads the Pod content of the file (or filehandle) that you specify, and processes it with that &lt;code&gt;$parser&lt;/code&gt; object, according to however &lt;code&gt;$parser&lt;/code&gt; 's class works, and according to whatever parser options you have set up for this &lt;code&gt;$parser&lt;/code&gt; object.</source>
          <target state="translated">这种读取您指定的文件（或文件句柄）的波德内容，并与处理它 &lt;code&gt;$parser&lt;/code&gt; 对象，但是，根据 &lt;code&gt;$parser&lt;/code&gt; 的一流作品，并按照任何解析器选项已就此成立 &lt;code&gt;$parser&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c31dda74f7214f2c1e1f0e262ad534c6710776eb" translate="yes" xml:space="preserve">
          <source>This regex from Benjamin Goldberg will add commas to numbers:</source>
          <target state="translated">这个来自Benjamin Goldberg的regex可以在数字上添加逗号。</target>
        </trans-unit>
        <trans-unit id="ba5402a82ba706913f690e8b3975f67ccd9cac88" translate="yes" xml:space="preserve">
          <source>This regexp displays a common task: perform a case-insensitive match. Perl provides a way of avoiding all those brackets by simply appending an &lt;code&gt;'i'&lt;/code&gt; to the end of the match. Then &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; can be rewritten as &lt;code&gt;/yes/i;&lt;/code&gt; . The &lt;code&gt;'i'&lt;/code&gt; stands for case-insensitive and is an example of a</source>
          <target state="translated">此正则表达式显示一项常见任务：执行不区分大小写的匹配。Perl提供了一种避免所有这些括号的方法，只需在比赛的末尾附加一个 &lt;code&gt;'i'&lt;/code&gt; 即可。然后 &lt;code&gt;/[yY][eE][sS]/;&lt;/code&gt; 可以改写为 &lt;code&gt;/yes/i;&lt;/code&gt; 。所述 &lt;code&gt;'i'&lt;/code&gt; 表示不区分大小写的，并且是的一个例子</target>
        </trans-unit>
        <trans-unit id="f039b2c10f0c743bc7161531bc5bb4ee7cf32e0f" translate="yes" xml:space="preserve">
          <source>This regexp matches at the earliest string position, &lt;code&gt;'T'&lt;/code&gt; . One might think that &lt;code&gt;e&lt;/code&gt; , being leftmost in the alternation, would be matched, but &lt;code&gt;r&lt;/code&gt; produces the longest string in the first quantifier.</source>
          <target state="translated">此正则表达式在最早的字符串位置 &lt;code&gt;'T'&lt;/code&gt; 匹配。可能会认为 &lt;code&gt;e&lt;/code&gt; 在交替中最左端会被匹配，但是 &lt;code&gt;r&lt;/code&gt; 在第一个量词中产生最长的字符串。</target>
        </trans-unit>
        <trans-unit id="a7d61ce1428d48124b4e47e558b037fdd3f04877" translate="yes" xml:space="preserve">
          <source>This registers warning categories for the given names and is primarily for use by the warnings::register pragma.</source>
          <target state="translated">它为给定的名字注册警告类别,主要用于警告::register pragma。</target>
        </trans-unit>
        <trans-unit id="ac7da667100d67a773306ce2d3526ac0aaefa222" translate="yes" xml:space="preserve">
          <source>This release (5.14) uses &lt;code&gt;unix&lt;/code&gt; as the bottom layer on Win32, and so still uses the C compiler's numeric file descriptor routines. There is an experimental native &lt;code&gt;win32&lt;/code&gt; layer, which is expected to be enhanced and should eventually become the default under Win32.</source>
          <target state="translated">此版本（5.14）使用 &lt;code&gt;unix&lt;/code&gt; 作为Win32的底层，因此仍使用C编译器的数字文件描述符例程。有一个实验性的本机 &lt;code&gt;win32&lt;/code&gt; 层，有望得到增强，最终应成为Win32下的默认层。</target>
        </trans-unit>
        <trans-unit id="08e93ba339b839f549405138c86c3e7a085e38a6" translate="yes" xml:space="preserve">
          <source>This release of Storable can be used on a newer version of Perl to serialize data which is not supported by earlier Perls. By default, Storable will attempt to do the right thing, by &lt;code&gt;croak()&lt;/code&gt; ing if it encounters data that it cannot deserialize. However, the defaults can be changed as follows:</source>
          <target state="translated">可以在较新版本的Perl上使用此版本的Storable来序列化早期Perls不支持的数据。默认情况下，如果Storable 遇到无法反序列化的数据，它将通过 &lt;code&gt;croak()&lt;/code&gt; 尝试做正确的事情。但是，可以如下更改默认值：</target>
        </trans-unit>
        <trans-unit id="2d1b77b3467fa5b58df05f447b8e32028382b1ea" translate="yes" xml:space="preserve">
          <source>This relies on the fact that uninitialized array elements are set to NULL.</source>
          <target state="translated">这依赖于未初始化的数组元素被设置为NULL的事实。</target>
        </trans-unit>
        <trans-unit id="9d7d55aad79de70107f3e8211b62fbf8c98570e5" translate="yes" xml:space="preserve">
          <source>This renders a print statement, which includes a call to the function. It's identical to rendering a file with a use call and that single statement, except for the filename which appears in the nextstate ops.</source>
          <target state="translated">这将渲染一条打印语句,其中包括对函数的调用。这与渲染一个带有使用调用和单一语句的文件是一样的,只是文件名会出现在 nextstate ops 中。</target>
        </trans-unit>
        <trans-unit id="ea6f5b9409b135d9fd2914f5e9712bb211e3d415" translate="yes" xml:space="preserve">
          <source>This renders all functions in the B::Concise package with the source lines. It eschews the O framework so that the stashref can be passed directly to B::Concise::compile(). See -stash option for a more convenient way to render a package.</source>
          <target state="translated">它可以渲染 B::Concise 包中的所有函数的源代码行。它避开了 O 框架,因此 stashref 可以直接传递给 B::Concise::compile()。参见 -stash 选项以获得更方便的渲染包的方法。</target>
        </trans-unit>
        <trans-unit id="65869e50f6892b08c4cf7dcb78cc5963bf748c6b" translate="yes" xml:space="preserve">
          <source>This requires &lt;code&gt;perl-5.8&lt;/code&gt; or higher, compiled with &lt;code&gt;perlio&lt;/code&gt;</source>
          <target state="translated">这需要 &lt;code&gt;perl-5.8&lt;/code&gt; 或更高版本（使用 &lt;code&gt;perlio&lt;/code&gt; 编译）</target>
        </trans-unit>
        <trans-unit id="cf4909d18f4323c37d07bae96a1d0080562f63f5" translate="yes" xml:space="preserve">
          <source>This requires require a 64-bit MIPS CPU (R8000, R10000, ...)</source>
          <target state="translated">这需要一个64位的MIPS CPU (R8000,R10000,...)</target>
        </trans-unit>
        <trans-unit id="f7da7513031db644267fa4b13fabe99ed2a030c7" translate="yes" xml:space="preserve">
          <source>This restores one of the standard line-styles: &lt;code&gt;terse&lt;/code&gt; , &lt;code&gt;concise&lt;/code&gt; , &lt;code&gt;linenoise&lt;/code&gt; , &lt;code&gt;debug&lt;/code&gt; , &lt;code&gt;env&lt;/code&gt; , into effect. It also accepts style names previously defined with add_style().</source>
          <target state="translated">这将恢复标准线样式之一： &lt;code&gt;terse&lt;/code&gt; ， &lt;code&gt;concise&lt;/code&gt; ， &lt;code&gt;linenoise&lt;/code&gt; ， &lt;code&gt;debug&lt;/code&gt; ， &lt;code&gt;env&lt;/code&gt; ，生效。它还接受以前用add_style（）定义的样式名称。</target>
        </trans-unit>
        <trans-unit id="f0559182bda8492a3ca4dae9b14b73dc55291956" translate="yes" xml:space="preserve">
          <source>This restores the default behavior after you've changed it with '-main' (it's not normally needed). If no subroutine name/ref is given, main is rendered, regardless of this flag.</source>
          <target state="translated">当你用'-main'改变了默认行为后,它将恢复默认行为(通常不需要)。如果没有给出子程序的名称/引用,则不管这个标志如何,main都会被渲染。</target>
        </trans-unit>
        <trans-unit id="f49545d47b4c2e67130feb223d7916803e2151e7" translate="yes" xml:space="preserve">
          <source>This restores the token object(s) to the front of the parser stream.</source>
          <target state="translated">这将令牌对象还原到解析器流的前面。</target>
        </trans-unit>
        <trans-unit id="438306ebd9d1acbe91b86dc11907f9e6dab643b7" translate="yes" xml:space="preserve">
          <source>This returns NULL if the variable does not exist.</source>
          <target state="translated">如果变量不存在,则返回NULL。</target>
        </trans-unit>
        <trans-unit id="c37bfa051bc09e91f6aa8c8e068658f22a9b05b4" translate="yes" xml:space="preserve">
          <source>This returns a glob reference for the symbol table entry of VARNAME in the package of the compartment. VARNAME must be the &lt;b&gt;name&lt;/b&gt; of a variable without any leading type marker. For example:</source>
          <target state="translated">这将返回隔离专区包中VARNAME的符号表条目的全局引用。VARNAME必须是没有任何前导类型标记的变量的&lt;b&gt;名称&lt;/b&gt;。例如：</target>
        </trans-unit>
        <trans-unit id="4846a06785f0daaeee2213d80f23082c8fa4965c" translate="yes" xml:space="preserve">
          <source>This returns a handy stringified value of this object. This is useful for debugging, as in:</source>
          <target state="translated">这将返回这个对象的一个方便的字符串化值。这对调试很有用,比如说。</target>
        </trans-unit>
        <trans-unit id="b1ea704d04f7c3ec75b7f4e64aa2fc6d627bedce" translate="yes" xml:space="preserve">
          <source>This returns a list of the elements of the op's aux data structure, or a null list if there is no aux. What will be returned depends on the object's type, but will typically be a collection of &lt;code&gt;B::IV&lt;/code&gt; , &lt;code&gt;B::GV&lt;/code&gt; , etc. objects. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">这将返回op的aux数据结构的元素列表，如果没有aux，则返回空列表。返回的内容取决于对象的类型，但通常是 &lt;code&gt;B::IV&lt;/code&gt; ， &lt;code&gt;B::GV&lt;/code&gt; 等对象的集合。 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;B::CV&lt;/code&gt; 对象，表示op所包含的子对象。</target>
        </trans-unit>
        <trans-unit id="78c4d2eacb966527e478f0083cb85da673514051" translate="yes" xml:space="preserve">
          <source>This returns a list of the names of all the installed modules. The perl 'core' is given the special name 'Perl'.</source>
          <target state="translated">这将返回一个所有安装模块的名称列表。perl的 &quot;core &quot;被赋予了特殊的名称 &quot;Perl&quot;。</target>
        </trans-unit>
        <trans-unit id="a39fe91e6096e4528d2eface949d54878f13adb3" translate="yes" xml:space="preserve">
          <source>This returns a new parser object, where</source>
          <target state="translated">这将返回一个新的解析器对象,其中的</target>
        </trans-unit>
        <trans-unit id="c0e359e0a6bfe07d5ae556f45550772e1dc21138" translate="yes" xml:space="preserve">
          <source>This returns a normal Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.</source>
          <target state="translated">这个函数从$x返回一个普通的Perl标量。每当需要标量的时候,比如在数组索引操作中,就会自动使用它。</target>
        </trans-unit>
        <trans-unit id="4bedda000844c8f0e165c8e9491e25dc6f787dac" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has short general category names (such as &lt;code&gt;Lu&lt;/code&gt; , &lt;code&gt;Nd&lt;/code&gt; , &lt;code&gt;Zs&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;UppercaseLetter&lt;/code&gt; , &lt;code&gt;DecimalNumber&lt;/code&gt; , &lt;code&gt;SpaceSeparator&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The general category is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;category&lt;/code&gt; key.</source>
          <target state="translated">这将返回对哈希的引用，该哈希具有短的常规类别名称（例如 &lt;code&gt;Lu&lt;/code&gt; ， &lt;code&gt;Nd&lt;/code&gt; ， &lt;code&gt;Zs&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; ）作为键，而长名称（例如 &lt;code&gt;UppercaseLetter&lt;/code&gt; ， &lt;code&gt;DecimalNumber&lt;/code&gt; ， &lt;code&gt;SpaceSeparator&lt;/code&gt; ， &lt;code&gt;Symbol&lt;/code&gt; ）作为值。如果您需要从长名称到短名称，则哈希是可逆的。常规类别是在 &lt;code&gt;category&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的类别。</target>
        </trans-unit>
        <trans-unit id="88c58feecc3765e5c4080f925afe0ce2010395de" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; ) as keys and long names (such as &lt;code&gt;Left-to-Right&lt;/code&gt; , &lt;code&gt;Right-to-Left&lt;/code&gt; ) as values. The hash is reversible in case you need to go from the long names to the short names. The bidi type is the one returned from &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; under the &lt;code&gt;bidi&lt;/code&gt; key. For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http://www.unicode.org/reports/tr9/&lt;/a&gt; (as of Unicode 5.0.0)</source>
          <target state="translated">这将返回对哈希的引用，该哈希的简称为双向（即双向）类型名称（例如 &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ），而长名称（例如 &lt;code&gt;Left-to-Right&lt;/code&gt; ， &lt;code&gt;Right-to-Left&lt;/code&gt; ）为值。如果您需要从长名称到短名称，则哈希是可逆的。 bidi类型是在 &lt;code&gt;bidi&lt;/code&gt; 键下从&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的类型。对于各种比迪烟类的确切含义，建议阅读Unicode TR9：&lt;a href=&quot;http://www.unicode.org/reports/tr9/&quot;&gt;http&lt;/a&gt; : //www.unicode.org/reports/tr9/（从Unicode 5.0.0开始）</target>
        </trans-unit>
        <trans-unit id="9b6e4381af622706d0b561391364ef549fe16051" translate="yes" xml:space="preserve">
          <source>This returns a reference to a hash whose keys are all the distinct Unicode (no Perl extension) properties, and whose values are the respective values for those properties for the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;.</source>
          <target state="translated">这将返回对哈希的引用，该哈希的键都是唯一的Unicode（无Perl扩展名）属性，其值是输入&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数的&lt;/a&gt;那些属性的相应值。</target>
        </trans-unit>
        <trans-unit id="92aa49cb1c3f622edac6a155f13e38f83b6dfb08" translate="yes" xml:space="preserve">
          <source>This returns a scalar reference to the string that this token holds. This can be useful if you don't want to memory-copy the potentially large text value (well, as large as a paragraph or a verbatim block) as calling $token-&amp;gt;text would do.</source>
          <target state="translated">这将返回对该令牌保存的字符串的标量引用。如果您不希望像调用$ token-&amp;gt; text那样，对内存中潜在的大文本值（以及与段落或逐字记录块一样大）进行内存复制，则此功能很有用。</target>
        </trans-unit>
        <trans-unit id="78d7fbfdd37ad836b426c426d9f57674d28b607c" translate="yes" xml:space="preserve">
          <source>This returns a textual representation of the object (likely to b useful for deparsing and debugging), or an empty string if the op type doesn't support this. &lt;code&gt;cv&lt;/code&gt; is the &lt;code&gt;B::CV&lt;/code&gt; object representing the sub that the op is contained within.</source>
          <target state="translated">这将返回对象的文本表示形式（可能对于b的解析和调试很有用），或者如果op类型不支持此字符串，则返回空字符串。 &lt;code&gt;cv&lt;/code&gt; 是 &lt;code&gt;B::CV&lt;/code&gt; 对象，表示op所包含的子对象。</target>
        </trans-unit>
        <trans-unit id="5163e24143304da0c24ab6f05ddab5463a924808" translate="yes" xml:space="preserve">
          <source>This returns all the case foldings in the current version of Unicode in the form of a reference to a hash. Each key to the hash is the decimal representation of a Unicode character that has a casefold to other than itself. The casefold of a semi-colon is itself, so it isn't in the hash; likewise for a lowercase &quot;a&quot;, but there is an entry for a capital &quot;A&quot;. The hash value for each key is another hash, identical to what is returned by &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; if called with that code point as its argument. So the value &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; is equivalent to &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</source>
          <target state="translated">这将以对哈希的引用形式返回当前版本Unicode中的所有大小写折叠。哈希的每个键都是Unicode字符的十进制表示形式，除了自身以外，还有其他大小写。分号的大小写是其自身，因此不在哈希表中。小写字母&amp;ldquo; a&amp;rdquo;也是如此，但是大写字母&amp;ldquo; A&amp;rdquo;存在一个条目。每个键的哈希值是另一个哈希，如果以该代码点作为其参数调用，则与&lt;a href=&quot;#casefold()&quot;&gt;casefold（）&lt;/a&gt;返回的哈希相同。因此，值 &lt;code&gt;all_casefolds()-&amp;gt;{&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;)}'&lt;/code&gt; 等同于 &lt;code&gt;casefold(&lt;a href=&quot;../functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;A&quot;))&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="cc96752d9a4198cd2cf54c44f2b3b5b10b6e33c5" translate="yes" xml:space="preserve">
          <source>This returns information about the input &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; as a reference to a hash of fields as defined by the Unicode standard. If the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; is not assigned in the standard (i.e., has the general category &lt;code&gt;Cn&lt;/code&gt; meaning &lt;code&gt;Unassigned&lt;/code&gt; ) or is a non-character (meaning it is guaranteed to never be assigned in the standard), &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">这将返回有关输入&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数的&lt;/a&gt;信息，作为对Unicode标准定义的字段哈希的引用。如果&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;未在标准中分配（即，通用类别 &lt;code&gt;Cn&lt;/code&gt; 表示 &lt;code&gt;Unassigned&lt;/code&gt; ）或为非字符（表示保证从不在标准中分配），则返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb91ab331ab9de210b4db7e921e9ff160732003a" translate="yes" xml:space="preserve">
          <source>This returns the (almost) locale-independent case folding of the character specified by the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. (Starting in Perl v5.16, the core function &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; returns the &lt;code&gt;full&lt;/code&gt; mapping (described below) faster than this does, and for entire strings.)</source>
          <target state="translated">这将返回由&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;指定的字符的（几乎）与语言环境无关的大小写折叠。（从Perl v5.16开始，核心函数 &lt;code&gt;&lt;a href=&quot;../functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;full&lt;/code&gt; 映射（如下所述）的速度比这样做更快，并且返回的是整个字符串。）</target>
        </trans-unit>
        <trans-unit id="91677229ee695edb8db59966a9bf52f69db7141f" translate="yes" xml:space="preserve">
          <source>This returns the ExtUtils::Packlist object for the specified module.</source>
          <target state="translated">返回指定模块的ExtUtils::Packlist对象。</target>
        </trans-unit>
        <trans-unit id="91c8292002290e5d7ad79eff5f6aca62a17b0302" translate="yes" xml:space="preserve">
          <source>This returns the file format version as number. It is a string like &quot;2.007&quot;. This value is suitable for numeric comparisons.</source>
          <target state="translated">这将以数字形式返回文件格式版本。它是一个字符串,如 &quot;2.007&quot;。这个值适合于数字比较。</target>
        </trans-unit>
        <trans-unit id="b28a3d3b844d30822d117ab98847259c42e20f28" translate="yes" xml:space="preserve">
          <source>This returns the file format version. It is a string like &quot;2.7&quot;.</source>
          <target state="translated">这将返回文件格式版本。它是一个字符串,如 &quot;2.7&quot;。</target>
        </trans-unit>
        <trans-unit id="88abd5e16e9b3ba61f0f89ea977172fa6b064d17" translate="yes" xml:space="preserve">
          <source>This returns the filename that this parser object was set to read from.</source>
          <target state="translated">返回这个解析器对象被设置为读取的文件名。</target>
        </trans-unit>
        <trans-unit id="bccff29a1ac784a814e5e53a8041bdec5c902b0f" translate="yes" xml:space="preserve">
          <source>This returns the full path of the first occurrence to the file. Package names (eg 'A::B') are automatically converted to directory names in the selected directory. Additionally, '.pm', '.pl' and '.pod' are automatically appended to the search as required. (So, for example, under Unix, &quot;A::B&quot; is converted to &quot;somedir/A/B.pm&quot;, &quot;somedir/A/B.pod&quot;, or &quot;somedir/A/B.pl&quot;, as appropriate.)</source>
          <target state="translated">这将返回第一次出现的文件的完整路径。包名(例如'A::B')会自动转换为所选目录中的目录名。此外,'.pm'、'.pl'和'.pod'会根据需要自动附加到搜索中。(所以,例如,在 Unix 下,&quot;A::B &quot;会被转换为 &quot;somedir/A/B.pm&quot;、&quot;somedir/A/B.pod &quot;或 &quot;somedir/A/B.pl&quot;,视情况而定。)</target>
        </trans-unit>
        <trans-unit id="2a501f04d237b4afdc751c24d97b1564c6c9be99" translate="yes" xml:space="preserve">
          <source>This returns the function name as a string (e.g. &quot;PL_ppaddr[OP_ADD]&quot;, &quot;PL_ppaddr[OP_RV2AV]&quot;).</source>
          <target state="translated">这将返回一个字符串的函数名称(例如 &quot;PL_ppaddr[OP_ADD]&quot;,&quot;PL_ppaddr[OP_RV2AV]&quot;)。</target>
        </trans-unit>
        <trans-unit id="a6c7ba8cdf1911985e871524f867f03a73878f39" translate="yes" xml:space="preserve">
          <source>This returns the given noun form which is appropriate for the quantity &lt;code&gt;$number&lt;/code&gt; according to this language's conventions. &lt;code&gt;numerate&lt;/code&gt; is used internally by &lt;code&gt;quant&lt;/code&gt; to quantify nouns. Use it directly -- usually from bracket notation -- to avoid &lt;code&gt;quant&lt;/code&gt; 's implicit call to &lt;code&gt;numf&lt;/code&gt; and output of a numeric quantity.</source>
          <target state="translated">根据该语言的约定，这将返回给定的名词形式，该形式适合于数量 &lt;code&gt;$number&lt;/code&gt; 。 &lt;code&gt;numerate&lt;/code&gt; 在内部由 &lt;code&gt;quant&lt;/code&gt; 用来量化名词。直接使用它-通常从方括号符号起-避免 &lt;code&gt;quant&lt;/code&gt; 对 &lt;code&gt;numf&lt;/code&gt; 的隐式调用和数字量的输出。</target>
        </trans-unit>
        <trans-unit id="9ecd76e9b7635df85484a01189e6a2f492cf6d79" translate="yes" xml:space="preserve">
          <source>This returns the given number formatted nicely according to this language's conventions. Maketext's default method is mostly to just take the normal string form of the number (applying sprintf &quot;%G&quot; for only very large numbers), and then to add commas as necessary. (Except that we apply &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; if $language-&amp;gt;{'numf_comma'} is true; that's a bit of a hack that's useful for languages that express two million as &quot;2.000.000&quot; and not as &quot;2,000,000&quot;).</source>
          <target state="translated">这将返回给定的数字，该数字按照该语言的约定很好地格式化。Maketext的默认方法主要是采用数字的常规字符串形式（仅对非常大的数字应用sprintf&amp;ldquo;％G&amp;rdquo;），然后根据需要添加逗号。（除了如果$ language-&amp;gt; {'numf_comma'}为true时，我们将应用 &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr/,./.,/&lt;/a&gt;&lt;/code&gt; ；这是一个小技巧，对于将200万表示为&amp;ldquo; 2.000.000&amp;rdquo;而不是&amp;ldquo; 2,000,000&amp;ldquo;）。</target>
        </trans-unit>
        <trans-unit id="025fac90217d4ce617ea39a22bf3a99d01ca61a8" translate="yes" xml:space="preserve">
          <source>This returns the hashref that is the attribute set for this start-token. This is useful if (for example) you want to ask what all the attributes are -- you can just do &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</source>
          <target state="translated">这将返回hashref，它是为此起始令牌设置的属性。如果（例如）您想询问所有属性是什么，这很有用-您可以只做 &lt;code&gt;&lt;a href=&quot;../../functions/keys&quot;&gt;keys&lt;/a&gt; %{$token-&amp;gt;attr_hash}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a1d54ba9e2a0e72117dea2ff05555485f06342" translate="yes" xml:space="preserve">
          <source>This returns the name of the associated .packlist file</source>
          <target state="translated">这将返回相关的.packlist文件的名称。</target>
        </trans-unit>
        <trans-unit id="8714a4ea9c89be9e02bb0a484046217a2fdc2659" translate="yes" xml:space="preserve">
          <source>This returns the next token object (which will be of a subclass of &lt;a href=&quot;pullparsertoken&quot;&gt;Pod::Simple::PullParserToken&lt;/a&gt;), or undef if the parser-stream has hit the end of the document.</source>
          <target state="translated">这将返回下一个标记对象（将是&lt;a href=&quot;pullparsertoken&quot;&gt;Pod :: Simple :: PullParserToken&lt;/a&gt;的子类），如果解析器流到达文档的末尾，则返回undef。</target>
        </trans-unit>
        <trans-unit id="db9439ac80b35bc802acd8f20ce2c7390e307d09" translate="yes" xml:space="preserve">
          <source>This returns the op description from the global C PL_op_desc array (e.g. &quot;addition&quot; &quot;array deref&quot;).</source>
          <target state="translated">返回全局C语言PL_op_desc数组中的操作描述(例如 &quot;addition&quot;&quot;array deref&quot;)。</target>
        </trans-unit>
        <trans-unit id="5681c12774f7d1547e4176d6eccb3ccd12074a1f" translate="yes" xml:space="preserve">
          <source>This returns the op name as a string (e.g. &quot;add&quot;, &quot;rv2av&quot;).</source>
          <target state="translated">这将返回一个字符串的操作名称(例如 &quot;add&quot;,&quot;rv2av&quot;)。</target>
        </trans-unit>
        <trans-unit id="7c24d1c30b8541d36722cb533fdf5d0b9d4b051d" translate="yes" xml:space="preserve">
          <source>This returns the potentially locale-dependent case mappings of the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;. The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; never are).</source>
          <target state="translated">这将返回&lt;a href=&quot;#code-point-argument&quot;&gt;代码点参数&lt;/a&gt;的可能与语言环境相关的大小写映射。映射可能比单个代码点长（&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;返回的基本Unicode大小写映射从来都不是）。</target>
        </trans-unit>
        <trans-unit id="e407d9572ab9c5f99771767ba652986d36609117" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this end-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">这将返回这个结束标记对象的tagname。例如,解析&quot;=head1 ...&quot;行,会得到一个带有 &quot;head1 &quot;tagname的起始标记、内容的标记,以及带有 &quot;head1 &quot;tagname的结束标记。</target>
        </trans-unit>
        <trans-unit id="1457f9cf582cb43f3b8ece06b77a4a774ea5edd5" translate="yes" xml:space="preserve">
          <source>This returns the tagname for this start-token object. For example, parsing a &quot;=head1 ...&quot; line will give you a start-token with the tagname of &quot;head1&quot;, token(s) for its content, and then an end-token with the tagname of &quot;head1&quot;.</source>
          <target state="translated">这将返回这个起始标记对象的tagname。例如,解析&quot;=head1 ...&quot;行会得到一个带有 &quot;head1 &quot;tagname的起始标记、内容的标记,以及带有 &quot;head1 &quot;tagname的结束标记。</target>
        </trans-unit>
        <trans-unit id="a92df26815537e43f9c0925776fd61d439836096" translate="yes" xml:space="preserve">
          <source>This returns the text that this token holds. For example, parsing C&amp;lt;foo&amp;gt; will return a C start-token, a text-token, and a C end-token. And if you want to get the &quot;foo&quot; out of the text-token, call &lt;code&gt;$token-&amp;gt;text&lt;/code&gt;</source>
          <target state="translated">这将返回该令牌保存的文本。例如，解析C &amp;lt;foo&amp;gt;将返回C起始令牌，文本令牌和C终止令牌。如果 &lt;code&gt;$token-&amp;gt;text&lt;/code&gt; 令牌中删除&amp;ldquo; foo&amp;rdquo;，请调用$ token-&amp;gt; text</target>
        </trans-unit>
        <trans-unit id="37adaa267b32499cf66804411e8414b1ad1805e1" translate="yes" xml:space="preserve">
          <source>This returns the thread's context in the same manner as &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;.</source>
          <target state="translated">这将以与&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;相同的方式返回线程的上下文。</target>
        </trans-unit>
        <trans-unit id="e65fe0dbb6e214f3cd7dbd02a6dc6c382b0c30da" translate="yes" xml:space="preserve">
          <source>This returns the type of the token. This will be either the string &quot;start&quot;, the string &quot;text&quot;, or the string &quot;end&quot;.</source>
          <target state="translated">返回token的类型,可以是字符串 &quot;start&quot;、字符串 &quot;text &quot;或字符串 &quot;end&quot;。可以是字符串 &quot;start&quot;、字符串 &quot;text &quot;或字符串 &quot;end&quot;。</target>
        </trans-unit>
        <trans-unit id="11b6f6f063cb5805a948af38969c126392d218a6" translate="yes" xml:space="preserve">
          <source>This returns the value of the</source>
          <target state="translated">这将返回</target>
        </trans-unit>
        <trans-unit id="6e7567ac847e3dd9703ee4f767f192a1f4433a0b" translate="yes" xml:space="preserve">
          <source>This returns the value of the Unicode property given by the second parameter for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; given by the first.</source>
          <target state="translated">这将为第&lt;a href=&quot;#code-point-argument&quot;&gt;一个参数&lt;/a&gt;指定的代码点参数返回第二个参数指定的Unicode属性值。</target>
        </trans-unit>
        <trans-unit id="00254886c0f76de134b6342f6c209f119eee2c52" translate="yes" xml:space="preserve">
          <source>This returns the version number for the specified module.</source>
          <target state="translated">返回指定模块的版本号。</target>
        </trans-unit>
        <trans-unit id="28cb21f0ce04fc34237dafa4d05afb66efd55c58" translate="yes" xml:space="preserve">
          <source>This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements. The version is a string of numbers delimited by dots (&lt;code&gt;'.'&lt;/code&gt; ).</source>
          <target state="translated">这将返回Unicode字符数据库的版本，换句话说，即数据库实现的Unicode标准的版本。版本是一串由点（ &lt;code&gt;'.'&lt;/code&gt; ）分隔的数字。</target>
        </trans-unit>
        <trans-unit id="0537cb9604bd46fdc53aedf1ef4d31156ea69d21" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and come to the end of that source.</source>
          <target state="translated">如果 &lt;code&gt;$parser&lt;/code&gt; 已从某个源中读取并到达该源的末尾，则返回true 。</target>
        </trans-unit>
        <trans-unit id="d892085e64119e5b73847e052d7936e4ec27fd45" translate="yes" xml:space="preserve">
          <source>This returns true if &lt;code&gt;$parser&lt;/code&gt; has read from a source, and has seen Pod content in it.</source>
          <target state="translated">如果 &lt;code&gt;$parser&lt;/code&gt; 已从源中读取并看到其中的Pod内容，则返回true 。</target>
        </trans-unit>
        <trans-unit id="0b811ea00850392c2bee3b4f40af1e1b677b7142" translate="yes" xml:space="preserve">
          <source>This returns true only if there has been any real content seen for this document. Returns false in cases where the document contains content, but does not make use of any Pod markup.</source>
          <target state="translated">只有当这个文档有真正的内容时,才返回true。如果文档包含内容,但没有使用任何Pod标记,则返回false。</target>
        </trans-unit>
        <trans-unit id="e28605a00b749132376858f485353c17ca2a0f0d" translate="yes" xml:space="preserve">
          <source>This routine also returns a different number of arguments depending on the success or failure of the call to statfs. If there is an error, the error number is returned as a single-element array. If the call is successful, then a 7-element array is returned. Since only one argument is passed into this function, we need room on the stack to hold the 7 values which may be returned.</source>
          <target state="translated">这个例程也会根据调用statfs的成功或失败返回不同数量的参数。如果出现错误,错误号将作为一个单元素数组返回。如果调用成功,则返回一个7元素数组。由于只有一个参数被传递到这个函数中,我们需要在堆栈中留出空间来容纳可能被返回的7个值。</target>
        </trans-unit>
        <trans-unit id="5b820e747b00eb7161f8b3a6555a694bd263c329" translate="yes" xml:space="preserve">
          <source>This routine behaves identically to the final two forms. That is, it does not return &lt;b&gt;true&lt;/b&gt; if the code point has a decomposition consisting of another single code point, nor if its decomposition starts with a code point whose combining class is non-zero. Code points that meet either of these conditions should also not be produced by composition normalization, which is probably why you should use the &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; property instead, as shown above.</source>
          <target state="translated">此例程的行为与最后两种形式相同。也就是说，如果代码点具有由另一个单个代码点组成的分解，或者其分解开始于其组合类别为非零的代码点，则它不会返回&lt;b&gt;true&lt;/b&gt;。满足上述任一条件的代码点也不应通过合成规范化来生成，这可能就是为什么您应该改用 &lt;code&gt;Full_Composition_Exclusion&lt;/code&gt; 属性的原因，如上所示。</target>
        </trans-unit>
        <trans-unit id="e6cbcd70e8dd9e2b5edee3c69038ed73e9a903ad" translate="yes" xml:space="preserve">
          <source>This routine checks to see what types of magic &lt;code&gt;sv&lt;/code&gt; has. If the mg_type field is an uppercase letter, then the mg_obj is copied to &lt;code&gt;nsv&lt;/code&gt; , but the mg_type field is changed to be the lowercase letter.</source>
          <target state="translated">该例程检查以查看魔术 &lt;code&gt;sv&lt;/code&gt; 的类型。如果mg_type字段是大写字母，则mg_obj将被复制到 &lt;code&gt;nsv&lt;/code&gt; ，但mg_type字段将变为小写字母。</target>
        </trans-unit>
        <trans-unit id="156fe43e5f5152548ce6f33bee1b7f0723071b2f" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns a list of attributes, which may be empty. If passed invalid arguments, it uses die() (via &lt;a href=&quot;carp&quot;&gt;Carp::croak&lt;/a&gt;) to raise a fatal exception. If it can find an appropriate package name for a class method lookup, it will include the results from a &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; call in its return list, as described in &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below. Otherwise, only &lt;a href=&quot;#Built-in-Attributes&quot;&gt;built-in attributes&lt;/a&gt; will be returned.</source>
          <target state="translated">该例程需要一个参数-对子例程或变量的引用。它返回属性列表，该列表可能为空。如果传递了无效的参数，它将使用die（）（通过&lt;a href=&quot;carp&quot;&gt;Carp :: croak&lt;/a&gt;）引发致命异常。如果它可以为类方法查找找到合适的包名称，则它将在其返回列表中包括来自 &lt;code&gt;FETCH_&lt;i&gt;type&lt;/i&gt;_ATTRIBUTES&lt;/code&gt; 调用的结果，如下面&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;的特定&lt;/a&gt;于包的属性处理中所述。否则，将仅返回&lt;a href=&quot;#Built-in-Attributes&quot;&gt;内置属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1cbd8c6e15630953581b673b778fa0654a81555" translate="yes" xml:space="preserve">
          <source>This routine expects a single parameter--a reference to a subroutine or variable. It returns the built-in type of the referenced variable, ignoring any package into which it might have been blessed. This can be useful for determining the</source>
          <target state="translated">这个例程只需要一个参数--一个对子程序或变量的引用,它返回被引用变量的内置类型,忽略任何可能被祝福的包。它返回被引用变量的内置类型,忽略它可能已经被装入的任何包。这对于确定变量的</target>
        </trans-unit>
        <trans-unit id="a441bbdb5a22183756c86532b0bd8538c60db634" translate="yes" xml:space="preserve">
          <source>This routine is automatically used whenever a scalar is required:</source>
          <target state="translated">每当需要标量时,就会自动使用这个例程。</target>
        </trans-unit>
        <trans-unit id="af05f40d5a349a9cf28386764e38317c02e23a0c" translate="yes" xml:space="preserve">
          <source>This routine provides word completion on the list of words in the array (or array ref).</source>
          <target state="translated">这个例程为数组(或数组ref)中的单词列表提供单词完成。</target>
        </trans-unit>
        <trans-unit id="a12916af343198cbe644e34418361cddb6245ff7" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the Unicode version being used is so early that it doesn't have this property.</source>
          <target state="translated">如果所使用的Unicode版本太早以至于它没有此属性，则此例程将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="101ceccec63478c5c011c3caa8244abb6108d41c" translate="yes" xml:space="preserve">
          <source>This routine returns a pointer to a &lt;code&gt;MAGIC&lt;/code&gt; structure stored in the SV. If the SV does not have that magical feature, &lt;code&gt;NULL&lt;/code&gt; is returned. If the SV has multiple instances of that magical feature, the first one will be returned. &lt;code&gt;mg_findext&lt;/code&gt; can be used to find a &lt;code&gt;MAGIC&lt;/code&gt; structure of an SV based on both its magic type and its magic virtual table:</source>
          <target state="translated">该例程返回指向存储在SV中的 &lt;code&gt;MAGIC&lt;/code&gt; 结构的指针。如果SV不具备该功能，则返回 &lt;code&gt;NULL&lt;/code&gt; 。如果SV具有该魔术功能的多个实例，则将返回第一个。 &lt;code&gt;mg_findext&lt;/code&gt; 可用于根据其魔术类型和魔术虚拟表查找SV 的 &lt;code&gt;MAGIC&lt;/code&gt; 结构：</target>
        </trans-unit>
        <trans-unit id="be064f7d7fc8c5c81c03e6f7693444f3da761d4d" translate="yes" xml:space="preserve">
          <source>This runs all the given</source>
          <target state="translated">这将运行所有给定的</target>
        </trans-unit>
        <trans-unit id="5f9d330768a086b11c3fee8aaebb21d2fcbcb969" translate="yes" xml:space="preserve">
          <source>This runs some basic sanity tests on the source tree and helps catch basic errors before you submit a patch.</source>
          <target state="translated">这将在源代码树上运行一些基本的理智性测试,有助于在提交补丁之前发现基本错误。</target>
        </trans-unit>
        <trans-unit id="b456dbbb28104ac1fe79034d2719d013d951db2d" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;#chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">此更安全的&lt;a href=&quot;#chop&quot;&gt;印章&lt;/a&gt;版本将删除任何与 &lt;code&gt;$/&lt;/code&gt; 当前值相对应的结尾字符串（在 &lt;code&gt;English&lt;/code&gt; 模块中也称为$ INPUT_RECORD_SEPARATOR ）。它返回从其所有参数中删除的字符总数。当您担心最终记录可能缺少其换行符时，通常用于从输入记录的末尾删除换行符。在段落模式下（ &lt;code&gt;$/ = ''&lt;/code&gt; ），它将从字符串中删除所有结尾的换行符。当处于slurp模式（ &lt;code&gt;$/ = &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）或固定长度记录模式（ &lt;code&gt;$/&lt;/code&gt; 是对整数等的引用；请参见&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;）时，chomp（）不会删除任何内容。如果省略了VARIABLE，它将砍掉 &lt;code&gt;$_&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="ade7671cda06ea60596db7de673c42e7e9809682" translate="yes" xml:space="preserve">
          <source>This safer version of &lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt; removes any trailing string that corresponds to the current value of &lt;code&gt;$/&lt;/code&gt; (also known as $INPUT_RECORD_SEPARATOR in the &lt;code&gt;English&lt;/code&gt; module). It returns the total number of characters removed from all its arguments. It's often used to remove the newline from the end of an input record when you're worried that the final record may be missing its newline. When in paragraph mode (&lt;code&gt;$/ = ''&lt;/code&gt; ), it removes all trailing newlines from the string. When in slurp mode (&lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) or fixed-length record mode (&lt;code&gt;$/&lt;/code&gt; is a reference to an integer or the like; see &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;) chomp() won't remove anything. If VARIABLE is omitted, it chomps &lt;code&gt;$_&lt;/code&gt; . Example:</source>
          <target state="translated">此更安全的&lt;a href=&quot;chop&quot;&gt;印章&lt;/a&gt;版本将删除任何与 &lt;code&gt;$/&lt;/code&gt; 当前值相对应的结尾字符串（在 &lt;code&gt;English&lt;/code&gt; 模块中也称为$ INPUT_RECORD_SEPARATOR ）。它返回从其所有参数中删除的字符总数。当您担心最终记录可能缺少其换行符时，通常用于从输入记录的末尾删除换行符。在段落模式下（ &lt;code&gt;$/ = ''&lt;/code&gt; ），它将从字符串中删除所有结尾的换行符。当处于slurp模式（ &lt;code&gt;$/ = &lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）或固定长度记录模式（ &lt;code&gt;$/&lt;/code&gt; 是对整数等的引用；请参见&lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;）时，chomp（）不会删除任何内容。如果省略了VARIABLE，它将砍掉 &lt;code&gt;$_&lt;/code&gt; 。例：</target>
        </trans-unit>
        <trans-unit id="29322e1fae611c7a4ec6b18f01c0e5539c007dbe" translate="yes" xml:space="preserve">
          <source>This same method is available from pure perl via, &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; .</source>
          <target state="translated">可以从纯perl通过 &lt;code&gt;mro::method_changed_in(classname)&lt;/code&gt; 获得相同的方法。</target>
        </trans-unit>
        <trans-unit id="e7a4db1ab47139698e5958a2175645481a1041ec" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is a reference (ROK), which points to another SV which is a PVAV, an array. The array has one element, element zero, which is another SV. The field &lt;code&gt;FILL&lt;/code&gt; above indicates the last element in the array, similar to &lt;code&gt;$#$a&lt;/code&gt; .</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是引用（ROK），它指向另一个SV，即PVAV，即数组。该数组有一个元素，元素零，这是另一个SV。上方的字段 &lt;code&gt;FILL&lt;/code&gt; 表示数组中的最后一个元素，类似于 &lt;code&gt;$#$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="036ebde834d76ddc89809412a48e08bc1aad5dd1" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar is an IV, a number. Its reference count is 1. It has the &lt;code&gt;IOK&lt;/code&gt; flag set, meaning it is currently being evaluated as a number. Because IOK is set we look at the IV item to see what is in the scalar.</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是SV，一个标量。标量是一个IV，一个数字。它的参考计数为1。它设置了 &lt;code&gt;IOK&lt;/code&gt; 标志，表示当前正在将其评估为数字。因为设置了IOK，所以我们查看IV项以查看标量中的内容。</target>
        </trans-unit>
        <trans-unit id="2536195f9e270d7a0608ccd9b92c67b39acf3e86" translate="yes" xml:space="preserve">
          <source>This says &lt;code&gt;$a&lt;/code&gt; is an SV, a scalar. The scalar type is a PVIV, which is capable of holding an integer (IV) and/or a string (PV) value. The scalar's head is allocated at address 0xbe9a8, while the body is at 0xbc288. Its reference count is 1. It has the &lt;code&gt;POK&lt;/code&gt; flag set, meaning its current PV field is valid. Because POK is set we look at the PV item to see what is in the scalar. The \0 at the end indicate that this PV is properly NUL-terminated. Note that the IV field still contains its old numeric value, but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR indicates the number of characters in the PV. LEN indicates the number of bytes allocated for the PV (at least one more than CUR, because LEN includes an extra byte for the end-of-string marker, then usually rounded up to some efficient allocation unit).</source>
          <target state="translated">这表示 &lt;code&gt;$a&lt;/code&gt; 是SV，一个标量。标量类型是PVIV，它可以保存整数（IV）和/或字符串（PV）值。标量头分配在地址0xbe9a8上，而主体分配在0xbc288上。它的参考计数为1。它具有 &lt;code&gt;POK&lt;/code&gt; 标志设置，表示其当前PV字段有效。由于已设置POK，因此我们查看PV项以查看标量中的内容。末尾的\ 0表示此PV已正确NUL端接。请注意，IV字段仍然包含其旧数值，但是由于FLAGS没有设置IOK，因此我们必须忽略IV项。CUR表示PV中的字符数。LEN指示为PV分配的字节数（至少比CUR多一个，因为LEN为字符串结尾标记包括一个额外的字节，然后通常向上舍入为一个有效的分配单元）。</target>
        </trans-unit>
        <trans-unit id="d4038eb2f65cf90ff5c5db0ff06612a08d942853" translate="yes" xml:space="preserve">
          <source>This says that records are delimited by the string &lt;code&gt;es&lt;/code&gt; . If the file contained the following data:</source>
          <target state="translated">这表示记录由字符串 &lt;code&gt;es&lt;/code&gt; 分隔。如果文件包含以下数据：</target>
        </trans-unit>
        <trans-unit id="c3f732b3da7c2a158f6a684ddbc311ca908a5e5b" translate="yes" xml:space="preserve">
          <source>This says what packages are internal to Perl. &lt;code&gt;Carp&lt;/code&gt; will never report an error as being from a line in a package that is internal to Perl. For example:</source>
          <target state="translated">这说明了Perl内部有哪些软件包。 &lt;code&gt;Carp&lt;/code&gt; 决不会报告错误，因为它来自Perl内部软件包中的一行。例如：</target>
        </trans-unit>
        <trans-unit id="94c9a814257648d20b0d4f2bf7acb2782a18b6ea" translate="yes" xml:space="preserve">
          <source>This says which packages are internal to Perl's warning system. For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; . But it is slightly different for the summary message generated by &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; . There errors will not be reported on any lines that are calling packages in &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">这说明了哪些软件包是Perl的警告系统内部的。为了生成完整的堆栈回溯，这与Perl内部相同，堆栈回溯将不会在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中列出的包内开始。但它是由所生成的摘要信息略有不同 &lt;code&gt;carp&lt;/code&gt; 或 &lt;code&gt;croak&lt;/code&gt; 。在 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 中调用软件包的任何行上都不会报告错误。</target>
        </trans-unit>
        <trans-unit id="31106a1a20d4ea51da0f7d90c3fe4fb2b5ff8f01" translate="yes" xml:space="preserve">
          <source>This scenario will mostly be applicable to code that is meant to be called from within destructors, asynchronous callbacks, and signal handlers. In such situations, where the code being called has little relation to the surrounding dynamic context, the main program needs to be insulated from errors in the called code, even if they can't be handled intelligently. It may also be useful to do this with code for &lt;code&gt;__DIE__&lt;/code&gt; or &lt;code&gt;__WARN__&lt;/code&gt; hooks, and &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">这种情况将最适用于要从析构函数，异步回调和信号处理程序中调用的代码。在这种情况下，被调用的代码与周围的动态上下文关系不大，因此即使无法智能地处理主程序，也需要将主程序与被调用的代码中的错误隔离开来。使用 &lt;code&gt;__DIE__&lt;/code&gt; 或 &lt;code&gt;__WARN__&lt;/code&gt; 钩子以及 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 函数的代码执行此操作也可能很有用。</target>
        </trans-unit>
        <trans-unit id="e17cbd723cbdc191dc4fdc562d2ff451e857ff96" translate="yes" xml:space="preserve">
          <source>This script shows how to override the default sorting algorithm that BTREE uses. Instead of using the normal lexical ordering, a case insensitive compare function will be used.</source>
          <target state="translated">这个脚本展示了如何覆盖 BTREE 使用的默认排序算法。我们将使用一个对大小写不敏感的比较函数,而不是使用正常的词法排序。</target>
        </trans-unit>
        <trans-unit id="af317b7379a832e3b0678b6eea769f242beb3e07" translate="yes" xml:space="preserve">
          <source>This script,</source>
          <target state="translated">这个剧本。</target>
        </trans-unit>
        <trans-unit id="cc448c949fa2502c3de5bd50cf25e079f49a973e" translate="yes" xml:space="preserve">
          <source>This section also applies to other overloaded math packages, like Math::String.</source>
          <target state="translated">本节也适用于其他重载数学包,如Math::String。</target>
        </trans-unit>
        <trans-unit id="be390d54ea95c83e1fca1268a1911351d2f7df4c" translate="yes" xml:space="preserve">
          <source>This section applies fully to Perls starting with v5.22. Various caveats for earlier releases are in the &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;Earlier releases caveats&lt;/a&gt; subsection below.</source>
          <target state="translated">本部分完全适用于从v5.22开始的Perls。下面的&amp;ldquo; &lt;a href=&quot;#Earlier-releases-caveats&quot;&gt;早期版本警告&amp;rdquo;&lt;/a&gt;小节中提供了有关早期版本的各种警告。</target>
        </trans-unit>
        <trans-unit id="56dd90ab92335c6f36e8ed1d4a60c84c97df21db" translate="yes" xml:space="preserve">
          <source>This section concerns the lookahead and lookbehind assertions. First, a little background.</source>
          <target state="translated">本节涉及lookahead和lookbehind断言。首先,介绍一下背景。</target>
        </trans-unit>
        <trans-unit id="ab4a7c816ed65ffc082450cf0217f6cf1db2cf6e" translate="yes" xml:space="preserve">
          <source>This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing, formats, and footers.</source>
          <target state="translated">本节涉及I/O和 &quot;f &quot;的问题:文件柄、刷新、格式和页脚。</target>
        </trans-unit>
        <trans-unit id="c67dd2be244aa67b2c3982a2251efd0aba82da6e" translate="yes" xml:space="preserve">
          <source>This section deals with general Perl language issues that don't clearly fit into any of the other sections.</source>
          <target state="translated">本节讨论的是一般的Perl语言问题,这些问题显然不属于其他任何一节。</target>
        </trans-unit>
        <trans-unit id="4dacb0d5b8529783cda24f9a101a291fd790bb1b" translate="yes" xml:space="preserve">
          <source>This section deals with questions related to running web sites, sending and receiving email as well as general networking.</source>
          <target state="translated">本节涉及与运行网站、收发电子邮件以及一般网络有关的问题。</target>
        </trans-unit>
        <trans-unit id="b8c7e75fcfcb79fa2aefcfcb9d7bd00c769af0ac" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory compression using the</source>
          <target state="translated">本节定义了一个接口,允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="07d89dd508bd9a1955f604c65746a72fe10cd652" translate="yes" xml:space="preserve">
          <source>This section defines an interface that allows in-memory uncompression using the</source>
          <target state="translated">本节定义了一个接口,允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="3243853ef1a289c9e89d976c5c5c21cc63e5a678" translate="yes" xml:space="preserve">
          <source>This section defines the interface available that allows in-memory uncompression using the</source>
          <target state="translated">本节定义了可用的接口,该接口允许在内存中使用</target>
        </trans-unit>
        <trans-unit id="95a0852ba843f17dcbe1940f17029f381d5d77f9" translate="yes" xml:space="preserve">
          <source>This section describes the accuracy/precision handling in Math::Big* as it used to be and as it is now, complete with an explanation of all terms and abbreviations.</source>
          <target state="translated">本节介绍了 Math::Big*中过去和现在的准确度/精度处理,并对所有术语和缩写进行了解释。</target>
        </trans-unit>
        <trans-unit id="39aef7a353c321f38285ab3f99461b24884c7fa4" translate="yes" xml:space="preserve">
          <source>This section describes the re-implementation of the tmpnam() and tmpfile() functions described in L</source>
          <target state="translated">这一节介绍了在 L.D.C.中描述的 tmpnam()和 tmpfile()函数的重新实现。</target>
        </trans-unit>
        <trans-unit id="5b6ee285a0e0ef806b91b3b763a8498277e66885" translate="yes" xml:space="preserve">
          <source>This section describes the recommended interface for generating temporary files and directories.</source>
          <target state="translated">本节介绍生成临时文件和目录的推荐界面。</target>
        </trans-unit>
        <trans-unit id="69aa90134b4dce1d696ebb05a6dbb67cf8770a91" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build PerlCE. You may find additional information about building perl for WinCE at &lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net&lt;/a&gt; and some pre-built binaries.</source>
          <target state="translated">本节介绍了构建PerlCE的步骤。您可以在&lt;a href=&quot;http://perlce.sourceforge.net&quot;&gt;http://perlce.sourceforge.net上&lt;/a&gt;找到有关为WinCE构建perl的其他信息以及一些预构建的二进制文件。</target>
        </trans-unit>
        <trans-unit id="11f3d56c367a6b305dcc2c5edd92d44276e1ff5b" translate="yes" xml:space="preserve">
          <source>This section describes the steps to be performed to build a Perl NLM and other associated NLMs.</source>
          <target state="translated">本节介绍了构建Perl NLM和其他相关NLM所要执行的步骤。</target>
        </trans-unit>
        <trans-unit id="73c6a4b67a7eaa7527571d5faec72b4bfebc75e4" translate="yes" xml:space="preserve">
          <source>This section documents functions to manipulate CVs which are code-values, or subroutines. For more information, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">本节介绍了操作CV的功能，这些CV是代码值或子例程。有关更多信息，请参见&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33ac896f6350aabd5af3622467a85a4b6b744251" translate="yes" xml:space="preserve">
          <source>This section gives some details on all extensions that aren't just synonyms for compound-form Unicode properties (for those properties, you'll have to refer to the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">本部分提供了所有扩展的详细信息，这些扩展不仅是复合格式Unicode属性的同义词（对于这些属性，您必须引用&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44&quot;&gt;Unicode Standard&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="954cb379e9610eb88d0cd37b6e5358601612440b" translate="yes" xml:space="preserve">
          <source>This section hopes to clarify how Perl handles quoted constructs. Although the most common reason to learn this is to unravel labyrinthine regular expressions, because the initial steps of parsing are the same for all quoting operators, they are all discussed together.</source>
          <target state="translated">本节希望能阐明Perl是如何处理引号结构的。虽然学习这一点最常见的原因是为了解开迷宫般的正则表达式,但由于解析的初始步骤对所有引号操作符都是一样的,所以将它们放在一起讨论。</target>
        </trans-unit>
        <trans-unit id="7547891b2c07526eb3624e622a75bf7d7cccf2c6" translate="yes" xml:space="preserve">
          <source>This section is about functions (really macros) that classify characters into types, such as punctuation versus alphabetic, etc. Most of these are analogous to regular expression character classes. (See &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.) There are several variants for each class. (Not all macros have all variants; each item below lists the ones valid for it.) None are affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , and only the ones with &lt;code&gt;LC&lt;/code&gt; in the name are affected by the current locale.</source>
          <target state="translated">本节介绍将字符分类为各种类型的函数（真正的宏），例如标点符号与字母等。大多数此类函数与正则表达式字符类类似。（请参阅&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclass中的POSIX字符类&lt;/a&gt;。）每个类都有几种变体。（并非所有宏都具有所有变体；下面的每一项都列出了对其有效的变体。）没有任何一个受 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 影响，并且只有名称中带有 &lt;code&gt;LC&lt;/code&gt; 的那些才受当前语言环境的影响。</target>
        </trans-unit>
        <trans-unit id="d919f2203b8f136316a99d5a21a115c2a5759b1a" translate="yes" xml:space="preserve">
          <source>This section is intended to supplement and clarify the discussion in &lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Command Paragraph in perlpod&lt;/a&gt;. These are the currently recognized Pod commands:</source>
          <target state="translated">本节旨在补充和阐明&lt;a href=&quot;perlpod#Command-Paragraph&quot;&gt;Perlpod&lt;/a&gt;中&amp;ldquo; 命令段落&amp;rdquo;中的讨论。这些是当前公认的Pod命令：</target>
        </trans-unit>
        <trans-unit id="12d39af9317de3b208731a0e9f6172ef3ca0985f" translate="yes" xml:space="preserve">
          <source>This section is just an outline of some of the things code in a compartment might do (intentionally or unintentionally) which can have an effect outside the compartment.</source>
          <target state="translated">本节只是概述了隔间中的代码可能做的一些事情(有意或无意),这些事情可能会对隔间外部产生影响。</target>
        </trans-unit>
        <trans-unit id="afce53c6f9505fd215e3565d5b9cbd7590482493" translate="yes" xml:space="preserve">
          <source>This section is only necessary for those who want to write a compiler backend module that can be used via this module.</source>
          <target state="translated">本节仅对那些想写一个编译器后台模块的人来说是必要的,可以通过这个模块来使用。</target>
        </trans-unit>
        <trans-unit id="1d2dead1ebaa9a0daf17a7735104700bab6a62c1" translate="yes" xml:space="preserve">
          <source>This section is only relevant if you want to use the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; together with the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">仅当您想将 &lt;code&gt;FOOBAR::DATA&lt;/code&gt; 与&lt;b&gt;SelfLoader&lt;/b&gt;一起使用时，此部分才有意义。</target>
        </trans-unit>
        <trans-unit id="6b8111cc382b6e222eab22ae8b7285382f21bba0" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;: &quot;How do I decode or create those %-encodings on the web&quot; and &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">本节之所以小，是因为该FAQ的其余部分充斥着涉及正则表达式的答案。例如，可以使用正则表达式处理URL解码并检查是否为数字，但是这些答案可以在本文档的其他地方找到（在&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9中&lt;/a&gt;：&amp;ldquo;我如何在网络上解码或创建这些％编码&amp;rdquo;和&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;：&amp;ldquo;精确地说，&amp;ldquo;如何确定标量是数字/整数/整数/浮点数&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e488b03478a9d4c34a486aa35881d2d7c336d0b6" translate="yes" xml:space="preserve">
          <source>This section is surprisingly small because the rest of the FAQ is littered with answers involving regular expressions. For example, decoding a URL and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : &quot;How do I decode or create those %-encodings on the web&quot; and perlfaq4 : &quot;How do I determine whether a scalar is a number/whole/integer/float&quot;, to be precise).</source>
          <target state="translated">这一节的内容出奇的少,因为在FAQ的其他部分,涉及到正则表达式的答案比比皆是。例如,解码一个URL和检查某个东西是否是一个数字可以用正则表达式来处理,但是这些答案在这个文档的其他地方都可以找到(准确地说,在perlfaq9:&quot;我如何在网络上解码或创建那些%编码 &quot;和perlfaq4:&quot;我如何确定一个标量是一个数字/整体/整数/浮点数&quot;)。</target>
        </trans-unit>
        <trans-unit id="94757c3cee869d3cff315104b19f6299d40770f6" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions about where to find source and documentation for Perl, support, and related matters.</source>
          <target state="translated">FAQ的这一部分回答了关于在哪里可以找到Perl的源代码和文档、支持和相关事宜的问题。</target>
        </trans-unit>
        <trans-unit id="dd108d0d127c5d70473c9d7274a370ea63329739" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.</source>
          <target state="translated">这一部分的常见问题回答了与操作数字、日期、字符串、数组、散列和其他数据问题有关的问题。</target>
        </trans-unit>
        <trans-unit id="43d6c325f900a7d6a933d383734e7454f02fa808" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers questions related to programmer tools and programming support.</source>
          <target state="translated">本节常见问题回答了有关程序员工具和编程支持的问题。</target>
        </trans-unit>
        <trans-unit id="8c63d2f74bc0df3e2938dcd3a6724a679f1d5b9f" translate="yes" xml:space="preserve">
          <source>This section of the FAQ answers very general, high-level questions about Perl.</source>
          <target state="translated">FAQ的这一部分回答了关于Perl的一般性、高级别的问题。</target>
        </trans-unit>
        <trans-unit id="f91732cbb36111757913713f2dd27264f7f4075b" translate="yes" xml:space="preserve">
          <source>This section of the Perl FAQ covers questions involving operating system interaction. Topics include interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.</source>
          <target state="translated">Perl FAQ 的这一部分涵盖了涉及操作系统交互的问题。主题包括进程间通信(IPC)、对用户界面(键盘、屏幕和指向设备)的控制,以及其他大多数与数据操作无关的问题。</target>
        </trans-unit>
        <trans-unit id="d25ee711a891d2493e43b730a8ee5f38afba1662" translate="yes" xml:space="preserve">
          <source>This section only applies to you if you have existing data written out by Storable 2.02 or earlier on perl 5.6.0 or 5.6.1 on Unix or Linux which has been configured with 64 bit integer support (not the default) If you got a precompiled perl, rather than running Configure to build your own perl from source, then it almost certainly does not affect you, and you can stop reading now (unless you're curious). If you're using perl on Windows it does not affect you.</source>
          <target state="translated">本节只适用于你,如果你在Unix或Linux上的perl 5.6.0或5.6.1上有Storable 2.02或更早写出的现有数据,而这些数据已被配置为64位整数支持(不是默认的)如果你得到了一个预编译的perl,而不是运行Configure从源头构建你自己的perl,那么几乎可以肯定它不会影响你,你可以停止阅读了(除非你很好奇)。如果你在Windows上使用perl,它不会影响你。</target>
        </trans-unit>
        <trans-unit id="5b9a6489148fff3cc80ff958733f7f998b0b3cdf" translate="yes" xml:space="preserve">
          <source>This server accepts one of five different commands, sending output back to the client. Unlike most network servers, this one handles only one incoming client at a time. Multitasking servers are covered in Chapter 16 of the Camel.</source>
          <target state="translated">这台服务器接受五种不同的命令之一,将输出送回客户端。与大多数网络服务器不同的是,这个服务器一次只处理一个传入的客户端。多任务服务器在《骆驼》第16章中有所介绍。</target>
        </trans-unit>
        <trans-unit id="ffb206fa8662fa49c173d5f9d350cc23a1d8b5c6" translate="yes" xml:space="preserve">
          <source>This server takes the trouble to clone off a child version via fork() for each incoming request. That way it can handle many requests at once, which you might not always want. Even if you don't fork(), the listen() will allow that many pending connections. Forking servers have to be particularly careful about cleaning up their dead children (called &quot;zombies&quot; in Unix parlance), because otherwise you'll quickly fill up your process table. The REAPER subroutine is used here to call waitpid() for any child processes that have finished, thereby ensuring that they terminate cleanly and don't join the ranks of the living dead.</source>
          <target state="translated">这个服务器很麻烦,对每个传入的请求都会通过fork()克隆出一个子版本。这样一来,它就可以同时处理许多请求,而你可能并不总是想要这样。即使你不fork(),listen()也会允许那么多待处理的连接。fork服务器必须特别小心清理它们死去的子程序(在Unix的术语中称为 &quot;僵尸&quot;),因为否则你会很快填满你的进程表。REAPER子程序在这里用于调用waitpid()来处理任何已经结束的子进程,从而确保它们干净利落地终止,不会加入活死人的行列。</target>
        </trans-unit>
        <trans-unit id="3c5ebe323e1cea15acbe8beafe841f6d123af5cf" translate="yes" xml:space="preserve">
          <source>This set of instructions is meant to describe a so-called &quot;native&quot; port of Perl to the Windows platform. This includes both 32-bit and 64-bit Windows operating systems. The resulting Perl requires no additional software to run (other than what came with your operating system). Currently, this port is capable of using one of the following compilers on the Intel x86 architecture:</source>
          <target state="translated">这组指令旨在描述所谓的 &quot;原生 &quot;Perl到Windows平台的移植。这包括32位和64位Windows操作系统。由此产生的Perl不需要额外的软件来运行(除了您的操作系统自带的软件)。目前,这个移植能够在 Intel x86 架构上使用下列编译器之一。</target>
        </trans-unit>
        <trans-unit id="8777023fd72f0e0c5194df7056fed5f92ab1ed79" translate="yes" xml:space="preserve">
          <source>This sets &lt;code&gt;$\&lt;/code&gt; to newline and then sets &lt;code&gt;$/&lt;/code&gt; to the null character.</source>
          <target state="translated">这会将 &lt;code&gt;$\&lt;/code&gt; 设置为换行符，然后将 &lt;code&gt;$/&lt;/code&gt; 设置为空字符。</target>
        </trans-unit>
        <trans-unit id="4549dd71bcce8b09d1c070ffac130c9cb9eed0b2" translate="yes" xml:space="preserve">
          <source>This sets a variable in op/numconvert.t.</source>
          <target state="translated">这个变量在op/numconvert.t中设置。</target>
        </trans-unit>
        <trans-unit id="df79d9971c873dd56e1affe3565f833f5f4ef4be" translate="yes" xml:space="preserve">
          <source>This sets the</source>
          <target state="translated">这设置了</target>
        </trans-unit>
        <trans-unit id="cc422551baf5bd378e1441e1ffd937104c35c5d0" translate="yes" xml:space="preserve">
          <source>This sets the accuracy for all math operations. The argument must be greater than or equal to zero. See Math::BigInt's bround() function for details.</source>
          <target state="translated">此项设置所有数学运算的精度。参数必须大于或等于零。详见 Math::BigInt 的 bround()函数。</target>
        </trans-unit>
        <trans-unit id="3b2057b585966ee5e34a71b1fcc4af8dffd8aef3" translate="yes" xml:space="preserve">
          <source>This sets the default per-thread stack size at the start of the application.</source>
          <target state="translated">这将在应用程序开始时设置默认的每线程栈大小。</target>
        </trans-unit>
        <trans-unit id="d80f3ae97beba02bd7de41d9d2bef09e8032704e" translate="yes" xml:space="preserve">
          <source>This sets the filehandle that &lt;code&gt;$parser&lt;/code&gt; 's output will be written to. You can pass &lt;code&gt;*STDOUT&lt;/code&gt; or &lt;code&gt;*STDERR&lt;/code&gt; , otherwise you should probably do something like this:</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将被写入的文件句柄。您可以传递 &lt;code&gt;*STDOUT&lt;/code&gt; 或 &lt;code&gt;*STDERR&lt;/code&gt; ，否则您可能应该执行以下操作：</target>
        </trans-unit>
        <trans-unit id="af102c7f2132a623b34e9347ca5e8597fbe36895" translate="yes" xml:space="preserve">
          <source>This sets the language code to tag this document as being in. By default, it is currently the value of the environment variable &lt;code&gt;RTFDEFLANG&lt;/code&gt; , or if that's not set, then the value 1033 (for US English).</source>
          <target state="translated">这将设置用于标记该文档所在语言的语言代码。默认情况下，当前它是环境变量 &lt;code&gt;RTFDEFLANG&lt;/code&gt; 的值，如果未设置，则为1033（对于美国英语）。</target>
        </trans-unit>
        <trans-unit id="529a10bfb87aaa836949c559d932aa868d0ea517" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, and are &amp;lt;B&amp;gt;ignored&amp;lt;/B&amp;gt; since all operations happen in integer space. A positive value rounds to this digit left from the dot. 0 or 1 mean round to integer and are ignore like negative values.</source>
          <target state="translated">这将设置所有数学运算的精度。参数可以是任何整数。负值表示点后的位数固定，并且&amp;lt;B&amp;gt;被忽略&amp;lt;/ B&amp;gt;，因为所有运算都在整数空间中进行。正值会四舍五入到该点左边的数字。0或1表示四舍五入为整数，并且像负值一样被忽略。</target>
        </trans-unit>
        <trans-unit id="674e5733f608427771b5b90d6f64c3b452aa5b35" translate="yes" xml:space="preserve">
          <source>This sets the precision for all math operations. The argument can be any integer. Negative values mean a fixed number of digits after the dot, while a positive value rounds to this digit left from the dot. 0 or 1 mean round to integer. See Math::BigInt's bfround() function for details.</source>
          <target state="translated">该函数设置所有数学运算的精度。参数可以是任何整数。负值意味着点后固定的数字,而正值则四舍五入到点后左边的这个数字。0或1意味着四舍五入到整数。详见 Math::BigInt 的 bfround()函数。</target>
        </trans-unit>
        <trans-unit id="7b5668a047104c30653c0804d67e484bf29d90cb" translate="yes" xml:space="preserve">
          <source>This sets the soft and hard limits to 10 and 20 seconds, respectively. After 10 seconds of time spent running on the CPU (not &quot;wall&quot; time), the process will be sent a signal (XCPU on some systems) which, if not trapped, will cause the process to terminate. If that signal is trapped, then after 10 more seconds (20 seconds in total) the process will be killed with a non-trappable signal.</source>
          <target state="translated">这将软限制和硬限制分别设置为10秒和20秒。在CPU上运行10秒的时间(不是 &quot;墙 &quot;的时间)后,进程将被发送一个信号(某些系统上的XCPU),如果该信号没有被捕获,将导致进程终止。如果该信号被捕获,那么再过10秒(共20秒)后,该进程将被一个不可捕获的信号杀死。</target>
        </trans-unit>
        <trans-unit id="130c125b35cf3d3da34044cd207b5628dc2ffac8" translate="yes" xml:space="preserve">
          <source>This sets the string that &lt;code&gt;$parser&lt;/code&gt; 's output will be sent to, instead of any filehandle.</source>
          <target state="translated">这将设置 &lt;code&gt;$parser&lt;/code&gt; 的输出将发送到的字符串，而不是任何文件句柄。</target>
        </trans-unit>
        <trans-unit id="ce02c4df1fe3dcc67a7d36b7b1e441cff60cc978" translate="yes" xml:space="preserve">
          <source>This sets what class is used for rendering the files. The default is &quot;Pod::Simple::HTML&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::HTML, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于渲染文件的类。默认值为&amp;ldquo; Pod :: Simple :: HTML&amp;rdquo;。如果您将其设置为其他内容，则它可能应该是Pod :: Simple :: HTML的子类，并且您应该 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就将其加载。</target>
        </trans-unit>
        <trans-unit id="ec1e3d22ca8911a43038e77812f3f3938f114390" translate="yes" xml:space="preserve">
          <source>This sets what class is used for searching for the files. The default is &quot;Pod::Simple::Search&quot;. If you set it to something else, it should probably be a subclass of Pod::Simple::Search, and you should &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; that class so that's it's loaded before Pod::Simple::HTMLBatch tries loading it.</source>
          <target state="translated">设置用于搜索文件的类。默认值为&amp;ldquo; Pod :: Simple :: Search&amp;rdquo;。如果将其设置为其他内容，则它可能应该是Pod :: Simple :: Search的子类，并且您应该 &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 该类，以便在Pod :: Simple :: HTMLBatch尝试加载它之前就已加载该类。</target>
        </trans-unit>
        <trans-unit id="0ef0f761ac69580bceb47730cfb76aca36efdbeb" translate="yes" xml:space="preserve">
          <source>This shares the variable(s) in the argument list with the compartment. This is almost identical to exporting variables using the &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; module.</source>
          <target state="translated">这将与隔离专区共享参数列表中的变量。这几乎与使用&amp;ldquo; &lt;a href=&quot;exporter&quot;&gt;导出器&amp;rdquo;&lt;/a&gt;模块导出变量相同。</target>
        </trans-unit>
        <trans-unit id="3d3464b620ba9f7ef03d81ee4683ae7ba242d757" translate="yes" xml:space="preserve">
          <source>This should &lt;b&gt;ONLY&lt;/b&gt; be used on memory obtained using &lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt; and friends.</source>
          <target state="translated">&lt;b&gt;仅&lt;/b&gt;应将其用于使用&lt;a href=&quot;#Newx&quot;&gt;Newx&lt;/a&gt;和friends 获得的内存。</target>
        </trans-unit>
        <trans-unit id="d79a68f01e1702d7ec1c9976d188db9c7f2aece8" translate="yes" xml:space="preserve">
          <source>This should allow read/write access to any files that are extracted from the zip file/buffer`.</source>
          <target state="translated">这应该允许读/写访问任何从zip文件/缓冲区提取的文件。</target>
        </trans-unit>
        <trans-unit id="b4bc0e6df3ccf75b9d4b22bada1e150f1c0bf5e1" translate="yes" xml:space="preserve">
          <source>This should be fixed already.</source>
          <target state="translated">这点应该已经解决了。</target>
        </trans-unit>
        <trans-unit id="d375da43f6c63dd4302e9f62a049ebffa1351990" translate="yes" xml:space="preserve">
          <source>This should be interpreted as '&lt;code&gt;PVOP&lt;/code&gt; ' only. The &lt;code&gt;_OR_SVOP&lt;/code&gt; is because the only core &lt;code&gt;PVOP&lt;/code&gt; , &lt;code&gt;OP_TRANS&lt;/code&gt; , can sometimes be a &lt;code&gt;SVOP&lt;/code&gt; instead.</source>
          <target state="translated">仅应将其解释为&amp;ldquo; &lt;code&gt;PVOP&lt;/code&gt; &amp;rdquo;。该 &lt;code&gt;_OR_SVOP&lt;/code&gt; 是因为只有核心 &lt;code&gt;PVOP&lt;/code&gt; ， &lt;code&gt;OP_TRANS&lt;/code&gt; ，有时是 &lt;code&gt;SVOP&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="13a5db63688f7fa372582799c1bd3dfdaa3ba0cd" translate="yes" xml:space="preserve">
          <source>This should be replaced by the full path to your clang executable if it is not in your path.</source>
          <target state="translated">如果你的路径中没有clang可执行文件的完整路径,则应该用它来代替。</target>
        </trans-unit>
        <trans-unit id="b5a95a55a5803d791f964bba2e2a1d75b4c88370" translate="yes" xml:space="preserve">
          <source>This should be the first thing you call in your test script. It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.</source>
          <target state="translated">这应该是你在测试脚本中调用的第一件事。它声明了你的测试计划,将有多少测试,是否允许任何测试失败,等等。</target>
        </trans-unit>
        <trans-unit id="c0f01ea79ad3c782b34e1c39edb42ab144bd80b0" translate="yes" xml:space="preserve">
          <source>This should build everything. Specifically, it will create perl.exe, perl522.dll at the perl toplevel, and various other extension dll's under the lib\auto directory. If the build fails for any reason, make sure you have done the previous steps correctly.</source>
          <target state="translated">这应该可以建立所有的东西。具体来说,它将创建perl.exe,perl522.dll在perl toplevel,以及其他各种扩展dll在lib/auto目录下。如果编译失败,请确保你正确地完成了前面的步骤。</target>
        </trans-unit>
        <trans-unit id="30ba9060ffc1293bd461e0db035bb80a563a059f" translate="yes" xml:space="preserve">
          <source>This should build miniperl and then fail when it tries to run it.</source>
          <target state="translated">这应该会构建miniperl,然后在尝试运行它时失败。</target>
        </trans-unit>
        <trans-unit id="678375f3c34a52f1c875afc4e9a5d9d1a7cc959a" translate="yes" xml:space="preserve">
          <source>This should create an executable</source>
          <target state="translated">这将创建一个可执行的</target>
        </trans-unit>
        <trans-unit id="0343ed053df7e2ae641054c461a6d9ef120ebfaa" translate="yes" xml:space="preserve">
          <source>This should match any sequences of characters that aren't &lt;code&gt;\xDF&lt;/code&gt; nor what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. &lt;code&gt;&quot;s&quot;&lt;/code&gt; isn't &lt;code&gt;\xDF&lt;/code&gt; , but Unicode says that &lt;code&gt;&quot;ss&quot;&lt;/code&gt; is what &lt;code&gt;\xDF&lt;/code&gt; matches under &lt;code&gt;/i&lt;/code&gt;. So which one &quot;wins&quot;? Do you fail the match because the string has &lt;code&gt;ss&lt;/code&gt; or accept it because it has an &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; followed by another &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;? Perl has chosen the latter. (See note in &lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;Bracketed Character Classes&lt;/a&gt; above.)</source>
          <target state="translated">这应该匹配不是 &lt;code&gt;\xDF&lt;/code&gt; 也不是 &lt;code&gt;/i&lt;/code&gt; 下 &lt;code&gt;\xDF&lt;/code&gt; 匹配的任何字符序列。 &lt;code&gt;&quot;s&quot;&lt;/code&gt; 不是 &lt;code&gt;\xDF&lt;/code&gt; ，但是Unicode表示 &lt;code&gt;\xDF&lt;/code&gt; 在 &lt;code&gt;/i&lt;/code&gt; 下匹配的是 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; 。那么哪一个&amp;ldquo;获胜&amp;rdquo;呢？你无法匹配，因为字符串有 &lt;code&gt;ss&lt;/code&gt; 或者接受它，因为它有一个 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 紧接着又 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ？ Perl选择了后者。 （请参阅上面&lt;a href=&quot;#Bracketed-Character-Classes&quot;&gt;括号字符类中的&lt;/a&gt;注释。）</target>
        </trans-unit>
        <trans-unit id="050396cf8762718cb34435af8d06d17eb8dd7bc6" translate="yes" xml:space="preserve">
          <source>This should not be used to supply default values for parameters. One would normally use this when a function parameter must be processed by another library function before it can be used. Default parameters are covered in the next section.</source>
          <target state="translated">这不应该被用来提供参数的默认值。通常,当一个函数参数必须由另一个库函数处理后才能使用时,才会使用这个选项。默认参数将在下一节介绍。</target>
        </trans-unit>
        <trans-unit id="8b1ca7922101edcce2a492b3a6c129abd8a583e6" translate="yes" xml:space="preserve">
          <source>This should only be necessary if</source>
          <target state="translated">只有在以下情况下才需要这样做</target>
        </trans-unit>
        <trans-unit id="598f32a1125324d2a241a1c920bc050b40fac3d7" translate="yes" xml:space="preserve">
          <source>This should rarely be necessary, as the Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with &lt;code&gt;MHCONTEXT&lt;/code&gt; above. But if you really have to, you may be able to do this:</source>
          <target state="translated">这几乎没有必要，因为Perl &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 函数将用于Perl打开的东西，即使它是如上面的 &lt;code&gt;MHCONTEXT&lt;/code&gt; 那样的数字描述符的复制。但是，如果确实需要，则可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="b7c7e9b83cb4841b6e6724c1f7e531bbbc2b68cb" translate="yes" xml:space="preserve">
          <source>This shows &lt;code&gt;$a&lt;/code&gt; is a reference pointing to an SV. That SV is a PVHV, a hash. Fields RITER and EITER are used by &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这表明 &lt;code&gt;$a&lt;/code&gt; 是指向SV的引用。那个SV是PVHV，一个哈希。 &lt;code&gt;&lt;a href=&quot;../functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 字段都使用RITER和EITER字段。</target>
        </trans-unit>
        <trans-unit id="4544b90fccd9dc8117d7d96fcbc15a1ca629dfae" translate="yes" xml:space="preserve">
          <source>This shows that</source>
          <target state="translated">这表明</target>
        </trans-unit>
        <trans-unit id="b55aa05d72ea8d4828d039cb967e2a4c2c9f3f35" translate="yes" xml:space="preserve">
          <source>This shows that we have an SV which is a reference, which points at another SV. In this case that second SV is a PVMG, a blessed scalar. Because it is blessed it has the &lt;code&gt;OBJECT&lt;/code&gt; flag set. Note that an SV which holds a C pointer also has the &lt;code&gt;IOK&lt;/code&gt; flag set. The &lt;code&gt;STASH&lt;/code&gt; is set to the package name which this SV was blessed into.</source>
          <target state="translated">这表明我们有一个SV作为参考，它指向另一个SV。在这种情况下，第二个SV是PVMG，即祝福的标量。因为它很幸运，所以它设置了 &lt;code&gt;OBJECT&lt;/code&gt; 标志。注意，持有C指针的SV也设置了 &lt;code&gt;IOK&lt;/code&gt; 标志。该 &lt;code&gt;STASH&lt;/code&gt; 被设定成这个SV很幸运进入包名。</target>
        </trans-unit>
        <trans-unit id="d6b36418bf4797a5df13199701553bd6ebeff202" translate="yes" xml:space="preserve">
          <source>This shows the sorts of output the &lt;code&gt;l&lt;/code&gt; command can produce:</source>
          <target state="translated">这显示了 &lt;code&gt;l&lt;/code&gt; 命令可以产生的各种输出：</target>
        </trans-unit>
        <trans-unit id="220ae5d1e65680423ed0fee8d1ae71265a4673d1" translate="yes" xml:space="preserve">
          <source>This shows the variables used in the subroutine &lt;code&gt;clear_noremap&lt;/code&gt; . The variable &lt;code&gt;$ready_to_print&lt;/code&gt; is a my() (lexical) variable, &lt;b&gt;i&lt;/b&gt;ntroduced (first declared with my()) on line 1069, and used on line 1079. The variable &lt;code&gt;$&amp;amp;&lt;/code&gt; from the main package is used on 1086, and so on.</source>
          <target state="translated">这显示了子例程 &lt;code&gt;clear_noremap&lt;/code&gt; 中使用的变量。变量 &lt;code&gt;$ready_to_print&lt;/code&gt; 是我的（）（词法）变量，&lt;b&gt;我&lt;/b&gt; ntroduced上线1069，并在线路1079的可变使用（第一与我的（）中声明） &lt;code&gt;$&amp;amp;&lt;/code&gt; 从主包装上使用1086，等。</target>
        </trans-unit>
        <trans-unit id="e3a1a612c118404300b4fc88e912d956be940f47" translate="yes" xml:space="preserve">
          <source>This shows us two libraries being updated and two being added, one of which has an undefined version in the right-hand side version.</source>
          <target state="translated">这表明我们有两个库在更新,两个库在添加,其中一个库的右侧版本有一个未定义的版本。</target>
        </trans-unit>
        <trans-unit id="a9392876266258935c97915a0016be1ab3e077a8" translate="yes" xml:space="preserve">
          <source>This shows what a reference looks like when it references a simple scalar.</source>
          <target state="translated">这显示了引用一个简单标量时的样子。</target>
        </trans-unit>
        <trans-unit id="62c1dd6d2092bdafabfdd27d34aabe7eb07a45cc" translate="yes" xml:space="preserve">
          <source>This shows what a reference to an array looks like.</source>
          <target state="translated">这显示了一个数组引用的样子。</target>
        </trans-unit>
        <trans-unit id="19b0c298e2bbc25317cee46892abecba84a7892d" translate="yes" xml:space="preserve">
          <source>This signifies that this entry should be replaced by the decompositions for all the code points whose decomposition is algorithmically calculated. (All of them are currently in one range and no others outside the range are likely to ever be added to Unicode; the &lt;code&gt;&quot;n&quot;&lt;/code&gt; format has this same entry.) These can be generated via the function &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize::NFD()&lt;/a&gt;.</source>
          <target state="translated">这表示该条目应由分解算法计算出的所有代码点的分解代替。（它们当前都在一个范围内，并且该范围之外的任何其他对象都不可能添加到Unicode； &lt;code&gt;&quot;n&quot;&lt;/code&gt; 格式具有相同的条目。）这些可以通过函数&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize :: NFD（ ）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8a3ee18b62d8c4cf82c2682ec3f88357d163d3e8" translate="yes" xml:space="preserve">
          <source>This silent implicit decoding is known as &quot;upgrading&quot;. That may sound positive, but it's best to avoid it.</source>
          <target state="translated">这种无声的隐性解码被称为 &quot;升级&quot;。这听起来似乎很积极,但最好还是避免。</target>
        </trans-unit>
        <trans-unit id="75ceec87638702fc9211fcbb47c663ad2b557d5f" translate="yes" xml:space="preserve">
          <source>This simplifies the reverse operation as the number of repetitions can be unpacked with the &lt;code&gt;/&lt;/code&gt; code:</source>
          <target state="translated">这可以简化反向操作，因为可以使用 &lt;code&gt;/&lt;/code&gt; 代码解开重复的次数：</target>
        </trans-unit>
        <trans-unit id="c76a52e49b25fb93c5814da39f8a0ca4f090ec45" translate="yes" xml:space="preserve">
          <source>This simply calls &lt;code&gt;sv_magic&lt;/code&gt; and coerces the &lt;code&gt;gv&lt;/code&gt; argument into an &lt;code&gt;SV&lt;/code&gt; .</source>
          <target state="translated">这只是调用 &lt;code&gt;sv_magic&lt;/code&gt; 并将 &lt;code&gt;gv&lt;/code&gt; 参数强制转换为 &lt;code&gt;SV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15c5bc95dce18ddda2693ffc0b4a16e21790eea4" translate="yes" xml:space="preserve">
          <source>This simply evaluates any expression (&lt;code&gt;$got eq $expected&lt;/code&gt; is just a simple example) and uses that to determine if the test succeeded or failed. A true expression passes, a false one fails. Very simple.</source>
          <target state="translated">这只是对任何表达式求值（ &lt;code&gt;$got eq $expected&lt;/code&gt; 只是一个简单的示例），并使用该表达式确定测试是成功还是失败。正确的表达式通过，错误的表达式通过。很简单。</target>
        </trans-unit>
        <trans-unit id="3d969d8fe90ed0cdf3881a37bda779e5984f6b64" translate="yes" xml:space="preserve">
          <source>This simply passes the C representation of the Perl variable (an SV*) in and out of the XS layer. This can be used if the C code wants to deal directly with the Perl variable.</source>
          <target state="translated">这只是简单地将Perl变量的C表示(一个SV*)传入和传出XS层。如果C代码想直接处理Perl变量,可以使用这个方法。</target>
        </trans-unit>
        <trans-unit id="2e6d63f50f6edf8d1ca7caa25f784dd03a42ad6f" translate="yes" xml:space="preserve">
          <source>This simultaneously affects all threads of the program, so it may be problematic to use locales in threaded applications except where there is a single locale applicable to all threads.</source>
          <target state="translated">这同时会影响到程序的所有线程,所以在线程应用程序中使用locale可能会有问题,除非有一个适用于所有线程的单一locale。</target>
        </trans-unit>
        <trans-unit id="39e7f436f0844c6bf989784164030c8f8ea5c91c" translate="yes" xml:space="preserve">
          <source>This software enables you to upgrade software on your computer and so is inherently dangerous because the newly installed software may contain bugs and may alter the way your computer works or even make it unusable. Please consider backing up your data before every upgrade.</source>
          <target state="translated">该软件可以让你升级电脑上的软件,因此具有内在的危险性,因为新安装的软件可能包含错误,可能会改变你的电脑的工作方式,甚至使其无法使用。在每次升级前,请考虑备份您的数据。</target>
        </trans-unit>
        <trans-unit id="95b86ac068430d7abe3629291f82ebff76fb040f" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 1996- by Andreas Koenig.</source>
          <target state="translated">本软件的版权是 (c)1996-by Andreas Koenig.</target>
        </trans-unit>
        <trans-unit id="67032da8813d4f4a0a08f93013ebb3760de4d75d" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2013 by Tim Jenness and the UK Particle Physics and Astronomy Research Council.</source>
          <target state="translated">本软件版权(c)2013年由Tim Jenness和英国粒子物理和天文学研究委员会版权所有。</target>
        </trans-unit>
        <trans-unit id="ff5cf6253d3c58ee0e8370fe0b1014e17ef0f493" translate="yes" xml:space="preserve">
          <source>This software is copyright (c) 2014 by Adam Kennedy and Contributors.</source>
          <target state="translated">本软件版权(c)2014年由亚当-肯尼迪和贡献者所有。</target>
        </trans-unit>
        <trans-unit id="0dbd632224b5aa617ba78b7d9260ccc05095f469" translate="yes" xml:space="preserve">
          <source>This software is released under the MIT license cited below. Additionally, when this software is distributed with &lt;b&gt;Perl Kit, Version 5&lt;/b&gt;, you may also redistribute it and/or modify it under the same terms as Perl itself.</source>
          <target state="translated">该软件根据以下引用的MIT许可证发布。此外，当此软件与&lt;b&gt;Perl Kit版本5一起&lt;/b&gt;分发时，您还可以按照与Perl本身相同的条款重新分发和/或修改它。</target>
        </trans-unit>
        <trans-unit id="b8cc7587a3592d000978422dcd1052715c6866c6" translate="yes" xml:space="preserve">
          <source>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying &lt;code&gt;'autotie'&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; statement. So, the cycling example, could also be written:</source>
          <target state="translated">该软件模式的适用范围非常广泛，以致Attribute :: Handlers提供了一种自动化的方式：在 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Attribute::Handlers&lt;/code&gt; Attribute :: Handlers语句中指定 &lt;code&gt;'autotie'&lt;/code&gt; 。因此，循环示例也可以写成：</target>
        </trans-unit>
        <trans-unit id="8e4e18e30d88ab31167f2d6596e06fcdc6dfcfae" translate="yes" xml:space="preserve">
          <source>This somewhat unpredictable behavior can be avoided with the experimental &quot;bitwise&quot; feature, new in Perl 5.22. You can enable it via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; . By default, it will warn unless the &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; warnings category has been disabled. (&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; will enable the feature and disable the warning.) Under this feature, the four standard bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;) are always numeric. Adding a dot after each operator (&lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ) forces it to treat its operands as strings:</source>
          <target state="translated">Perl 5.22中新增的实验性&amp;ldquo;按位&amp;rdquo;功能可以避免这种无法预测的行为。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; 启用它。默认情况下，它将警告，除非已禁用 &lt;code&gt;&quot;experimental::bitwise&quot;&lt;/code&gt; 警告类别。 （ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; experimental 'bitwise'&lt;/code&gt; 将启用该功能并禁用警告。）在此功能下，四个标准按位运算符（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）始终为数字。在每个运算符（ &lt;code&gt;~. |. &amp;amp;. ^.&lt;/code&gt; ）之后添加一个点，将其强制将其操作数视为字符串：</target>
        </trans-unit>
        <trans-unit id="c23e7895c905e61a802fac11e961fcc5116c44d1" translate="yes" xml:space="preserve">
          <source>This sort of code can be a real eyesore to read, as well as being very sensitive to typos, and it's much clearer to dereference the variable explicitly. We're side-stepping the issue of working with object-oriented programming techniques to encapsulate variable access via methods, only accessible through an object. Here we're just discussing the technical implementation of choice, and whether this has an effect on performance. We can see whether this dereferencing operation, has any overhead by putting comparative code in a file and running a &lt;code&gt;Benchmark&lt;/code&gt; test.</source>
          <target state="translated">这类代码可能真是让人讨厌阅读，并且对错别字非常敏感，并且显式取消对变量的引用更加清晰。我们正在回避使用面向对象的编程技术来封装只能通过对象访问的方法访问变量的问题。在这里，我们只是在讨论选择的技术实现，以及这是否会对性能产生影响。通过将比较代码放在文件中并运行 &lt;code&gt;Benchmark&lt;/code&gt; 测试，我们可以查看此取消引用操作是否有任何开销。</target>
        </trans-unit>
        <trans-unit id="a97c4e8f1d7ea6446c4098759acfa71805444e34" translate="yes" xml:space="preserve">
          <source>This special variable is correctly set to the pseudo-process ID. It can be used to identify pseudo-processes within a particular session. Note that this value is subject to recycling if any pseudo-processes are launched after others have been wait()-ed on.</source>
          <target state="translated">这个特殊变量被正确地设置为伪进程ID。它可以用来识别特定会话中的伪进程。请注意,如果任何伪进程在其他伪进程被wait()-ed后启动,这个值会被回收。</target>
        </trans-unit>
        <trans-unit id="d6c4aceca7fa6325a5de35ebe0aa5f8ca9090348" translate="yes" xml:space="preserve">
          <source>This specifies a search for library &lt;code&gt;gl&lt;/code&gt; as before. If that search fails to find the library, it looks at the next item in the list. The &lt;code&gt;:nosearch&lt;/code&gt; flag will prevent searching for the libraries that follow, so it simply returns the value as &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt;, since GCC can use that value as is with its linker.</source>
          <target state="translated">与以前一样，这指定了对库 &lt;code&gt;gl&lt;/code&gt; 的搜索。如果该搜索找不到图书馆，它将查看列表中的下一项。的 &lt;code&gt;:nosearch&lt;/code&gt; 标志将阻止搜索后面的库，所以它只是返回值 &lt;code&gt;-Ld:\mesalibs -lmesa -luser32&lt;/code&gt; ，因为GCC可以使用该值作为与它的连接。</target>
        </trans-unit>
        <trans-unit id="15c61edb09c43955982bc45d6acb4f0c4af7b4ab" translate="yes" xml:space="preserve">
          <source>This specifies an option to call the formatter &lt;b&gt;w&lt;/b&gt;ith. For example, &lt;code&gt;-w textsize:15&lt;/code&gt; will call &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; on the formatter object before it is used to format the object. For this to be valid, the formatter class must provide such a method, and the value you pass should be valid. (So if &lt;code&gt;textsize&lt;/code&gt; expects an integer, and you do &lt;code&gt;-w textsize:big&lt;/code&gt;, expect trouble.)</source>
          <target state="translated">这是选项调用格式化&lt;b&gt;W&amp;macr;&amp;macr;&lt;/b&gt;第i个。例如， &lt;code&gt;-w textsize:15&lt;/code&gt; 在用于格式化对象之前将在格式化程序对象上调用 &lt;code&gt;$formatter-&amp;gt;textsize(15)&lt;/code&gt; 。为使此方法有效，格式化程序类必须提供这样的方法，并且您传递的值必须有效。（因此，如果 &lt;code&gt;textsize&lt;/code&gt; 需要一个整数，而您执行 &lt;code&gt;-w textsize:big&lt;/code&gt; ，则会遇到麻烦。）</target>
        </trans-unit>
        <trans-unit id="14a814b946e54a59ba68d016b5b039bbdb959679" translate="yes" xml:space="preserve">
          <source>This specifies that the director &quot;somedir&quot; is the input. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">这指定了导演 &quot;somedir &quot;是输入。可以是绝对路径或相对路径,这并不重要)。</target>
        </trans-unit>
        <trans-unit id="6e3a29e95276948f0b11420f703cc3aaddffd6ef" translate="yes" xml:space="preserve">
          <source>This specifies that the input directories are the items in the arrayref &lt;code&gt;\@dirs&lt;/code&gt; .</source>
          <target state="translated">这指定输入目录是arrayref &lt;code&gt;\@dirs&lt;/code&gt; 中的项目。</target>
        </trans-unit>
        <trans-unit id="63679666659be8466fb9bd4dddfdca5063fd3f26" translate="yes" xml:space="preserve">
          <source>This specifies that the output is not to be sent to a pager, but is to be sent directly to STDOUT.</source>
          <target state="translated">这指定了输出不会被发送到寻呼机,而是直接发送到STDOUT。</target>
        </trans-unit>
        <trans-unit id="b1a8fe6a04c1ca76ee22b76d1682c8136ef9711f" translate="yes" xml:space="preserve">
          <source>This specifies that the output is to be sent neither to a pager nor to STDOUT, but is to be saved to the specified filename. Example: &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</source>
          <target state="translated">这指定输出既不发送到寻呼机也不发送到STDOUT，而是保存到指定的文件名。示例： &lt;code&gt;perldoc -oLaTeX -dtextwrapdocs.tex Text::Wrap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45d4b28c13ac9c0ec2726a96f6188b8beab502af" translate="yes" xml:space="preserve">
          <source>This specifies that you want Perldoc to try using a Pod-formatting class for the output format that you specify. For example: &lt;code&gt;-oman&lt;/code&gt; . This is actually just a wrapper around the &lt;code&gt;-M&lt;/code&gt; switch; using &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; just looks for a loadable class by adding that format name (with different capitalizations) to the end of different classname prefixes.</source>
          <target state="translated">这指定您希望Perldoc尝试对指定的输出格式使用Pod格式的类。例如： &lt;code&gt;-oman&lt;/code&gt; 。实际上，这只是 &lt;code&gt;-M&lt;/code&gt; 开关的包装。使用 &lt;code&gt;-o&lt;i&gt;formatname&lt;/i&gt;&lt;/code&gt; 只是通过将格式名称（大小写不同）添加到不同的类名前缀的末尾来查找可加载的类。</target>
        </trans-unit>
        <trans-unit id="9e4b01265a71898dfb9f81df9b68ddce9ce51346" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the current directory.</source>
          <target state="translated">这说明你希望HTML输出进入当前目录。</target>
        </trans-unit>
        <trans-unit id="2ae7a3e343e7bbeb0dfb1ab04a69a9932581a88b" translate="yes" xml:space="preserve">
          <source>This specifies that you want the HTML output to go into the directory 'somedir'. (This can be an absolute or relative path, it doesn't matter.)</source>
          <target state="translated">这说明你希望HTML输出进入'somedir'目录。这可以是一个绝对或相对的路径,这并不重要。</target>
        </trans-unit>
        <trans-unit id="e7729b553095fc163c271a3e43dbeb5e583f17f6" translate="yes" xml:space="preserve">
          <source>This specifies that you want the dirs &quot;somedir&quot;, &quot;someother&quot;, and &quot;also&quot; scanned, just as if you'd passed the arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; . Note that a &quot;:&quot;-separator is normal under Unix, but Under MSWin, you'll need &lt;code&gt;'somedir;someother;also'&lt;/code&gt; instead, since the pathsep on MSWin is &quot;;&quot; instead of &quot;:&quot;. (And</source>
          <target state="translated">这指定您要扫描目录&amp;ldquo; somedir&amp;rdquo;，&amp;ldquo; someother&amp;rdquo;和&amp;ldquo; also&amp;rdquo;，就像传递了arrayref &lt;code&gt;[qw( somedir someother also)]&lt;/code&gt; 。请注意，&amp;ldquo;：&amp;rdquo;-分隔符在Unix下是正常的，但在MSWin下，您将需要 &lt;code&gt;'somedir;someother;also'&lt;/code&gt; ，因为MSWin上的pathep是&amp;ldquo;;&amp;rdquo;。代替 &amp;rdquo;：&amp;rdquo;。（和</target>
        </trans-unit>
        <trans-unit id="b8852ab4d60e276583c1dd4292c015bb068208e6" translate="yes" xml:space="preserve">
          <source>This specifies the module that you want to try using for formatting the pod. The class must at least provide a &lt;code&gt;parse_from_file&lt;/code&gt; method. For example: &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; .</source>
          <target state="translated">这指定您要尝试用于格式化容器的模块。该类至少必须提供 &lt;code&gt;parse_from_file&lt;/code&gt; 方法。例如： &lt;code&gt;perldoc -MPod::Perldoc::ToChecker&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be95e643e0441d56be0f4bdb53c658cbf47d5fc4" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the beginning of the contents page. The default is a string more or less like this:</source>
          <target state="translated">这指定了内容页的开头应该放什么字符串。默认情况下是一个类似于这样的字符串。</target>
        </trans-unit>
        <trans-unit id="9c8f94ea33d23c19ce77204a84bf9dc0e745ad73" translate="yes" xml:space="preserve">
          <source>This specifies what string should be put at the end of the contents page. The default is a string more or less like this:</source>
          <target state="translated">这指定了内容页的结尾应该放什么字符串。默认的是一个类似于这样的字符串。</target>
        </trans-unit>
        <trans-unit id="6917d9958e46c59dbadffa0d75ffc8ead9eeb027" translate="yes" xml:space="preserve">
          <source>This specifies where to find a YAML file of test scheduling rules. If not provided, it looks for a default file to use. It first checks for a file given in the &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; environment variable, then it checks for</source>
          <target state="translated">这指定在哪里可以找到测试计划规则的YAML文件。如果未提供，它将查找要使用的默认文件。它首先检查在 &lt;code&gt;HARNESS_RULESFILE&lt;/code&gt; 环境变量中给定的文件，然后检查</target>
        </trans-unit>
        <trans-unit id="c702c584a5b241344dd398527ce50b4bfbe9b63e" translate="yes" xml:space="preserve">
          <source>This stage is controlled by the macro &lt;code&gt;SIZE_ONLY&lt;/code&gt; being set.</source>
          <target state="translated">该阶段由设置的宏 &lt;code&gt;SIZE_ONLY&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="bad4c7bd6149d53fef7284ef08f67b09b3206bd8" translate="yes" xml:space="preserve">
          <source>This statement is not a legal contract. This statement is not a legal document in any way, shape, or form. Perl is distributed under the GNU Public License and under the Artistic License; those are the precise legal terms. This statement isn't about the law or licenses. It's about community, mutual respect, trust, and good-faith cooperation.</source>
          <target state="translated">本声明不是法律合同。本声明不是以任何方式、形状或形式的法律文件。Perl 是在 GNU Public License 和 Artistic License 下发布的;这些都是准确的法律条款。本声明不是关于法律或许可证的,而是关于社区、相互尊重。它是关于社区、相互尊重、信任和善意的合作。</target>
        </trans-unit>
        <trans-unit id="5a98c55935426becf715b954b892501f79db080b" translate="yes" xml:space="preserve">
          <source>This statement should at least appear in the README file. You may also wish to include it in a Copying file and your source files. Remember to include the other words in addition to the Copyright.</source>
          <target state="translated">这个声明至少应该出现在 README 文件中。您可能也希望在复制文件和您的源文件中包含它。记住,除了版权之外,还要包括其他文字。</target>
        </trans-unit>
        <trans-unit id="5584a0e56dfda5fbec4748cd6a50bc455909922d" translate="yes" xml:space="preserve">
          <source>This step is listed for completeness only. Since it does not change semantics, details of this step are not documented and are subject to change without notice. This step is performed over the finite automaton that was generated during the previous pass.</source>
          <target state="translated">列举这一步只是为了完整性。因为它不改变语义,所以这一步的细节没有被记录下来,可能会在不通知的情况下发生变化。这一步是在上一次生成的有限自动机上进行的。</target>
        </trans-unit>
        <trans-unit id="54c5eb8ed193c34bf7512d41b140b26cac84363b" translate="yes" xml:space="preserve">
          <source>This step is the last one for all constructs except regular expressions, which are processed further.</source>
          <target state="translated">这一步是除正则表达式以外的所有构造体的最后一步,它将被进一步处理。</target>
        </trans-unit>
        <trans-unit id="821b4588528e230329db6b553dfd4048a67b80be" translate="yes" xml:space="preserve">
          <source>This still doesn't guarantee that a real person is answering your prompts or reading your output.</source>
          <target state="translated">这仍然不能保证有真人在回答你的提示或阅读你的输出。</target>
        </trans-unit>
        <trans-unit id="a7c9161f97b6f8900f13bf7304c1db4d0488adaf" translate="yes" xml:space="preserve">
          <source>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将在模式中存储评估组的数量。当使用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 将已编译的正则表达式嵌入较大的模式时，这出于安全目的使用。</target>
        </trans-unit>
        <trans-unit id="fc38633b5aabfda04a32707218d9bef85297337b" translate="yes" xml:space="preserve">
          <source>This strategy can employ a network connection. As such it would be computationally expensive.</source>
          <target state="translated">这种策略可以采用网络连接。因此,它在计算上会很昂贵。</target>
        </trans-unit>
        <trans-unit id="55b6f7ba63a618224a4b898bcbb27d9706c30d52" translate="yes" xml:space="preserve">
          <source>This string tells Perl to consult the CRTL's internal &lt;code&gt;environ&lt;/code&gt; array of key-value pairs, using</source>
          <target state="translated">该字符串告诉Perl使用以下命令查询CRTL的键值对的内部 &lt;code&gt;environ&lt;/code&gt; 数组</target>
        </trans-unit>
        <trans-unit id="7ae6448a0aa9566553b6817c071e02a343cc087d" translate="yes" xml:space="preserve">
          <source>This struct typedef</source>
          <target state="translated">该结构类型ef</target>
        </trans-unit>
        <trans-unit id="f1bc15138286b1a37e209e8a6243ffb9f2ea5373" translate="yes" xml:space="preserve">
          <source>This structure is used for handling data structures that the regex engine needs to handle specially during a clone or free operation on the compiled product. Each element in the data array has a corresponding element in the what array. During compilation regops that need special structures stored will add an element to each array using the add_data() routine and then store the index in the regop.</source>
          <target state="translated">该结构用于处理regex引擎在对编译产品进行克隆或释放操作时需要特别处理的数据结构。数据数组中的每个元素在what数组中都有一个对应的元素。在编译过程中,需要存储特殊结构的regop会使用add_data()例程向每个数组中添加一个元素,然后将索引存储在regop中。</target>
        </trans-unit>
        <trans-unit id="d78d4b0d4925694b27ab08d1c6e58334dc8e28bc" translate="yes" xml:space="preserve">
          <source>This style of commenting has been largely superseded by the raw, freeform commenting that is allowed with the &lt;code&gt;//x&lt;/code&gt; modifier.</source>
          <target state="translated">这种注释风格已被 &lt;code&gt;//x&lt;/code&gt; 修饰符允许的原始的自由格式注释所取代。</target>
        </trans-unit>
        <trans-unit id="97f344b018a57310e7df154cc09c4a4c8ffc8347" translate="yes" xml:space="preserve">
          <source>This subroutine accepts a new style name and three style arguments as above, and creates, registers, and selects the newly named style. It is an error to re-add a style; call set_style_standard() to switch between several styles.</source>
          <target state="translated">这个子程序像上面一样接受一个新的样式名称和三个样式参数,并创建、注册和选择新命名的样式。重新添加一个样式是错误的,调用set_style_standard()可以在多个样式之间切换。</target>
        </trans-unit>
        <trans-unit id="d4edd10fd3d7f6f2e8552ea6e5bfd25a981a931d" translate="yes" xml:space="preserve">
          <source>This subroutine produces a standard help message, derived from the program's POD section SYNOPSIS using &lt;a href=&quot;../pod/usage&quot;&gt;Pod::Usage&lt;/a&gt;. It takes the same arguments as VersionMessage(). In particular, you cannot tie it directly to an option, e.g.:</source>
          <target state="translated">该子例程生成标准帮助消息，该消息是使用&lt;a href=&quot;../pod/usage&quot;&gt;Pod :: Usage&lt;/a&gt;从程序的POD部分SYNOPSIS派生的。它采用与VersionMessage（）相同的参数。特别是，您不能将其直接绑定到选项，例如：</target>
        </trans-unit>
        <trans-unit id="5689fa040b7fc66f95972afdb83490d423250c81" translate="yes" xml:space="preserve">
          <source>This subroutine provides a standard version message. Its argument can be:</source>
          <target state="translated">这个子程序提供了一个标准版本信息。其参数可以是:</target>
        </trans-unit>
        <trans-unit id="8ecee5dd8e0a61ddae4c3d45c386aa7954dd0f33" translate="yes" xml:space="preserve">
          <source>This subroutine will add commas to your number:</source>
          <target state="translated">这个子程序将在你的数字上添加逗号。</target>
        </trans-unit>
        <trans-unit id="f33530c08d2ea0b801b43fac5cff8bb563110c57" translate="yes" xml:space="preserve">
          <source>This succeeds if the &quot;martian&quot; character GX is in the string, and fails otherwise. If you don't like using (?&amp;lt;!), a zero-width negative look-behind assertion, you can replace (?&amp;lt;![A-Z]) with (?:^|[^A-Z]).</source>
          <target state="translated">如果字符串中的&amp;ldquo;火星人&amp;rdquo;字符GX成功，则成功，否则失败。如果您不喜欢使用（？&amp;lt;！）（零宽度的负后向断言），则可以将（？&amp;lt;！[AZ]）替换为（？：^ | [^ AZ]）。</target>
        </trans-unit>
        <trans-unit id="85a98330f72d7fa29e768ec7aa2344fb1a20cbca" translate="yes" xml:space="preserve">
          <source>This suppresses printing of VMS status messages to SYS$OUTPUT and SYS$ERROR if Perl terminates with an error status, and allows programs that are expecting &quot;unix-style&quot; Perl to avoid having to parse VMS error messages. It does not suppress any messages from Perl itself, just the messages generated by DCL after Perl exits. The DCL symbol $STATUS will still have the termination status, but with a high-order bit set:</source>
          <target state="translated">如果Perl以错误状态结束,它将抑制向SYS$OUTPUT和SYS$ERROR打印VMS状态信息,并允许那些期望使用 &quot;unix-style &quot;Perl的程序避免解析VMS错误信息。它不会抑制Perl本身的任何消息,只是在Perl退出后DCL产生的消息。DCL符号$STATUS仍将具有终止状态,但设置了一个高阶位。</target>
        </trans-unit>
        <trans-unit id="a73c08f06f0acf42846845d03633aa9b47905a33" translate="yes" xml:space="preserve">
          <source>This surprising autovivification in what does not at first--or even second--glance appear to be an lvalue context may be fixed in a future release.</source>
          <target state="translated">这种出人意料的自动进化,乍看之下甚至不像是一个l值上下文,可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="e56b6634af06492105c8150cce8eec38c642722a" translate="yes" xml:space="preserve">
          <source>This switch causes Perl to dump core after compiling your program. You can then in theory take this core dump and turn it into an executable file by using the</source>
          <target state="translated">这个开关会让Perl在编译你的程序后转储核心。理论上,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="cdeac32803cbaac383dc34d3e5d5f188b61766f8" translate="yes" xml:space="preserve">
          <source>This switch really just enables the global &lt;code&gt;$^W&lt;/code&gt; variable; normally, the lexically scoped &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma is preferred. You can disable or promote into fatal errors specific warnings using &lt;code&gt;__WARN__&lt;/code&gt; hooks, as described in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; and &lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;. See also &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; and &lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;. A fine-grained warning facility is also available if you want to manipulate entire classes of warnings; see &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">这个开关实际上只是启用了全局 &lt;code&gt;$^W&lt;/code&gt; 变量。通常，首选词法范围的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 。您可以使用 &lt;code&gt;__WARN__&lt;/code&gt; 挂钩将特定的警告禁用或升级为致命错误，如&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;和&lt;a href=&quot;functions/warn&quot;&gt;warn中所述&lt;/a&gt;。另请参见&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;和&lt;a href=&quot;perltrap&quot;&gt;perltrap&lt;/a&gt;。如果您要操纵整个警告类别，还可以使用细粒度的警告工具。看到&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9aace5953cb75e0bd50c74f57a0b38f9c0103c2" translate="yes" xml:space="preserve">
          <source>This symbol conditionally defines the symbol &lt;code&gt;BSD&lt;/code&gt; when running on a &lt;code&gt;BSD&lt;/code&gt; system.</source>
          <target state="translated">在 &lt;code&gt;BSD&lt;/code&gt; 系统上运行时，该符号有条件地定义了 &lt;code&gt;BSD&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="9dffb9b12a2139e8c4c666d76c2bbb94b410515d" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by mmap() (and simultaneously the type of the first argument). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;caddr_t&lt;/code&gt; .</source>
          <target state="translated">该符号包含mmap（）返回的指针类型（以及第一个参数的类型）。它可以是 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;caddr_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e78cc593a5e3d5f9580ef534ee09e8fe0d641140" translate="yes" xml:space="preserve">
          <source>This symbol contains the type of pointer returned by shmat(). It can be &lt;code&gt;void *&lt;/code&gt; or &lt;code&gt;char *&lt;/code&gt; .</source>
          <target state="translated">该符号包含shmat（）返回的指针的类型。它可以是 &lt;code&gt;void *&lt;/code&gt; 或 &lt;code&gt;char *&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="584f3ba36a4f3dda7bd8acb2eea24bb10daa748c" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n has the side effect of decreasing the value of File_cnt(fp) by n.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏作为左值将指针增加n，则具有将File_cnt（fp）的值减少n的副作用，则定义此符号。</target>
        </trans-unit>
        <trans-unit id="0683919acfce603ad7685e97943788fb4e37c119" translate="yes" xml:space="preserve">
          <source>This symbol is defined if using the &lt;code&gt;FILE_ptr&lt;/code&gt; macro as an lvalue to increase the pointer by n leaves File_cnt(fp) unchanged.</source>
          <target state="translated">如果使用 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏作为左值将指针增加n，而File_cnt（fp）保持不变，则定义此符号。</target>
        </trans-unit>
        <trans-unit id="93f9dcbec7fb63d67f75a0e1d4dc9ae41d2b59f2" translate="yes" xml:space="preserve">
          <source>This symbol is set to &lt;code&gt;struct direct&lt;/code&gt; or &lt;code&gt;struct dirent&lt;/code&gt; depending on whether dirent is available or not. You should use this pseudo type to portably declare your directory entries.</source>
          <target state="translated">根据是否可用 &lt;code&gt;struct dirent&lt;/code&gt; 将此符号设置为 &lt;code&gt;struct direct&lt;/code&gt; 或struct dirent。您应该使用此伪类型来可移植地声明您的目录条目。</target>
        </trans-unit>
        <trans-unit id="ac5221df55c0b6f88cbdccf1d492a80ec8b042ec" translate="yes" xml:space="preserve">
          <source>This symbol reflects the patchlevel, if available. Will usually come from the</source>
          <target state="translated">这个符号反映了补丁级别(如果有的话)。通常会来自于</target>
        </trans-unit>
        <trans-unit id="b709a76faa1011cf3f1c524bd59100484a2a8c2a" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports fpos64_t.</source>
          <target state="translated">如果C编译器支持fpos64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="343c9a95f0e1882d7b8de9c8d965312cb38ddb59" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports int64_t.</source>
          <target state="translated">如果C编译器支持int64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="9fabec6c07d2b2eb93287e97cce2db59d9d91ab9" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports off64_t.</source>
          <target state="translated">如果C编译器支持off64_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="425b3d025cac3f927d48be352caec0255a6ff1f6" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports ptrdiff_t.</source>
          <target state="translated">如果C编译器支持ptrdiff_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="8b08c311a150e9da2b658a2599a4ffb33ccacd56" translate="yes" xml:space="preserve">
          <source>This symbol will be defined if the C compiler supports socklen_t.</source>
          <target state="translated">如果C编译器支持socklen_t,这个符号将被定义。</target>
        </trans-unit>
        <trans-unit id="025aea88f0880f5a01a7cfa41a1296fe3bb5e473" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_good_size routine is available for use.</source>
          <target state="translated">如果定义了这个符号,表示malloc_good_size例程可以使用。</target>
        </trans-unit>
        <trans-unit id="8a656f9000aaa7b4a0b80166141d60895ed70146" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the malloc_size routine is available for use.</source>
          <target state="translated">如果定义了这个符号,则表示malloc_size例程可以使用。</target>
        </trans-unit>
        <trans-unit id="9f16a25b173530b121560b8b39634ea26912b006" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system provides a prototype for the modfl() function. Otherwise, it is up to the program to supply one. C99 says it should be long double modfl(long double, long double *);</source>
          <target state="translated">如果定义了这个符号,则表示系统为modfl()函数提供了一个原型。否则,就要由程序提供一个原型。C99说应该是long double modfl(long double,long double *)。</target>
        </trans-unit>
        <trans-unit id="46fd1ea7339001ddcefcaaf1e70c3783b77303d2" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that the system stores the variable argument list datatype, va_list, in a format that cannot be copied by simple assignment, so that some other means must be used when copying is required. As such systems vary in their provision (or non-provision) of copying mechanisms,</source>
          <target state="translated">如果定义了这个符号,则表示系统存储的变量参数列表数据类型va_list的格式不能通过简单的赋值来复制,因此在需要复制时必须使用其他手段。由于这种系统在提供(或不提供)复制机制方面各不相同。</target>
        </trans-unit>
        <trans-unit id="33cfc6c8458868fdba1853ad63d6a5ab248c80dd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, indicates that we can use _NSGetExecutablePath and realpath to get a full path for the executable, and hence convert $^X to an absolute path.</source>
          <target state="translated">如果定义了这个符号,表示我们可以使用_NSGetExecutablePath和realpath来获取可执行文件的完整路径,从而将$^X转换为绝对路径。</target>
        </trans-unit>
        <trans-unit id="1e5579cd2141da02375bbc1afc9cdf3e216d16eb" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that fflush(&lt;code&gt;NULL&lt;/code&gt; ) correctly flushes all pending stdio output without side effects. In particular, on some platforms calling fflush(&lt;code&gt;NULL&lt;/code&gt; ) *still* corrupts &lt;code&gt;STDIN&lt;/code&gt; if it is a pipe.</source>
          <target state="translated">如果定义了此符号，则表明fflush（ &lt;code&gt;NULL&lt;/code&gt; ）正确刷新了所有未处理的stdio输出，而没有副作用。特别是，在某些平台上，如果fflush（ &lt;code&gt;NULL&lt;/code&gt; ）* still * 是管道，则它仍然会破坏 &lt;code&gt;STDIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="345492b736fde856a18832ea228dc15b7f57e1fd" translate="yes" xml:space="preserve">
          <source>This symbol, if defined, tells that to flush all pending stdio output one must loop through all the stdio file handles stored in an array and fflush them. Note that if fflushNULL is defined, fflushall will not even be probed for and will be left undefined.</source>
          <target state="translated">如果定义了这个符号,则说明要刷新所有待处理的stdio输出,必须循环检查所有存储在数组中的stdio文件句柄,并将其fflush。请注意,如果定义了flushNULL,那么flushall甚至不会被探测到,而是未定义。</target>
        </trans-unit>
        <trans-unit id="dcd9bfb79795353183cc954075073576d42a4a96" translate="yes" xml:space="preserve">
          <source>This syntax can be used with any class or object method:</source>
          <target state="translated">这种语法可以用于任何类或对象方法。</target>
        </trans-unit>
        <trans-unit id="361a88cbd3ef11a7c4b058ea6f65a1768cf1bf06" translate="yes" xml:space="preserve">
          <source>This syntax make the caret a special character inside a bracketed character class, but only if it is the first character of the class. So if you want the caret as one of the characters to match, either escape the caret or else don't list it first.</source>
          <target state="translated">这个语法使小括号成为一个特殊的字符,但前提是它是该类的第一个字符。因此,如果你想让小括号作为字符之一来匹配,要么转义小括号,要么不要把它列在第一位。</target>
        </trans-unit>
        <trans-unit id="cf8882c6e41ea0e436011545b6eac42846ae64e6" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::postderef'&lt;/code&gt; is in effect.</source>
          <target state="translated">必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'postderef'&lt;/code&gt; 启用此语法。它是实验性的，除非 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::postderef'&lt;/code&gt; 有效，否则它将默认发出警告。</target>
        </trans-unit>
        <trans-unit id="2448d5ee0ab20cace7d0d694356cb8b018b6fff7" translate="yes" xml:space="preserve">
          <source>This syntax must be enabled with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; . It is experimental, and will warn by default unless &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'refaliasing'&lt;/code&gt; 启用此语法。这是实验性的，并且默认情况下会发出警告，除非 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::refaliasing'&lt;/code&gt; 生效。</target>
        </trans-unit>
        <trans-unit id="17f3dce1b8ffb69288b5e7233eedf50e51bf6d28" translate="yes" xml:space="preserve">
          <source>This table should give some indication on the relative speed of different algorithms. It is sorted by throughput based on a benchmark done with of some implementations of this API:</source>
          <target state="translated">这个表格应该可以提供一些关于不同算法的相对速度的指示。它是根据这个API的一些实现的基准,按吞吐量排序的。</target>
        </trans-unit>
        <trans-unit id="61e7d00a447b322e0b6281e41be210174353561f" translate="yes" xml:space="preserve">
          <source>This tag holds groups of assorted specialist opcodes that don't warrant having optags defined for them.</source>
          <target state="translated">该标签保存了一组不需要为其定义光学标签的各种专业操作码。</target>
        </trans-unit>
        <trans-unit id="4b596b3ecff7c84a2d9f652cda2f444e71a7c9fa" translate="yes" xml:space="preserve">
          <source>This tag holds opcodes related to loading modules and getting information about calling environment and args.</source>
          <target state="translated">这个标签持有与加载模块和获取调用环境和args信息有关的操作码。</target>
        </trans-unit>
        <trans-unit id="04ae009bf5132dad193828814ac61d5405735292" translate="yes" xml:space="preserve">
          <source>This tag is simply a bucket for opcodes that are unlikely to be used via a tag name but need to be tagged for completeness and documentation.</source>
          <target state="translated">这个标签只是一个操作码的桶,这些操作码不太可能通过标签名称使用,但为了完整性和文档的需要,需要对其进行标记。</target>
        </trans-unit>
        <trans-unit id="2f05cedd800de4070129a2009cffd984beb3db08" translate="yes" xml:space="preserve">
          <source>This takes a list of operator names and returns the corresponding list of operator descriptions.</source>
          <target state="translated">这需要一个操作者名称列表,并返回相应的操作者描述列表。</target>
        </trans-unit>
        <trans-unit id="7c7d2a6226efbfa63a2425be94ed3ca13dcfd261" translate="yes" xml:space="preserve">
          <source>This takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored); and after each one, this function inserts super-ordinate forms that don't already appear in the list. The original list, plus these insertions, is returned.</source>
          <target state="translated">这个函数接收一个字符串列表(假定这些字符串是语言标记;不是语言标记的字符串将被忽略);在每一个字符串之后,这个函数插入列表中还没有出现的上位形式。返回的是原始列表,加上这些插入的内容。</target>
        </trans-unit>
        <trans-unit id="13fd8ee50911015c2027466ceb16f127d689e9d2" translate="yes" xml:space="preserve">
          <source>This takes a locale name (like &quot;en&quot;, &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a language tag. If it's not mappable (as with, notably, &quot;C&quot; and &quot;POSIX&quot;), this returns empty-list in a list context, or undef in a scalar context.</source>
          <target state="translated">它接收一个locale名称(如 &quot;en&quot;、&quot;en_US &quot;或 &quot;en_US.ISO8859-1&quot;),并将其映射到一个语言标记。如果它不可映射 (如 &quot;C &quot;和 &quot;POSIX&quot;),在列表上下文中返回 empty-list,在标量上下文中返回 undef。</target>
        </trans-unit>
        <trans-unit id="bec8c5f2b922f1fda3abe6ef42f1ed85d0f41b3d" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of a .packlist. If the file exists, it will be opened and the contents of the file will be read. The new() method returns a reference to a hash. This hash holds an entry for each line in the .packlist. In the case of old-style .packlists, the value associated with each key is undef. In the case of new-style .packlists, the value associated with each key is a hash containing the key=value pairs following the filename in the .packlist.</source>
          <target state="translated">它需要一个可选的参数,即.packlist的名称。如果文件存在,它将被打开并读取文件的内容。new()方法返回一个哈希的引用。这个哈希包含了.packlist中每一行的条目。在旧式.packlists的情况下,与每个键相关的值是undef。在新样式的 .packlists 中,与每个键相关联的值是一个哈希,包含 .packlist 中文件名后的 key=value 对。</target>
        </trans-unit>
        <trans-unit id="cc773e12adc99441c781ca39ab744dcff4457a5a" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be read. If no file is specified, the .packlist specified to new() will be read. If the .packlist does not exist, Carp::croak will be called.</source>
          <target state="translated">这个参数是一个可选的参数,即要读取的.packlist的名称。如果没有指定文件,将读取new()指定的.packlist。如果.packlist不存在,Carp::croak将被调用。</target>
        </trans-unit>
        <trans-unit id="1a1bc9e2453dd25ae8b25a05301cb1b80e688d4f" translate="yes" xml:space="preserve">
          <source>This takes an optional parameter, the name of the .packlist to be written. If no file is specified, the .packlist specified to new() will be overwritten.</source>
          <target state="translated">这需要一个可选的参数,即要写入的.packlist的名称。如果没有指定文件,那么指定给new()的.packlist将被覆盖。</target>
        </trans-unit>
        <trans-unit id="71c865c7274d3c7e5bfe698effd4f04214f7cd15" translate="yes" xml:space="preserve">
          <source>This takes name/value pairs that effect how the test is run.</source>
          <target state="translated">这需要影响测试运行方式的名称/值对。</target>
        </trans-unit>
        <trans-unit id="cc76b10f19749554379a021ff3eedaa58c818a23" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It checks that all the files listed in the modules .packlist actually exist, and returns a list of any missing files. If an optional second argument which evaluates to true is given any missing files will be removed from the .packlist</source>
          <target state="translated">这个函数需要一个强制性的参数,即模块的名称,它检查模块.packlist中列出的所有文件是否存在,并返回一个缺少的文件列表。它检查模块.packlist中列出的所有文件是否真实存在,并返回一个缺少的文件列表。如果给定一个可选的第二个参数,该参数的值为true,则任何丢失的文件将从.packlist中删除。</target>
        </trans-unit>
        <trans-unit id="5b5d51a829067c0f74043220e1f7dc0a082fd9a1" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the directories from the package. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program directories, just manual directories or all directories. The remaining parameters are a list of directories. The directories returned will be restricted to those under the specified directories. This method returns only the leaf directories that contain files from the specified module.</source>
          <target state="translated">它需要一个强制性参数,即模块的名称。它返回的是包中所有目录的列表。允许使用额外的参数,第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个。第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个,用来选择仅仅是程序目录、仅仅是手册目录或所有目录。剩下的参数是一个目录列表。返回的目录将被限制在指定目录下的目录。本方法只返回包含指定模块文件的叶目录。</target>
        </trans-unit>
        <trans-unit id="d2af5c7a635840c9a764106b51edcb4ae7965f15" translate="yes" xml:space="preserve">
          <source>This takes one mandatory parameter, the name of a module. It returns a list of all the filenames from the package. To obtain a list of core perl files, use the module name 'Perl'. Additional parameters are allowed. The first is one of the strings &quot;prog&quot;, &quot;doc&quot; or &quot;all&quot;, to select either just program files, just manual files or all files. The remaining parameters are a list of directories. The filenames returned will be restricted to those under the specified directories.</source>
          <target state="translated">这个函数需要一个强制性的参数,即模块的名称。它返回一个包中所有文件名的列表。要获得核心 perl 文件的列表,请使用模块名 'Perl'。允许使用额外的参数。第一个参数是 &quot;prog&quot;、&quot;doc &quot;或 &quot;all &quot;中的一个,可以选择只选程序文件、只选手动文件或所有文件。剩下的参数是一个目录列表。返回的文件名将被限制在指定目录下的文件名。</target>
        </trans-unit>
        <trans-unit id="c87f6895af9c38d5c250f2c66fe4725760f823f0" translate="yes" xml:space="preserve">
          <source>This takes optional named parameters. Without parameters, this searches for all the installed .packlists on the system using information from &lt;code&gt;%Config::Config&lt;/code&gt; and the default module search paths &lt;code&gt;@INC&lt;/code&gt; . The packlists are read using the &lt;a href=&quot;packlist&quot;&gt;ExtUtils::Packlist&lt;/a&gt; module.</source>
          <target state="translated">这需要可选的命名参数。如果没有参数，它将使用 &lt;code&gt;%Config::Config&lt;/code&gt; 和默认模块搜索路径 &lt;code&gt;@INC&lt;/code&gt; 来搜索系统上所有已安装的.packlists 。使用&lt;a href=&quot;packlist&quot;&gt;ExtUtils :: Packlist&lt;/a&gt;模块读取包装清单。</target>
        </trans-unit>
        <trans-unit id="9a03ab8b368c68d278641fea23e27727f8dbba74" translate="yes" xml:space="preserve">
          <source>This target is stubbed out. Not sure why.</source>
          <target state="translated">这个目标被捅破了。不知道为什么。</target>
        </trans-unit>
        <trans-unit id="f1ca50a85da91c16a0a908f36c57ff992ef7c02c" translate="yes" xml:space="preserve">
          <source>This technique of separation of the glue part from the workhorse part has obvious tradeoffs: if you want to change a Perl interface, you need to change two places in your code. However, it removes a lot of clutter, and makes the workhorse part independent from idiosyncrasies of Perl calling convention. (In fact, there is nothing Perl-specific in the above description, a different version of &lt;b&gt;xsubpp&lt;/b&gt; might have translated this to TCL glue or Python glue as well.)</source>
          <target state="translated">这种将胶水部分与主力部分分开的技术具有明显的权衡：如果要更改Perl接口，则需要在代码中更改两个位置。但是，它消除了很多混乱，并使主力部件独立于Perl调用约定的特质。（实际上，上面的描述中没有Perl特定的内容，不同版本的&lt;b&gt;xsubpp&lt;/b&gt;可能也已将其翻译为TCL胶水或Python胶水。）</target>
        </trans-unit>
        <trans-unit id="579494abf777c1edad219e4e3e72f24bade80f1c" translate="yes" xml:space="preserve">
          <source>This technique was popular for a while (and was recommended in Damian Conway's</source>
          <target state="translated">这种技术曾流行过一段时间(在Damian Conway的</target>
        </trans-unit>
        <trans-unit id="5e8f5ce6d67f7bf4b479db2dfff968206c152d0a" translate="yes" xml:space="preserve">
          <source>This tells the compiler to use integer operations from here to the end of the enclosing BLOCK. On many machines, this doesn't matter a great deal for most computations, but on those without floating point hardware, it can make a big difference in performance.</source>
          <target state="translated">这告诉编译器,从这里到包围BLOCK的末尾都要使用整数运算。在许多机器上,这对大多数计算来说并不重要,但在那些没有浮点硬件的机器上,它可以使性能有很大的不同。</target>
        </trans-unit>
        <trans-unit id="5c227c573c801b67ab844d5a781ca2d861b5ad11" translate="yes" xml:space="preserve">
          <source>This test harness is the same as &lt;a href=&quot;../harness&quot;&gt;TAP::Harness&lt;/a&gt;, but test results are output in color. Passing tests are printed in green. Failing tests are in red. Skipped tests are blue on a white background and TODO tests are printed in white.</source>
          <target state="translated">该测试工具与&lt;a href=&quot;../harness&quot;&gt;TAP :: Harness&lt;/a&gt;相同，但是测试结果以彩色输出。通过测试以绿色打印。测试失败为红色。跳过的测试在白色背景上为蓝色，TODO测试以白色打印。</target>
        </trans-unit>
        <trans-unit id="56c5da5399251bb5e1db8f624c5839bd6c16417b" translate="yes" xml:space="preserve">
          <source>This test not coming out ok could indicate that you have in fact installed a bLuRfle.pm module or that the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; test may give misleading results with your installation of perl. If yours is the latter case then please let the author know.</source>
          <target state="translated">该测试无法正常进行，这可能表明您实际上已经安装了bLuRfle.pm模块，或者 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot; require \&quot;$module_name.pm\&quot;; &quot;&lt;/code&gt; 测试可能会给安装Perl带来误导的结果。如果您属于后一种情况，请告知作者。</target>
        </trans-unit>
        <trans-unit id="d7779eb97d1704eb5b38f4af625c19d04da87929" translate="yes" xml:space="preserve">
          <source>This third program fails to run because &lt;code&gt;$&amp;amp;&lt;/code&gt; is tainted: it is the result of a match involving &lt;code&gt;\w&lt;/code&gt; while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">由于 &lt;code&gt;$&amp;amp;&lt;/code&gt; 被污染，该第三个程序无法运行：这是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境有效时涉及 &lt;code&gt;\w&lt;/code&gt; 的匹配的结果。</target>
        </trans-unit>
        <trans-unit id="a3af2bc97cd9f37316fc3da9caf4914a2a7462bf" translate="yes" xml:space="preserve">
          <source>This threshold can be changed from 100, by recompiling the</source>
          <target state="translated">这个阈值可以从100开始改变,通过重新编译的方式。</target>
        </trans-unit>
        <trans-unit id="2a47e3515c81e527144a0c9b60fab0d504885832" translate="yes" xml:space="preserve">
          <source>This tie class has chosen to return an error rather than raising an exception if its constructor should fail. While this is how dbmopen() works, other classes may well not wish to be so forgiving. It checks the global variable &lt;code&gt;$^W&lt;/code&gt; to see whether to emit a bit of noise anyway.</source>
          <target state="translated">如果其构造函数应该失败，则该tie类选择返回错误而不是引发异常。尽管dbmopen（）是这样工作的，但其他类可能不希望如此宽容。它检查全局变量 &lt;code&gt;$^W&lt;/code&gt; 看看是否仍然发出一点噪声。</target>
        </trans-unit>
        <trans-unit id="65215d2823f33c6578d2c1ee584a26f404ed972a" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used -- we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">这次只使用了两个过滤器--我们只需要操作键的内容,所以没有必要安装任何值过滤器。</target>
        </trans-unit>
        <trans-unit id="ce475e5b88de267f8c35364dcce4ac0349ad1b9f" translate="yes" xml:space="preserve">
          <source>This time only two filters have been used; we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</source>
          <target state="translated">这次只使用了两个过滤器,我们只需要操作键的内容,所以没有必要安装任何值过滤器。</target>
        </trans-unit>
        <trans-unit id="33080a774d1683a847960294bf99870a610d6d24" translate="yes" xml:space="preserve">
          <source>This time we get the right answer:</source>
          <target state="translated">这一次我们得到了正确的答案。</target>
        </trans-unit>
        <trans-unit id="de132ff4c4de4a8dae8876bdea9d65e3845d2e34" translate="yes" xml:space="preserve">
          <source>This time we have got all the key/value pairs, including the multiple values associated with the key &lt;code&gt;Wall&lt;/code&gt; .</source>
          <target state="translated">这次，我们获得了所有键/值对，包括与键 &lt;code&gt;Wall&lt;/code&gt; 相关联的多个值。</target>
        </trans-unit>
        <trans-unit id="549daec07a3febc80783db85efb5cb76a1300cf5" translate="yes" xml:space="preserve">
          <source>This time we've decided to blow up (raise an exception) if the renice fails--there's no place for us to return an error otherwise, and it's probably the right thing to do.</source>
          <target state="translated">这次我们决定,如果renice失败,就炸掉(引发异常)--否则没有地方让我们返回错误,这可能是正确的做法。</target>
        </trans-unit>
        <trans-unit id="e8220bb1a44581d2e3ca1f66709b3d28e4dca5ce" translate="yes" xml:space="preserve">
          <source>This time whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it will execute the Perl subroutine &lt;code&gt;joe&lt;/code&gt; (assuming it exists) rather than &lt;code&gt;fred&lt;/code&gt; as was originally requested in the call to &lt;code&gt;SaveSub1&lt;/code&gt; .</source>
          <target state="translated">每次 &lt;code&gt;CallSavedSub1&lt;/code&gt; 时，它将执行Perl子例程 &lt;code&gt;joe&lt;/code&gt; （假设它存在），而不是像最初对 &lt;code&gt;SaveSub1&lt;/code&gt; 的调用中所要求的那样执行 &lt;code&gt;fred&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f97f664a05e05836532f171c31abc8294dc4fa2e" translate="yes" xml:space="preserve">
          <source>This timeout prevents CPAN from hanging when trying to parse a pathologically coded $VERSION from a module.</source>
          <target state="translated">当CPAN试图从一个模块中解析一个病理编码的$VERSION时,这个超时可以防止CPAN挂起。</target>
        </trans-unit>
        <trans-unit id="818cb77ceebe03d7349ba167c3cce5e948a3bb9b" translate="yes" xml:space="preserve">
          <source>This tip has been brought to you by Nick Ing-Simmons and Stas Bekman.</source>
          <target state="translated">这个提示是由Nick Ing-Simmons和Stas Bekman带来的。</target>
        </trans-unit>
        <trans-unit id="1ad35df16ed4d238965d8000164af0c76d6be400" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">该令牌仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或&amp;ldquo; current_sub&amp;rdquo;功能下可用。请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35716269721e35aed3ed9931d09baf8957f4a7d8" translate="yes" xml:space="preserve">
          <source>This token is only available under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or the &quot;current_sub&quot; feature. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">该令牌仅在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; 或&amp;ldquo; current_sub&amp;rdquo;功能下可用。请参阅&lt;a href=&quot;../feature&quot;&gt;功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a442863544084141507fc6b9cc253372f4528af" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers for all subsequently listed signals. This is the default behavior.</source>
          <target state="translated">该令牌告诉&lt;b&gt;sigtrap&lt;/b&gt;为随后列出的所有信号安装处理程序。这是默认行为。</target>
        </trans-unit>
        <trans-unit id="563416938874462a6a3a7e213b018a4bbf3569b4" translate="yes" xml:space="preserve">
          <source>This token tells &lt;b&gt;sigtrap&lt;/b&gt; to install handlers only for subsequently listed signals which aren't already trapped or ignored.</source>
          <target state="translated">此令牌告诉&lt;b&gt;sigtrap&lt;/b&gt;仅为随后列出的尚未被捕获或忽略的信号安装处理程序。</target>
        </trans-unit>
        <trans-unit id="dbef2365e83f0b66bb2b5afb7a58a64a398a46f8" translate="yes" xml:space="preserve">
          <source>This tool isn't appropriate for reporting bugs in any version prior to Perl 5.0.</source>
          <target state="translated">这个工具不适合用于报告Perl 5.0之前任何版本的错误。</target>
        </trans-unit>
        <trans-unit id="88cd36d63ba450353c54dc7196ff92a040ad99b2" translate="yes" xml:space="preserve">
          <source>This translates as &quot;set &lt;code&gt;TARG&lt;/code&gt; to 10, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack; set &lt;code&gt;TARG&lt;/code&gt; to 20, push a pointer to &lt;code&gt;TARG&lt;/code&gt; onto the stack&quot;. At the end of the operation, the stack does not contain the values 10 and 20, but actually contains two pointers to &lt;code&gt;TARG&lt;/code&gt; , which we have set to 20.</source>
          <target state="translated">这表示为&amp;ldquo;将 &lt;code&gt;TARG&lt;/code&gt; 设置为10，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上；将 &lt;code&gt;TARG&lt;/code&gt; 设置为20，将指向 &lt;code&gt;TARG&lt;/code&gt; 的指针推到堆栈上&amp;rdquo;。在操作结束时，堆栈不包含值10和20，但实际上包含指向 &lt;code&gt;TARG&lt;/code&gt; 的两个指针，我们已将其设置为20。</target>
        </trans-unit>
        <trans-unit id="ba94eb90171beedcd9bec6456a8694f27844f356" translate="yes" xml:space="preserve">
          <source>This transport contacts a remote SMTP server over TCP. It optionally uses SSL and can authenticate to the server via SASL.</source>
          <target state="translated">该传输通过TCP与远程SMTP服务器联系。它可以选择使用SSL,并可以通过SASL对服务器进行验证。</target>
        </trans-unit>
        <trans-unit id="c5f84e699be8b82423bdf0c8efc71c8b6cffc002" translate="yes" xml:space="preserve">
          <source>This tree has 5 nodes (one per &lt;code&gt;TYPE&lt;/code&gt; specifier), only 3 of them are not optimized away (one per number in the left column). The immediate children of the given node correspond to &lt;code&gt;{}&lt;/code&gt; pairs on the same level of indentation, thus this listing corresponds to the tree:</source>
          <target state="translated">该树有5个节点（每个 &lt;code&gt;TYPE&lt;/code&gt; 说明符一个），其中只有3个尚未优化（左侧列中每个数字一个）。给定节点的直接子级对应于相同缩进级别上的 &lt;code&gt;{}&lt;/code&gt; 对，因此此清单对应于树：</target>
        </trans-unit>
        <trans-unit id="10bdb23da270b66c79801ca69744614d31056771" translate="yes" xml:space="preserve">
          <source>This tries loading classes based on the language-tags you give (like &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; , and for the first class that succeeds, returns YourProjClass::</source>
          <target state="translated">这会尝试根据您提供的语言标签（例如 &lt;code&gt;(&quot;en-US&quot;, &quot;sk&quot;, &quot;kon&quot;, &quot;es-MX&quot;, &quot;ja&quot;, &quot;i-klingon&quot;)&lt;/code&gt; ，成功的类，返回YourProjClass ::</target>
        </trans-unit>
        <trans-unit id="2350736fbbdb09c3e03af560458218f7c39a0887" translate="yes" xml:space="preserve">
          <source>This tries to get the title string out of $parser, by getting some tokens, and scanning them for the title, and then ungetting them so that you can process the token-stream from the beginning.</source>
          <target state="translated">这将尝试从$parser中获取标题字符串,通过获取一些tokens,并扫描它们以获取标题,然后解除它们,这样你就可以从头开始处理token-stream。</target>
        </trans-unit>
        <trans-unit id="2c43b29369b0643df2b475c636f7ba4a7760104c" translate="yes" xml:space="preserve">
          <source>This tutorial assumes that the make program that Perl is configured to use is called &lt;code&gt;make&lt;/code&gt; . Instead of running &quot;make&quot; in the examples that follow, you may have to substitute whatever make program Perl has been configured to use. Running &lt;b&gt;perl -V:make&lt;/b&gt; should tell you what it is.</source>
          <target state="translated">本教程假定Perl配置为使用的make程序称为 &lt;code&gt;make&lt;/code&gt; 。您可能必须替换配置为使用Perl的任何make程序，而不是在下面的示例中运行&amp;ldquo; make&amp;rdquo;。运行&lt;b&gt;perl -V：make&lt;/b&gt;应该告诉您它是什么。</target>
        </trans-unit>
        <trans-unit id="8c02c1e1c4554cfc38ab4519576c46376d729f42" translate="yes" xml:space="preserve">
          <source>This tutorial can still be used on such a system. The XSUB build mechanism will check the system and build a dynamically-loadable library if possible, or else a static library and then, optionally, a new statically-linked executable with that static library linked in.</source>
          <target state="translated">本教程仍然可以在这样的系统上使用。XSUB的构建机制会检查系统,如果可能的话,会构建一个可动态加载的库,否则就会构建一个静态库,然后,再选择性地构建一个新的静态链接的可执行文件,并将该静态库链接进去。</target>
        </trans-unit>
        <trans-unit id="042a6a29ffea342487866bd18b2ff67e8550a4e6" translate="yes" xml:space="preserve">
          <source>This tutorial describes the use of Perl interpreter threads (sometimes referred to as</source>
          <target state="translated">本教程介绍了Perl解释器线程(有时被称为 &quot;线程&quot;)的使用。</target>
        </trans-unit>
        <trans-unit id="584c62ddbbc858e85333edcc1d7b6494d833b45b" translate="yes" xml:space="preserve">
          <source>This tutorial flattens the learning curve by discussing regular expression concepts, along with their notation, one at a time and with many examples. The first part of the tutorial will progress from the simplest word searches to the basic regular expression concepts. If you master the first part, you will have all the tools needed to solve about 98% of your needs. The second part of the tutorial is for those comfortable with the basics and hungry for more power tools. It discusses the more advanced regular expression operators and introduces the latest cutting-edge innovations.</source>
          <target state="translated">本教程通过逐一讨论正则表达式的概念以及它们的符号,并结合许多实例,使学习曲线变得平坦。本教程的第一部分将从最简单的单词搜索发展到基本的正则表达式概念。如果你掌握了第一部分,你将拥有解决大约98%需求的所有工具。教程的第二部分是为那些对基础知识感到舒适并渴望获得更多强大工具的人准备的。它讨论了更高级的正则表达式运算符,并介绍了最新的前沿创新。</target>
        </trans-unit>
        <trans-unit id="09418d1e9dc1ccd649181b2ae1d0e9cc30227030" translate="yes" xml:space="preserve">
          <source>This tutorial speaks in rather absolute terms, and provides only a limited view of the wealth of character string related features that Perl has to offer. For most projects, this information will probably suffice.</source>
          <target state="translated">本教程以相当绝对的术语来说明,并且只提供了Perl所提供的与字符字符串相关的丰富功能的有限视图。对于大多数项目来说,这些信息可能已经足够了。</target>
        </trans-unit>
        <trans-unit id="5a1babab3f5740242709a97dfef0170b83cfd116" translate="yes" xml:space="preserve">
          <source>This tutorial starts with very simple examples and becomes more complex, with each new example adding new features. Certain concepts may not be completely explained until later in the tutorial in order to slowly ease the reader into building extensions.</source>
          <target state="translated">本教程从非常简单的例子开始,然后变得越来越复杂,每个新的例子都会增加新的功能。某些概念可能要到教程的后面才会完全解释清楚,以便让读者慢慢地了解如何构建扩展。</target>
        </trans-unit>
        <trans-unit id="513743e90a808d724cf722e256c18c6a577aed36" translate="yes" xml:space="preserve">
          <source>This tutorial was written from a Unix point of view. Where I know them to be otherwise different for other platforms (e.g. Win32), I will list them. If you find something that was missed, please let me know.</source>
          <target state="translated">本教程是从Unix的角度来写的。如果我知道它们与其他平台(如Win32)不同,我将列出它们。如果你发现有遗漏的地方,请告诉我。</target>
        </trans-unit>
        <trans-unit id="2d3bc7e20dd6d03170372006d4bcd471be2b1a05" translate="yes" xml:space="preserve">
          <source>This tutorial will educate the reader on the steps involved in creating a Perl extension. The reader is assumed to have access to &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;, &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">本教程将向读者介绍创建Perl扩展所涉及的步骤。假定读者可以访问&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;，&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;和&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73d6133ba18859a5eaedd64f01ef459aa33a4f61" translate="yes" xml:space="preserve">
          <source>This ucfirst form of #var generates a tag-value form of itself for display; it converts '#Var' into a 'Var =&amp;gt; #var' style, which is then handled as described above. (Imp-note: #Vars cannot be used for conditional-fills, because the =&amp;gt; #var transform is done after the check for #Var's value).</source>
          <target state="translated">#var的第一种形式生成其自身的标签值形式以供显示；它将&amp;ldquo; #Var&amp;rdquo;转换为&amp;ldquo; Var =&amp;gt; #var&amp;rdquo;样式，然后按上述说明进行处理。（提示：#Vars不能用于条件填充，因为=&amp;gt; #var变换是在检查#Var的值之后完成的）。</target>
        </trans-unit>
        <trans-unit id="e1c48ccdb02bacfa9c7db277adb42c2586c3c859" translate="yes" xml:space="preserve">
          <source>This unloading is usually necessary when embedding a shared-object perl (e.g. one configured with -Duseshrplib) within a larger application, and the perl interpreter is created and destroyed several times within the lifetime of the application. In this case it is possible that the system dynamic linker will unload and then subsequently reload the shared libperl without relocating any references to it from any files DynaLoaded by the previous incarnation of the interpreter. As a result, any shared objects opened by DynaLoader may point to a now invalid 'ghost' of the libperl shared object, causing apparently random memory corruption and crashes. This behaviour is most commonly seen when using Apache and mod_perl built with the APXS mechanism.</source>
          <target state="translated">这种卸载通常是必要的,当把一个共享对象perl(例如用-Duseshrplib配置的)嵌入到一个较大的应用程序中,并且perl解释器在应用程序的生命周期内被创建和销毁了好几次。在这种情况下,系统动态链接器有可能会卸载,然后再重新加载共享的libperl,而不会从解释器的前一个化身DynaLoaded的任何文件中重新定位对它的任何引用。因此,任何由DynaLoader打开的共享对象可能会指向一个现在无效的libperl共享对象的 &quot;幽灵&quot;,导致明显的随机内存损坏和崩溃。这种行为最常见于使用APXS机制构建的Apache和mod_perl。</target>
        </trans-unit>
        <trans-unit id="1b13f3deb5370e5675a9d76c565d42ae5d602f71" translate="yes" xml:space="preserve">
          <source>This usage is deprecated, because the behavior is likely to change in a future version of Perl.</source>
          <target state="translated">这个用法已经被废弃了,因为在未来的Perl版本中,这种行为可能会改变。</target>
        </trans-unit>
        <trans-unit id="d8b6fb62901deb9e84ba258e77b4c4979b396131" translate="yes" xml:space="preserve">
          <source>This used to provide support for the old 5.005 threading module. It now does nothing.</source>
          <target state="translated">这曾经为旧的5.005线程模块提供支持。现在它什么也不做。</target>
        </trans-unit>
        <trans-unit id="ad74ce7c330e222ac3a23c23df9097ca9cc782c1" translate="yes" xml:space="preserve">
          <source>This uses &lt;code&gt;[...]&lt;/code&gt; notation to create a new anonymous array, and &lt;code&gt;$aref2&lt;/code&gt; is assigned a reference to the new array. The new array is initialized with the contents of the array referred to by &lt;code&gt;$aref1&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;[...]&lt;/code&gt; 这将使用符号创建一个新的匿名数组，并 &lt;code&gt;$aref2&lt;/code&gt; 分配一个对该新数组的引用。新数组使用 &lt;code&gt;$aref1&lt;/code&gt; 引用的数组的内容初始化。</target>
        </trans-unit>
        <trans-unit id="0ec25d0bdb752659175b1040a999aeb2b6d490b8" translate="yes" xml:space="preserve">
          <source>This uses a comment character so that we can distinguish a &lt;code&gt;set&lt;/code&gt; value (from a previous</source>
          <target state="translated">它使用注释字符，以便我们可以区分 &lt;code&gt;set&lt;/code&gt; 值（与上一个</target>
        </trans-unit>
        <trans-unit id="cc1cad67a921e3eb4640eba7ead1b7740937eea5" translate="yes" xml:space="preserve">
          <source>This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="5a9ad1aba7c9a639b483b1f8f929290363dd11bd" translate="yes" xml:space="preserve">
          <source>This utility is designed to write a Makefile for an extension module from a Makefile.PL. It is based on the Makefile.SH model provided by Andy Dougherty and the perl5-porters.</source>
          <target state="translated">这个工具是用来为扩展模块从Makefile.PL中写一个Makefile。它是基于Andy Dougherty和perl5-porters提供的Makefile.SH模型。</target>
        </trans-unit>
        <trans-unit id="b24b7df29646f7c014772e5059f3068df5bbacbd" translate="yes" xml:space="preserve">
          <source>This utility takes a list of libraries in the form &lt;code&gt;-llib1 -llib2
-llib3&lt;/code&gt; and returns lines suitable for inclusion in an extension Makefile. Extra library paths may be included with the form &lt;code&gt;-L/another/path&lt;/code&gt; this will affect the searches for all subsequent libraries.</source>
          <target state="translated">该实用程序采用 &lt;code&gt;-llib1 -llib2 -llib3&lt;/code&gt; 形式的库列表，并返回适合包含在扩展Makefile中的行。 &lt;code&gt;-L/another/path&lt;/code&gt; 格式可能包含额外的库路径，这将影响对所有后续库的搜索。</target>
        </trans-unit>
        <trans-unit id="b766c16803f46a0ae895c110a4b6edf915519f91" translate="yes" xml:space="preserve">
          <source>This utility will read *.pl files (given as parameters) and write corresponding *.pm files. The pl2pm utilities does the following:</source>
          <target state="translated">这个实用程序将读取*.pl文件(以参数形式给出)并写入相应的*.pm文件。pl2pm实用程序可以完成以下工作。</target>
        </trans-unit>
        <trans-unit id="a410c695becbafd5bc2593139ba56b80c63242e8" translate="yes" xml:space="preserve">
          <source>This utility, that comes with the &lt;code&gt;Digest::SHA&lt;/code&gt; module, is used to print or verify SHA checksums.</source>
          <target state="translated">&lt;code&gt;Digest::SHA&lt;/code&gt; 模块随附的此实用程序用于打印或验证SHA校验和。</target>
        </trans-unit>
        <trans-unit id="fa4ff7242b8a2fd67b36df12914e2cc6d1af606d" translate="yes" xml:space="preserve">
          <source>This value can be adjusted to reduce security checking if required. The value is only relevant when C</source>
          <target state="translated">如果需要,可以调整该值以减少安全检查。该值仅在C</target>
        </trans-unit>
        <trans-unit id="7591c615f6c14e41979e1eaadb2f09a869a865a0" translate="yes" xml:space="preserve">
          <source>This value overrides any &lt;code&gt;stack_size&lt;/code&gt; parameter given to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; . Its primary purpose is to permit setting the per-thread stack size for legacy threaded applications.</source>
          <target state="translated">该值将覆盖为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; thread而给定的所有 &lt;code&gt;stack_size&lt;/code&gt; 参数。其主要目的是允许为遗留线程应用程序设置每个线程的堆栈大小。</target>
        </trans-unit>
        <trans-unit id="41ecf008113019e40a6e54f73ff5a98b48282c9e" translate="yes" xml:space="preserve">
          <source>This variable (default is 1) controls whether to enforce the contents of $^E to start with &lt;code&gt;SYS0003&lt;/code&gt; -like id. If set to 0, then the string value of $^E is what is available from the OS/2 message file. (Some messages in this file have an &lt;code&gt;SYS0003&lt;/code&gt; -like id prepended, some not.)</source>
          <target state="translated">此变量（默认值为1）控制是否强制$ ^ E的内容以 &lt;code&gt;SYS0003&lt;/code&gt; 的id 开头。如果设置为0，则$ ^ E字符串值是OS / 2消息文件中可用的值。（此文件中的某些消息带有 &lt;code&gt;SYS0003&lt;/code&gt; 的ID，有些则没有。）</target>
        </trans-unit>
        <trans-unit id="16732492f2d070676c6f99bbc0efae47b95f7071" translate="yes" xml:space="preserve">
          <source>This variable bears the symbol value to be used during open() or fcntl() to turn on non-blocking I/O for a file descriptor. If you wish to switch between blocking and non-blocking, you may try ioctl(&lt;code&gt;FIOSNBIO&lt;/code&gt; ) instead, but that is only supported by some devices.</source>
          <target state="translated">此变量带有将在open（）或fcntl（）期间用于打开文件描述符的非阻塞I / O的符号值。如果希望在阻止和非阻止之间切换，则可以尝试使用ioctl（ &lt;code&gt;FIOSNBIO&lt;/code&gt; ），但这仅在某些设备上支持。</target>
        </trans-unit>
        <trans-unit id="cca2eeea3350d961dcaad04aa855c2a1f247bac2" translate="yes" xml:space="preserve">
          <source>This variable bears the symbolic errno code set by read() when no data is present on the file and non-blocking I/O was enabled (otherwise, read() blocks naturally).</source>
          <target state="translated">当文件上没有数据并且启用了非阻塞I/O时,这个变量带有由read()设置的符号errno代码(否则,read()会自然阻塞)。</target>
        </trans-unit>
        <trans-unit id="248382abe33b16964803e73f6ecfb34faabcc93f" translate="yes" xml:space="preserve">
          <source>This variable can be used to determine whether the Perl interpreter executing a script is in the right range of versions:</source>
          <target state="translated">这个变量可以用来确定执行脚本的Perl解释器是否在正确的版本范围内。</target>
        </trans-unit>
        <trans-unit id="dfea1020f3dea68d67242c313286038f4a0d0e35" translate="yes" xml:space="preserve">
          <source>This variable can be used to establish a fallthrough for the cases where nm fails to find a symbol. If usenm is false or usenm is true and mistrustnm is false, this variable has no effect. If usenm is true and mistrustnm is &lt;code&gt;compile&lt;/code&gt; , a test program will be compiled to try to find any symbol that can't be located via nm lookup. If mistrustnm is &lt;code&gt;run&lt;/code&gt; , the test program will be run as well as being compiled.</source>
          <target state="translated">对于nm无法找到符号的情况，可以使用此变量来建立过渡。如果usenm为false或usenm为true且mistrustnm为false，则此变量无效。如果usenm为true且mistrustnm为 &lt;code&gt;compile&lt;/code&gt; ，则将编译测试程序以尝试找到任何无法通过nm查找定位的符号。如果mistrustnm被 &lt;code&gt;run&lt;/code&gt; ，则测试程序将被运行以及被编译。</target>
        </trans-unit>
        <trans-unit id="4b0fbadd8567e78cf31399e6a2260ad4aafcd61e" translate="yes" xml:space="preserve">
          <source>This variable combines api_revision, api_version, and api_subversion in a format such as 5.6.1 (or 5_6_1) suitable for use as a directory name. This is filesystem dependent.</source>
          <target state="translated">这个变量结合了 api_revision、api_version 和 api_subversion,其格式为 5.6.1 (或 5_6_1),适合用作目录名。这与文件系统有关。</target>
        </trans-unit>
        <trans-unit id="3a2c3f8de756634885e7def1800fcfd4dd0d57a3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defined &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义了 &lt;code&gt;PERL_VENDORARCH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efd929c3d0bcbeeec8636fa669401d4e86c870d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;ARCHLIB&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $archlib is the same as $privlib, then this is set to undef.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;ARCHLIB&lt;/code&gt; 来保存$ package依赖于体系结构的库文件的路径名。如果$ archlib与$ privlib相同，则将其设置为undef。</target>
        </trans-unit>
        <trans-unit id="ef97d2a231904adfc4265eba4006701690eed6ca" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CAN_VAPROTO&lt;/code&gt; on systems supporting prototype declaration of functions with a variable number of arguments. See also prototype.</source>
          <target state="translated">该变量在支持带有可变数量参数的函数原型声明的系统上有条件地定义 &lt;code&gt;CAN_VAPROTO&lt;/code&gt; 。另请参见原型。</target>
        </trans-unit>
        <trans-unit id="980485e36e7b05790618d387e3c7b5f9dffdd4ab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CASTNEG&lt;/code&gt; , which indicates whether the C compiler can cast negative float to unsigned.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;CASTNEG&lt;/code&gt; ，它指示C编译器是否可以将负浮点数强制转换为无符号。</target>
        </trans-unit>
        <trans-unit id="6a2c21b1fb400d236c7f8b93084483db1894c446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CHARVSPRINTF&lt;/code&gt; if this system has vsprintf returning type (char*). The trend seems to be to declare it as &quot;int vsprintf()&quot;.</source>
          <target state="translated">如果此系统具有vsprintf返回类型（char *），则此变量有条件地定义 &lt;code&gt;CHARVSPRINTF&lt;/code&gt; 。趋势似乎是将其声明为&amp;ldquo; int vsprintf（）&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5078955ce08b58cadcdb20d3c38df82d26ee60ff" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;CTERMID&lt;/code&gt; if ctermid() is available to generate filename for terminal.</source>
          <target state="translated">如果ctermid（）可用于为终端生成文件名，则此变量有条件地定义 &lt;code&gt;CTERMID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978df228f8d800c08979baf4f0b9bb0fc46ebfa9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DIRNAMLEN&lt;/code&gt; , which indicates to the C program that the length of directory entry names is provided by a d_namelen field.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;DIRNAMLEN&lt;/code&gt; ，它向C程序指示目录条目名称的长度由d_namelen字段提供。</target>
        </trans-unit>
        <trans-unit id="df3c72fff3ec53eb910b33c4d8de7ba859b22249" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; , which indicates that we need to prepend an underscore to the symbol name before calling dlsym().</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;DLSYM_NEEDS_UNDERSCORE&lt;/code&gt; ，这表明在调用dlsym（）之前，我们需要在符号名称前添加下划线。</target>
        </trans-unit>
        <trans-unit id="49b013eda5d273dde0c71244769fe3ad52ab910f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EBCDIC&lt;/code&gt; if this system uses &lt;code&gt;EBCDIC&lt;/code&gt; encoding.</source>
          <target state="translated">如果此系统使用 &lt;code&gt;EBCDIC&lt;/code&gt; 编码，则此变量有条件地定义 &lt;code&gt;EBCDIC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95f5847b07ee6a0574affcb0afba6691ba0cb5dc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; if &lt;code&gt;EOF&lt;/code&gt; can be seen when reading from a non-blocking I/O source.</source>
          <target state="translated">如果从非阻塞I / O源读取时可以看到 &lt;code&gt;EOF&lt;/code&gt; ,则此变量有条件地定义 &lt;code&gt;EOF_NONBLOCK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0af8dac12168ddb05c87d99076fc3d364dbfc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;GRPASSWD&lt;/code&gt; , which indicates that struct group in &amp;lt;grp.h&amp;gt; contains gr_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;GRPASSWD&lt;/code&gt; ，它指示&amp;lt;grp.h&amp;gt;中的结构组包含gr_passwd。</target>
        </trans-unit>
        <trans-unit id="e239460b32f067f0e57a573c2a38cc269c4e8cf6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; , which indicates that &lt;code&gt;GCC&lt;/code&gt; can handle the attribute for marking deprecated APIs</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_DEPRECATED&lt;/code&gt; ，这表明 &lt;code&gt;GCC&lt;/code&gt; 可以处理用于标记不赞成使用的API的属性</target>
        </trans-unit>
        <trans-unit id="096a4e7335c9e97171f7b50c60f3c4f1d139650c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; , which indicates the C compiler can check for printf-like formats.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_FORMAT&lt;/code&gt; ，它指示C编译器可以检查类似printf的格式。</target>
        </trans-unit>
        <trans-unit id="0fc32aff59b98aa4940aa65546e2ce2f0bae5f6b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; , which indicates the C compiler can understand functions as having malloc-like semantics.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_MALLOC&lt;/code&gt; ，这表明C编译器可以将函数理解为具有类似malloc的语义。</target>
        </trans-unit>
        <trans-unit id="cc77040e22d8dbd38fd3bdef2b4c807ff2648d0f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; , which indicates that the C compiler can know that certain arguments must not be &lt;code&gt;NULL&lt;/code&gt; , and will check accordingly at compile time.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NONNULL&lt;/code&gt; ，这表明C编译器可以知道某些参数一定不能为 &lt;code&gt;NULL&lt;/code&gt; ，并将在编译时进行相应检查。</target>
        </trans-unit>
        <trans-unit id="c1ca1b192eaeeef39ff342721f49f9732f5c25b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; , which indicates that the C compiler can know that certain functions are guaranteed never to return.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_NORETURN&lt;/code&gt; ，这表明C编译器可以知道某些函数可以保证永远不会返回。</target>
        </trans-unit>
        <trans-unit id="35f0cde07593cb535b92fefc63eb7d81d46fe8bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; , which indicates that the C compiler can know that certain functions are &lt;code&gt;pure&lt;/code&gt; functions, meaning that they have no side effects, and only rely on function input</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_PURE&lt;/code&gt; ，这表明C编译器可以知道某些函数是 &lt;code&gt;pure&lt;/code&gt; 函数，这意味着它们没有副作用，仅依赖于函数输入</target>
        </trans-unit>
        <trans-unit id="420fa8e106aa6be346627e32f034151a52362ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; , which indicates that the C compiler can know that certain variables and arguments may not always be used, and to not throw warnings if they don't get used.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASATTRIBUTE_UNUSED&lt;/code&gt; ，这表明C编译器可以知道某些变量和参数可能不总是被使用，并且如果不使用它们就不会发出警告。</target>
        </trans-unit>
        <trans-unit id="ddcad35f0c318736909295f4f6cd964d37f1a53f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; , which indicates that the C compiler can know that certain functions have a return values that must not be ignored, such as malloc() or open().</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HASATTRIBUTE_WARN_UNUSED_RESULT&lt;/code&gt; ，这表明C编译器可以知道某些函数具有不可忽略的返回值，例如malloc（）或open（）。</target>
        </trans-unit>
        <trans-unit id="4f215b234b46ef7c56eb723ad08f919ae0a7c950" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ACCESS&lt;/code&gt; if the access() system call is available to check for access permissions using real IDs.</source>
          <target state="translated">如果access（）系统调用可用于使用真实ID检查访问权限，则此变量有条件地定义 &lt;code&gt;HAS_ACCESS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c105d4e6058827fec8056bf20316718cbab9faa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; if closedir() is available.</source>
          <target state="translated">如果closedir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_CLOSEDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8654218934b9b6758432460c578cc5a644b91d92" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; if endhostent() is available to close whatever was being used for host queries.</source>
          <target state="translated">如果可以使用endhostent（）关闭用于主机查询的 &lt;code&gt;HAS_ENDHOSTENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDHOSTENT。</target>
        </trans-unit>
        <trans-unit id="79e5c8edfd4691e1b4f25bb1c714fe1507e829f4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; if endnetent() is available to close whatever was being used for network queries.</source>
          <target state="translated">如果endnetent（）可用于关闭用于网络查询的 &lt;code&gt;HAS_ENDNETENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDNETENT。</target>
        </trans-unit>
        <trans-unit id="23979ba16f9e3dd7409c1aeb4d7d4d5911e864e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; if endprotoent() is available to close whatever was being used for protocol queries.</source>
          <target state="translated">如果可以使用endprotoent（）关闭用于协议查询的 &lt;code&gt;HAS_ENDPROTOENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDPROTOENT。</target>
        </trans-unit>
        <trans-unit id="1f85023e116dfb459bcb6c6b9ea107e1880da801" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; if endservent() is available to close whatever was being used for service queries.</source>
          <target state="translated">如果可以使用endservent（）关闭用于服务查询的 &lt;code&gt;HAS_ENDSERVENT&lt;/code&gt; 则此变量有条件地定义HAS_ENDSERVENT。</target>
        </trans-unit>
        <trans-unit id="9026ce557a983587089262cdc30c657f39523536" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; if fegetround() is available to get the floating point rounding mode.</source>
          <target state="translated">如果fegetround（）可用于获取浮点舍入模式，则此变量有条件地定义 &lt;code&gt;HAS_FEGETROUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5695e9822f626cc75613841b734f1880b97e1cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FGETPOS&lt;/code&gt; if fgetpos() is available to get the file position indicator.</source>
          <target state="translated">如果fgetpos（）可用于获取文件位置指示符，则此变量有条件地定义 &lt;code&gt;HAS_FGETPOS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecd11d67113d55076e38c3f87fbec174b96046c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FLOCK&lt;/code&gt; if flock() is available to do file locking.</source>
          <target state="translated">如果flock（）可用于执行文件锁定，则此变量有条件地定义 &lt;code&gt;HAS_FLOCK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d12df32e7c3e2769df2173cc4aeba55819c508b3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; if fpgetround() is available to get the floating point rounding mode.</source>
          <target state="translated">如果fpgetround（）可用于获取浮点舍入模式，则此变量有条件地定义 &lt;code&gt;HAS_FPGETROUND&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7caed5a67bbd1068f15dc1afc8a52fbcbb8a3a6c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_FSETPOS&lt;/code&gt; if fsetpos() is available to set the file position indicator.</source>
          <target state="translated">如果fsetpos（）可用于设置文件位置指示符，则此变量有条件地定义 &lt;code&gt;HAS_FSETPOS&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ca1f26e1ee2a6d6b7bcc20d2c601de0d8652782" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; if getespwnam() is available to retrieve enhanced (shadow) password entries by name.</source>
          <target state="translated">如果getespwnam（）可用于按名称检索增强的（影子）密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETESPWNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="523b849ed0e10fbdf244f4e8cd77184e7b2e7e2e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; if gethostent() is available to look up host names in some data base or another.</source>
          <target state="translated">如果gethostent（）可用于在某些数据库或其他数据库中查找主机名，则此变量有条件地定义 &lt;code&gt;HAS_GETHOSTENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c477102d11cefe29ba1af921e3e01940cce25886" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETNETENT&lt;/code&gt; if getnetent() is available to look up network names in some data base or another.</source>
          <target state="translated">如果getnetent（）可用于在某些数据库或其他数据库中查找网络名称，则此变量有条件地定义 &lt;code&gt;HAS_GETNETENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dd4221c56df17e7463336ebb61e6a0a59685106" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; if getpagesize() is available to get the system page size.</source>
          <target state="translated">如果getpagesize（）可用于获取系统页面大小，则此变量有条件地定义 &lt;code&gt;HAS_GETPAGESIZE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="008f90e9dce5e248f0a062499f460cbfe1316a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPGRP&lt;/code&gt; if getpgrp() is available to get the current process group.</source>
          <target state="translated">如果getpgrp（）可用于获取当前进程组，则此变量有条件地定义 &lt;code&gt;HAS_GETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="466f30d3944227e178d079578b5e186c11b86479" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; if getpriority() is available to get a process's priority.</source>
          <target state="translated">如果getpriority（）可用于获取进程的优先级，则此变量有条件地定义 &lt;code&gt;HAS_GETPRIORITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8a60b1d5d8d846ce3f5e6fe4d7b072471b5e6c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; if getprotoent() is available to look up protocols in some data base or another.</source>
          <target state="translated">如果getprotoent（）可用于在某些数据库或其他数据库中查找协议，则此变量有条件地定义 &lt;code&gt;HAS_GETPROTOENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703bdebcae3a9b18831e785584b8e179d8f5569d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; if getprpwnam() is available to retrieve protected (shadow) password entries by name.</source>
          <target state="translated">如果getprpwnam（）可用于按名称检索受保护的（影子）密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETPRPWNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d470dbda91b75051a9116195c5471b4cc0a994bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; if getservent() is available to look up network services in some data base or another.</source>
          <target state="translated">如果可以使用getservent（）在某些数据库或其他数据库中查找网络服务，则此变量有条件地定义 &lt;code&gt;HAS_GETSERVENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f1532a01e5d8ec8dbefe92231b99738657124d6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; if getspnam() is available to retrieve SysV shadow password entries by name.</source>
          <target state="translated">如果getspnam（）可用于按名称检索SysV影子密码条目，则此变量有条件地定义 &lt;code&gt;HAS_GETSPNAM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cfad68a688a0a88c6b15faed3a855ee7ed81db88" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HTONL&lt;/code&gt; if htonl() and its friends are available to do network order byte swapping.</source>
          <target state="translated">如果htonl（）及其朋友可用于进行网络顺序字节交换，则此变量有条件地定义 &lt;code&gt;HAS_HTONL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36ae55fc8ab6d9db052670febb9d6c73ffc9c7fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_HYPOT&lt;/code&gt; if hypot is available for numerically stable hypotenuse function.</source>
          <target state="translated">如果 &lt;code&gt;HAS_HYPOT&lt;/code&gt; 可用于数值稳定的斜边函数，则此变量有条件地定义HAS_HYPOT。</target>
        </trans-unit>
        <trans-unit id="1c8f906308fe5425fd5dc9fc6c65283219211f28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_INDEX&lt;/code&gt; if index() and rindex() are available for string searching.</source>
          <target state="translated">如果index（）和rindex（）可用于字符串搜索，则此变量有条件地定义 &lt;code&gt;HAS_INDEX&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f58665b1066bffd31d93be9865becf02e07fbc33" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LINK&lt;/code&gt; if link() is available to create hard links.</source>
          <target state="translated">如果link（）可用于创建硬链接，则此变量有条件地定义 &lt;code&gt;HAS_LINK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7aaa9b5790c7fed2f4557a1b76230d9dee2b872" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; if localeconv() is available for numeric and monetary formatting conventions.</source>
          <target state="translated">如果localeconv（）可用于数字和货币格式约定，则此变量有条件地定义 &lt;code&gt;HAS_LOCALECONV&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3c4adc80b08fec49de9e85a9758844bbed93d4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LOCKF&lt;/code&gt; if lockf() is available to do file locking.</source>
          <target state="translated">如果lockf（）可用于进行文件锁定，则此变量有条件地定义 &lt;code&gt;HAS_LOCKF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3309e731f7ec54de80f5709f885fa11f752d281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; if the long double type is supported.</source>
          <target state="translated">如果支持long double类型，则此变量有条件地定义 &lt;code&gt;HAS_LONG_DOUBLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f96dc22b2fabc7d6becfede8302b062283c67511" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; if the long long type is supported.</source>
          <target state="translated">如果支持long long类型，则此变量有条件地定义 &lt;code&gt;HAS_LONG_LONG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bde46e5f10d187a1e49089e8f14937e758db8660" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_LSTAT&lt;/code&gt; if lstat() is available to do file stats on symbolic links.</source>
          <target state="translated">如果lstat（）可用于执行符号链接上的文件统计，则此变量有条件地定义 &lt;code&gt;HAS_LSTAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c29d2f5108f120fc070de1998bbec52bcea01c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MADVISE&lt;/code&gt; if madvise() is available to map a file into memory.</source>
          <target state="translated">如果madvise（）可用于将文件映射到内存，则此变量有条件地定义 &lt;code&gt;HAS_MADVISE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9773977cefbb09ffe9bf40f7bdd75aa66788128d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MMAP&lt;/code&gt; if mmap() is available to map a file into memory.</source>
          <target state="translated">如果mmap（）可用于将文件映射到内存，则此变量有条件地定义 &lt;code&gt;HAS_MMAP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e49a09fbe97831dedb0097fc04c353ecd4fdc497" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MPROTECT&lt;/code&gt; if mprotect() is available to modify the access protection of a memory mapped file.</source>
          <target state="translated">如果mprotect（）可用于修改内存映射文件的访问保护，则此变量有条件地定义 &lt;code&gt;HAS_MPROTECT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d39b4760c4a7ddea99da224cda29212d2ef99aed" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MSYNC&lt;/code&gt; if msync() is available to synchronize a mapped file.</source>
          <target state="translated">如果msync（）可用于同步映射的文件，则此变量有条件地定义 &lt;code&gt;HAS_MSYNC&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="542bb319608c7eec938e5b98398f37ee190044a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_MUNMAP&lt;/code&gt; if munmap() is available to unmap a region mapped by mmap().</source>
          <target state="translated">如果munmap（）可用于取消映射由mmap（）映射的区域，则此变量有条件地定义 &lt;code&gt;HAS_MUNMAP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02d3878b96b9be7c2121b2227ea0c924b133a4a0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NAN&lt;/code&gt; if nan() is available to generate NaN.</source>
          <target state="translated">如果nan（）可用于生成NaN，则此变量有条件地定义 &lt;code&gt;HAS_NAN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b6ab26a7e66c25dc87e4ed8365e14b5b776d611" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; if nearbyint() is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">如果 &lt;code&gt;HAS_NEARBYINT&lt;/code&gt; （）可用于将最接近（根据当前舍入模式）的整数值返回到x，则此变量有条件地定义HAS_NEARBYINT。</target>
        </trans-unit>
        <trans-unit id="9de8df4ca9d3107d7b5e197ebc2f8b56f2a456de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; if nextafter() is available to return the next machine representable double from x in direction y.</source>
          <target state="translated">如果nextafter（）可用于从y方向从x返回下一个可表示的double值，则此变量有条件地定义 &lt;code&gt;HAS_NEXTAFTER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09cc9884f832b1e2f2ad4607b97076420d46d665" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; if nexttoward() is available to return the next machine representable long double from x in direction y.</source>
          <target state="translated">如果nexttoward（）可用于从y方向从x返回下一个机器可表示的长双 &lt;code&gt;HAS_NEXTTOWARD&lt;/code&gt; 则此变量有条件地定义HAS_NEXTTOWARD。</target>
        </trans-unit>
        <trans-unit id="e84d3a1694bc236dbf1d7993a1d2c9255724da86" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; if pthread_attr_setscope() is available to set the contention scope attribute of a thread attribute object.</source>
          <target state="translated">如果pthread_attr_setscope（）可用于设置线程属性对象的竞争作用域属性，则此变量有条件地定义 &lt;code&gt;HAS_PTHREAD_ATTR_SETSCOPE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca9e53f6ec390b98dfba5bb4f284367970f8d262" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_READDIR&lt;/code&gt; if readdir() is available to read directory entries.</source>
          <target state="translated">如果readdir（）可用于读取目录条目，则此变量有条件地定义 &lt;code&gt;HAS_READDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c772ddc21b6658b7802061d88a44caa292765ab3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; if rewinddir() is available.</source>
          <target state="translated">如果rewinddir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_REWINDDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="102609636e6adf43c7c619fd51b5305af390db97" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_RMDIR&lt;/code&gt; if rmdir() is available to remove directories.</source>
          <target state="translated">如果rmdir（）可用于删除目录，则此变量有条件地定义 &lt;code&gt;HAS_RMDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="887794d99137721bdeb0c86f2844b40ead019692" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; if seekdir() is available.</source>
          <target state="translated">如果seekdir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SEEKDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eabab054867a6e7a1fda52591f68108f354fff8a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SELECT&lt;/code&gt; if select() is available to select active file descriptors. A &amp;lt;sys/time.h&amp;gt; inclusion may be necessary for the timeout field.</source>
          <target state="translated">如果select（）可用于选择活动文件描述符，则此变量有条件地定义 &lt;code&gt;HAS_SELECT&lt;/code&gt; 。超时字段可能需要包含&amp;lt;sys / time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="bc33f5c99454e91ae2ee5c0078387d95e7d2e9a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; if sethostent() is available.</source>
          <target state="translated">如果sethostent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETHOSTENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75151e22ebcabc154ea71d8ff2b10a358ed030a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; if setlocale() is available to handle locale-specific ctype implementations.</source>
          <target state="translated">如果setlocale（）可用于处理特定于语言环境的ctype实现，则此变量有条件地定义 &lt;code&gt;HAS_SETLOCALE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d673facbb75d108913e27f1a2486a73d55d0236" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETNETENT&lt;/code&gt; if setnetent() is available.</source>
          <target state="translated">如果setnetent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETNETENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7914dcc37c31303f3da0f6e201df5d765f8aa85c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPGRP&lt;/code&gt; if setpgrp() is available to set the current process group.</source>
          <target state="translated">如果setpgrp（）可用于设置当前进程组，则此变量有条件地定义 &lt;code&gt;HAS_SETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2002a17a2c2a55f6f40172b2b8fb58d5b76cdd2a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; if setpriority() is available to set a process's priority.</source>
          <target state="translated">如果setpriority（）可用于设置进程的优先级，则此变量有条件地定义 &lt;code&gt;HAS_SETPRIORITY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c631092c3030de3575c0a7a87bf0eb17b021238" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; if setprotoent() is available.</source>
          <target state="translated">如果setprotoent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETPROTOENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f78400a8b12f8656f01ebbdf5086223548e1e83" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREGID&lt;/code&gt; if setregid() is available to change the real and effective gid of the current process.</source>
          <target state="translated">如果setregid（）可用于更改当前进程的实际和有效gid，则此变量有条件地定义 &lt;code&gt;HAS_SETREGID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30c69bd63c2acea93583c8f9220b4a879c50d781" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETRESGID&lt;/code&gt; if setresgid() is available to change the real, effective and saved gid of the current process.</source>
          <target state="translated">如果setresgid（）可用于更改当前进程的实际，有效和保存的gid，则此变量有条件地定义 &lt;code&gt;HAS_SETRESGID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35485f4098b6c1c258054bdb628277a4ccf112e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setresuid() is available to change the real, effective and saved uid of the current process.</source>
          <target state="translated">如果setresuid（）可用于更改当前进程的实际，有效和已保存的uid，则此变量有条件地定义 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aba8a0bc40989a1ca38df2aae3c387f371d5192b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETREUID&lt;/code&gt; if setreuid() is available to change the real and effective uid of the current process.</source>
          <target state="translated">如果setreuid（）可用于更改当前进程的实际和有效uid，则此变量有条件地定义 &lt;code&gt;HAS_SETREUID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6783028c86e7bf10a2b92123734f47a7944fac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; if setservent() is available.</source>
          <target state="translated">如果setservent（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SETSERVENT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56d4df6b62a7f4a67414b6f9ecb8ddad65efc719" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SETSID&lt;/code&gt; if setsid() is available to set the process group &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">如果setsid（）可用于设置进程组 &lt;code&gt;ID&lt;/code&gt; ,则此变量有条件地定义 &lt;code&gt;HAS_SETSID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a53a8b438b669e85e8dac90bda9a163f72b38dcd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; if sigprocmask() is available to examine or change the signal mask of the calling process.</source>
          <target state="translated">如果sigprocmask（）可用于检查或更改调用过程的信号掩码，则此变量有条件地定义 &lt;code&gt;HAS_SIGPROCMASK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fedaa514d1228b3cb8d459d4c50ec34f00f6ac02" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SOCKET&lt;/code&gt; , which indicates that the &lt;code&gt;BSD&lt;/code&gt; socket interface is supported.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_SOCKET&lt;/code&gt; ，它指示支持 &lt;code&gt;BSD&lt;/code&gt; 套接字接口。</target>
        </trans-unit>
        <trans-unit id="5acf41a0b06778d8de2ab0c3e21b6db83e6e1a26" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STAT&lt;/code&gt; if stat() is available to get file status.</source>
          <target state="translated">如果stat（）可用于获取文件状态，则此变量有条件地定义 &lt;code&gt;HAS_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="104dec5b82fbc045989fe3c8c4ef8fa75c373740" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCHR&lt;/code&gt; if strchr() and strrchr() are available for string searching.</source>
          <target state="translated">如果strchr（）和strrchr（）可用于字符串搜索，则此变量有条件地定义 &lt;code&gt;HAS_STRCHR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c65e480ececd2a54e0b9068f9890c68b2b94ad" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRCOLL&lt;/code&gt; if strcoll() is available to compare strings using collating information.</source>
          <target state="translated">如果 &lt;code&gt;HAS_STRCOLL&lt;/code&gt; （）可用于使用整理信息比较字符串，则此变量有条件地定义HAS_STRCOLL。</target>
        </trans-unit>
        <trans-unit id="b82eb75e3b5d7a021a62e68340d85ee6ee407d5d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRERROR&lt;/code&gt; if strerror() is available to translate error numbers to strings.</source>
          <target state="translated">如果strerror（）可用于将错误号转换为字符串，则此变量有条件地定义 &lt;code&gt;HAS_STRERROR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="157fd2966246701c1e0fd97cb121f370d5243dfd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_STRXFRM&lt;/code&gt; if strxfrm() is available to transform strings.</source>
          <target state="translated">如果strxfrm（）可用于转换字符串，则此变量有条件地定义 &lt;code&gt;HAS_STRXFRM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f665cc4a3804d1cfbb21ea5e1e553f34ba0001f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSCALL&lt;/code&gt; if syscall() is available call arbitrary system calls.</source>
          <target state="translated">如果syscall（）可用，则此变量有条件地定义 &lt;code&gt;HAS_SYSCALL&lt;/code&gt; ，以调用任意系统调用。</target>
        </trans-unit>
        <trans-unit id="76958e03c19c57ba5daadf788ceb559703fda4a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYSTEM&lt;/code&gt; if system() is available to issue a shell command.</source>
          <target state="translated">如果system（）可用于发出Shell命令，则此变量有条件地定义 &lt;code&gt;HAS_SYSTEM&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fba0f75ab5519c316f7379166065cac7a0fa0f08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; if sys_errlist[] is available to translate error numbers to strings.</source>
          <target state="translated">如果sys_errlist []可用于将错误号转换为字符串，则此变量有条件地定义 &lt;code&gt;HAS_SYS_ERRLIST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3133e51b2626aefa90c83a60c2bc07b45364f9d8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; if sys_errnolist[] is available to translate error numbers to the symbolic name.</source>
          <target state="translated">如果sys_errnolist []可用于将错误编号转换为符号名称，则此变量有条件地定义 &lt;code&gt;HAS_SYS_ERRNOLIST&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b6cc938eb6588fef7831af7c25c38df6b393dba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TELLDIR&lt;/code&gt; if telldir() is available.</source>
          <target state="translated">如果telldir（）可用，则此变量有条件地定义 &lt;code&gt;HAS_TELLDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13376d783be11f279f6a31e5dca53c18c5518beb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_gmtoff field.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_TM_TM_GMTOFF&lt;/code&gt; ，它向C程序指示结构tm具有tm_gmtoff字段。</target>
        </trans-unit>
        <trans-unit id="a5fdffc25ffd7e4584eb45e68410699ffcf4500b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; , which indicates indicates to the C program that the struct tm has the tm_zone field.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_TM_TM_ZONE&lt;/code&gt; ，它向C程序指示struct tm具有tm_zone字段。</target>
        </trans-unit>
        <trans-unit id="56c5c15d4eddf8d206488d6739d6fd8de91eb4bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; if truncate() is available to truncate files.</source>
          <target state="translated">如果truncate（）可用于截断文件，则此变量有条件地定义 &lt;code&gt;HAS_TRUNCATE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b911e2460cf128e44ed370b2980c2209097f87" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_TZNAME&lt;/code&gt; if tzname[] is available to access timezone names.</source>
          <target state="translated">如果tzname []可用于访问时区名称，则此变量有条件地定义 &lt;code&gt;HAS_TZNAME&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d2899983d1ce6900d5663872bcf0fe4bc31fe25" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; if the union semun is defined by including &amp;lt;sys/sem.h&amp;gt;.</source>
          <target state="translated">如果通过包含&amp;lt;sys / sem.h&amp;gt;来定义联合semun，则此变量有条件地定义 &lt;code&gt;HAS_UNION_SEMUN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dbad1c6f722a7fb60b2580c6825a89a0875ea78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USLEEP&lt;/code&gt; if usleep() is available to do high granularity sleeps.</source>
          <target state="translated">如果usleep（）可用于执行高粒度睡眠，则此变量有条件地定义 &lt;code&gt;HAS_USLEEP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62fcdd3f292691fc949ae90083b1d7e19d396383" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_USTAT&lt;/code&gt; if ustat() is available to query file system statistics by dev_t.</source>
          <target state="translated">如果ustat（）可用于dev_t查询文件系统统计信息，则此变量有条件地定义 &lt;code&gt;HAS_USTAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6da30a5484ed0715193a06b75bbdc0f387b14b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS_WAITPID&lt;/code&gt; if waitpid() is available to wait for child process.</source>
          <target state="translated">如果waitpid（）可用于等待子进程，则此变量有条件地定义 &lt;code&gt;HAS_WAITPID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea1ebdb3e07eb3cfa8774547eb7eca99b9cbda6a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;HAS__FWALK&lt;/code&gt; if _fwalk() is available to apply a function to all the file handles.</source>
          <target state="translated">如果_fwalk（）可用于将函数应用于所有文件句柄，则此变量有条件地定义 &lt;code&gt;HAS__FWALK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccfbe62640f2e7f4d3f434546f57dde1c801c589" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_DIRENT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;dirent.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_DIRENT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;dirent.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="b09b17b8feebed4fb31ad1053dd929b31fc1552d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_NETINET_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;netinet/in.h&amp;gt;. Otherwise, you may try &amp;lt;sys/in.h&amp;gt;.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_NETINET_IN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;netinet / in.h&amp;gt;。否则，您可以尝试&amp;lt;sys / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="18545a27b23f4ec408fe168cb07019ddd52aeb9d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_PWD&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;pwd.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_PWD&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;pwd.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="3999885997764e29fe1e4dcd432c1a48f0dbd137" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_QUADMATH&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;quadmath.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_QUADMATH&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;quadmath.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="2a59b19169614e1208d6a92cb8cd08ec908a8e0b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_IN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/in.h&amp;gt; instead of &amp;lt;netinet/in.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_IN&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / in.h&amp;gt;而不是&amp;lt;netinet / in.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="b72fad23f2686fa8a3b7ba796dba5e928d3c1193" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SELECT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/select.h&amp;gt; in order to get the definition of struct timeval.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_SYS_SELECT&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / select.h&amp;gt;以便获取struct timeval的定义。</target>
        </trans-unit>
        <trans-unit id="46b3e1dfb1e11c227d687db5d0baaa2e450457de" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; to indicate to the C program that socket ioctl codes may be found in &amp;lt;sys/sockio.h&amp;gt; instead of &amp;lt;sys/ioctl.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_SOCKIO&lt;/code&gt; ，以向C程序指示可以在&amp;lt;sys / sockio.h&amp;gt;中而不是&amp;lt;sys / ioctl.h&amp;gt;中找到套接字ioctl代码。</target>
        </trans-unit>
        <trans-unit id="abc49b9ac08dff6a9f6857ae04835d4e61d8c3d9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="134ce192071bcaa440fc2e6dd10833f44f8a3750" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/time.h&amp;gt; with &lt;code&gt;KERNEL&lt;/code&gt; defined.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_TIME_KERNEL&lt;/code&gt; ，它向C程序指示它应包含定义了 &lt;code&gt;KERNEL&lt;/code&gt; 的 &amp;lt;sys / time.h&amp;gt; 。</target>
        </trans-unit>
        <trans-unit id="939cb7b0620edee4edc61983e7278fc31a5c1093" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_UN&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/un.h&amp;gt; to get &lt;code&gt;UNIX&lt;/code&gt; domain socket definitions.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_UN&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;sys / un.h&amp;gt;以获得 &lt;code&gt;UNIX&lt;/code&gt; 域套接字定义。</target>
        </trans-unit>
        <trans-unit id="d05b60d3b34826e6947a78549014fc461f91e426" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_SYS_WAIT&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;sys/wait.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_SYS_WAIT&lt;/code&gt; ，它向C程序指示它应包括&amp;lt;sys / wait.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="cbee00fea0a0e43a823409e3c9ea7ecbe6db0995" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_TIME&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;time.h&amp;gt;.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;I_TIME&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;time.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="5e26138c57947cb8f890b9cb6f5d5a73c355cb2b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;I_VARARGS&lt;/code&gt; , which indicates to the C program that it should include &amp;lt;varargs.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;I_VARARGS&lt;/code&gt; ，它向C程序指示它应包含&amp;lt;varargs.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="58139b2e3b281a9a118c344ae314fa19f7ef819b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;MYMALLOC&lt;/code&gt; in case other parts of the source want to take special action if &lt;code&gt;MYMALLOC&lt;/code&gt; is used. This may include different sorts of profiling or error detection.</source>
          <target state="translated">如果使用 &lt;code&gt;MYMALLOC&lt;/code&gt; 时源的其他部分想要采取特殊措施，则此变量有条件地定义 &lt;code&gt;MYMALLOC&lt;/code&gt; 。这可能包括不同种类的分析或错误检测。</target>
        </trans-unit>
        <trans-unit id="2c8fdadfdd30950a7b700d396be77876a6f4c5f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; . It is set to undef when &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; is empty.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 。当 &lt;code&gt;PERL_INC_VERSION_LIST&lt;/code&gt; 为空时，将其设置为undef 。</target>
        </trans-unit>
        <trans-unit id="4ff46e0082d05a29ab6252efc4bd771d18d5878f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; , which contains a colon-separated set of paths for the perl binary to include in @&lt;code&gt;INC&lt;/code&gt; . See also otherlibdirs.</source>
          <target state="translated">此变量有条件定义 &lt;code&gt;PERL_OTHERLIBDIRS&lt;/code&gt; ，其中包含一个冒号分隔的一组路径用于Perl二进制到在@包括 &lt;code&gt;INC&lt;/code&gt; 。另请参见otherlibdirs。</target>
        </trans-unit>
        <trans-unit id="caef6d2331c84b17275d3f9012789c819b377ba9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORBIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533111c8d8f10b6751abb6a1a0088f4c19073d3e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORLIB&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="177a5dd44b77ca5ced87275d19c31e96d16bc7b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PERL_VENDORSCRIPT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cc9c3d91fb6f28bed8329dae1d992b2ddc3b88b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; , which indicates the C compiler allows printf-like formats to be null.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PRINTF_FORMAT_NULL_OK&lt;/code&gt; ，这表明C编译器允许类似printf的格式为null。</target>
        </trans-unit>
        <trans-unit id="1b45d18a0fa0b9cd91b944a53b1e7323f8adc333" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWAGE&lt;/code&gt; , which indicates that struct passwd contains pw_age.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWAGE&lt;/code&gt; ，它指示结构passwd包含pw_age。</target>
        </trans-unit>
        <trans-unit id="6b184e19c4dcc5f872f5344f6afc9d5aa8890c36" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCHANGE&lt;/code&gt; , which indicates that struct passwd contains pw_change.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCHANGE&lt;/code&gt; ，它指示结构passwd包含pw_change。</target>
        </trans-unit>
        <trans-unit id="da5fb50ace415a9312b25c289ac7ee228f0dd1f8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCLASS&lt;/code&gt; , which indicates that struct passwd contains pw_class.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCLASS&lt;/code&gt; ，它指示struct passwd包含pw_class。</target>
        </trans-unit>
        <trans-unit id="9f567085df536f85d28a3794c7c79c2f135c39fc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWCOMMENT&lt;/code&gt; , which indicates that struct passwd contains pw_comment.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWCOMMENT&lt;/code&gt; ，它指示结构passwd包含pw_comment。</target>
        </trans-unit>
        <trans-unit id="2223305749b21469a0762164dc8dc0df3aaa8c7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWEXPIRE&lt;/code&gt; , which indicates that struct passwd contains pw_expire.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWEXPIRE&lt;/code&gt; ，指示结构passwd包含pw_expire。</target>
        </trans-unit>
        <trans-unit id="ebf2af3d9e7342f5f1fe442fb4ba6590cba3aeaf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWGECOS&lt;/code&gt; , which indicates that struct passwd contains pw_gecos.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;PWGECOS&lt;/code&gt; ，它指示结构passwd包含pw_gecos。</target>
        </trans-unit>
        <trans-unit id="e4df7b4ce4ecdac74c8fac53257d7c54e9e2b1d2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWPASSWD&lt;/code&gt; , which indicates that struct passwd contains pw_passwd.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWPASSWD&lt;/code&gt; ，它指示结构passwd包含pw_passwd。</target>
        </trans-unit>
        <trans-unit id="f6f5c85237fcc07cb2101d49b94de63960320aab" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;PWQUOTA&lt;/code&gt; , which indicates that struct passwd contains pw_quota.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;PWQUOTA&lt;/code&gt; ，它指示结构passwd包含pw_quota。</target>
        </trans-unit>
        <trans-unit id="8e6dc66871cca735678df0954175fa95cf018eb7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; if setuid scripts can be secure. This test looks in</source>
          <target state="translated">如果setuid脚本可以安全，则此变量有条件地定义 &lt;code&gt;SETUID_SCRIPTS_ARE_SECURE_NOW&lt;/code&gt; 。该测试在</target>
        </trans-unit>
        <trans-unit id="81f004e1abf850968e0e52c15f9f6cad13d862f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;SITEARCH&lt;/code&gt; to hold the pathname of architecture-dependent library files for $package. If $sitearch is the same as $archlib, then this is set to undef.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;SITEARCH&lt;/code&gt; 来保存$ package依赖于体系结构的库文件的路径名。如果$ sitearch与$ archlib相同，则将其设置为undef。</target>
        </trans-unit>
        <trans-unit id="8b1027f2dc2d15c75eedea147e9dd18e08a6014d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDCHAR&lt;/code&gt; to be the type of char used in</source>
          <target state="translated">此变量有条件地将 &lt;code&gt;STDCHAR&lt;/code&gt; 定义为用于</target>
        </trans-unit>
        <trans-unit id="f33764730e4076b75f7a54ca0311a31df43bbaae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_cnt&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">如果 &lt;code&gt;FILE_cnt&lt;/code&gt; 宏可用作左值，则此变量有条件地定义 &lt;code&gt;STDIO_CNT_LVALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e69f3a8bd1de18db50aaf0b9ef5033e3dafd978" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; if the &lt;code&gt;FILE_ptr&lt;/code&gt; macro can be used as an lvalue.</source>
          <target state="translated">如果 &lt;code&gt;FILE_ptr&lt;/code&gt; 宏可用作左值，则此变量有条件地定义 &lt;code&gt;STDIO_PTR_LVALUE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7bc8c4e73c6aaa4fc8b7bd3db1eed9675bd50c1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; if getpgrp needs one arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none.</source>
          <target state="translated">如果getpgrp需要一个参数而 &lt;code&gt;USG&lt;/code&gt; 一个不需要，则此变量有条件地定义 &lt;code&gt;USE_BSD_GETPGRP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4cb9da0f1f2c05f27c0a4f7de8f8706f136adf70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; if setpgrp needs two arguments whereas &lt;code&gt;USG&lt;/code&gt; one needs none. See also d_setpgid for a &lt;code&gt;POSIX&lt;/code&gt; interface.</source>
          <target state="translated">如果setpgrp需要两个参数，而 &lt;code&gt;USG&lt;/code&gt; 一个不需要，则此变量有条件地定义 &lt;code&gt;USE_BSD_SETPGRP&lt;/code&gt; 。关于 &lt;code&gt;POSIX&lt;/code&gt; 接口，另请参见d_setpgid 。</target>
        </trans-unit>
        <trans-unit id="f057b25789e3d0c0c978f875ab711fef26822396" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; to indicate that the ioctl() call with &lt;code&gt;TIOCNOTTY&lt;/code&gt; should be used to void tty association. Otherwise (on &lt;code&gt;USG&lt;/code&gt; probably), it is enough to close the standard file descriptors and do a setpgrp().</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;USE_IOCNOTTY&lt;/code&gt; ,以指示应该将带有 &lt;code&gt;TIOCNOTTY&lt;/code&gt; 的ioctl（）调用用于使tty关联无效。否则（可能在 &lt;code&gt;USG&lt;/code&gt; 上），足以关闭标准文件描述符并执行setpgrp（）。</target>
        </trans-unit>
        <trans-unit id="c86f9683041fce14f0acc7f22e22cb66e7ecf21d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; , which indicates that struct semid_ds * is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMID_DS&lt;/code&gt; ，这表明struct semid_ds *将用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="165216a22f48262f27b72dd85b30d1c442227e08" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; , which indicates that union semun is to be used for semctl &lt;code&gt;IPC_STAT&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;USE_SEMCTL_SEMUN&lt;/code&gt; ，这指示将联合semun用于semctl &lt;code&gt;IPC_STAT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d946a174db1c59c6d451a81dd08b793b70e50298" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; if this system has a stat structure declaring st_blksize and st_blocks.</source>
          <target state="translated">此变量有条件定义 &lt;code&gt;USE_STAT_BLOCKS&lt;/code&gt; 如果该系统具有一个stat结构声明st_blksize和的st_blocks。</target>
        </trans-unit>
        <trans-unit id="4f2a34f2d97a9448f367a3e7dc94f6a98d0c8541" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring a usable _base field (or equivalent) in</source>
          <target state="translated">如果此系统具有 &lt;code&gt;FILE&lt;/code&gt; 结构，该文件声明了一个可用的_base字段（或等效项），则此变量有条件地定义 &lt;code&gt;USE_STDIO_BASE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="884014009e45fc4b799369297408405b825f05ec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;USE_STDIO_PTR&lt;/code&gt; if this system has a &lt;code&gt;FILE&lt;/code&gt; structure declaring usable _ptr and _cnt fields (or equivalent) in</source>
          <target state="translated">如果此系统具有 &lt;code&gt;FILE&lt;/code&gt; 结构，该文件声明了以下文件中的可用_ptr和_cnt字段（或等效项），则此变量有条件地定义 &lt;code&gt;USE_STDIO_PTR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ce6f3e2ba733cc080d545a7f5345eaada6b53b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOIDSIG&lt;/code&gt; if this system declares &quot;void (*signal(...))()&quot; in</source>
          <target state="translated">如果此系统在其中声明&amp;ldquo; void（* signal（...））（）&amp;rdquo;，则此变量有条件地定义 &lt;code&gt;VOIDSIG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1b1eb5455ff0e45585c738f286f73520d2bda4a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; if closedir() does not return a value.</source>
          <target state="translated">如果closedir（）不返回值，则此变量有条件地定义 &lt;code&gt;VOID_CLOSEDIR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f67d5b9663b7f0f671bc57d6208cef2ecf39a7bd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines CASTI32, which indicates whether the C compiler can cast large floats to 32-bit ints.</source>
          <target state="translated">这个变量有条件地定义了CASTI32,它表示C编译器是否可以将大的float转换为32位的ints。</target>
        </trans-unit>
        <trans-unit id="1e0e56548eb03f6bba0bfbdaf1893bfedf8b743e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_DUP2 if dup2() is available to duplicate file descriptors.</source>
          <target state="translated">如果dup2()可用于复制文件描述符,则这个变量有条件地定义HAS_DUP2。</target>
        </trans-unit>
        <trans-unit id="439c57e77afcdbc973932168c0d12a970d487a4f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines HAS_LC_MONETARY_2008 if libc has the international currency locale rules from &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008.</source>
          <target state="translated">如果libc具有 &lt;code&gt;POSIX&lt;/code&gt; 1003.1-2008中的国际货币语言环境规则，则此变量有条件地定义HAS_LC_MONETARY_2008。</target>
        </trans-unit>
        <trans-unit id="3d55d58456df494116e8e08588b498d9a5a4a48d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_dbl_dig if this system's header files provide &lt;code&gt;DBL_DIG&lt;/code&gt; , which is the number of significant digits in a double precision number.</source>
          <target state="translated">如果此系统的头文件提供 &lt;code&gt;DBL_DIG&lt;/code&gt; ，则此变量有条件地定义d_dbl_dig ，这是双精度数字中的有效位数。</target>
        </trans-unit>
        <trans-unit id="26943f542b57e3d665241442f5609c91f668a2bc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines d_ldbl_dig if this system's header files provide &lt;code&gt;LDBL_DIG&lt;/code&gt; , which is the number of significant digits in a long double precision number.</source>
          <target state="translated">如果此系统的头文件提供 &lt;code&gt;LDBL_DIG&lt;/code&gt; ，则此变量有条件地定义d_ldbl_dig ，这是长双精度数字中的有效位数。</target>
        </trans-unit>
        <trans-unit id="41d4367b100c21704ff1afa07d5fcbbbff3622b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines pthread_create_joinable. undef if</source>
          <target state="translated">这个变量有条件地定义了pthread_create_joinable。</target>
        </trans-unit>
        <trans-unit id="4e65c9696692a1039d19a96f88bbb8715e74549c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CHSIZE&lt;/code&gt; symbol, which indicates to the C program that the chsize() routine is available to truncate files. You might need a -lx to get this routine.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;CHSIZE&lt;/code&gt; 符号，该符号向C程序表明chsize（）例程可用于截断文件。您可能需要-lx才能获取此例程。</target>
        </trans-unit>
        <trans-unit id="846b0e7427992bb9738c034b084170cbd17a9268" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CRYPT&lt;/code&gt; symbol, which indicates to the C program that the crypt() routine is available to encrypt passwords and the like.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;CRYPT&lt;/code&gt; 符号，该符号向C程序指示crypt（）例程可用于加密密码等。</target>
        </trans-unit>
        <trans-unit id="357bf08dc30645376499e133bedc6c5b51689b15" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;CSH&lt;/code&gt; symbol, which indicates to the C program that the C-shell exists.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;CSH&lt;/code&gt; 符号，该符号向C程序指示C-shell存在。</target>
        </trans-unit>
        <trans-unit id="e54e9f341c505bb1d2ec118651994c8e65d0f811" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; symbol and indicates whether file locking with fcntl() works.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;FCNTL_CAN_LOCK&lt;/code&gt; 符号，并指示使用fcntl（）锁定文件是否有效。</target>
        </trans-unit>
        <trans-unit id="02d3adba206dca72cb969c2114087d914736e57e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;FLEXFILENAMES&lt;/code&gt; symbol, which indicates that the system supports filenames longer than 14 characters.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;FLEXFILENAMES&lt;/code&gt; 符号，该符号表示系统支持长度超过14个字符的文件名。</target>
        </trans-unit>
        <trans-unit id="b6165df6dc3c074b8386cff10673ed582f2313bf" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASCONST&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the const type.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASCONST&lt;/code&gt; 符号，该符号向C程序表明该C编译器知道const类型。</target>
        </trans-unit>
        <trans-unit id="514ce51d44fd8efc6f22a726ff2d864524dc5927" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HASVOLATILE&lt;/code&gt; symbol, which indicates to the C program that this C compiler knows about the volatile declaration.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HASVOLATILE&lt;/code&gt; 符号，该符号向C程序表明该C编译器知道有关volatile声明的信息。</target>
        </trans-unit>
        <trans-unit id="3baa45e96d482436f92754c7ebdc6a73550f0eae" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACCESSX&lt;/code&gt; symbol, which indicates to the C program that the accessx() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ACCESSX&lt;/code&gt; 符号，该符号向C程序表明accessx（）例程可用。</target>
        </trans-unit>
        <trans-unit id="12a76ff5170c955de143e03f08fd4db9b4437e7b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ACOSH&lt;/code&gt; symbol, which indicates to the C program that the acosh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ACOSH&lt;/code&gt; 符号，该符号向C程序指示acosh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="3bbc6bd18282fbbaa0a5df512d46d448872f79f0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_AINTL&lt;/code&gt; symbol, which indicates to the C program that the aintl() routine is available. If copysignl is also present we can emulate modfl.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_AINTL&lt;/code&gt; 符号，该符号向C程序指示aintl（）例程可用。如果copysignl也存在，我们可以模拟modfl。</target>
        </trans-unit>
        <trans-unit id="ac4f3fc539e3b11a8b62b87684564e56d5832bdb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ALARM&lt;/code&gt; symbol, which indicates to the C program that the alarm() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ALARM&lt;/code&gt; 符号，该符号向C程序指示alarm（）例程可用。</target>
        </trans-unit>
        <trans-unit id="393748ad8a6e58564f59c88a5a65a0fccff40956" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; symbol, which indicates to the C program that the asctime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ASCTIME_R&lt;/code&gt; 符号，该符号向C程序指示asctime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="e6240de5e54fe3a786d797ae169f9a039181d8e9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ASINH&lt;/code&gt; symbol, which indicates to the C program that the asinh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ASINH&lt;/code&gt; 符号，该符号向C程序指示asinh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="968fc15f09fb64edc7440ecd0aed6b099eb7c13a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATANH&lt;/code&gt; symbol, which indicates to the C program that the atanh() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ATANH&lt;/code&gt; 符号，该符号向C程序表明atanh（）例程可用。</target>
        </trans-unit>
        <trans-unit id="0b6ee241d9266a7948fd72b86cd3046b1822d99c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLF&lt;/code&gt; symbol, which indicates to the C program that the atolf() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ATOLF&lt;/code&gt; 符号，该符号向C程序指示atolf（）例程可用。</target>
        </trans-unit>
        <trans-unit id="7f44fe9ea95c9ae1f907047c17022ef03aa1acbb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ATOLL&lt;/code&gt; symbol, which indicates to the C program that the atoll() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ATOLL&lt;/code&gt; 符号，该符号向C程序指示atoll（）例程可用。</target>
        </trans-unit>
        <trans-unit id="d5e0162b328b8a9b754dac6231795ba2f27a65bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; symbol, which indicates to the C program that the backtrace() routine is available to get a stack trace.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_BACKTRACE&lt;/code&gt; 符号，该符号向C程序指示backtrace（）例程可用于获取堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="e96fa08dff1194cea11b6b542d4bb635e9998fe7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCMP&lt;/code&gt; symbol if the bcmp() routine is available to compare strings.</source>
          <target state="translated">如果bcmp（）例程可用于比较字符串，则此变量有条件地定义 &lt;code&gt;HAS_BCMP&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="2c3a347a1f168f38f12b42fec82e5a9d4a71e447" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BCOPY&lt;/code&gt; symbol if the bcopy() routine is available to copy strings.</source>
          <target state="translated">如果bcopy（）例程可用于复制字符串，则此变量有条件地定义 &lt;code&gt;HAS_BCOPY&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="fe7d21ac1bac028a9a4864da166ebd5752380e71" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_BZERO&lt;/code&gt; symbol if the bzero() routine is available to set memory to 0.</source>
          <target state="translated">如果bzero（）例程可用于将内存设置为0，则此变量有条件地定义 &lt;code&gt;HAS_BZERO&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="6ca90016e7f6abf49f24d5147f764f4e266fad51" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CBRT&lt;/code&gt; symbol, which indicates to the C program that the cbrt() (cube root) function is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CBRT&lt;/code&gt; 符号，该符号向C程序指示cbrt（）（多维数据集根）功能可用。</target>
        </trans-unit>
        <trans-unit id="9190489c62bb031470f6a8b4f7cd7a1825719930" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHOWN&lt;/code&gt; symbol, which indicates to the C program that the chown() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CHOWN&lt;/code&gt; 符号，该符号向C程序指示chown（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ab782a1830d8f2fd000403d6b221d923f1975987" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CHROOT&lt;/code&gt; symbol, which indicates to the C program that the chroot() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CHROOT&lt;/code&gt; 符号，该符号向C程序表明chroot（）例程可用。</target>
        </trans-unit>
        <trans-unit id="32e6c736a6ca4ad0fe4ee89e271bd5cc262bc051" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLASS&lt;/code&gt; symbol, which indicates to the C program that the class() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CLASS&lt;/code&gt; 符号，该符号向C程序指示class（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a075a89328697cbb603b70b3c6d8d110f118b481" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CLEARENV&lt;/code&gt; symbol, which indicates to the C program that the clearenv () routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CLEARENV&lt;/code&gt; 符号，该符号向C程序表明clearenv（）例程可用。</target>
        </trans-unit>
        <trans-unit id="74f77f33bb77370820b1492e4169ae2248f4c8c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; symbol, which indicates to the C program that the copysign() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_COPYSIGN&lt;/code&gt; 符号，该符号向C程序指示copysign（）例程可用。</target>
        </trans-unit>
        <trans-unit id="98b66499ba2e3361546a98261177f15a6de1a0f6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; symbol, which indicates to the C program that the copysignl() routine is available. If aintl is also present we can emulate modfl.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_COPYSIGNL&lt;/code&gt; 符号，该符号向C程序指示copysignl（）例程可用。如果还存在aintl，我们可以模拟modfl。</target>
        </trans-unit>
        <trans-unit id="df0f6e4346afa66f63cca26a76d791fade6366c0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; symbol, which indicates to the C program that the crypt_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CRYPT_R&lt;/code&gt; 符号，该符号向C程序指示crypt_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="953edbb919ba277a0602d4f2fae83655b7094d65" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; symbol, which indicates to the C program that the ctermid_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_CTERMID_R&lt;/code&gt; 符号，该符号向C程序表明ctermid_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="88f0e31c279f299ee13d676f3280ed80bdc1ec78" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CTIME_R&lt;/code&gt; symbol, which indicates to the C program that the ctime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CTIME_R&lt;/code&gt; 符号，该符号向C程序指示ctime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f94152d7278e725fe89c658a702df792c385b802" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_CUSERID&lt;/code&gt; symbol, which indicates to the C program that the cuserid() routine is available to get character login names.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_CUSERID&lt;/code&gt; 符号，该符号向C程序表明cuserid（）例程可用于获取字符登录名。</target>
        </trans-unit>
        <trans-unit id="ce2c192cea1c48bf6a95dcfd9e173ca30310cf0e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the dbminit() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DBMINIT_PROTO&lt;/code&gt; 符号，该符号向C程序表明系统为dbminit（）函数提供了原型。否则，由程序提供一个。</target>
        </trans-unit>
        <trans-unit id="9f277ae3e34118b1fe4f7a94827507d1e32928ea" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; symbol, which indicates to the C program that the difftime() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DIFFTIME&lt;/code&gt; 符号，该符号向C程序指示difftime（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a13740603c74d16121c0903202111151cb13d77c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIRFD&lt;/code&gt; constant, which indicates to the C program that dirfd() is available to return the file descriptor of a directory stream.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DIRFD&lt;/code&gt; 常量，该常量向C程序指示dirfd（）可用于返回目录流的文件描述符。</target>
        </trans-unit>
        <trans-unit id="87bbbc4e9449012cc05f3e6c9ced36d1a9bc5f01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; symbol, which indicates that the &lt;code&gt;DIR&lt;/code&gt; directory stream type contains a member variable called dd_fd.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DIR_DD_FD&lt;/code&gt; 符号，该符号指示 &lt;code&gt;DIR&lt;/code&gt; 目录流类型包含一个名为dd_fd的成员变量。</target>
        </trans-unit>
        <trans-unit id="ca28447a8986907b62f8a42e124cc4cf1327b826" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLADDR&lt;/code&gt; symbol, which indicates to the C program that the dladdr() routine is available to get a stack trace.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DLADDR&lt;/code&gt; 符号，该符号向C程序表明dladdr（）例程可用于获取堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="44450e1cdbf629ec9119c59c9f90d2b874b7e95d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLERROR&lt;/code&gt; symbol, which indicates to the C program that the dlerror() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_DLERROR&lt;/code&gt; 符号，该符号向C程序指示dlerror（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ed1d2043eb098d6534774a50acff39bfc0910625" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_DLOPEN&lt;/code&gt; symbol, which indicates to the C program that the dlopen() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_DLOPEN&lt;/code&gt; 符号，该符号向C程序指示dlopen（）例程可用。</target>
        </trans-unit>
        <trans-unit id="feae0a63aaa2182b296fd904e1c563d6c234cfec" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_EACCESS&lt;/code&gt; symbol, which indicates to the C program that the eaccess() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_EACCESS&lt;/code&gt; 符号，该符号向C程序指示eaccess（）例程可用。</target>
        </trans-unit>
        <trans-unit id="fc59246a386f8974acd05f0aa4d2f594daee00df" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; symbol, which indicates to the C program that the endgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDGRENT&lt;/code&gt; 符号，该符号向C程序表明endgrent（）例程可用于组数据库的顺序访问。</target>
        </trans-unit>
        <trans-unit id="c3521391643a5fa8000971d289ffbc808252e90e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the endgrent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDGRENT_R&lt;/code&gt; 符号，该符号向C程序指示endgrent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="8ceecbf6a76e7908e513f849eb1de5b3d245fac5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the endhostent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDHOSTENT_R&lt;/code&gt; 符号，该符号向C程序表明endhostent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="85d098e6acbbd799d64738081bddb484d9041c70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the endnetent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDNETENT_R&lt;/code&gt; 符号，该符号向C程序指示endnetent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="416322d92948c65411d0e4d7da6d1b4fcb72938b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the endprotoent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDPROTOENT_R&lt;/code&gt; 符号，该符号向C程序指示endprotoent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="93b579b440342c900503cc17debbb4a84724f3f2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; symbol, which indicates to the C program that the endpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDPWENT&lt;/code&gt; 符号，该符号向C程序指示endpwent（）例程可用于顺序访问passwd数据库。</target>
        </trans-unit>
        <trans-unit id="5fd0311a9220d51e48d013d60dc59e4fb98646e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the endpwent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDPWENT_R&lt;/code&gt; 符号，该符号向C程序指示endpwent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="1975eb77352c3791983498df03109baa693a8003" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the endservent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ENDSERVENT_R&lt;/code&gt; 符号，该符号向C程序指示endersvent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="b18c6ff2e894197a9996c9fa5fb041fb1da60ebb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERF&lt;/code&gt; symbol, which indicates to the C program that the erf() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ERF&lt;/code&gt; 符号，该符号向C程序指示erf（）例程可用。</target>
        </trans-unit>
        <trans-unit id="11cfc319c8768f753a10806f70be842234f0d8c6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ERFC&lt;/code&gt; symbol, which indicates to the C program that the erfc() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ERFC&lt;/code&gt; 符号，该符号向C程序指示erfc（）例程可用。</target>
        </trans-unit>
        <trans-unit id="607d8c09f8852e64deb233f04ab669fe416307e5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; symbol, which indicates to the C program that the &quot;fast stdio&quot; is available to manipulate the stdio buffers directly.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FAST_STDIO&lt;/code&gt; 符号，该符号向C程序表明&amp;ldquo;快速stdio&amp;rdquo;可用于直接操作stdio缓冲区。</target>
        </trans-unit>
        <trans-unit id="4ccef8ea96652d985074f68d669458feccd5e889" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHDIR&lt;/code&gt; symbol, which indicates to the C program that the fchdir() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FCHDIR&lt;/code&gt; 符号，该符号向C程序表明fchdir（）例程可用。</target>
        </trans-unit>
        <trans-unit id="2b2fd22f810dafdb7f08dee5c7b2267e8ea89ef0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHMOD&lt;/code&gt; symbol, which indicates to the C program that the fchmod() routine is available to change mode of opened files.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FCHMOD&lt;/code&gt; 符号，该符号向C程序表明fchmod（）例程可用于更改打开的文件的模式。</target>
        </trans-unit>
        <trans-unit id="9c49735af970135b28a3d9f02063c62ac7d11452" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCHOWN&lt;/code&gt; symbol, which indicates to the C program that the fchown() routine is available to change ownership of opened files.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FCHOWN&lt;/code&gt; 符号，该符号向C程序表明fchown（）例程可用于更改打开的文件的所有权。</target>
        </trans-unit>
        <trans-unit id="f77965caac290b89da17681f28495b9f8fdfe67f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FCNTL&lt;/code&gt; symbol, and indicates whether the fcntl() function exists</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FCNTL&lt;/code&gt; 符号，并指示fcntl（）函数是否存在</target>
        </trans-unit>
        <trans-unit id="a2fcb0bfc83505fad937da436d307c0c9ada3232" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FDIM&lt;/code&gt; symbol, which indicates to the C program that the fdim() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FDIM&lt;/code&gt; 符号，该符号向C程序指示fdim（）例程可用。</target>
        </trans-unit>
        <trans-unit id="11e2724a5c3ae4b7f0de83cc60d5928d8a3f4d81" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITE&lt;/code&gt; symbol, which indicates to the C program that the finite() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FINITE&lt;/code&gt; 符号，该符号向C程序指示finite（）例程可用。</target>
        </trans-unit>
        <trans-unit id="0caf0447193e8dd99c3be264377abad5f070779b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FINITEL&lt;/code&gt; symbol, which indicates to the C program that the finitel() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FINITEL&lt;/code&gt; 符号，该符号向C程序指示finitel（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ef6f0d37edde2d9b9e3068f863ad72dfd028852d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the flock() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FLOCK_PROTO&lt;/code&gt; 符号，该符号向C程序表明系统为flock（）函数提供了原型。否则，由程序提供一个。</target>
        </trans-unit>
        <trans-unit id="b7230abc643d63b3ff949047a34fa476fec01c89" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMA&lt;/code&gt; symbol, which indicates to the C program that the fma() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FMA&lt;/code&gt; 符号，该符号向C程序表明fma（）例程可用。</target>
        </trans-unit>
        <trans-unit id="fe2ccccffbf8d2f15aa401771663c24fe0ef72b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMAX&lt;/code&gt; symbol, which indicates to the C program that the fmax() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FMAX&lt;/code&gt; 符号，该符号向C程序指示fmax（）例程可用。</target>
        </trans-unit>
        <trans-unit id="3df9fdbc0ab5f9af76565f047d2b383854350a70" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FMIN&lt;/code&gt; symbol, which indicates to the C program that the fmin() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FMIN&lt;/code&gt; 符号，该符号向C程序表明fmin（）例程可用。</target>
        </trans-unit>
        <trans-unit id="4c07c14ce41ab8f9b9c87417a26676cf07833635" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FORK&lt;/code&gt; symbol, which indicates to the C program that the fork() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FORK&lt;/code&gt; 符号，该符号向C程序指示fork（）例程可用。</target>
        </trans-unit>
        <trans-unit id="c926988df26ecaa58ebdfaa007ae97cb94e0a26e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; symbol, which indicates to the C program that the pathconf() routine is available to determine file-system related limits and options associated with a given open file descriptor.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FPATHCONF&lt;/code&gt; 符号，该符号向C程序表明pathconf（）例程可用于确定与给定打开文件描述符关联的文件系统相关限制和选项。</target>
        </trans-unit>
        <trans-unit id="9bbd2019de42dcc3e64e59b2a0a5d922b5b1d74e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASS&lt;/code&gt; symbol, which indicates to the C program that the fpclass() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FPCLASS&lt;/code&gt; 符号，该符号向C程序指示fpclass（）例程可用。</target>
        </trans-unit>
        <trans-unit id="d5fe50cfedd8bbd389632006ec016bddca06ada9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fpclassify() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FPCLASSIFY&lt;/code&gt; 符号，该符号向C程序指示fpclassify（）例程可用。</target>
        </trans-unit>
        <trans-unit id="917f1d97f54623a4d5b664a0773e1e59567c63fe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; symbol, which indicates to the C program that the fpclassl() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FPCLASSL&lt;/code&gt; 符号，该符号向C程序指示fpclassl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="7d55b5137fd8aae7bd0294444ae3398b83ef2eb0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; symbol, which indicates to the C program that the fp_class() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FP_CLASS&lt;/code&gt; 符号，该符号向C程序指示fp_class（）例程可用。</target>
        </trans-unit>
        <trans-unit id="b4998906b4a9ccf7bdee0f004832d674aa7bbd9a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; symbol, which indicates to the C program that the fp_classify() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FP_CLASSIFY&lt;/code&gt; 符号，该符号向C程序指示fp_classify（）例程可用。</target>
        </trans-unit>
        <trans-unit id="41f0ce9e1b9e64ce9cd583c93400552f4e5a6a52" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; symbol, which indicates to the C program that the fp_classl() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FP_CLASSL&lt;/code&gt; 符号，该符号向C程序指示fp_classl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="9a718ac3558705993c3b67243a1457d9b8addbd1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FREXPL&lt;/code&gt; symbol, which indicates to the C program that the frexpl() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FREXPL&lt;/code&gt; 符号，该符号向C程序指示frexpl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="80c041b61a3854b0c9acdcab50bfa3457a568fcc" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSEEKO&lt;/code&gt; symbol, which indicates to the C program that the fseeko() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FSEEKO&lt;/code&gt; 符号，该符号向C程序表明fseeko（）例程可用。</target>
        </trans-unit>
        <trans-unit id="4051a12dce9cc656f7cd21a6c5cca4ada63aa004" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATFS&lt;/code&gt; symbol, which indicates to the C program that the fstatfs() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FSTATFS&lt;/code&gt; 符号，该符号向C程序表明fstatfs（）例程可用。</target>
        </trans-unit>
        <trans-unit id="376e9454716c971bba83efc24ced69d3a6928836" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; symbol, which indicates to the C program that the fstatvfs() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FSTATVFS&lt;/code&gt; 符号，该符号向C程序表明fstatvfs（）例程可用。</target>
        </trans-unit>
        <trans-unit id="435d2dacb00d4fba9f51b8f56fc86f2e5cd1c130" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FSYNC&lt;/code&gt; symbol, which indicates to the C program that the fsync() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FSYNC&lt;/code&gt; 符号，该符号向C程序表明fsync（）例程可用。</target>
        </trans-unit>
        <trans-unit id="3d1a5f264f0ada9a48dfb15cda9ab839d11e60e6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTELLO&lt;/code&gt; symbol, which indicates to the C program that the ftello() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FTELLO&lt;/code&gt; 符号，该符号向C程序指示ftello（）例程可用。</target>
        </trans-unit>
        <trans-unit id="4064b0e9f22fe23434bd0ec738f58649333e1d6f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FTIME&lt;/code&gt; symbol, which indicates that the ftime() routine exists. The ftime() routine is basically a sub-second accuracy clock.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_FTIME&lt;/code&gt; 符号，该符号指示存在ftime（）例程。ftime（）例程基本上是亚秒级精度时钟。</target>
        </trans-unit>
        <trans-unit id="993d1a28d890386a8f56af4b9e1e99b1a4831c24" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_FUTIMES&lt;/code&gt; symbol, which indicates to the C program that the futimes() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_FUTIMES&lt;/code&gt; 符号，该符号向C程序指示futimes（）例程可用。</target>
        </trans-unit>
        <trans-unit id="43ac0e0e1a1e5f5c73c1a3d69bc5a74620bbdbac" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; symbol, which indicates to the C program that the getaddrinfo() function is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETADDRINFO&lt;/code&gt; 符号，该符号向C程序指示getaddrinfo（）函数可用。</target>
        </trans-unit>
        <trans-unit id="7cc91f8b53047d998123d92a6d27f96f7dfebc76" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETCWD&lt;/code&gt; symbol, which indicates to the C program that the getcwd() routine is available to get the current working directory.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETCWD&lt;/code&gt; 符号，该符号向C程序表明getcwd（）例程可用于获取当前工作目录。</target>
        </trans-unit>
        <trans-unit id="e7004f7e14bed6afec5bd1f4a037a94dbc84c28f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; symbol, which indicates to the C program that the getfsstat() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETFSSTAT&lt;/code&gt; 符号，该符号向C程序指示getfsstat（）例程可用。</target>
        </trans-unit>
        <trans-unit id="2938f1d0c5a29f26cd258b1d2d58005964b3f928" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT&lt;/code&gt; symbol, which indicates to the C program that the getgrent() routine is available for sequential access of the group database.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETGRENT&lt;/code&gt; 符号，该符号向C程序表明getgrent（）例程可用于组数据库的顺序访问。</target>
        </trans-unit>
        <trans-unit id="09573807a7f9ee202cbace6d8d9b71d9e084b114" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; symbol, which indicates to the C program that the getgrent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETGRENT_R&lt;/code&gt; 符号，该符号向C程序指示getgrent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ffdee0c89f8e16f98534bde8ff72861b068f14e2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; symbol, which indicates to the C program that the getgrgid_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETGRGID_R&lt;/code&gt; 符号，该符号向C程序指示getgrgid_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="030e0d1f9c9ec5d5113cadafdb1d46cca6636eba" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getgrnam_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETGRNAM_R&lt;/code&gt; 符号，该符号向C程序指示getgrnam_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="5df49eaa2617f7f95ae5a3bfea499bb49b6e147a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; symbol, which indicates to the C program that the getgroups() routine is available to get the list of process groups.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETGROUPS&lt;/code&gt; 符号，该符号向C程序指示getgroups（）例程可用于获取进程组列表。</target>
        </trans-unit>
        <trans-unit id="800265a52655b0eed9fc30b1377171be6fe75acb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr() routine is available to look up hosts by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETHOSTBYADDR&lt;/code&gt; 符号，该符号向C程序表明gethostbyaddr（）例程可用于按主机的 &lt;code&gt;IP&lt;/code&gt; 地址查找主机。</target>
        </trans-unit>
        <trans-unit id="3ea6fb7457d69ab022ea88e866995c66dd82da32" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyaddr_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETHOSTBYADDR_R&lt;/code&gt; 符号，该符号向C程序指示gethostbyaddr_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f6e8e21dbcc61a6d007e0d9229782dc31b5d46a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname() routine is available to look up host names in some data base or other.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETHOSTBYNAME&lt;/code&gt; 符号，该符号向C程序表明gethostbyname（）例程可用于在某些数据库或其他数据库中查找主机名。</target>
        </trans-unit>
        <trans-unit id="4bf98ecfa6e8572b6387b8b2c890ea9af37d6e48" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the gethostbyname_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETHOSTBYNAME_R&lt;/code&gt; 符号，该符号向C程序指示gethostbyname_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="8ab2674e64e01f9d704936c384471673343e5f6d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; symbol, which indicates to the C program that the gethostent_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETHOSTENT_R&lt;/code&gt; 符号，该符号向C程序指示gethostent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="b5275b5b15c84ca1128b06be5161f949867399a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; symbol, which indicates to the C program that the gethostname() routine may be used to derive the host name.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETHOSTNAME&lt;/code&gt; 符号，该符号向C程序指示gethostname（）例程可用于派生主机名。</target>
        </trans-unit>
        <trans-unit id="db277869ea8d6e46267e65bb1f91f362288123a2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various gethost*() functions. See also</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETHOST_PROTOS&lt;/code&gt; 符号，该符号向C程序表明&amp;lt;netdb.h&amp;gt;为各种gethost *（）函数提供了原型。也可以看看</target>
        </trans-unit>
        <trans-unit id="6911ca40dacf0175aa25657133be0fd097867be4" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETITIMER&lt;/code&gt; symbol, which indicates to the C program that the getitimer() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETITIMER&lt;/code&gt; 符号，该符号向C程序指示getitimer（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f04b4d71f3b0d33d951527806b9faa1b90d89c13" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; symbol, which indicates to the C program that the getlogin() routine is available to get the login name.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETLOGIN&lt;/code&gt; 符号，该符号向C程序指示getlogin（）例程可用于获取登录名。</target>
        </trans-unit>
        <trans-unit id="cf1e0fa70097167eda24ba22a85cbfefb047a83b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; symbol, which indicates to the C program that the getlogin_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETLOGIN_R&lt;/code&gt; 符号，该符号向C程序指示getlogin_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="3040c09147f006139a9558f8a311da05ada71cc3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNT&lt;/code&gt; symbol, which indicates to the C program that the getmnt() routine is available to retrieve one or more mount info blocks by filename.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETMNT&lt;/code&gt; 符号，该符号向C程序指示getmnt（）例程可用于按文件名检索一个或多个安装信息块。</target>
        </trans-unit>
        <trans-unit id="df153c694674c9eb98ea57c25cde4b2529e93311" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; symbol, which indicates to the C program that the getmntent() routine is available to iterate through mounted files to get their mount info.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETMNTENT&lt;/code&gt; 符号，该符号向C程序指示getmntent（）例程可用于遍历已装入的文件以获取其装入信息。</target>
        </trans-unit>
        <trans-unit id="998b35a864ca7293bfdbdc5a68d5a152a1d7c29e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; symbol, which indicates to the C program that the getnameinfo() function is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETNAMEINFO&lt;/code&gt; 符号，该符号向C程序指示getnameinfo（）函数可用。</target>
        </trans-unit>
        <trans-unit id="8474869224bdf2ca0fc35d392c15a984241143e3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr() routine is available to look up networks by their &lt;code&gt;IP&lt;/code&gt; addresses.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETNETBYADDR&lt;/code&gt; 符号，该符号向C程序表明getnetbyaddr（）例程可用于通过其 &lt;code&gt;IP&lt;/code&gt; 地址查找网络。</target>
        </trans-unit>
        <trans-unit id="f75e54ebc6a22f2ef91ec6d724d333f9d033387c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyaddr_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETNETBYADDR_R&lt;/code&gt; 符号，该符号向C程序指示getnetbyaddr_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="6b5ef841b8644e4d43f32175f64b87de38e60b50" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname() routine is available to look up networks by their names.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETNETBYNAME&lt;/code&gt; 符号，该符号向C程序表明getnetbyname（）例程可用于按名称查找网络。</target>
        </trans-unit>
        <trans-unit id="721c47b838e08cebc4dfc525ba1a86bef8ed22b8" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getnetbyname_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETNETBYNAME_R&lt;/code&gt; 符号，该符号向C程序表明getnetbyname_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="5e1f8d2dc25f66de5fe6af8a19d35c75f17a5000" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; symbol, which indicates to the C program that the getnetent_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETNETENT_R&lt;/code&gt; 符号，该符号向C程序指示getnetent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="bceed1c7ecb752248dae3627ddd88c982cb3b42e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getnet*() functions. See also</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETNET_PROTOS&lt;/code&gt; 符号，该符号向C程序表明&amp;lt;netdb.h&amp;gt;为各种getnet *（）函数提供了原型。也可以看看</target>
        </trans-unit>
        <trans-unit id="7aa9f35159df360d21bd577eca2bcbf715c7998d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPGID&lt;/code&gt; symbol, which indicates to the C program that the getpgid(pid) function is available to get the process group id.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPGID&lt;/code&gt; 符号，该符号向C程序指示getpgid（pid）函数可用于获取进程组ID。</target>
        </trans-unit>
        <trans-unit id="04f375e83ea7b8de60cfb2691530d1bc9774418d" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPPID&lt;/code&gt; symbol, which indicates to the C program that the getppid() routine is available to get the parent process &lt;code&gt;ID&lt;/code&gt; .</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPPID&lt;/code&gt; 符号，该符号向C程序表明getppid（）例程可用于获取父进程 &lt;code&gt;ID&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a78c1d0e9007adf39f8c4627cff4de19b836276" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname() routine is available to look up protocols by their name.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPROTOBYNAME&lt;/code&gt; 符号，该符号向C程序表明getprotobyname（）例程可用于按其名称查找协议。</target>
        </trans-unit>
        <trans-unit id="94ee0c74e30f9d4b71ac73fae7e719b93f83ff28" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobyname_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETPROTOBYNAME_R&lt;/code&gt; 符号，该符号向C程序指示getprotobyname_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="89d5b6b59bfef172f96bfa6cc53c69ec52250783" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber() routine is available to look up protocols by their number.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPROTOBYNUMBER&lt;/code&gt; 符号，该符号向C程序表明getprotobynumber（）例程可用于按协议号查找协议。</target>
        </trans-unit>
        <trans-unit id="368c95f7c37edd3f397895e63f2b56a7b2a21f03" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; symbol, which indicates to the C program that the getprotobynumber_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPROTOBYNUMBER_R&lt;/code&gt; 符号，该符号向C程序指示getprotobynumber_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="d05bd546cb9ce10a4ef01cbbaaa2e5620cb6fb98" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; symbol, which indicates to the C program that the getprotoent_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPROTOENT_R&lt;/code&gt; 符号，该符号向C程序指示getprotoent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f547c005ea9729c6769bbf465f8db85dfc630fb1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getproto*() functions. See also</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPROTO_PROTOS&lt;/code&gt; 符号，该符号向C程序表明&amp;lt;netdb.h&amp;gt;为各种getproto *（）函数提供了原型。也可以看看</target>
        </trans-unit>
        <trans-unit id="eaee5a550cc6a07f34637bc2870d60dbfb57bba0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT&lt;/code&gt; symbol, which indicates to the C program that the getpwent() routine is available for sequential access of the passwd database.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETPWENT&lt;/code&gt; 符号，该符号向C程序指示getpwent（）例程可用于顺序访问passwd数据库。</target>
        </trans-unit>
        <trans-unit id="0cfeae59d099abce81836530d715a51913eaf2a9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; symbol, which indicates to the C program that the getpwent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETPWENT_R&lt;/code&gt; 符号，该符号向C程序指示getpwent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="9275e131831690787dbdc11f7dfcedfb8c9f2eda" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getpwnam_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETPWNAM_R&lt;/code&gt; 符号，该符号向C程序指示getpwnam_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="8827a97094e26a9a854d28073049c8082dc5d239" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; symbol, which indicates to the C program that the getpwuid_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETPWUID_R&lt;/code&gt; 符号，该符号向C程序指示getpwuid_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="ddc4a151da38a54d4688d4389e590a62e281759b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; symbol, which indicates to the C program that the getservbyname() routine is available to look up services by their name.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETSERVBYNAME&lt;/code&gt; 符号，该符号向C程序表明getservbyname（）例程可用于按其名称查找服务。</target>
        </trans-unit>
        <trans-unit id="f63223f218d82f595643d54737913a982ed89b01" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyname_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETSERVBYNAME_R&lt;/code&gt; 符号，该符号向C程序表明getservbyname_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="2233b0d3a5dbbbc8649c940b930ca9249fb21aa0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; symbol, which indicates to the C program that the getservbyport() routine is available to look up services by their port.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETSERVBYPORT&lt;/code&gt; 符号，该符号向C程序表明getservbyport（）例程可用于通过其端口查找服务。</target>
        </trans-unit>
        <trans-unit id="e47e4595e0b65cee2c0cb9c76e2aaaffe9e90733" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; symbol, which indicates to the C program that the getservbyport_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETSERVBYPORT_R&lt;/code&gt; 符号，该符号向C程序表明getservbyport_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="07df398a34922beccb5e215e721d52f31b38b932" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; symbol, which indicates to the C program that the getservent_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETSERVENT_R&lt;/code&gt; 符号，该符号向C程序指示getservent_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="08eec3a50cec026084bfb933ad487f92365051f3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; symbol, which indicates to the C program that &amp;lt;netdb.h&amp;gt; supplies prototypes for the various getserv*() functions. See also</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETSERV_PROTOS&lt;/code&gt; 符号，该符号向C程序表明&amp;lt;netdb.h&amp;gt;为各种getserv *（）函数提供了原型。也可以看看</target>
        </trans-unit>
        <trans-unit id="6ee9b27273c95fe6af664a46ca2e4b018eb2a3bb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; symbol, which indicates to the C program that the getspnam_r() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_GETSPNAM_R&lt;/code&gt; 符号，该符号向C程序表明getspnam_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="e672430eb4f4b23e7c8ea71a0d9547945979104c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; symbol, which indicates that the gettimeofday() system call exists (to obtain a sub-second accuracy clock). You should probably include &amp;lt;sys/resource.h&amp;gt;.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GETTIMEOFDAY&lt;/code&gt; 符号，该符号指示存在gettimeofday（）系统调用（以获取亚秒级精度时钟）。您可能应该包括&amp;lt;sys / resource.h&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="84fced701ac1d8972ad41c237d19c362f2099ca2" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; symbol, which indicates to the C program that the gmtime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_GMTIME_R&lt;/code&gt; 符号，该符号向C程序指示gmtime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="1fd3c7d3ad1a3dfa9df8edc33011f70a34e07812" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; symbol, which indicates to the C program that the hasmntopt() routine is available to query the mount options of file systems.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_HASMNTOPT&lt;/code&gt; 符号，该符号向C程序表明hasmntopt（）例程可用于查询文件系统的安装选项。</target>
        </trans-unit>
        <trans-unit id="00e5a920dcdf38a72d0e1f65eec67c25b8f6b02e" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGB&lt;/code&gt; symbol, which indicates to the C program that the ilogb() routine is available for extracting the exponent of double x as a signed integer.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ILOGB&lt;/code&gt; 符号，该符号向C程序指示ilogb（）例程可用于提取double x的指数作为有符号整数。</target>
        </trans-unit>
        <trans-unit id="08c0b5bc5432877b8453b37bdcbcd6004c0f3533" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ILOGBL&lt;/code&gt; symbol, which indicates to the C program that the ilogbl() routine is available for extracting the exponent of long double x as a signed integer. If scalbnl is also present we can emulate frexpl.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ILOGBL&lt;/code&gt; 符号，该符号向C程序指示ilogbl（）例程可用于提取long double x的指数作为有符号整数。如果还存在scalbnl，我们可以模拟frexpl。</target>
        </trans-unit>
        <trans-unit id="d7a6e67ac883b1040cb0eb3aa3cd89d5352feb93" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETNTOP&lt;/code&gt; symbol, which indicates to the C program that the inet_ntop() function is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_INETNTOP&lt;/code&gt; 符号，该符号向C程序指示inet_ntop（）函数可用。</target>
        </trans-unit>
        <trans-unit id="22502f98a24d835efbc320660dd0c293f19ac278" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INETPTON&lt;/code&gt; symbol, which indicates to the C program that the inet_pton() function is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_INETPTON&lt;/code&gt; 符号，该符号向C程序指示inet_pton（）函数可用。</target>
        </trans-unit>
        <trans-unit id="ff67d886f79098d9924c2d3ff3d0db78ccef4ffe" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_INET_ATON&lt;/code&gt; symbol, which indicates to the C program that the inet_aton() function is available to parse &lt;code&gt;IP&lt;/code&gt; address &lt;code&gt;dotted-quad&lt;/code&gt; strings.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_INET_ATON&lt;/code&gt; 符号，该符号向C程序指示inet_aton（）函数可用于解析 &lt;code&gt;IP&lt;/code&gt; 地址的 &lt;code&gt;dotted-quad&lt;/code&gt; 进制字符串。</target>
        </trans-unit>
        <trans-unit id="ab41c4767757cf5520d581b43402f2b69d925446" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_IP_MREQ&lt;/code&gt; 符号，该符号指示结构ip_mreq的可用性。</target>
        </trans-unit>
        <trans-unit id="55f85ff4272b951d973813125721ee335bf64458" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; symbol, which indicates the availability of a struct ip_mreq_source.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_IP_MREQ_SOURCE&lt;/code&gt; 符号，该符号指示结构ip_mreq_source的可用性。</target>
        </trans-unit>
        <trans-unit id="72388a4f1ba17b3fd0e62b5152d323f4548da870" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISASCII&lt;/code&gt; constant, which indicates to the C program that isascii() is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ISASCII&lt;/code&gt; 常数，该常数向C程序指示isascii（）可用。</target>
        </trans-unit>
        <trans-unit id="5a5c21b2a9944da065cad96d5e707e6c815182d3" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISBLANK&lt;/code&gt; constant, which indicates to the C program that isblank() is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ISBLANK&lt;/code&gt; 常量，该常量向C程序指示isblank（）可用。</target>
        </trans-unit>
        <trans-unit id="fcfef1f9f54abc2b109ba1f21e62b9cb30d767cd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITE&lt;/code&gt; symbol, which indicates to the C program that the isfinite() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ISFINITE&lt;/code&gt; 符号，该符号向C程序指示isfinite（）例程可用。</target>
        </trans-unit>
        <trans-unit id="b52552318ae18b7d8b2396ea779d84538ec17c45" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; symbol, which indicates to the C program that the isfinitel() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ISFINITEL&lt;/code&gt; 符号，该符号向C程序指示isfinitel（）例程可用。</target>
        </trans-unit>
        <trans-unit id="5cd5f09b0af60ecfb75127a22d7e1ee2c772c023" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINF&lt;/code&gt; symbol, which indicates to the C program that the isinf() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ISINF&lt;/code&gt; 符号，该符号向C程序指示isinf（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a94a2b2142e85325054f5f4823ba6b83d8fa642a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISINFL&lt;/code&gt; symbol, which indicates to the C program that the isinfl() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ISINFL&lt;/code&gt; 符号，该符号向C程序指示isinfl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="4fd09d1b06bd7c7d728ac0ffd960b30379c4a768" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNAN&lt;/code&gt; symbol, which indicates to the C program that the isnan() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ISNAN&lt;/code&gt; 符号，该符号向C程序指示isnan（）例程可用。</target>
        </trans-unit>
        <trans-unit id="0ae4b6ae907fe92bcc5cb3aa1a2e0540e4b58a60" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNANL&lt;/code&gt; symbol, which indicates to the C program that the isnanl() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_ISNANL&lt;/code&gt; 符号，该符号向C程序指示isnanl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="94a6de8a4e8a40a43a72c3936b6277b9b9b82512" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; symbol, which indicates to the C program that the isnormal() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_ISNORMAL&lt;/code&gt; 符号，该符号向C程序指示isnormal（）例程可用。</target>
        </trans-unit>
        <trans-unit id="9461c7ba3e2b8bec7df67bc8c282aae74033fc39" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_KILLPG&lt;/code&gt; symbol, which indicates to the C program that the killpg() routine is available to kill process groups.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_KILLPG&lt;/code&gt; 符号，该符号向C程序指示killpg（）例程可用于终止进程组。</target>
        </trans-unit>
        <trans-unit id="274a3e469317759be16452a214542288c6b937a7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LCHOWN&lt;/code&gt; symbol, which indicates to the C program that the lchown() routine is available to operate on a symbolic link (instead of following the link).</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_LCHOWN&lt;/code&gt; 符号，该符号向C程序表明lchown（）例程可用于在符号链接上进行操作（而不是跟随该链接）。</target>
        </trans-unit>
        <trans-unit id="0f56859453fc1d27f3f17bb37fc0a2d155502907" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LDEXPL&lt;/code&gt; symbol, which indicates to the C program that the ldexpl() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LDEXPL&lt;/code&gt; 符号，该符号向C程序指示ldexpl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="a37d8cf4a0848f3d9bb4cc5545717c3e60e45b64" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA&lt;/code&gt; symbol, which indicates to the C program that the lgamma() routine is available for the log gamma function. See also d_tgamma and d_lgamma_r.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_LGAMMA&lt;/code&gt; 符号，该符号向C程序表明lgamma（）例程可用于对数伽马函数。另请参见d_tgamma和d_lgamma_r。</target>
        </trans-unit>
        <trans-unit id="5b284947de52d44afb16de832ba8c676b549a69b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; symbol, which indicates to the C program that the lgamma_r() routine is available for the log gamma function, without using the global signgam variable.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LGAMMA_R&lt;/code&gt; 符号，该符号向C程序表明lgamma_r（）例程可用于对数伽马函数，而无需使用全局signgam变量。</target>
        </trans-unit>
        <trans-unit id="ffb5213a88acb50acec17dbb6c54f9e6a79439a1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLRINT&lt;/code&gt; symbol, which indicates to the C program that the llrint() routine is available to return the long long value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LLRINT&lt;/code&gt; 符号，该符号向C程序表明llrint（）例程可用于将最接近（根据当前舍入模式）的long long值返回给x。</target>
        </trans-unit>
        <trans-unit id="36eb192d0749628551dd02acda589177da2e7d35" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLRINTL&lt;/code&gt; symbol, which indicates to the C program that the llrintl() routine is available to return the long long value closest to (according to the current rounding mode) to long double x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LLRINTL&lt;/code&gt; 符号，该符号向C程序表明llrintl（）例程可用于将最接近（根据当前舍入模式）的long long值返回为double double x。</target>
        </trans-unit>
        <trans-unit id="507a36c2b350b208ae4a46fb5a72082e021ebc45" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLROUND&lt;/code&gt; symbol, which indicates to the C program that the llround() routine is available to return the long long value nearest to x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LLROUND&lt;/code&gt; 符号，该符号向C程序表明llround（）例程可用于返回最接近x的long long值。</target>
        </trans-unit>
        <trans-unit id="376c225543a2aa31e29c03d6e79d5c7959f398b0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LLROUNDL&lt;/code&gt; symbol, which indicates to the C program that the llroundl() routine is available to return the long long value nearest to long double x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LLROUNDL&lt;/code&gt; 符号，该符号向C程序表明llroundl（）例程可用于返回最接近long double x的long long值。</target>
        </trans-unit>
        <trans-unit id="26b625166da5e7848c2b479c515fe2ce2068675c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LOCALTIME_R&lt;/code&gt; symbol, which indicates to the C program that the localtime_r() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_LOCALTIME_R&lt;/code&gt; 符号，该符号向C程序指示localtime_r（）例程可用。</target>
        </trans-unit>
        <trans-unit id="c32fe04a06654e46c76a07b1aa643b0837f3e1c9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LOGB&lt;/code&gt; symbol, which indicates to the C program that the logb() routine is available to extract the exponent of x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LOGB&lt;/code&gt; 符号，该符号向C程序指示logb（）例程可用于提取x的指数。</target>
        </trans-unit>
        <trans-unit id="707826980dd3a292f3abccaa532be36235824b3f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LRINT&lt;/code&gt; symbol, which indicates to the C program that the lrint() routine is available to return the integral value closest to (according to the current rounding mode) to x.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_LRINT&lt;/code&gt; 符号，该符号向C程序表明lrint（）例程可用于将最接近（根据当前舍入模式）的整数值返回给x。</target>
        </trans-unit>
        <trans-unit id="13c1d76b4549133b6a13e4a1416e75f07fde92c7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LRINTL&lt;/code&gt; symbol, which indicates to the C program that the lrintl() routine is available to return the integral value closest to (according to the current rounding mode) to long double x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LRINTL&lt;/code&gt; 符号，该符号向C程序指示lrintl（）例程可用于将最接近（根据当前舍入模式）的整数值返回为long double x。</target>
        </trans-unit>
        <trans-unit id="68fa84636788a64a519f29a7d95a105e7ea43315" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LROUND&lt;/code&gt; symbol, which indicates to the C program that the lround() routine is available to return the integral value nearest to x.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LROUND&lt;/code&gt; 符号，该符号向C程序指示lround（）例程可用于返回最接近x的整数值。</target>
        </trans-unit>
        <trans-unit id="8a554bc9a850d4c6deffc69109e332c1e8434acb" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LROUNDL&lt;/code&gt; symbol, which indicates to the C program that the lroundl() routine is available to return the integral value nearest to x of the long double argument.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_LROUNDL&lt;/code&gt; 符号，该符号向C程序表明lroundl（）例程可用于返回最接近long double参数的x的整数值。</target>
        </trans-unit>
        <trans-unit id="9026f0b5e7d8f8d8ec995eda93ddae70790dcdbd" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_LSEEK_PROTO&lt;/code&gt; symbol, which indicates to the C program that the system provides a prototype for the lseek() function. Otherwise, it is up to the program to supply one.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_LSEEK_PROTO&lt;/code&gt; 符号，该符号向C程序表明系统为lseek（）函数提供了原型。否则，由程序提供一个。</target>
        </trans-unit>
        <trans-unit id="702f47257224cd23f04e020414c05342dff68475" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBLEN&lt;/code&gt; symbol, which indicates to the C program that the mblen() routine is available to find the number of bytes in a multibye character.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MBLEN&lt;/code&gt; 符号，该符号向C程序表明mblen（）例程可用于查找多字节字符中的字节数。</target>
        </trans-unit>
        <trans-unit id="68073aab3a42045bf6c2864188f0973dd612c281" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBSTOWCS&lt;/code&gt; symbol, which indicates to the C program that the mbstowcs() routine is available to convert a multibyte string into a wide character string.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MBSTOWCS&lt;/code&gt; 符号，该符号向C程序表明mbstowcs（）例程可用于将多字节字符串转换为宽字符串。</target>
        </trans-unit>
        <trans-unit id="42b542845477967812c79aae9ed300adea839dd9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MBTOWC&lt;/code&gt; symbol, which indicates to the C program that the mbtowc() routine is available to convert multibyte to a wide character.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MBTOWC&lt;/code&gt; 符号，该符号向C程序表明mbtowc（）例程可用于将多字节转换为宽字符。</target>
        </trans-unit>
        <trans-unit id="102db711f4b0e45e67feb844a2fc8fe9e66537a6" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCHR&lt;/code&gt; symbol, which indicates to the C program that the memchr() routine is available to locate characters within a C string.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MEMCHR&lt;/code&gt; 符号，该符号向C程序表明memchr（）例程可用于在C字符串中定位字符。</target>
        </trans-unit>
        <trans-unit id="7235ca768c8d034cec91ebe2d78865b39fdf2ba7" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCMP&lt;/code&gt; symbol, which indicates to the C program that the memcmp() routine is available to compare blocks of memory.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MEMCMP&lt;/code&gt; 符号，该符号向C程序表明memcmp（）例程可用于比较内存块。</target>
        </trans-unit>
        <trans-unit id="9bebe696de97246540e522bb2e6da8fab93032d1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMCPY&lt;/code&gt; symbol, which indicates to the C program that the memcpy() routine is available to copy blocks of memory.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MEMCPY&lt;/code&gt; 符号，该符号向C程序表明memcpy（）例程可用于复制内存块。</target>
        </trans-unit>
        <trans-unit id="325a4968300d1d00834d074e2dda029f39634d7f" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMMOVE&lt;/code&gt; symbol, which indicates to the C program that the memmove() routine is available to copy potentially overlapping blocks of memory.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MEMMOVE&lt;/code&gt; 符号，该符号向C程序表明memmove（）例程可用于复制潜在重叠的内存块。</target>
        </trans-unit>
        <trans-unit id="c7d0f000fc251635fd80e34aa635da5773481577" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MEMSET&lt;/code&gt; symbol, which indicates to the C program that the memset() routine is available to set blocks of memory.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MEMSET&lt;/code&gt; 符号，该符号向C程序表明memset（）例程可用于设置内存块。</target>
        </trans-unit>
        <trans-unit id="dc8f79cfbd2b96ee25d6d1ee5c1384a4ad8b5b3b" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKDIR&lt;/code&gt; symbol, which indicates to the C program that the mkdir() routine is available to create</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MKDIR&lt;/code&gt; 符号，该符号向C程序表明mkdir（）例程可用于创建</target>
        </trans-unit>
        <trans-unit id="0dfb53b8b3dee823205d19c28ace4b726497760a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKDTEMP&lt;/code&gt; symbol, which indicates to the C program that the mkdtemp() routine is available to exclusively create a uniquely named temporary directory.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MKDTEMP&lt;/code&gt; 符号，该符号向C程序表明mkdtemp（）例程可用于专门创建唯一命名的临时目录。</target>
        </trans-unit>
        <trans-unit id="c1f680310dfb70f55e565d1e0109be2e8e4c87f5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKFIFO&lt;/code&gt; symbol, which indicates to the C program that the mkfifo() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MKFIFO&lt;/code&gt; 符号，该符号向C程序指示mkfifo（）例程可用。</target>
        </trans-unit>
        <trans-unit id="d329c85fbd87b445b67f4dc354564f846b9735aa" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKSTEMP&lt;/code&gt; symbol, which indicates to the C program that the mkstemp() routine is available to exclusively create and open a uniquely named temporary file.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MKSTEMP&lt;/code&gt; 符号，该符号向C程序表明mkstemp（）例程可用于专门创建和打开唯一命名的临时文件。</target>
        </trans-unit>
        <trans-unit id="8805b03cf4516a990a6b253e051e527792bc4add" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKSTEMPS&lt;/code&gt; symbol, which indicates to the C program that the mkstemps() routine is available to exclusively create and open a uniquely named (with a suffix) temporary file.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MKSTEMPS&lt;/code&gt; 符号，该符号向C程序表明mkstemps（）例程可用于专门创建和打开唯一命名（带有后缀）的临时文件。</target>
        </trans-unit>
        <trans-unit id="206f66bb208940b6f4dad138b2fc18cc3c165061" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MKTIME&lt;/code&gt; symbol, which indicates to the C program that the mktime() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MKTIME&lt;/code&gt; 符号，该符号向C程序指示mktime（）例程可用。</target>
        </trans-unit>
        <trans-unit id="f8b01b3cc879138798d33d0417c145e742ff8d00" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MODFL&lt;/code&gt; symbol, which indicates to the C program that the modfl() routine is available.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MODFL&lt;/code&gt; 符号，该符号向C程序指示modfl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="59c032422721290310c184282c0c203c9082b8f1" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG&lt;/code&gt; symbol, which indicates that the entire msg*(2) library is present.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MSG&lt;/code&gt; 符号，该符号指示存在整个msg *（2）库。</target>
        </trans-unit>
        <trans-unit id="fb5e836bd1b6ceda16daf87a813a852108bdbdb9" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGCTL&lt;/code&gt; symbol, which indicates to the C program that the msgctl() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSGCTL&lt;/code&gt; 符号，该符号向C程序指示msgctl（）例程可用。</target>
        </trans-unit>
        <trans-unit id="1ef076a7a468a1472229759a7af88f68403a3519" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGGET&lt;/code&gt; symbol, which indicates to the C program that the msgget() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSGGET&lt;/code&gt; 符号，该符号向C程序指示msgget（）例程可用。</target>
        </trans-unit>
        <trans-unit id="95826169e9ec6e737b42970b82165e9dd23743e0" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGRCV&lt;/code&gt; symbol, which indicates to the C program that the msgrcv() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSGRCV&lt;/code&gt; 符号，该符号向C程序表明msgrcv（）例程可用。</target>
        </trans-unit>
        <trans-unit id="8325f3391840c0f56f190ee2693366b6e70a6573" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSGSND&lt;/code&gt; symbol, which indicates to the C program that the msgsnd() routine is available.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSGSND&lt;/code&gt; 符号，该符号向C程序表明msgsnd（）例程可用。</target>
        </trans-unit>
        <trans-unit id="84941c248e23475cd8c896889cac2c4c99454a7c" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_CTRUNC&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_CTRUNC&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSG_CTRUNC&lt;/code&gt; 符号，该符号指示 &lt;code&gt;MSG_CTRUNC&lt;/code&gt; 可用。#ifdef不够，因为它可能是一个枚举，因此已知glibc可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="950da7c3fd59c0e17f00f095ffc534d207054985" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_DONTROUTE&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_DONTROUTE&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSG_DONTROUTE&lt;/code&gt; 符号，该符号指示 &lt;code&gt;MSG_DONTROUTE&lt;/code&gt; 可用。#ifdef不够，因为它可能是一个枚举，因此已知glibc会这样做。</target>
        </trans-unit>
        <trans-unit id="340fb73e5613c1253991bbcd58d22b8f0a4f607a" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_OOB&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_OOB&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSG_OOB&lt;/code&gt; 符号，该符号指示 &lt;code&gt;MSG_OOB&lt;/code&gt; 可用。#ifdef不够，因为它可能是一个枚举，因此已知glibc会这样做。</target>
        </trans-unit>
        <trans-unit id="1ba5b98861532f57b23f48c18b0143746c802ead" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_PEEK&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_PEEK&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">该变量有条件地定义 &lt;code&gt;HAS_MSG_PEEK&lt;/code&gt; 符号，该符号指示 &lt;code&gt;MSG_PEEK&lt;/code&gt; 可用。#ifdef不够，因为它可能是一个枚举，因此已知glibc会这样做。</target>
        </trans-unit>
        <trans-unit id="21d1bc76282392273685e2fda20d7ff8209a22b5" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_MSG_PROXY&lt;/code&gt; symbol, which indicates that the &lt;code&gt;MSG_PROXY&lt;/code&gt; is available. #ifdef is not enough because it may be an enum, glibc has been known to do this.</source>
          <target state="translated">此变量有条件地定义 &lt;code&gt;HAS_MSG_PROXY&lt;/code&gt; 符号，该符号指示 &lt;code&gt;MSG_PROXY&lt;/code&gt; 可用。#ifdef不够，因为它可能是一个枚举，因此已知glibc会这样做。</target>
        </trans-unit>
        <trans-unit id="d1603a6598296b1c4fdf0ef321efb381ba924904" translate="yes" xml:space="preserve">
          <source>This variable conditionally defines the &lt;code&gt;HAS_NDBM&lt;/code&gt; symbol, which indicates that both the</source>
          <target state="translated">此变量有条件地定义了 &lt;code&gt;HAS_NDBM&lt;/code&gt; 符号，该符号表示</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
