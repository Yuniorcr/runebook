<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="49b0c6a17d4f130bfec02b6faa0add21c28561e6" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;glob('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;glob('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt;, or &lt;code&gt;glob('c:/Program\ Files/*/*.dll')&lt;/code&gt;. The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt;, so see &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a8df9b760336178fca425339ec1c7e542a2463" translate="yes" xml:space="preserve">
          <source>Spain</source>
          <target state="translated">Spain</target>
        </trans-unit>
        <trans-unit id="39b253a2d834caa9ad3a83fa215c9eabff3effb2" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; , that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="translated">说到调试，Perl中有几种编译控制可用于控制和调试正则表达式。在上一节中，我们已经遇到了一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval';&lt;/code&gt; ，请使用 re'eval'; ，它允许变量插值和代码表达式共存于正则表达式中。其他的语用是</target>
        </trans-unit>
        <trans-unit id="0bc7408574e69956819d40445cf53d374170785f" translate="yes" xml:space="preserve">
          <source>Speaking of debugging, there are several pragmas available to control and debug regexps in Perl. We have already encountered one pragma in the previous section, &lt;code&gt;use re 'eval';&lt;/code&gt;, that allows variable interpolation and code expressions to coexist in a regexp. The other pragmas are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cdd144975003eba8959b061eba84041ab9e203b" translate="yes" xml:space="preserve">
          <source>Speaking of the build directory. Do I have to clean it up myself?</source>
          <target state="translated">说到构建目录。我必须自己清理吗?</target>
        </trans-unit>
        <trans-unit id="cf16c389cb12320d4c2b7cc5db763c0d5676df4a" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; , the following are actually the same thing:</source>
          <target state="translated">说到 &lt;code&gt;@{$AoA[$i]}&lt;/code&gt; 之类的东西，实际上是相同的：</target>
        </trans-unit>
        <trans-unit id="83aa40d82b5ec161297d7a176f14d055b800dde4" translate="yes" xml:space="preserve">
          <source>Speaking of things like &lt;code&gt;@{$AoA[$i]}&lt;/code&gt;, the following are actually the same thing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="942078ca2d04f25545a316c123a392c4d5d339fd" translate="yes" xml:space="preserve">
          <source>Special</source>
          <target state="translated">Special</target>
        </trans-unit>
        <trans-unit id="735223734da1211964b616a8067d85971e38faaf" translate="yes" xml:space="preserve">
          <source>Special &lt;code&gt;make test&lt;/code&gt; targets</source>
          <target state="translated">特殊 &lt;code&gt;make test&lt;/code&gt; 目标</target>
        </trans-unit>
        <trans-unit id="fdfdc56af4901b065f0b9e0022efafcd50dad6b5" translate="yes" xml:space="preserve">
          <source>Special Backtracking Control Verbs</source>
          <target state="translated">特殊回溯控制动词</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">特殊情况</target>
        </trans-unit>
        <trans-unit id="c09831be5235393e990f8ebc035a5453fef09355" translate="yes" xml:space="preserve">
          <source>Special Characters Inside a Bracketed Character Class</source>
          <target state="translated">括号内的特殊字符</target>
        </trans-unit>
        <trans-unit id="076a0893de022e884b65708a98aa1abe56ee52c6" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 过载专用键</target>
        </trans-unit>
        <trans-unit id="fd43bdf2a69d1a862223b1bbefa15cce4dedd0cb" translate="yes" xml:space="preserve">
          <source>Special Keys for &lt;code&gt;use overload&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1bc7b98edc6763e9d6c0abf8b4fa80886e2046f" translate="yes" xml:space="preserve">
          <source>Special Keys for use overload</source>
          <target state="translated">过载使用的特殊键</target>
        </trans-unit>
        <trans-unit id="749ad8df41c6024cc71b56ff395f77ccf401c88e" translate="yes" xml:space="preserve">
          <source>Special Literals</source>
          <target state="translated">特殊文字</target>
        </trans-unit>
        <trans-unit id="d4cb1cbcc64290386b7c11a130ff81a51320cc9f" translate="yes" xml:space="preserve">
          <source>Special Patterns</source>
          <target state="translated">特殊模式</target>
        </trans-unit>
        <trans-unit id="f4d1e4b7e421f179bd6711768af6fd760a8db942" translate="yes" xml:space="preserve">
          <source>Special Topics</source>
          <target state="translated">专题</target>
        </trans-unit>
        <trans-unit id="93e61da05b321c91a757c91aeb83a231cf936002" translate="yes" xml:space="preserve">
          <source>Special behaviors for OS X</source>
          <target state="translated">OS X的特殊行为</target>
        </trans-unit>
        <trans-unit id="e0e39ed69d2c670390ee8a8802b8ef63f9291065" translate="yes" xml:space="preserve">
          <source>Special floating point: infinity (Inf) and not-a-number (NaN)</source>
          <target state="translated">特殊浮点数:无穷大(Inf)和非数(NaN)</target>
        </trans-unit>
        <trans-unit id="ca393fa33bfec26b8152f3f8b37c3b963f3cd851" translate="yes" xml:space="preserve">
          <source>Special make test targets</source>
          <target state="translated">特殊制造测试目标</target>
        </trans-unit>
        <trans-unit id="3bc242af481a6d0584675ca62d67c528336abb44" translate="yes" xml:space="preserve">
          <source>Special note should be made of the return values for a few properties:</source>
          <target state="translated">需要特别注意的是,有几个属性的返回值。</target>
        </trans-unit>
        <trans-unit id="b129e56f9be43046b321c79a90495916b0276970" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, see &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; comparison block or function.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 时的特殊包变量，请参见&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;。由于这种特殊性，即使使用 &lt;code&gt;strict 'vars'&lt;/code&gt; 编译指示，也无需声明 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; （使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our()&lt;/a&gt;&lt;/code&gt; ）。不要用lexicalize他们 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $a&lt;/code&gt; $一个或 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $b&lt;/code&gt; $ B，如果你希望能够在使用它们 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 的比较块或者函数。</target>
        </trans-unit>
        <trans-unit id="11283dda6b65d5275c4aa3ef39c12903730f96b2" translate="yes" xml:space="preserve">
          <source>Special package variables when using &lt;code&gt;sort()&lt;/code&gt;, see &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt;. Because of this specialness &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; don't need to be declared (using &lt;code&gt;use vars&lt;/code&gt;, or &lt;code&gt;our()&lt;/code&gt;) even when using the &lt;code&gt;strict 'vars'&lt;/code&gt; pragma. Don't lexicalize them with &lt;code&gt;my $a&lt;/code&gt; or &lt;code&gt;my $b&lt;/code&gt; if you want to be able to use them in the &lt;code&gt;sort()&lt;/code&gt; comparison block or function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c400e57824d764b6a1f1b8ed067b982b5491dad3" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt; . Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="translated">所使用的特殊regop &lt;code&gt;re_intuit_start()&lt;/code&gt; ，以检查是否一个图案可以在某一位置相匹配。例如，如果正则表达式引擎知道模式必须以'Z'开头，则它可以扫描字符串直到找到一个字符串，然后从那里启动正则表达式引擎。处理该问题的例程称为 &lt;code&gt;find_by_class()&lt;/code&gt; 。有时，该字段指向嵌入在程序中的一个规则的regop，有时指向一个由优化器构造的独立的合成regop。</target>
        </trans-unit>
        <trans-unit id="52f092c6d31813604bca533dbc8c71a0c669a0b7" translate="yes" xml:space="preserve">
          <source>Special regop that is used by &lt;code&gt;re_intuit_start()&lt;/code&gt; to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a 'Z' then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called &lt;code&gt;find_by_class()&lt;/code&gt;. Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c69507b8821a1ac319bfe089337d432b752233" translate="yes" xml:space="preserve">
          <source>Special thanks to Craig Berry and Peter Prymmer (for VMS portability help), Randy Kobes (for Win32 portability help), Clinton Pierce and Autrijus Tang (for heroic eleventh-hour Win32 testing above and beyond the call of duty), Michael G Schwern (for testing advice), and the rest of the CPAN testers (for testing generally).</source>
          <target state="translated">特别感谢Craig Berry和Peter Prymmer(为VMS移植提供帮助),Randy Kobes(为Win32移植提供帮助),Clinton Pierce和Autrijus Tang(为Win32测试的第十一个小时的英勇表现提供帮助),Michael G Schwern(为测试提供建议),以及其他CPAN测试人员(为测试提供帮助)。</target>
        </trans-unit>
        <trans-unit id="5543458d832e80fa74fffef1fb3a6e0c964fd937" translate="yes" xml:space="preserve">
          <source>Special thanks to Jarkko Hietaniemi, the 5.8.0 pumpking, for including this module in the core and for his patient and helpful guidance during the integration process.</source>
          <target state="translated">特别感谢5.8.0 pumpking的Jarkko Hietaniemi,感谢他将这个模块纳入核心,并在集成过程中给予耐心和有益的指导。</target>
        </trans-unit>
        <trans-unit id="bdc349ae3de267bae2e06e8394305bd25b3d697e" translate="yes" xml:space="preserve">
          <source>Special thanks to Tels for suggesting several speed and memory optimizations.</source>
          <target state="translated">特别感谢Tels提出的多项速度和内存优化建议。</target>
        </trans-unit>
        <trans-unit id="58c72ff51f409e740d18b159d1db36db70f1453a" translate="yes" xml:space="preserve">
          <source>Special thanks to the following people who assisted in the creation of the document.</source>
          <target state="translated">特别感谢下列人员协助编写本文件:</target>
        </trans-unit>
        <trans-unit id="b9982eff3f0e28f25e92903f06ecf866a5e7dab5" translate="yes" xml:space="preserve">
          <source>Special variables that have side effects when you access them or assign to them. For example, in Perl, changing elements of the &lt;code&gt;%ENV&lt;/code&gt; array also changes the corresponding environment variables that subprocesses will use. Reading the &lt;code&gt;$!&lt;/code&gt; variable gives you the current system error number or message.</source>
          <target state="translated">访问或分配给它们时会产生副作用的特殊变量。例如，在Perl中，更改 &lt;code&gt;%ENV&lt;/code&gt; 数组的元素也会更改子流程将使用的相应环境变量。读 &lt;code&gt;$!&lt;/code&gt; 变量为您提供当前的系统错误号或消息。</target>
        </trans-unit>
        <trans-unit id="100bcda8aa4f874878478525651d3bbff5ff7492" translate="yes" xml:space="preserve">
          <source>Specialised Import Lists</source>
          <target state="translated">专业进口清单</target>
        </trans-unit>
        <trans-unit id="7b09828591f2a4848f0494348259138540610a11" translate="yes" xml:space="preserve">
          <source>Specific (mis)features of OS/2 port</source>
          <target state="translated">OS/2端口的具体(错误)特征</target>
        </trans-unit>
        <trans-unit id="f1dec8c277f6ad361d73048827b65d45acdb1217" translate="yes" xml:space="preserve">
          <source>Specific features of the Cygwin port</source>
          <target state="translated">Cygwin port的具体功能</target>
        </trans-unit>
        <trans-unit id="686482526f9ca64e951de751df199a7ac0b21959" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Gives the directory part of the location for</source>
          <target state="translated">专用于 EMX port。给予目录中的</target>
        </trans-unit>
        <trans-unit id="8719eacadd757c4d532ec01e84ca717f26242d45" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Should have the form</source>
          <target state="translated">EMX端口专用。应具有以下形式</target>
        </trans-unit>
        <trans-unit id="57a0519d586edded6d90f93d7b49b9ce56048c1e" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since</source>
          <target state="translated">专门针对EMX端口。由于</target>
        </trans-unit>
        <trans-unit id="3f69d6ce7ad07d5935103bd51d3ea2a5f16d4ee9" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17684874cc7718b5fa207627bf38a956b3362a43" translate="yes" xml:space="preserve">
          <source>Specific for EMX port. Used as storage place for temporary files.</source>
          <target state="translated">EMX端口专用。用作临时文件的存放处。</target>
        </trans-unit>
        <trans-unit id="e8a7871f78fa47c54d3b07594f2afe06c4064c9a" translate="yes" xml:space="preserve">
          <source>Specific types of access to files that can be requested via the &lt;code&gt;$uAccess&lt;/code&gt; argument to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f59751d539130b16033ff7290507022cfe789faf" translate="yes" xml:space="preserve">
          <source>Specifically, notice that the formatting codes are present and unescaped in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee5fb071a0f4fc5995dbb8fab061746ab818f7e" translate="yes" xml:space="preserve">
          <source>Specifically, we read pathnames one at a time from the input array, and store the results in an output array (results) in the same order. If statfs fails, the element pushed onto the return array is the value of errno after the failure. If statfs succeeds, though, the value pushed onto the return array is a reference to a hash containing some of the information in the statfs structure.</source>
          <target state="translated">具体来说,我们每次从输入数组中读取一个路径名,并以同样的顺序将结果存储在输出数组(results)中。如果 statfs 失败,推送到返回数组中的元素是失败后的 errno 值。但如果 statfs 成功了,推送到返回数组上的值是对包含 statfs 结构中一些信息的哈希的引用。</target>
        </trans-unit>
        <trans-unit id="eda3fdece3884b319c275582d4e0949e974b3c68" translate="yes" xml:space="preserve">
          <source>Specifically: Turning on this option will disable the heuristics for seeing only files with Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">具体来说。开启这个选项将禁用启发式功能,只看到带有类似Perl扩展名的文件,省略那些有数字的子目录,但确实是</target>
        </trans-unit>
        <trans-unit id="ed81a4faa05daf1c1be51b7b8fa82d019bf30684" translate="yes" xml:space="preserve">
          <source>Specification for CPAN distribution metadata</source>
          <target state="translated">CPAN分销元数据规范</target>
        </trans-unit>
        <trans-unit id="dffd2f13d0f19c68e6d18b2ad7656bd3be03e49e" translate="yes" xml:space="preserve">
          <source>Specified allowed version number formats</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9358b554d9001e9e29d42fe71cb2423f6e13d1fd" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;a href=&quot;#-e-commandline&quot;&gt;-e&lt;/a&gt; or &lt;a href=&quot;#-E-commandline&quot;&gt;-E&lt;/a&gt; switches on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a4072f8995fd4faf63509594cc45d51dcda62a" translate="yes" xml:space="preserve">
          <source>Specified line by line via &lt;b&gt;-e&lt;/b&gt; or &lt;b&gt;-E&lt;/b&gt; switches on the command line.</source>
          <target state="translated">通过&lt;b&gt;-e&lt;/b&gt;或&lt;b&gt;-E&lt;/b&gt;在命令行上逐行指定。</target>
        </trans-unit>
        <trans-unit id="acc937be340e9018f067e36d4fbe600f0ca7a48d" translate="yes" xml:space="preserve">
          <source>Specifies a TAP::Harness subclass to be used in place of TAP::Harness.</source>
          <target state="translated">指定一个 TAP::Harness 子类来代替 TAP::Harness。</target>
        </trans-unit>
        <trans-unit id="2ccb38b1ea1946cfb54e7b524ba85568b166e308" translate="yes" xml:space="preserve">
          <source>Specifies a name to be used for the extension, e.g., -n RPC::DCE</source>
          <target state="translated">指定用于扩展的名称,例如,-n RPC::DCE。</target>
        </trans-unit>
        <trans-unit id="fb10437a9b9ee94fe2ef27d29d4fd6290157541f" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt; , the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt; .</source>
          <target state="translated">指定用于存储词典条目的编码，而不是utf8字符串。如果设置为 &lt;code&gt;locale&lt;/code&gt; ，则使用来自当前语言环境设置的编码。表示 &lt;code&gt;Decode&lt;/code&gt; 为真值。</target>
        </trans-unit>
        <trans-unit id="6b02361353aebba65f1252053ca8da3ec24a84ab" translate="yes" xml:space="preserve">
          <source>Specifies an encoding to store lexicon entries, instead of utf8-strings. If set to &lt;code&gt;locale&lt;/code&gt;, the encoding from the current locale setting is used. Implies a true value for &lt;code&gt;Decode&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5288f1281b330410c08afae34819d7cfc53b87f4" translate="yes" xml:space="preserve">
          <source>Specifies any additional arguments to pass to the compiler. Should be given as a list reference containing the arguments individually, or if this is not possible, as a string containing all the arguments together.</source>
          <target state="translated">指定要传递给编译器的任何附加参数。应该以包含各个参数的列表引用的形式给出,如果无法做到,则以包含所有参数的字符串形式给出。</target>
        </trans-unit>
        <trans-unit id="8c0fc5c465acc07c545f1645a7b4737064b57885" translate="yes" xml:space="preserve">
          <source>Specifies any additional directories in which to search for header files. May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</source>
          <target state="translated">指定要搜索头文件的任何附加目录。可以用字符串表示单个目录,也可以用列表引用表示多个目录。</target>
        </trans-unit>
        <trans-unit id="df5f877cdfce163f364b76c3bfab4e6c5095d6d8" translate="yes" xml:space="preserve">
          <source>Specifies file structure for file to be transferred.</source>
          <target state="translated">指定要传输的文件结构。</target>
        </trans-unit>
        <trans-unit id="087e5ef636ea46b335e961f7299045a135d4c08f" translate="yes" xml:space="preserve">
          <source>Specifies how much effort bzip2 should take before resorting to a slower fallback compression algorithm.</source>
          <target state="translated">指定在采用较慢的回退压缩算法之前,bzip2 应该付出多少努力。</target>
        </trans-unit>
        <trans-unit id="98ed6b009cf98007a6f6d9bd7e33d610c98ad8ec" translate="yes" xml:space="preserve">
          <source>Specifies one or more directories to search for the input file if it was not supplied with an absolute path. Each directory path in the given list should be separated by a ':' on Unix (';' on MSWin32 and DOS).</source>
          <target state="translated">如果没有提供绝对路径,指定一个或多个目录来搜索输入文件。在给定列表中的每个目录路径在Unix上应该用':'来分隔(在MSWin32和DOS上用';')。</target>
        </trans-unit>
        <trans-unit id="8dd4c4abae664fff706848263f7e2a14f71871c3" translate="yes" xml:space="preserve">
          <source>Specifies source mappings for Tangut ideographs and components. This data file also includes informative radical-stroke values that are used internally by Unicode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e97bcf5fbd96ebc76bb798faacc45cc0f7deca3" translate="yes" xml:space="preserve">
          <source>Specifies source material for Nushu characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b9774b42720c2ff28dbc21e628ebcd3703ef058" translate="yes" xml:space="preserve">
          <source>Specifies that the source file is a C++ source file and sets appropriate compiler flags</source>
          <target state="translated">指定源文件是C++源文件,并设置相应的编译器标志。</target>
        </trans-unit>
        <trans-unit id="752f5b793296a2436f0f638671fc26add2789004" translate="yes" xml:space="preserve">
          <source>Specifies that this distribution shall not be processed at all.</source>
          <target state="translated">指明本次发行完全不做处理。</target>
        </trans-unit>
        <trans-unit id="27c19b2359d6f4ac0335e1401df42879661c8cd1" translate="yes" xml:space="preserve">
          <source>Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.</source>
          <target state="translated">指定临时目录使用的目录。临时目录名称由内部模板导出。</target>
        </trans-unit>
        <trans-unit id="69c1bcd4ebd70c8615309d5b9b715199cd57859f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting from. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">指定要转换的编码。与&lt;b&gt;iconv&lt;/b&gt;不同，此选项可以省略。在这种情况下，将使用当前语言环境。</target>
        </trans-unit>
        <trans-unit id="b6aabb58f01ed0bc266ebcb530fd5e3060867e4c" translate="yes" xml:space="preserve">
          <source>Specifies the encoding you are converting to. Unlike &lt;b&gt;iconv&lt;/b&gt;, this option can be omitted. In such cases, the current locale is used.</source>
          <target state="translated">指定要转换为的编码。与&lt;b&gt;iconv&lt;/b&gt;不同，此选项可以省略。在这种情况下，将使用当前语言环境。</target>
        </trans-unit>
        <trans-unit id="bc14cf57cc1d526c9df38cf39a2a5e11891e51ad" translate="yes" xml:space="preserve">
          <source>Specifies the extension of the module's loadable object. For example:</source>
          <target state="translated">指定模块的可加载对象的扩展。例如:</target>
        </trans-unit>
        <trans-unit id="62350db256aee74b2119a37a32d38d1a559bd3c6" translate="yes" xml:space="preserve">
          <source>Specifies the method or subroutine to use when printing error messages about POD syntax. The supplied method/subroutine</source>
          <target state="translated">指定打印POD语法错误信息时要使用的方法或子程序。提供的方法/子程序</target>
        </trans-unit>
        <trans-unit id="8490adfe21694bc6560acb4c4b017183f5259a5a" translate="yes" xml:space="preserve">
          <source>Specifies the name of the Perl module that will be created by linking. On platforms that need to do prelinking (Win32, OS/2, etc.) this is a required parameter.</source>
          <target state="translated">指定将通过链接创建的Perl模块的名称。在需要进行预链接的平台上(Win32、OS/2等),这是一个必须的参数。</target>
        </trans-unit>
        <trans-unit id="f6fab30529e40665f8d0178ef7752b76fb583aec" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">指定要创建的输出可执行文件的名称。否则，将 &lt;code&gt;exe_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;objects&lt;/code&gt; 第一个条目的名称。</target>
        </trans-unit>
        <trans-unit id="15de15454ec9b8a4605521f63e575015b98bd2c4" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output executable file to create. Otherwise the &lt;code&gt;exe_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712c7b0a7198fb19bf2fcbbf1b68671ab3789d42" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to create. Otherwise the &lt;code&gt;object_file()&lt;/code&gt; method will be consulted, passing it the name of the &lt;code&gt;source&lt;/code&gt; file.</source>
          <target state="translated">指定要创建的输出文件的名称。否则，将 &lt;code&gt;object_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;source&lt;/code&gt; 文件的名称。</target>
        </trans-unit>
        <trans-unit id="0ea5fb9dc13c7dfd946c4f0ec1f502d959136293" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output file to generate. If no file is specified, output will be written to standard output.</source>
          <target state="translated">指定要生成的输出文件的名称,如果没有指定文件,输出将写入标准输出。如果没有指定文件,输出将被写入标准输出。</target>
        </trans-unit>
        <trans-unit id="95eb37279bd4905df986dc0709bc7910f0b3037c" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt; .</source>
          <target state="translated">指定要创建的输出库文件的名称。否则，将 &lt;code&gt;lib_file()&lt;/code&gt; 方法，并向其传递 &lt;code&gt;objects&lt;/code&gt; 第一个条目的名称。</target>
        </trans-unit>
        <trans-unit id="ef72e21940c27171a6511a580792ff08d2fefffd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the output library file to create. Otherwise the &lt;code&gt;lib_file()&lt;/code&gt; method will be consulted, passing it the name of the first entry in &lt;code&gt;objects&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc8b469ff5b98736322a31c19a8ffad03de9557" translate="yes" xml:space="preserve">
          <source>Specifies the string that will be prefixed to every line of the output. Empty string by default.</source>
          <target state="translated">指定输出的每行前缀的字符串。默认为空字符串。</target>
        </trans-unit>
        <trans-unit id="969aa343df55e9a403d592d5b7e666d694e7c272" translate="yes" xml:space="preserve">
          <source>Specifies transfer mode (stream, block or compressed) for file to be transferred.</source>
          <target state="translated">指定要传输的文件的传输模式(流、块或压缩)。</target>
        </trans-unit>
        <trans-unit id="cc7f9fc804bc9d91b61a85b96105c59f7689d5aa" translate="yes" xml:space="preserve">
          <source>Specifies what to do with symbolic links whose target doesn't exist. If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, a warning of the form &lt;code&gt;&quot;symbolic_link_name is a dangling symbolic link\n&quot;&lt;/code&gt; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7aea723a83b432e8b220dab2e656f549c707e4d" translate="yes" xml:space="preserve">
          <source>Specifies which version of the &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt; should be used as the format of the &lt;code&gt;provides&lt;/code&gt; output. Currently only '1.4' and '2' are supported (and their format is identical). This may change in the future as the definition of &lt;code&gt;provides&lt;/code&gt; changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50a3555457e006ff9201a0e994fbe18d143981" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">指定用Perl版本要求 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b40cf4bd5d43a9f1abad87e39cbbacc3be8422d6" translate="yes" xml:space="preserve">
          <source>Specify Perl version requirements with &lt;code&gt;use&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51af544190f4d9e1d2d6358a5fcd6745e16f2552" translate="yes" xml:space="preserve">
          <source>Specify SHELL if needed - not done on Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a389cd0788a594b00d81ac38b0d5b58f982bb23" translate="yes" xml:space="preserve">
          <source>Specify a collation strength of level 1 to ignore case and diacritics, only looking at the basic character.</source>
          <target state="translated">指定1级的整理强度,忽略大小写和双拼,只看基本字符。</target>
        </trans-unit>
        <trans-unit id="fd9decfe42c6333527f5da43637561403cd51753" translate="yes" xml:space="preserve">
          <source>Specify a prefix which should be removed from the Perl function names, e.g., -p sec_rgy_ This sets up the XS &lt;b&gt;PREFIX&lt;/b&gt; keyword and removes the prefix from functions that are autoloaded via the &lt;code&gt;constant()&lt;/code&gt; mechanism.</source>
          <target state="translated">指定应从Perl函数名称中删除的前缀，例如-p sec_rgy_。这将设置XS &lt;b&gt;PREFIX&lt;/b&gt;关键字，并从通过 &lt;code&gt;constant()&lt;/code&gt; 机制自动加载的函数中删除该前缀。</target>
        </trans-unit>
        <trans-unit id="8c37cb69f6acc79919a59db7bb047596246ded37" translate="yes" xml:space="preserve">
          <source>Specify a section to include in the output. See &lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS in Pod::Parser&lt;/a&gt; for the format to use for</source>
          <target state="translated">指定要包含在输出中的部分。请参阅&lt;a href=&quot;pod/parser#SECTION-SPECIFICATIONS&quot;&gt;Pod :: Parser&lt;/a&gt;中的SECTION SPECIFICATIONS，以了解用于</target>
        </trans-unit>
        <trans-unit id="c842e0100e27043e97262bc2a56a8695e0228b4b" translate="yes" xml:space="preserve">
          <source>Specify a version number for this extension. This version number is added to the templates. The default is 0.01, or 0.00_01 if &lt;code&gt;-B&lt;/code&gt; is specified. The version specified should be numeric.</source>
          <target state="translated">指定此扩展的版本号。该版本号已添加到模板中。缺省值为0.01，如果指定 &lt;code&gt;-B&lt;/code&gt; ，则为0.00_01 。指定的版本应为数字。</target>
        </trans-unit>
        <trans-unit id="e7f58f2c2dcff1260c061c4b22f076c9afef1f52" translate="yes" xml:space="preserve">
          <source>Specify content is binary</source>
          <target state="translated">指定内容为二进制</target>
        </trans-unit>
        <trans-unit id="196ff6b62a23b7ba506c7490495c47cea5d35955" translate="yes" xml:space="preserve">
          <source>Specify in seconds how long to run the command before it is killed with SIG_KILL (9), which effectively terminates it and all of its children (direct or indirect).</source>
          <target state="translated">以秒为单位,指定运行命令的时间,然后用SIG_KILL (9)杀死命令,从而有效地终止该命令及其所有子命令(直接或间接)。</target>
        </trans-unit>
        <trans-unit id="e42f9f14e720a274b615a5fad1a17e292745c606" translate="yes" xml:space="preserve">
          <source>Specify pre-requisites in Makefile.PL or Build.PL</source>
          <target state="translated">在Makefile.PL或Build.PL中指定先决条件。</target>
        </trans-unit>
        <trans-unit id="1a3e3b8941c020b4dead165334a6a7f6f39e0c5c" translate="yes" xml:space="preserve">
          <source>Specify replacement for groff</source>
          <target state="translated">指定更换groff</target>
        </trans-unit>
        <trans-unit id="82792121ccf914c52ccf31c689a51331bdf9896b" translate="yes" xml:space="preserve">
          <source>Specify some text that will be passed into the &lt;code&gt;STDIN&lt;/code&gt; of the executed program.</source>
          <target state="translated">指定一些将传递到已执行程序的 &lt;code&gt;STDIN&lt;/code&gt; 中的文本。</target>
        </trans-unit>
        <trans-unit id="e4f8120097eb5801ad49966dad7112d6c8bcad54" translate="yes" xml:space="preserve">
          <source>Specify stream encoding. This is the normal way to deal with encoded text, not by calling low-level functions.</source>
          <target state="translated">指定流编码。这是处理编码文本的正常方式,而不是通过调用低级函数。</target>
        </trans-unit>
        <trans-unit id="8473cee86e4b03ee43a6c19c0f0dc45619e13394" translate="yes" xml:space="preserve">
          <source>Specify the HTML file to create. Output goes to STDOUT if no outfile is specified.</source>
          <target state="translated">指定要创建的HTML文件。如果没有指定输出文件,则输出到STDOUT。</target>
        </trans-unit>
        <trans-unit id="2deadb9e68c32c96f8a837b13d5dc23a9778d417" translate="yes" xml:space="preserve">
          <source>Specify the URL of a cascading style sheet. Also disables all HTML/CSS &lt;code&gt;style&lt;/code&gt; attributes that are output by default (to avoid conflicts).</source>
          <target state="translated">指定级联样式表的URL。还禁用默认情况下输出的所有HTML / CSS &lt;code&gt;style&lt;/code&gt; 属性（以避免冲突）。</target>
        </trans-unit>
        <trans-unit id="4aa99f54409387b7146f47653777c920418ff10b" translate="yes" xml:space="preserve">
          <source>Specify the URL of cascading style sheet to link from resulting HTML file. Default is none style sheet.</source>
          <target state="translated">指定从HTML文件中链接的层叠样式表的URL。默认为无样式表。</target>
        </trans-unit>
        <trans-unit id="9afcf7f83edb719a030bfbfd6d7f5c91cf7f8d6b" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods.</source>
          <target state="translated">指定用于查找库荚的基础目录。</target>
        </trans-unit>
        <trans-unit id="44291a4ec495223a1da4f1839ae4e831f5a3c791" translate="yes" xml:space="preserve">
          <source>Specify the base directory for finding library pods. Default is the current working directory.</source>
          <target state="translated">指定用于查找库荚的基础目录。默认为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="5753e538bcef55bd82135ab9b921c4428299f2cd" translate="yes" xml:space="preserve">
          <source>Specify the encoding for implicit byte-string upgrading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5534a64aa32340e65ed43e45968b60d705f9fc" translate="yes" xml:space="preserve">
          <source>Specify the internal type that the constant() mechanism uses for macros. The default is IV (signed integer). Currently all macros found during the header scanning process will be assumed to have this type. Future versions of &lt;code&gt;h2xs&lt;/code&gt; may gain the ability to make educated guesses.</source>
          <target state="translated">指定constant（）机制用于宏的内部类型。默认值为IV（有符号整数）。当前，将假定在标头扫描过程中找到的所有宏都具有此类型。将来的 &lt;code&gt;h2xs&lt;/code&gt; 版本可能会进行有根据的猜测。</target>
        </trans-unit>
        <trans-unit id="a20b2619004bea1e14f0e7f2949d240b1952dd51" translate="yes" xml:space="preserve">
          <source>Specify the number of 100K blocks bzip2 uses during compression.</source>
          <target state="translated">指定bzip2在压缩过程中使用的100K块数。</target>
        </trans-unit>
        <trans-unit id="1d869ecbc9c626d4a96da51d8e392c8fcdb22cdc" translate="yes" xml:space="preserve">
          <source>Specify the pod file to convert. Input is taken from STDIN if no infile is specified.</source>
          <target state="translated">指定要转换的 pod 文件。如果没有指定infile,则从STDIN输入。</target>
        </trans-unit>
        <trans-unit id="2bed91a5a620b4aae10dcfd8cbca6e35a0ef51dd" translate="yes" xml:space="preserve">
          <source>Specify the targets for testing.</source>
          <target state="translated">指定测试的目标。</target>
        </trans-unit>
        <trans-unit id="21bb885000d067ff7c549508e4dd3407f52920a2" translate="yes" xml:space="preserve">
          <source>Specify the title of the resulting HTML file.</source>
          <target state="translated">指定生成的HTML文件的标题。</target>
        </trans-unit>
        <trans-unit id="46f23c724776424563c656a058b3155bcce7e71b" translate="yes" xml:space="preserve">
          <source>Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.</source>
          <target state="translated">在你的Makefile.PL或Build.PL的前置条件中指定其他Perl模块的版本要求。</target>
        </trans-unit>
        <trans-unit id="8bd129aeb5d58a2d4cd81a32d015c916c4dfff29" translate="yes" xml:space="preserve">
          <source>Specify which directory is used for storing cache. Default directory is the current working directory.</source>
          <target state="translated">指定用于存储缓存的目录。默认目录为当前工作目录。</target>
        </trans-unit>
        <trans-unit id="c06413cd34d05ffad8b760e0ccbb2a8039560c0e" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked to in cross references.</source>
          <target state="translated">指定podroot的哪些子目录包含pod文件,其HTML转换后的表单可以链接到交叉引用中。</target>
        </trans-unit>
        <trans-unit id="4ed9289cec9db507a9bd1e2cf8a443192d39f482" translate="yes" xml:space="preserve">
          <source>Specify which subdirectories of the podroot contain pod files whose HTML converted forms can be linked-to in cross-references.</source>
          <target state="translated">指定podroot的哪些子目录包含pod文件,其HTML转换后的表单可以在交叉引用中被链接到。</target>
        </trans-unit>
        <trans-unit id="08ce00bfc35270a0506d4be19cf439c32891aca2" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;flags&lt;/code&gt; can further restrict what is allowed and not warned on, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddb0fa6b996bdc82d7ed351288c14ade48e2fbe" translate="yes" xml:space="preserve">
          <source>Specifying I/O layers in MODE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda870361643b1e3b5ceca1a143c1054b6477609" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl (that is, prior to 5.6.0) that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">一般来说,应该避免将 VERSION 指定为 v5.6.1 这种形式的文字,因为在不支持这种语法的早期 Perl 版本(即 5.6.0 之前的版本)下,它会导致误导性的错误信息。应该使用等价的数字版本。</target>
        </trans-unit>
        <trans-unit id="4cc4c6ab0a0e40b55ad8e487edeab38628dd47f2" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a literal of the form v5.6.1 should generally be avoided, because it leads to misleading error messages under earlier versions of Perl that do not support this syntax. The equivalent numeric version should be used instead.</source>
          <target state="translated">一般来说,应该避免将 VERSION 指定为 v5.6.1 这种形式的文字,因为在不支持这种语法的早期 Perl 版本中,它会导致误导性的错误信息。应该使用等价的数字版本来代替。</target>
        </trans-unit>
        <trans-unit id="b76a85ec03f0c93fc5652cb698781d576e230edd" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a numeric argument of the form 5.024001 should generally be avoided as older less readable syntax compared to v5.24.1. Before perl 5.8.0 (released in 2002), the more verbose numeric form was the only supported syntax, which is why you might see it in older code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aa5c6fcdba9772c2f949fa78c3312ba8e176e5c" translate="yes" xml:space="preserve">
          <source>Specifying VERSION as a numeric argument of the form 5.024001 should generally be avoided as older less readable syntax compared to v5.24.1. Before perl 5.8.0 released in 2002 the more verbose numeric form was the only supported syntax, which is why you might see it in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105a66a84ae1308320a2e6185af2d7c0f4640974" translate="yes" xml:space="preserve">
          <source>Specifying Values</source>
          <target state="translated">指定值</target>
        </trans-unit>
        <trans-unit id="6ddacaf845437713514dee82096d8d2996a0782a" translate="yes" xml:space="preserve">
          <source>Specifying a compatibility version higher than the version of perl you are using to run h2xs will have no effect. If unspecified h2xs will default to compatibility with the version of perl you are using to run h2xs.</source>
          <target state="translated">指定比运行h2xs所使用的perl版本更高的兼容性版本将不会有任何影响,如果没有指定,h2xs将默认与运行h2xs的perl版本兼容。如果没有指定,h2xs将默认为与运行h2xs的perl版本兼容。</target>
        </trans-unit>
        <trans-unit id="b9ac38be3885e820db907e52feea151509c97c14" translate="yes" xml:space="preserve">
          <source>Specifying a negative flag after the caret is an error, as the flag is redundant.</source>
          <target state="translated">在转折号后指定一个负标志是错误的,因为这个标志是多余的。</target>
        </trans-unit>
        <trans-unit id="fcb93594508dd14f6f183606eef58af67f897bab" translate="yes" xml:space="preserve">
          <source>Specifying a negative index position greater than the number of items in the queue adds the list to the head of the queue.</source>
          <target state="translated">指定一个大于队列中项目数的负指数位置,将列表添加到队列的头部。</target>
        </trans-unit>
        <trans-unit id="0428551388a304fda9da2ce393b07c826bf5874b" translate="yes" xml:space="preserve">
          <source>Specifying a rule to allow tests to run in parallel does not make the run in parallel. You still need specify the number of parallel &lt;code&gt;jobs&lt;/code&gt; in your Harness object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae5b52602873edfea60de35a979b3a17659ea0" translate="yes" xml:space="preserve">
          <source>Specifying a rule to allow tests to run in parallel does not make them run in parallel. You still need specify the number of parallel &lt;code&gt;jobs&lt;/code&gt; in your Harness object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e80e764794a3f53d9bd22d3f4959b3c3e8e8c0" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue just adds the list to the end.</source>
          <target state="translated">指定的索引位置大于队列中的项目数,只是将列表添加到最后。</target>
        </trans-unit>
        <trans-unit id="9c224eb1496ab5698ab91d2a22838e04eaf02d0d" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list being returned.</source>
          <target state="translated">如果指定的索引位置大于队列中的项目数，则会导致 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或返回空列表。</target>
        </trans-unit>
        <trans-unit id="16018fb283b08c865834aaa6b2e024c776590ab5" translate="yes" xml:space="preserve">
          <source>Specifying an index position greater than the number of items in the queue results in &lt;code&gt;undef&lt;/code&gt; or an empty list being returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5fcdf16424ed34965445319ec725af2d142641e" translate="yes" xml:space="preserve">
          <source>Specifying mode and filename as a single argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b369061e994be9b95b9b52fd041d04e9eccbbae" translate="yes" xml:space="preserve">
          <source>Specifying sub-versions such as the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;5.14.0&lt;/code&gt; in feature bundles has no effect. Feature bundles are guaranteed to be the same for all sub-versions.</source>
          <target state="translated">指定子版本，如在 &lt;code&gt;0&lt;/code&gt; 在 &lt;code&gt;5.14.0&lt;/code&gt; 中特征束不起作用。保证所有子版本的功能包都相同。</target>
        </trans-unit>
        <trans-unit id="79a6f96c957e7feef1314dc46564cc00f5833bc6" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see</source>
          <target state="translated">指定 &quot;udp &quot;协议会使ping()方法向远程主机的echo端口发送一个udp数据包。如果从远程主机接收到回声数据包,并且接收到的数据包包含的数据与发送的数据包相同,则认为远程主机是可到达的。这个协议不需要任何特殊的权限。需要注意的是,对于udp ping来说,如果主机没有运行适当的echo服务,则会被报告为不可到达。对于类似Unix的系统,请参见</target>
        </trans-unit>
        <trans-unit id="a43e4d18241d23c364eb62d107e205d919850575" translate="yes" xml:space="preserve">
          <source>Specifying the &quot;udp&quot; protocol causes the ping() method to send a udp packet to the remote host's echo port. If the echoed packet is received from the remote host and the received packet contains the same data as the packet that was sent, the remote host is considered reachable. This protocol does not require any special privileges. It should be borne in mind that, for a udp ping, a host will be reported as unreachable if it is not running the appropriate echo service. For Unix-like systems see &lt;a href=&quot;http://man.he.net/man8/inetd&quot;&gt;inetd(8)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2819720e6a0b64709090cd36c99161c9c51d2535" translate="yes" xml:space="preserve">
          <source>Specifying the G_DISCARD flag with</source>
          <target state="translated">在指定G_DISCARD标志的时候,用</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="40e5809be52d66c56af4f3807fbc74465fe77f2b" translate="yes" xml:space="preserve">
          <source>Spherical coordinates,</source>
          <target state="translated">球面坐标:</target>
        </trans-unit>
        <trans-unit id="0bce309883c4786c8f96950f6206dff26186fc2b" translate="yes" xml:space="preserve">
          <source>Split a directory specification into the components.</source>
          <target state="translated">将一个目录规范分割成各个组件。</target>
        </trans-unit>
        <trans-unit id="0e9eed69886886b90fb3afa01fba40f13ff4d0a7" translate="yes" xml:space="preserve">
          <source>Split a package for autoloading</source>
          <target state="translated">分割一个包以便自动加载</target>
        </trans-unit>
        <trans-unit id="5a8f5f6aec0e05c9fd24b5a8ca47f652c1c2ceaf" translate="yes" xml:space="preserve">
          <source>Split loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a230284c2746978c6d208e00f352e0d6fb5d918" translate="yes" xml:space="preserve">
          <source>Split out from Safe module version 1, named opcode tags and other changes added by Tim Bunce.</source>
          <target state="translated">从Safe模块第1版中拆分出来,命名为opcode标签,并由Tim Bunce添加了其他改动。</target>
        </trans-unit>
        <trans-unit id="273ddbe310d23df41c94915a842b407f242c4749" translate="yes" xml:space="preserve">
          <source>Splits a path in to volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。在没有卷的概念的系统中,返回''表示卷。</target>
        </trans-unit>
        <trans-unit id="334895ed21abe595a625b2f1658f99e01bbe8d40" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。</target>
        </trans-unit>
        <trans-unit id="9683042273a4ecd00e523d0bde1551fc4f8c1380" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. Assumes that the last file is a path unless the path ends in '\\', '\\.', '\\..' or $no_file is true. On Win32 this means that $no_file true makes this return ( $volume, $path, '' ).</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。假设最后一个文件是一个路径,除非路径以'\\','\\','\\...'结尾或者$no_file为真。在Win32中,这意味着$no_file为真会返回($volume,$path,'')。</target>
        </trans-unit>
        <trans-unit id="86fed3cc24e2d19645e7064b9a14b47a5f182fe6" translate="yes" xml:space="preserve">
          <source>Splits a path into volume, directory, and filename portions. On systems with no concept of volume, returns '' for volume.</source>
          <target state="translated">将一个路径分割成卷、目录和文件名的部分。在没有volume概念的系统中,返回''表示volume。</target>
        </trans-unit>
        <trans-unit id="5d39c4c6b066b235387ae82c04d47c7856f6398b" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context.</source>
          <target state="translated">将字符串EXPR分割成一个字符串列表,并在列表上下文中返回列表,或者在标量上下文中返回列表的大小。</target>
        </trans-unit>
        <trans-unit id="2936a94e1d47596e4e39d9256be18597c3aa4179" translate="yes" xml:space="preserve">
          <source>Splits the string EXPR into a list of strings and returns the list in list context, or the size of the list in scalar context. (Prior to Perl 5.11, it also overwrote &lt;code&gt;@_&lt;/code&gt; with the list in void and scalar context. If you target old perls, beware.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="250f996321b0ccf8a0a091d8ad8d1f0defcbee6b" translate="yes" xml:space="preserve">
          <source>Splitting up a program text into &lt;b&gt;tokens&lt;/b&gt;. Also known as &amp;ldquo;lexing&amp;rdquo;, in which case you get &amp;ldquo;lexemes&amp;rdquo; instead of tokens.</source>
          <target state="translated">将程序文本拆分为&lt;b&gt;令牌&lt;/b&gt;。也称为&amp;ldquo;词法&amp;rdquo;，在这种情况下，您将获得&amp;ldquo;词法&amp;rdquo;而不是标记。</target>
        </trans-unit>
        <trans-unit id="ff729dbb2771278d79c384030e9caa881a4db264" translate="yes" xml:space="preserve">
          <source>Spool to system printer on close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fc00753787683a6ac1541ee8a68b3aa017c6a5" translate="yes" xml:space="preserve">
          <source>Spurious text after =pod / =cut</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44359690bcaf314432bdd57278be918c222c6a77" translate="yes" xml:space="preserve">
          <source>Square Brackets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="dab8825d9ab14cb0ae9c8c35a6b41109eb0231a8" translate="yes" xml:space="preserve">
          <source>Stabilized</source>
          <target state="translated">Stabilized</target>
        </trans-unit>
        <trans-unit id="699cbcfa1d2de31b511ffab2c2a0ef9730993e7e" translate="yes" xml:space="preserve">
          <source>Stable CPAN modules</source>
          <target state="translated">稳定的CPAN模块</target>
        </trans-unit>
        <trans-unit id="0c37e4671699616f1b661a8adda9cc25f7e7c380" translate="yes" xml:space="preserve">
          <source>Stable modules should maintain backwards compatibility</source>
          <target state="translated">稳定的模块应保持向后兼容性</target>
        </trans-unit>
        <trans-unit id="e59f32f5132f95bd8522cf0423d93b2b074371e3" translate="yes" xml:space="preserve">
          <source>Stack Manipulation Macros</source>
          <target state="translated">堆栈操作宏</target>
        </trans-unit>
        <trans-unit id="d3f19bccf79868f3c579b95c4b4aa5c3173cdfc2" translate="yes" xml:space="preserve">
          <source>Stack Overflow is a free question-and-answer site for programmers. It's not focussed solely on Perl, but it does have an active group of users who do their best to help people with their Perl programming questions.</source>
          <target state="translated">Stack Overflow是一个面向程序员的免费问答网站。它并不只专注于Perl,但它有一个活跃的用户群,他们会尽力帮助人们解决Perl编程问题。</target>
        </trans-unit>
        <trans-unit id="79c0915aad1c8e4662635799d017c78213056099" translate="yes" xml:space="preserve">
          <source>Stack Trace formatting</source>
          <target state="translated">堆栈跟踪格式化</target>
        </trans-unit>
        <trans-unit id="bed6dbd7b4c6ff7ccd34126ec3ad733b680488ca" translate="yes" xml:space="preserve">
          <source>Stack backtrace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbdf4bd83f4cf97cb14bdbe17601c9d4a7b9b2b" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dMARK&quot;&gt;&quot;dMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32c5432806926c51af3a6d722094d1b8498ee67" translate="yes" xml:space="preserve">
          <source>Stack marker variable for the XSUB. See &lt;code&gt;dMARK&lt;/code&gt; .</source>
          <target state="translated">XSUB的堆栈标记变量。参见 &lt;code&gt;dMARK&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abb5c52ccc52723cd1612e07bb13d70407d8e476" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt; .</source>
          <target state="translated">堆栈指针。通常由 &lt;code&gt;xsubpp&lt;/code&gt; 处理。请参阅 &lt;code&gt;dSP&lt;/code&gt; 和 &lt;code&gt;SPAGAIN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f089b00d917131a98e897f79444313cdb238edf" translate="yes" xml:space="preserve">
          <source>Stack pointer. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#dSP&quot;&gt;&quot;dSP&quot;&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;SPAGAIN&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eeeffb91b556017b0569617dac90bb982af82c6" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="translated">堆栈大小讨论：&lt;a href=&quot;http://www.perlmonks.org/?node_id=532956&quot;&gt;http&lt;/a&gt; ://www.perlmonks.org/?node_id= 532956</target>
        </trans-unit>
        <trans-unit id="154b31259cd2c2ec7e9e63fa8a80cdb8ccfd16a7" translate="yes" xml:space="preserve">
          <source>Stack size discussion: &lt;a href=&quot;https://www.perlmonks.org/?node_id=532956&quot;&gt;https://www.perlmonks.org/?node_id=532956&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249f056b552dcec0dec16b7eed3b2513cf1351f3" translate="yes" xml:space="preserve">
          <source>Stacks</source>
          <target state="translated">Stacks</target>
        </trans-unit>
        <trans-unit id="5972ab200f32099d27f68650121e9738cdd0e0dc" translate="yes" xml:space="preserve">
          <source>Standard Exports</source>
          <target state="translated">标准出口</target>
        </trans-unit>
        <trans-unit id="615e5b98a32ea52bb60f7df7a2666749db3e59ab" translate="yes" xml:space="preserve">
          <source>Standard I/O functions via VMS extensions</source>
          <target state="translated">通过VMS扩展的标准I/O功能</target>
        </trans-unit>
        <trans-unit id="eba63c181dd248d4b5bba8f0065bbb50178505fc" translate="yes" xml:space="preserve">
          <source>Standard Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc014247a90e3e9471cd43027f6ed1dd5022323" translate="yes" xml:space="preserve">
          <source>Standard Modules</source>
          <target state="translated">标准模块</target>
        </trans-unit>
        <trans-unit id="c9c684d7aa085e9385f19a731c50f29d333142bb" translate="yes" xml:space="preserve">
          <source>Standard TAP formatter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb1fc559ce28778664dae993a8bd3c9c1e13c04" translate="yes" xml:space="preserve">
          <source>Standard codes for country identification</source>
          <target state="translated">国家识别的标准代码</target>
        </trans-unit>
        <trans-unit id="60f2260734e540712fc0b3a84eed77018b10ca66" translate="yes" xml:space="preserve">
          <source>Standard codes for currency identification</source>
          <target state="translated">货币识别的标准代码</target>
        </trans-unit>
        <trans-unit id="b5deda2e5280ead9cecc60bbf30d177abf9ec4ea" translate="yes" xml:space="preserve">
          <source>Standard codes for language extension identification</source>
          <target state="translated">语文扩展标识的标准代码</target>
        </trans-unit>
        <trans-unit id="f2ee3631bc2f34f1c73413a9d2061ce03c5ab44f" translate="yes" xml:space="preserve">
          <source>Standard codes for language identification</source>
          <target state="translated">语文识别标准代码</target>
        </trans-unit>
        <trans-unit id="10a16afeaf36afe90baa03b4e90894540cc06be0" translate="yes" xml:space="preserve">
          <source>Standard codes for language variation identification</source>
          <target state="translated">语文差异识别的标准代码</target>
        </trans-unit>
        <trans-unit id="b1589d1520251236f9eb362681e4874ce8c5e9ee" translate="yes" xml:space="preserve">
          <source>Standard codes for script identification</source>
          <target state="translated">脚本识别的标准代码</target>
        </trans-unit>
        <trans-unit id="5d6d11511a070bcf17fa4eb2391ebf6e7a493c05" translate="yes" xml:space="preserve">
          <source>Standard modules with VMS-specific differences</source>
          <target state="translated">标准模块与VMS特有的差异</target>
        </trans-unit>
        <trans-unit id="de92c20ac3781f514b3f3e2c2c6d7cf3cd1b6af8" translate="yes" xml:space="preserve">
          <source>Standard, bundled modules are all expected to behave in a well-defined manner with respect to namespace pollution because they use the Exporter module. See their own documentation for details.</source>
          <target state="translated">标准的、捆绑的模块因为使用了Exporter模块,所以在命名空间污染方面的行为都应该有一个明确的规定。详情请看它们自己的文档。</target>
        </trans-unit>
        <trans-unit id="06d642894968e30a189e062bc83886c6edaae47c" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.html</source>
          <target state="translated">StandardizedVariants.html</target>
        </trans-unit>
        <trans-unit id="8e0bc2ae4e7dee6efa427af24dac0f51946576f0" translate="yes" xml:space="preserve">
          <source>StandardizedVariants.txt</source>
          <target state="translated">StandardizedVariants.txt</target>
        </trans-unit>
        <trans-unit id="8f1eb352b92791858ba92c3002eb4f33fe75c02e" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Create if none&quot;. If the requested file does not exist, then it is created and then opened. This is the default if &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested or if &lt;code&gt;&quot;t&quot;&lt;/code&gt; or &lt;code&gt;&quot;n&quot;&lt;/code&gt; was specified. Contrast with &lt;code&gt;&quot;e&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="822e0e0d7c446c8fe35f0a8dc97579be22addccb" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Existing file only&quot;. If the requested file does not exist, then nothing is opened and the &lt;code&gt;createFile&lt;/code&gt; call fails. This is the default unless &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested or &lt;code&gt;&quot;t&quot;&lt;/code&gt; or &lt;code&gt;&quot;n&quot;&lt;/code&gt; was specified. Contrast with &lt;code&gt;&quot;c&quot;&lt;/code&gt;. Can't be used with &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652ad6f84c10dfa8eb50a6eccca9974ed76fa82f" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Keep if exists&quot;. If the requested file exists, then it is opened. This is the default unless &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested but &lt;code&gt;GENERIC_READ&lt;/code&gt; access has not been requested. Contrast with &lt;code&gt;&quot;t&quot;&lt;/code&gt; and &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97906deb67c16b9ab59b8c8cd40f5544710588f" translate="yes" xml:space="preserve">
          <source>Stands for &quot;New file only&quot;. If the requested file exists, then it is not opened and the &lt;code&gt;createFile&lt;/code&gt; call fails. Contrast with &lt;code&gt;&quot;k&quot;&lt;/code&gt; and &lt;code&gt;&quot;t&quot;&lt;/code&gt;. Can't be used with &lt;code&gt;&quot;e&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65a514e0a0fb34443686dd34171dc3a164f90121" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Query access&quot;. This is really a no-op since you always have query access when you open a file. You can specify &lt;code&gt;&quot;q&quot;&lt;/code&gt; to document that you plan to query the file [or device, etc.]. This is especially helpful when you don't want read nor write access since something like &lt;code&gt;&quot;q&quot;&lt;/code&gt; or &lt;code&gt;&quot;q ke&quot;&lt;/code&gt; may be easier to understand than just &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;ke&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca1e430d40009621884ba6704cb12fdbd5a5f0a" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Read access&quot;. Sets the &lt;code&gt;GENERIC_READ&lt;/code&gt; bit(s) in the &lt;code&gt;$uAccess&lt;/code&gt; that is passed to &lt;code&gt;CreateFile&lt;/code&gt;. This is the default access if the &lt;code&gt;$svAccess&lt;/code&gt; parameter is missing [or if it is &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;$rvhvOptions&lt;/code&gt; doesn't specify an &lt;code&gt;&quot;Access&quot;&lt;/code&gt; option].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7a0d1e7c51667204657dcea2b802a67f1a4440" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Truncate if exists&quot;. If the requested file exists, then it is truncated to zero length and then opened. This is the default if &lt;code&gt;GENERIC_WRITE&lt;/code&gt; access has been requested and &lt;code&gt;GENERIC_READ&lt;/code&gt; access has not been requested. Contrast with &lt;code&gt;&quot;k&quot;&lt;/code&gt; and &lt;code&gt;&quot;n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481c6b37648dd19153bdddeac4cc38f4916dae94" translate="yes" xml:space="preserve">
          <source>Stands for &quot;Write access&quot;. Sets the &lt;code&gt;GENERIC_WRITE&lt;/code&gt; bit(s) in the &lt;code&gt;$uAccess&lt;/code&gt; that is passed to &lt;code&gt;CreateFile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07142f93c49bc59a674f3cf54cfc45c16742e4f3" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="translated">代表&amp;ldquo;数据库管理&amp;rdquo;例程，这是一&lt;b&gt;组&lt;/b&gt;使用磁盘文件模拟&lt;b&gt;关联阵列&lt;/b&gt;的例程。这些例程使用动态哈希方案来定位只有两个磁盘访问权限的任何条目。DBM文件允许Perl程序在多个调用之间保持持久性&lt;b&gt;哈希&lt;/b&gt;。您可以 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 哈希变量绑定到各种DBM实现。</target>
        </trans-unit>
        <trans-unit id="1a775e3592f8bbe5e3864eeff5292ad588cc2550" translate="yes" xml:space="preserve">
          <source>Stands for &amp;ldquo;Database Management&amp;rdquo; routines, a set of routines that emulate an &lt;b&gt;associative array&lt;/b&gt; using disk files. The routines use a dynamic hashing scheme to locate any entry with only two disk accesses. DBM files allow a Perl program to keep a persistent &lt;b&gt;hash&lt;/b&gt; across multiple invocations. You can &lt;code&gt;tie&lt;/code&gt; your hash variables to various DBM implementations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912db97dd4f77a0ec4611c2eb6976e694df9c91d" translate="yes" xml:space="preserve">
          <source>Start by familiarizing yourself with &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; and &lt;a href=&quot;TAP::Parser::IteratorFactory&quot;&gt;TAP::Parser::IteratorFactory&lt;/a&gt;. &lt;a href=&quot;TAP::Parser::SourceHandler::RawTAP&quot;&gt;TAP::Parser::SourceHandler::RawTAP&lt;/a&gt; is the easiest sub-class to use as an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1dfbc7a4324027580845858a63c6abfc58480ed" translate="yes" xml:space="preserve">
          <source>Start iPKGui. Install the packages &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;coreutils&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42ab44220e1cd65314352df58f468e908b8005a5" translate="yes" xml:space="preserve">
          <source>Start logging each disk request in a buffer internal to the disk device driver of size &lt;code&gt;$uLogBufferSize&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32e3debe4cf1141c3184e11a9dc572fab1423447" translate="yes" xml:space="preserve">
          <source>Start position and no-match optimisations</source>
          <target state="translated">起始位置和无匹配优化</target>
        </trans-unit>
        <trans-unit id="db76cc0f3f883ec9a2ed91694d94f4588b9f7245" translate="yes" xml:space="preserve">
          <source>Start up an interval timer: after a certain time, a signal ($which) arrives, and more signals may keep arriving at certain intervals. To disable an &quot;itimer&quot;, use &lt;code&gt;$floating_seconds&lt;/code&gt; of zero. If the &lt;code&gt;$interval_floating_seconds&lt;/code&gt; is set to zero (or unspecified), the timer is disabled &lt;b&gt;after&lt;/b&gt; the next delivered signal.</source>
          <target state="translated">启动一个间隔计时器：在一定的时间后，信号（$ which）到达，并且更多的信号可能以一定的间隔不断到达。要禁用&amp;ldquo;初始值&amp;rdquo;，请使用 &lt;code&gt;$floating_seconds&lt;/code&gt; 为零。如果 &lt;code&gt;$interval_floating_seconds&lt;/code&gt; 设置为零（或未指定），则在下一个传递信号&lt;b&gt;后&lt;/b&gt;禁用计时器。</target>
        </trans-unit>
        <trans-unit id="06610ff85775ebe35f7b8f21af74dc2942b66fd2" translate="yes" xml:space="preserve">
          <source>Start using Devel::PPPort for XS projects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc3261b7747ff88ddb552066307bdb160a93102" translate="yes" xml:space="preserve">
          <source>Start with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf54d336f01982c7f36b58a5973054d7f918d05e" translate="yes" xml:space="preserve">
          <source>Start with a dummy run of h2xs:</source>
          <target state="translated">先用h2xs假跑。</target>
        </trans-unit>
        <trans-unit id="8d112be587c3b58ec2b08ad08b5f28537f049d9b" translate="yes" xml:space="preserve">
          <source>Start with single-step on.</source>
          <target state="translated">从单步上开始。</target>
        </trans-unit>
        <trans-unit id="8332767a94ccaf8b2674f5e407c13b8594261e03" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 'a'.</source>
          <target state="translated">从字符串'a'的第一个字母开始。</target>
        </trans-unit>
        <trans-unit id="be46870dc50c93db69a63c772d7b331eea2b204f" translate="yes" xml:space="preserve">
          <source>Start with the first letter in the string 't'.</source>
          <target state="translated">从字符串't'的第一个字母开始。</target>
        </trans-unit>
        <trans-unit id="e5189aa41c41bf90fef351656e01e6473fbaf249" translate="yes" xml:space="preserve">
          <source>Start your Perl program</source>
          <target state="translated">启动你的Perl程序</target>
        </trans-unit>
        <trans-unit id="9f05ee38f1d8c4b639d2c05f6f7cb39a8f63ba62" translate="yes" xml:space="preserve">
          <source>Start-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的起始标记。</target>
        </trans-unit>
        <trans-unit id="bba3dd50f7eb62963e78abd741a6ecb84d7e0e92" translate="yes" xml:space="preserve">
          <source>Starting From Scratch</source>
          <target state="translated">从零开始</target>
        </trans-unit>
        <trans-unit id="d9722acfd050423d2f793d245909513d9f792a51" translate="yes" xml:space="preserve">
          <source>Starting OS/2 (and DOS) programs under Perl</source>
          <target state="translated">在Perl下启动OS/2(和DOS)程序。</target>
        </trans-unit>
        <trans-unit id="6a454cb163d40a3be765256333ed856099e340c6" translate="yes" xml:space="preserve">
          <source>Starting Perl in the VMS debugger may change the program execution profile in a way that such problems are not reproduced.</source>
          <target state="translated">在VMS调试器中启动Perl可能会改变程序的执行配置文件,从而无法重现此类问题。</target>
        </trans-unit>
        <trans-unit id="61b2b3d56b228f00035d9baf98e67307d761a53f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS</source>
          <target state="translated">在AmigaOS下启动Perl程序</target>
        </trans-unit>
        <trans-unit id="0aee4d40c0b8d064ab00858293dabb8236e2cf55" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under AmigaOS 4.1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c712909317e062b2443119b81f61884099ac7f3f" translate="yes" xml:space="preserve">
          <source>Starting Perl programs under OS/2 (and DOS and...)</source>
          <target state="translated">在OS/2(以及DOS和...)下启动Perl程序。</target>
        </trans-unit>
        <trans-unit id="653f89b4c2f41c0d0134c806e923d3709fc205d1" translate="yes" xml:space="preserve">
          <source>Starting from IO::Zlib version 1.02, IO::Zlib can also use an external</source>
          <target state="translated">从IO::Zlib 1.02版本开始,IO::Zlib也可以使用外部的</target>
        </trans-unit>
        <trans-unit id="a508a2e273548a63bb5c0b07719e420fe300b9fd" translate="yes" xml:space="preserve">
          <source>Starting from OS/400 V5R2 the IBM Visual Age compiler is supported on OS/400 PASE, so it is possible to build Perl natively on OS/400. The easier way, however, is to compile in AIX, as just described.</source>
          <target state="translated">从OS/400 V5R2开始,OS/400 PASE支持IBM Visual Age编译器,因此可以在OS/400上原生地构建Perl。然而,更简单的方法是在AIX上编译,就像刚才所说的那样。</target>
        </trans-unit>
        <trans-unit id="5e473385f5209d49f3d6236a23d69b61072e12c5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.10.1 (well, 5.10.0, but it didn't work right), you can say</source>
          <target state="translated">从Perl 5.10.1 (好吧,5.10.0,但它没有工作正确)开始,你可以说</target>
        </trans-unit>
        <trans-unit id="213483245e12096ac5558b413cc608887022de0d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.6 Perl has had some level of multibyte character support. Perl 5.8 or later is recommended. Supported multibyte character repertoires include Unicode, and legacy encodings through the Encode module. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;, &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, and &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;.</source>
          <target state="translated">从Perl 5.6开始，Perl具有一定程度的多字节字符支持。建议使用Perl 5.8或更高版本。支持的多字节字符库包括Unicode和通过&amp;ldquo;编码&amp;rdquo;模块的旧版编码。请参见&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;，&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;和&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3401e5a549f724e4569e770d48d8137b822e30b" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.7.2 (and consequently 5.8.x / 5.10.x / 5.12.x) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">从Perl 5.7.2(以及5.8.x/5.10.x/5.12.x)和AIX 4.3或更新版本开始,Perl在所谓的运行时链接模式中使用AIX本地动态加载接口,而不是在Perl 5.6.1和更早的版本中使用的模拟接口,或者在AIX 4.2和更早的版本中使用。这一改变确实破坏了与早期 Perl 版本的编译模块的向后兼容性。这一改动是为了使Perl更符合其他应用程序的要求,比如Apache/mod_perl,它们使用的是AIX本地接口。这一改动也使得 Perl 扩展中可以使用带有静态构造函数和反构造函数的 C++代码,而使用仿真接口则是不可能的。</target>
        </trans-unit>
        <trans-unit id="25d510ae8cee14025ed8b7521c9e7b4803c6e585" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 Filter::Util::Call (the core part of the Source Filters distribution) is part of the standard Perl distribution. Also included is a friendlier interface called Filter::Simple, by Damian Conway.</source>
          <target state="translated">从Perl 5.8开始,Filter::Util::Call(Source Filters发行版的核心部分)是标准Perl发行版的一部分。同时还包含了一个更友好的接口,叫做Filter::Simple,由Damian Conway编写。</target>
        </trans-unit>
        <trans-unit id="84131be03444ffa9bfcdc4607ace523b2b4abf69" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8 you can use the standard module Encode to translate from EBCDIC to Latin-1 code points. Encode knows about more EBCDIC character sets than Perl can currently be compiled to run on.</source>
          <target state="translated">从Perl 5.8开始,你可以使用标准模块Encode从EBCDIC翻译成Latin-1码点。Encode 知道的 EBCDIC 字符集比 Perl 目前可以编译运行的更多。</target>
        </trans-unit>
        <trans-unit id="b494835e5e76badb9fdcdcf6ee9b4a757213c9dc" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt; , can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="translated">从Perl 5.8开始，源过滤器模块 &lt;code&gt;Switch&lt;/code&gt; 也可以用于获取switch和case。现在不鼓励使用它，因为它与Perl 5.10的本机开关不完全兼容，并且因为它作为源过滤器实现，所以在涉及复杂语法时，它并不总是按预期工作。</target>
        </trans-unit>
        <trans-unit id="d155ec5cb50db186fa8a14b8502428201e840a22" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, a source filter module, &lt;code&gt;Switch&lt;/code&gt;, can also be used to get switch and case. Its use is now discouraged, because it's not fully compatible with the native switch of Perl 5.10, and because, as it's implemented as a source filter, it doesn't always work as intended when complex syntax is involved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6f4302390c39dc69e8bb4ae56d84681737deb52" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8, in C/C++ level Perl knows how to wrap system/library interfaces that have thread-aware versions (e.g. getpwent_r()) into frontend macros (e.g. getpwent()) that correctly handle the multithreaded interaction with the Perl interpreter. This will happen transparently, the only thing you need to do is to instantiate a Perl interpreter.</source>
          <target state="translated">从Perl 5.8开始,在C/C++层面,Perl知道如何将具有线程感知版本的系统/库接口(如getpwent_r())包装成前端宏(如getpwent()),正确处理与Perl解释器的多线程交互。这将透明地发生,你唯一需要做的就是实例化一个 Perl 解释器。</target>
        </trans-unit>
        <trans-unit id="d0ecdc5671ad43a21bb3ba4b49951928dc27fb67" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;Algorithmic Complexity Attacks in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="translated">从Perl 5.8.1开始，不同的Perl运行将具有不同的哈希键顺序。进行此更改以提高安全性，请参阅&lt;a href=&quot;../perlsec#Algorithmic-Complexity-Attacks&quot;&gt;perlsec中的算法复杂性攻击&lt;/a&gt;。这意味着，如果数据包含哈希，则不同的Perl运行将具有不同的Data :: Dumper输出。如果需要从不同的Perl运行获得相同的Data :: Dumper输出，请使用环境变量PERL_HASH_SEED，请参见&lt;a href=&quot;../perlrun#PERL_HASH_SEED&quot;&gt;perlrun中的PERL_HASH_SEED&lt;/a&gt;。使用此方法可以恢复旧的（特定于平台的）排序：更漂亮的解决方案可能是使用Data :: Dumper 的 &lt;code&gt;Sortkeys&lt;/code&gt; 过滤器。</target>
        </trans-unit>
        <trans-unit id="f68deda9f44fedf246c9591657da44f835e61c6d" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.8.1 different runs of Perl will have different ordering of hash keys. The change was done for greater security, see &lt;a href=&quot;perlsec#Algorithmic-Complexity-Attacks&quot;&gt;&quot;Algorithmic Complexity Attacks&quot; in perlsec&lt;/a&gt;. This means that different runs of Perl will have different Data::Dumper outputs if the data contains hashes. If you need to have identical Data::Dumper outputs from different runs of Perl, use the environment variable PERL_HASH_SEED, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;&quot;PERL_HASH_SEED&quot; in perlrun&lt;/a&gt;. Using this restores the old (platform-specific) ordering: an even prettier solution might be to use the &lt;code&gt;Sortkeys&lt;/code&gt; filter of Data::Dumper.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b73ef5c7c43845a94f049a96a2982af7951ff5" translate="yes" xml:space="preserve">
          <source>Starting from Perl 5.9.4 the following extra flags are added:</source>
          <target state="translated">从Perl 5.9.4开始,增加了以下标志。</target>
        </trans-unit>
        <trans-unit id="d0f3b9a37d935e7c453cae03a9fc889658a8b375" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas (the exception being some differences in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;, and that is fixed starting in Perl 5.16.0). To enable this seamless support, you should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; (which is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher). See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. (5.14 also fixes a number of bugs and departures from the Unicode standard.)</source>
          <target state="translated">从Perl v5.6.0开始，Perl具备了本地处理Unicode的能力。但是，Perl v5.8.0是用于认真Unicode工作的第一个推荐版本。维护版本5.6.1修复了最初Unicode实现的许多问题，但是例如正则表达式仍然无法在5.6.1中使用Unicode。 Perl v5.14.0是第一个发行版，其中Unicode支持（几乎）可以无缝集成，而没有一些麻烦（例外是&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;有所不同，并且从Perl 5.16.0开始已修复）。要启用此无缝支持，应 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; （如果 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 或更高版本，则会自动选择该功能）。查看&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;。（5.14还修复了一些错误以及与Unicode标准的不同之处。）</target>
        </trans-unit>
        <trans-unit id="df97b58d295ae07b3c7e368fabefa9c327ce3a5a" translate="yes" xml:space="preserve">
          <source>Starting from Perl v5.6.0, Perl has had the capacity to handle Unicode natively. Perl v5.8.0, however, is the first recommended release for serious Unicode work. The maintenance release 5.6.1 fixed many of the problems of the initial Unicode implementation, but for example regular expressions still do not work with Unicode in 5.6.1. Perl v5.14.0 is the first release where Unicode support is (almost) seamlessly integrable without some gotchas. (There are a few exceptions. Firstly, some differences in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;quotemeta&lt;/a&gt; were fixed starting in Perl 5.16.0. Secondly, some differences in &lt;a href=&quot;perlop#Range-Operators&quot;&gt;the range operator&lt;/a&gt; were fixed starting in Perl 5.26.0. Thirdly, some differences in &lt;a href=&quot;perlfunc#split&quot;&gt;split&lt;/a&gt; were fixed started in Perl 5.28.0.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="416a20fa36c19a41cf13089d9b7e6cda76a07463" translate="yes" xml:space="preserve">
          <source>Starting from perl 5.7.1 perl uses the Solaris malloc, since the perl malloc breaks when dealing with more than 2GB of memory, and the Solaris malloc also seems to be faster.</source>
          <target state="translated">从perl 5.7.1开始,perl使用Solaris malloc,因为perl malloc在处理超过2GB的内存时就会中断,而且Solaris malloc似乎也更快。</target>
        </trans-unit>
        <trans-unit id="e6f60ae2145b9aa31e782db73fe39a61dbb6b373" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt; , the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt; , it determines the most-significant bit of a character.</source>
          <target state="translated">从输入字符串的开头开始，每8个字符的字符将转换为1个字符的输出。对于格式 &lt;code&gt;b&lt;/code&gt; ，8元组的第一个字符确定字符的最低有效位；使用格式 &lt;code&gt;B&lt;/code&gt; ，它将确定字符的最高有效位。</target>
        </trans-unit>
        <trans-unit id="924f79553c56797f30f757475a664dc8c52550ae" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the input string, each 8-tuple of characters is converted to 1 character of output. With format &lt;code&gt;b&lt;/code&gt;, the first character of the 8-tuple determines the least-significant bit of a character; with format &lt;code&gt;B&lt;/code&gt;, it determines the most-significant bit of a character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a530103a351aa6cda54d5b0c4c2b630750302d" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt;, the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt;, it determines the most-significant nybble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca54402551e7931f104cb3acd73bb3d87fc7a43" translate="yes" xml:space="preserve">
          <source>Starting from the beginning of the template to pack(), each pair of characters is converted to 1 character of output. With format &lt;code&gt;h&lt;/code&gt; , the first character of the pair determines the least-significant nybble of the output character; with format &lt;code&gt;H&lt;/code&gt; , it determines the most-significant nybble.</source>
          <target state="translated">从模板的开头到pack（），每对字符都转换为1个字符的输出。使用格式 &lt;code&gt;h&lt;/code&gt; ，该对中的第一个字符确定输出字符的最低有效字符。格式为 &lt;code&gt;H&lt;/code&gt; ，它确定最重要的连夜。</target>
        </trans-unit>
        <trans-unit id="e0719e57793beb804762734f954a0430e8236ad0" translate="yes" xml:space="preserve">
          <source>Starting from the top, this says &lt;code&gt;$b&lt;/code&gt; is an SV. The scalar is an IV, which is capable of holding an integer or reference value. It has the &lt;code&gt;ROK&lt;/code&gt; flag set, meaning it is a reference (rather than an integer or string). Notice that Dump follows the reference and shows us what &lt;code&gt;$b&lt;/code&gt; was referencing. We see the same &lt;code&gt;$a&lt;/code&gt; that we found in the previous example.</source>
          <target state="translated">从顶部开始，这表示 &lt;code&gt;$b&lt;/code&gt; 是SV。标量是一个IV，它可以保存整数或参考值。它设置了 &lt;code&gt;ROK&lt;/code&gt; 标志，这意味着它是一个引用（而不是整数或字符串）。注意，Dump遵循引用并向我们显示 &lt;code&gt;$b&lt;/code&gt; 所引用的内容。我们看到与上一个示例相同的 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0542c0de06c1b01762ccd40a6fe67b90b3556cde" translate="yes" xml:space="preserve">
          <source>Starting from version 5.8, Perl uses a builtin translation layer for text-mode files. This replaces the efficient well-tested EMX layer by some code which should be best characterized as a &quot;quick hack&quot;.</source>
          <target state="translated">从 5.8 版开始,Perl 为文本模式文件使用了一个内置的翻译层。它用一些代码取代了高效的、经过良好测试的EMX层,这些代码最好被称为 &quot;快速黑客&quot;。</target>
        </trans-unit>
        <trans-unit id="889838782f9044eb1988a4e66547d5f47a179ecb" translate="yes" xml:space="preserve">
          <source>Starting in 5.28, changing locales on threaded builds is supported on systems that offer thread-safe locale functions. These include POSIX 2008 systems and Windows starting with Visual Studio 2005, and this module will work properly in such situations. However, on threaded builds on Windows prior to Visual Studio 2015, retrieving the items &lt;code&gt;CRNCYSTR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; can result in a race with a thread that has converted to use the global locale. It is quite uncommon for a thread to have done this. It would be possible to construct a workaround for this; patches welcome: see &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&quot;switch_to_global_locale&quot; in perlapi&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52cca7c60b1d846e7ee0624e6dbe1baa1d2c524" translate="yes" xml:space="preserve">
          <source>Starting in 5.32, the Name, Name Aliases, and Named Sequences properties are allowed to be matched. They are considered to be a single combination property, just as has long been the case for &lt;code&gt;\N{}&lt;/code&gt;. Loose matching doesn't work in exactly the same way for these as it does for the values of other properties. The rules are given in &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;. As a result, Perl doesn't try loose matching for you, like it does in other properties. All letters in names are uppercase, but you can add &lt;code&gt;(?i)&lt;/code&gt; to your subpattern to ignore case. If you're uncertain where a blank is, you can use &lt;code&gt; ?&lt;/code&gt; in your subpattern. No character name contains an underscore, so don't bother trying to match one. The use of hyphens is particularly problematic; refer to the above link. But note that, as of Unicode 13.0, the only script in modern usage which has weirdnesses with these is Tibetan; also the two Korean characters U+116C HANGUL JUNGSEONG OE and U+1180 HANGUL JUNGSEONG O-E. Unicode makes no promises to not add hyphen-problematic names in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac77222ae2e654fdac46266902dcc915cb8e811b" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.12.0, &lt;code&gt;\N&lt;/code&gt; also can have an additional meaning (only) in patterns, namely to match a non-newline character. (This is short for &lt;code&gt;[^\n]&lt;/code&gt;, and like &lt;code&gt;.&lt;/code&gt; but is not affected by the &lt;code&gt;/s&lt;/code&gt; regex modifier.)</source>
          <target state="translated">从Perl 5.12.0开始， &lt;code&gt;\N&lt;/code&gt; 在模式中也可以（仅）具有其他含义，即匹配非换行符。（这是 &lt;code&gt;[^\n]&lt;/code&gt; 缩写，类似于 &lt;code&gt;.&lt;/code&gt; 但不受 &lt;code&gt;/s&lt;/code&gt; regex修饰符的影响。）</target>
        </trans-unit>
        <trans-unit id="2859a2d886c0e9aec6c1de9465ceff2207dfb72a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="translated">从Perl 5.14开始（部分在Perl 5.12中开始），只需在程序开头附近放置一个 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; 。在其词汇范围内，您不应遇到此问题。对于Perl 5.12或更高版本，还可以在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature ':5.12'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 或在命令行上使用 &lt;code&gt;-E&lt;/code&gt; 的情况下自动启用它。</target>
        </trans-unit>
        <trans-unit id="df8245894479d7975ceddeb310b62137ac0e64fe" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14 (and partially in Perl 5.12), just put a &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; near the beginning of your program. Within its lexical scope you shouldn't have this problem. It also is automatically enabled under &lt;code&gt;use feature ':5.12'&lt;/code&gt; or &lt;code&gt;use v5.12&lt;/code&gt; or using &lt;code&gt;-E&lt;/code&gt; on the command line for Perl 5.12 or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b056d808ccaa125ddd8cb5bd3248f668c64c977" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imnsx&lt;/code&gt;. Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt;) may follow the caret, so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b2dad99d1883b55d274e9ecc2470180f982e800" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imnsx&lt;/code&gt;. Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt;) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8902a856b5fd88514da38f6d1ea437cef45dc91" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Any positive flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret, so</source>
          <target state="translated">从Perl 5.14开始，紧接在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 之后的是 &lt;code&gt;&quot;^&quot;&lt;/code&gt; （插入符号或抑扬音符号）。是 &lt;code&gt;d-imsx&lt;/code&gt; 的简写。任何正号（ &lt;code&gt;&quot;d&quot;&lt;/code&gt; 除外）都可以跟在插入符号后面，因此</target>
        </trans-unit>
        <trans-unit id="dd982f589d8e87c6c46ce3117db1a952a4a3a29e" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14, a &lt;code&gt;&quot;^&quot;&lt;/code&gt; (caret or circumflex accent) immediately after the &lt;code&gt;&quot;?&quot;&lt;/code&gt; is a shorthand equivalent to &lt;code&gt;d-imsx&lt;/code&gt; . Flags (except &lt;code&gt;&quot;d&quot;&lt;/code&gt; ) may follow the caret to override it. But a minus sign is not legal with it.</source>
          <target state="translated">从Perl 5.14开始，紧接在 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 之后的是 &lt;code&gt;&quot;^&quot;&lt;/code&gt; （插入符号或抑扬音符号）。是 &lt;code&gt;d-imsx&lt;/code&gt; 的简写。标记（除 &lt;code&gt;&quot;d&quot;&lt;/code&gt; ）可以跟在插入号后面以覆盖它。但是减号不合法。</target>
        </trans-unit>
        <trans-unit id="f8764da9a2d4e197710fd50d36bbe6c6ef6a3ac9" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.14.0, regular expressions compiled within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; use Unicode rules even when executed or compiled into larger regular expressions outside the scope.</source>
          <target state="translated">在Perl 5.14.0开始，范围内编译的正则表达式 &lt;code&gt;unicode_strings&lt;/code&gt; 执行或编译成的范围较大的正则表达式时，即使使用Unicode规则。</target>
        </trans-unit>
        <trans-unit id="69cd047e088fdbefa20b4fff4c70feeb8034d880" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt; , as described in &lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="translated">在Perl 5.16.0开始，一致引用规则的范围内使用 &lt;code&gt;unicode_strings&lt;/code&gt; ，如描述&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;。在此之前或在其范围之外，UTF-8编码的字符串中没有引用高于127的代码点，但是在字节编码的字符串中，始终引用在128-255之间的代码点。</target>
        </trans-unit>
        <trans-unit id="18d82ac8aba251c121572f60699a2bf12308e978" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.16.0, consistent quoting rules are used within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;, as described in &lt;a href=&quot;perlfunc#quotemeta&quot;&gt;&quot;quotemeta&quot; in perlfunc&lt;/a&gt;. Prior to that, or outside its scope, no code points above 127 are quoted in UTF-8 encoded strings, but in byte encoded strings, code points between 128-255 are always quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399f06c020d8cd6de2c45e4ca951de47d9647e70" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.18, there are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. Here's a complete list of the current ones affecting ASCII characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8e157579b8bab3ccd61e698c935bfec29a8f08" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.20, a hash slice operation with the % symbol is a variant of slice operation returning a list of key/value pairs rather than just values:</source>
          <target state="translated">从Perl 5.20开始,带有%符号的哈希分片操作是分片操作的一种变体,它返回的是键/值对的列表,而不仅仅是值。</target>
        </trans-unit>
        <trans-unit id="39e60469d5cdf9ceb960a075ac6c5b92f2cc1e99" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.26.0, the range operator on strings treats their lengths consistently within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;. Prior to that, or outside its scope, it could produce strings whose length in characters exceeded that of the right-hand side, where the right-hand side took up more bytes than the correct range endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c411e4acf4de658ce7555b24fb1288a04a3bbeb3" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is a fatal error to try to complement a string containing a character with an ordinal value above 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa44c6c3c091efdcacc965773935ea7f947644" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is illegal for bit operators, like &lt;code&gt;~&lt;/code&gt;, to operate on strings containing code points above 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05b2f43207fbc6b0a71ca28ad690738fd985132" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, it is now easy to detect strings that aren't script runs. Simply enclose just about any pattern like either of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e29afd35da622d839a7f0cbd5ae88b8a5f51e23" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, on multi-threaded perls compiled on systems that implement POSIX 2008 thread-safe locale operations, this function doesn't actually call the system &lt;code&gt;setlocale&lt;/code&gt;. Instead those thread-safe operations are used to emulate the &lt;code&gt;setlocale&lt;/code&gt; function, but in a thread-safe manner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebaa36867a4be778f15993a9a2db66338883da5" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, this module is available even on systems that lack a native &lt;code&gt;nl_langinfo&lt;/code&gt;. On such systems, it uses various methods to construct what that function, if present, would return. But there are potential glitches. These are the items that could be different:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31e1eb3f09fae3aaaa4cf7976dd6db42da82227a" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28, this pragma may be used in &lt;a href=&quot;threads&quot;&gt;multi-threaded&lt;/a&gt; applications on systems that have thread-safe locale ability. Some caveats apply, see &lt;a href=&quot;#Multi-threaded&quot;&gt;&quot;Multi-threaded&quot;&lt;/a&gt; below. On systems without this capability, or in earlier Perls, do NOT use this pragma in scripts that have multiple &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; active. The locale in these cases is not local to a single thread. Another thread may change the locale at any time, which could cause at a minimum that a given thread is operating in a locale it isn't expecting to be in. On some platforms, segfaults can also occur. The locale change need not be explicit; some operations cause perl to change the locale itself. You are vulnerable simply by having done a &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af6703d45f3b80a1d7fa23b6e6ecb6c4049fc60" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.28.0, the &lt;code&gt;split&lt;/code&gt; function with a pattern specified as a string containing a single space handles whitespace characters consistently within the scope of &lt;code&gt;unicode_strings&lt;/code&gt;. Prior to that, or outside its scope, characters that are whitespace according to Unicode rules but not according to ASCII rules were treated as field contents rather than field separators when they appear in byte-encoded strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a7e78b35743da5e79f86d77337042b624f1dcf2" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.30, it is possible to do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67c1f2502a54e1fd7e5f8ea0c68c3e31e84a505f" translate="yes" xml:space="preserve">
          <source>Starting in Perl 5.32, you can specify a character by its name in regular expression patterns using &lt;code&gt;\p{name=...}&lt;/code&gt;. This is in addition to the longstanding method of using &lt;code&gt;\N{...}&lt;/code&gt;. The following summarizes the differences between these two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="013197011e87f7e0633670e8b800c1024b759400" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16 in a very limited way, and more generally in v5.22, you can restrict which category or categories are enabled by this particular instance of the pragma by adding parameters to it. For example,</source>
          <target state="translated">从 Perl v5.16 开始,以一种非常有限的方式,在 v5.22 中,你可以通过添加参数来限制这个 pragma 的特定实例启用哪些类别。例如,你可以通过添加参数来限制这个 pragma 的特定实例启用哪些类别。</target>
        </trans-unit>
        <trans-unit id="d7be757a62548668bef82e6fa7932eb10efddb3b" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, Perl adopted a Unicode-defined strategy for quoting non-ASCII characters; the quoting of ASCII characters is unchanged.</source>
          <target state="translated">从Perl v5.16开始,Perl采用了Unicode定义的策略来引用非ASCII字符,而引用ASCII字符的策略没有改变。</target>
        </trans-unit>
        <trans-unit id="a75aca801899de40f1e5f4fc3d561cb6af7bcdc4" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use
charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="translated">从Perl v5.16开始，如果双引号字符串中的 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 序列出现任何情况，则该模块将自动使用参数 &lt;code&gt;:full&lt;/code&gt; 和 &lt;code&gt;:short&lt;/code&gt; （如下所述）加载该模块（如果尚未使用不同的参数加载该模块），为了将命名的Unicode字符编译到字符串中的位置。在v5.16之前，需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames&lt;/code&gt; 来启用此用法。 （但是，在v5.16之前，格式 &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; 未启用 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="2febf15cd94e7fcad788accee9fc2d94365a32bb" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.16, any occurrence of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; sequences in a double-quotish string automatically loads this module with arguments &lt;code&gt;:full&lt;/code&gt; and &lt;code&gt;:short&lt;/code&gt; (described below) if it hasn't already been loaded with different arguments, in order to compile the named Unicode character into position in the string. Prior to v5.16, an explicit &lt;code&gt;use charnames&lt;/code&gt; was required to enable this usage. (However, prior to v5.16, the form &lt;code&gt;&quot;use charnames ();&quot;&lt;/code&gt; did not enable &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608b1e70a82457592a3e840a3bb2cb2b40f918ad" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except &lt;code&gt;LC_COLLATE&lt;/code&gt; is only partially supported; collation support is improved in Perl v5.26 to a level that may be sufficient for your needs (see &lt;a href=&quot;#Category-LC_COLLATE%3A-Collation%3A-Text-Comparisons-and-Sorting&quot;&gt;&quot;Category &lt;code&gt;LC_COLLATE&lt;/code&gt;: Collation: Text Comparisons and Sorting&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc88b853a6a300ebebd43ce48839b53ca6b33945" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.20, UTF-8 locales are supported in Perl, except for &lt;code&gt;LC_COLLATE&lt;/code&gt; (use &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; instead). If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">从Perl v5.20开始，Perl支持UTF-8语言环境，除了 &lt;code&gt;LC_COLLATE&lt;/code&gt; （改用&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;）。如果您拥有Perl v5.16或v5.18并且无法升级，则可以使用</target>
        </trans-unit>
        <trans-unit id="24c20bca7982b6c0163573088c845daca9bc60e3" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt; , &lt;code&gt;\N{U+21}&lt;/code&gt; , ..., &lt;code&gt;\N{U+7F}&lt;/code&gt; . This range is all the printable characters that the ASCII character set contains.</source>
          <target state="translated">从Perl v5.22开始，这适用于方括号字符类中的范围。例如，如果说 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/a&gt;&lt;/code&gt; ，则表示字符 &lt;code&gt;\N{U+20}&lt;/code&gt; ， &lt;code&gt;\N{U+21}&lt;/code&gt; ，.. 。， &lt;code&gt;\N{U+7F}&lt;/code&gt; 。此范围是ASCII字符集包含的所有可打印字符。</target>
        </trans-unit>
        <trans-unit id="b54e661a1090defa2b2777581232122fccb99a2a" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this applies to ranges in bracketed character classes. If you say, for example, &lt;code&gt;qr/[\N{U+20}-\N{U+7F}]/&lt;/code&gt;, it means the characters &lt;code&gt;\N{U+20}&lt;/code&gt;, &lt;code&gt;\N{U+21}&lt;/code&gt;, ..., &lt;code&gt;\N{U+7F}&lt;/code&gt;. This range is all the printable characters that the ASCII character set contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23b660058cb3ee939b11052749bad9b7526e31f" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.22, this is trivially changeable to work portably on both ASCII and EBCDIC platforms.</source>
          <target state="translated">从Perl v5.22开始,这一点可以简单地改变,以便在ASCII和EBCDIC平台上可移植地工作。</target>
        </trans-unit>
        <trans-unit id="78b643b4bf49444d908712fc4608ad821a201d28" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.26, if the modifier has a second &lt;code&gt;&quot;x&quot;&lt;/code&gt; within it, it does everything that a single &lt;code&gt;/x&lt;/code&gt; does, but additionally non-backslashed SPACE and TAB characters within bracketed character classes are also generally ignored, and hence can be added to make the classes more readable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d25eddbb4ffae5919e515185604e4ce1f21281" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.26, specifying &lt;code&gt;/xx&lt;/code&gt; changes the square-bracketed portions of a pattern to ignore tabs and space characters unless they are escaped by preceding them with a backslash. So, we could write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f981605ccbb39cb3202cced83d909060decc021" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.30, Perl detects Turkic locales by their behaviour, and seamlessly handles both types; previously only the non-Turkic one was supported. The name of the locale is ignored, if your system has a &lt;code&gt;tr_TR.UTF-8&lt;/code&gt; locale and it doesn't behave like a Turkic locale, perl will treat it like a non-Turkic locale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad33022de79501f8101617222266c778da37687" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.32, an alternative to &lt;code&gt;\N{...}&lt;/code&gt; for full names is available, and that is to say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e38118c6920f78946e8d31e17cb36ad4ee8bf0e" translate="yes" xml:space="preserve">
          <source>Starting in Perl v5.8.6 (&lt;code&gt;Encode&lt;/code&gt; version 2.0.1),</source>
          <target state="translated">从Perl v5.8.6（ &lt;code&gt;Encode&lt;/code&gt; 版本2.0.1）开始，</target>
        </trans-unit>
        <trans-unit id="474e1944b6ecbc8a507bc2e01a2a550b04aa62eb" translate="yes" xml:space="preserve">
          <source>Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and names that were formerly Perl extensions, and some additional ones that Perl did not previously accept. The list is getting too long to reproduce here, but you can get the complete list from the Unicode web site: &lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&lt;/a&gt;.</source>
          <target state="translated">从Unicode 6.1和Perl v5.16开始，Unicode定义了许多以前是Perl扩展名的缩写和名称，以及一些Perl以前不接受的其他缩写和名称。该列表太长了，无法在此处复制，但是您可以从Unicode网站获得完整列表：&lt;a href=&quot;http://www.unicode.org/Public/UNIDATA/NameAliases.txt&quot;&gt;http&lt;/a&gt; : //www.unicode.org/Public/UNIDATA/NameAliases.txt。</target>
        </trans-unit>
        <trans-unit id="d7ed0dc1ff9e9044e5149578e2503104831b9063" translate="yes" xml:space="preserve">
          <source>Starting in perl v5.30, wildcards are allowed in Unicode property values. See &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b155d3280c20b781dad3393cccf04005ee9e4a0f" translate="yes" xml:space="preserve">
          <source>Starting in the 5.9.x development version of perl you can &lt;code&gt;use re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="818df47ef2f0fcf2a87de97f12babb967ed1fcfb" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt; , but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. (If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into.) The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;).</source>
          <target state="translated">从v5.20开始，Perl支持 &lt;code&gt;LC_CTYPE&lt;/code&gt; 的 UTF-8语言环境，否则Perl仅支持单字节语言环境，例如ISO 8859系列。这意味着没有很好的字符支持区域设置，例如亚洲语言。 （如果从Perl v5.22开始，如果平台具有Perl能够检测到这样的语言环境的&lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;功能&lt;/a&gt;，则每当切换到这样的语言环境时，Perl就会使用 &lt;code&gt;locale&lt;/code&gt; 警告类别来警告默认启用）。实际上是POSIX语言环境的超集，因为它实际上是完整的Unicode行为，好像根本没有 &lt;code&gt;LC_CTYPE&lt;/code&gt; 语言环境有效（除污点；请参阅&lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;）。 POSIX语言环境，甚至是UTF-8语言环境，在Unicode中都缺少某些概念，例如更改字符大小写可以扩展为多个字符的想法。在UTF-8语言环境中的Perl将为您提供扩展。在v5.20之前，Perl在某些平台上（例如ISO 8859-1）在某些平台上对UTF-8语言环境进行了处理，而在其他平台上则更像&amp;ldquo; C&amp;rdquo;语言环境。对于v5.16和v5.18版本，可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters&lt;/code&gt; 来解决此问题（请参见&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode和UTF-8&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="abf931cf0a232d610a20a5327eae490434a5d7a8" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl supports UTF-8 locales for &lt;code&gt;LC_CTYPE&lt;/code&gt;, but otherwise Perl only supports single-byte locales, such as the ISO 8859 series. This means that wide character locales, for example for Asian languages, are not well-supported. Use of these locales may cause core dumps. If the platform has the capability for Perl to detect such a locale, starting in Perl v5.22, &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;Perl will warn, default enabled&lt;/a&gt;, using the &lt;code&gt;locale&lt;/code&gt; warning category, whenever such a locale is switched into. The UTF-8 locale support is actually a superset of POSIX locales, because it is really full Unicode behavior as if no &lt;code&gt;LC_CTYPE&lt;/code&gt; locale were in effect at all (except for tainting; see &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;). POSIX locales, even UTF-8 ones, are lacking certain concepts in Unicode, such as the idea that changing the case of a character could expand to be more than one character. Perl in a UTF-8 locale, will give you that expansion. Prior to v5.20, Perl treated a UTF-8 locale on some platforms like an ISO 8859-1 one, with some restrictions, and on other platforms more like the &quot;C&quot; locale. For releases v5.16 and v5.18, &lt;code&gt;use locale 'not_characters&lt;/code&gt; could be used as a workaround for this (see &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0b3fbd50ff716e496a38d1dbfc0634c6a5772b" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">从v5.20开始，如果语言环境为UTF-8，Perl将使用完整的Unicode规则。否则，此方案存在缺陷，那就是跨越255/256边界的情况更改未明确定义。例如，在Unicode规则中，小写拉丁字母大写SHARP S（U + 1E9E）为U + 00DF（在ASCII平台上）。但在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （在v5.20之前，而不是UTF-8语言环境之前），U + 1E9E本身是小写字母，因为0xDF可能不是当前语言环境中的LATIN SMALL LETTER SHARP S，并且Perl无法知道该字符甚至存在于语言环境中，更不用说代码点了。 Perl返回大于255的结果（对于所有实例（并且不多），否则将超过255/256边界的输入字符几乎总是不变）；并且从v5.22开始，它会发出&lt;a href=&quot;perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;区域设置&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="cf1eee1ccf148c85a77132cb28b023038cea490f" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged, for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="translated">从v5.20开始，如果语言环境为UTF-8，Perl将使用完整的Unicode规则。否则，此方案存在缺陷，那就是跨越255/256边界的情况更改未明确定义。例如，在Unicode规则中，小写拉丁字母大写SHARP S（U + 1E9E）为U + 00DF（在ASCII平台上）。但在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （在v5.20之前，而不是UTF-8语言环境之前），U + 1E9E本身是小写字母，因为0xDF可能不是当前语言环境中的LATIN SMALL LETTER SHARP S，并且Perl无法知道该字符甚至存在于语言环境中，更不用说代码点了。 Perl返回大于255的结果（对于所有实例（并且不多），否则将超过255/256边界的输入字符几乎总是不变）；并且从v5.22开始，它会发出&lt;a href=&quot;../perldiag#Can't-do-%25s(%22%25s%22)-on-non-UTF-8-locale%3b-resolved-to-%22%25s%22.&quot;&gt;区域设置&lt;/a&gt;警告。</target>
        </trans-unit>
        <trans-unit id="fc33dddc57e009befe8b624c019e0d98b1679536" translate="yes" xml:space="preserve">
          <source>Starting in v5.20, Perl uses full Unicode rules if the locale is UTF-8. Otherwise, there is a deficiency in this scheme, which is that case changes that cross the 255/256 boundary are not well-defined. For example, the lower case of LATIN CAPITAL LETTER SHARP S (U+1E9E) in Unicode rules is U+00DF (on ASCII platforms). But under &lt;code&gt;use locale&lt;/code&gt; (prior to v5.20 or not a UTF-8 locale), the lower case of U+1E9E is itself, because 0xDF may not be LATIN SMALL LETTER SHARP S in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is. Perl returns a result that is above 255 (almost always the input character unchanged), for all instances (and there aren't many) where the 255/256 boundary would otherwise be crossed; and starting in v5.22, it raises a &lt;a href=&quot;perldiag#Can%27t-do-%25s%28%22%25s%22%29-on-non-UTF-8-locale%3B-resolved-to-%22%25s%22.&quot;&gt;locale&lt;/a&gt; warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c762f587a88d06d3ee0d5c6c5c66f9e2aa3c2b6" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt; , but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt; , and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="translated">从v5.22开始，默认情况下，Perl将在切换到将任何ASCII可打印字符（加上 &lt;code&gt;\t&lt;/code&gt; 和 &lt;code&gt;\n&lt;/code&gt; ）重新定义为与预期不同的类的语言环境时发出警告。仅在EBCDIC平台上，这可能会在现代语言环境中发生，例如，在CCSID 1047机器上的CCSID 0037语言环境移动了 &lt;code&gt;&quot;[&quot;&lt;/code&gt; ，但是在具有ISO 646和其他7位语言环境的ASCII平台上，可能会发生这种情况。本质上已经过时了。根据程序使用Perl的功能，事情仍然可能起作用。例如，在上面的示例中， &lt;code&gt;&quot;|&quot;&lt;/code&gt; 成为 &lt;code&gt;\w&lt;/code&gt; ，并且在此没有正则表达式，该程序可能仍能正常运行。该警告列出了它可以确定可能会受到不利影响的所有字符。</target>
        </trans-unit>
        <trans-unit id="045ba6195cde654f0e61c6b886bb35824c0a5a9a" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, Perl will by default warn when switching into a locale that redefines any ASCII printable character (plus &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;) into a different class than expected. This is likely to happen on modern locales only on EBCDIC platforms, where, for example, a CCSID 0037 locale on a CCSID 1047 machine moves &lt;code&gt;&quot;[&quot;&lt;/code&gt;, but it can happen on ASCII platforms with the ISO 646 and other 7-bit locales that are essentially obsolete. Things may still work, depending on what features of Perl are used by the program. For example, in the example from above where &lt;code&gt;&quot;|&quot;&lt;/code&gt; becomes a &lt;code&gt;\w&lt;/code&gt;, and there are no regular expressions where this matters, the program may still work properly. The warning lists all the characters that it can determine could be adversely affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ce7d231c27d2be8f1b1d8928ca5c39bf4aed51" translate="yes" xml:space="preserve">
          <source>Starting in v5.22, you can use Unicode code points as the end points of regular expression pattern character ranges, and the range will include all Unicode code points that lie between those end points, inclusive.</source>
          <target state="translated">从v5.22开始,您可以使用Unicode码点作为正则表达式模式字符范围的端点,该范围将包括位于这些端点之间的所有Unicode码点,包括。</target>
        </trans-unit>
        <trans-unit id="6a0d77e9e3a9155e3031928b6e984c64d451ee78" translate="yes" xml:space="preserve">
          <source>Starting in v5.32, you can also use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd5e5803935bbb6537a6c17faa83c7fdd9ffba0" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt; . This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; use that encoding.</source>
          <target state="translated">从v5.8.6开始，编码名称可以是 &lt;code&gt;:locale&lt;/code&gt; 。这意味着编码是从当前语言环境获取的，而不是由编译指示进行硬编码的。由于脚本实际上只能以一种编码进行编码，因此此选项很危险。仅当脚本本身是用ASCII编写的并且执行脚本时将使用的所有可能的语言环境都是ASCII的超集时，这才有意义。这意味着脚本本身不会更改，但是I / O句柄已添加了指定的编码，并且诸如 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 之类的操作都使用该编码。</target>
        </trans-unit>
        <trans-unit id="8cbc9aa4d02eb518e769236727e93c4edd075393" translate="yes" xml:space="preserve">
          <source>Starting in v5.8.6, the encoding name may be &lt;code&gt;:locale&lt;/code&gt;. This means that the encoding is taken from the current locale, and not hard-coded by the pragma. Since a script really can only be encoded in exactly one encoding, this option is dangerous. It makes sense only if the script itself is written in ASCII, and all the possible locales that will be in use when the script is executed are supersets of ASCII. That means that the script itself doesn't get changed, but the I/O handles have the specified encoding added, and the operations like &lt;code&gt;chr&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; use that encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8eb72d81f87d6a7a0f9e91198c8aa2adc48dbed" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt; . When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="translated">在5.21.2版本开始，与实验内置皮尔斯定义 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 添加一个额外的布尔标志为每个运算， &lt;code&gt;op_moresib&lt;/code&gt; 。如果未设置，则表示这是 &lt;code&gt;OpSIBLING&lt;/code&gt; 链中的最后一个op 。这将释放最后一个同级上的 &lt;code&gt;op_sibling&lt;/code&gt; 字段，使其指向父级op。在此构建中，该字段也重命名为 &lt;code&gt;op_sibparent&lt;/code&gt; 以反映其共同作用。宏 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 包装了此特殊行为，并在最后一个同级上始终返回NULL。通过这种构建，可以使用 &lt;code&gt;op_parent(o)&lt;/code&gt; 函数查找任何op的父级。因此，为了向前兼容，您应始终使用 &lt;code&gt;OpSIBLING(o)&lt;/code&gt; 宏，而不是直接访问 &lt;code&gt;op_sibling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fee6bf661a5a6cbe9e9f6e7dc3357f58ab23b1f3" translate="yes" xml:space="preserve">
          <source>Starting in version 5.21.2, perls built with the experimental define &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; add an extra boolean flag for each op, &lt;code&gt;op_moresib&lt;/code&gt;. When not set, this indicates that this is the last op in an &lt;code&gt;OpSIBLING&lt;/code&gt; chain. This frees up the &lt;code&gt;op_sibling&lt;/code&gt; field on the last sibling to point back to the parent op. Under this build, that field is also renamed &lt;code&gt;op_sibparent&lt;/code&gt; to reflect its joint role. The macro &lt;code&gt;OpSIBLING(o)&lt;/code&gt; wraps this special behaviour, and always returns NULL on the last sibling. With this build the &lt;code&gt;op_parent(o)&lt;/code&gt; function can be used to find the parent of any op. Thus for forward compatibility, you should always use the &lt;code&gt;OpSIBLING(o)&lt;/code&gt; macro rather than accessing &lt;code&gt;op_sibling&lt;/code&gt; directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6641cb9032ef109574e28893d667801fcaa3e2c6" translate="yes" xml:space="preserve">
          <source>Starting with 2.10, the special module name &lt;code&gt;Unicode&lt;/code&gt; refers to the version of the Unicode Character Database bundled with Perl.</source>
          <target state="translated">从2.10开始，特殊模块名称 &lt;code&gt;Unicode&lt;/code&gt; 是指与Perl捆绑在一起的Unicode字符数据库的版本。</target>
        </trans-unit>
        <trans-unit id="aca846c8be32988d259af2e704c9972784ca9b87" translate="yes" xml:space="preserve">
          <source>Starting with AutoLoader 5.73, you can call the &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; function with the fully-qualified name of the function to load from its</source>
          <target state="translated">从AutoLoader 5.73开始，您可以使用函数的标准名称来调用 &lt;code&gt;AutoLoader::autoload_sub&lt;/code&gt; 函数，以从该函数的名称进行加载</target>
        </trans-unit>
        <trans-unit id="fe6dc30d7e458c682ee2ffab73f38deab13b705d" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; . Two steps to getting that module's typemaps available in your code:</source>
          <target state="translated">从ExtUtils :: ParseXS版本3.13_01（perl 5.16和更高版本附带）开始，在多个CPAN发行版之间共享类型映射代码非常容易。通常的想法是将其共享为提供特定API的模块，并让相关模块将其声明为内置时间要求，并将类型映射导入XS。CPAN上 &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt; 共享模块的示例是ExtUtils :: Typemaps :: Basic。在代码中获得该模块的类型图的两个步骤：</target>
        </trans-unit>
        <trans-unit id="c7a9329439741d22826499b7e8ccc62b257e0036" translate="yes" xml:space="preserve">
          <source>Starting with ExtUtils::ParseXS version 3.13_01 (comes with perl 5.16 and better), it is rather easy to share typemap code between multiple CPAN distributions. The general idea is to share it as a module that offers a certain API and have the dependent modules declare that as a built-time requirement and import the typemap into the XS. An example of such a typemap-sharing module on CPAN is &lt;code&gt;ExtUtils::Typemaps::Basic&lt;/code&gt;. Two steps to getting that module's typemaps available in your code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f964cabb5662a6c495bdc0c921d6b311abc6ad4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9212af4220a7c7e6998749dd4723a25f0d7eab4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10, &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; are part of the standard distribution, so you might think that you could do something like this:</source>
          <target state="translated">从Perl 5.10开始，&lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt;和&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;是标准发行版的一部分，因此您可能会认为可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="97eea9254558fb3fd8f17c44c41b369b3648d850" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; , and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="translated">从Perl 5.10.0开始，整数和浮点格式，以及 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 格式以及 &lt;code&gt;()&lt;/code&gt; 组，都可能跟在 &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&lt;/code&gt; endianness修饰符之后，分别强制使用大端或小端字节顺序。鉴于 &lt;code&gt;n&lt;/code&gt; ， &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 如何不覆盖有符号整数，64位整数或浮点值，这些修饰符特别有用。</target>
        </trans-unit>
        <trans-unit id="91887288c16197195e2b34bfb5cb24e865412909" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.10.0, integer and floating-point formats, along with the &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats and &lt;code&gt;()&lt;/code&gt; groups, may all be followed by the &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; endianness modifiers to respectively enforce big- or little-endian byte-order. These modifiers are especially useful given how &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt; don't cover signed integers, 64-bit integers, or floating-point values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee36782903bc57420ba5e155b45524572f22583" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt; :</source>
          <target state="translated">从Perl 5.12开始， &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 可以处理2038年1月19日03:14:08之后的日期，此时基于32位的时间将溢出。您仍然可能在32位 &lt;code&gt;perl&lt;/code&gt; 上收到警告：</target>
        </trans-unit>
        <trans-unit id="06064bcbd3db9848f0c8a7c119116ec7dded2dac" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; can handle dates past 03:14:08 January 19, 2038, when a 32-bit based time would overflow. You still might get a warning on a 32-bit &lt;code&gt;perl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3547c4def41d12fec193f972e11bcb976215d4c4" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从Perl 5.12开始，将传递一个附加的整数参数。如果不带参数调用 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ，它将为零；否则为0 。如果给 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 一个文件句柄作为参数，例如 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(FH)&lt;/a&gt;&lt;/code&gt; ，则为 &lt;code&gt;1&lt;/code&gt; ；和 &lt;code&gt;2&lt;/code&gt; 在非常特殊的情况下，该捆绑的文件句柄是 &lt;code&gt;ARGV&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 被称为带有空参数列表，如 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="052780286d8ffb3a2e7d500cfc57d223e2ef8ffc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.12, an additional integer parameter will be passed. It will be zero if &lt;code&gt;eof&lt;/code&gt; is called without parameter; &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;eof&lt;/code&gt; is given a filehandle as a parameter, e.g. &lt;code&gt;eof(FH)&lt;/code&gt;; and &lt;code&gt;2&lt;/code&gt; in the very special case that the tied filehandle is &lt;code&gt;ARGV&lt;/code&gt; and &lt;code&gt;eof&lt;/code&gt; is called with an empty parameter list, e.g. &lt;code&gt;eof()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3385173ff54b55e840ed45e4ab6e0da31d97fba8" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="translated">从Perl 5.14开始，父级将不会自动为已被 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('TERM', ...)&lt;/code&gt; 发出信号的任何子级使用wait（）以避免死锁，以防子级在I / O上阻塞并且从不接收信号。</target>
        </trans-unit>
        <trans-unit id="2f071da8b4fbf9d03d4174f4254c8ac70323e8cb" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14 a parent will not wait() automatically for any child that has been signalled with &lt;code&gt;kill('TERM', ...)&lt;/code&gt; to avoid a deadlock in case the child is blocking on I/O and never receives the signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90de3712cf0c49e19f3e9d37735c0e97d4b521ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 方面都被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="818e24d28a7aaf2cbc1a6702710734a070d06698" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 方面都被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="72fa5cd516760576150d0418affb48e1abda4a5b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="e2b92aff600824b9c22651f1e75f3d65c35db8ae" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="07bb8994fa6804d1b79f779661eabab22fa4d596" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="10642e156a8402673021a377c62441722a9d8a63" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="5169411fd5bf69d929b67dfac03c2c64e43db230" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="7439a015aa95224d62eb3bbca9a133f540e69f0f" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。保持 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="23e76a783b752b5dc19b6f3c4b3d934de488d5e6" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="47398b3574f050221d9d55302c39ea94e67781b9" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must contain a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="fac0b7eb35a23345be196afebeca8562c183fce3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="427fc5d0e35cec380d803ece997f22ba459e7c3c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="a0a12ea19c52c77b676bcf9fb786b8629096b3dc" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="a3217cf42c0331e4a0cfa6eb7dd493042a8c7e44" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; can take scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对无祝福数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="d0f153998e2fa782a330b974d3d6a495fc8735ee" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未祝福数组的引用。该参数将自动取消引用。保持 &lt;code&gt;&lt;a href=&quot;unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="e3eb26fa45077fda36157e3c2cd25a74327fbf5e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; can take a scalar EXPR, which must hold a reference to an unblessed hash or array. The argument will be dereferenced automatically. This aspect of &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; is considered highly experimental. The exact behaviour may change in a future version of Perl.</source>
          <target state="translated">从Perl 5.14开始， &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 可以采用标量EXPR，该标量必须包含对未加祝福的哈希或数组的引用。该参数将自动取消引用。 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 这一方面被认为是高度实验性的。确切的行为可能会在Perl的将来版本中更改。</target>
        </trans-unit>
        <trans-unit id="de83fa8042912e9f6ddf571cde7008f435d64f25" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a5d1f49a9fb5c5245141f7dfc7c9150a868c0e" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99313bdb1dd7941c61f4079e6582dd0df5ded04d" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#pop-ARRAY&quot;&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e05abb4efe9535e153e305c31af2507782337868" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#push-ARRAY%2CLIST&quot;&gt;&lt;code&gt;push&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b401da5a4481ae0700b1ffba5e3e1def6bf593b" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#shift-ARRAY&quot;&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ee1f2fd5baa405873ebfdb113cbcd1a850a5c7" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04cd81960709d263997df907683fe183f516f9c" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#unshift-ARRAY%2CLIST&quot;&gt;&lt;code&gt;unshift&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37dbf87d17e9cfc89d47e4dceb5bb03787d175d3" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.14, an experimental feature allowed &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; to take a scalar expression. This experiment has been deemed unsuccessful, and was removed as of Perl 5.24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84114b43a4e1c51016947fa39587027a5c42b337" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.16, you can embed typemaps into your XS code instead of or in addition to typemaps in a separate file. Multiple such embedded typemaps will be processed in order of appearance in the XS code and like local typemap files take precedence over the default typemap, the embedded typemaps may overwrite previous definitions of TYPEMAP, INPUT, and OUTPUT stanzas. The syntax for embedded typemaps is</source>
          <target state="translated">从Perl 5.16开始,你可以在XS代码中嵌入typemaps,代替或补充单独文件中的typemaps。在XS代码中,多个这样的嵌入式类型映射将按照出现的顺序进行处理,就像本地类型映射文件优先于默认类型映射一样,嵌入式类型映射可能会覆盖之前定义的typemap、input和output节。嵌入式类型地图的语法是</target>
        </trans-unit>
        <trans-unit id="ead2268f227644c92e6fae21c9b2bbc1c3977d01" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8, a macro framework has been defined to allow static data to be safely stored in XS modules that will be accessed from a multi-threaded Perl.</source>
          <target state="translated">从Perl 5.8开始,我们定义了一个宏框架,允许静态数据安全地存储在XS模块中,这些模块将从多线程的Perl中访问。</target>
        </trans-unit>
        <trans-unit id="83f897274d9417a81431b1cfc87771e6f6b3c937" translate="yes" xml:space="preserve">
          <source>Starting with Perl 5.8.1 strict is strict about its restrictions: if unknown restrictions are used, the strict pragma will abort with</source>
          <target state="translated">从Perl 5.8.1开始,strict对限制条件的要求非常严格:如果使用了未知的限制条件,strict pragma会用下面的命令中止。</target>
        </trans-unit>
        <trans-unit id="4c86c42abf281eff02c433a98ecba5908f6fea66" translate="yes" xml:space="preserve">
          <source>Starting with Solaris 8, perl5.00503 (or higher) is supplied with the operating system, so you might not even need to build a newer version of perl at all. The Sun-supplied version is installed in /usr/perl5 with</source>
          <target state="translated">从Solaris 8开始,perl5.00503(或更高版本)随操作系统一起提供,所以你可能根本不需要构建一个更新的perl版本。Sun提供的版本是安装在/usr/perl5中的,并带有</target>
        </trans-unit>
        <trans-unit id="070cbbea94d8e9dec2f41e08f125528dd6a6e9b2" translate="yes" xml:space="preserve">
          <source>Starting with Tiger (Mac OS X 10.4), Apple shipped broken locale files for the eu_ES locale (Basque-Spain). In previous releases of Perl, this resulted in failures in the</source>
          <target state="translated">从Tiger (Mac OS X 10.4)开始,Apple提供的eu_ES语言(Basque-Spain)的locale文件出现了问题。在之前发布的Perl中,这导致了在</target>
        </trans-unit>
        <trans-unit id="0811928afaca739fa817229f5f4a0d0397bc7c2a" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt; .</source>
          <target state="translated">从版本1.23_03开始，Scalar-List-Util &lt;b&gt;始终&lt;/b&gt;使用XS实现，但是为了向后兼容，我们仍然提供 &lt;code&gt;List::Util::XS&lt;/code&gt; 模块，该模块仅加载 &lt;code&gt;List::Util&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd623545d3ee1fd614905389b9ae3f566a5c0eda" translate="yes" xml:space="preserve">
          <source>Starting with release 1.23_03, Scalar-List-Util is &lt;b&gt;always&lt;/b&gt; using the XS implementation, but for backwards compatibility, we still ship the &lt;code&gt;List::Util::XS&lt;/code&gt; module which just loads &lt;code&gt;List::Util&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f31afb43ed5a01839f8ddc750e5dd35f48c3a6c" translate="yes" xml:space="preserve">
          <source>Starting with this section, we will be discussing Perl's set of</source>
          <target state="translated">从本节开始,我们将讨论Perl的一组</target>
        </trans-unit>
        <trans-unit id="351709654314c24c7e4828574de12d19b419fe3b" translate="yes" xml:space="preserve">
          <source>Starting with version 2, the specification document is part of the CPAN-Meta distribution and will be published on CPAN as &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a60279d2b084f61a9ca16d8326eb786bc2e1ba" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef231992030ec09e2d04d1b4b88e1196c802a84" translate="yes" xml:space="preserve">
          <source>Starting with version 2.x, Berkeley DB has internal support for locking. The companion module to this one, &lt;b&gt;BerkeleyDB&lt;/b&gt;, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using &lt;b&gt;BerkeleyDB&lt;/b&gt;.</source>
          <target state="translated">从2.x版开始，Berkeley DB具有内部锁定支持。该模块的配套模块&lt;b&gt;BerkeleyDB&lt;/b&gt;提供了此锁定功能的接口。如果您真的想锁定Berkeley DB数据库，我强烈建议您使用&lt;b&gt;BerkeleyDB&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b0ddaaadcc9b4e10884d35d5140782f71785a028" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6299a2f62ed0797f2e4ca75150d013801fc49f" translate="yes" xml:space="preserve">
          <source>Starts a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">启动一个try块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79ce33706ca0540aaf9d8ed291d64bf45fad0cd4" translate="yes" xml:space="preserve">
          <source>Startup</source>
          <target state="translated">Startup</target>
        </trans-unit>
        <trans-unit id="6991439e4716de488447c6e2c2f9b1970b90a8e3" translate="yes" xml:space="preserve">
          <source>Stashes and Globs</source>
          <target state="translated">储藏室和球体</target>
        </trans-unit>
        <trans-unit id="d798831840bb11ab5bf25cf6beacc1e88e0ccd5f" translate="yes" xml:space="preserve">
          <source>State Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf91ec4328cf0ba3defd8522962fa33e41a1740" translate="yes" xml:space="preserve">
          <source>State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; 命令的状态存储。</target>
        </trans-unit>
        <trans-unit id="ed2cb72d0aaac69d6842c67515cf3bf802a6b33a" translate="yes" xml:space="preserve">
          <source>Statement Modifiers</source>
          <target state="translated">声明修正</target>
        </trans-unit>
        <trans-unit id="92fe71f129a3152d601e68e5cf094d2e72591e9b" translate="yes" xml:space="preserve">
          <source>Statement unlikely to be reached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ddbc09b1ca4e7855762d5787c6c0d7a3595a8af" translate="yes" xml:space="preserve">
          <source>Static Linking of a new Perl Binary</source>
          <target state="translated">新的Perl二进制的静态链接。</target>
        </trans-unit>
        <trans-unit id="3c5f15db40f98d51818ecdf0034d37509667528b" translate="yes" xml:space="preserve">
          <source>Static functions might not be visible for the backtrace.</source>
          <target state="translated">静态函数在回溯中可能不可见。</target>
        </trans-unit>
        <trans-unit id="8f8ab9355e9f77bfc04d09779d25ce6944605b91" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously.</source>
          <target state="translated">关于下载的统计是按大小和周期同时截断的。</target>
        </trans-unit>
        <trans-unit id="5b62492ca830ebc3f7a3384ab3714a073b9f3f35" translate="yes" xml:space="preserve">
          <source>Statistics about downloads are truncated by size and period simultaneously. Setting this to zero or negative disables download statistics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5610cd01f9a3d6080e798d67334a100aa1573c90" translate="yes" xml:space="preserve">
          <source>Status 1 overrides status 2. If you want unambiguous results, call &lt;b&gt;podchecker&lt;/b&gt; with one single argument only.</source>
          <target state="translated">状态1覆盖状态2。如果要获得明确的结果，请&lt;b&gt;仅&lt;/b&gt;使用一个参数调用&lt;b&gt;podchecker&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="187236d960db5eb4ad8363cf8f2f9b1ddb6ac5e1" translate="yes" xml:space="preserve">
          <source>Stdio class buffering options.</source>
          <target state="translated">Stdio类缓冲选项。</target>
        </trans-unit>
        <trans-unit id="60a9d23beb62cbe40cee43c7f38898ee6c1f97c7" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">斯特芬&amp;middot;穆勒（Steffen Mueller）&amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d59ce5418f2072a961fa75b41a54fbc928b69c82" translate="yes" xml:space="preserve">
          <source>Steffen Mueller &lt;code&gt;&amp;lt;smueller@cpan.org&lt;/code&gt;&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c982c59dd847ba297d8467bd252ba58dd872a85c" translate="yes" xml:space="preserve">
          <source>Steffen Mueller, &amp;lt;smueller@cpan.org&amp;gt;</source>
          <target state="translated">斯蒂芬&amp;middot;穆勒（Steffen Mueller），&amp;lt;smueller@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="67aeabbbe7f975f118f5118824dfb5a83bb31c11" translate="yes" xml:space="preserve">
          <source>Step-by-step: Distributing your module</source>
          <target state="translated">一步一步的。分发你的模块</target>
        </trans-unit>
        <trans-unit id="1a565c4552b2edcc3b1a58d76fe5018ccb0e6a32" translate="yes" xml:space="preserve">
          <source>Step-by-step: Making the module</source>
          <target state="translated">一步一步来。制作模块</target>
        </trans-unit>
        <trans-unit id="481a4d002beceae3935eab8245f4c76879540359" translate="yes" xml:space="preserve">
          <source>Step-by-step: Preparing the ground</source>
          <target state="translated">逐步进行。准备地面</target>
        </trans-unit>
        <trans-unit id="80427e23cbb5abd94ca5e55445014873b52c64b8" translate="yes" xml:space="preserve">
          <source>Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;, based on an earlier version by Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;, with contributions from Gisle Aas, James Duncan, Albert Dvornik, Robin Houston, Dave Mitchell, Hugo van der Sanden, Gurusamy Sarathy, Nick Ing-Simmons, and Rafael Garcia-Suarez.</source>
          <target state="translated">Stephen McCamant &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;，基于Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;的早期版本，由Gisle Aas，James Duncan，Albert Dvornik，Robin Houston，Dave Mitchell，雨果&amp;middot;范德&amp;middot;桑登（Hugo van der Sanden），古鲁萨米&amp;middot;萨拉西（Gurusamy Sarathy），尼克&amp;middot;英格&amp;middot;西蒙斯（Nick Ing-Simmons）和拉斐尔&amp;middot;加西亚&amp;middot;苏亚雷斯（Rafael Garcia-Suarez）。</target>
        </trans-unit>
        <trans-unit id="6a244b340bceacb4b7643a7f28401322b0f43369" translate="yes" xml:space="preserve">
          <source>Stephen McCamant, &amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;.</source>
          <target state="translated">史蒂芬&amp;middot;麦卡曼（Stephen McCamant），&amp;lt;smcc@CSUA.Berkeley.EDU&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="406bdac466755debe16970475ad1ba98d0b486e3" translate="yes" xml:space="preserve">
          <source>Stepping through code</source>
          <target state="translated">踏过代码</target>
        </trans-unit>
        <trans-unit id="f13a1be70942b94ceb5c4947f5cad9efec256df0" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time, without descending into functions.</source>
          <target state="translated">一行一行地浏览程序,不需要进入函数。</target>
        </trans-unit>
        <trans-unit id="67e08e5dee051e0626b0f262d208037e870d3ac2" translate="yes" xml:space="preserve">
          <source>Steps through the program a line at a time.</source>
          <target state="translated">一行一行地走过程序。</target>
        </trans-unit>
        <trans-unit id="44dfc13e25f20c2b72056096edf2fa584b23e680" translate="yes" xml:space="preserve">
          <source>Steve Grazzini &amp;lt;steve.grazzini@grantstreet.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18c11d1612cf243a4188b75a5a32a4030b759d2" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;</source>
          <target state="translated">史蒂夫&amp;middot;海伊&amp;lt;</target>
        </trans-unit>
        <trans-unit id="378237399a39a01265203b3e7167eea75f75c0c4" translate="yes" xml:space="preserve">
          <source>Steve Hay &amp;lt;steve.m.hay@googlemail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28fe4c0fd5295a5323e60434a55f5b50b8297659" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d16db78589f14f29e83bbd762e7ffb3c9579828" translate="yes" xml:space="preserve">
          <source>Steve Lembark goes through the details in his YAPC::NA 2009 talk &quot;Perly Linked Lists&quot; ( &lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt; ), although you can just use his &lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList::Single&lt;/a&gt; module.</source>
          <target state="translated">史蒂夫&amp;middot;伦巴克（Steve Lembark）在YAPC :: NA 2009演讲&amp;ldquo; Perly Linked Lists&amp;rdquo;（&lt;a href=&quot;http://www.slideshare.net/lembark/perly-linked-lists&quot;&gt;http://www.slideshare.net/lembark/perly-linked-lists&lt;/a&gt;）中详细介绍了该过程，尽管您可以使用他的&lt;a href=&quot;http://search.cpan.org/perldoc/LinkedList::Single&quot;&gt;LinkedList :: Single&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="09652192134371fdefcd293d5003ff83e32ed6ed" translate="yes" xml:space="preserve">
          <source>Steve Peters &amp;lt;steve@fisharerojo.org&amp;gt;</source>
          <target state="translated">史蒂夫&amp;middot;彼得斯&amp;lt;steve@fisharerojo.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7d6ea163d8063bfc57b0256f3178b768eac364c1" translate="yes" xml:space="preserve">
          <source>Steve Purkis</source>
          <target state="translated">Steve Purkis</target>
        </trans-unit>
        <trans-unit id="9efb7766602083380f01f9cadb6f278fbfabf5e5" translate="yes" xml:space="preserve">
          <source>Steve Purkis &amp;lt;spurkis@cpan.org&amp;gt;</source>
          <target state="translated">史蒂夫&amp;middot;珀基斯（Steve Purkis）&amp;lt;spurkis@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2200943829d703ee08a178c2eb1eee2c0a806988" translate="yes" xml:space="preserve">
          <source>Steve Purkis.</source>
          <target state="translated">Steve Purkis</target>
        </trans-unit>
        <trans-unit id="270c172269bbb0672801106f89223f66575337c6" translate="yes" xml:space="preserve">
          <source>Steven McDougall &amp;lt;swmcd@world.std.com&amp;gt; for his help and patience with re-writing this manpage.</source>
          <target state="translated">史蒂文&amp;middot;麦克杜格尔（Steven McDougall）&amp;lt;swmcd@world.std.com&amp;gt;感谢他的帮助和耐心，重新编写了此联机帮助页。</target>
        </trans-unit>
        <trans-unit id="3a70ee5e8fb61558310f5b5e31b73a3d007c0de0" translate="yes" xml:space="preserve">
          <source>Still another problem is that this approach can lead to two code points meaning the same character. Thus in a Greek locale, both U+03A7 and U+00D7 are GREEK CAPITAL LETTER CHI.</source>
          <target state="translated">还有一个问题是,这种方法可能会导致两个码点意思相同的字符。因此在希腊语的地方,U+03A7和U+00D7都是GREEK CAPITAL LETTER CHI。</target>
        </trans-unit>
        <trans-unit id="8328b23c2df12839f29c28c4eca38fd0aaace45d" translate="yes" xml:space="preserve">
          <source>Still another use is to maintain visual space between &lt;code&gt;=item&lt;/code&gt; lines. If you specify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f032a03c23ac64e26ed67dff94c5b968b51897fa" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.02</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548ad6711bf4d2c2e72ae86a234fd3904bec68fd" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.05</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42108b0060916a9925408d666ac09829728230ed" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.11</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c382741891bd1d6f7e460709510a9d80509ec7fa" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.20</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee45fe089bcfb256a94238e7233dca4c3a45655" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.3.0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0f25affc6234202644d5b637ab1fbe92fe3712" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.32</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6880cdcd0506151ea51b1d4e727ce16ab7512631" translate="yes" xml:space="preserve">
          <source>Still broken as of version: 0.373</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3165fead8117026ccedeeae5459ce4da4396860" translate="yes" xml:space="preserve">
          <source>Still broken in version: 0.052</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3eea18c3547245e8ba9bb10ace527c065a868d" translate="yes" xml:space="preserve">
          <source>Still in Settings, in Channel Update, select Beta Channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfa5a1bd92d7066216395c95a296195ffe2e0f16" translate="yes" xml:space="preserve">
          <source>Stolen from File::Path::Expand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6682620d81182203397e365b84fecf9cd43d1829" translate="yes" xml:space="preserve">
          <source>Stop logging each disk request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bc7a84f86b7c98bba879166a64bc5b045625fd" translate="yes" xml:space="preserve">
          <source>Stops running tests as &quot;TODO&quot; tests. This method is fatal if called without a preceding &lt;code&gt;todo_start&lt;/code&gt; method call.</source>
          <target state="translated">停止将测试作为&amp;ldquo; TODO&amp;rdquo;测试运行。如果在没有前面的 &lt;code&gt;todo_start&lt;/code&gt; 方法调用的情况下调用此方法，将是致命的。</target>
        </trans-unit>
        <trans-unit id="45b0f8b6273dfd6e7997a4038c99b48d40e17dae" translate="yes" xml:space="preserve">
          <source>Storable</source>
          <target state="translated">Storable</target>
        </trans-unit>
        <trans-unit id="46f9f6e335231e1456d3ba18bd5a505213eb74c6" translate="yes" xml:space="preserve">
          <source>Storable - persistence for Perl data structures</source>
          <target state="translated">Storable--Perl数据结构的持久化。</target>
        </trans-unit>
        <trans-unit id="1630856d50b3ec9af87960aa33400ccd3dc094bd" translate="yes" xml:space="preserve">
          <source>Storable has now been changed to write out and read in a file header with information about the size of integers. It's impossible to detect whether an old file being read in was written with 32 or 64 bit integers (they have the same header) so it's impossible to automatically switch to a correct backwards compatibility mode. Hence this Storable defaults to the new, correct behaviour.</source>
          <target state="translated">Storable现在已经被改变为写出和读入一个带有整数大小信息的文件头。它不可能检测到被读入的旧文件是用32位还是64位整数写的(它们有相同的头),所以不可能自动切换到正确的向后兼容模式。因此,这个Storable默认为新的、正确的行为。</target>
        </trans-unit>
        <trans-unit id="714a2ccbafbac0389af167e01df326cf6b8a78ff" translate="yes" xml:space="preserve">
          <source>Storable magic</source>
          <target state="translated">储存魔法</target>
        </trans-unit>
        <trans-unit id="dfd98121663ee3170e7a7e6a0d89a8a9dfe033b8" translate="yes" xml:space="preserve">
          <source>Storable now has experimental support for storing regular expressions, but there are significant limitations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7182df5560db2bb6b5167976e453bb5798e3130f" translate="yes" xml:space="preserve">
          <source>Storable provides you with a &lt;code&gt;dclone&lt;/code&gt; interface which does not create that intermediary scalar but instead freezes the structure in some internal memory space and then immediately thaws it out.</source>
          <target state="translated">Storable为您提供了一个 &lt;code&gt;dclone&lt;/code&gt; 接口，该接口不会创建该中间标量，而是将结构冻结在某些内部内存空间中，然后立即将其解冻。</target>
        </trans-unit>
        <trans-unit id="70fb12ce1748ed7f4a137be836ce41aa365bbd68" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt; ). Use eval {} to trap those exceptions.</source>
          <target state="translated">Storable使用&amp;ldquo;例外&amp;rdquo;范式，因为它不会尝试解决失败：如果发生了某些不良情况，则会从调用者的角度生成异常（请参阅&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;和 &lt;code&gt;croak()&lt;/code&gt; ）。使用eval {}捕获那些异常。</target>
        </trans-unit>
        <trans-unit id="efb225f838cb012d7da5a2492afd60f053bbc61a" translate="yes" xml:space="preserve">
          <source>Storable uses the &quot;exception&quot; paradigm, in that it does not try to workaround failures: if something bad happens, an exception is generated from the caller's perspective (see &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; and &lt;code&gt;croak()&lt;/code&gt;). Use eval {} to trap those exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531ca0b8b45f41c9f0b1aa246372790831675baa" translate="yes" xml:space="preserve">
          <source>Storable was written by Raphael Manfredi</source>
          <target state="translated">Storable是由Raphael Manfredi写的。</target>
        </trans-unit>
        <trans-unit id="2f13ce5cb38e462f6f7f68a313f75016b704439f" translate="yes" xml:space="preserve">
          <source>Storable will throw an exception if a frozen regular expression cannot be thawed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e864254e3dece2f3614748bd8acc66ad85caaa" translate="yes" xml:space="preserve">
          <source>Storable writes a file header which contains the sizes of various C language types for the C compiler that built Storable (when not writing in network order), and will refuse to load files written by a Storable not on the same (or compatible) architecture. This check and a check on machine byteorder is needed because the size of various fields in the file are given by the sizes of the C language types, and so files written on different architectures are incompatible. This is done for increased speed. (When writing in network order, all fields are written out as standard lengths, which allows full interworking, but takes longer to read and write)</source>
          <target state="translated">Storable会给构建Storable的C编译器写一个文件头,这个文件头包含了各种C语言类型的大小(不按网络顺序写的时候),会拒绝加载不在同一(或兼容)架构上的Storable写的文件。这个检查和对机器字节顺序的检查是需要的,因为文件中各种字段的大小是由C语言类型的大小给出的,所以在不同架构上编写的文件是不兼容的。这样做是为了提高速度。(按网络顺序写时,所有字段都按标准长度写出来,这样可以实现充分的互通,但读写时间较长)</target>
        </trans-unit>
        <trans-unit id="fcaa72ed14ae844e5cba322adeff102b58e7d72e" translate="yes" xml:space="preserve">
          <source>Store (method 0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4150d3a5cc43231c993765dececd1a150bb52a3d" translate="yes" xml:space="preserve">
          <source>Store Memoized data in Storable database</source>
          <target state="translated">将记忆数据存储在可存储数据库中。</target>
        </trans-unit>
        <trans-unit id="92a651d3dc16aed75ba857e2f774b7e083ba7965" translate="yes" xml:space="preserve">
          <source>Store and re-use state information about distributions between CPAN.pm sessions?</source>
          <target state="translated">存储和重用CPAN.pm会话之间分布的状态信息?</target>
        </trans-unit>
        <trans-unit id="2c71530924851d1b8827aef4994b16eb515c4e61" translate="yes" xml:space="preserve">
          <source>Store data</source>
          <target state="translated">储存日期</target>
        </trans-unit>
        <trans-unit id="b25c722ad4f1fce5bbbe8fc35b0030d7d69ef919" translate="yes" xml:space="preserve">
          <source>Store datum</source>
          <target state="translated">存储基准面</target>
        </trans-unit>
        <trans-unit id="8f37eea7a30e3775bbbbb580f43dfdd3bec41576" translate="yes" xml:space="preserve">
          <source>Store the results of a test.</source>
          <target state="translated">存储测试的结果。</target>
        </trans-unit>
        <trans-unit id="389cd56c2ab90c83d09e93be1e21e43d82460448" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;$value&lt;/code&gt; in the gzip OS header field. A number between 0 and 255 is valid.</source>
          <target state="translated">将 &lt;code&gt;$value&lt;/code&gt; 存储在gzip OS标头字段中。0到255之间的数字有效。</target>
        </trans-unit>
        <trans-unit id="b39d714bdc1e95f53f0e2222e4e3c3755001f302" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; . The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store_ent takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that hv_store_ent only reads the &lt;code&gt;key&lt;/code&gt; ; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">将 &lt;code&gt;val&lt;/code&gt; 存储在哈希中。哈希键被指定为 &lt;code&gt;key&lt;/code&gt; 。的 &lt;code&gt;hash&lt;/code&gt; 参数是预先计算的散列值;如果为零，则Perl将对其进行计算。返回值是这样创建的新哈希条目。如果操作失败或如果该值实际上不需要存储在哈希中（如绑定哈希的情况），则为NULL。否则，可以使用 &lt;code&gt;He?&lt;/code&gt; 访问返回值的内容。这里描述的宏。请注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。有效地，成功的hv_store_ent拥有对 &lt;code&gt;val&lt;/code&gt; 的一个引用的所有权。这通常是您想要的；新创建的SV的引用计数为1，因此，如果您所有的代码都是创建SV，然后将其存储在哈希中，则hv_store将拥有对新SV的唯一引用，并且您的代码无需执行任何其他操作即可整理。注意hv_store_ent只读取 &lt;code&gt;key&lt;/code&gt; ；与 &lt;code&gt;val&lt;/code&gt; 不同，它不拥有它的所有权，因此，保持 &lt;code&gt;key&lt;/code&gt; 上正确的引用计数完全是调用者的责任。 hv_store未实现为对hv_store_ent的调用，并且不会为密钥创建临时SV，因此，如果密钥数据尚未采用SV格式，则优先使用hv_store而不是hv_store_ent。</target>
        </trans-unit>
        <trans-unit id="1d4914da783cf76bac012d3e2b02900b8208b54e" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;val&lt;/code&gt; in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it. The return value is the new hash entry so created. It will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise the contents of the return value can be accessed using the &lt;code&gt;He?&lt;/code&gt; macros described here. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful &lt;code&gt;hv_store_ent&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. Note that &lt;code&gt;hv_store_ent&lt;/code&gt; only reads the &lt;code&gt;key&lt;/code&gt;; unlike &lt;code&gt;val&lt;/code&gt; it does not take ownership of it, so maintaining the correct reference count on &lt;code&gt;key&lt;/code&gt; is entirely the caller's responsibility. The reason it does not take ownership, is that &lt;code&gt;key&lt;/code&gt; is not used after this function returns, and so can be freed immediately. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e853791e7f610503cb4ac62aa2d38d07104bcbf" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash</source>
          <target state="translated">将一个与键相关联的值存储在 cop hints hash 中。</target>
        </trans-unit>
        <trans-unit id="e4608cb007876dc9a320a4e730182bf778f713b9" translate="yes" xml:space="preserve">
          <source>Stores a value, associated with a key, in the cop hints hash &lt;code&gt;cophh&lt;/code&gt;, and returns the modified hash. The returned hash pointer is in general not the same as the hash pointer that was passed in. The input hash is consumed by the function, and the pointer to it must not be subsequently used. Use &lt;a href=&quot;#cophh_copy&quot;&gt;&quot;cophh_copy&quot;&lt;/a&gt; if you need both hashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0142d462eb02b96cf9082ac295203e85636940" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt; . The values are the original list elements.</source>
          <target state="translated">将LIST的每个元素的所有明确的截断存储为 &lt;code&gt;$hashref&lt;/code&gt; 引用的关联数组中的键。这些值是原始列表元素。</target>
        </trans-unit>
        <trans-unit id="c2253242048c2f74667f3a23355d9505c38b27fe" translate="yes" xml:space="preserve">
          <source>Stores all unambiguous truncations of each element of LIST as keys in the associative array referenced by &lt;code&gt;$hashref&lt;/code&gt;. The values are the original list elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4236561c990b7cd479ccb52f08cd5fac9306b818" translate="yes" xml:space="preserve">
          <source>Stores an SV in a hash. The hash key is specified as &lt;code&gt;key&lt;/code&gt; and the absolute value of &lt;code&gt;klen&lt;/code&gt; is the length of the key. If &lt;code&gt;klen&lt;/code&gt; is negative the key is assumed to be in UTF-8-encoded Unicode. The &lt;code&gt;hash&lt;/code&gt; parameter is the precomputed hash value; if it is zero then Perl will compute it.</source>
          <target state="translated">将SV存储在哈希中。哈希密钥被指定为 &lt;code&gt;key&lt;/code&gt; ， &lt;code&gt;klen&lt;/code&gt; 的绝对值是密钥的长度。如果 &lt;code&gt;klen&lt;/code&gt; 为负，则假定密钥为UTF-8编码的Unicode。的 &lt;code&gt;hash&lt;/code&gt; 参数是预先计算的散列值; 如果为零，则Perl将对其进行计算。</target>
        </trans-unit>
        <trans-unit id="d6c29a0065e8b044a53af0ddb9dc3214fa041cf5" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt; . The return value will be NULL if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt; )).</source>
          <target state="translated">将SV存储在数组中。数组索引指定为 &lt;code&gt;key&lt;/code&gt; 。如果操作失败或如果不需要将该值实际存储在数组中（如绑定数组），则返回值为NULL。否则，可以取消引用以获取存储在那里的 &lt;code&gt;SV*&lt;/code&gt; （= &lt;code&gt;val&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="76dd68cc1b2cbd70a2c8fe63742bb4f5c0c8d0f4" translate="yes" xml:space="preserve">
          <source>Stores an SV in an array. The array index is specified as &lt;code&gt;key&lt;/code&gt;. The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the array (as in the case of tied arrays). Otherwise, it can be dereferenced to get the &lt;code&gt;SV*&lt;/code&gt; that was stored there (= &lt;code&gt;val&lt;/code&gt;)).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7401a972574f8c1665c02fe0802590c81677bf55" translate="yes" xml:space="preserve">
          <source>Stores an alias to a variable in a hash instead of copying the value.</source>
          <target state="translated">在哈希中存储一个变量的别名,而不是复制其值。</target>
        </trans-unit>
        <trans-unit id="9f6711f9c55cd1025cf538a50470266deb723a43" translate="yes" xml:space="preserve">
          <source>Stores results for later output, all together.</source>
          <target state="translated">将结果存储起来,以便以后输出,所有的人都在一起。</target>
        </trans-unit>
        <trans-unit id="ced5e829ffc1318c3116b905b84107c1f3b72848" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the COMMENT field in the gzip header. By default, no comment field is written to the gzip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在gzip标头的COMMENT字段中。默认情况下，没有注释字段写入gzip文件。</target>
        </trans-unit>
        <trans-unit id="26843a54a3aa3332ec1baa3fb76f8c537a96c327" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the Central File Header of the zip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在zip文件的中央文件头中。</target>
        </trans-unit>
        <trans-unit id="f6d27852fc3f996b193528d04367b82db064d418" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$comment&lt;/code&gt; in the End of Central Directory record of the zip file.</source>
          <target state="translated">将 &lt;code&gt;$comment&lt;/code&gt; 的内容存储在zip文件的Central Directory末尾记录中。</target>
        </trans-unit>
        <trans-unit id="24042b8640feee28c4f2a0aafea788776423cdd1" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the gzip NAME header field. If &lt;code&gt;Name&lt;/code&gt; is not specified, no gzip NAME field will be created.</source>
          <target state="translated">将 &lt;code&gt;$string&lt;/code&gt; 的内容存储在gzip NAME标头字段中。如果未指定 &lt;code&gt;Name&lt;/code&gt; 则不会创建gzip NAME字段。</target>
        </trans-unit>
        <trans-unit id="1023c335a52babfe2f8c4a04c4f2766471fa8387" translate="yes" xml:space="preserve">
          <source>Stores the contents of &lt;code&gt;$string&lt;/code&gt; in the zip filename header field.</source>
          <target state="translated">将 &lt;code&gt;$string&lt;/code&gt; 的内容存储在zip文件名标题字段中。</target>
        </trans-unit>
        <trans-unit id="51541d8a3d93b2d48a376cb2252ed37ed72421ab" translate="yes" xml:space="preserve">
          <source>Stores the key/value pair in the database.</source>
          <target state="translated">在数据库中存储键/值对。</target>
        </trans-unit>
        <trans-unit id="ab093d23324af52293488a603b3cc3854b181a9e" translate="yes" xml:space="preserve">
          <source>Stores the pad name (which may be null) at the given index, freeing any existing pad name in that slot.</source>
          <target state="translated">在给定的索引中存储垫名(可以是空的),释放该槽中任何现有的垫名。</target>
        </trans-unit>
        <trans-unit id="9d70a29a0f92ba96f998b27b0c51d6b21ce2123e" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">存储字符串 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 字符串化到。例如，在 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/eek/&lt;/a&gt;&lt;/code&gt; 的情况下，Perl引擎存储 &lt;code&gt;(?^:eek)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bba419efdc2f7f861e8ccd4110f43bd3fa7e32d3" translate="yes" xml:space="preserve">
          <source>Stores the string &lt;code&gt;qr//&lt;/code&gt; stringifies to. The Perl engine for example stores &lt;code&gt;(?^:eek)&lt;/code&gt; in the case of &lt;code&gt;qr/eek/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30082107d90ca21e79e8350f2001678a7dc4b25b" translate="yes" xml:space="preserve">
          <source>Storing data canonically that contains large hashes can be significantly slower than storing the same data normally, as temporary arrays to hold the keys for each hash have to be allocated, populated, sorted and freed. Some tests have shown a halving of the speed of storing -- the exact penalty will depend on the complexity of your data. There is no slowdown on retrieval.</source>
          <target state="translated">以规范的方式存储包含大型散列的数据可能会比正常存储相同的数据要慢得多,因为必须分配、填充、排序和释放用于保存每个散列键的临时数组。一些测试表明,存储的速度减半--具体的惩罚将取决于你的数据的复杂程度。检索速度不会减慢。</target>
        </trans-unit>
        <trans-unit id="2ccce2de5e8ad98636ec0480f8c1e95cb4123766" translate="yes" xml:space="preserve">
          <source>Storing numbers</source>
          <target state="translated">储存数字</target>
        </trans-unit>
        <trans-unit id="408286a7232f91f660936da7835bac0e8863fd20" translate="yes" xml:space="preserve">
          <source>Storing options values in a hash</source>
          <target state="translated">在哈希中存储期权值</target>
        </trans-unit>
        <trans-unit id="5ca11c09231ed950fa4ac2095c30a18383eebf81" translate="yes" xml:space="preserve">
          <source>Storing pre-compiled regexps in an array &lt;code&gt;@compiled&lt;/code&gt; allows us to simply loop through the regexps without any recompilation, thus gaining flexibility without sacrificing speed.</source>
          <target state="translated">将预编译的正则 &lt;code&gt;@compiled&lt;/code&gt; 存储在数组@compiled中，使我们可以简单地循环遍历该正则表达式而无需任何重新编译，从而在不牺牲速度的情况下获得了灵活性。</target>
        </trans-unit>
        <trans-unit id="3e08b2cdc880eca3b63a251507ea23ebf665def8" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; , for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="translated">直截了当地，我们可以看到每行被调用的次数与 &lt;code&gt;Devel::SmallProf&lt;/code&gt; 输出相同，并且根据每行执行时间的长短， &lt;code&gt;if ( $debug ) { &lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $message = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; ， 例如。记录的实际时间差异可能是内部使用的算法，也可能是由于系统资源限制或争用所致。</target>
        </trans-unit>
        <trans-unit id="b0bd17b455e668c15c8b3e94cf9e6f3076ea19b7" translate="yes" xml:space="preserve">
          <source>Straightaway we can see that the number of times each line has been called is identical to the &lt;code&gt;Devel::SmallProf&lt;/code&gt; output, and the sequence is only very slightly different based on the ordering of the amount of time each line took to execute, &lt;code&gt;if ( $debug ) { &lt;/code&gt; and &lt;code&gt;my $message = shift;&lt;/code&gt;, for example. The differences in the actual times recorded might be in the algorithm used internally, or it could be due to system resource limitations or contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf5060e04f34c62382f4c8552c1d1cf9f000d47b" translate="yes" xml:space="preserve">
          <source>Strategies for Storing Callback Context Information</source>
          <target state="translated">存储回调上下文信息的策略</target>
        </trans-unit>
        <trans-unit id="85d8ba9bfe62936890930b5c6a10433e149d003f" translate="yes" xml:space="preserve">
          <source>Stratus OpenVOS (17.0 or later)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="813265ea56803a78f3b7159d5fee7e20c7133600" translate="yes" xml:space="preserve">
          <source>Stratus Technologies on the web at &lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</source>
          <target state="translated">Web上的Stratus Technologies网址为&lt;a href=&quot;http://www.stratus.com&quot;&gt;http://www.stratus.com&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e27222dd34cc6a5684f257f4f56510f3e78b139" translate="yes" xml:space="preserve">
          <source>Stratus VOS / OpenVOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e8d1a4aa1f448e22fd91f660943bf3fb47ccc9" translate="yes" xml:space="preserve">
          <source>Stratus VOS 15.1, &lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&lt;/a&gt;</source>
          <target state="translated">Stratus VOS 15.1，&lt;a href=&quot;http://stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context=r502-01&amp;amp;file=ch5r502-01bi.html&quot;&gt;http:&lt;/a&gt; //stratadoc.stratus.com/vos/15.1.1/r502-01/wwhelp/wwhimpl/js/html/wwhelp.htm?context = r502-01&amp;amp;file=ch5r502-01bi.html</target>
        </trans-unit>
        <trans-unit id="6dac5050cc8d5226a232897b98c67a79066b8e3a" translate="yes" xml:space="preserve">
          <source>Stream TAP from a Perl executable</source>
          <target state="translated">从Perl可执行文件中流出TAP流</target>
        </trans-unit>
        <trans-unit id="411adcb2712346800a739adfeb9ade95333b1abf" translate="yes" xml:space="preserve">
          <source>Stream TAP from a text file.</source>
          <target state="translated">从文本文件传输TAP。</target>
        </trans-unit>
        <trans-unit id="5517c94f54c087e37e9e39887df00a0c39d682fc" translate="yes" xml:space="preserve">
          <source>Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="translated">从一个IO::Handle或一个GLOB流TAP。</target>
        </trans-unit>
        <trans-unit id="aa321b146ad904dc93d6b1334004656dc82f28d4" translate="yes" xml:space="preserve">
          <source>Stream format with carriage-return terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf344468bbe5af0df1f27ec4b813e688b7db58d7" translate="yes" xml:space="preserve">
          <source>Stream format with line-feed terminator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044591cd59e9b7c9396655ff7bb64423112f9b95" translate="yes" xml:space="preserve">
          <source>Stream output from an executable TAP source</source>
          <target state="translated">从可执行的TAP源输出流</target>
        </trans-unit>
        <trans-unit id="137d2933966619b13837102be962efe1a1067d69" translate="yes" xml:space="preserve">
          <source>Stream output from raw TAP in a scalar/array ref.</source>
          <target state="translated">以标量/数组形式从原始TAP中输出的数据流。</target>
        </trans-unit>
        <trans-unit id="1e8325521df6e6903ede77955f9bf1a333363aed" translate="yes" xml:space="preserve">
          <source>Streaming</source>
          <target state="translated">Streaming</target>
        </trans-unit>
        <trans-unit id="79d9a52c246461dc0594d29507cd94db89e5088f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="translated">更严格的规则有助于查找错别字和其他错误。如果 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 是其他字符，或者应该转义（例如 &lt;code&gt;&quot;\-&quot;&lt;/code&gt; ），也许您甚至都没有打算在此指定范围。如果您确实打算使用某个范围，那么所使用的范围就不能在ASCII和EBCDIC平台之间移植，并且对普通读者没有明显的意义。</target>
        </trans-unit>
        <trans-unit id="5396990d692459cc4babef519081fd255b847e8f" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. Perhaps you didn't even intend a range here, if the &lt;code&gt;&quot;-&quot;&lt;/code&gt; was meant to be some other character, or should have been escaped (like &lt;code&gt;&quot;\-&quot;&lt;/code&gt;). If you did intend a range, the one that was used is not portable between ASCII and EBCDIC platforms, and doesn't have an obvious meaning to a casual reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eda0deef3d3835356e2633ac9dde47a16b13b5d" translate="yes" xml:space="preserve">
          <source>Stricter rules help to find typos and other errors. You included a range, and at least one of the end points is a decimal digit. Under the stricter rules, when this happens, both end points should be digits in the same group of 10 consecutive digits.</source>
          <target state="translated">更严格的规则有助于发现错别字和其他错误。你包含了一个范围,并且至少有一个端点是小数点。根据更严格的规则,当发生这种情况时,两个端点应该是同一组10个连续数字中的数字。</target>
        </trans-unit>
        <trans-unit id="8871c27b11e121bdab37c41ce307e123e5948970" translate="yes" xml:space="preserve">
          <source>Strictly speaking, MIME header encoding documented in RFC 2047 is more of encapsulation than encoding. However, their support in modern world is imperative so they are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0650e0c020aef4abbfbd4bda604f404ed598e991" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that munches up another program and spits out yet another file containing the program in a &amp;ldquo;more executable&amp;rdquo; form, typically containing native machine instructions. The</source>
          <target state="translated">严格来说，是一种程序，它压缩另一个程序并以&amp;ldquo;更具可执行性&amp;rdquo;的形式吐出另一个包含该程序的文件，该文件通常包含本机指令。的</target>
        </trans-unit>
        <trans-unit id="19287d999efabb7aed57bbe8e78bb9475aab4690" translate="yes" xml:space="preserve">
          <source>Strictly speaking, a program that reads a second program and does what the second program says directly without turning the program into a different form first, which is what &lt;b&gt;compilers&lt;/b&gt; do. Perl is not an interpreter by this definition, because it contains a kind of compiler that takes a program and turns it into a more executable form (&lt;b&gt;syntax trees&lt;/b&gt;) within the</source>
          <target state="translated">严格来说，一个程序读取第二个程序并直接执行第二个程序所说的操作，而无需先将程序转换为其他形式，这就是&lt;b&gt;编译器&lt;/b&gt;所做的。Perl不是此定义的解释器，因为它包含一种编译器，该编译器接受程序并将其转换为更可执行的形式（&lt;b&gt;语法树&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="a6fde2b9f7e959d871c8af08462a6492339f7057" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="translated">严格来说，没什么。从风格上讲，这不是编写可维护代码的好方法。Perl有多个用于运行外部命令的运算符。反引号是一个；他们从命令中收集输出以在您的程序中使用。该 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 的功能是另一个; 它不会这样做。</target>
        </trans-unit>
        <trans-unit id="3c8ebada708fb113d97be17e44dc95013a97d6cf" translate="yes" xml:space="preserve">
          <source>Strictly speaking, nothing. Stylistically speaking, it's not a good way to write maintainable code. Perl has several operators for running external commands. Backticks are one; they collect the output from the command for use in your program. The &lt;code&gt;system&lt;/code&gt; function is another; it doesn't do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ea50d3a212d751dc75823785ce8d3fc481176b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="translated">严格来说，应该以与 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 一致的格式来指定年份，即与1900的偏移量。为了使人们更容易理解年份，但更习惯于将年份视为两位数或四位数的值，遵循以下约定：</target>
        </trans-unit>
        <trans-unit id="23a6b2fb53b29ab8753d41951749465184e362aa" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the year should be specified in a form consistent with &lt;code&gt;localtime()&lt;/code&gt;, i.e. the offset from 1900. In order to make the interpretation of the year easier for humans, however, who are more accustomed to seeing years as two-digit or four-digit values, the following conventions are followed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4b8f90e8599772141d5d74184d3678eb652f81" translate="yes" xml:space="preserve">
          <source>Strictly, the shell&amp;rsquo;s &lt;code&gt;*&lt;/code&gt; character, which will match a &amp;ldquo;glob&amp;rdquo; of characters when you&amp;rsquo;re trying to generate a list of filenames. Loosely, the act of using globs and similar symbols to do pattern matching. See also &lt;b&gt;fileglob&lt;/b&gt; and &lt;b&gt;typeglob&lt;/b&gt;.</source>
          <target state="translated">严格来说，shell的 &lt;code&gt;*&lt;/code&gt; 字符将与您尝试生成文件名列表时的字符&amp;ldquo; glob&amp;rdquo;匹配。松散地使用glob和类似符号进行模式匹配的行为。另请参见&lt;b&gt;fileglob&lt;/b&gt;和&lt;b&gt;typeglob&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="158127f06e6da3362607fa7cbbba756efc7019b1" translate="yes" xml:space="preserve">
          <source>Strictness and warnings</source>
          <target state="translated">严格性和警告</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="516c0f4e3c92a494342e3cb25a961d2360643bc2" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="translated">字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;LC_NUMERIC&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13d19fb185a642a2881088ab8e929269f84edb68" translate="yes" xml:space="preserve">
          <source>String &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322644ec18f089375fd934ccac0ee29b7bf9401a" translate="yes" xml:space="preserve">
          <source>String Collation</source>
          <target state="translated">字符串整理</target>
        </trans-unit>
        <trans-unit id="40837ec372cc75f0a51393ed930c1fe017719b97" translate="yes" xml:space="preserve">
          <source>String Equivalence</source>
          <target state="translated">字符串等价</target>
        </trans-unit>
        <trans-unit id="c0852fa4a49f9a7f054796351af22423733e0ae5" translate="yes" xml:space="preserve">
          <source>String Lengths</source>
          <target state="translated">字符串长度</target>
        </trans-unit>
        <trans-unit id="b231adac90ed5af6e5723df56d210bfd345958ac" translate="yes" xml:space="preserve">
          <source>String Processing, Language Text Processing, Parsing, and Searching</source>
          <target state="translated">字符串处理、语言文字处理、解析和搜索。</target>
        </trans-unit>
        <trans-unit id="a76a0b86b2d8c7c2af26080ae08b76bef9730da0" translate="yes" xml:space="preserve">
          <source>String comparison</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f618ca662dfcc3b16eb26b3a99e8a37d3fd5c229" translate="yes" xml:space="preserve">
          <source>String constants that would normally evaluate to 0 or 1 are warned about.</source>
          <target state="translated">字符串常量通常为0或1,会被警告。</target>
        </trans-unit>
        <trans-unit id="6104084e70872a799af75c0c3b3e9c680e29b421" translate="yes" xml:space="preserve">
          <source>String conversion</source>
          <target state="translated">字符串转换</target>
        </trans-unit>
        <trans-unit id="8dc84df0bc8f7e36bf6046d5ceb68a3cfd06dca6" translate="yes" xml:space="preserve">
          <source>String conversion methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ce711ae430e00ec658d92f901bfb5ff64ae114" translate="yes" xml:space="preserve">
          <source>String eval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597fe8909ca1928228ff982d52d105d13e058f8b" translate="yes" xml:space="preserve">
          <source>String eval and LC_NUMERIC</source>
          <target state="translated">字符串 eval 和 LC_NUMERIC</target>
        </trans-unit>
        <trans-unit id="4941134ab361827bee0789e57907295ac43600ee" translate="yes" xml:space="preserve">
          <source>String for the package. If the package does not have a &lt;code&gt;$VERSION&lt;/code&gt;, this field must be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860dceea01893fc71bff8d83982d93e598606a4e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下，字符串处理功能继续在字符方面运行。例如， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 返回字符串中的字符数，就像以前一样。但是该数字不再必须与字符串中的字节数相同（字节数多于字符数）。其他此类函数包括 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/rindex&quot;&gt;rindex()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="401ccffa7eab02269ca231a09dc9fc080d0ef44e" translate="yes" xml:space="preserve">
          <source>String handling functions, for the most part, continue to operate in terms of characters. &lt;code&gt;length()&lt;/code&gt;, for example, returns the number of characters in a string, just as before. But that number no longer is necessarily the same as the number of bytes in the string (there may be more bytes than characters). The other such functions include &lt;code&gt;chop()&lt;/code&gt;, &lt;code&gt;chomp()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;pos()&lt;/code&gt;, &lt;code&gt;index()&lt;/code&gt;, &lt;code&gt;rindex()&lt;/code&gt;, &lt;code&gt;sort()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, and &lt;code&gt;write()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93394b81d59344078a9850ad4f758f0f59ea42a4" translate="yes" xml:space="preserve">
          <source>String holding augmented version of second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c329814ec2d3d4971e2511c74b3273f40003742e" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest =
&quot;C:\U$name.$ext&quot;&lt;/code&gt; , may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="translated">如果伪造的 &lt;code&gt;LC_CTYPE&lt;/code&gt; 大小写映射表有效，则带有大小写映射的字符串插值（例如 &lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt; ）可能会产生危险的结果。</target>
        </trans-unit>
        <trans-unit id="cd79a2810365d4fde650c3f3ecb48c64b7bd3d40" translate="yes" xml:space="preserve">
          <source>String interpolation with case-mapping, as in, say, &lt;code&gt;$dest = &quot;C:\U$name.$ext&quot;&lt;/code&gt;, may produce dangerous results if a bogus &lt;code&gt;LC_CTYPE&lt;/code&gt; case-mapping table is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6780b9a46b265648d17e144b69c48ee74770992" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; ). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt; for a list.</source>
          <target state="translated">字符串文字通常用单引号或双引号分隔。它们的工作方式与标准Unix Shell中的引号很像：双引号字符串文字受反斜杠和变量替换的约束；单引号字符串不是（ &lt;code&gt;\'&lt;/code&gt; 和 &lt;code&gt;\\&lt;/code&gt; 除外）。通常的C样式反斜杠规则适用于制作字符，例如换行符，制表符等，以及一些更奇特的形式。有关列表，请参见&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlop&lt;/a&gt;中的Quote和类似Quote的运算符。</target>
        </trans-unit>
        <trans-unit id="13732576251fc8d08b8cf385b7308ea1c12b8efc" translate="yes" xml:space="preserve">
          <source>String literals are usually delimited by either single or double quotes. They work much like quotes in the standard Unix shells: double-quoted string literals are subject to backslash and variable substitution; single-quoted strings are not (except for &lt;code&gt;\'&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;). The usual C-style backslash rules apply for making characters such as newline, tab, etc., as well as some more exotic forms. See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt; for a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0fe980f60efc7c1f918b95be4503588f28be99" translate="yes" xml:space="preserve">
          <source>String needing checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3051b99c9691d2719f0563e333076fae287e689" translate="yes" xml:space="preserve">
          <source>String needing escaping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b011a78c96a9c16cf6436848fa3f565de97986a2" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt; . Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="translated">传递给xsubpp的选项字符串。这可能包括 &lt;code&gt;-C++&lt;/code&gt; 或 &lt;code&gt;-extern&lt;/code&gt; 。不要在此处包括类型映射。为此，存在TYPEMAP参数。</target>
        </trans-unit>
        <trans-unit id="01cf92ed42a8c75a1838e0a5762b33f6a2b55111" translate="yes" xml:space="preserve">
          <source>String of options to pass to xsubpp. This might include &lt;code&gt;-C++&lt;/code&gt; or &lt;code&gt;-extern&lt;/code&gt;. Do not include typemaps here; the TYPEMAP parameter exists for that purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fec62342425ec8f81ce629d9250491168e3f930" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt; 's case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="translated">将字符串重载对象&lt;b&gt;作为字符串&lt;/b&gt;进行比较（或在 &lt;code&gt;cmp_ok()&lt;/code&gt; 的情况下，将字符串或数字视作比较op的合适对象）。这样可以防止Test :: More穿透对象的界面，从而实现更好的黑盒测试。因此，如果函数开始返回重载对象而不是裸字符串，则您的测试将不会注意到差异。很好</target>
        </trans-unit>
        <trans-unit id="fa1a43b0163b121a327b4a58480c5d680c5b9558" translate="yes" xml:space="preserve">
          <source>String overloaded objects are compared &lt;b&gt;as strings&lt;/b&gt; (or in &lt;code&gt;cmp_ok()&lt;/code&gt;'s case, strings or numbers as appropriate to the comparison op). This prevents Test::More from piercing an object's interface allowing better blackbox testing. So if a function starts returning overloaded objects instead of bare strings your tests won't notice the difference. This is good.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00ebea06538bbe227ded196b24216fa175546f" translate="yes" xml:space="preserve">
          <source>String that will be included in the compiler call command line between the arguments INC and OPTIMIZE.</source>
          <target state="translated">将包含在编译器调用命令行中参数INC和OPTIMIZE之间的字符串。</target>
        </trans-unit>
        <trans-unit id="6e526f1a740ace9291b3849106bb71fe9922d6d7" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">字符串到（长）整数的转换。返回解析的数字和字符串的未解析部分中的字符数。真正符合POSIX的系统设置 &lt;code&gt;$!&lt;/code&gt; （ &lt;code&gt;$ERRNO&lt;/code&gt; ）表示翻译错误，因此请清除 &lt;code&gt;$!&lt;/code&gt; 在调用 &lt;code&gt;strtol&lt;/code&gt; 之前。但是，非POSIX系统可能不会检查溢出，因此永远不会设置 &lt;code&gt;$!&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="1e3afd2c721e94e17632288572aff18f68920d41" translate="yes" xml:space="preserve">
          <source>String to (long) integer translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtol&lt;/code&gt;. However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ad43047bd965bdc4d07f5ce2456ad0a02b96c7" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt; ) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt; . However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">字符串以双重翻译。返回解析的数字和字符串的未解析部分中的字符数。真正符合POSIX的系统设置 &lt;code&gt;$!&lt;/code&gt; （ &lt;code&gt;$ERRNO&lt;/code&gt; ）表示翻译错误，因此请清除 &lt;code&gt;$!&lt;/code&gt; 在调用 &lt;code&gt;strtod&lt;/code&gt; 之前。但是，非POSIX系统可能不会检查溢出，因此永远不会设置 &lt;code&gt;$!&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="d8676f880462f433f166d907d612c3e8919af6de" translate="yes" xml:space="preserve">
          <source>String to double translation. Returns the parsed number and the number of characters in the unparsed portion of the string. Truly POSIX-compliant systems set &lt;code&gt;$!&lt;/code&gt; (&lt;code&gt;$ERRNO&lt;/code&gt;) to indicate a translation error, so clear &lt;code&gt;$!&lt;/code&gt; before calling &lt;code&gt;strtod&lt;/code&gt;. However, non-POSIX systems may not check for overflow, and therefore will never set &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45f0eaf01673564e0319c5f3bfbb5d8942bb1f18" translate="yes" xml:space="preserve">
          <source>String to prepend to the &lt;code&gt;file&lt;/code&gt; field of the resulting output. This defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e6cc14bde5be0fa13f9402d856fc2a265b21a7" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;&quot;strtol&quot;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abcfc7dcb04cc4aa0bcda4543317ca564702847" translate="yes" xml:space="preserve">
          <source>String to unsigned (long) integer translation. &lt;code&gt;strtoul()&lt;/code&gt; is identical to &lt;code&gt;strtol()&lt;/code&gt; except that &lt;code&gt;strtoul()&lt;/code&gt; only parses unsigned integers. See &lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt; for details.</source>
          <target state="translated">字符串到无符号（长整数）转换。 &lt;code&gt;strtoul()&lt;/code&gt; 与 &lt;code&gt;strtol()&lt;/code&gt; 相同，除了 &lt;code&gt;strtoul()&lt;/code&gt; 仅解析无符号整数。有关详细信息，请参见&lt;a href=&quot;#strtol&quot;&gt;strtol&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ad6f48bf54709b2ba69a1fce32b7638601bfac7" translate="yes" xml:space="preserve">
          <source>String transformation. Returns the transformed string.</source>
          <target state="translated">字符串转换。返回转换后的字符串。</target>
        </trans-unit>
        <trans-unit id="3093f7beb97882dcb9a98d3b5be7d4560e5f5ef4" translate="yes" xml:space="preserve">
          <source>String, numeric, boolean, and regexp conversions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095d3b7d7b51ca9267c55a71d96ee740ce9ed714" translate="yes" xml:space="preserve">
          <source>String-To-Number Conversions</source>
          <target state="translated">字符串到数字的转换</target>
        </trans-unit>
        <trans-unit id="5942152bba6334b38f5af4b68fa787f8c4338bf1" translate="yes" xml:space="preserve">
          <source>String.</source>
          <target state="translated">String.</target>
        </trans-unit>
        <trans-unit id="89f0c9a299c3800ad98959c29c190d1bc9de23ac" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">串。任意字符序列。参数以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头是有效的。</target>
        </trans-unit>
        <trans-unit id="81f30cf5068f2f28c67e584c10005d36bbd46507" translate="yes" xml:space="preserve">
          <source>String. An arbitrary sequence of characters. It is valid for the argument to start with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6805d3a9d242376321929e78e5ba39e0634fbb9" translate="yes" xml:space="preserve">
          <source>Stringification</source>
          <target state="translated">Stringification</target>
        </trans-unit>
        <trans-unit id="fafc0f2cb3777e3c850edce9bbb0624fb76d8e93" translate="yes" xml:space="preserve">
          <source>Stringification also destroys arrays.</source>
          <target state="translated">串化也会破坏数组。</target>
        </trans-unit>
        <trans-unit id="a96e53fa801a030d61d0b0afb131453e4a3a7511" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">字符串化的perl数据结构，适用于打印和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22b2c8519d7e0bf7d3dd8b66c9c7ae4d2bf2a17f" translate="yes" xml:space="preserve">
          <source>Stringified perl data structures, suitable for both printing and &lt;code&gt;eval&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bad8926562843b707945e86b277e1f637dc69d2" translate="yes" xml:space="preserve">
          <source>Stringify dumps the data inside the object.</source>
          <target state="translated">Stringify将数据转储到对象内部。</target>
        </trans-unit>
        <trans-unit id="242a6a36753d3e416e5262c8b767349bc289b912" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;. These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cca40b8e6ab951533c16fbbdd8e8eeb9f0e6f8" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 创建的字符串也可以使用逻辑运算符进行操作 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。当两个操作数均为字符串时，这些运算符将假定需要进行位向量运算。请参见&lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;perlop中的按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc0a2fc8d4082ea8e735316dde8d1811abffaf90" translate="yes" xml:space="preserve">
          <source>Strings created with &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; can also be manipulated with the logical operators &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; . These operators will assume a bit vector operation is desired when both operands are strings. See &lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;Bitwise String Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 创建的字符串也可以使用逻辑运算符进行操作 &lt;code&gt;|&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; 。当两个操作数均为字符串时，这些运算符将假定需要进行位向量运算。请参见&lt;a href=&quot;../perlop#Bitwise-String-Operators&quot;&gt;perlop中的按位字符串运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f7e8a6f87a8a42268a64c6a11af8887059d5680" translate="yes" xml:space="preserve">
          <source>Strings of multiple sub- and superscripts are not recognized as numbers. You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &lt;code&gt;num&lt;/code&gt; on the result.</source>
          <target state="translated">多个下标和上标的字符串不能识别为数字。您可以使用Unicode :: Normalize中的任一兼容性分解将其更改为数字，然后对结果调用 &lt;code&gt;num&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe482813a109ae5d2d22da9c6e84cc6ce253ee7f" translate="yes" xml:space="preserve">
          <source>Strings with code points over 0xFF may not be mapped into in-memory file handles</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaa3eb6eac6d4efb6574a9ba9018939acd1f8cf" translate="yes" xml:space="preserve">
          <source>Strings--including hash keys--and regular expression patterns may contain characters that have ordinal values larger than 255.</source>
          <target state="translated">字符串--包括哈希键--和正则表达式模式可能包含序数值大于255的字符。</target>
        </trans-unit>
        <trans-unit id="d6348b5c86af8ba2c83c3a187e28bfcf9f1d038b" translate="yes" xml:space="preserve">
          <source>Stripping Perl Binaries on Cygwin</source>
          <target state="translated">在Cygwin上剥离Perl二进制文件</target>
        </trans-unit>
        <trans-unit id="f9141f854e0e233503d419a0cf18d9153715c039" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and fully-featured with a long development history and a large community and addon ecosystem. It is excellent for large and complex applications, where you have full control over the server.</source>
          <target state="translated">强大的面向对象,功能齐全,具有悠久的开发历史和庞大的社区和插件生态系统。它非常适合大型复杂的应用,你可以完全控制服务器。</target>
        </trans-unit>
        <trans-unit id="0a7ad50fa5faede1ac1a8e9d617b83a136f3b36c" translate="yes" xml:space="preserve">
          <source>Strongly object-oriented and minimal, built for speed and intended as a toolkit for building micro web apps, custom frameworks or for tieing together existing Plack-compatible web applications with one central dispatcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92faa1dc48e3fe73a6fc4858913998fc576077e6" translate="yes" xml:space="preserve">
          <source>Strtod</source>
          <target state="translated">Strtod</target>
        </trans-unit>
        <trans-unit id="2bb3001dd42d6db227fc38ef7fd440ba6f9787f9" translate="yes" xml:space="preserve">
          <source>Strtol</source>
          <target state="translated">Strtol</target>
        </trans-unit>
        <trans-unit id="aaac07ac9b1f9026b0065ac193b055defc924b2e" translate="yes" xml:space="preserve">
          <source>Strtoul</source>
          <target state="translated">Strtoul</target>
        </trans-unit>
        <trans-unit id="4e5f4595501ae7d455e886e191bc02eb4a97eb9d" translate="yes" xml:space="preserve">
          <source>StructCopy</source>
          <target state="translated">StructCopy</target>
        </trans-unit>
        <trans-unit id="f23a884e110f1886cdc16e896ca93598233740f9" translate="yes" xml:space="preserve">
          <source>Structs are required to be aligned to the maximum alignment required by the fields - which for native types is for usually equivalent to sizeof() of the field</source>
          <target state="translated">结构需要按照字段所要求的最大对齐方式进行对齐--对于本地类型来说,这通常相当于字段的sizeof()。</target>
        </trans-unit>
        <trans-unit id="eb761c94903285d6515bd20e9cd52538249ae83b" translate="yes" xml:space="preserve">
          <source>Structure of a Regexp Program</source>
          <target state="translated">Regexp程序的结构</target>
        </trans-unit>
        <trans-unit id="a5c0ab1b864f9236f0a013c0c90f92ca429edfd8" translate="yes" xml:space="preserve">
          <source>Structure your modules so they are all located under</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd40698b4bb94e939846994c9f9741e198f30bc1" translate="yes" xml:space="preserve">
          <source>Structured data retrieval of perl -V output</source>
          <target state="translated">perl -V输出的结构化数据检索。</target>
        </trans-unit>
        <trans-unit id="3e4953dd11e72439867b2ad528b4c6dad15a7661" translate="yes" xml:space="preserve">
          <source>Stub found while resolving method &quot;%s&quot; overloading &quot;%s&quot; in package &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ce54f7f99cf2cca6626a2de77f397b8065d514" translate="yes" xml:space="preserve">
          <source>Stub that provides thread hook for perl_destruct when there are no threads.</source>
          <target state="translated">当没有线程时,为perl_destruct提供线程钩子的存根。</target>
        </trans-unit>
        <trans-unit id="d8d7cb9c0bd0e5d2e8d74ffc3881bd4b4fc1400b" translate="yes" xml:space="preserve">
          <source>Stubs for Deleted Documents</source>
          <target state="translated">已删除文件的存根</target>
        </trans-unit>
        <trans-unit id="4d7dabe926bb346f9396e40dca4282529b230cab" translate="yes" xml:space="preserve">
          <source>Stuff here is really low-priority to optimize, since it is far better to implement the operation in the low-level math library directly, possible even using a call to the native lib.</source>
          <target state="translated">这里的东西真的是低优先级的优化,因为直接在低级数学库中实现操作要好得多,甚至可以使用对原生库的调用。</target>
        </trans-unit>
        <trans-unit id="2869e1f287c823d9d113fb739c0f867918c01e7c" translate="yes" xml:space="preserve">
          <source>Stuffit Expander</source>
          <target state="translated">Stuffit扩展器</target>
        </trans-unit>
        <trans-unit id="99a0efc6cfd85d8ff2732a6718140f822cb90472" translate="yes" xml:space="preserve">
          <source>Style</source>
          <target state="translated">Style</target>
        </trans-unit>
        <trans-unit id="454122721f6b63e2ec36cf3779d6bbadd2e22140" translate="yes" xml:space="preserve">
          <source>Sub::Util</source>
          <target state="translated">Sub::Util</target>
        </trans-unit>
        <trans-unit id="200e883b1bf91bd7e7b1892b6781abbb8731b040" translate="yes" xml:space="preserve">
          <source>Sub::Util - A selection of utility subroutines for subs and CODE references</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4fae33d407351a21e057015a8cfce97b1d1d2a" translate="yes" xml:space="preserve">
          <source>Subclass</source>
          <target state="translated">Subclass</target>
        </trans-unit>
        <trans-unit id="1a337fcb31e5829e1a600e170299e1eed7692c3f" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e337d12e7f0f9db812cc8b4bb46be2d64cb670" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a598fbe728e9996509df163e945962ae7a4ffed0" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;TAP::Parser::ResultFactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873c1d3b114c3c8ca9fa8263d71c270acec87256" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt; and customize your parser by setting the &lt;code&gt;grammar_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">子类&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammar&lt;/a&gt;并通过设置 &lt;code&gt;grammar_class&lt;/code&gt; 参数来自定义解析器。有关更多详细信息，请参见&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a88a43bb409ce5ce1ef29fd247b1a667d1a95af9" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; and register your new result type/class with the default &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt;.</source>
          <target state="translated">子类&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result，&lt;/a&gt;并使用默认的&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt;注册新的结果类型/类。</target>
        </trans-unit>
        <trans-unit id="b9c1095f48c3aca9e5b044be2e9f7d4aebd28ac4" translate="yes" xml:space="preserve">
          <source>Subclass &lt;a href=&quot;parser/resultfactory&quot;&gt;TAP::Parser::ResultFactory&lt;/a&gt; itself and implement your own &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; creation logic. Then you'll need to customize the class used by your parser by setting the &lt;code&gt;result_factory_class&lt;/code&gt; parameter. See &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; for more details.</source>
          <target state="translated">子类&lt;a href=&quot;parser/resultfactory&quot;&gt;TAP :: Parser :: ResultFactory&lt;/a&gt;本身，并实现自己的&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;创建逻辑。然后，您需要通过设置 &lt;code&gt;result_factory_class&lt;/code&gt; 参数来自定义解析器使用的类。有关更多详细信息，请参见&lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e73f017d1b2756188610b88957a8f09f27806cab" translate="yes" xml:space="preserve">
          <source>Subclass implementations of this method may wish to invoke the &lt;b&gt;nested()&lt;/b&gt; method of &lt;code&gt;$pod_seq&lt;/code&gt; to see if it is nested inside some other interior-sequence (and if so, which kind).</source>
          <target state="translated">此方法的子类实现可能希望调用 &lt;code&gt;$pod_seq&lt;/code&gt; 的&lt;b&gt;nested（）&lt;/b&gt;方法以查看其是否嵌套在其他内部序列中（如果是，则嵌套在哪种内部序列中）。</target>
        </trans-unit>
        <trans-unit id="64bde9a828bba22dd63e418d48e0703d9c34544f" translate="yes" xml:space="preserve">
          <source>Subclass it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206092a8f1bccf21dc1a96fb2aecc7852ff2c2b3" translate="yes" xml:space="preserve">
          <source>Subclass off of ExtUtils::MM_Any</source>
          <target state="translated">从ExtUtils::MM_Any的子类。</target>
        </trans-unit>
        <trans-unit id="c726c3176746b961b1da7788108e104c74c302c2" translate="yes" xml:space="preserve">
          <source>Subclasses will add methods, and will also inherit these methods:</source>
          <target state="translated">子类会增加方法,也会继承这些方法。</target>
        </trans-unit>
        <trans-unit id="f3e2eeeafa90ba07510736c79555f75b3f2683f2" translate="yes" xml:space="preserve">
          <source>Subclassing Math::BigInt</source>
          <target state="translated">子类Math::BigInt</target>
        </trans-unit>
        <trans-unit id="7a1cf3add6a7e4a2dd149344bc26ee4f53a43b6c" translate="yes" xml:space="preserve">
          <source>Subject to include with the message. You will be prompted if you don't supply one on the command line.</source>
          <target state="translated">要包含在信息中的主题,如果你不在命令行中提供一个主题,你会被提示。如果你不在命令行中提供一个主题,你会被提示。</target>
        </trans-unit>
        <trans-unit id="514a69c7cb010ea0bf9f49cd1b452991b8b8c5f5" translate="yes" xml:space="preserve">
          <source>Subject to include with the report. You will be prompted if you don't supply one on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="403bc0e6094ca81cdc2ca6f64a247c639431d231" translate="yes" xml:space="preserve">
          <source>Submit all messages/phrases/etc. to translators.</source>
          <target state="translated">将所有信息/短语/等提交给翻译人员。</target>
        </trans-unit>
        <trans-unit id="0d2e3edd3ad42a3c825fac56543a9ba6ed29f070" translate="yes" xml:space="preserve">
          <source>Submit as command file on close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740057b8189ca179a92f1c0babad5e8319eb10b8" translate="yes" xml:space="preserve">
          <source>Submitting patches</source>
          <target state="translated">提交补丁</target>
        </trans-unit>
        <trans-unit id="c9a1540fce9398b2881e3e765d38647cec10bf30" translate="yes" xml:space="preserve">
          <source>Subprocesses started with open use a minimal popen() routine and therefore they do not return pids usable with waitpid etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5792d60bcabce4e99c77d69a1b0a93002b6b2c75" translate="yes" xml:space="preserve">
          <source>Subroutine &quot;%s&quot; will not stay shared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800547d773f13c68fa4495c8910007398137cdb8" translate="yes" xml:space="preserve">
          <source>Subroutine &quot;&amp;amp;%s&quot; is not available</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29109439b3ee3e3ad4d67ea3d37066e59b15da" translate="yes" xml:space="preserve">
          <source>Subroutine %s redefined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ef2c6312acb93997fc9533ac9d5fab3c547483" translate="yes" xml:space="preserve">
          <source>Subroutine Attributes</source>
          <target state="translated">子程序属性</target>
        </trans-unit>
        <trans-unit id="e505b9988266048dcf61fcc7b04326e41ac00577" translate="yes" xml:space="preserve">
          <source>Subroutine References as Methods</source>
          <target state="translated">子程序引用作为方法</target>
        </trans-unit>
        <trans-unit id="e0c81de6298b00147539fb1fd776b06104ff3a1b" translate="yes" xml:space="preserve">
          <source>Subroutine Stubs</source>
          <target state="translated">子程序存根</target>
        </trans-unit>
        <trans-unit id="a522560a592f55d1244a49a61ccbec20e0f1bdb4" translate="yes" xml:space="preserve">
          <source>Subroutine attributes must come before the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17d78c0715b7cc40ffcc13047f5c03c7076ce7e" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2c6bab1119398dcc6fbf96d66f3ef433c36e56" translate="yes" xml:space="preserve">
          <source>Subroutine call to a named capture group. Equivalent to &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt;.</source>
          <target state="translated">对命名捕获组的子例程调用。等效于 &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2db8d18b231e5da42e906ca30c0b2a5d6ae6ff13" translate="yes" xml:space="preserve">
          <source>Subroutine calls and lookups of individual array elements arise often enough that it gets cumbersome to use method 2. As a form of syntactic sugar, the examples for method 2 may be written:</source>
          <target state="translated">子程序的调用和单个数组元素的查找经常出现,以至于使用方法2会很麻烦。作为一种语法糖的形式,方法2的例子可以写成:</target>
        </trans-unit>
        <trans-unit id="2a4b563566baea0b906bb1fd2aafe77f5b8f15d9" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="translated">子例程声明和定义可以选择具有与之关联的属性列表。（ &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明也可能是变量，但请参见下面的警告。）Perl通过将有关调用站点和要声明的事物的一些信息以及属性列表传递到此模块来处理这些声明。特别地，上面的第一个示例等效于以下示例：</target>
        </trans-unit>
        <trans-unit id="1073836739fed365f30def4568eabbaf570bbb96" translate="yes" xml:space="preserve">
          <source>Subroutine declarations and definitions may optionally have attribute lists associated with them. (Variable &lt;code&gt;my&lt;/code&gt; declarations also may, but see the warning below.) Perl handles these declarations by passing some information about the call site and the thing being declared along with the attribute list to this module. In particular, the first example above is equivalent to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1033729ecd127028ccf3e2aa66d4fd8f486f7da3" translate="yes" xml:space="preserve">
          <source>Subroutine defined.</source>
          <target state="translated">定义了子程序。</target>
        </trans-unit>
        <trans-unit id="d9339f9cd00dee3efa9f7f46ee1ed9f5d6e327f1" translate="yes" xml:space="preserve">
          <source>Subroutine definitions (and declarations, for that matter) need not necessarily be situated in the package whose symbol table they occupy. You can define a subroutine outside its package by explicitly qualifying the name of the subroutine:</source>
          <target state="translated">子程序的定义(以及声明)不一定要位于它们所占用的符号表的包中。你可以通过明确限定子程序的名称,在其包之外定义一个子程序。</target>
        </trans-unit>
        <trans-unit id="e9df428b17a930b0722f07795c93f287fd3afdec" translate="yes" xml:space="preserve">
          <source>Subroutine or method call.</source>
          <target state="translated">子程序或方法调用。</target>
        </trans-unit>
        <trans-unit id="69c680037a9b95df2742cb6788f31ebc24c5c06b" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through &lt;a href=&quot;perlvar#%40INC&quot;&gt;&lt;code&gt;@INC&lt;/code&gt;&lt;/a&gt; and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e848b12ba1771594d7f90740383f312abe841d15" translate="yes" xml:space="preserve">
          <source>Subroutine references are the simplest case. When the inclusion system walks through @INC and encounters a subroutine, this subroutine gets called with two parameters, the first a reference to itself, and the second the name of the file to be included (e.g., &quot;</source>
          <target state="translated">子程序引用是最简单的情况。当包含系统走过@INC,遇到一个子程序时,这个子程序会被调用,有两个参数,第一个是对自身的引用,第二个是要包含的文件名(例如,&quot;</target>
        </trans-unit>
        <trans-unit id="b392dcb7d8c01390614814ebacd1c58485fdcd21" translate="yes" xml:space="preserve">
          <source>Subroutines</source>
          <target state="translated">Subroutines</target>
        </trans-unit>
        <trans-unit id="3a9c9397dc48823cce2af70d8aec97a4fb827cbd" translate="yes" xml:space="preserve">
          <source>Subroutines can also return values:</source>
          <target state="translated">子程序也可以返回值。</target>
        </trans-unit>
        <trans-unit id="7cbe2412d3dda1f0b9872899595b0870846f911a" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="translated">子例程声明也可以使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句加载，也可以 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句加载和导入到名称空间中。有关详细信息，请参见&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c9413cb94cc1864a97b409cf3b7e7117c8f53d17" translate="yes" xml:space="preserve">
          <source>Subroutines declarations can also be loaded up with the &lt;code&gt;require&lt;/code&gt; statement or both loaded and imported into your namespace with a &lt;code&gt;use&lt;/code&gt; statement. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b365b15ba275665842a040de4aa6dff221b841" translate="yes" xml:space="preserve">
          <source>Subroutines in multiple packages within the same file are supported - but you should note that this requires exporting the &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; to every package which requires it. This is done automatically by the &lt;b&gt;SelfLoader&lt;/b&gt; when it first loads the subs into the cache, but you should really specify it in the initialization before the &lt;code&gt;__DATA__&lt;/code&gt; by putting a 'use SelfLoader' statement in each package.</source>
          <target state="translated">支持同一文件中多个包中的子例程-但是您应注意，这需要将 &lt;code&gt;SelfLoader::AUTOLOAD&lt;/code&gt; 导出到每个需要它的包中。这是由&lt;b&gt;SelfLoader&lt;/b&gt;在第一次将子项加载到缓存时自动完成的，但是您实际上应该在 &lt;code&gt;__DATA__&lt;/code&gt; 之前的初始化中通过在每个包中放置'use SelfLoader'语句来指定它。</target>
        </trans-unit>
        <trans-unit id="908bce63fd3bee1510a99f3549ad888c8938e948" translate="yes" xml:space="preserve">
          <source>Subroutines may be called recursively. If a subroutine is called using the &lt;code&gt;&amp;amp;&lt;/code&gt; form, the argument list is optional, and if omitted, no &lt;code&gt;@_&lt;/code&gt; array is set up for the subroutine: the &lt;code&gt;@_&lt;/code&gt; array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid.</source>
          <target state="translated">子例程可以递归调用。如果一个子程序使用被叫 &lt;code&gt;&amp;amp;&lt;/code&gt; 形式，参数列表是可选的，如果省略，没有 &lt;code&gt;@_&lt;/code&gt; 阵列设置为子程序：在 &lt;code&gt;@_&lt;/code&gt; 数组在调用的时候是可见的，而不是子程序。这是新用户可能希望避免的效率机制。</target>
        </trans-unit>
        <trans-unit id="cda2b08c81beb1e8e27be40c69e142c7b306247c" translate="yes" xml:space="preserve">
          <source>Subroutines used with ExtUtils::ParseXS</source>
          <target state="translated">与ExtUtils::ParseXS一起使用的子程序。</target>
        </trans-unit>
        <trans-unit id="3f753412893b86e74de31ef62203854e630f7671" translate="yes" xml:space="preserve">
          <source>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines whose name start with a left parenthesis are also reserved the same way. The following is a list of some subroutines that currently do special, pre-defined things.</source>
          <target state="translated">名称全部为大写的子程序是保留给Perl核心的,名称全部为小写的模块也是如此。全大写的子程序是一个松散的惯例,意味着它将被运行时系统本身间接调用,通常是由于一个触发事件。名字以左括号开头的子程序也是这样保留的。下面是一些目前做特殊的、预先定义的子程序的列表。</target>
        </trans-unit>
        <trans-unit id="bd995cb059355e488a61a605eadaa870990fb34e" translate="yes" xml:space="preserve">
          <source>Subscribe to perl5-porters, follow the patches and try and understand them; don't be afraid to ask if there's a portion you're not clear on - who knows, you may unearth a bug in the patch...</source>
          <target state="translated">订阅 perl5-porters,关注补丁并试着去理解它们;如果有不清楚的地方,不要害怕去问--谁知道呢,你可能会在补丁中发现一个 bug......</target>
        </trans-unit>
        <trans-unit id="93d9b06a27141e76f1c5da56e07d3f537a49d789" translate="yes" xml:space="preserve">
          <source>Subscribe/Unsubscribe</source>
          <target state="translated">Subscribe/Unsubscribe</target>
        </trans-unit>
        <trans-unit id="a9be04fdf20dd61cb8df7236630151f2b739230f" translate="yes" xml:space="preserve">
          <source>Subscribers to perl5-porters (the porters themselves) come in several flavours. Some are quiet curious lurkers, who rarely pitch in and instead watch the ongoing development to ensure they're forewarned of new changes or features in Perl. Some are representatives of vendors, who are there to make sure that Perl continues to compile and work on their platforms. Some patch any reported bug that they know how to fix, some are actively patching their pet area (threads, Win32, the regexp -engine), while others seem to do nothing but complain. In other words, it's your usual mix of technical people.</source>
          <target state="translated">perl5-porters 的订阅者 (porters 本身)有好几种口味。有些人是安静的好奇爱好者,他们很少参与,而是观察正在进行的开发工作,以确保他们能够预先了解 Perl 的新变化或功能。有些人是供应商的代表,他们的目的是确保 Perl 能够继续在他们的平台上编译和工作。有些人给他们知道如何修复的任何报告的bug打补丁,有些人积极地给他们的宠物领域打补丁(线程、Win32、regexp -engine),而有些人似乎除了抱怨什么也不做。换句话说,这就是通常的技术人员的组合。</target>
        </trans-unit>
        <trans-unit id="4ce7140689363704a8ba85b5261797d063cdadf8" translate="yes" xml:space="preserve">
          <source>Subscripts</source>
          <target state="translated">Subscripts</target>
        </trans-unit>
        <trans-unit id="6555f256c06dba45d12ae5b008404f7426193f59" translate="yes" xml:space="preserve">
          <source>Substantial contributions by Sean Burke &amp;lt;sburke@cpan.org&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972581919796c696d3887a640cd0abc4a9d6fe2f" translate="yes" xml:space="preserve">
          <source>Substitute &lt;code&gt;mmk&lt;/code&gt; for &lt;code&gt;mms&lt;/code&gt; above if you're using MMK.</source>
          <target state="translated">如果您使用的是MMK，请将 &lt;code&gt;mmk&lt;/code&gt; 替换为以上的 &lt;code&gt;mms&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbc00d62cb7997a305b625c77616bced61d7a767" translate="yes" xml:space="preserve">
          <source>Substitution loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014d5a9e6f1c5bae7a50cda20695fb756eee0cc0" translate="yes" xml:space="preserve">
          <source>Substitution of &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; block with:</source>
          <target state="translated">将 &lt;code&gt;BEGIN { add_100() }&lt;/code&gt; 块替换为：</target>
        </trans-unit>
        <trans-unit id="6aa080c65a0705bf8b85bd864e5d55d3b8ce1d38" translate="yes" xml:space="preserve">
          <source>Substitution pattern not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618ea16f2fe1c5efd77bdfb863d15430e39ab7d9" translate="yes" xml:space="preserve">
          <source>Substitution replacement not terminated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821f56dfe7408535081734d464b6578d0a9340e7" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in</source>
          <target state="translated">中所述的特定替换修饰剂</target>
        </trans-unit>
        <trans-unit id="748640ee60ffaf08dbf9cf2300dfb0ab8b09456a" translate="yes" xml:space="preserve">
          <source>Substitution-specific modifiers described in &lt;a href=&quot;perlop#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;&quot;s/PATTERN/REPLACEMENT/msixpodualngcer&quot; in perlop&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85608dfc0000ff615c1dec302e3be9c2df7837d" translate="yes" xml:space="preserve">
          <source>Substitutions are made with $col and $row in the output string with the following sprintf() line formats:</source>
          <target state="translated">在输出字符串中用$col和$row进行替换,格式如下printf()行。</target>
        </trans-unit>
        <trans-unit id="e9a34939ee76bec97fd549a9a6b322c326e9dbba" translate="yes" xml:space="preserve">
          <source>Substring data about strings that must appear in the final match. This is currently only used internally by Perl's engine, but might be used in the future for all engines for optimisations.</source>
          <target state="translated">关于最终匹配中必须出现的字符串的子串数据。目前只有Perl引擎内部使用,但将来可能会用于所有引擎的优化。</target>
        </trans-unit>
        <trans-unit id="16f77c4705ec7e98c86e25e92de290785b8aa469" translate="yes" xml:space="preserve">
          <source>Subtest implementation is more sane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9292ec7a4b6c6d463da3dc2a73e0168876180e17" translate="yes" xml:space="preserve">
          <source>Subtest indentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288c9b632547ccefc043ed0814e269fb40d46750" translate="yes" xml:space="preserve">
          <source>Subtests make use of this hub to route events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de3a6f2fafae521ea8d2aedc747771ba7ff68a0" translate="yes" xml:space="preserve">
          <source>Subtests were released in Test::More 0.94, which came with Perl 5.12.0. Subtests did not implicitly call &lt;code&gt;done_testing()&lt;/code&gt; until 0.96; the first Perl with that fix was Perl 5.14.0 with 0.98.</source>
          <target state="translated">子测试在Test :: More 0.94中发布，它随Perl 5.12.0一起提供。子 &lt;code&gt;done_testing()&lt;/code&gt; 直到0.96 才隐式调用done_testing（）。具有此修复程序的第一个Perl是带有0.98的Perl 5.14.0。</target>
        </trans-unit>
        <trans-unit id="da70c837fb111755e855b0a137562f112a4e55e2" translate="yes" xml:space="preserve">
          <source>Subtle interdependencies between test programs can mask problems - for example an earlier test may neglect to remove a temporary file that affects the behaviour of a later test. To find this kind of problem I use the --shuffle and --reverse options to run my tests in random or reversed order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a773e71238655167a41521fa50857f3f27293a6" translate="yes" xml:space="preserve">
          <source>Subtleties of this behavior may be platform-dependent and may change in the future.</source>
          <target state="translated">这种行为的细微之处可能会依赖于平台,未来可能会改变。</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="532674971418925bf881a12b4532f1662a1e9a91" translate="yes" xml:space="preserve">
          <source>Subtracts $y from $x and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c757fe97bd3bdc11456c873d4a95f5772e2115" translate="yes" xml:space="preserve">
          <source>Success results contain:</source>
          <target state="translated">成功的结果包含:</target>
        </trans-unit>
        <trans-unit id="f918892a0be28ec22ae2148c6c8b20e089383319" translate="yes" xml:space="preserve">
          <source>Successes</source>
          <target state="translated">Successes</target>
        </trans-unit>
        <trans-unit id="9f13946904481800a60a2508acdf81d63816cbc9" translate="yes" xml:space="preserve">
          <source>Successfully tested means that all &quot;make test&quot; runs finish with a result of 100% OK. All tests were conducted with -Duseshrplib set.</source>
          <target state="translated">成功测试意味着所有的 &quot;make test &quot;运行结果都是100% OK。所有测试都是在-Duseshrplib设置下进行的。</target>
        </trans-unit>
        <trans-unit id="acd9d5af15f64c17e2970ba3b3a2889b142e6fb0" translate="yes" xml:space="preserve">
          <source>Such QP strings can be decoded with:</source>
          <target state="translated">这样的QP字符串可以用以下方法解码。</target>
        </trans-unit>
        <trans-unit id="9bd751ae4548def6edde9b711d0020609ff568b3" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; is the one that matters.</source>
          <target state="translated">由于两个原因，这样的代码不再具有预期的效果。首先，使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 意味着排序算法要等到运行时才能更改，到那时它已为时已晚而没有任何效果。其次， &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 在运行时也被调用，而事实上 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort::current&lt;/a&gt;&lt;/code&gt; 的编译时值很重要。</target>
        </trans-unit>
        <trans-unit id="142ef3d73b12a657e355c82858c85c2cd7a23472" translate="yes" xml:space="preserve">
          <source>Such code no longer has the desired effect, for two reasons. Firstly, the use of &lt;code&gt;eval()&lt;/code&gt; means that the sorting algorithm is not changed until runtime, by which time it's too late to have any effect. Secondly, &lt;code&gt;sort::current&lt;/code&gt; is also called at run-time, when in fact the compile-time value of &lt;code&gt;sort::current&lt;/code&gt; is the one that matters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ef159fceda5830f0aa82ac39ad009b226aeb52" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; ? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="translated">这样的组合可能包含其他选择，从而导致选择问题：如果我们将正则表达式 &lt;code&gt;a|ab&lt;/code&gt; 与 &lt;code&gt;&quot;abc&quot;&lt;/code&gt; 匹配，它将匹配子字符串 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 吗？描述实际匹配哪个子字符串的一种方法是回溯的概念（请参阅&lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;）。但是，此描述太底层了，使您需要考虑特定的实现。</target>
        </trans-unit>
        <trans-unit id="3a0a0250134ad0585c52e578d2c27b8e55bf21c1" translate="yes" xml:space="preserve">
          <source>Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &lt;code&gt;a|ab&lt;/code&gt; against &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, will it match substring &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt;? One way to describe which substring is actually matched is the concept of backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;&quot;Backtracking&quot;&lt;/a&gt;). However, this description is too low-level and makes you think in terms of a particular implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d1b0795c68a81e9549d343de87babe2d5446e2" translate="yes" xml:space="preserve">
          <source>Such commands are explained in the &quot;&lt;a href=&quot;#Formatting-Codes&quot;&gt;Formatting Codes&lt;/a&gt;&quot; section, below.</source>
          <target state="translated">此类命令在下面的&amp;ldquo; &lt;a href=&quot;#Formatting-Codes&quot;&gt;格式代码&lt;/a&gt; &amp;rdquo;部分中进行了说明。</target>
        </trans-unit>
        <trans-unit id="610620ff68fcfedc9e4625433127c1fd73d100c6" translate="yes" xml:space="preserve">
          <source>Such constructs are quite frequently used, both because older versions of Perl had no official &lt;code&gt;switch&lt;/code&gt; statement, and also because the new version described immediately below remains experimental and can sometimes be confusing.</source>
          <target state="translated">之所以会经常使用这样的结构，是因为Perl的旧版本没有正式的 &lt;code&gt;switch&lt;/code&gt; 语句，也因为下面立即描述的新版本仍处于试验阶段，有时会造成混淆。</target>
        </trans-unit>
        <trans-unit id="ea3348659ce40b97978cb89e7a2d2a3c12e7d561" translate="yes" xml:space="preserve">
          <source>Such dangers are not peculiar to the locale system: any aspect of an application's environment which may be modified maliciously presents similar challenges. Similarly, they are not specific to Perl: any programming language that allows you to write programs that take account of their environment exposes you to these issues.</source>
          <target state="translated">这种危险并不是locale系统所特有的:应用程序环境中任何可能被恶意修改的方面都会带来类似的挑战。同样,它们也不是Perl所特有的:任何允许你编写考虑到环境的程序的编程语言都会让你面临这些问题。</target>
        </trans-unit>
        <trans-unit id="92e64e08c8f255e5e8a21829e9acd359d7cc7e25" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="translated">这样的文字被接受都 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 做一个版本检查。请注意，除非您也使用Socket程序包的inet_aton（）/ inet_ntoa（）例程，否则将v字符串用于IPv4地址是不可移植的。</target>
        </trans-unit>
        <trans-unit id="b3ece4d85f65108445ce8ad183c4acd13b1bae15" translate="yes" xml:space="preserve">
          <source>Such literals are accepted by both &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;use&lt;/code&gt; for doing a version check. Note that using the v-strings for IPv4 addresses is not portable unless you also use the inet_aton()/inet_ntoa() routines of the Socket package.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45d151cfb183e258e5e363109f24149b1db62ae" translate="yes" xml:space="preserve">
          <source>Such modules should</source>
          <target state="translated">这些模块应</target>
        </trans-unit>
        <trans-unit id="7aa5a2112d8e6f60d9221533518e8ad273984dab" translate="yes" xml:space="preserve">
          <source>Such things aside, you can see that a lot can be achieved with a modest amount of code.</source>
          <target state="translated">抛开这样的事情不谈,你可以看到,用少量的代码可以实现很多东西。</target>
        </trans-unit>
        <trans-unit id="3f289da124b245076253fddcae953c824b46fb88" translate="yes" xml:space="preserve">
          <source>Suggestion for disuse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88beb5e8792960b693418a1e821caf3667e2978e" translate="yes" xml:space="preserve">
          <source>Sum of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="625d4a750d30cd6f4ad0513fdf02b0a356847795" translate="yes" xml:space="preserve">
          <source>Summary Results</source>
          <target state="translated">结果摘要</target>
        </trans-unit>
        <trans-unit id="090f5890d90dd32f61ec60eddd99730f85a15bf5" translate="yes" xml:space="preserve">
          <source>Summary about the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d8f92a0739a61061673d891b1afa8db3bbc87d" translate="yes" xml:space="preserve">
          <source>Summary methods</source>
          <target state="translated">简要方法</target>
        </trans-unit>
        <trans-unit id="bbeaa09c87f3637cdf1095b67ab5a263e83c735c" translate="yes" xml:space="preserve">
          <source>Summary of Option Specifications</source>
          <target state="translated">选项规格摘要</target>
        </trans-unit>
        <trans-unit id="90bd8a629095e4d3e067b9ee655f4a7aef77fe44" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and installing the Developer Tools would be good.</source>
          <target state="translated">摘要： &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 并安装开发人员工具会很好。</target>
        </trans-unit>
        <trans-unit id="fac6a1b8f230cdc10fcc15f1e97d9ef7d5b8d095" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt; .</source>
          <target state="translated">摘要： &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; 然后需要 &lt;code&gt;-lbfd&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="667597966182758709a808e416e091ee04e5a076" translate="yes" xml:space="preserve">
          <source>Summary: &lt;code&gt;Configure ... -Dusecbacktrace&lt;/code&gt; and you need &lt;code&gt;-lbfd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4dd97ceb3548f78756cbaa9fdb900f6de48597" translate="yes" xml:space="preserve">
          <source>Summing up, Perl numeric values can store only those numbers which have a finite decimal expansion or a &quot;short&quot; binary expansion.</source>
          <target state="translated">综上所述,Perl数值只能存储那些具有有限十进制扩展或 &quot;短 &quot;二进制扩展的数字。</target>
        </trans-unit>
        <trans-unit id="a30c74d272f700d25fc5ffc72319faf190f9cd38" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of May 2019, the last stable release took place on 2017, and one can buy support contracts for them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2aaceda628f6be2c51aa728019480822a4776e" translate="yes" xml:space="preserve">
          <source>Sun Microsystems has released a port of their Sun Studio compilers for Linux. As of November 2005, only an alpha version has been released. Until a release of these compilers is made, support for compiling Perl with these compiler experimental.</source>
          <target state="translated">Sun Microsystems公司已经发布了他们的Sun Studio编译器的Linux移植版。截至2005年11月,只发布了一个alpha版本。在这些编译器发布之前,支持用这些编译器实验性地编译Perl。</target>
        </trans-unit>
        <trans-unit id="c878825d39958359a72cd8a76c4798d5c63452e1" translate="yes" xml:space="preserve">
          <source>Sun and GNU make</source>
          <target state="translated">太阳与GNU合作</target>
        </trans-unit>
        <trans-unit id="718d79465fef1629218681af768f2453685f48a1" translate="yes" xml:space="preserve">
          <source>Sun's C Compiler</source>
          <target state="translated">Sun公司的C编译器</target>
        </trans-unit>
        <trans-unit id="6195b0f6879010bbee2ff42c95d1331cc047feb8" translate="yes" xml:space="preserve">
          <source>SunOS 4.x</source>
          <target state="translated">SunOS 4.x</target>
        </trans-unit>
        <trans-unit id="0887ccabfd110aa623b91de64a05467ad2ff0b37" translate="yes" xml:space="preserve">
          <source>Supersede.</source>
          <target state="translated">Supersede.</target>
        </trans-unit>
        <trans-unit id="e16d86479fe3fa44742384e85cda27574322cbc3" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;):</source>
          <target state="translated">为sort（）提供一个比较函数（在&lt;a href=&quot;functions/sort&quot;&gt;sort中&lt;/a&gt;描述）：</target>
        </trans-unit>
        <trans-unit id="1abf49bb15ef4ea8e1f725a8e57c7d302079a707" translate="yes" xml:space="preserve">
          <source>Supply a comparison function to sort() (described in &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de415e5d5000869495451db35dc93df656397ea8" translate="yes" xml:space="preserve">
          <source>Supply a password. If this token is present, the auto-login process will supply the specified string if the remote server requires a password as part of the login process.</source>
          <target state="translated">提供一个密码,如果有这个标记,当远程服务器需要密码时,自动登录过程将提供指定的字符串。如果这个标记存在,如果远程服务器需要密码作为登录过程的一部分,自动登录过程将提供指定的字符串。</target>
        </trans-unit>
        <trans-unit id="2b5e575cc764d4329007cce80f84811dda7921d8" translate="yes" xml:space="preserve">
          <source>Supply an additional account password. If this token is present, the auto-login process will supply the specified string if the remote server requires an additional account password.</source>
          <target state="translated">提供一个额外的账户密码。如果存在这个标记,如果远程服务器需要额外的账户密码,自动登录进程将提供指定的字符串。</target>
        </trans-unit>
        <trans-unit id="63bb1d0a1fc152b9571b2b05084b5b7573c0a7dc" translate="yes" xml:space="preserve">
          <source>Supply object methods for I/O handles</source>
          <target state="translated">为I/O句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="e754d6f0995eab7526c2995e6dd29fc5213bbe9f" translate="yes" xml:space="preserve">
          <source>Supply object methods for directory handles</source>
          <target state="translated">为目录句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="9f22ffa5d56d4c5cfa232e27b220356c8959032d" translate="yes" xml:space="preserve">
          <source>Supply object methods for filehandles</source>
          <target state="translated">为filehandles提供对象方法</target>
        </trans-unit>
        <trans-unit id="b2a77c0ef03836a7333e41ce4f0c7055106ac057" translate="yes" xml:space="preserve">
          <source>Supply object methods for pipes</source>
          <target state="translated">为管道提供对象方法</target>
        </trans-unit>
        <trans-unit id="24f8675a681a3fcf0a19ce2f457ac46639a461cc" translate="yes" xml:space="preserve">
          <source>Supply seek based methods for I/O objects</source>
          <target state="translated">为I/O对象提供基于寻求的方法</target>
        </trans-unit>
        <trans-unit id="4577ee52f9d606e12ad2fa9f7ea83ec15081ff52" translate="yes" xml:space="preserve">
          <source>Supplying a count to the</source>
          <target state="translated">提供一个计数给</target>
        </trans-unit>
        <trans-unit id="9256abeb61b0e9c2634b93f868b22e3b6be3e559" translate="yes" xml:space="preserve">
          <source>Support for 64-bit Windows added in 5.8 (ActiveState Corp).</source>
          <target state="translated">在5.8中增加了对64位Windows的支持(ActiveState公司)。</target>
        </trans-unit>
        <trans-unit id="832ef41556695f42d002862c25aa7f6927ea5c9c" translate="yes" xml:space="preserve">
          <source>Support for 64-bit addressing is experimental: some aspects of Perl may be omitted or buggy. Note the messages output by</source>
          <target state="translated">对64位寻址的支持是试验性的:Perl的某些方面可能会被省略或出现错误。请注意由</target>
        </trans-unit>
        <trans-unit id="dfd649a90bcb497a90c270b395e1aca8e9f13d5a" translate="yes" xml:space="preserve">
          <source>Support for Inside-Out Classes</source>
          <target state="translated">对内外班的支持</target>
        </trans-unit>
        <trans-unit id="a6e9ff56bd571fa57e267af64d661fa73e5d1898" translate="yes" xml:space="preserve">
          <source>Support for NO_COLOR was added in Term::ANSIColor 5.01.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74542dacfa191bd88d61863d9855931e106e4c3" translate="yes" xml:space="preserve">
          <source>Support for PERL_OBJECT was added in 5.005 (ActiveState Tool Corp).</source>
          <target state="translated">在5.005中增加了对PERL_OBJECT的支持(ActiveState Tool Corp)。</target>
        </trans-unit>
        <trans-unit id="aa9a9b9bea1d915cddc6e189a212373757505afc" translate="yes" xml:space="preserve">
          <source>Support for calling Test::Builder-&amp;gt;note is minimal. It's implemented as an empty stub, so modules that use it will not crash but the calls are not recorded for testing purposes like the others. Patches welcome.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4152d06f964d8c8500926a55fcc080decb5f3944" translate="yes" xml:space="preserve">
          <source>Support for code 3 (italic) is rare and therefore not mentioned in that table. It is not believed to be fully supported by any of the terminals listed, although it's displayed as green in the Linux console, but it is reportedly supported by urxvt.</source>
          <target state="translated">对代码3(斜体)的支持很少,因此该表中没有提到。虽然在Linux控制台中显示为绿色,但据说urxvt支持它,但据信没有任何一种终端完全支持它。</target>
        </trans-unit>
        <trans-unit id="d13a3104d38bfebd2d8edefc71bb43ed89c25719" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt; , &lt;code&gt;rgb&lt;/code&gt; , and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="translated">Perl 5.17中包含的Term :: ANSIColor 4.00中增加了对颜色16至256（ &lt;code&gt;ansi&lt;/code&gt; ， &lt;code&gt;rgb&lt;/code&gt; 和 &lt;code&gt;grey&lt;/code&gt; ）的支持， &lt;code&gt;:constants256&lt;/code&gt; 导入标记，coloralias（）函数以及对ANSI_COLORS_ALIASES环境变量的支持。 8。</target>
        </trans-unit>
        <trans-unit id="21899951038dc28e07a818ac9d52e61c8083b56f" translate="yes" xml:space="preserve">
          <source>Support for colors 16 through 256 (the &lt;code&gt;ansi&lt;/code&gt;, &lt;code&gt;rgb&lt;/code&gt;, and &lt;code&gt;grey&lt;/code&gt; colors), the &lt;code&gt;:constants256&lt;/code&gt; import tag, the coloralias() function, and support for the ANSI_COLORS_ALIASES environment variable were added in Term::ANSIColor 4.00, included in Perl 5.17.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9d79655477c957d3ded48d250eed51bd3ecf8ff" translate="yes" xml:space="preserve">
          <source>Support for colors 8 through 15 (the &lt;code&gt;bright_&lt;/code&gt; variants) was added in Term::ANSIColor 3.00, included in Perl 5.13.3.</source>
          <target state="translated">Perl 5.13.3中包含的Term :: ANSIColor 3.00中增加了对颜色8至15（ &lt;code&gt;bright_&lt;/code&gt; 变体）的支持。</target>
        </trans-unit>
        <trans-unit id="3520e7db85802558bb1d2a5a7277d73d6dd7678b" translate="yes" xml:space="preserve">
          <source>Support for concurrent interpreters and the fork() emulation was implemented by ActiveState, with funding from Microsoft Corporation.</source>
          <target state="translated">在微软公司的资助下,ActiveState实现了对并发解释器和fork()仿真的支持。</target>
        </trans-unit>
        <trans-unit id="46d9a08c8fe0a5fa65df6f50206b3d6f86276cea" translate="yes" xml:space="preserve">
          <source>Support for dark was added in Term::ANSIColor 1.08, included in Perl 5.8.4.</source>
          <target state="translated">在 Term::ANSIColor 1.08 中增加了对 dark 的支持,包含在 Perl 5.8.4 中。</target>
        </trans-unit>
        <trans-unit id="13c3f3679453dc21cf99ba9668b08821dc7c3536" translate="yes" xml:space="preserve">
          <source>Support for external gzip added by Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemi添加的对外部gzip的支持&amp;lt;</target>
        </trans-unit>
        <trans-unit id="c1d15c06235a8f38ea6479c09486fef84b83b91c" translate="yes" xml:space="preserve">
          <source>Support for fork() emulation was added in 5.6 (ActiveState Tool Corp).</source>
          <target state="translated">在5.6中增加了对fork()仿真的支持(ActiveState Tool Corp)。</target>
        </trans-unit>
        <trans-unit id="4da419edd1ac30a4a7b7cbe60b1ff8e03675397f" translate="yes" xml:space="preserve">
          <source>Support for globally overriding glob() (GSAR 3-JUN-98)</source>
          <target state="translated">支持全局覆盖 glob()(GSAR 3-JUN-98)</target>
        </trans-unit>
        <trans-unit id="52d4e9ac29525e6d8e33903392c09e0782a71a40" translate="yes" xml:space="preserve">
          <source>Support for italic was added in Term::ANSIColor 3.02, included in Perl 5.17.1.</source>
          <target state="translated">在 Perl 5.17.1 中的 Term::ANSIColor 3.02 中加入了对斜体的支持。</target>
        </trans-unit>
        <trans-unit id="5e61014798c019e10930e4b0e0ccb8e127ac816a" translate="yes" xml:space="preserve">
          <source>Support for output other than TAP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fee3b6033badb5f9d6b2ad7b4bd90ed22c35a68" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt; , &lt;code&gt;seteuid()&lt;/code&gt; , &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt; . However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="translated">支持交换真实有效用户和组ID的支持不完整。在WinNT上，Cygwin提供 &lt;code&gt;setuid()&lt;/code&gt; ， &lt;code&gt;seteuid()&lt;/code&gt; ， &lt;code&gt;setgid()&lt;/code&gt; 和 &lt;code&gt;setegid()&lt;/code&gt; 。但是，需要额外的Cygwin调用来操纵WinNT访问令牌和安全上下文。</target>
        </trans-unit>
        <trans-unit id="5bb747be5ba781647f7ee9e1b01af00ae6891e82" translate="yes" xml:space="preserve">
          <source>Support for swapping real and effective user and group IDs is incomplete. On WinNT Cygwin provides &lt;code&gt;setuid()&lt;/code&gt;, &lt;code&gt;seteuid()&lt;/code&gt;, &lt;code&gt;setgid()&lt;/code&gt; and &lt;code&gt;setegid()&lt;/code&gt;. However, additional Cygwin calls for manipulating WinNT access tokens and security contexts are required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d45f23a800f84de37770824448a89f7d793b8" translate="yes" xml:space="preserve">
          <source>Support for this module is provided via the datetime@perl.org email list. See &lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt; for more details.</source>
          <target state="translated">通过datetime@perl.org电子邮件列表提供了对该模块的支持。有关更多详细信息，请参见&lt;a href=&quot;http://lists.perl.org/&quot;&gt;http://lists.perl.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b5dad507bd8d5ed70d50a2dce7e70ae220730928" translate="yes" xml:space="preserve">
          <source>Support for threading/forking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b47c288b94e063b5e848ebb4c141831f2f842b" translate="yes" xml:space="preserve">
          <source>Support for threads extends beyond the code in this module (i.e.,</source>
          <target state="translated">对线程的支持超出了本模块的代码范围(即。</target>
        </trans-unit>
        <trans-unit id="21dd6f486b02b193ff80841db50fc3fa27133663" translate="yes" xml:space="preserve">
          <source>Support for true color (the &lt;code&gt;rNNNgNNNbNNN&lt;/code&gt; and &lt;code&gt;on_rNNNgNNNbNNN&lt;/code&gt; attributes), defining aliases in terms of other aliases, and aliases mapping to multiple attributes instead of only a single attribute was added in Term::ANSIColor 5.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ebd54c9803d67645a6bec6e8a530fc77962d822" translate="yes" xml:space="preserve">
          <source>Supported Colors</source>
          <target state="translated">支持的颜色</target>
        </trans-unit>
        <trans-unit id="a65b7f12a991185f44b505808bc867e90d749e20" translate="yes" xml:space="preserve">
          <source>Supported Compilers</source>
          <target state="translated">支持的编译器</target>
        </trans-unit>
        <trans-unit id="e86357f3df6067cf4701809cd469c16322e01a41" translate="yes" xml:space="preserve">
          <source>Supported Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c494dc50dd3ab8063517ff409c4657b627cea738" translate="yes" xml:space="preserve">
          <source>Supported Perl API, sorted by version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a182e900ad0b28f084dbe30c2f1ab8dc81f123a" translate="yes" xml:space="preserve">
          <source>Supported Platforms</source>
          <target state="translated">支持平台</target>
        </trans-unit>
        <trans-unit id="49b953a7424bb44dd08394b0aeda11553bb12089" translate="yes" xml:space="preserve">
          <source>Supported Platforms (Perl 5.8)</source>
          <target state="translated">支持的平台 (Perl 5.8)</target>
        </trans-unit>
        <trans-unit id="b1429d26115432e6f40c246dd70a7c60030a0632" translate="yes" xml:space="preserve">
          <source>Supported are: &lt;code&gt;build_requires_install_policy&lt;/code&gt; , &lt;code&gt;check_sigs&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;make_install_make_command&lt;/code&gt; , &lt;code&gt;prefer_installer&lt;/code&gt; , &lt;code&gt;test_report&lt;/code&gt; . Please report as a bug when you need another one supported.</source>
          <target state="translated">支持的对象包括： &lt;code&gt;build_requires_install_policy&lt;/code&gt; ， &lt;code&gt;check_sigs&lt;/code&gt; ， &lt;code&gt;make&lt;/code&gt; ， &lt;code&gt;make_install_make_command&lt;/code&gt; ， &lt;code&gt;prefer_installer&lt;/code&gt; ， &lt;code&gt;test_report&lt;/code&gt; 。如果您需要另一个支持，请作为错误报告。</target>
        </trans-unit>
        <trans-unit id="a300efed490ba967b52cf87f5ed3078c87e2e5f8" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for &lt;code&gt;tempfile&lt;/code&gt;: UNLINK (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename template is specified using the TEMPLATE option. The OPEN option is not supported (the file is always opened).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fef4367afdb333ca61c98475adcf339702a0de4a" translate="yes" xml:space="preserve">
          <source>Supported arguments are the same as for C</source>
          <target state="translated">支持的参数与C语言相同</target>
        </trans-unit>
        <trans-unit id="fea58cf8a3651927bfad6193b75319d8c2af260d" translate="yes" xml:space="preserve">
          <source>Supported operators include &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aee30f240e3b0641c58b8ea19a5ce4e73c13514" translate="yes" xml:space="preserve">
          <source>Supported versions of Perl</source>
          <target state="translated">支持的Perl版本</target>
        </trans-unit>
        <trans-unit id="16d6bd14e545e871010e04ca5850bc1f495fe10f" translate="yes" xml:space="preserve">
          <source>Supporting CLICOLOR</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc8693c1249e9f6a0e8cf33a70dea32c26fa53d" translate="yes" xml:space="preserve">
          <source>Supports the same options as the &lt;code&gt;tempdir&lt;/code&gt; function. Note that directories created with this method default to CLEANUP =&amp;gt; 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ab85bed1d3b1a215699ee5c1c8be8f331ffab56" translate="yes" xml:space="preserve">
          <source>Supports the same options as the C</source>
          <target state="translated">支持与C语言相同的选项</target>
        </trans-unit>
        <trans-unit id="68a10bfa60258c2bbfe38e9f1a7ff60f4694f8f6" translate="yes" xml:space="preserve">
          <source>Suppose instead, that if no matching &quot;/endpara&quot; tag is found, the &quot;/para&quot; tag refers only to the immediately following paragraph:</source>
          <target state="translated">假设没有找到匹配的&quot;/endpara &quot;标签,则&quot;/para &quot;标签仅指紧接着的段落。</target>
        </trans-unit>
        <trans-unit id="4a2e98ea3f847f379e1d62458409b455691002c8" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt; . This is all we need:</source>
          <target state="translated">假设出于某种奇怪的原因，我们需要在标准C库函数 &lt;code&gt;fputs()&lt;/code&gt; 周围进行包装。这就是我们所需要的：</target>
        </trans-unit>
        <trans-unit id="cc6556ba8db25d3e88bccf33270c985ae50ea100" translate="yes" xml:space="preserve">
          <source>Suppose that for some strange reason we need a wrapper around the standard C library function &lt;code&gt;fputs()&lt;/code&gt;. This is all we need:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9713a66e131c3277390fd2e0a638134463da779" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt; , &lt;code&gt;divide_off&lt;/code&gt; , &lt;code&gt;add_off&lt;/code&gt; , &lt;code&gt;subtract_off&lt;/code&gt; . Then one can use</source>
          <target state="translated">假设在前面的示例函数中，multiple（），divide（），add（），subtract（）的指针保存在全局C数组 &lt;code&gt;fp[]&lt;/code&gt; ，其偏移量为 &lt;code&gt;multiply_off&lt;/code&gt; ， &lt;code&gt;divide_off&lt;/code&gt; ， &lt;code&gt;add_off&lt;/code&gt; ， &lt;code&gt;subtract_off&lt;/code&gt; 。然后可以使用</target>
        </trans-unit>
        <trans-unit id="ea8ab19bf86289ef6108d40f927555e5f4e3c590" translate="yes" xml:space="preserve">
          <source>Suppose that in the previous example functions pointers for multiply(), divide(), add(), subtract() are kept in a global C array &lt;code&gt;fp[]&lt;/code&gt; with offsets being &lt;code&gt;multiply_off&lt;/code&gt;, &lt;code&gt;divide_off&lt;/code&gt;, &lt;code&gt;add_off&lt;/code&gt;, &lt;code&gt;subtract_off&lt;/code&gt;. Then one can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b728cf8454bb8ebd395d51ef450a37f61ee3df" translate="yes" xml:space="preserve">
          <source>Suppose that we want to enable a new RE escape-sequence &lt;code&gt;\Y|&lt;/code&gt; which matches at a boundary between whitespace characters and non-whitespace characters. Note that &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; matches exactly at these positions, so we want to have each &lt;code&gt;\Y|&lt;/code&gt; in the place of the more complicated version. We can create a module &lt;code&gt;customre&lt;/code&gt; to do this:</source>
          <target state="translated">假设我们要启用一个新的RE转义序列 &lt;code&gt;\Y|&lt;/code&gt; 在空白字符和非空白字符之间的边界处匹配。注意 &lt;code&gt;(?=\S)(?&amp;lt;!\S)|(?!\S)(?&amp;lt;=\S)&lt;/code&gt; 在这些位置上完全匹配，因此我们希望每个 &lt;code&gt;\Y|&lt;/code&gt; 代替更复杂的版本。我们可以创建一个模块 &lt;code&gt;customre&lt;/code&gt; 来做到这一点：</target>
        </trans-unit>
        <trans-unit id="5ab2eaff078de5c28b462a36a77339cffbb8f320" translate="yes" xml:space="preserve">
          <source>Suppose that you have some C files implementing some functionality, and the corresponding header files. How to create an extension which makes this functionality accessible in Perl? The example below assumes that the header files are</source>
          <target state="translated">假设你有一些实现某些功能的C文件,以及相应的头文件。如何创建一个扩展,使这些功能在Perl中可以访问?下面的例子假设头文件为</target>
        </trans-unit>
        <trans-unit id="0a98ed263af8d4ba63e18dadba6d2dc4eec20053" translate="yes" xml:space="preserve">
          <source>Suppose we wrote the following string to a file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38ce69c0f981610bad14796ceb31eadf517ce86" translate="yes" xml:space="preserve">
          <source>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</source>
          <target state="translated">假设你想创建一个既可以作为数组引用又可以作为哈希引用访问的对象。</target>
        </trans-unit>
        <trans-unit id="abacd026fc80e9051241fe69f59c13539803bbd4" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &amp;lt;a&amp;gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt; . Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt; .</source>
          <target state="translated">假设您要匹配字符串&amp;ldquo; 1122a44&amp;rdquo;中的所有连续数字对，并在遇到非数字时停止匹配。您想匹配 &lt;code&gt;11&lt;/code&gt; 和 &lt;code&gt;22&lt;/code&gt; ,但是字母&amp;lt;a&amp;gt;显示在 &lt;code&gt;22&lt;/code&gt; 和 &lt;code&gt;44&lt;/code&gt; 之间，并且您想在 &lt;code&gt;a&lt;/code&gt; 处停止。简单匹配的数字对将跳过 &lt;code&gt;a&lt;/code&gt; 并仍然匹配 &lt;code&gt;44&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43b6b33a52cb0c2ab7e4d2d5a81bdf49073103dc" translate="yes" xml:space="preserve">
          <source>Suppose you want to match all of consecutive pairs of digits in a string like &quot;1122a44&quot; and stop matching when you encounter non-digits. You want to match &lt;code&gt;11&lt;/code&gt; and &lt;code&gt;22&lt;/code&gt; but the letter &lt;code&gt;a&lt;/code&gt; shows up between &lt;code&gt;22&lt;/code&gt; and &lt;code&gt;44&lt;/code&gt; and you want to stop at &lt;code&gt;a&lt;/code&gt;. Simply matching pairs of digits skips over the &lt;code&gt;a&lt;/code&gt; and still matches &lt;code&gt;44&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc722b9b16484d706d6ab120abc391e667f22c8" translate="yes" xml:space="preserve">
          <source>Suppose you wanted &lt;code&gt;ARGUMENTS&lt;/code&gt; to be an empty list,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f46adab557fd8dab8b4b0b09a159b2654c69a5" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to match only the allocated characters, not the raw block ranges: in other words, you want to remove the unassigned characters:</source>
          <target state="translated">假设你只想匹配已分配的字符,而不是原始块范围:换句话说,你想删除未分配的字符。</target>
        </trans-unit>
        <trans-unit id="7282725934a73028b4873e419044ca1541b7ef81" translate="yes" xml:space="preserve">
          <source>Suppose your function looks like this:</source>
          <target state="translated">假设你的函数是这样的。</target>
        </trans-unit>
        <trans-unit id="3cdc33b87c0a24861f5653d7a4749ecf4d10599b" translate="yes" xml:space="preserve">
          <source>Suppress statically defined functions from the profile.</source>
          <target state="translated">禁止在配置文件中使用静态定义的函数。</target>
        </trans-unit>
        <trans-unit id="f000eea4b15966462d081470a0dbb8675e040042" translate="yes" xml:space="preserve">
          <source>Suppress the verbose descriptions in the profile.</source>
          <target state="translated">抑制简介中的冗长描述。</target>
        </trans-unit>
        <trans-unit id="b1d411f9454876226deea65132d8958b5f310ebd" translate="yes" xml:space="preserve">
          <source>Suppresses echoing of input data on the screen as it is entered on the keyboard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4ca7a4b62d0d93f13a11c00e6e1ef2ac15f93d" translate="yes" xml:space="preserve">
          <source>Suppressing Lines Where All Fields Are Void</source>
          <target state="translated">抑制所有字段都是空的线。</target>
        </trans-unit>
        <trans-unit id="f8a4d33a75006d37aaaa326a12ea28f45b06e609" translate="yes" xml:space="preserve">
          <source>Suppressing all output.</source>
          <target state="translated">压制所有输出。</target>
        </trans-unit>
        <trans-unit id="4db0aec339465e45f71592f3d61d3b7d5519b564" translate="yes" xml:space="preserve">
          <source>Suppressing everything but the tests summary.</source>
          <target state="translated">抑制一切,但测试总结。</target>
        </trans-unit>
        <trans-unit id="3118002fe0231bc240b745efda50a51f4811af55" translate="yes" xml:space="preserve">
          <source>Suppressing some test output (mostly failures while tests are running).</source>
          <target state="translated">抑制一些测试输出(主要是测试运行时的失败)。</target>
        </trans-unit>
        <trans-unit id="2f0421f55fddacae44a5e70879884253681983a3" translate="yes" xml:space="preserve">
          <source>Surprisingly, &lt;code&gt;decode&lt;/code&gt; will ignore these flags and so treat all input values as governed by the &lt;code&gt;utf8&lt;/code&gt; flag. If it is disabled, this allows you to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaf2f474284f3bb3469459a5f2e282c817445e0a" translate="yes" xml:space="preserve">
          <source>Surprisingly, the following dangerous-looking construct will actually work out fine:</source>
          <target state="translated">出乎意料的是,下面这个看似危险的构造,其实也会有不错的效果。</target>
        </trans-unit>
        <trans-unit id="89de18d6062f8f62c80480423d64e1771fc8ce04" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt; . If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="translated">出人意料的是，要调用的例程称为 &lt;code&gt;freeze&lt;/code&gt; 和 &lt;code&gt;thaw&lt;/code&gt; 。如果希望将冻结的标量发送到另一台计算机，请使用 &lt;code&gt;nfreeze&lt;/code&gt; 来获取可移植图像。</target>
        </trans-unit>
        <trans-unit id="38b1f8d5199fc680c670a3cdffbc331409087673" translate="yes" xml:space="preserve">
          <source>Surprisingly, the routines to be called are named &lt;code&gt;freeze&lt;/code&gt; and &lt;code&gt;thaw&lt;/code&gt;. If you wish to send out the frozen scalar to another machine, use &lt;code&gt;nfreeze&lt;/code&gt; instead to get a portable image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a047875b873f6d1d398e86dbb7108d34705540" translate="yes" xml:space="preserve">
          <source>Surrogate Pairs</source>
          <target state="translated">代孕夫妇</target>
        </trans-unit>
        <trans-unit id="07a0eab00168ce9bedc809f5ad8c9eb56cbd1edb" translate="yes" xml:space="preserve">
          <source>Surrogate pairs were born when the Unicode Consortium finally admitted that 16 bits were not big enough to hold all the world's character repertoires. But they already made UCS-2 16-bit. What do we do?</source>
          <target state="translated">当Unicode联盟终于承认16位不足以容纳世界上所有的字符集时,代用对就诞生了。但他们已经把UCS-2做成了16位。我们该怎么办?</target>
        </trans-unit>
        <trans-unit id="1eaaa69a37b20a485ea6f0e51d7a77d119e19f29" translate="yes" xml:space="preserve">
          <source>Surrogates are code points set aside to encode the &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; range of Unicode code points in pairs of 16-bit units. The</source>
          <target state="translated">替代项是留出的代码点，用于以16位为单位对 &lt;code&gt;U+10000..U+10FFFF&lt;/code&gt; 范围的Unicode代码点进行编码。的</target>
        </trans-unit>
        <trans-unit id="856dbe523b5bc18c3ac9b4ef67ed5a73d664d082" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; . But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="translated">代理在成对使用代表其他代码点时，代理在Unicode中没有任何意义。但是，Perl允许在内部单独表示它们，例如通过说 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0xD801)&lt;/a&gt;&lt;/code&gt; ，以便可以表示所有代码点，而不仅仅是对开放交换有效的代码点。 Unicode确实为它们定义了语义，例如它们的 &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;General_Category&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&quot;Cs&quot;&lt;/code&gt; 。但是，由于尝试使用它们有些危险，因此，如果尝试做类似小写的小写或匹配大小写的事情，Perl会发出警告（使用警告类别 &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt; ，这是 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; 的子类别）。 -不敏感，或输出它们。 （但不要在5.14之前在Perls上尝试此操作。）</target>
        </trans-unit>
        <trans-unit id="7e4f255eb9d4da0b778db2cbd0767cd7435fa252" translate="yes" xml:space="preserve">
          <source>Surrogates have no meaning in Unicode outside their use in pairs to represent other code points. However, Perl allows them to be represented individually internally, for example by saying &lt;code&gt;chr(0xD801)&lt;/code&gt;, so that all code points, not just those valid for open interchange, are representable. Unicode does define semantics for them, such as their &lt;code&gt;&lt;a href=&quot;#General_Category&quot;&gt;&quot;General_Category&quot;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&quot;Cs&quot;&lt;/code&gt;. But because their use is somewhat dangerous, Perl will warn (using the warning category &lt;code&gt;&quot;surrogate&quot;&lt;/code&gt;, which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt;) if an attempt is made to do things like take the lower case of one, or match case-insensitively, or to output them. (But don't try this on Perls before 5.14.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540da7a8cd172c1838160d487b9d7ef0924efc97" translate="yes" xml:space="preserve">
          <source>Suspicious Warnings on Cygwin</source>
          <target state="translated">Cygwin上的可疑警告</target>
        </trans-unit>
        <trans-unit id="ade7a22fa4aa1143e2d2d4f40f65a94eb90d8572" translate="yes" xml:space="preserve">
          <source>SvAMAGIC_off</source>
          <target state="translated">SvAMAGIC_off</target>
        </trans-unit>
        <trans-unit id="9b9fa0e67675873845864411f1905f615bc33d13" translate="yes" xml:space="preserve">
          <source>SvAMAGIC_on</source>
          <target state="translated">SvAMAGIC_on</target>
        </trans-unit>
        <trans-unit id="2425fee0a45344518684d0c9b14dde2323fe9de7" translate="yes" xml:space="preserve">
          <source>SvCUR</source>
          <target state="translated">SvCUR</target>
        </trans-unit>
        <trans-unit id="6058a9ad780b864ec71080d419dca4d99c96b0e6" translate="yes" xml:space="preserve">
          <source>SvCUR_set</source>
          <target state="translated">SvCUR_set</target>
        </trans-unit>
        <trans-unit id="661476f7df6dbc01af035711108e0d1500868903" translate="yes" xml:space="preserve">
          <source>SvEND</source>
          <target state="translated">SvEND</target>
        </trans-unit>
        <trans-unit id="e59e241299dce8584448d13053a18ac8814b51ab" translate="yes" xml:space="preserve">
          <source>SvGAMAGIC</source>
          <target state="translated">SvGAMAGIC</target>
        </trans-unit>
        <trans-unit id="aebf3d2208b03126421cfebdd2654ea2db0a30f7" translate="yes" xml:space="preserve">
          <source>SvGETMAGIC</source>
          <target state="translated">SvGETMAGIC</target>
        </trans-unit>
        <trans-unit id="4ddf923c756d56139db1069ad97f7b8f40e70f94" translate="yes" xml:space="preserve">
          <source>SvGROW</source>
          <target state="translated">SvGROW</target>
        </trans-unit>
        <trans-unit id="abfa953c1fed37e05526c0219c09e917f51bbd9e" translate="yes" xml:space="preserve">
          <source>SvIOK</source>
          <target state="translated">SvIOK</target>
        </trans-unit>
        <trans-unit id="c0e62457bc773af183a3e1d8cda75a5f3adbaf1c" translate="yes" xml:space="preserve">
          <source>SvIOK_UV</source>
          <target state="translated">SvIOK_UV</target>
        </trans-unit>
        <trans-unit id="cfbeae889fea001d8bb1a161c1f0da0c7af2b5f7" translate="yes" xml:space="preserve">
          <source>SvIOK_notUV</source>
          <target state="translated">SvIOK_notUV</target>
        </trans-unit>
        <trans-unit id="8f0272bd6fc26a005d760d2fea687329b0e4a68c" translate="yes" xml:space="preserve">
          <source>SvIOK_off</source>
          <target state="translated">SvIOK_off</target>
        </trans-unit>
        <trans-unit id="34a30cb8e77826bc36fe6388f6c8eb39936d73d8" translate="yes" xml:space="preserve">
          <source>SvIOK_on</source>
          <target state="translated">SvIOK_on</target>
        </trans-unit>
        <trans-unit id="eed3c603a946c2dcc8e9ac46fa3cd88ac634ee17" translate="yes" xml:space="preserve">
          <source>SvIOK_only</source>
          <target state="translated">SvIOK_only</target>
        </trans-unit>
        <trans-unit id="13e3f4df7cd8f72b57259101aa3948f2204a9335" translate="yes" xml:space="preserve">
          <source>SvIOK_only_UV</source>
          <target state="translated">SvIOK_only_UV</target>
        </trans-unit>
        <trans-unit id="45a18c6bb3b31a95939140770d9eaf87b85c8af4" translate="yes" xml:space="preserve">
          <source>SvIOKp</source>
          <target state="translated">SvIOKp</target>
        </trans-unit>
        <trans-unit id="e58c0b91b4f10ba7ea023ead483916f688590254" translate="yes" xml:space="preserve">
          <source>SvIV</source>
          <target state="translated">SvIV</target>
        </trans-unit>
        <trans-unit id="1e1cd0c78512c809bc8f82ce5a88755a660fc1dd" translate="yes" xml:space="preserve">
          <source>SvIV()</source>
          <target state="translated">SvIV()</target>
        </trans-unit>
        <trans-unit id="e3f836b31a83cc11f5f8cc34d3ffa47690b79351" translate="yes" xml:space="preserve">
          <source>SvIVX</source>
          <target state="translated">SvIVX</target>
        </trans-unit>
        <trans-unit id="a7e83f79d851aa05c23e8e127c1c0104d7becb61" translate="yes" xml:space="preserve">
          <source>SvIV_nomg</source>
          <target state="translated">SvIV_nomg</target>
        </trans-unit>
        <trans-unit id="d54d9f546b2a3ee3896c8e62f21916b605c8749e" translate="yes" xml:space="preserve">
          <source>SvIV_set</source>
          <target state="translated">SvIV_set</target>
        </trans-unit>
        <trans-unit id="d0e6c181ed31a5825fe2aba5e86b6714622736fc" translate="yes" xml:space="preserve">
          <source>SvIVx</source>
          <target state="translated">SvIVx</target>
        </trans-unit>
        <trans-unit id="bfb611e82edc20e454e089941049df596bb71192" translate="yes" xml:space="preserve">
          <source>SvIsCOW</source>
          <target state="translated">SvIsCOW</target>
        </trans-unit>
        <trans-unit id="9aecfe6c9cbba3f5b8ffdf25297fd019b7b2eaf2" translate="yes" xml:space="preserve">
          <source>SvIsCOW_shared_hash</source>
          <target state="translated">SvIsCOW_shared_hash</target>
        </trans-unit>
        <trans-unit id="80a0475edeea5c18e06234c9d64a8fcc2e3f6c39" translate="yes" xml:space="preserve">
          <source>SvLEN</source>
          <target state="translated">SvLEN</target>
        </trans-unit>
        <trans-unit id="556d85f2a0063cc9ba584af5e853a1ceb2f6783d" translate="yes" xml:space="preserve">
          <source>SvLEN_set</source>
          <target state="translated">SvLEN_set</target>
        </trans-unit>
        <trans-unit id="97aec17efc79908cfbaf02941eae143d8b976a42" translate="yes" xml:space="preserve">
          <source>SvLOCK</source>
          <target state="translated">SvLOCK</target>
        </trans-unit>
        <trans-unit id="84cc200fa83f3f6ed106b0dd44cb7c16363e0435" translate="yes" xml:space="preserve">
          <source>SvMAGIC_set</source>
          <target state="translated">SvMAGIC_set</target>
        </trans-unit>
        <trans-unit id="d379abe0c8da0cf1e20d037eb2f8185f062b9489" translate="yes" xml:space="preserve">
          <source>SvNIOK</source>
          <target state="translated">SvNIOK</target>
        </trans-unit>
        <trans-unit id="fb4f99f52267211a93dc9edb5e96013ebf799d8e" translate="yes" xml:space="preserve">
          <source>SvNIOK_off</source>
          <target state="translated">SvNIOK_off</target>
        </trans-unit>
        <trans-unit id="defaa8b9a1718665f488a28ac6a6a046a710c0d6" translate="yes" xml:space="preserve">
          <source>SvNIOKp</source>
          <target state="translated">SvNIOKp</target>
        </trans-unit>
        <trans-unit id="ca25134015aee24be79876d35dd93a74df11c721" translate="yes" xml:space="preserve">
          <source>SvNOK</source>
          <target state="translated">SvNOK</target>
        </trans-unit>
        <trans-unit id="baaa77e5fd0bf7672f89eaeb72acc5efa6ff8b0c" translate="yes" xml:space="preserve">
          <source>SvNOK_off</source>
          <target state="translated">SvNOK_off</target>
        </trans-unit>
        <trans-unit id="dd1f88650a4a7b063453463c4580f0b16fabe2d4" translate="yes" xml:space="preserve">
          <source>SvNOK_on</source>
          <target state="translated">SvNOK_on</target>
        </trans-unit>
        <trans-unit id="1b8500076baeb528cecf476027ad962a134be104" translate="yes" xml:space="preserve">
          <source>SvNOK_only</source>
          <target state="translated">SvNOK_only</target>
        </trans-unit>
        <trans-unit id="df8a270b374b63fb7ad234036190cb6d9599dc79" translate="yes" xml:space="preserve">
          <source>SvNOKp</source>
          <target state="translated">SvNOKp</target>
        </trans-unit>
        <trans-unit id="17482a420e00ffd25f7122c8a4e97ab029e48c16" translate="yes" xml:space="preserve">
          <source>SvNV</source>
          <target state="translated">SvNV</target>
        </trans-unit>
        <trans-unit id="dbc4878fd112ac06a09fc11cde47bb125aee2c3f" translate="yes" xml:space="preserve">
          <source>SvNV()</source>
          <target state="translated">SvNV()</target>
        </trans-unit>
        <trans-unit id="f62717e28cc640cdf47f8dd6ee4c879eb42bea28" translate="yes" xml:space="preserve">
          <source>SvNVX</source>
          <target state="translated">SvNVX</target>
        </trans-unit>
        <trans-unit id="dd86bbe5ae725800fcf2d56c703e0a31d42e3a42" translate="yes" xml:space="preserve">
          <source>SvNV_nomg</source>
          <target state="translated">SvNV_nomg</target>
        </trans-unit>
        <trans-unit id="c026cc4a3dbd70507f3a01baf8b04c8414942781" translate="yes" xml:space="preserve">
          <source>SvNV_set</source>
          <target state="translated">SvNV_set</target>
        </trans-unit>
        <trans-unit id="6a541df7bd973627ec28ca14270b2c53a16dac8e" translate="yes" xml:space="preserve">
          <source>SvNVx</source>
          <target state="translated">SvNVx</target>
        </trans-unit>
        <trans-unit id="020d091cc2310c06e45f2bc3d53eba7c49731b6d" translate="yes" xml:space="preserve">
          <source>SvOK</source>
          <target state="translated">SvOK</target>
        </trans-unit>
        <trans-unit id="0580de03ad05ae223672bac31eca2ff976a459f8" translate="yes" xml:space="preserve">
          <source>SvOOK</source>
          <target state="translated">SvOOK</target>
        </trans-unit>
        <trans-unit id="4dde88ed106842ab159cd28a6c4d036172ee28c7" translate="yes" xml:space="preserve">
          <source>SvOOK_offset</source>
          <target state="translated">SvOOK_offset</target>
        </trans-unit>
        <trans-unit id="b4ad9d1f5c7f6646cd2710f7f7da0b899e3a96cb" translate="yes" xml:space="preserve">
          <source>SvPOK</source>
          <target state="translated">SvPOK</target>
        </trans-unit>
        <trans-unit id="5654f39dee44eae829fb8b496682a50f0982a5e7" translate="yes" xml:space="preserve">
          <source>SvPOK_off</source>
          <target state="translated">SvPOK_off</target>
        </trans-unit>
        <trans-unit id="3fc674f1095783934e3ac6f2709bc63b02d7430c" translate="yes" xml:space="preserve">
          <source>SvPOK_on</source>
          <target state="translated">SvPOK_on</target>
        </trans-unit>
        <trans-unit id="63cf7f854220f91309bc16c8b83e2c3a33c8ab02" translate="yes" xml:space="preserve">
          <source>SvPOK_only</source>
          <target state="translated">SvPOK_only</target>
        </trans-unit>
        <trans-unit id="6181decd9d199af54afc923b0ff0ebf390a6d7b4" translate="yes" xml:space="preserve">
          <source>SvPOK_only_UTF8</source>
          <target state="translated">SvPOK_only_UTF8</target>
        </trans-unit>
        <trans-unit id="1f6818d473538e1037ae99abfd3928b6194d55f4" translate="yes" xml:space="preserve">
          <source>SvPOKp</source>
          <target state="translated">SvPOKp</target>
        </trans-unit>
        <trans-unit id="7565784ec8ed0b2a10e7ce11934bff895f7866ad" translate="yes" xml:space="preserve">
          <source>SvPV</source>
          <target state="translated">SvPV</target>
        </trans-unit>
        <trans-unit id="935c09deb58ecb63d6891adc1aabec93c4c8a5b7" translate="yes" xml:space="preserve">
          <source>SvPV()</source>
          <target state="translated">SvPV()</target>
        </trans-unit>
        <trans-unit id="bf9de3c1167813342adaabc11e3c1b95d085aee2" translate="yes" xml:space="preserve">
          <source>SvPVCLEAR</source>
          <target state="translated">SvPVCLEAR</target>
        </trans-unit>
        <trans-unit id="441e4866b0c8dfdb41e2b081d770159832861536" translate="yes" xml:space="preserve">
          <source>SvPVX</source>
          <target state="translated">SvPVX</target>
        </trans-unit>
        <trans-unit id="bb779035a6b5212f5bc497064139d582eac78761" translate="yes" xml:space="preserve">
          <source>SvPV_force</source>
          <target state="translated">SvPV_force</target>
        </trans-unit>
        <trans-unit id="a371ca6a1e78ccac0de2a78800f60864935747e1" translate="yes" xml:space="preserve">
          <source>SvPV_force_nomg</source>
          <target state="translated">SvPV_force_nomg</target>
        </trans-unit>
        <trans-unit id="e460005b105a2b7bfd76b6a69fac89cf40b7f1d9" translate="yes" xml:space="preserve">
          <source>SvPV_nolen</source>
          <target state="translated">SvPV_nolen</target>
        </trans-unit>
        <trans-unit id="ee503ff4f441fd072927bc4adf1a3b2b61c96eb8" translate="yes" xml:space="preserve">
          <source>SvPV_nomg</source>
          <target state="translated">SvPV_nomg</target>
        </trans-unit>
        <trans-unit id="7dc0def922bcc926f6b2a0768c4dc6365edb9c39" translate="yes" xml:space="preserve">
          <source>SvPV_nomg_nolen</source>
          <target state="translated">SvPV_nomg_nolen</target>
        </trans-unit>
        <trans-unit id="b294767f00b4898e2955e33a91d5667698462a42" translate="yes" xml:space="preserve">
          <source>SvPV_set</source>
          <target state="translated">SvPV_set</target>
        </trans-unit>
        <trans-unit id="8dfe9329a5a7e9cb118b1baf10944b5ae534ec2e" translate="yes" xml:space="preserve">
          <source>SvPVbyte</source>
          <target state="translated">SvPVbyte</target>
        </trans-unit>
        <trans-unit id="a42257f4844c980ccf0e6066f8db9f6f15894819" translate="yes" xml:space="preserve">
          <source>SvPVbyte_force</source>
          <target state="translated">SvPVbyte_force</target>
        </trans-unit>
        <trans-unit id="37adc1f4cfd7a587db4e891abb49367190445337" translate="yes" xml:space="preserve">
          <source>SvPVbyte_nolen</source>
          <target state="translated">SvPVbyte_nolen</target>
        </trans-unit>
        <trans-unit id="7923345fa2b2955faca8c97835509b73e61c0f71" translate="yes" xml:space="preserve">
          <source>SvPVbyte_nomg</source>
          <target state="translated">SvPVbyte_nomg</target>
        </trans-unit>
        <trans-unit id="7dabdc96dfd70ff777704e95caf484a1bbd67626" translate="yes" xml:space="preserve">
          <source>SvPVbyte_or_null</source>
          <target state="translated">SvPVbyte_or_null</target>
        </trans-unit>
        <trans-unit id="6f473eaded3b18d22bd0cfbd398f1d3838819074" translate="yes" xml:space="preserve">
          <source>SvPVbyte_or_null_nomg</source>
          <target state="translated">SvPVbyte_or_null_nomg</target>
        </trans-unit>
        <trans-unit id="00286cef8b77db9493694652d7e00120622a74fd" translate="yes" xml:space="preserve">
          <source>SvPVbytex</source>
          <target state="translated">SvPVbytex</target>
        </trans-unit>
        <trans-unit id="fed8330e0b39b1ac7a27526d358e6d7bd6a90609" translate="yes" xml:space="preserve">
          <source>SvPVbytex_force</source>
          <target state="translated">SvPVbytex_force</target>
        </trans-unit>
        <trans-unit id="b302138ff008911538b45179c44f73ff2f15910d" translate="yes" xml:space="preserve">
          <source>SvPVutf8</source>
          <target state="translated">SvPVutf8</target>
        </trans-unit>
        <trans-unit id="a8de8e18c45d70ca0a2ee1f75e6737824757551e" translate="yes" xml:space="preserve">
          <source>SvPVutf8_force</source>
          <target state="translated">SvPVutf8_force</target>
        </trans-unit>
        <trans-unit id="34b12f7ac99c5d36b41f8c87cb93ef246cef0211" translate="yes" xml:space="preserve">
          <source>SvPVutf8_nolen</source>
          <target state="translated">SvPVutf8_nolen</target>
        </trans-unit>
        <trans-unit id="423ddab605b2202c3b3c7cf1a6aab74e87847180" translate="yes" xml:space="preserve">
          <source>SvPVutf8_nomg</source>
          <target state="translated">SvPVutf8_nomg</target>
        </trans-unit>
        <trans-unit id="4266cc27f9fcb29ce91587ace651e07d810d65b5" translate="yes" xml:space="preserve">
          <source>SvPVutf8_or_null</source>
          <target state="translated">SvPVutf8_or_null</target>
        </trans-unit>
        <trans-unit id="d92f3b72d1647089e88a44d2515cd6a801386b09" translate="yes" xml:space="preserve">
          <source>SvPVutf8_or_null_nomg</source>
          <target state="translated">SvPVutf8_or_null_nomg</target>
        </trans-unit>
        <trans-unit id="35823de756974d226740f00e5c68a6481e4ed0de" translate="yes" xml:space="preserve">
          <source>SvPVutf8x</source>
          <target state="translated">SvPVutf8x</target>
        </trans-unit>
        <trans-unit id="7def8a7e5746a1d922bd31c60d3cb8a70d51aa60" translate="yes" xml:space="preserve">
          <source>SvPVutf8x_force</source>
          <target state="translated">SvPVutf8x_force</target>
        </trans-unit>
        <trans-unit id="6b594f1f8b6cd1295001275a5c619bad5200c1fb" translate="yes" xml:space="preserve">
          <source>SvPVx</source>
          <target state="translated">SvPVx</target>
        </trans-unit>
        <trans-unit id="4fa947438e302d4c0cfa0fd091b866be1356e841" translate="yes" xml:space="preserve">
          <source>SvREADONLY</source>
          <target state="translated">SvREADONLY</target>
        </trans-unit>
        <trans-unit id="be79d366d9292bb9353ad47fa578f3ba4c51d644" translate="yes" xml:space="preserve">
          <source>SvREADONLY(THING, [, $value])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76ee936f6a9d9874c72ac97c2ae38c0ac457002" translate="yes" xml:space="preserve">
          <source>SvREADONLY_off</source>
          <target state="translated">SvREADONLY_off</target>
        </trans-unit>
        <trans-unit id="ebbbefde1cfff96f373b3af6c19695b6b47fe85c" translate="yes" xml:space="preserve">
          <source>SvREADONLY_on</source>
          <target state="translated">SvREADONLY_on</target>
        </trans-unit>
        <trans-unit id="41356e74473a3c2dd231981a54cbf8916dae6a6f" translate="yes" xml:space="preserve">
          <source>SvREFCNT</source>
          <target state="translated">SvREFCNT</target>
        </trans-unit>
        <trans-unit id="e21722a974d6353587902b5def5af30f86188580" translate="yes" xml:space="preserve">
          <source>SvREFCNT(THING [, $value])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbc1bf9563ab155051e035e471f156eba22dc15" translate="yes" xml:space="preserve">
          <source>SvREFCNT_dec</source>
          <target state="translated">SvREFCNT_dec</target>
        </trans-unit>
        <trans-unit id="6d3d7d60ea55b7e2400d8e3c957adb22ceec857f" translate="yes" xml:space="preserve">
          <source>SvREFCNT_dec_NN</source>
          <target state="translated">SvREFCNT_dec_NN</target>
        </trans-unit>
        <trans-unit id="d6d6cfefd8cf7744542e901404792f234eef8a87" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc</source>
          <target state="translated">SvREFCNT_inc</target>
        </trans-unit>
        <trans-unit id="b1c71741a55c44f3cf76f940293fd4e4067b6c8c" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_NN</source>
          <target state="translated">SvREFCNT_inc_NN</target>
        </trans-unit>
        <trans-unit id="6e813ab000508b7b24df3398011a2c9c250e9d3d" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple</source>
          <target state="translated">SvREFCNT_inc_simple</target>
        </trans-unit>
        <trans-unit id="67b0407bf6132cb27ed090533a37abfe3f7d17e7" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_NN</source>
          <target state="translated">SvREFCNT_inc_simple_NN</target>
        </trans-unit>
        <trans-unit id="355f655fe4c86d54f671992d7a810ce7e8512bc2" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_void</source>
          <target state="translated">SvREFCNT_inc_simple_void</target>
        </trans-unit>
        <trans-unit id="822614c7d4b2a58a9282398c20eb02c49458d68d" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_simple_void_NN</source>
          <target state="translated">SvREFCNT_inc_simple_void_NN</target>
        </trans-unit>
        <trans-unit id="c6f050b18183b6e90800a93ea7e82b46868d707f" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_void</source>
          <target state="translated">SvREFCNT_inc_void</target>
        </trans-unit>
        <trans-unit id="149f6e6626b6f4ebd70bdf3a3eb889b7ec93bdf3" translate="yes" xml:space="preserve">
          <source>SvREFCNT_inc_void_NN</source>
          <target state="translated">SvREFCNT_inc_void_NN</target>
        </trans-unit>
        <trans-unit id="3889ade1aec07364b71e18598417719a90402368" translate="yes" xml:space="preserve">
          <source>SvROK</source>
          <target state="translated">SvROK</target>
        </trans-unit>
        <trans-unit id="b4e270c3ae40052ec524acd38a350e379d3010aa" translate="yes" xml:space="preserve">
          <source>SvROK_off</source>
          <target state="translated">SvROK_off</target>
        </trans-unit>
        <trans-unit id="c7a1d36a4bff0e8c7571cf20c8d6a3df05ea6d45" translate="yes" xml:space="preserve">
          <source>SvROK_on</source>
          <target state="translated">SvROK_on</target>
        </trans-unit>
        <trans-unit id="3551ff814d3508fe0494321baf0b08462a5951a1" translate="yes" xml:space="preserve">
          <source>SvRV</source>
          <target state="translated">SvRV</target>
        </trans-unit>
        <trans-unit id="98657f4eb633c067b2f4bbd96111ec20385af83f" translate="yes" xml:space="preserve">
          <source>SvRV_set</source>
          <target state="translated">SvRV_set</target>
        </trans-unit>
        <trans-unit id="5231d45a15ed6a1e96e1c7adf65310a112ccdb14" translate="yes" xml:space="preserve">
          <source>SvRX</source>
          <target state="translated">SvRX</target>
        </trans-unit>
        <trans-unit id="8bf53e27da8805a20511f9e414f46c9a92c3fe7c" translate="yes" xml:space="preserve">
          <source>SvRXOK</source>
          <target state="translated">SvRXOK</target>
        </trans-unit>
        <trans-unit id="6ce588dbb5a26b48845042b1fed998c7094f41b9" translate="yes" xml:space="preserve">
          <source>SvSETMAGIC</source>
          <target state="translated">SvSETMAGIC</target>
        </trans-unit>
        <trans-unit id="03b9e565f8509ce2cdd182d158dca6b07c40361c" translate="yes" xml:space="preserve">
          <source>SvSHARE</source>
          <target state="translated">SvSHARE</target>
        </trans-unit>
        <trans-unit id="663202fcb6a07de7521aee49ad200856328f670e" translate="yes" xml:space="preserve">
          <source>SvSTASH</source>
          <target state="translated">SvSTASH</target>
        </trans-unit>
        <trans-unit id="1e4dda9ea59b23608fcebfdab0f78b8414975f4b" translate="yes" xml:space="preserve">
          <source>SvSTASH_set</source>
          <target state="translated">SvSTASH_set</target>
        </trans-unit>
        <trans-unit id="55f331b95bad8451772b832cb2896cd13d8a62bf" translate="yes" xml:space="preserve">
          <source>SvSetMagicSV</source>
          <target state="translated">SvSetMagicSV</target>
        </trans-unit>
        <trans-unit id="a2363fa9b8d5575fdee7b5f5137de002a0d7fbd7" translate="yes" xml:space="preserve">
          <source>SvSetMagicSV_nosteal</source>
          <target state="translated">SvSetMagicSV_nosteal</target>
        </trans-unit>
        <trans-unit id="a870c5f5f765c31be19cc225270f373bf2a19609" translate="yes" xml:space="preserve">
          <source>SvSetSV</source>
          <target state="translated">SvSetSV</target>
        </trans-unit>
        <trans-unit id="0a56b40c972eb03057e49afb45a5f79c3b3c850c" translate="yes" xml:space="preserve">
          <source>SvSetSV_nosteal</source>
          <target state="translated">SvSetSV_nosteal</target>
        </trans-unit>
        <trans-unit id="3757c6ffdf931a1f2a0babe56b6b7bcfa87d7dcd" translate="yes" xml:space="preserve">
          <source>SvTAINT</source>
          <target state="translated">SvTAINT</target>
        </trans-unit>
        <trans-unit id="b132d1a6ca07d23104de48a3a5b9b9e288757452" translate="yes" xml:space="preserve">
          <source>SvTAINTED</source>
          <target state="translated">SvTAINTED</target>
        </trans-unit>
        <trans-unit id="da48b96bbbd0a5ec83161761506d58ef29de8d6a" translate="yes" xml:space="preserve">
          <source>SvTAINTED_off</source>
          <target state="translated">SvTAINTED_off</target>
        </trans-unit>
        <trans-unit id="e468ae6914e87cdb2b57113711db192dcf342f4e" translate="yes" xml:space="preserve">
          <source>SvTAINTED_on</source>
          <target state="translated">SvTAINTED_on</target>
        </trans-unit>
        <trans-unit id="0daba26132d99fae2f657acc44a21ff8e035bd1a" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST</source>
          <target state="translated">SvTHINKFIRST</target>
        </trans-unit>
        <trans-unit id="d644182b7fecca2e84a27663743f7d7d1731110e" translate="yes" xml:space="preserve">
          <source>SvTHINKFIRST sometimes produces false positives. In those cases sv_force_normal does nothing.</source>
          <target state="translated">SvTHINKFIRST 有时会产生假阳性。在这种情况下,sv_force_normal什么也不做。</target>
        </trans-unit>
        <trans-unit id="2b4f8344aad95fbd47f327c9ffb82473442fdc07" translate="yes" xml:space="preserve">
          <source>SvTRUE</source>
          <target state="translated">SvTRUE</target>
        </trans-unit>
        <trans-unit id="5591dda75f8cb8334b1aa5f7592580f0e1465a90" translate="yes" xml:space="preserve">
          <source>SvTRUE_nomg</source>
          <target state="translated">SvTRUE_nomg</target>
        </trans-unit>
        <trans-unit id="ef07939a32727e62f23ab3bf8294ee0ae227b03b" translate="yes" xml:space="preserve">
          <source>SvTRUEx</source>
          <target state="translated">SvTRUEx</target>
        </trans-unit>
        <trans-unit id="d0b53af1ac0ffb7024eea6f6ecb8a708b9c38980" translate="yes" xml:space="preserve">
          <source>SvTYPE</source>
          <target state="translated">SvTYPE</target>
        </trans-unit>
        <trans-unit id="b775bed176614e9a49e8732c4986d2b2525760f8" translate="yes" xml:space="preserve">
          <source>SvUNLOCK</source>
          <target state="translated">SvUNLOCK</target>
        </trans-unit>
        <trans-unit id="54b59fb943f1a8c6fc241231137d882737d769f5" translate="yes" xml:space="preserve">
          <source>SvUOK</source>
          <target state="translated">SvUOK</target>
        </trans-unit>
        <trans-unit id="a5569c2ff8aba92fd99ba9b2df30c443b34a6f1f" translate="yes" xml:space="preserve">
          <source>SvUPGRADE</source>
          <target state="translated">SvUPGRADE</target>
        </trans-unit>
        <trans-unit id="4cd670c5feb308ed3b15e5b58b2f681b4c5bb579" translate="yes" xml:space="preserve">
          <source>SvUTF8</source>
          <target state="translated">SvUTF8</target>
        </trans-unit>
        <trans-unit id="12aa020f8a66c3e1d0a998e5c7796999c4211ab4" translate="yes" xml:space="preserve">
          <source>SvUTF8_off</source>
          <target state="translated">SvUTF8_off</target>
        </trans-unit>
        <trans-unit id="31712c4817da7a521357a0236b626c9b62700a5d" translate="yes" xml:space="preserve">
          <source>SvUTF8_on</source>
          <target state="translated">SvUTF8_on</target>
        </trans-unit>
        <trans-unit id="97e374818598ae8696854ce66ebfe26153cf81d6" translate="yes" xml:space="preserve">
          <source>SvUV</source>
          <target state="translated">SvUV</target>
        </trans-unit>
        <trans-unit id="1c39bfc4cdacb7f60ffec9b7097060595b0abf27" translate="yes" xml:space="preserve">
          <source>SvUVX</source>
          <target state="translated">SvUVX</target>
        </trans-unit>
        <trans-unit id="cf7246c4c0c7e22abb4930c099853bf5a86af5d1" translate="yes" xml:space="preserve">
          <source>SvUVXx</source>
          <target state="translated">SvUVXx</target>
        </trans-unit>
        <trans-unit id="37b28974a3152d2c3de1c657d9b3df720c807e0b" translate="yes" xml:space="preserve">
          <source>SvUV_nomg</source>
          <target state="translated">SvUV_nomg</target>
        </trans-unit>
        <trans-unit id="728d716b7fe1f957388320e1810e447969265d9c" translate="yes" xml:space="preserve">
          <source>SvUV_set</source>
          <target state="translated">SvUV_set</target>
        </trans-unit>
        <trans-unit id="f0070f4312b6d3c4e9753ebbebd42cc576a21cc7" translate="yes" xml:space="preserve">
          <source>SvUVx</source>
          <target state="translated">SvUVx</target>
        </trans-unit>
        <trans-unit id="2b2c80bf0f6f562d3d900c990060affb4cc3cdbb" translate="yes" xml:space="preserve">
          <source>SvVOK</source>
          <target state="translated">SvVOK</target>
        </trans-unit>
        <trans-unit id="72ddd2b619af6d6a73febf80f7fcad22495498cd" translate="yes" xml:space="preserve">
          <source>Sweden</source>
          <target state="translated">Sweden</target>
        </trans-unit>
        <trans-unit id="d1e609cdf540975b2ef838162ca1765da2f782c9" translate="yes" xml:space="preserve">
          <source>Switch (?(condition)... contains too many branches in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388b56e3569a3c2f26662f9bd0bad1aef19a414d" translate="yes" xml:space="preserve">
          <source>Switch (?(condition)... not terminated in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d140830d04307683300b42c263a4bad9b2b05e6" translate="yes" xml:space="preserve">
          <source>Switch Statements</source>
          <target state="translated">开关语句</target>
        </trans-unit>
        <trans-unit id="81f3afb94b79b127f4ba3f323efbf6b5702494d6" translate="yes" xml:space="preserve">
          <source>Switch condition not recognized in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd9a48c2b8a06497ad155d8fb2e22e3efb40ec2" translate="yes" xml:space="preserve">
          <source>Switch off optimizations.</source>
          <target state="translated">关闭优化。</target>
        </trans-unit>
        <trans-unit id="3bb7fa365adb6d9413c8c9a8c7435723660691af" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; statement. If</source>
          <target state="translated">切换到查看其他文件或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 语句。如果</target>
        </trans-unit>
        <trans-unit id="d701d90d00f98c308677ac71f008ef2cd2b1b580" translate="yes" xml:space="preserve">
          <source>Switch to viewing a different file or &lt;code&gt;eval&lt;/code&gt; statement. If</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc7caf5e748552e870fbdf8c7d017c5fa6cf84c" translate="yes" xml:space="preserve">
          <source>Switched to JSON serialization from YAML</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941726dc5468b689bfb5334269ab159c8c5ac044" translate="yes" xml:space="preserve">
          <source>Switches On the &quot;#!&quot; Line</source>
          <target state="translated">开启 &quot;#!&quot;。线</target>
        </trans-unit>
        <trans-unit id="22865b749e47c4f80690e8fbf02747aa53e87248" translate="yes" xml:space="preserve">
          <source>Switches include:</source>
          <target state="translated">开关包括:</target>
        </trans-unit>
        <trans-unit id="1a104dee1272b5ea48fa02cf2cd55d0cf5980bda" translate="yes" xml:space="preserve">
          <source>Switches which take an argument don't care whether there is a space between the switch and the argument. If unspecified switches are found on the command-line, the user will be warned that an unknown option was given.</source>
          <target state="translated">接受参数的开关不关心开关和参数之间是否有空格。如果在命令行中发现了未指定的开关,用户会被警告说是一个未知的选项。</target>
        </trans-unit>
        <trans-unit id="88a10266365bec895433e46eaf4bb0d9f4319fa6" translate="yes" xml:space="preserve">
          <source>Switching in a loop</source>
          <target state="translated">循环切换</target>
        </trans-unit>
        <trans-unit id="77dcd849e550afec3c83d38fcc8cbc72c058f4db" translate="yes" xml:space="preserve">
          <source>Switzerland</source>
          <target state="translated">Switzerland</target>
        </trans-unit>
        <trans-unit id="c4833a3fbcd559394f2c58d1f54c950e1415a542" translate="yes" xml:space="preserve">
          <source>Sx is an interface to the Athena widget set which comes with X, but again it appears not to be much used nowadays.</source>
          <target state="translated">Sx是X自带的雅典娜小部件集的接口,但现在似乎又不怎么用了。</target>
        </trans-unit>
        <trans-unit id="cd32c48fcfdab7a133c532cff3d2d0c939be7f22" translate="yes" xml:space="preserve">
          <source>Symbian</source>
          <target state="translated">Symbian</target>
        </trans-unit>
        <trans-unit id="899b34f07ea283295bd5ac5271424c60aff58966" translate="yes" xml:space="preserve">
          <source>Symbian (Series 60 v3, 3.2 and 5 - what else?)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="6f23f00b2c5559251a269c3e95612a03f0fa5304" translate="yes" xml:space="preserve">
          <source>Symbol - manipulate Perl symbols and their names</source>
          <target state="translated">Symbol-操作Perl符号和它们的名称</target>
        </trans-unit>
        <trans-unit id="e2434de5e406913ebf6a3ac33e80e10d4a315aea" translate="yes" xml:space="preserve">
          <source>Symbol Encodings</source>
          <target state="translated">符号编码</target>
        </trans-unit>
        <trans-unit id="d794fc2c3b0c30f40edbe0d808d2368ffeb21d98" translate="yes" xml:space="preserve">
          <source>Symbol Tables</source>
          <target state="translated">符号表</target>
        </trans-unit>
        <trans-unit id="4b05d7078c77af4d667a4898e87b6c3188ae4b11" translate="yes" xml:space="preserve">
          <source>Symbolic Calculator</source>
          <target state="translated">符号计算器</target>
        </trans-unit>
        <trans-unit id="37008620b710f26771f72ef684d0d762ce0c312d" translate="yes" xml:space="preserve">
          <source>Symbolic Links</source>
          <target state="translated">符号链接</target>
        </trans-unit>
        <trans-unit id="d0a9fa28cc57e07ecbedf349e28f66a417dbd550" translate="yes" xml:space="preserve">
          <source>Symbolic Unary Operators</source>
          <target state="translated">符号统一运算符</target>
        </trans-unit>
        <trans-unit id="c85b29041363945d0d38e6dd76ab2012cab61284" translate="yes" xml:space="preserve">
          <source>Symbolic links will be replicated in the destination directory. If &lt;b&gt;-l&lt;/b&gt; is not specified, then links are skipped over.</source>
          <target state="translated">符号链接将复制到目标目录中。如果未指定&lt;b&gt;-l&lt;/b&gt;，则跳过链接。</target>
        </trans-unit>
        <trans-unit id="5740fe00b50befc25ecdbfe2ce1dcb268f365ae5" translate="yes" xml:space="preserve">
          <source>Symbolic methods</source>
          <target state="translated">符号方法</target>
        </trans-unit>
        <trans-unit id="2ed5a46b240bca78e1ebda87bbf53e151430ff41" translate="yes" xml:space="preserve">
          <source>Symbolic references</source>
          <target state="translated">符号参考</target>
        </trans-unit>
        <trans-unit id="11ea83f8147883e582553aebb48729beba5bdaf1" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 编译指示时，禁止使用符号引用。它们不是真正的引用，因此没有引用计数或垃圾回收。</target>
        </trans-unit>
        <trans-unit id="af9f81a30b480e3a5214ee12ab8f0ac2f3b093d2" translate="yes" xml:space="preserve">
          <source>Symbolic references are forbidden under the &lt;code&gt;use strict&lt;/code&gt; pragma. They are not true references and consequently are not reference-counted or garbage-collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3d231a255923086dc7e82179bb6e9c216f886c" translate="yes" xml:space="preserve">
          <source>Symbolic references are names of variables or other objects, just as a symbolic link in a Unix filesystem contains merely the name of a file. The &lt;code&gt;*glob&lt;/code&gt; notation is something of a symbolic reference. (Symbolic references are sometimes called &quot;soft references&quot;, but please don't call them that; references are confusing enough without useless synonyms.)</source>
          <target state="translated">符号引用是变量或其他对象的名称，就像Unix文件系统中的符号链接仅包含文件名一样。在 &lt;code&gt;*glob&lt;/code&gt; 符号是一个象征性的参考的东西。（符号引用有时被称为&amp;ldquo;软引用&amp;rdquo;，但是请不要这样称呼；没有无用同义词的引用会引起混乱。）</target>
        </trans-unit>
        <trans-unit id="7eb647835a30e5a1bbf74157fa14f494b596a5c9" translate="yes" xml:space="preserve">
          <source>Symbols representing the concepts &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;xor&amp;rdquo;, and &amp;ldquo;not&amp;rdquo;.</source>
          <target state="translated">代表概念&amp;ldquo;和&amp;rdquo;，&amp;ldquo;或&amp;rdquo;，&amp;ldquo;异或&amp;rdquo;和&amp;ldquo;非&amp;rdquo;的符号。</target>
        </trans-unit>
        <trans-unit id="bc32943d7841b88a1cf40309071785aab7d4e9d1" translate="yes" xml:space="preserve">
          <source>Synchronization and control</source>
          <target state="translated">同步和控制</target>
        </trans-unit>
        <trans-unit id="3cea5373055c1ded68843107ad2f2e539bd093c5" translate="yes" xml:space="preserve">
          <source>Synology manufactures a vast number of Network Attached Storage (NAS) devices that are very popular in large organisations as well as small businesses and homes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6877f381ee0675d5bd925a8ea887b401ae7a51" translate="yes" xml:space="preserve">
          <source>Synonymous options (like both the short and long forms) are separated by a comma and a space on the same &lt;code&gt;=item&lt;/code&gt; line, or optionally listed as their own item with a reference to the canonical name. For example, since &lt;b&gt;--section&lt;/b&gt; can also be written as &lt;b&gt;-s&lt;/b&gt;, the above would be:</source>
          <target state="translated">同义选项（如短格式和长格式）在同一 &lt;code&gt;=item&lt;/code&gt; 行上用逗号和空格分隔，或者可以选择将其作为自己的项目列出，并引用规范名称。例如，由于&lt;b&gt;--section&lt;/b&gt;也可以写为&lt;b&gt;-s&lt;/b&gt;，因此上述内容将是：</target>
        </trans-unit>
        <trans-unit id="fcbf093f7bdc572a445b9a43606c7f7a83836b33" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;recipient&lt;/code&gt; 同义词。</target>
        </trans-unit>
        <trans-unit id="79fdd2d4dec4b005410dc78b4fc5a2b54509cf1c" translate="yes" xml:space="preserve">
          <source>Synonyms for &lt;code&gt;recipient&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="af5f0a5e089ff24df87876664a300fc1d94de87c" translate="yes" xml:space="preserve">
          <source>Synopsis:</source>
          <target state="translated">Synopsis:</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="69c40972b3eb05b16c311ef5e1e2135fa3fd9faa" translate="yes" xml:space="preserve">
          <source>Syntax error in (?[...]) in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb07c71de4335da146595d32e9320b5a8140d2f2" translate="yes" xml:space="preserve">
          <source>Syntax error in =encoding directive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e90738f5d4b2229f3a4c124484c36b1275df5262" translate="yes" xml:space="preserve">
          <source>Syntax for invoking shar, tar and zip differs from that for Unix.</source>
          <target state="translated">调用shar、tar和zip的语法与Unix的不同。</target>
        </trans-unit>
        <trans-unit id="7d8c7607abfe852f9a6ad8648332314d9917e637" translate="yes" xml:space="preserve">
          <source>Syntax of Attribute Lists</source>
          <target state="translated">属性列表的语法</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="be3351180e2a37f5c7ceb3ef2e3724ddf7a09419" translate="yes" xml:space="preserve">
          <source>Syohei YOSHIDA &amp;lt;syohex@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0785d5c2121b7134c4af7c65680f001acb76a92c" translate="yes" xml:space="preserve">
          <source>Sys$Library</source>
          <target state="translated">Sys$Library</target>
        </trans-unit>
        <trans-unit id="65fb3d73b0b7d628e2887a67776fd305bc37b9e6" translate="yes" xml:space="preserve">
          <source>Sys$Share</source>
          <target state="translated">Sys$Share</target>
        </trans-unit>
        <trans-unit id="dbb39438e97d2bc740ddc791cb728708fa6deab2" translate="yes" xml:space="preserve">
          <source>Sys$System:</source>
          <target state="translated">Sys$System:</target>
        </trans-unit>
        <trans-unit id="48fee1621e8e0fbac3a51bb7b722933258b770f4" translate="yes" xml:space="preserve">
          <source>Sys::Hostname</source>
          <target state="translated">Sys::Hostname</target>
        </trans-unit>
        <trans-unit id="2e415aac42b72faad3c72367e40e8717dbc66b3c" translate="yes" xml:space="preserve">
          <source>Sys::Hostname - Try every conceivable way to get hostname</source>
          <target state="translated">Sys::Hostname-尝试所有能想到的方法来获取主机名。</target>
        </trans-unit>
        <trans-unit id="c1e878d92efc49a2e4d7c74bab56ecb4df79e136" translate="yes" xml:space="preserve">
          <source>Sys::Syslog</source>
          <target state="translated">Sys::Syslog</target>
        </trans-unit>
        <trans-unit id="d0e7c26b96f1913c444745d08172cdce4e0c92fa" translate="yes" xml:space="preserve">
          <source>Sys::Syslog - Perl interface to the UNIX syslog(3) calls</source>
          <target state="translated">Sys::Syslog-连接 UNIX syslog(3)调用的 Perl 接口。</target>
        </trans-unit>
        <trans-unit id="70083380e8efc0c90f74c992ef02124b7c1f9076" translate="yes" xml:space="preserve">
          <source>Sys::Syslog::Win32</source>
          <target state="translated">Sys::Syslog::Win32</target>
        </trans-unit>
        <trans-unit id="cfe74b88debb47d505f4b0c08319f0ca059d43ec" translate="yes" xml:space="preserve">
          <source>Sys::Syslog::Win32 - Win32 support for Sys::Syslog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c9e6fce8c27f1db38faca8727f60ffbd03b1df" translate="yes" xml:space="preserve">
          <source>SysV IPC</source>
          <target state="translated">SysV IPC</target>
        </trans-unit>
        <trans-unit id="b769fe98988d4570b7169913197897773fb46367" translate="yes" xml:space="preserve">
          <source>SysV Msg IPC object class</source>
          <target state="translated">SysV Msg IPC对象类</target>
        </trans-unit>
        <trans-unit id="1b5cd833684b7ef6a59dab44ff94b295bccc40b4" translate="yes" xml:space="preserve">
          <source>SysV Semaphore IPC object class</source>
          <target state="translated">SysV Semaphore IPC对象类。</target>
        </trans-unit>
        <trans-unit id="71c44529ecac23b5c9809ec7a57f43fadf59d867" translate="yes" xml:space="preserve">
          <source>SysV Shared Memory IPC object class</source>
          <target state="translated">SysV 共享内存 IPC 对象类</target>
        </trans-unit>
        <trans-unit id="40f6355398d4cc8e6d990f10eb780e3725d4416e" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno). Note that some system calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45e7e358eb9351a96a4b4d44c0db473a81b0bd0" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall返回其调用的系统调用返回的任何值。如果系统调用失败，则 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。请注意，某些系统调用</target>
        </trans-unit>
        <trans-unit id="e0b761d47162708932873aa746a0b31a4af21afe" translate="yes" xml:space="preserve">
          <source>Syscall returns whatever value returned by the system call it calls. If the system call fails, &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno). Note that some system calls</source>
          <target state="translated">Syscall返回其调用的系统调用返回的任何值。如果系统调用失败，则 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。请注意，某些系统调用</target>
        </trans-unit>
        <trans-unit id="53aa71666c5046c70bdb9cfa19d05f3e5e2dbe70" translate="yes" xml:space="preserve">
          <source>Syslogging with Perl</source>
          <target state="translated">用Perl做系统日志</target>
        </trans-unit>
        <trans-unit id="b9c23727af44d87276c73142b1bbc56acfa2ff99" translate="yes" xml:space="preserve">
          <source>Sysroot.U</source>
          <target state="translated">Sysroot.U</target>
        </trans-unit>
        <trans-unit id="80c0b230762f1b4764b9bec6b3b1ff958262b7bd" translate="yes" xml:space="preserve">
          <source>System CPU Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286ad58c359f169cf560ed965ca49713b4161be5" translate="yes" xml:space="preserve">
          <source>System Interaction</source>
          <target state="translated">系统交互</target>
        </trans-unit>
        <trans-unit id="a5f5e2adb8b84a09a3496b92bfc8ae6f7818b5f8" translate="yes" xml:space="preserve">
          <source>System Resources</source>
          <target state="translated">系统资源</target>
        </trans-unit>
        <trans-unit id="12920688fafa23a0e3538825316e84488141b30c" translate="yes" xml:space="preserve">
          <source>System Specifics</source>
          <target state="translated">系统特性</target>
        </trans-unit>
        <trans-unit id="d6112adb659d79581ddf0b5cc4c94caed341f770" translate="yes" xml:space="preserve">
          <source>System V %s is not implemented on this machine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c80f9799bbc3cebb5501e8db9a2d073ae25632e" translate="yes" xml:space="preserve">
          <source>System V IPC constants and system calls</source>
          <target state="translated">系统五 IPC 常量和系统调用</target>
        </trans-unit>
        <trans-unit id="c4b08ad7296a6185b44d15785cd2e71597984993" translate="yes" xml:space="preserve">
          <source>System V interprocess communication functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16956db37d0c77a530acbdbc4b5059785173084f" translate="yes" xml:space="preserve">
          <source>System calls accept either &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;\&lt;/code&gt; as the path separator. However, many command-line utilities of DOS vintage treat &lt;code&gt;/&lt;/code&gt; as the option prefix, so may get confused by filenames containing &lt;code&gt;/&lt;/code&gt;. Aside from calling any external programs, &lt;code&gt;/&lt;/code&gt; will work just fine, and probably better, as it is more consistent with popular usage, and avoids the problem of remembering what to backwhack and what not to.</source>
          <target state="translated">系统调用接受 &lt;code&gt;/&lt;/code&gt; 或 &lt;code&gt;\&lt;/code&gt; 作为路径分隔符。但是，许多DOS vintage的命令行实用程序都将 &lt;code&gt;/&lt;/code&gt; 当作选项前缀，因此可能会对包含 &lt;code&gt;/&lt;/code&gt; 的文件名感到困惑。除了调用任何外部程序外， &lt;code&gt;/&lt;/code&gt; 可以很好地工作，并且可能会更好，因为它与流行用法更加一致，并且避免了记住要反击什么和不反击什么的问题。</target>
        </trans-unit>
        <trans-unit id="4f24e94ced298a298739ba1339ef795f85bd6541" translate="yes" xml:space="preserve">
          <source>System calls at compile time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="007271cb98a5608fe64c06188e43289d61f1c7bd" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="translated">系统调用在错误时返回-1（将ERRNO设置为原因），在错误时返回（通常）为0。如果返回值为-1，则此类型映射将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。如果返回值不是-1，则此类型映射将0（perl false）转换为&amp;ldquo; 0 but true&amp;rdquo;（perl true）或返回值本身，以指示命令成功。</target>
        </trans-unit>
        <trans-unit id="2359b820aa0452b65508553cdd45209d3b858de3" translate="yes" xml:space="preserve">
          <source>System calls return -1 on error (setting ERRNO with the reason) and (usually) 0 on success. If the return value is -1 this typemap returns &lt;code&gt;undef&lt;/code&gt;. If the return value is not -1, this typemap translates a 0 (perl false) to &quot;0 but true&quot; (which is perl true) or returns the value itself, to indicate that the command succeeded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb78d5fbb36025d1ade73acf0ec1dc017253b7c6" translate="yes" xml:space="preserve">
          <source>System calls such as link(), unlink(), rename(), etc. return nonzero for success, not 0. (system(), however, returns zero for success.)</source>
          <target state="translated">系统调用如link()、unlink()、rename()等,成功时返回非零,而不是0(但system()成功时返回0)。</target>
        </trans-unit>
        <trans-unit id="a5bfc62972086e83c2f9e4d6647ba3081448737b" translate="yes" xml:space="preserve">
          <source>System errno constants</source>
          <target state="translated">系统errno常数</target>
        </trans-unit>
        <trans-unit id="0464247110efd6dc873ab7d03699ac46391aa089" translate="yes" xml:space="preserve">
          <source>SystemV Interprocess Communications:</source>
          <target state="translated">SystemV进程间通信。</target>
        </trans-unit>
        <trans-unit id="a183fb872a859df2f57021c9ab88f775bce8ce4c" translate="yes" xml:space="preserve">
          <source>Systems that don't use GDBM compatibilty for ndbm support will be using a platform specific library, possibly inherited from BSD systems, where it may or may not be safe to use an untrusted file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bae914465ea54a3f354cb49e4c193a3ffe266b8f" translate="yes" xml:space="preserve">
          <source>Systems that don't use GDBM compatibilty for old dbm support will be using a platform specific library, possibly inherited from BSD systems, where it may or may not be safe to use an untrusted file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="5217808996f069ddbc219ab5febe206f9d89f653" translate="yes" xml:space="preserve">
          <source>T2_KEEP_TEMPDIR=0</source>
          <target state="translated">T2_KEEP_TEMPDIR=0</target>
        </trans-unit>
        <trans-unit id="463b5addcced0fba1581ac4edc4526052505db59" translate="yes" xml:space="preserve">
          <source>T2_TEMPDIR_TEMPLATE='test2-XXXXXX'</source>
          <target state="translated">T2_TEMPDIR_TEMPLATE='test2-XXXXXX'</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="9f94efb44fe911a9e20566c2b4f9e9743238c25c" translate="yes" xml:space="preserve">
          <source>TABLE OF CONTENTS</source>
          <target state="translated">目 录</target>
        </trans-unit>
        <trans-unit id="3b4df05d703541d151d3e3628328bb8fd532308b" translate="yes" xml:space="preserve">
          <source>TAP GRAMMAR</source>
          <target state="translated">录音带语法</target>
        </trans-unit>
        <trans-unit id="1920029d62435d8577df2572dd0096bfaff76178" translate="yes" xml:space="preserve">
          <source>TAP pragma token.</source>
          <target state="translated">TAP pragma token。</target>
        </trans-unit>
        <trans-unit id="a6ad0c7cbda3b41f87bebc3eecd396afa503fee6" translate="yes" xml:space="preserve">
          <source>TAP syntax version token.</source>
          <target state="translated">TAP语法版本令牌。</target>
        </trans-unit>
        <trans-unit id="3876ffd2c762f78e88b10fd7b5ed6b67ff853ed5" translate="yes" xml:space="preserve">
          <source>TAP::Base</source>
          <target state="translated">TAP::Base</target>
        </trans-unit>
        <trans-unit id="9b1c8b8b7e60c2d2e7b147def758851a2032505c" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393bbdfe5b0291f7582e0a00a859897a43f52662" translate="yes" xml:space="preserve">
          <source>TAP::Base - Base class that provides common functionality to &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt;</source>
          <target state="translated">TAP :: Base-为&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;和&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="863c519a681845de61f18ccf2d91ed2bae4b3a87" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base</source>
          <target state="translated">TAP::Formatter::Base</target>
        </trans-unit>
        <trans-unit id="2219301c0e6ab7a0cac653627940a66913b4e00c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Base - Base class for harness output delegates</source>
          <target state="translated">TAP::Formatter::Base-harness输出委托的基础类。</target>
        </trans-unit>
        <trans-unit id="737a5324c5901c02f42ad717687b54b1dafd7c3b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color</source>
          <target state="translated">TAP::Formatter::Color</target>
        </trans-unit>
        <trans-unit id="83dc9a13e5e40b4cace713c5d42771d2b5bb47e0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Color - Run Perl test scripts with color</source>
          <target state="translated">TAP::Formatter::Color-使用颜色运行Perl测试脚本。</target>
        </trans-unit>
        <trans-unit id="de057ff7c6b5e40851d3c50d32e9750e339c5926" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console</source>
          <target state="translated">TAP::Formatter::Console</target>
        </trans-unit>
        <trans-unit id="e5caa85b06270fe34451b375ee12674e638dd733" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console - Harness output delegate for default console output</source>
          <target state="translated">TAP::Formatter::Console-驾驭输出委托,用于默认的控制台输出。</target>
        </trans-unit>
        <trans-unit id="01b7c503e4f8a4af70b89b685b263fa99a7779a7" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession</target>
        </trans-unit>
        <trans-unit id="db7bd0c049621f91358c7128fbd5472680ec6d31" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::ParallelSession - Harness output delegate for parallel console output</source>
          <target state="translated">TAP::Formatter::Console::ParallelSession-驾驭并行控制台输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="e10aa0877a249858e704e343610555a15b6331f0" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session</source>
          <target state="translated">TAP::Formatter::Console::Session</target>
        </trans-unit>
        <trans-unit id="617e83a9b0bba0c6a87c6403d55512035b5d4331" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Console::Session - Harness output delegate for default console output</source>
          <target state="translated">TAP::Formatter::Console::Session-驾驭默认控制台输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="ebcc51d604eabcfa523d96f91dc1b0eb51dccb7d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File</source>
          <target state="translated">TAP::Formatter::File</target>
        </trans-unit>
        <trans-unit id="ce9e5131d6998f180ee6abe8bad4643f869cfb3d" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File - Harness output delegate for file output</source>
          <target state="translated">TAP::Formatter::File-用于文件输出的输出委托。</target>
        </trans-unit>
        <trans-unit id="5a53ebb59dd4ba13f5939d6a9f81cddf3e1c6f45" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session</source>
          <target state="translated">TAP::Formatter::File::Session</target>
        </trans-unit>
        <trans-unit id="360d8f026e4e5483612bf0275831836f9ffb249f" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::File::Session - Harness output delegate for file output</source>
          <target state="translated">TAP::Formatter::File::Session-驾驭文件输出的输出委托人</target>
        </trans-unit>
        <trans-unit id="46af53bbf8c7eee3da8d825fcace74fe474d232b" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session</source>
          <target state="translated">TAP::Formatter::Session</target>
        </trans-unit>
        <trans-unit id="c2df33c30bd450c40b146c186ea09c6cab11e56c" translate="yes" xml:space="preserve">
          <source>TAP::Formatter::Session - Abstract base class for harness output delegate</source>
          <target state="translated">TAP::Formatter::Session-驾驭输出委托的抽象基类。</target>
        </trans-unit>
        <trans-unit id="93ebad31adfaf596a987126afe3d7a3f18d93c05" translate="yes" xml:space="preserve">
          <source>TAP::Harness</source>
          <target state="translated">TAP::Harness</target>
        </trans-unit>
        <trans-unit id="b7d5d266f7a8edc064e0b8c710521d51a2bc894a" translate="yes" xml:space="preserve">
          <source>TAP::Harness - Run test scripts with statistics</source>
          <target state="translated">TAP::Harness-使用统计数据运行测试脚本。</target>
        </trans-unit>
        <trans-unit id="a28a3f4d3229f49494c71baca96520e2ecfb6ce6" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env</source>
          <target state="translated">TAP::Harness::Env</target>
        </trans-unit>
        <trans-unit id="91f28a5a62ef8f799cd7525ba0b5759ca2448d9c" translate="yes" xml:space="preserve">
          <source>TAP::Harness::Env - Parsing harness related environmental variables where appropriate</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a70a46bfa38bc1216fe94cb04afcea34c7e8685" translate="yes" xml:space="preserve">
          <source>TAP::Object</source>
          <target state="translated">TAP::Object</target>
        </trans-unit>
        <trans-unit id="f09e3a92ac29a0ecd8a4f02097d67c9251bfb4fd" translate="yes" xml:space="preserve">
          <source>TAP::Object - Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">TAP :: Object-为所有 &lt;code&gt;TAP::*&lt;/code&gt; 模块提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="73c55e213830c688e72c24e7e2dc38927a8f526e" translate="yes" xml:space="preserve">
          <source>TAP::Parser</source>
          <target state="translated">TAP::Parser</target>
        </trans-unit>
        <trans-unit id="f762f998d40c617b51b08688208676705b948fa6" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f07ed865105b4fe8e06f2ed0ef74d2249f0ce1b" translate="yes" xml:space="preserve">
          <source>TAP::Parser - Parse &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt; output</source>
          <target state="translated">TAP :: Parser-解析&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::TAP&quot;&gt;TAP&lt;/a&gt;输出</target>
        </trans-unit>
        <trans-unit id="947140d84d6dc3586ce66227c8fbf3b5502269bb" translate="yes" xml:space="preserve">
          <source>TAP::Parser also supports callbacks; bailout, comment, plan, test, unknown, version and yaml are called for the corresponding TAP result types, ALL is called for all results, ELSE is called for all results for which a named callback is not installed and EOF is called once at the end of each TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a216f40bfe5d8c4e9f480503b3353a997f25d9e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator</source>
          <target state="translated">TAP::Parser::Aggregator</target>
        </trans-unit>
        <trans-unit id="29967243373ff3c2847efa03292cf1394ade91bf" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Aggregator - Aggregate TAP::Parser results</source>
          <target state="translated">TAP::Parser::Aggregator-Aggregate TAP::Parser results</target>
        </trans-unit>
        <trans-unit id="ea252a87adf45624e0915f082cf3a171691e2b87" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar</source>
          <target state="translated">TAP::Parser::Grammar</target>
        </trans-unit>
        <trans-unit id="99d73c9149822b89f098465b0ef15b6e5e432ba4" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Grammar - A grammar for the Test Anything Protocol.</source>
          <target state="translated">TAP::Parser::Grammar-Test Anything Protocol 的语法。</target>
        </trans-unit>
        <trans-unit id="f66dcc18cf605bab72f282216bf437fafae85c73" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator</source>
          <target state="translated">TAP::Parser::Iterator</target>
        </trans-unit>
        <trans-unit id="d222e4542e0f93a9f4cabc8a65b724fcc86515cd" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator - Base class for TAP source iterators</source>
          <target state="translated">TAP::Parser::Iterator-TAP源迭代器的基类。</target>
        </trans-unit>
        <trans-unit id="599e631b6f320b3fc47ee504d90a3e175b821f4e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array</source>
          <target state="translated">TAP::Parser::Iterator::Array</target>
        </trans-unit>
        <trans-unit id="8849b72265bccd1154b20c5bcfd79b6177e1d979" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Array - Iterator for array-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Array-基于数组的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="8afb640018f748c7abac8e508f78557fe8689509" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process</source>
          <target state="translated">TAP::Parser::Iterator::Process</target>
        </trans-unit>
        <trans-unit id="ef61fd1ef2ee2ba4a706833aed0bb08fe84a24ba" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Process - Iterator for process-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Process-用于基于过程的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="c97751b26f9e6df1ee3c0a7feabeda4e0d9102c3" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream</source>
          <target state="translated">TAP::Parser::Iterator::Stream</target>
        </trans-unit>
        <trans-unit id="be38f68275dc99a67c8ac1d8cfd48bb032de4d4a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Iterator::Stream - Iterator for filehandle-based TAP sources</source>
          <target state="translated">TAP::Parser::Iterator::Stream-用于基于文件柄的TAP源的迭代器。</target>
        </trans-unit>
        <trans-unit id="d89bed7b6f6d5d165f751cac2ac0a13e2dd7f697" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory</source>
          <target state="translated">TAP::Parser::IteratorFactory</target>
        </trans-unit>
        <trans-unit id="8d39f8677b4d63ea3260e5507a930c994a438d70" translate="yes" xml:space="preserve">
          <source>TAP::Parser::IteratorFactory - Figures out which SourceHandler objects to use for a given Source</source>
          <target state="translated">TAP::Parser::IteratorFactory-计算出要为给定的Source使用哪些SourceHandler对象。</target>
        </trans-unit>
        <trans-unit id="6f50fafc730902e3aa24fa13c0c429b89a2cc1ff" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer</source>
          <target state="translated">TAP::Parser::Multiplexer</target>
        </trans-unit>
        <trans-unit id="2da48d5d830b8cd9138d15d18237febc28e0b498" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Multiplexer - Multiplex multiple TAP::Parsers</source>
          <target state="translated">TAP::解析器::多路复用器-多路复用多个TAP::解析器。</target>
        </trans-unit>
        <trans-unit id="3c077c3ce874909f47ae77cbcca2c04344198e5b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result</source>
          <target state="translated">TAP::Parser::Result</target>
        </trans-unit>
        <trans-unit id="a422082a9e255b156b40569483bd6f50f2d5a284" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result - Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::Result-TAP::Parser输出对象的基类。</target>
        </trans-unit>
        <trans-unit id="03b8058105031bc1095218a7667a2ea1b2512b1e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout</source>
          <target state="translated">TAP::Parser::Result::Bailout</target>
        </trans-unit>
        <trans-unit id="00f4b677e9dddb24581e9ed004b7470cf77a617e" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Bailout - Bailout result token.</source>
          <target state="translated">TAP::Parser::Result::Bailout-Bailout result token。</target>
        </trans-unit>
        <trans-unit id="afba56eaac641feaac3daf9f840411e87ecf1e14" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment</source>
          <target state="translated">TAP::Parser::Result::Comment</target>
        </trans-unit>
        <trans-unit id="15ac19d49aebc2fdbf7a430ac512a0c55bc03548" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Comment - Comment result token.</source>
          <target state="translated">TAP::Parser::Result::Comment-评论结果标记。</target>
        </trans-unit>
        <trans-unit id="8028e0720d8ec37d7287bdb1bc7450078b0bf251" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan</source>
          <target state="translated">TAP::Parser::Result::Plan</target>
        </trans-unit>
        <trans-unit id="4383859286c921d76add9716628e055668e9e51d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Plan - Plan result token.</source>
          <target state="translated">TAP::Parser::Result::Plan-计划结果标记。</target>
        </trans-unit>
        <trans-unit id="f69e80305022a26d3e2f7acc2b0ed1b953372499" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma</source>
          <target state="translated">TAP::Parser::Result::Pragma</target>
        </trans-unit>
        <trans-unit id="14e0c88ebea6563cf55ee8c08b3b9ed300f0d20c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Pragma - TAP pragma token.</source>
          <target state="translated">TAP::Parser::Result::Pragma-TAP pragma token。</target>
        </trans-unit>
        <trans-unit id="2c91344b1f933a9487eebefc220df8812b008445" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test</source>
          <target state="translated">TAP::Parser::Result::Test</target>
        </trans-unit>
        <trans-unit id="edc9dae5ee4fae6dd91f0295f192573a8fb6a01a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Test - Test result token.</source>
          <target state="translated">TAP::Parser::Result::Test-测试结果标记。</target>
        </trans-unit>
        <trans-unit id="44c345b7d9dc9992b3e410debbb02b0d29d66e79" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown</source>
          <target state="translated">TAP::Parser::Result::Unknown</target>
        </trans-unit>
        <trans-unit id="2943117d9510c588ee4451eb94edacf47000ab69" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Unknown - Unknown result token.</source>
          <target state="translated">TAP::Parser::Result::Unknown-未知结果标记。</target>
        </trans-unit>
        <trans-unit id="c6da177c03a14aa64f029674caca24adf3980051" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version</source>
          <target state="translated">TAP::Parser::Result::Version</target>
        </trans-unit>
        <trans-unit id="57883e95518fac69c11831c9fff6d78815a22b85" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::Version - TAP syntax version token.</source>
          <target state="translated">TAP::Parser::Result::Version-TAP语法版本标记。</target>
        </trans-unit>
        <trans-unit id="0f318e8c966222dedab8b0415294cae97d5f4f64" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML</source>
          <target state="translated">TAP::Parser::Result::YAML</target>
        </trans-unit>
        <trans-unit id="68efbf9d5d727c77c2280206016668c939f6f897" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Result::YAML - YAML result token.</source>
          <target state="translated">TAP::Parser::Result::YAML-YAML结果标记。</target>
        </trans-unit>
        <trans-unit id="1a3c6d732b12248b1b6d9e14cf320584eb0a7af0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory</source>
          <target state="translated">TAP::Parser::ResultFactory</target>
        </trans-unit>
        <trans-unit id="4f51e316d0426f94634c75bc33e9099d8d304e39" translate="yes" xml:space="preserve">
          <source>TAP::Parser::ResultFactory - Factory for creating TAP::Parser output objects</source>
          <target state="translated">TAP::Parser::ResultFactory-用于创建TAP::Parser输出对象的工厂。</target>
        </trans-unit>
        <trans-unit id="50d7a126914ae0138b7bdc512d9ccd5a5d77784d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler</source>
          <target state="translated">TAP::Parser::Scheduler</target>
        </trans-unit>
        <trans-unit id="6da57a5308e690ad2cdb39023741e3d016f8b96b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler - Schedule tests during parallel testing</source>
          <target state="translated">TAP::Parser::Scheduler-在并行测试中安排测试。</target>
        </trans-unit>
        <trans-unit id="81a373608790f502b94224968ea5fc04bfbb7622" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job</source>
          <target state="translated">TAP::Parser::Scheduler::Job</target>
        </trans-unit>
        <trans-unit id="657d2fb895dc4c666b37510d12e2199629196955" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Job - A single testing job.</source>
          <target state="translated">TAP::Parser::Scheduler::Job-一个单一的测试作业。</target>
        </trans-unit>
        <trans-unit id="5f18e879edab289da9e626ab0da6617557a360e9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner</target>
        </trans-unit>
        <trans-unit id="73c0394de64be963748b5ce71edfd4ac21a6b40d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Scheduler::Spinner - A no-op job.</source>
          <target state="translated">TAP::Parser::Scheduler::Spinner-一个无操作的作业。</target>
        </trans-unit>
        <trans-unit id="223a37f35fb2a759c5993cb7f97ef9683ee5bef9" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source</source>
          <target state="translated">TAP::Parser::Source</target>
        </trans-unit>
        <trans-unit id="ba1432bca02f36d9b7eb2dec89d208a92989961b" translate="yes" xml:space="preserve">
          <source>TAP::Parser::Source - a TAP source &amp;amp; meta data about it</source>
          <target state="translated">TAP :: Parser :: Source-TAP源和有关它的元数据</target>
        </trans-unit>
        <trans-unit id="b88d422ffa232da21769ecf23f36c9215fb7316d" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler</source>
          <target state="translated">TAP::Parser::SourceHandler</target>
        </trans-unit>
        <trans-unit id="7a11e510cbf8229cb9deefa589961e1880c0ef0c" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler - Base class for different TAP source handlers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567fb9a0760765f024156fd52b7260852fb83a9f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable</source>
          <target state="translated">TAP::Parser::SourceHandler::Executable</target>
        </trans-unit>
        <trans-unit id="def5a816ec0112a978d703f8596c8df1a84fd5e0" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Executable - Stream output from an executable TAP source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7855e6a236f3f1bba1561cccffbc0253a8b41c1a" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File</source>
          <target state="translated">TAP::Parser::SourceHandler::File</target>
        </trans-unit>
        <trans-unit id="c84a46ff700384567f810cc0dbe5e4d5b91c8613" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::File - Stream TAP from a text file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75757e90ca350dfe386979f74159d3e72435290" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle</source>
          <target state="translated">TAP::Parser::SourceHandler::Handle</target>
        </trans-unit>
        <trans-unit id="b6f0bcffb30af38c06936b6bf1545dd5a83277c1" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Handle - Stream TAP from an IO::Handle or a GLOB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4545cce101afaf68b0bd75f8cbbb180c6b160964" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl</source>
          <target state="translated">TAP::Parser::SourceHandler::Perl</target>
        </trans-unit>
        <trans-unit id="04e054f8c028c674d2c9287cae69082bbf9ce520" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::Perl - Stream TAP from a Perl executable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849652a7b8f5b288e476708d89c71b634dc488c2" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP</source>
          <target state="translated">TAP::Parser::SourceHandler::RawTAP</target>
        </trans-unit>
        <trans-unit id="7fe676e21d00db4b7e1f5adc9ab5a7fc5c10349f" translate="yes" xml:space="preserve">
          <source>TAP::Parser::SourceHandler::RawTAP - Stream output from raw TAP in a scalar/array ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75366f8757d0c89dc67745e9e30ae921835fc92" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader</source>
          <target state="translated">TAP::Parser::YAMLish::Reader</target>
        </trans-unit>
        <trans-unit id="92a795f40e2bb73376fc045a4635f6fcf7d6a7de" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Reader - Read YAMLish data from iterator</source>
          <target state="translated">TAP::解析器::YAMLish::Reader-从迭代器中读取YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="08d78eef616ac71669e623449566134b1c6d4b77" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer</source>
          <target state="translated">TAP::Parser::YAMLish::Writer</target>
        </trans-unit>
        <trans-unit id="662f33223b14be1ce958a19abee31b207588ba54" translate="yes" xml:space="preserve">
          <source>TAP::Parser::YAMLish::Writer - Write YAMLish data</source>
          <target state="translated">TAP::Parser::YAMLish::Writer-写入YAMLish数据。</target>
        </trans-unit>
        <trans-unit id="5b754807c6604c3c6635f1f0f60d367a6cffd283" translate="yes" xml:space="preserve">
          <source>TAPx Developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4682dfeedc4e9ca5c57ef7dd969ecc22339454" translate="yes" xml:space="preserve">
          <source>TARG</source>
          <target state="translated">TARG</target>
        </trans-unit>
        <trans-unit id="f762108ca727f0bcd961fc7467c248887dfa70dc" translate="yes" xml:space="preserve">
          <source>TARGET</source>
          <target state="translated">TARGET</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
