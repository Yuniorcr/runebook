<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">如果左参数在数值上大于或等于右参数，则Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">如果左参数在数值上小于右参数，则二进制 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; 返回其左参数的值，该值左移右参数指定的位数。参数应为整数。（另请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">如果左参数在数值上小于或等于右参数，则二进制 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 返回-1、0或1，具体取决于左参数在数值上小于，等于还是大于右参数。如果您的平台支持 &lt;code&gt;NaN&lt;/code&gt; （非数字）作为数值，则将它们与 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; 将返回undef。 &lt;code&gt;NaN&lt;/code&gt; 不是 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;==&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; ， &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; 任何东西（甚至是 &lt;code&gt;NaN&lt;/code&gt; ），因此那5返回false。 &lt;code&gt;NaN != NaN&lt;/code&gt; 返回true， &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 将两个数字相乘。</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;**&quot;&lt;/code&gt; 是幂运算符。它的绑定比一元负数更紧密，因此 &lt;code&gt;-2**4&lt;/code&gt; 是 &lt;code&gt;-(2**4)&lt;/code&gt; ，而不是 &lt;code&gt;(-2)**4&lt;/code&gt; 。（这是使用C的 &lt;code&gt;pow(3)&lt;/code&gt; 函数实现的，该函数实际上在内部对double起作用。）</target>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 返回两个数字的和。</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 是逗号运算符。在标量上下文中，它评估其左自变量，将该值丢弃，然后评估其右自变量并返回该值。就像C的逗号运算符一样。</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 返回两个数字的差。</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 连接两个字符串。</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">二进制 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 是范围运算符，根据上下文，它实际上是两个不同的运算符。在列表上下文中，它返回从左值到右值计数（逐个递增）的值列表。如果左值大于右值，则返回空列表。范围运算符对于编写 &lt;code&gt;foreach (1..10)&lt;/code&gt; 循环以及对数组执行切片操作很有用。在当前的实现中，当将range运算符用作 &lt;code&gt;foreach&lt;/code&gt; 循环中的表达式时，不会创建任何临时数组，但是当您编写如下代码时，较旧版本的Perl可能会消耗大量内存：</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 将两个数字相除。</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">如果左参数在数值上等于右参数，则二进制 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 将标量表达式绑定到模式匹配。某些操作默认情况下会搜索或修改字符串 &lt;code&gt;$_&lt;/code&gt; 。该运算符使这种运算对其他字符串起作用。正确的参数是搜索模式，替换或音译。左参数是应该被搜索，替换或音译的东西，而不是默认的 &lt;code&gt;$_&lt;/code&gt; 。在标量环境中使用时，返回值通常表示操作成功。例外的是取代度（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ）和音译（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）与 &lt;code&gt;/r&lt;/code&gt; （非破坏性）选项，该选项使&lt;b&gt;ř&lt;/b&gt;返回值是替换的结果。列表上下文中的行为取决于特定的运算符。有关详细信息，请参见&lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp类引用运算符&lt;/a&gt;；有关使用这些运算符的示例，请参见&lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 将其操作数逐位异或在一起。</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 返回两个周围表达式的逻辑结合。它的优先级非常低，与 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 等效。这意味着它短路：仅当左表达式为true时，才对右表达式求值。</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 返回-1、0或1，具体取决于左参数是按字符串方式小于，等于还是大于右参数。</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上等于右参数，则二进制 &lt;code&gt;&quot;eq&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上大于或等于右参数，则二进制 &lt;code&gt;&quot;ge&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">如果左参数在字符串上大于右参数，则二进制 &lt;code&gt;&quot;gt&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">如果左参数在字符串上小于或等于右参数，则二进制 &lt;code&gt;&quot;le&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">如果左参数在字符串上小于右参数，则二进制 &lt;code&gt;&quot;lt&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">如果左参数沿字符串方向不等于右参数，则二进制 &lt;code&gt;&quot;ne&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">二进制 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 返回两个周围表达式的逻辑和。相当于 &lt;code&gt;||&lt;/code&gt; 除了非常低的优先级。这对于控制流很有用：</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 是重复运算符。在标量上下文中，或者如果左操作数未括在括号中，则它将返回由左操作数组成的字符串，该字符串重复右操作数指定的次数。在列表上下文中，如果左操作数用括号括起来或是由 &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; 的列表，则它会重复该列表。如果右操作数为零或负（在负数时发出警告），则根据上下文返回空字符串或空列表。</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">二进制 &lt;code&gt;&quot;xor&quot;&lt;/code&gt; 返回两个周围表达式的异或。它不能短路（当然）。</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 返回其操作数进行逐位或运算。</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;||&quot;&lt;/code&gt; 执行短路逻辑或运算。也就是说，如果左操作数为true，则甚至不会评估右操作数。如果评估标量或列表上下文，则向下传播到正确的操作数。</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 在其参数之间进行智能匹配。下一节将介绍智能匹配。</target>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">二进制向后兼容；该函数是一个宏，但也具有 &lt;code&gt;Perl_&lt;/code&gt; 实现（已导出）。</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">某些专有平台的二进制发行版可在&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;目录中找到。因为这些不是标准发行版的一部分，所以它们实际上可能确实以多种方式与基本perl端口不同。您必须查看它们各自的发行说明，以了解它们之间的区别。这些差异可以是肯定的（例如，Perl的源代码发行版中不支持的特定平台功能的扩展）或否定的（例如，可能基于最新的Perl的源代码发行版）。</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">二进制安装程序也会在你的桌面上创建一个文件夹,里面有一些有用的对象。如果你需要改变二进制安装程序工作的某些方面,请随时编辑文件------。</target>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">二进制字符串(字节字符串)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">绑定操作员</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">将一个宏中的多个语句绑定在一起</target>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像bind（2）一样，将网络地址绑定到套接字。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">就像bind（2）一样，将网络地址绑定到套接字。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell，AndrewD。《线程编程简介》。Digital Equipment Corporation，1989年，DEC-SRC研究报告＃35，网址为&lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt;（强烈建议）</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">位补码运算符 ~ And vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">位串</target>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">位是内存世界中的原子。不得已只能使用对单个位的访问，或者因为这是处理数据的最便捷方法。位字符串（解包）在包含一系列 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 个字符的字符串以及每个包含一组8位的字节序列之间转换。除了用两种方法可以将字节的内容写为位字符串外，这几乎听起来很简单。让我们看一下带注释的字节：</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">文件&lt;b&gt;所有者&lt;/b&gt;设置或取消设置的位，以允许或禁止其他人访问。当您询问文件时，这些标志位是 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 内置返回的&lt;b&gt;模式&lt;/b&gt;字的一部分。在Unix系统上，您可以检查</target>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">任何大小的位串都可以由按位运算符（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）操纵。</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">位元和</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">Bitwise Or 和 Exclusive Or</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">字符串操作符</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">位元运算符</target>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">块之间的空白线,做不同的事情。</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">受祝福的引用和类对象</target>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">将SV祝福到指定的软件包中。SV必须是RV。该软件包必须由其藏匿处指定（请参阅 &lt;code&gt;gv_stashpv()&lt;/code&gt; ）。SV的参考计数不受影响。</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">盲目地通过va_list</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">盲目使用变量宏</target>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">块名称以复合形式匹配，例如 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; 或 &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; 。与大多数其他属性不同，只有少数块名称具有Unicode定义的短名称。但是Perl确实提供了一个（不再推荐的快捷方式）快捷方式：例如，您可以说 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; 或 &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">报告正文。如果未包含在命令行中或&lt;b&gt;-f&lt;/b&gt;文件中，您将有机会编辑该消息。</target>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的粗体斜体（可能实际上是斜体）版本。Pod :: Man不假定您具有此 &lt;code&gt;CB&lt;/code&gt; ，并且默认为CB。某些系统（例如Solaris）具有此字体的 &lt;code&gt;CX&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的粗体斜体（可能实际上是斜体）版本。Pod :: Man不假定您具有此 &lt;code&gt;CB&lt;/code&gt; ，并且默认为CB。某些系统（例如Solaris）具有此字体的 &lt;code&gt;CX&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定宽度字体的加粗版本。默认为 &lt;code&gt;CB&lt;/code&gt; 。仅对&lt;b&gt;troff&lt;/b&gt;输出有效。</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定宽度字体的加粗版本。默认为 &lt;code&gt;CB&lt;/code&gt; 。仅对troff（1）输出有效。</target>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">布尔 如果此参数为true，则缺少必需的模块（或其正确版本）将是致命的。 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 将 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 而不是简单地通知用户缺少的依赖项。</target>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">Bool.如果该参数为真,则先决条件将被打印到stdout,MakeMaker将退出。如果该参数为真,则先决条件将被打印到stdout,MakeMaker将退出。输出格式是一个可评价的哈希ref。</target>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">布尔方法</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">布尔运算符</target>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">布尔选项。</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">布尔值。如果为false，则禁用在运行测试时显示的 &lt;code&gt;X/Y&lt;/code&gt; 测试计数。</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">Boolean,它告诉MakeMaker应该包含规则来制作一个perl。这是由MakeMaker作为开关自动处理的。用户通常不需要它。</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">布尔型。禁止进入子目录的属性。</target>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">被祝福到类 &lt;code&gt;two_refs1&lt;/code&gt; 中的两个&amp;ldquo;对象&amp;rdquo; 都是对数组的引用，因此是对a的引用。</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">#1和#2都使$data由一个完全有效的UTF-8字符串组成,但只有#2打开了UTF8标志。#1相当于:</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">现在， &lt;code&gt;bstr()&lt;/code&gt; 和 &lt;code&gt;bsstr()&lt;/code&gt; 以及通过重载自动进行字符串化都将删除前导'+'。旧代码将返回&amp;ldquo; +3&amp;rdquo;，新代码将返回&amp;ldquo; 3&amp;rdquo;。这与Perl保持一致，并使 &lt;code&gt;cmp&lt;/code&gt; （尤其是在重载时）能够按预期工作。它还解决了 &lt;code&gt;Test.pm&lt;/code&gt; 和&lt;a href=&quot;../test/more&quot;&gt;Test :: More的问题&lt;/a&gt;，它们在比较参数之前先对其进行了字符串化处理。</target>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">既 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 和 &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; 将返回 &lt;code&gt;MAYBE&lt;/code&gt; 。NFC中没有 &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; （它的NFC是 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ），而NFC中没有 &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">无论 &lt;code&gt;timelocal()&lt;/code&gt; 和 &lt;code&gt;timegm()&lt;/code&gt; 如果有支持的范围以外的日期蛙鸣。</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">这两个 &lt;code&gt;wrap()&lt;/code&gt; 和 &lt;code&gt;fill()&lt;/code&gt; 返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">两个Perl函数都将一个对象作为第一个参数。在生成的C ++代码中，该对象称为 &lt;code&gt;THIS&lt;/code&gt; ，方法调用将在此对象上执行。因此，在C ++代码中，blue（）和set_blue（）方法将被这样调用：</target>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">YAML.pm和YAML::Syck都能够反序列化代码。由于这需要一个字符串评估,这可能是一个安全风险,你可以使用这个选项通过CPAN::DeferredCode来启用或禁用代码的反序列化。(注意:这在 perl 5.6 下不起作用)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">两者都不好,而且坏了,无法移植。使用PTR2IV()宏就可以了。同样,还有PTR2UV()、PTR2NV()、INT2PTR()和NUM2PTR()。</target>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">双方的努力都欢迎志愿者。为了参与Perl本身的烟雾测试，请访问&lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;。为了开始烟雾测试CPAN模块，请访问&lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt;或&lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org / dist / CPAN-Reporter /&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">这两种形式是等同的。</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">这两个函数都返回相等的信息（如 &lt;code&gt;gettimeofday&lt;/code&gt; ），但是具有不同的表示形式。选择名称 &lt;code&gt;NVtime&lt;/code&gt; 和 &lt;code&gt;U2time&lt;/code&gt; 的主要原因是它们与操作系统无关。（ &lt;code&gt;gettimeofday&lt;/code&gt; 以Unix为中心，尽管某些平台（如Win32和VMS对此具有仿真功能。）</target>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">install()和uninstall()都是针对ExtUtils::MakeMaker处理perl模块的安装和卸载的方式。它们不是作为通用工具设计的。</target>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">数字值和字符串值均可接受,但请注意,字符串值是区分大小写的。该设置的默认值是 &quot;RANDOM &quot;或1。</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">上面两个都匹配字符 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; ，... &lt;code&gt;\N{U+08}&lt;/code&gt; ， &lt;code&gt;\N{U+09}&lt;/code&gt; ，但是 &lt;code&gt;\x09&lt;/code&gt; 看起来可能是错误，因此会发出警告（在 &lt;code&gt;re 'strict'&lt;/code&gt; 之下）。</target>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">读和写两种访问方式。</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">这两个例程都返回一个对哈希操作的引用。</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">两者都表示由&quot;$x&quot;、一个空格、&quot;?&quot;、一个空格、&quot;:&quot;、一个空格、&quot;$z &quot;组成的单空格(c[颂]式)文字。不同的是,在后者的S码中,这些空格不是 &quot;正常 &quot;的空格,而是非断开的空格。</target>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">现在，stringify和bstr（）都删除前导&amp;ldquo; +&amp;rdquo;。旧代码将返回&amp;ldquo; +1.23&amp;rdquo;，新代码将返回&amp;ldquo; 1.23&amp;rdquo;。有关推理和详细信息，请参见&lt;a href=&quot;bigint&quot;&gt;Math :: BigInt中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">这两种风格都可以使用对象或实际文件柄的类型格洛布(在某些情况下也可以使用字符串,但这是有风险的)。(在某些情况下,它们也可能适用于字符串,但这是有风险的。)</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">这里的两个子程序都是在标量上下文中调用的,而在。</target>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">无论是 &lt;code&gt;$key&lt;/code&gt; 和 &lt;code&gt;$value&lt;/code&gt; 参数将被设置到该键/值对从数据库中读取。</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">无论是 &lt;code&gt;FETCH&lt;/code&gt; 荷兰国际集团功能和 &lt;code&gt;EXISTS&lt;/code&gt; 函数具有相同签名：参数是 &lt;code&gt;$key, $data&lt;/code&gt; ; $ data与tie（）处理期间作为参数给出的值相同。如果该值不存在，则两个函数均应返回一个空列表。如果 &lt;code&gt;EXISTS&lt;/code&gt; 函数与 &lt;code&gt;FETCH&lt;/code&gt; ing函数不同，则成功时应返回TRUE值。该 &lt;code&gt;FETCH&lt;/code&gt; 如果关键是有效ing功能可将返回预期值。</target>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 两个对等总是假定Unicode规则有效。在ASCII平台上，这意味着它们假定从128到255的代码点是Latin-1，这意味着在语言环境规则下使用它们是不明智的，除非保证语言环境是Latin-1或UTF-8。相反，在区域设置规则下，POSIX字符类很有用。它们受有效的实际规则影响，如下所示：</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">两种 &lt;code&gt;filter&lt;/code&gt; 方法都与</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Store和Fetch过滤器都可操作 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">这两个函数都可以导入指定的函数。</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">主进程和它分叉的任何子进程都共享相同的STDIN、STDOUT和STDERR文件柄。如果两个进程同时试图访问它们,就会发生奇怪的事情。您可能还想关闭或重新打开子进程的文件柄。你可以通过使用open()打开管道来解决这个问题,但是在某些系统中,这意味着子进程的寿命不能超过父进程。</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">主进程和后台进程（&amp;ldquo;子&amp;rdquo;进程）都共享相同的STDIN，STDOUT和STDERR文件句柄。如果两者都尝试一次访问它们，则可能会发生奇怪的事情。您可能要为孩子关闭或重新打开它们。您可以通过 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 管道来解决此问题（请参见&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;），但是在某些系统上，这意味着子进程无法超过父进程。</target>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">特殊的和正常的映射都存储于</target>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">这两个XS声明都对应于 &lt;code&gt;char*&lt;/code&gt; C类型，但是它们具有不同的语义，请参见&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The＆Unary Operator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">这两种方法都会自动将 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 作为第一个参数（如果未提供其他参数），并且您也可以显式地给 &lt;code&gt;&quot;:full&quot;&lt;/code&gt; ，例如</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">这两个问题都是可以治愈的。比如说,如果我们想在一个对象的引用上重载Hash dereference,这个对象就是</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">wdayname (day)和 monname (month)都允许传入一个列表,用来索引日期的名称。如果你需要在不实际安装或使用locales的情况下实现某种形式的本地化,这可能很有用。</target>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">底层UTF-8解码例程。返回字符串 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中第一个字符的本机代码点值，该值假定为UTF-8（或UTF-EBCDIC）编码，且长度不超过 &lt;code&gt;curlen&lt;/code&gt; 字节； &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不是NULL）将设置为该字符的长度（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">韩语音节的界限是根据连体即墨行为来确定的。</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin,Joseph,David Kirschen,Alan Langerman,and Susan LoVerso.马赫下的编程》。Addison-Wesley,1994,ISBN 0-201-52739-1。</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">准备好迎接上一步的感谢、错误报告、仇恨邮件和垃圾邮件。好事不出门,坏事传千里!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">在引用命名的捕获组时，必须使用大括号，但对于绝对编号或相对编号的捕获组则为可选。通过连接较小的字符串创建正则表达式时，花括号更安全。例如，如果您有 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; ，并且 &lt;code&gt;$a&lt;/code&gt; 包含 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; ，而 &lt;code&gt;$b&lt;/code&gt; 包含 &lt;code&gt;&quot;37&quot;&lt;/code&gt; ，则将得到 &lt;code&gt;/\g137/&lt;/code&gt; ，这可能不是您想要的。</target>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">Bracket Notation是Locale::Maketext的一个重要功能。我的意思是,括号符号提供了一个使用sprintf格式化的替代品。你用括号符号做的所有事情都可以用一个子块来完成,但是括号符号的目的是为了更简洁。</target>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">括号表示法就像一个微型的&amp;ldquo;模板&amp;rdquo;系统（在&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;的意义上，而不是在C ++模板的意义上），其中普通文本基本上按原样传递，但是特殊区域中的文本得到了特殊解释。在方括号表示法中，使用方括号（&amp;ldquo; [...]&amp;rdquo;）而不是大括号（&amp;ldquo; {...}&amp;rdquo;）来标注经过特殊解释的部分。</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">括号符号将在后面的章节中讨论。请注意,如果字符串在语法上无效(例如,没有正确地平衡括号),试图将字符串编译成括号符号会引发异常。</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">空的或只有空格的括号组会被忽略。例子:&quot;[]&quot;、&quot;[]&quot;或带有回车和/或制表符和/或空格的[和a]。&quot;[]&quot;、&quot;[]&quot;,或带有回车和/或制表符和/或空格的[和a]。</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">括号内的字符类</target>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">方括号字符类由 &lt;code&gt;regnode_charclass&lt;/code&gt; 结构表示，该结构具有4字节参数，然后具有32字节（256位）位图，指示该类中包括Latin1范围内的哪些字符。</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">符号引用周围的括号可以简单地将标识符或变量名称与表达式的其他部分隔离开来,就像在字符串中一样。例如</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">括号必须平衡-每个开括号都必须有一个匹配的括号，反之亦然。所以这些都是&lt;b&gt;无效的&lt;/b&gt;：</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">布拉德&amp;middot;阿普尔顿&amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;（初始版本），Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">布拉德&amp;middot;阿普尔顿（Brad Appleton）&amp;lt;bradapp@enteract.com&amp;gt;，马瑞克&amp;middot;鲁沙（Marek Rouchal）&amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">布兰登&amp;middot;布莱克（Brandon L.Black），&amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">突破 &lt;code&gt;given()&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">如果您要 &lt;code&gt;autouse&lt;/code&gt; 使用的模块进行了一些初始化，希望可以尽早完成，请中断程序的执行。</target>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">根据Unicode规则将文本分成几行。</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">将可重用的代码分解成一个或多个独立的模块文件。</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">易碎线标有 &lt;code&gt;:&lt;/code&gt; 。断点行被标记为 &lt;code&gt;b&lt;/code&gt; 和那些通过行动 &lt;code&gt;a&lt;/code&gt; 。将要执行的行由 &lt;code&gt;==&amp;gt;&lt;/code&gt; 标记。</target>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">突破</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">破坏DBM文件和哈希之间的绑定。</target>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">中断变量和包之间的绑定。（请参见&lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;。）如果未绑定变量，则无效。</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powers具有一个 &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; 模块，该模块旨在与Memoize一起使用，并提供最近最少使用的数据的到期时间。高速缓存保存在固定数量的条目中，当新数据进入时，最近最少使用的数据将过期。请参阅&lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">简而言之， &lt;code&gt;/l&lt;/code&gt; 将字符集设置为执行模式匹配时有效的任何&lt;b&gt;L&lt;/b&gt; ocale 的字符集。</target>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">广义上讲,将一个字符串与一个模式进行匹配包括以下步骤。</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">破损的系统</target>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">缓冲区标量，其中包含当前正在考虑的当前正在处理的文本块。这始终是纯字符串标量（其 &lt;code&gt;SvPOK&lt;/code&gt; 为true）。不能将其用作常规标量方法的标量；而是直接通过下面描述的指针变量来引用缓冲区。</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">最欢迎BUG报告和其他反馈。</target>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">许多人提供的错误报告，补丁和na-谢谢大家！特别感谢Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt;向我保证＆nested_quotewords（）很有用，并感谢Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt;告诉我不要担心错误检查（有点像-您必须在那里。</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Peter John Acklam的错误修复&amp;lt;pjacklam@online.no&amp;gt; 2010-2011。</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">可以通过CPAN RT系统将错误（和对新功能的请求）报告给作者：&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http&lt;/a&gt; ://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">错误/功能要求</target>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">你不打算修复的错误。 :-)</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">在OS/390上使用Perl构建异常点。</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">构建常见问题</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">在AmigaOS上构建Perl的前提条件。</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">构建一个迭代器，该迭代器在给定目录下的树中查找distroprefs文件。在树中，匹配 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; 目录被修剪。</target>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">OS / 2，&lt;a href=&quot;perlos2&quot;&gt;perlos2的&lt;/a&gt;构建说明</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">在为Win32构建指令&lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;，或天鹅环境下&lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">构建人页,也</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">构建系统</target>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">在标量 &lt;code&gt;dsv&lt;/code&gt; 上构建标量 &lt;code&gt;sv&lt;/code&gt; 的可显示版本，该可显示版本最多为 &lt;code&gt;pvlim&lt;/code&gt; 字节长（如果更长，则其余部分将被截断并附加&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">将标量 &lt;code&gt;dsv&lt;/code&gt; 的可显示版本构建为字符串 &lt;code&gt;spv&lt;/code&gt; ，长度 &lt;code&gt;len&lt;/code&gt; ，该可显示版本最多为 &lt;code&gt;pvlim&lt;/code&gt; 个字节长（如果更长，则其余部分将被截断并附加&amp;ldquo; ...&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">在OS/390上构建、测试、安装Perl。</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Windows平台的生成器类</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">在Irix中构建32位Perl</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">在Irix中构建64位Perl</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">在AIX上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">在AIX &amp;lt;5L上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">在HP-UX上构建动态扩展</target>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">在DOS上构建非XS模块</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">为WinCE构建Perl</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">在DOS上构建Perl</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">在DOS上构建Perl的前提条件</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">在DOS上构建XS模块</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">只有当你拥有HP C-ANSI C编译器或已经可以使用的64位gcc二进制文件时,才有可能在PA-RISC上从源码上构建一个64位的gcc。使用HP的原生编译器可以获得perl的最佳性能。</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">建立一个二进制分布</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">建立一个regexp</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">建立一个LP64的perl</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">定制建筑</target>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">建立自定义_.EXE_文件</target>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">根据你安装的perl版本是否已经存在并在你的系统中使用,或者是尚未使用的新版本,构建过程应该有所不同。下面的描述假设这个版本是新的,所以安装它的DLLs和</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">在Irix中使用螺纹构建</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">内置属性</target>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">内置的运算器和功能</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">内置类型包括:</target>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">捆绑式编码器::Locale</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">捆绑包在CPAN包中被特殊处理。如果你说 &quot;install Bundle::Tkkit&quot;(假设存在这样一个Bundle),CPAN将安装pod的CONTENTS部分的所有模块。你可以通过在你的 @INC 路径中的某个地方放置一个符合要求的 Bundle 文件来在本地安装你自己的 Bundles。shell 界面中的 autobundle()命令通过将所有当前安装的模块包含在一个快照 bundle 文件中来实现。</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">但是(在可预见的将来),Pod并没有提供任何方法让Pod作者区分上述&quot;=item&quot;-cluster结构是指哪种分组。所以格式化者应该这样格式化。</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">但我认为这有点分散了我对主代码工作的注意力--更不用说我经常要在程序中玩几次才能准确地决定我想要的消息中的措辞(在这种情况下,我需要去改变三行代码:用那个键调用maketext,然后是ThisProject/I18N/en.pm中的两行)。</target>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">但是Unicode的目的是统一现有的字符集标准和实践，并且几个预先存在的标准具有单个字符，这些字符与这些组合中的某些组合（例如ISO-8859-1）具有相同的含义。例如，当Unicode出现时， &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; 字母E&amp;rdquo;已经在此标准中。因此，Unicode将它作为单个字符添加到其库中。但是，Unicode认为此字符等效于由字符 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; 大写字母E&amp;rdquo;和字符 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 组成的序列。</target>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">但要提醒大家的是。当使用下面的方法对一个数字进行复制时,只能进行浅层复制。</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">但任何修改器仍将适用于所有组件。</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">但正如你可以想象的那样,这对读者来说可能会变得相当粗糙。</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">但是在 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 为CJK统一表意文字分配权重仍然有效。如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则CJK统一表意文字的权重将被视为未定义。但是，当 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8时， &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 没有特殊含义。</target>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">但是一定要确保在第一个块中调用 &lt;code&gt;ok&lt;/code&gt; 的次数与在第二个块中调用 &lt;code&gt;skip&lt;/code&gt; 的次数相同。</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">但这两种方法都比分配空列表或未定义%HASH或@ARRAY要慢,后者是清空集合的习惯方法。</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">但不要打扰他,他已经退休了。</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">但不要把</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">但是由于类型图文件中存在无法修复的错误（修复该错误会破坏很多现有的CPAN模块），因此 &lt;code&gt;AV *&lt;/code&gt; 的引用计数未适当减少。因此，上述XSUB每当被调用时都会泄漏内存。 &lt;code&gt;HV *&lt;/code&gt; ， &lt;code&gt;CV *&lt;/code&gt; 和 &lt;code&gt;SVREF&lt;/code&gt; 存在相同的问题（这表示标量参考，而不是一般的 &lt;code&gt;SV *&lt;/code&gt; ）。在以perl 5.16开头的perl的XS代码中，您可以使用对引用计数进行适当处理的版本覆盖这些类型中的任何类型的类型映射。在您的 &lt;code&gt;TYPEMAP&lt;/code&gt; 部分中，执行</target>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">但是最简单的是，如果该字符可指定为文字，例如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;%&quot;&lt;/code&gt; ，则使用它；如果不是很明确，则可以使用 &lt;code&gt;\N{}&lt;/code&gt; ，如果副作用没有问题。只需使用 &lt;code&gt;\N{U+ZZ}&lt;/code&gt; 而不是 &lt;code&gt;\xZZ&lt;/code&gt; ，以十六进制指定所有字符。 &lt;code&gt;\N{}&lt;/code&gt; 是Unicode名称，因此它始终为您提供Unicode字符。 &lt;code&gt;\N{U+41}&lt;/code&gt; 是Unicode代码点为 &lt;code&gt;0x41&lt;/code&gt; 的字符，因此在所有平台上均为 &lt;code&gt;'A'&lt;/code&gt; 。副作用是：</target>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">但failail_handler_auto,并没有死掉,而是编译了$key,把它缓存在了</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">但是不要担心，有一个简单的解决方案。 &lt;code&gt;Sub::Name&lt;/code&gt; 模块将进入perl内部，并为您为匿名子例程分配一个名称。只需执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">但是对于&amp;ldquo;目录&amp;rdquo;，您需要 &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; 以便我们的基本 &lt;code&gt;quant&lt;/code&gt; 方法不会认为&amp;ldquo; directory&amp;rdquo;的复数是&amp;ldquo; directorys&amp;rdquo;。如果您指定否定形式，您可能会发现输出听起来会更好，例如：</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">但现在,让我们看看所有这些类型的数据结构所共有的一般问题。</target>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">但是对于其他语言（如&lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13中&lt;/a&gt;详细讨论的那样），简单的 &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; 是不够的。对于特别有问题的斯拉夫语言，您可能需要提供一种方法，该方法提供数字，名词的引用形式以进行量化，以及句子语法投射到该名词槽上的大小写和性别。然后，该方法将负责确定数字将什么语法数字投射到其名词短语上，以及该数字可能覆盖普通的大小写和性别。然后它将在词典中查找名词，并提供所有需要的变体形式。</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">但是对于某些处理器/格式，这很难控制。与HTML示例一样，多个歧义&amp;lt;a name =&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">但一般情况下,一个块是由大括号,也就是括号来限定的。我们将这种语法结构称为BLOCK。</target>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">但如果客户端要求 &quot;i-Mingo &quot;或 &quot;x-mingo&quot;,或 &quot;Fr&quot;,那么%greetings中的查找就会失败。这就是错误的地方。</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">但如果文件一开始就。</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">但如果你将Pod::Simple::Methody子类化,当它看到&quot;=head1 Hi there &quot;时,它反而会这样做。</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">但如果你试试这个。</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">但是，如果您希望嵌套出现 &lt;code&gt;START&lt;/code&gt; 到 &lt;code&gt;END&lt;/code&gt; ，则会遇到本节中有关平衡文本匹配问题中描述的问题。</target>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">但是，如果您编写的代码使用 &lt;code&gt;\005&lt;/code&gt; 表示TAB或 &lt;code&gt;\xC1&lt;/code&gt; 表示&amp;ldquo; A&amp;rdquo;，或 &lt;code&gt;\xDF&lt;/code&gt; 表示&amp;ldquo;&amp;yuml;&amp;rdquo;（带有小写字母的小 &lt;code&gt;&quot;y&quot;&lt;/code&gt; ），那么您的代码很可能可以在您的计算机上正常工作EBCDIC平台，但不是在ASCII平台上。如果没有人愿意在ASCII平台上运行您的代码，那很好。但是本文的偏向在于编写可在EBCDIC和ASCII系统之间移植的代码。同样，如果您关心的每个字符都可以轻松地从键盘输入，那么您就不必了解ASCII，但是许多键盘都不容易让您直接输入字符 &lt;code&gt;\xDF&lt;/code&gt; ，因此您必须间接指定它，例如通过使用 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; 转义序列。在这些情况下，最容易了解有关ASCII / Unicode字符集的知识。如果知道小&amp;ldquo;&amp;yuml;&amp;rdquo;是 &lt;code&gt;U+00FF&lt;/code&gt; ，则可以将其指定为 &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; ，并让计算机自动将其翻译为平台上的 &lt;code&gt;\xDF&lt;/code&gt; ，并将其保留为 &lt;code&gt;\xFF&lt;/code&gt; ASCII码上的xFF。或者，您可以使用名称 &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 来指定它，而不必知道数字。两种方法都可以，但是需要熟悉Unicode。</target>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">但如果你是一个perl程序员,那么对于你来说,我有比结构胶印机更奇妙的东西。</target>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">但无论如何,尽量把功能和操作系统分开。</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">但万一你发现需要......</target>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">但在这个特殊的例子中,你可能真的想要的是</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">但实际上是这样编译的。</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">但它也把同样的信息放在XSUB本身的某些字段中。</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">但它也适用于词法声明的聚合体。</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">但它同样也可以是讨论三个(相关或相当的)项目,&quot;Neque&quot;、&quot;Porro &quot;和 &quot;Quisquam Est&quot;,然后用一段话解释它们,再加上一个新项目 &quot;Ut Enim&quot;。在这种情况下,你可能会想要这样的格式。</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">但是它在Perl 6中根本不起作用。相反，您应该使用（可并行化的） &lt;code&gt;any&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">但它会呱呱坠地,如果。</target>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">但切勿在未先设置默认编码的情况下使用裸露的 &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 。否则，Perl将不知道您拥有多种形式的文本文件，而Perl将不知道如何将文件中的数据正确映射为可以使用的实际字符。其他常见的编码格式包括 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; ， &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; ， &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; ，甚至是 &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; 。有关编码的更多信息，请参见&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">但是请注意，仅当 &lt;code&gt;SvPOK()&lt;/code&gt; 为true时，这后三个宏才有效。</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">但是请注意，这并不意味着字符串中的任何字符都是必需的UTF-8编码，或者任何字符的代码点都大于0xFF（255）甚至是0x80（128），或者字符串具有任何字符。 &lt;code&gt;is_utf8()&lt;/code&gt; 所做的全部操作是返回附加在 &lt;code&gt;$string&lt;/code&gt; 上的内部&amp;ldquo; utf8ness&amp;rdquo;标志的值。如果该标志关闭，则标量中的字节将解释为单字节编码。如果标记打开，则标量中的字节将被解释为字符的（可变长度，可能为多字节）UTF-8编码的代码点。添加到UTF-8编码字符串的字节将自动升级为UTF-8。如果合并了混合的非UTF-8和UTF-8标量（双引号插值，显式级联或printf / sprintf参数替换），则结果将采用UTF-8编码，就好像字节字符串的副本已升级为UTF一样-8：例如，</target>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">但是在v5.16之前，您必须明确要使用的字符集。的 &lt;code&gt;:full&lt;/code&gt; 名是正式的Unicode字符的名称，别名或序列，它都共享一个命名空间。</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">但请记住,并不是所有的操作系统都支持分叉或捕获命令的输出,所以这个复杂的语句可能无法移植。</target>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">但是,有些模块不能用这个口号来构建,它们试图通过环境、额外的参数或交互式来从用户那里获取一些额外的数据--从而扰乱了像Phalanx100这样的大型捆绑包或像Plagger这样有许多依赖关系的模块的安装。它们试图通过环境、额外的参数或交互方式从用户那里获取一些额外的数据--从而干扰了像Phalanx100这样的大型捆绑包或像Plagger这样有许多依赖关系的模块的安装。</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">但把它串起来,你得到的只是文字内容。</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">但要注意不要把它传成,比如说</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">但测试污点只能让你走到这一步。有时你只需要清除数据的污点。通过将值作为哈希中的键来使用,可以不受污染;否则绕过污点机制的唯一方法是通过从正则表达式匹配中引用子模式。Perl假定,如果你在非污点模式中使用$1、$2等引用一个子串,那么你在写这个模式时就知道自己在做什么。这意味着要用点心思--不要盲目地取消任何东西,否则你就会打败整个机制。最好是验证变量是否只有好的字符(对于某些 &quot;好 &quot;的值),而不是检查它是否有坏的字符。这是因为太容易漏掉你从未想过的坏字符了。</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">但这在某些情况下会产生模棱两可的语法,所以通常使用直接方法调用的方法更好。</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">但这是不会匹配的,至少,不是你所希望的方式。它声称字符串中没有123。这里有一张更清晰的图片,说明为什么该模式会匹配,与大众的期望相反。</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">但是第二次 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 正在紧锣密鼓地进行中。它没有为模板使用简单的文字字符串。所以也许我们应该介绍...</target>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">但这不是非常漂亮。从长远来看,你可能会发现这样做更简单或更清晰。</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">但这样的效率相当低。更好的方法是用以下方式开始你的程序。</target>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">但是HERE_TARGET仍然必须与空白处齐平。如果你想让它也缩进,你就得在缩进处引用。</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">但下面的代码相当糟糕。</target>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">但是在某些情况下，只有此解决方案有效（例如 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; ）；</target>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">但是在某些情况下，您可能想知道要在哪个字符集下运行。一个可能的示例是在&lt;a href=&quot;#SORTING&quot;&gt;对&lt;/a&gt;性能至关重要的内部循环中进行排序。</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">但实际上并不需要&lt;b&gt;两者&lt;/b&gt;都是临时文件...以下内容也应同样有效，而不会出现死锁：</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">但它们可能是任意长的。</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">但它们可能会跨越几条(非空白)线。</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">但这并不会产生阅读代码的人所期望的效果，因为交集仅适用于 &lt;code&gt;\p{Thai}&lt;/code&gt; ，不包括老挝语。可以通过在组成部分中加上括号来避免此类陷阱：</target>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">但这不匹配，至少不符合人们的预期。只有插入内插的 &lt;code&gt;$a99a&lt;/code&gt; 并查看生成的正则表达式的全文之后，才可以明显看出反向引用适得其反。子表达式 &lt;code&gt;(\w+)&lt;/code&gt; 抢夺了数字1，并将 &lt;code&gt;$a99a&lt;/code&gt; 的组降级了一级。可以通过使用相对反向引用来避免这种情况：</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">但这不是。</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">但是为了避免可移植性警告（请参阅&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;），您可能更喜欢：</target>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">但是等等：不 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 返回字节序列吗？我们如何将这个字节字符串传递给某些C语言代码，期望它的指针毕竟是一个数字呢？答案很简单：我们必须从 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 返回的字节中获取数字地址。</target>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">但是，如果我们的单词数量不确定，该怎么办？ &lt;code&gt;//g&lt;/code&gt; 是完成的任务。要提取所有单词，形成简单的正则表达式 &lt;code&gt;(\w+)&lt;/code&gt; 并使用 &lt;code&gt;/(\w+)/g&lt;/code&gt; 遍历所有匹配项：</target>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">但当 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 代替 &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">但如果在最后加上以下几行字。</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">但是对于 &lt;code&gt;$a = $b + $c&lt;/code&gt; 的实际编译树，情况有所不同：某些节点</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">但当调用为时,就不能用了。</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">但实际上你不需要进行两个管道调用。如果你有socketpair()系统调用,它将为你完成这一切。</target>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">但你仍然不能假设这是否正确,除非你的政策规定是这样。你真的最好问一下用户。</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">但你仍然有那些有趣的select()s。所以只要使用FileHandle模块就可以了。现在,你可以使用小写的方法名来访问这些特殊变量。</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">但是，通过使用 &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; 提取指令，&lt;a href=&quot;../functions/undef&quot;&gt; undef&lt;/a&gt;，'&amp;lt;&amp;gt;'）仅将'&amp;gt;'字符视为代码块最外层的定界符，因此可以正确解析指令。</target>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">通过调用类方法 &lt;code&gt;Math::Complex::display_format&lt;/code&gt; 并提供 &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 作为参数，您可以覆盖默认的显示样式，即 &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; 。不提供任何参数将返回当前设置。</target>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">相反,如果</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">按照惯例，CPAN摘要模块可以 &lt;b&gt;不&lt;/b&gt;填充其Base64输出。将此类摘要提供给其他需要正确填充Base64编码的软件时，可能会出现问题。</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">按照惯例,所有对OS/2 API的调用都应该通过重置$^E来表示其失败。所有调用OS/2 API的Perl可访问的函数都可以分为两类:一些函数在遇到API错误时死(),另一些函数则通过一个错误的返回值来报告错误(当然,这并不涉及到Perl可访问的函数,这些函数是</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">按照惯例，检查例程的名称为 &lt;code&gt;ck_*&lt;/code&gt; 。它们通常是从 &lt;code&gt;new*OP&lt;/code&gt; 子例程（或 &lt;code&gt;convert&lt;/code&gt; ）中调用的（而后者又是从</target>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">按照惯例,每个测试都会按顺序分配一个号码。这在很大程度上是为您自动完成的。然而,为每个测试指定一个名称往往是非常有用的。你想看哪个。</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">默认情况下</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">默认情况下 &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; 将解压缩</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">默认情况下， &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; 将使用zlib库的1.2.5版的私有副本进行构建。（请参阅</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">默认情况下， &lt;code&gt;Hash::Util&lt;/code&gt; 不导出任何内容。</target>
        </trans-unit>
        <trans-unit id="09e2116155b494da50686ee8fd22c6f8af75259f" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;List::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">默认情况下 &lt;code&gt;List::Util&lt;/code&gt; 不导出任何子例程。</target>
        </trans-unit>
        <trans-unit id="5c8967b9c380cc8af7979a94b2f6e12071d5756c" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Scalar::Util&lt;/code&gt; does not export any subroutines.</source>
          <target state="translated">默认 &lt;code&gt;Scalar::Util&lt;/code&gt; 不导出任何子例程。</target>
        </trans-unit>
        <trans-unit id="6a85c45889f6bd96a07b3072c70fdac86872c8e7" translate="yes" xml:space="preserve">
          <source>By default CPAN Meta specification &lt;code&gt;1.4&lt;/code&gt; is used. In order to use CPAN Meta specification &lt;code&gt;2.0&lt;/code&gt; , indicate with &lt;code&gt;meta-spec&lt;/code&gt; the version you want to use.</source>
          <target state="translated">默认情况下，使用CPAN Meta规范 &lt;code&gt;1.4&lt;/code&gt; 。为了使用CPAN Meta Specification &lt;code&gt;2.0&lt;/code&gt; ，请以 &lt;code&gt;meta-spec&lt;/code&gt; 表示要使用的版本。</target>
        </trans-unit>
        <trans-unit id="8bc161a96f1f3872cf0bfff0e6212dcccea74651" translate="yes" xml:space="preserve">
          <source>By default Perl does not use the &lt;code&gt;malloc()&lt;/code&gt; included with the Perl source, because it was slower and not entirely thread-safe. If you want to force Perl to build with the old -Dusemymalloc define this.</source>
          <target state="translated">默认情况下，Perl不使用 &lt;code&gt;malloc()&lt;/code&gt; Perl源代码附带，因为它速度较慢并且也不完全是线程安全的。如果要强制Perl使用旧的-Dusemymalloc进行构建，请定义此代码。</target>
        </trans-unit>
        <trans-unit id="1261dc25c0b95e8495b666b1c3497fb4bd944f86" translate="yes" xml:space="preserve">
          <source>By default Perl uses 64 bit integers. If you want to use smaller 32 bit integers, define this symbol.</source>
          <target state="translated">默认情况下,Perl 使用 64 位整数。如果你想使用更小的32位整数,请定义这个符号。</target>
        </trans-unit>
        <trans-unit id="2b8741f41b3847fc8e6d6ed4c668a3b8923660d9" translate="yes" xml:space="preserve">
          <source>By default Pod::Simple::HTML adds a dummy anchor at the top of the HTML. You can change it by calling</source>
          <target state="translated">默认情况下,Pod::Simple::HTML在HTML的顶部添加了一个虚拟锚。你可以通过调用</target>
        </trans-unit>
        <trans-unit id="63d675d5fb6fc8fe769b7759c86a5571aae789b8" translate="yes" xml:space="preserve">
          <source>By default floating point numbers substituted inside strings use the dot (&quot;.&quot;) as the decimal separator. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, and POSIX::setlocale() has been called, the character used for the decimal separator is affected by the LC_NUMERIC locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">默认情况下，在字符串内替换的浮点数使用点（&amp;ldquo;。&amp;rdquo;）作为十进制分隔符。如果有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，并且已调用POSIX :: setlocale（），则用于小数点分隔符的字符会受到LC_NUMERIC语言环境的影响。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dadc258ff54a1a05b69b778084fc2dfc7494a970" translate="yes" xml:space="preserve">
          <source>By default it does nothing.</source>
          <target state="translated">默认情况下,它什么也不做。</target>
        </trans-unit>
        <trans-unit id="4033d9fb012c9ab68d72ab1a3b85a5a59eb68724" translate="yes" xml:space="preserve">
          <source>By default it just prints the stubs, but you can set the global $Devel::SelfStubber::JUST_STUBS to 0 and it will print out the entire module with the stubs positioned correctly.</source>
          <target state="translated">默认情况下,它只是打印存根,但你可以将全局的$Devel::SelfStubber::JUST_STUBS设置为0,它将打印出整个模块的存根,并正确定位。</target>
        </trans-unit>
        <trans-unit id="f3cfe07b0874e5c860a9ad1e8fd1566639cad34f" translate="yes" xml:space="preserve">
          <source>By default it writes to &lt;code&gt;cwd()&lt;/code&gt; , but you can override that by specifying the &lt;code&gt;to&lt;/code&gt; argument:</source>
          <target state="translated">默认情况下，它写入 &lt;code&gt;cwd()&lt;/code&gt; ，但是您可以通过指定 &lt;code&gt;to&lt;/code&gt; 参数来覆盖它：</target>
        </trans-unit>
        <trans-unit id="27c6146d97f6523b1856790ae4b8a285b8e3db7e" translate="yes" xml:space="preserve">
          <source>By default no Unix2 extra field is created.</source>
          <target state="translated">默认情况下,没有创建Unix2额外字段。</target>
        </trans-unit>
        <trans-unit id="0ab606593d4a9d45e75e4256f15600160e7bc2fa" translate="yes" xml:space="preserve">
          <source>By default no UnixN extra field is created.</source>
          <target state="translated">默认情况下,没有创建UnixN额外字段。</target>
        </trans-unit>
        <trans-unit id="ee18fc042b3c569119417a51774089c404eb248f" translate="yes" xml:space="preserve">
          <source>By default no extended time field is created.</source>
          <target state="translated">默认情况下,没有创建扩展时间字段。</target>
        </trans-unit>
        <trans-unit id="ebb685a0031880a3b5e0df98008f367fed554c4e" translate="yes" xml:space="preserve">
          <source>By default no opmask is in effect and any code can be compiled.</source>
          <target state="translated">默认情况下,没有pmask,任何代码都可以被编译。</target>
        </trans-unit>
        <trans-unit id="c2a6e64907872a01e02add6a8ea23d69c4a6e77e" translate="yes" xml:space="preserve">
          <source>By default only the &lt;code&gt;langinfo()&lt;/code&gt; function is exported.</source>
          <target state="translated">默认情况下只有 &lt;code&gt;langinfo()&lt;/code&gt; 导出函数。</target>
        </trans-unit>
        <trans-unit id="d98ec28c38227dc5b1c1a5373143946764c67c67" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP::Parser::SourceHandler::Executable&lt;/a&gt; class will create a &lt;a href=&quot;parser/iterator/process&quot;&gt;TAP::Parser::Iterator::Process&lt;/a&gt; object to handle the source. This passes the array reference strings as command arguments to &lt;a href=&quot;../ipc/open3&quot;&gt;IPC::Open3::open3&lt;/a&gt;:</source>
          <target state="translated">默认情况下，&lt;a href=&quot;parser/sourcehandler/executable&quot;&gt;TAP :: Parser :: SourceHandler :: Executable&lt;/a&gt;类将创建一个&lt;a href=&quot;parser/iterator/process&quot;&gt;TAP :: Parser :: Iterator :: Process&lt;/a&gt;对象来处理源。这会将数组引用字符串作为命令参数传递给&lt;a href=&quot;../ipc/open3&quot;&gt;IPC :: Open3 :: open3&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a48220280114a78503f2a2001b0a32eddecb9d87" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;flush_type&lt;/code&gt; used is &lt;code&gt;Z_FINISH&lt;/code&gt; . Other valid values for &lt;code&gt;flush_type&lt;/code&gt; are &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; , &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; , &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; and &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; . It is strongly recommended that you only set the &lt;code&gt;flush_type&lt;/code&gt; parameter if you fully understand the implications of what it does. See the &lt;code&gt;zlib&lt;/code&gt; documentation for details.</source>
          <target state="translated">默认情况下，使用的 &lt;code&gt;flush_type&lt;/code&gt; 是 &lt;code&gt;Z_FINISH&lt;/code&gt; 。 &lt;code&gt;flush_type&lt;/code&gt; 的其他有效值是 &lt;code&gt;Z_NO_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_PARTIAL_FLUSH&lt;/code&gt; ， &lt;code&gt;Z_SYNC_FLUSH&lt;/code&gt; 和 &lt;code&gt;Z_FULL_FLUSH&lt;/code&gt; 。强烈建议您仅在完全了解其含义的情况下才设置 &lt;code&gt;flush_type&lt;/code&gt; 参数。有关详细信息，请参见 &lt;code&gt;zlib&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="13a328506dc208738ad9d028668747611624fc18" translate="yes" xml:space="preserve">
          <source>By default the Makefile produced includes all the static extensions in the perl library. (Purified versions of library files, e.g., DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)</source>
          <target state="translated">默认情况下,生成的Makefile包含了perl库中的所有静态扩展。(库文件的纯化版本,例如DynaLoader_pure_p1_c0_032.a会被自动忽略,以避免链接错误。)</target>
        </trans-unit>
        <trans-unit id="72406ce9b9b1b9e64fd6ddb212ef0d9f15de7828" translate="yes" xml:space="preserve">
          <source>By default the debugger is called using &lt;code&gt;-d&lt;/code&gt; option to perl. If you want to specify some other option, set the &lt;code&gt;TESTDB_SW&lt;/code&gt; variable:</source>
          <target state="translated">缺省情况下，使用Perl的 &lt;code&gt;-d&lt;/code&gt; 选项调用调试器。如果要指定其他选项，请设置 &lt;code&gt;TESTDB_SW&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="b2356cae1189c23be90e67a7d45b9477ad72051f" translate="yes" xml:space="preserve">
          <source>By default the directory is deleted when the object goes out of scope.</source>
          <target state="translated">默认情况下,当对象超出范围时,该目录会被删除。</target>
        </trans-unit>
        <trans-unit id="cbf770fbcc502baf26e331b84104d6aaf9126f59" translate="yes" xml:space="preserve">
          <source>By default the layers from the input side of the filehandle are returned; to get the output side, use the optional &lt;code&gt;output&lt;/code&gt; argument:</source>
          <target state="translated">默认情况下，返回文件句柄输入侧的图层；要获得输出端，请使用可选的 &lt;code&gt;output&lt;/code&gt; 参数：</target>
        </trans-unit>
        <trans-unit id="29f25f3b77d3062c86a659cbc91ff07ea769bf59" translate="yes" xml:space="preserve">
          <source>By default this will include *.pm and *.pl and the files found in the PMLIBDIRS directories. Defining PM in the Makefile.PL will override PMLIBDIRS.</source>
          <target state="translated">默认情况下,这将包括 *.pm 和 *.pl 以及 PMLIBDIRS 目录中的文件。在Makefile.PL中定义PM将覆盖PMLIBDIRS。</target>
        </trans-unit>
        <trans-unit id="1c14ce64b17e700de893a0b00ad2e97e494dcfd4" translate="yes" xml:space="preserve">
          <source>By default verbose output is generated, setting the PERL_INSTALL_QUIET environment variable will silence this output.</source>
          <target state="translated">在默认情况下,会产生冗长的输出,设置PERL_INSTALL_QUIET环境变量将使这个输出沉默。</target>
        </trans-unit>
        <trans-unit id="4e63e74d2a508a1a33c3e1bb5754226ab9609082" translate="yes" xml:space="preserve">
          <source>By default your system's F_* and O_* constants (eg, F_DUPFD and O_CREAT) and the FD_CLOEXEC constant are exported into your namespace.</source>
          <target state="translated">默认情况下,你的系统的 F_*和 O_*常量 (例如,F_DUPFD 和 O_CREAT)以及 FD_CLOEXEC 常量会被导出到你的命名空间。</target>
        </trans-unit>
        <trans-unit id="b44b2a95f6381a248195f00274a8435d100aaa35" translate="yes" xml:space="preserve">
          <source>By default,</source>
          <target state="translated">默认情况下。</target>
        </trans-unit>
        <trans-unit id="6d88a1aadef2616cc309d3135c3c0ad225e5d689" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN::Meta::YAML&lt;/a&gt; will be used for deserializing YAML data. If the &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; environment variable is defined, then it is interpreted as a module to use for deserialization. The given module must be installed, must load correctly and must implement the &lt;code&gt;Load()&lt;/code&gt; function or an exception will be thrown.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;../../cpan/meta/yaml&quot;&gt;CPAN :: Meta :: YAML&lt;/a&gt;将用于反序列化YAML数据。如果定义了 &lt;code&gt;PERL_YAML_BACKEND&lt;/code&gt; 环境变量，则将其解释为用于反序列化的模块。给定的模块必须已安装，必须正确加载并且必须实现 &lt;code&gt;Load()&lt;/code&gt; 函数，否则将引发异常。</target>
        </trans-unit>
        <trans-unit id="a9ce14085141d2bedbc81e908e7a8dd19fcc292a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../../json/pp&quot;&gt;JSON::PP&lt;/a&gt; will be used for deserializing JSON data. If the &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; environment variable exists, is true and is not &quot;JSON::PP&quot;, then the &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; module (version 2.5 or greater) will be loaded and used to interpret &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; . If &lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt; is not installed or is too old, an exception will be thrown.</source>
          <target state="translated">默认情况下，&lt;a href=&quot;../../json/pp&quot;&gt;JSON :: PP&lt;/a&gt;将用于反序列化JSON数据。如果 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 环境变量存在，为true且不是&amp;ldquo; JSON :: PP&amp;rdquo;，则将加载&lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt;模块（版本2.5或更高版本）并用于解释 &lt;code&gt;PERL_JSON_BACKEND&lt;/code&gt; 。如果是&lt;a href=&quot;http://search.cpan.org/perldoc/JSON&quot;&gt;JSON&lt;/a&gt;未安装或过旧，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="79a294e48ade56dbe097d94ecb2d017b667469c8" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email::Sender::Simple&lt;/a&gt; will try `sendmail` first, if it exists in your $PATH. This generally isn't the case. If there's a remote mail server you use to send mail, consider investigating one of the Transport classes. At time of writing, the available transports include:</source>
          <target state="translated">默认情况下，如果$ PATH中存在&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Sender::Simple&quot;&gt;Email :: Sender :: Simple，&lt;/a&gt;它将首先尝试使用sendmail。通常情况并非如此。如果有用于发送邮件的远程邮件服务器，请考虑研究传输类别之一。在撰写本文时，可用的传输方式包括：</target>
        </trans-unit>
        <trans-unit id="d72ee058cb3ba5edce2a08b405dc90217d0eada0" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;Locale::Maketext::Simple&lt;/b&gt; draws its source from the calling package's</source>
          <target state="translated">默认情况下，&lt;b&gt;Locale :: Maketext :: Simple&lt;/b&gt;从调用包的</target>
        </trans-unit>
        <trans-unit id="35fc08f26016b44845e97a461120088a4d635511" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2man&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">默认情况下，如果在POD输入中检测到任何错误，&lt;b&gt;pod2man将&lt;/b&gt;死亡。如果&lt;b&gt;--stderr&lt;/b&gt;，并给出没有&lt;b&gt;--errors&lt;/b&gt;标志存在，错误被发送到标准错误，但&lt;b&gt;pod2man将&lt;/b&gt;不会中止。这等效于 &lt;code&gt;--errors=stderr&lt;/code&gt; ,并且为了向后兼容而受支持。</target>
        </trans-unit>
        <trans-unit id="30d3609c8a43f768f52510e95fef029cac6273de" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2man&lt;/b&gt; produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">默认情况下，&lt;b&gt;pod2man&lt;/b&gt;会生成最保守的* roff输出，以尝试确保它可以与尽可能多的不同* roff实现一起使用。许多的* roff实现不能处理非ASCII字符，因此，这意味着所有的非ASCII字符或者转换为*的roff转义序列，试图创建一个适当重音字符（至少对于troff的输出），或 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7337f82d45ceca3575dcc4fcaada9bab5f7a5ae" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; dies if any errors are detected in the POD input. If &lt;b&gt;--stderr&lt;/b&gt; is given and no &lt;b&gt;--errors&lt;/b&gt; flag is present, errors are sent to standard error, but &lt;b&gt;pod2text&lt;/b&gt; does not abort. This is equivalent to &lt;code&gt;--errors=stderr&lt;/code&gt; and is supported for backward compatibility.</source>
          <target state="translated">默认情况下，如果在POD输入中检测到任何错误，则&lt;b&gt;pod2text会&lt;/b&gt;消失。如果&lt;b&gt;--stderr&lt;/b&gt;，并给出没有&lt;b&gt;--errors&lt;/b&gt;标志存在，错误被发送到标准错误，但&lt;b&gt;pod2text&lt;/b&gt;不会中止。这等效于 &lt;code&gt;--errors=stderr&lt;/code&gt; ,并且为了向后兼容而受支持。</target>
        </trans-unit>
        <trans-unit id="d7d98831aaac5ae8bfa863600541ce748cdfa2ce" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2text&lt;/b&gt; tries to use the same output encoding as its input encoding (to be backward-compatible with older versions). This option says to instead force the output encoding to UTF-8.</source>
          <target state="translated">默认情况下，&lt;b&gt;pod2text&lt;/b&gt;尝试使用与其输入编码相同的输出编码（以与旧版本向后兼容）。此选项表示改为将输出编码强制为UTF-8。</target>
        </trans-unit>
        <trans-unit id="f53f148127af7bd5af025188de73dc79a271f7fe" translate="yes" xml:space="preserve">
          <source>By default, &lt;b&gt;pod2usage()&lt;/b&gt; will use &lt;code&gt;$0&lt;/code&gt; as the path to the pod input file. Unfortunately, not all systems on which Perl runs will set &lt;code&gt;$0&lt;/code&gt; properly (although if &lt;code&gt;$0&lt;/code&gt; isn't found, &lt;b&gt;pod2usage()&lt;/b&gt; will search &lt;code&gt;$ENV{PATH}&lt;/code&gt; or else the list specified by the &lt;code&gt;-pathlist&lt;/code&gt; option). If this is the case for your system, you may need to explicitly specify the path to the pod docs for the invoking script using something similar to the following:</source>
          <target state="translated">默认情况下，&lt;b&gt;pod2usage（）&lt;/b&gt;将使用 &lt;code&gt;$0&lt;/code&gt; 作为pod输入文件的路径。不幸的是，并非所有运行Perl的系统都会正确设置 &lt;code&gt;$0&lt;/code&gt; （尽管如果找不到 &lt;code&gt;$0&lt;/code&gt; ，&lt;b&gt;pod2usage（）&lt;/b&gt;将搜索 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 或 &lt;code&gt;-pathlist&lt;/code&gt; 选项指定的列表）。如果您的系统是这种情况，则可能需要使用类似于以下内容的方式为调用脚本显式指定pod doc的路径：</target>
        </trans-unit>
        <trans-unit id="139ad65b1f5c08871019f97feca04f36c4d7791f" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &lt;code&gt;tar&lt;/code&gt; to store files. For paths greater than 100 characters, this is done using the &lt;code&gt;POSIX header prefix&lt;/code&gt; . Non-POSIX-compatible clients may not support this part of the specification, and may only support the &lt;code&gt;GNU Extended
Header&lt;/code&gt; functionality. To facilitate those clients, you can set the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; . See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section for details on this variable.</source>
          <target state="translated">默认情况下， &lt;code&gt;Archive::Tar&lt;/code&gt; 处于完全与POSIX兼容的模式，该模式使用 &lt;code&gt;tar&lt;/code&gt; 的POSIX规范存储文件。对于大于100个字符的路径，使用 &lt;code&gt;POSIX header prefix&lt;/code&gt; 来完成。不兼容POSIX的客户端可能不支持该规范的这一部分，并且可能仅支持 &lt;code&gt;GNU Extended Header&lt;/code&gt; 功能。为了方便这些客户端，可以将 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 变量设置为 &lt;code&gt;true&lt;/code&gt; 。有关此变量的详细信息，请参见&amp;ldquo; &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="a0ce25419277d6adf6e0c4949f8ca8dca00cd62d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt;-ing.</source>
          <target state="translated">默认情况下， &lt;code&gt;Archive::Tar&lt;/code&gt; 会尝试 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; 文件存档中的特定文件中指定的任何模式。在某些情况下，这可能是不希望的。在这种情况下，将此变量设置为 &lt;code&gt;0&lt;/code&gt; 可禁用 &lt;code&gt;&lt;a href=&quot;../functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; -ing。</target>
        </trans-unit>
        <trans-unit id="eb67a5af923530004ebe769a16f96c44f7d23600" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to &lt;code&gt;0&lt;/code&gt; to disable &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt;-ing, even if it were possible.</source>
          <target state="translated">默认情况下， &lt;code&gt;Archive::Tar&lt;/code&gt; 会尝试对文件进行 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; 。在某些情况下，这可能是不希望的。在这种情况下，将此变量设置为 &lt;code&gt;0&lt;/code&gt; 以禁用 &lt;code&gt;&lt;a href=&quot;../functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; -ing，即使可能的话。</target>
        </trans-unit>
        <trans-unit id="a46faa893a6a331982326586cd0db0d3a2c1dfbd" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Archive::Tar&lt;/code&gt; will try to put paths that are over 100 characters in the &lt;code&gt;prefix&lt;/code&gt; field of your tar header, as defined per POSIX-standard. However, some (older) tar programs do not implement this spec. To retain compatibility with these older or non-POSIX compliant versions, you can set the &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; variable to a true value, and &lt;code&gt;Archive::Tar&lt;/code&gt; will use an alternate way of dealing with paths over 100 characters by using the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature.</source>
          <target state="translated">默认情况下， &lt;code&gt;Archive::Tar&lt;/code&gt; 会尝试将超过100个字符的路径放入tar标头的 &lt;code&gt;prefix&lt;/code&gt; 字段中，这是根据POSIX标准定义的。但是，某些（较旧的）tar程序未实现此规范。为了保持与这些较早版本或不兼容POSIX的版本的兼容性，可以将 &lt;code&gt;$DO_NOT_USE_PREFIX&lt;/code&gt; 变量设置为true值，并且 &lt;code&gt;Archive::Tar&lt;/code&gt; 将使用 &lt;code&gt;GNU Extended Header&lt;/code&gt; 功能使用另一种方式处理100个以上字符的路径。</target>
        </trans-unit>
        <trans-unit id="ca08f9f1e5aebac60920c9f0bab0c8d5475cdd53" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Sys::Syslog&lt;/code&gt; exports the symbols from the &lt;code&gt;:standard&lt;/code&gt; tag.</source>
          <target state="translated">默认情况下， &lt;code&gt;Sys::Syslog&lt;/code&gt; 从 &lt;code&gt;:standard&lt;/code&gt; 标记中导出符号。</target>
        </trans-unit>
        <trans-unit id="ea04cfd93bdf64370c1cc20e848935f755855d27" translate="yes" xml:space="preserve">
          <source>By default, CJK unified ideographs are ordered in Unicode codepoint order, but those in the CJK Unified Ideographs block are less than those in the CJK Unified Ideographs Extension A etc.</source>
          <target state="translated">默认情况下,中日韩统一表意文字是按Unicode码点顺序排列的,但中日韩统一表意文字块中的表意文字要少于中日韩统一表意文字扩展A等。</target>
        </trans-unit>
        <trans-unit id="c9fd4df55423b1ff0429c30297d024455fc09d6b" translate="yes" xml:space="preserve">
          <source>By default, CPAN will install the latest non-developer release of a module. If you want to install a dev release, you have to specify the partial path starting with the author id to the tarball you wish to install, like so:</source>
          <target state="translated">默认情况下,CPAN会安装一个模块的最新非开发者版本。如果你想安装一个开发版,你必须指定一个以作者 id 开始的部分路径,以达到你想安装的 tar 包,就像这样。</target>
        </trans-unit>
        <trans-unit id="d31a5f0a0e7ac5c54379eb4d64385f193a7c7e78" translate="yes" xml:space="preserve">
          <source>By default, Data::Dumper builds up the &quot;seen&quot; hash of scalars that it has encountered during serialization. This is very expensive. This seen hash is necessary to support and even just detect circular references. It is exposed to the user via the &lt;code&gt;Seen()&lt;/code&gt; call both for writing and reading.</source>
          <target state="translated">默认情况下，Data :: Dumper会建立序列化过程中遇到的标量的&amp;ldquo;可见&amp;rdquo;散列。这非常昂贵。这种可见的散列对于支持甚至检测循环引用都是必需的。它通过 &lt;code&gt;Seen()&lt;/code&gt; 调用显示给用户，以进行写入和读取。</target>
        </trans-unit>
        <trans-unit id="cd1b6853947249bceb85a960748d4561e30fc8ae" translate="yes" xml:space="preserve">
          <source>By default, GetOptions parses the options that are present in the global array &lt;code&gt;@ARGV&lt;/code&gt; . A special entry &lt;code&gt;GetOptionsFromArray&lt;/code&gt; can be used to parse options from an arbitrary array.</source>
          <target state="translated">默认情况下，GetOptions解析全局数组 &lt;code&gt;@ARGV&lt;/code&gt; 中存在的选项。特殊条目 &lt;code&gt;GetOptionsFromArray&lt;/code&gt; 可用于解析任意数组中的选项。</target>
        </trans-unit>
        <trans-unit id="96d8266281e8d2795ccf65d39f9f3a28ecacdd25" translate="yes" xml:space="preserve">
          <source>By default, HP-UX comes configured with a maximum data segment size of 64MB. This is too small to correctly compile Perl with the maximum optimization levels. You can increase the size of the maxdsiz kernel parameter through the use of SAM.</source>
          <target state="translated">默认情况下,HP-UX配置的最大数据段大小为64MB。这个大小太小了,无法正确编译具有最大优化级别的Perl。你可以通过使用SAM来增加maxdsiz内核参数的大小。</target>
        </trans-unit>
        <trans-unit id="137732db42e50a8e0a9c182ecd242a32825b115f" translate="yes" xml:space="preserve">
          <source>By default, Hangul syllables are decomposed into Hangul Jamo, even if &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; . But the mapping of Hangul syllables may be overridden.</source>
          <target state="translated">默认情况下，即使 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，韩文音节也被分解为韩文Jamo 。但是，韩文音节的映射可能会被覆盖。</target>
        </trans-unit>
        <trans-unit id="41b45806d57c8440d5ef81fe98a720868522060d" translate="yes" xml:space="preserve">
          <source>By default, Perl assumes that it must do most of its arithmetic in floating point. But by saying</source>
          <target state="translated">默认情况下,Perl认为它必须用浮点运算来完成大部分运算。但如果说</target>
        </trans-unit>
        <trans-unit id="4de9fffb0ae0d357c4fcb6328d235687ad4441ca" translate="yes" xml:space="preserve">
          <source>By default, Perl does a depth-first left-to-right search for a method. That means it starts with the first parent in the &lt;code&gt;@ISA&lt;/code&gt; array, and then searches all of its parents, grandparents, etc. If it fails to find the method, it then goes to the next parent in the original class's &lt;code&gt;@ISA&lt;/code&gt; array and searches from there.</source>
          <target state="translated">默认情况下，Perl对方法进行深度优先的从左到右搜索。这意味着它从 &lt;code&gt;@ISA&lt;/code&gt; 数组中的第一个父级开始，然后搜索其所有父级，祖父母等。如果未能找到该方法，则它将转到原始类的 &lt;code&gt;@ISA&lt;/code&gt; 数组中的下一个父级并进行搜索从那里。</target>
        </trans-unit>
        <trans-unit id="b268ca20b85e7cb3d549ac0ab2d0251384881b6c" translate="yes" xml:space="preserve">
          <source>By default, Perl itself (outside the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module) ignores the current locale. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma tells Perl to use the current locale for some operations. Starting in v5.16, there are optional parameters to this pragma, described below, which restrict which operations are affected by it.</source>
          <target state="translated">默认情况下，Perl本身（在&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块外部）将忽略当前语言环境。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 编译告诉Perl使用当前区域设置的一些操作。从v5.16开始，此编译指示有一些可选参数，如下所述，它们限制了受其影响的操作。</target>
        </trans-unit>
        <trans-unit id="d3796ef67591d4f35614b1eaeb5b1f668ac93c4c" translate="yes" xml:space="preserve">
          <source>By default, Perl's built-in OO system is very minimal, leaving you to do most of the work. This minimalism made a lot of sense in 1994, but in the years since Perl 5.0 we've seen a number of common patterns emerge in Perl OO. Fortunately, Perl's flexibility has allowed a rich ecosystem of Perl OO systems to flourish.</source>
          <target state="translated">默认情况下,Perl内置的OO系统是非常简约的,让你来做大部分的工作。这种极简主义在1994年是很有意义的,但在Perl 5.0之后的几年里,我们看到Perl OO中出现了一些常见的模式。幸运的是,Perl的灵活性使得一个丰富的Perl OO系统的生态系统得以蓬勃发展。</target>
        </trans-unit>
        <trans-unit id="fcb268259208b983d01ebd2fb8ea62f828af5570" translate="yes" xml:space="preserve">
          <source>By default, Pod::Escapes exports none of its symbols. But you can request any of them to be exported. Either request them individually, as with &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; , or you can do &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; to get all exportable symbols.</source>
          <target state="translated">默认情况下，Pod :: Escapes不会导出任何符号。但是您可以要求将其中任何一个导出。要么单独请求它们，如 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(symbolname symbolname2...);&lt;/code&gt; ，或者您也可以 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Pod::Escapes qw(:ALL);&lt;/code&gt; 获取所有可导出的符号。</target>
        </trans-unit>
        <trans-unit id="a42f3e93e67354db749eedfb3803802a7a1b163f" translate="yes" xml:space="preserve">
          <source>By default, Pod::Man produces the most conservative possible *roff output to try to ensure that it will work with as many different *roff implementations as possible. Many *roff implementations cannot handle non-ASCII characters, so this means all non-ASCII characters are converted either to a *roff escape sequence that tries to create a properly accented character (at least for troff output) or to &lt;code&gt;X&lt;/code&gt; .</source>
          <target state="translated">默认情况下，Pod :: Man会生成最保守的* roff输出，以尝试确保它将与尽可能多的不同* roff实现一起使用。许多的* roff实现不能处理非ASCII字符，因此，这意味着所有的非ASCII字符或者转换为*的roff转义序列，试图创建一个适当重音字符（至少对于troff的输出），或 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98107783dba2f8c87d2092a6ced42a0827ce5268" translate="yes" xml:space="preserve">
          <source>By default, Pod::Text uses the same output encoding as the input encoding of the POD source (provided that Perl was built with PerlIO; otherwise, it doesn't encode its output). If this option is given, the output encoding is forced to UTF-8.</source>
          <target state="translated">默认情况下,Pod::Text使用与POD源的输入编码相同的输出编码(前提是Perl是用PerlIO构建的;否则,它不会对输出进行编码)。如果给定了这个选项,输出编码将被强制为UTF-8。</target>
        </trans-unit>
        <trans-unit id="607468b061542c5fb308ea35e966138c590f5abc" translate="yes" xml:space="preserve">
          <source>By default, Pod::Usage will call &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; when -verbose &amp;gt;= 2 is specified. This does not work well e.g. if the script was packed with &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;. The -noperldoc option suppresses the external call to &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; and uses the simple text formatter (&lt;a href=&quot;text&quot;&gt;Pod::Text&lt;/a&gt;) to output the POD.</source>
          <target state="translated">默认情况下，当指定-verbose&amp;gt; = 2时，Pod :: Usage将调用&lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt;。这不能很好地工作，例如，如果脚本中包含&lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;。-noperldoc选项禁止对&lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt;的外部调用，并使用简单文本格式化程序（&lt;a href=&quot;text&quot;&gt;Pod :: Text&lt;/a&gt;）输出POD。</target>
        </trans-unit>
        <trans-unit id="7aaf9130ce3cc364b8ff0d6d870dfc5f5e3ff5d9" translate="yes" xml:space="preserve">
          <source>By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match. If you want it to match the minimum number of times possible, follow the quantifier with a &quot;?&quot;. Note that the meanings don't change, just the &quot;greediness&quot;:</source>
          <target state="translated">默认情况下,量化子模式是 &quot;贪婪的&quot;,也就是说,它将尽可能多地匹配(给定一个特定的起始位置),同时仍然允许模式的其他部分匹配。如果你想让它尽可能地减少匹配次数,可以在量化符后面加上&quot;?&quot;。注意,含义不会改变,只是 &quot;贪婪&quot;。</target>
        </trans-unit>
        <trans-unit id="b48a9b04f7e394f8ae5c84a6badf024eee518a01" translate="yes" xml:space="preserve">
          <source>By default, all ftp connections are done in passive mode. To change that, see the &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; variable further down.</source>
          <target state="translated">默认情况下，所有ftp连接都是在被动模式下完成的。要更改此设置，请进一步查看 &lt;code&gt;$FTP_PASSIVE&lt;/code&gt; 变量。</target>
        </trans-unit>
        <trans-unit id="7f80a56139fac5d67611619acae3e63a365a4381" translate="yes" xml:space="preserve">
          <source>By default, attribute handlers are called at the end of the compilation phase (in a &lt;code&gt;CHECK&lt;/code&gt; block). This seems to be optimal in most cases because most things that can be defined are defined by that point but nothing has been executed.</source>
          <target state="translated">默认情况下，属性处理程序在编译阶段结束时（在 &lt;code&gt;CHECK&lt;/code&gt; 块中）被调用。在大多数情况下，这似乎是最佳选择，因为大多数可定义的事物都由该点定义，但是什么都没有执行。</target>
        </trans-unit>
        <trans-unit id="d92e033ccee030ae17ccf241ebba25503e925cbf" translate="yes" xml:space="preserve">
          <source>By default, but can be redefined.</source>
          <target state="translated">默认情况下,但可以重新定义。</target>
        </trans-unit>
        <trans-unit id="9f90d660b6b88d20d5a032c88e00b0f974301c2b" translate="yes" xml:space="preserve">
          <source>By default, case-sensitive comparison (that is level 3 difference) won't ignore accents (that is level 2 difference).</source>
          <target state="translated">默认情况下,区分大小写的比较(也就是3级差)不会忽略重音(也就是2级差)。</target>
        </trans-unit>
        <trans-unit id="b957d395a8a7eedebb03724489ebfa7e55174b9c" translate="yes" xml:space="preserve">
          <source>By default, classes in Perl only perform the &lt;code&gt;UNIVERSAL&lt;/code&gt; role, as well as the role of all classes in their inheritance. In other words, by default &lt;code&gt;DOES&lt;/code&gt; responds identically to &lt;code&gt;isa&lt;/code&gt; .</source>
          <target state="translated">默认情况下，Perl中的类仅扮演 &lt;code&gt;UNIVERSAL&lt;/code&gt; 角色，以及所有类在其继承中的角色。换句话说，默认情况下， &lt;code&gt;DOES&lt;/code&gt; 对 &lt;code&gt;isa&lt;/code&gt; 的响应相同。</target>
        </trans-unit>
        <trans-unit id="a09751b6a3dd219cd03f615c311b1588c0433a01" translate="yes" xml:space="preserve">
          <source>By default, each time the CPAN module is started, cache scanning is performed to keep the cache size in sync ('atstart'). Alternatively, scanning and cleanup can happen when CPAN exits ('atexit'). To prevent any cache cleanup, answer 'never'.</source>
          <target state="translated">默认情况下,每次CPAN模块启动时,都会进行缓存扫描以保持缓存大小同步('atstart')。或者,扫描和清理可以在CPAN退出时进行('atexit')。要防止任何缓存清理,回答 &quot;never&quot;。</target>
        </trans-unit>
        <trans-unit id="a04a99ac495330cd07b871fc7a9618f7082ee169" translate="yes" xml:space="preserve">
          <source>By default, every base class needs to live in a file of its own. If you want to have a subclass and its parent class in the same file, you can tell &lt;code&gt;parent&lt;/code&gt; not to load any modules by using the &lt;code&gt;-norequire&lt;/code&gt; switch:</source>
          <target state="translated">默认情况下，每个基类都需要驻留在自己的文件中。如果要在同一文件中包含子类及其父类，则可以使用 &lt;code&gt;-norequire&lt;/code&gt; 开关告诉 &lt;code&gt;parent&lt;/code&gt; 不要加载任何模块：</target>
        </trans-unit>
        <trans-unit id="009314417d0e225d96e9c70c4f8a61f37cbd61fb" translate="yes" xml:space="preserve">
          <source>By default, file names are assumed to be case sensitive; this flag makes bsd_glob() treat case differences as not significant.</source>
          <target state="translated">默认情况下,文件名是区分大小写的;这个标志使得bsd_glob()将大小写差异视为不重要。</target>
        </trans-unit>
        <trans-unit id="6e050dc7d694db5e9597e9b5666a97cb998c6670" translate="yes" xml:space="preserve">
          <source>By default, hiragana is before katakana. If the parameter is made true, this is reversed.</source>
          <target state="translated">默认情况下,平假名在片假名之前。如果该参数为真,则会反过来。</target>
        </trans-unit>
        <trans-unit id="a68b6a00ff07db87e5b4fca637ec784a918f2f88" translate="yes" xml:space="preserve">
          <source>By default, if a redispatch attempt fails to find another method elsewhere in the objects class hierarchy, it quietly gives up and does nothing (but see &lt;a href=&quot;#Enforcing-redispatch&quot;&gt;Enforcing redispatch&lt;/a&gt;). This gracious acquiescence is also unlike the (generally annoying) behaviour of &lt;code&gt;SUPER&lt;/code&gt; , which throws an exception if it cannot redispatch.</source>
          <target state="translated">默认情况下，如果重新分配尝试未能在对象类层次结构中的其他地方找到另一个方法，则它会安静地放弃并且不执行任何操作（但请参见&lt;a href=&quot;#Enforcing-redispatch&quot;&gt;实施redispatch&lt;/a&gt;）。这种客气的默认也不同于 &lt;code&gt;SUPER&lt;/code&gt; 的（通常令人讨厌的）行为，如果SUPER无法重新分派，则会抛出异常。</target>
        </trans-unit>
        <trans-unit id="622748004543277cac1eed24641a5d626b92e074" translate="yes" xml:space="preserve">
          <source>By default, it checks only ascii, utf8 and UTF-16/32 with BOM.</source>
          <target state="translated">默认情况下,它只检查ascii、utf8和UTF-16/32与BOM。</target>
        </trans-unit>
        <trans-unit id="7d795357eb0370d795216bc893725d71f457449f" translate="yes" xml:space="preserve">
          <source>By default, it exports the functions cwd(), getcwd(), fastcwd(), and fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.</source>
          <target state="translated">默认情况下,它将函数cwd()、getcwd()、fastcwd()和fastgetcwd()(以及在Win32上的getdcwd())导出到调用者的命名空间。</target>
        </trans-unit>
        <trans-unit id="bd57ef383f01461a26729aaf5bda1caeec29a44b" translate="yes" xml:space="preserve">
          <source>By default, lowercase is before uppercase. If the parameter is made true, this is reversed.</source>
          <target state="translated">默认情况下,小写字母在大写字母之前。如果该参数为真,则会反过来。</target>
        </trans-unit>
        <trans-unit id="bd52b1e53c314fe3c4b656aedbdea4b06daed47d" translate="yes" xml:space="preserve">
          <source>By default, no comment field is written to the zip file.</source>
          <target state="translated">默认情况下,没有注释字段被写入压缩文件。</target>
        </trans-unit>
        <trans-unit id="5d5b6fb015586b3864b9f25cf4e1c4322f8f41ee" translate="yes" xml:space="preserve">
          <source>By default, optional warnings are disabled, so any legacy code that doesn't attempt to control the warnings will work unchanged.</source>
          <target state="translated">默认情况下,可选的警告是被禁用的,所以任何不试图控制警告的遗留代码都不会改变。</target>
        </trans-unit>
        <trans-unit id="56744be38bf9987fcb8b98dab67cef731ba84ab1" translate="yes" xml:space="preserve">
          <source>By default, perl handles file globbing using the File::Glob extension, which provides portable globbing.</source>
          <target state="translated">默认情况下,perl使用File::Glob扩展来处理文件glob,它提供了可移植的glob。</target>
        </trans-unit>
        <trans-unit id="b252359c438a3c8369c5cbca58632d9664dd0131" translate="yes" xml:space="preserve">
          <source>By default, perl uses the large file compilation environment and relies on Solaris to do the underlying mapping of interfaces.</source>
          <target state="translated">默认情况下,perl使用大文件编译环境,依靠Solaris来做底层的接口映射。</target>
        </trans-unit>
        <trans-unit id="95ea6d685281e6fc9b1246edd3de6ccbfbf85ecd" translate="yes" xml:space="preserve">
          <source>By default, perl will be compiled as a 32-bit application. Unless you want to allocate more than ~ 4GB of memory inside perl, or unless you need more than 255 open file descriptors, you probably don't need perl to be a 64-bit app.</source>
          <target state="translated">默认情况下,perl将被编译为32位应用程序。除非你想在perl内部分配超过4GB的内存,或者你需要超过255个打开的文件描述符,否则你可能不需要perl成为一个64位的应用程序。</target>
        </trans-unit>
        <trans-unit id="8beb3118174cbb4befcc9218c3e11ee8559a67ed" translate="yes" xml:space="preserve">
          <source>By default, perl-5.6.0 (or later) is compiled as a 32-bit application with largefile and long-long support.</source>
          <target state="translated">默认情况下,perl-5.6.0(或更高版本)是作为一个32位应用程序编译的,支持大文件和长文件。</target>
        </trans-unit>
        <trans-unit id="c1d7d31b73907dcda6cd3ad0857aee8de05a33a3" translate="yes" xml:space="preserve">
          <source>By default, running out of memory is an untrappable, fatal error. However, if suitably built, Perl can use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency memory pool after &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;ing. Suppose that your Perl were compiled with &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; and used Perl's malloc. Then</source>
          <target state="translated">默认情况下，内存不足是无法陷阱的致命错误。但是，如果构建得当，Perl可以在 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 之后使用 &lt;code&gt;$^M&lt;/code&gt; 的内容作为紧急存储池。假设您的Perl是使用 &lt;code&gt;-DPERL_EMERGENCY_SBRK&lt;/code&gt; 编译的，并且使用了Perl的malloc。然后</target>
        </trans-unit>
        <trans-unit id="4190ef76a4299cfe3e352f5cfeb999b38851b5f5" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt; in which case section 3 will be selected.</source>
          <target state="translated">默认情况下，将使用第1节，除非文件以 &lt;code&gt;.pm&lt;/code&gt; 结尾，在这种情况下将选择第3节。</target>
        </trans-unit>
        <trans-unit id="8d9133733d7f7dcd376ecd3cd224e4dddd523774" translate="yes" xml:space="preserve">
          <source>By default, section 1 will be used unless the file ends in &lt;code&gt;.pm&lt;/code&gt;, in which case section 3 will be selected.</source>
          <target state="translated">默认情况下，除非文件以 &lt;code&gt;.pm&lt;/code&gt; 结尾，否则将使用第1节，在这种情况下，将选择第3节。</target>
        </trans-unit>
        <trans-unit id="961a8c7a3d78a4ba111b92d292c8ae5c80f7c1a1" translate="yes" xml:space="preserve">
          <source>By default, semaphores behave like locks, letting only one thread &lt;code&gt;down()&lt;/code&gt; them at a time. However, there are other uses for semaphores.</source>
          <target state="translated">默认情况下，信号量的行为类似于锁，一次只允许一个线程 &lt;code&gt;down()&lt;/code&gt; 。但是，信号量还有其他用途。</target>
        </trans-unit>
        <trans-unit id="fed769cd67eb1346af1f13055d0984c3c18e8ed3" translate="yes" xml:space="preserve">
          <source>By default, strings whose weights are equal should be equal, even though their code points are not equal. Completely ignorable characters are ignored.</source>
          <target state="translated">默认情况下,权重相等的字符串应该是相等的,即使它们的代码点不相等。完全可忽略的字符会被忽略。</target>
        </trans-unit>
        <trans-unit id="4a36fa72282c7563bf7e21fc24cf3c3c9ea04d1b" translate="yes" xml:space="preserve">
          <source>By default, the</source>
          <target state="translated">默认情况下</target>
        </trans-unit>
        <trans-unit id="56921ea3749d0afb26fde19f34e5cd700c2dac28" translate="yes" xml:space="preserve">
          <source>By default, the &quot;^&quot; character is guaranteed to match only the beginning of the string, the &quot;$&quot; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line. Embedded newlines will not be matched by &quot;^&quot; or &quot;$&quot;. You may, however, wish to treat a string as a multi-line buffer, such that the &quot;^&quot; will match after any newline within the string (except if the newline is the last character in the string), and &quot;$&quot; will match before any newline. At the cost of a little more overhead, you can do this by using the /m modifier on the pattern match operator. (Older programs did this by setting &lt;code&gt;$*&lt;/code&gt; , but this option was removed in perl 5.10.)</source>
          <target state="translated">默认情况下，保证&amp;ldquo; ^&amp;rdquo;字符仅匹配字符串的开头，&amp;ldquo; $&amp;rdquo;字符仅匹配结尾（或末尾的换行符），并且Perl在假定字符串仅包含字符串的情况下进行了某些优化。一条线。嵌入的换行符不会与&amp;ldquo; ^&amp;rdquo;或&amp;ldquo; $&amp;rdquo;匹配。但是，您可能希望将字符串视为多行缓冲区，以使&amp;ldquo; ^&amp;rdquo;将在字符串中的任何换行符之后匹配（除非换行符是字符串中的最后一个字符），而&amp;ldquo; $&amp;rdquo;将在任何换行符之前匹配。您可以通过花费一些额外开销来实现，方法是使用模式匹配运算符上的/ m修饰符。 （较早的程序通过设置 &lt;code&gt;$*&lt;/code&gt; 完成此操作，但是此选项在perl 5.10中已删除。）</target>
        </trans-unit>
        <trans-unit id="a1a870bf9d52ad0a2c1a90186336492c4ae0aed3" translate="yes" xml:space="preserve">
          <source>By default, the function is &lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;, and the SV parameter is</source>
          <target state="translated">默认情况下，该函数为&lt;a href=&quot;#ck_entersub_args_proto_or_list&quot;&gt;Perl_ck_entersub_args_proto_or_list&lt;/a&gt;，并且SV参数为</target>
        </trans-unit>
        <trans-unit id="beeed48a59ea18c1b18a6cfda68d25973cd743b6" translate="yes" xml:space="preserve">
          <source>By default, the installed filter only filters up to a line consisting of one of the three standard source &quot;terminators&quot;:</source>
          <target state="translated">默认情况下,安装的过滤器最多只能过滤由三个标准源 &quot;终结符 &quot;之一组成的行。</target>
        </trans-unit>
        <trans-unit id="e79e890007f8b504a54617ddbf05ff93a90734ba" translate="yes" xml:space="preserve">
          <source>By default, the only variables shared with compartments are the &quot;underscore&quot; variables $_ and @_ (and, technically, the less frequently used %_, the _ filehandle and so on). This is because otherwise perl operators which default to $_ will not work and neither will the assignment of arguments to @_ on subroutine entry.</source>
          <target state="translated">默认情况下,与隔间共享的变量只有 &quot;下划线 &quot;变量$_和@_(技术上,还有不常用的%_、_文件柄等)。这是因为,否则默认为$_的perl运算符将无法使用,子程序进入时将参数赋给@_也无法使用。</target>
        </trans-unit>
        <trans-unit id="4eebbb2dfa043331a8ced51ef018a956d406180e" translate="yes" xml:space="preserve">
          <source>By default, the pathnames are sorted in ascending ASCII order; this flag prevents that sorting (speeding up bsd_glob()).</source>
          <target state="translated">默认情况下,路径名是按照ASCII码升序排序的;这个标志可以防止这种排序方式(加快bsd_glob()的速度)。</target>
        </trans-unit>
        <trans-unit id="cd52d7b7234ea4b8c1ee0272333575fae9c9ac61" translate="yes" xml:space="preserve">
          <source>By default, the string appended is assumed to be valid UTF-8 if the SV has the UTF-8 status set, and a string of bytes otherwise. One can force the appended string to be interpreted as UTF-8 by supplying the &lt;code&gt;SV_CATUTF8&lt;/code&gt; flag, and as bytes by supplying the &lt;code&gt;SV_CATBYTES&lt;/code&gt; flag; the SV or the string appended will be upgraded to UTF-8 if necessary.</source>
          <target state="translated">默认情况下，如果SV设置了UTF-8状态，则假定附加的字符串为有效的UTF-8，否则假定为字符串。人可以强迫所附字符串通过提供被解释为UTF-8 &lt;code&gt;SV_CATUTF8&lt;/code&gt; 标志，并且如通过提供字节 &lt;code&gt;SV_CATBYTES&lt;/code&gt; 标志; 如有必要，SV或附加的字符串将升级为UTF-8。</target>
        </trans-unit>
        <trans-unit id="8d41f8d85e7a977c1704e0b6aa0d1e3446f200e7" translate="yes" xml:space="preserve">
          <source>By default, this module creates an &lt;code&gt;::I18N&lt;/code&gt; subclass under the caller's package (or the package specified by &lt;code&gt;Class&lt;/code&gt; ), and stores lexicon data in its subclasses. You can assign a name other than &lt;code&gt;I18N&lt;/code&gt; via this option.</source>
          <target state="translated">默认情况下，此模块在调用者的包（或 &lt;code&gt;Class&lt;/code&gt; 指定的包）下创建 &lt;code&gt;::I18N&lt;/code&gt; 子类，并将词典数据存储在其子类中。您可以通过此选项分配 &lt;code&gt;I18N&lt;/code&gt; 以外的名称。</target>
        </trans-unit>
        <trans-unit id="5949c007c079cc7a10f34781de30c09a225b6eca" translate="yes" xml:space="preserve">
          <source>By default, this module exports a single function, &lt;code&gt;loc&lt;/code&gt; , into its caller's namespace. You can set it to another name, or set it to an empty string to disable exporting.</source>
          <target state="translated">默认情况下，此模块将单个函数 &lt;code&gt;loc&lt;/code&gt; 导出到其调用者的名称空间。您可以将其设置为其他名称，或将其设置为空字符串以禁用导出。</target>
        </trans-unit>
        <trans-unit id="8ad4115958f94effa9746305a9b0cb4cffc6bd7c" translate="yes" xml:space="preserve">
          <source>By default, this module uses the &lt;code&gt;maketext&lt;/code&gt; style of &lt;code&gt;[_1]&lt;/code&gt; and &lt;code&gt;[quant,_1]&lt;/code&gt; for interpolation. Alternatively, you can specify the &lt;code&gt;gettext&lt;/code&gt; style, which uses &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%quant(%1)&lt;/code&gt; for interpolation.</source>
          <target state="translated">默认情况下，此模块使用 &lt;code&gt;[_1]&lt;/code&gt; 和 &lt;code&gt;[quant,_1]&lt;/code&gt; 的 &lt;code&gt;maketext&lt;/code&gt; 样式进行插值。或者，您可以指定 &lt;code&gt;gettext&lt;/code&gt; 样式，该样式使用 &lt;code&gt;%1&lt;/code&gt; 和 &lt;code&gt;%quant(%1)&lt;/code&gt; 进行插值。</target>
        </trans-unit>
        <trans-unit id="252a3c80bb1e3517a1330d8a71715773619ce9ac" translate="yes" xml:space="preserve">
          <source>By default, variables are private to each thread, and each newly created thread gets a private copy of each existing variable. This module allows you to share variables across different threads (and pseudo-forks on Win32). It is used together with the &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; module.</source>
          <target state="translated">默认情况下，变量是每个线程专用的，每个新创建的线程都将获取每个现有变量的专用副本。该模块允许您在不同线程（和Win32上的伪叉）之间共享变量。它与&lt;a href=&quot;../threads&quot;&gt;线程&lt;/a&gt;模块一起使用。</target>
        </trans-unit>
        <trans-unit id="08d154b38941f09ce6557f839a81a8eafedac239" translate="yes" xml:space="preserve">
          <source>By default, when a new interpreter is created as a copy of an existing one (eg via &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ), both interpreters share the same physical my_cxt_t structure. Calling &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; (typically via the package's &lt;code&gt;CLONE()&lt;/code&gt; function), causes a byte-for-byte copy of the structure to be taken, and any future dMY_CXT will cause the copy to be accessed instead.</source>
          <target state="translated">默认情况下，当将新解释器创建为现有解释器的副本时（例如，通过 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; ），两个解释器共享相同的物理my_cxt_t结构。调用 &lt;code&gt;MY_CXT_CLONE&lt;/code&gt; （通常通过程序包的 &lt;code&gt;CLONE()&lt;/code&gt; 函数）将导致结构的逐字节复制，而以后的任何dMY_CXT都会导致对该复制进行访问。</target>
        </trans-unit>
        <trans-unit id="1f023b47e4b490e5f3861a02400fb5ce0693a9fc" translate="yes" xml:space="preserve">
          <source>By default, your program starts in package &lt;code&gt;main&lt;/code&gt; , so you will always be in some package.</source>
          <target state="translated">默认情况下，您的程序从包 &lt;code&gt;main&lt;/code&gt; 开始，因此您将始终处于某个包中。</target>
        </trans-unit>
        <trans-unit id="cc16f7e5e668d806fbde2fd531d2629a195bfd9c" translate="yes" xml:space="preserve">
          <source>By explicitly requiring a minimum Perl version number for your program, with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; construct. That is,</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 构造为程序明确要求最低Perl版本号。那是，</target>
        </trans-unit>
        <trans-unit id="b496b26c66a41bb8b28e0a2591cb8dda23a4871c" translate="yes" xml:space="preserve">
          <source>By far the easiest way to build Perl for OS/400 is to use the PASE (Portable Application Solutions Environment), for more information see &lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt; This environment allows one to use AIX APIs while programming, and it provides a runtime that allows AIX binaries to execute directly on the PowerPC iSeries.</source>
          <target state="translated">到目前为止，为OS / 400构建Perl的最简单方法是使用PASE（便携式应用程序解决方案环境），有关更多信息，请参见&lt;a href=&quot;http://www.iseries.ibm.com/developer/factory/pase/index.html&quot;&gt;http://www.iseries.ibm.com/developer/factory/pase/index.html&lt;/a&gt;。环境允许在编程时使用AIX API，并且它提供了允许AIX二进制文件直接在PowerPC iSeries上执行的运行时。</target>
        </trans-unit>
        <trans-unit id="90b268ad6928ce9b139ce0bfe20e0ab522c5a230" translate="yes" xml:space="preserve">
          <source>By far the most common reason is that the locale has characters in it that are represented by more than one byte. The only such locales that Perl can handle are the UTF-8 locales. Most likely the specified locale is a non-UTF-8 one for an East Asian language such as Chinese or Japanese. If the locale is a superset of ASCII, the ASCII portion of it may work in Perl.</source>
          <target state="translated">到目前为止,最常见的原因是locale中的字符由多个字节表示。Perl能处理的唯一的这种locale是UTF-8的locale。很可能指定的locale是一个非UTF-8的东亚语言,比如中文或日文。如果这个locale是ASCII码的超集,那么它的ASCII码部分就可以在Perl中使用。</target>
        </trans-unit>
        <trans-unit id="5be86ce403211ab50be3b7ce1f4f87ec5b6bd179" translate="yes" xml:space="preserve">
          <source>By first converting the FOO-encoded byte string to a text string, and then the text string to a BAR-encoded byte string:</source>
          <target state="translated">通过先将FOO编码的字节串转换成文本串,再将文本串转换成BAR编码的字节串。</target>
        </trans-unit>
        <trans-unit id="3456e5ab0f472be26a41623d10e3cc8ff953c769" translate="yes" xml:space="preserve">
          <source>By including Exporter in your &lt;code&gt;@ISA&lt;/code&gt; you inherit an Exporter's import() method but you also inherit several other helper methods which you probably don't want. To avoid this you can do:</source>
          <target state="translated">通过将Exporter包含在 &lt;code&gt;@ISA&lt;/code&gt; 中,您可以继承Exporter的import（）方法，但也可以继承其他一些可能不需要的帮助器方法。为避免这种情况，您可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="583ac2704011a6bdba33e0ae7763c40858b78828" translate="yes" xml:space="preserve">
          <source>By passing a reference to a hash you may set the configuration values. This works only for values that a marked with a &lt;code&gt;RW&lt;/code&gt; above, anything else is read-only.</source>
          <target state="translated">通过将引用传递给哈希，可以设置配置值。这仅适用于标有 &lt;code&gt;RW&lt;/code&gt; 的值，其他任何值都是只读的。</target>
        </trans-unit>
        <trans-unit id="e30293ddc7efc1598420ad5a32ac1415cea4ba8a" translate="yes" xml:space="preserve">
          <source>By running &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you ensure that your Mytest.t script runs and uses the correct version of your extension. If you have many test cases, save your test files in the &quot;t&quot; directory and use the suffix &quot;.t&quot;. When you run &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, all of these test files will be executed.</source>
          <target state="translated">通过运行&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo;，可以确保Mytest.t脚本运行并使用正确的扩展版本。如果您有很多测试用例，请将测试文件保存在&amp;ldquo; t&amp;rdquo;目录中，并使用后缀&amp;ldquo; .t&amp;rdquo;。当您运行&amp;ldquo; &lt;code&gt;make test&lt;/code&gt; &amp;rdquo;时，所有这些测试文件将被执行。</target>
        </trans-unit>
        <trans-unit id="49d2ff2073c166abecd08a90ef566dc2e86a7f38" translate="yes" xml:space="preserve">
          <source>By setting and then using &lt;code&gt;$var&lt;/code&gt; in this way relieves you from having to worry about exactly which numbered set of parentheses they are.</source>
          <target state="translated">通过以这种方式设置然后使用 &lt;code&gt;$var&lt;/code&gt; ，可以使您不必担心它们到底是哪个编号的括号。</target>
        </trans-unit>
        <trans-unit id="265fb107c25a0f703500d08dbe4e8f2787903896" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string you can generate a Makefile that prints all commands. Mainly used in debugging MakeMaker itself.</source>
          <target state="translated">通过设置为空字符串,可以生成一个打印所有命令的Makefile。主要用于调试MakeMaker本身。</target>
        </trans-unit>
        <trans-unit id="619bd2bab7e99a9933fcadbbac647cbc3917a48b" translate="yes" xml:space="preserve">
          <source>By specifying &lt;code&gt;:loose&lt;/code&gt; , Unicode's &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;loose character name matching&lt;/a&gt; rules are selected instead of the strict exact match used otherwise. That means that</source>
          <target state="translated">通过指定 &lt;code&gt;:loose&lt;/code&gt; ，将选择Unicode的&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr44%23Matching_Rules&quot;&gt;宽松字符名称匹配&lt;/a&gt;规则，而不是其他情况下使用的严格精确匹配。那意味着</target>
        </trans-unit>
        <trans-unit id="4173811273acdfc3b518c06a8c9add11d80be073" translate="yes" xml:space="preserve">
          <source>By subclassing, you may end up overriding undocumented methods. That's not a bad thing per se, but be forewarned that undocumented methods may change without warning from one release to the next - we cannot guarantee backwards compatibility. If any</source>
          <target state="translated">通过子类化,你可能最终会覆盖未记录的方法。这本身并不是一件坏事,但要注意的是,未记录的方法可能会在没有警告的情况下从一个版本改变到下一个版本--我们不能保证向后兼容。如果有任何</target>
        </trans-unit>
        <trans-unit id="7963af28b4afe4fecf3771e6be636d3a37450528" translate="yes" xml:space="preserve">
          <source>By the time Perl 5 rolled around, we were already stuck with this design: Hash values must be scalars. The solution to this is references.</source>
          <target state="translated">当Perl 5推出的时候,我们已经被这种设计所困。哈希值必须是标量值 解决这个问题的办法就是引用。</target>
        </trans-unit>
        <trans-unit id="92f8d8ab799211d118cdd3b80bc6282c36c18e07" translate="yes" xml:space="preserve">
          <source>By the time each of the &lt;code&gt;SaveSub1&lt;/code&gt; statements above has been executed, the SV*s which corresponded to the parameters will no longer exist. Expect an error message from Perl of the form</source>
          <target state="translated">到上述每个 &lt;code&gt;SaveSub1&lt;/code&gt; 语句执行完毕时，与参数相对应的SV *将不再存在。期待来自Perl的错误消息，形式如下</target>
        </trans-unit>
        <trans-unit id="334c1508a5d779cb0c1040092154fbe0583ab19f" translate="yes" xml:space="preserve">
          <source>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run, in routines that read the &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; field which it populates.</source>
          <target state="translated">到comp回调被调用时，这些标志中的某些标志已经生效（在适用的地方，在下面注明）。但是，它们的大多数影响发生在comp回调运行之后，在读取其所填充的 &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; 字段的例程中。</target>
        </trans-unit>
        <trans-unit id="72795a79e31e2518cbd921d2bc0697a1bdbd6144" translate="yes" xml:space="preserve">
          <source>By tuning the stack size to more accurately reflect your application's needs, you may significantly reduce your application's memory usage, and increase the number of simultaneously running threads.</source>
          <target state="translated">通过调整堆栈大小以更准确地反映应用程序的需求,您可能会显著降低应用程序的内存使用率,并增加同时运行的线程数量。</target>
        </trans-unit>
        <trans-unit id="bd379fb72b0b513ca230e24dca7f155e46117288" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; , if there is no other &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the method call, an exception will be thrown (as usually happens in the absence of a suitable &lt;code&gt;AUTOLOAD&lt;/code&gt; ).</source>
          <target state="translated">通过使用 &lt;code&gt;NEXT::ACTUAL&lt;/code&gt; ，如果没有其他 &lt;code&gt;AUTOLOAD&lt;/code&gt; 来处理方法调用，则将引发异常（通常在没有合适的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 的情况下发生）。</target>
        </trans-unit>
        <trans-unit id="f260eb29b6f0673bfdb6b907d310d5d3920f6717" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;-E&lt;/code&gt; switch on the Perl command-line instead of &lt;code&gt;-e&lt;/code&gt; . That will enable the feature bundle for that version of Perl in the main compilation unit (that is, the one-liner that follows &lt;code&gt;-E&lt;/code&gt; ).</source>
          <target state="translated">通过在Perl命令行上使用 &lt;code&gt;-E&lt;/code&gt; 开关而不是 &lt;code&gt;-e&lt;/code&gt; 。这将在主要编译单元（即， &lt;code&gt;-E&lt;/code&gt; 后面的单行代码）中启用该版本的Perl的功能包。</target>
        </trans-unit>
        <trans-unit id="9dfef463e4e713cbb716245b6be6a4856999a34d" translate="yes" xml:space="preserve">
          <source>By using the WWW interface you can ask the Upload Server to mirror your modules from your ftp or WWW site into your own directory on CPAN!</source>
          <target state="translated">通过使用WWW接口,您可以要求上传服务器将您的模块从您的ftp或WWW站点镜像到您自己的CPAN目录中!</target>
        </trans-unit>
        <trans-unit id="4f37c6bc860992a71dc03ba0a6eb8583644d0eac" translate="yes" xml:space="preserve">
          <source>By using the backslash operator on a variable, subroutine, or value. (This works much like the &amp;amp; (address-of) operator in C.) This typically creates</source>
          <target state="translated">通过对变量，子例程或值使用反斜杠运算符。（这很像C中的＆（地址）运算符。）这通常会创建</target>
        </trans-unit>
        <trans-unit id="4fea865bf2bc7c769f8247d0ffedba42a3ee67f2" translate="yes" xml:space="preserve">
          <source>By way of demonstration, we present below a laborious listing resulting from setting your &lt;code&gt;PERLDB_OPTS&lt;/code&gt; environment variable to the value &lt;code&gt;f=n N&lt;/code&gt; , and running</source>
          <target state="translated">作为演示，我们在下面列出了一个麻烦的清单，该清单是将您的 &lt;code&gt;PERLDB_OPTS&lt;/code&gt; 环境变量设置为值 &lt;code&gt;f=n N&lt;/code&gt; 并运行的结果</target>
        </trans-unit>
        <trans-unit id="05ff92e836fe1c104b327e3d41d6f42c1c2f68cf" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getgr*() functions</source>
          <target state="translated">对Perl内置的getgr*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="8701f0c6760ad255897a2adbc246d9e8608c8d7a" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gethost*() functions</source>
          <target state="translated">对Perl的内置gethost*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="8edbac978dbd72904307e2cc9662b26a10b3bd66" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getnet*() functions</source>
          <target state="translated">对Perl的内置getnet*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="905cb97e8ed297dc43dcd08d2a9db1d9958b4ddc" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getproto*() functions</source>
          <target state="translated">对Perl内置的getproto*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="7980958e534d59fc2ef012727304a32f6778bc74" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getpw*() functions</source>
          <target state="translated">对Perl内置的getpw*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="8c13e6c841eee178cc9c90b3ec31731fb7b6e9d6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in getserv*() functions</source>
          <target state="translated">对Perl内置的geterv*()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="10bacc859a37b5cb2457a9867f2de200be21a6bd" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in gmtime() function</source>
          <target state="translated">对Perl内置的gmtime()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="827cbeee072a43490f322081b175fcaabf1286c6" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in localtime() function</source>
          <target state="translated">为Perl内置的localtime()函数提供按名称命名的接口。</target>
        </trans-unit>
        <trans-unit id="34a637e08658f8356d26a5052ced9a5575ccaa48" translate="yes" xml:space="preserve">
          <source>By-name interface to Perl's built-in stat() functions</source>
          <target state="translated">对Perl内置的stat()函数的按名接口。</target>
        </trans-unit>
        <trans-unit id="00a7465e9ae8fc45cdd85380909fc57080f23c9d" translate="yes" xml:space="preserve">
          <source>Bypass shell script and produce qualifiers for CC directly (but warn user if a shell script for this extension exists). Fold multiple /Defines into one, since some C compilers pay attention to only one instance of this qualifier on the command line.</source>
          <target state="translated">绕过shell脚本,直接生成CC的限定符(但如果存在该扩展的shell脚本,则警告用户)。将多个/定义折叠成一个,因为一些C编译器只注意命令行上的一个限定符实例。</target>
        </trans-unit>
        <trans-unit id="9f9d63573452a4bd55326feb5fe5283989ad472d" translate="yes" xml:space="preserve">
          <source>Byte and Character Semantics</source>
          <target state="translated">字节和字符语义</target>
        </trans-unit>
        <trans-unit id="1e6a3eac8ab6b01ca95c7c44eb60befc42854a50" translate="yes" xml:space="preserve">
          <source>Byte order is not compatible</source>
          <target state="translated">字节顺序不兼容</target>
        </trans-unit>
        <trans-unit id="635424c9374984012107c0dd02fd2041e999753a" translate="yes" xml:space="preserve">
          <source>Byte-order modifiers</source>
          <target state="translated">字节序修改器</target>
        </trans-unit>
        <trans-unit id="b0cb8dbe3d4ffe27cb86b68da21fae1475b9d341" translate="yes" xml:space="preserve">
          <source>Byteorders &lt;code&gt;&quot;1234&quot;&lt;/code&gt; and &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; are little-endian; &lt;code&gt;&quot;4321&quot;&lt;/code&gt; and &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; are big-endian. Systems with multiarchitecture binaries will have &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; , signifying that static information doesn't work, one must use runtime probing.</source>
          <target state="translated">字节顺序 &lt;code&gt;&quot;1234&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;12345678&quot;&lt;/code&gt; 为低位字节序； &lt;code&gt;&quot;4321&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;87654321&quot;&lt;/code&gt; 为大端。具有多体系结构二进制文件的系统将具有 &lt;code&gt;&quot;ffff&quot;&lt;/code&gt; ，表示静态信息不起作用，必须使用运行时探测。</target>
        </trans-unit>
        <trans-unit id="7bf6c5677e50bfc87de6c08c11b4d2bd476a1535" translate="yes" xml:space="preserve">
          <source>Bytes in the source text that have their high-bit set will be treated as being part of a literal UTF-X sequence. This includes most literals such as identifier names, string constants, and constant regular expression patterns.</source>
          <target state="translated">源文本中具有高位集的字节将被视为字面UTF-X序列的一部分。这包括大多数的文字,如标识符名称、字符串常量和常量正则表达式模式。</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="129226dbff7ac0a26641ae86a93a3ce3ab2b8aca" translate="yes" xml:space="preserve">
          <source>C Operators Missing From Perl</source>
          <target state="translated">Perl中缺少C操作符</target>
        </trans-unit>
        <trans-unit id="b810a5ecd150e1d0012428a848e5d769f60fea9b" translate="yes" xml:space="preserve">
          <source>C RTL</source>
          <target state="translated">C RTL</target>
        </trans-unit>
        <trans-unit id="17a5304c5884fe220f513c1c918ef7adab324995" translate="yes" xml:space="preserve">
          <source>C backtrace</source>
          <target state="translated">C 回溯</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C码</target>
        </trans-unit>
        <trans-unit id="ebcfbca1a38de887c4893368cd463906e0bbe7b3" translate="yes" xml:space="preserve">
          <source>C code to place between the assignment of value (to a temporary) and the return from the function. This allows you to clear up anything in</source>
          <target state="translated">将C代码放置在值的分配(对一个临时的)和函数的返回之间。这允许你在</target>
        </trans-unit>
        <trans-unit id="538185c3d7f303f06af9140ec0da107705c84d52" translate="yes" xml:space="preserve">
          <source>C code to use before the assignment of the value of the constant. This allows you to use temporary variables to extract a value from part of a &lt;code&gt;struct&lt;/code&gt; and return this as</source>
          <target state="translated">分配值之前使用的C代码常量。这允许您使用临时变量从 &lt;code&gt;struct&lt;/code&gt; 一部分中提取值并将其返回为</target>
        </trans-unit>
        <trans-unit id="0d6da997067e1b793fb43677b57abb70e6d14673" translate="yes" xml:space="preserve">
          <source>C doesn't have a concept of local scope, so perl provides one. We've seen that &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; are used as scoping braces; the save stack implements the C equivalent of, for example:</source>
          <target state="translated">C没有局部范围的概念，因此perl提供了一个范围。我们已经看到 &lt;code&gt;ENTER&lt;/code&gt; 和 &lt;code&gt;LEAVE&lt;/code&gt; 用作范围括号；保存堆栈实现了C的等效项，例如：</target>
        </trans-unit>
        <trans-unit id="062ffdd22a0d9502c039f8528f8150dbe0714cfe" translate="yes" xml:space="preserve">
          <source>C function parameters are normally initialized with their values from the argument stack (which in turn contains the parameters that were passed to the XSUB from Perl). The typemaps contain the code segments which are used to translate the Perl values to the C parameters. The programmer, however, is allowed to override the typemaps and supply alternate (or additional) initialization code. Initialization code starts with the first &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; on a line in the INPUT: section. The only exception happens if this &lt;code&gt;;&lt;/code&gt; terminates the line, then this &lt;code&gt;;&lt;/code&gt; is quietly ignored.</source>
          <target state="translated">通常使用参数堆栈中的值初始化C函数参数（参数堆栈又包含从Perl传递到XSUB的参数）。类型映射包含用于将Perl值转换为C参数的代码段。但是，允许程序员重写类型映射并提供备用（或附加）初始化代码。初始化代码开始与第一 &lt;code&gt;=&lt;/code&gt; ， &lt;code&gt;;&lt;/code&gt; 或 &lt;code&gt;+&lt;/code&gt; 在INPUT：部分的一行上。唯一的例外就是这种情况 &lt;code&gt;;&lt;/code&gt; 终止行，然后此 &lt;code&gt;;&lt;/code&gt; 被悄悄地忽略了。</target>
        </trans-unit>
        <trans-unit id="33ca94bf1de4049e4f9bdaa005b019e6d57ed90a" translate="yes" xml:space="preserve">
          <source>C header file. This file contains a series of macros and, if explicitly requested, functions that allow XS modules to be built using older versions of Perl. Currently, Perl versions from 5.003 to 5.20 are supported.</source>
          <target state="translated">C头文件。这个文件包含了一系列的宏和函数,如果明确要求的话,这些函数允许XS模块使用旧版本的Perl来构建。目前,支持5.003到5.20的Perl版本。</target>
        </trans-unit>
        <trans-unit id="a90cbbad6ac1bd0dbc637e8984710d08b0d07f9c" translate="yes" xml:space="preserve">
          <source>C header file.)</source>
          <target state="translated">C头文件)。)</target>
        </trans-unit>
        <trans-unit id="6475b4e6bb646eb3e0b6202577ce4b2fb0cd180d" translate="yes" xml:space="preserve">
          <source>C keyword introducing a structure definition or name.</source>
          <target state="translated">C关键字引入结构定义或名称。</target>
        </trans-unit>
        <trans-unit id="0a4b78bc2d00244d4f2291c70d25ad9ed10ec746" translate="yes" xml:space="preserve">
          <source>C preprocessor directives are allowed within BOOT:, PREINIT: INIT:, CODE:, PPCODE:, POSTCALL:, and CLEANUP: blocks, as well as outside the functions. Comments are allowed anywhere after the MODULE keyword. The compiler will pass the preprocessor directives through untouched and will remove the commented lines. POD documentation is allowed at any point, both in the C and XS language sections. POD must be terminated with a &lt;code&gt;=cut&lt;/code&gt; command; &lt;code&gt;xsubpp&lt;/code&gt; will exit with an error if it does not. It is very unlikely that human generated C code will be mistaken for POD, as most indenting styles result in whitespace in front of any line starting with &lt;code&gt;=&lt;/code&gt; . Machine generated XS files may fall into this trap unless care is taken to ensure that a space breaks the sequence &quot;\n=&quot;.</source>
          <target state="translated">BOOT :、 PREINIT：INIT :、 CODE :、 PPCODE :、 POSTCALL：和CLEANUP：块以及函数外部均允许使用C预处理程序指令。在MODULE关键字之后的任何位置都允许注释。编译器将通过不变的方式传递预处理器指令，并将删除注释行。 C和XS语言部分中的任何地方都允许POD文档。 POD必须使用 &lt;code&gt;=cut&lt;/code&gt; 命令终止；如果没有， &lt;code&gt;xsubpp&lt;/code&gt; 将退出并显示错误。人为生成的C代码不太可能会误认为POD，因为大多数缩进样式会导致以 &lt;code&gt;=&lt;/code&gt; 开头的任何行前都有空格。机器生成的XS文件可能会落入此陷阱，除非注意确保空格中断序列&amp;ldquo; \ n =&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8b72786c4e2763e287b454e5689b07155e0cdb40" translate="yes" xml:space="preserve">
          <source>C&amp;lt;_pc_chown_restricted&amp;gt; symbol (for example, Windows NT) it is assumed that ``chown() giveaway'' is possible and the recursive test is performed.</source>
          <target state="translated">C &amp;lt;_pc_chown_restricted&amp;gt;符号（例如Windows NT）假定``chown（）赠品''是可能的，并执行递归测试。</target>
        </trans-unit>
        <trans-unit id="d682623210c6b24f8d8f68ce43a83783f1b6c8af" translate="yes" xml:space="preserve">
          <source>C-style Logical And</source>
          <target state="translated">C型逻辑和</target>
        </trans-unit>
        <trans-unit id="468d5b286c1316bc4a6baa7daaefae5e90272197" translate="yes" xml:space="preserve">
          <source>C-style Logical Or</source>
          <target state="translated">C型逻辑或</target>
        </trans-unit>
        <trans-unit id="0403ad1f3298e7e9e68a2636bf42146ffa41b4ae" translate="yes" xml:space="preserve">
          <source>C. BUILD</source>
          <target state="translated">C.建设</target>
        </trans-unit>
        <trans-unit id="624f656f2b44769e8027ab2f2c47b638fe6eea88" translate="yes" xml:space="preserve">
          <source>C/C++ Traps</source>
          <target state="translated">C/C++陷阱</target>
        </trans-unit>
        <trans-unit id="633490a93f1c6b59da0e4592f3c36f5d9d5fc276" translate="yes" xml:space="preserve">
          <source>C3 is the name of an algorithm which aims to provide a sane method resolution order under multiple inheritance. It was first introduced in the language Dylan (see links in the &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; section), and then later adopted as the preferred MRO (Method Resolution Order) for the new-style classes in Python 2.3. Most recently it has been adopted as the &quot;canonical&quot; MRO for Perl 6 classes, and the default MRO for Parrot objects as well.</source>
          <target state="translated">C3是旨在在多重继承下提供合理方法解析顺序的算法的名称。它最初是用Dylan语言引入的（请参见&lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt;部分中的链接），然后被采用为Python 2.3中新样式类的首选MRO（方法解析顺序）。最近，它已被用作Perl 6类的&amp;ldquo;规范&amp;rdquo; MRO，以及Parrot对象的默认MRO。</target>
        </trans-unit>
        <trans-unit id="4aa8a8fa5eacc54ba9f8a4e755d8440833ba62a6" translate="yes" xml:space="preserve">
          <source>C3 works by always preserving local precedence ordering. This essentially means that no class will appear before any of its subclasses. Take, for instance, the classic diamond inheritance pattern:</source>
          <target state="translated">C3的工作原理是始终保留局部的优先顺序。这本质上意味着,任何类都不会出现在它的任何子类之前。以经典的钻石继承模式为例。</target>
        </trans-unit>
        <trans-unit id="7a382120912440ea350318c064061d0e6ea8184a" translate="yes" xml:space="preserve">
          <source>C:/emx.add/bin/bash.exe</source>
          <target state="translated">C:/emx.add/bin/bash.exe</target>
        </trans-unit>
        <trans-unit id="519c5bd785564af1dec76cf3a5edc1bf3e894ac6" translate="yes" xml:space="preserve">
          <source>C:/emx/bin/foo.cmd</source>
          <target state="translated">C:/emx/bin/foo.cmd</target>
        </trans-unit>
        <trans-unit id="f6665c2627be2b969dcd410132185e0dd599f37b" translate="yes" xml:space="preserve">
          <source>CALLBACKS</source>
          <target state="translated">CALLBACKS</target>
        </trans-unit>
        <trans-unit id="3991ab584fec70130dcdb49fb4dbe4638d6f1b90" translate="yes" xml:space="preserve">
          <source>CALLING FROM PERL</source>
          <target state="translated">从PERL调用</target>
        </trans-unit>
        <trans-unit id="5f0a327136ac9e42e9905406e9cf6ed2f2b8cdbf" translate="yes" xml:space="preserve">
          <source>CALLING FROM THE COMMAND LINE</source>
          <target state="translated">从命令行调用</target>
        </trans-unit>
        <trans-unit id="aa884ac53759d984488c656f65f21f650359027e" translate="yes" xml:space="preserve">
          <source>CAN</source>
          <target state="translated">CAN</target>
        </trans-unit>
        <trans-unit id="5f05bf320ccd994a5b4376cbf772126d72a752e5" translate="yes" xml:space="preserve">
          <source>CANONICAL REPRESENTATION</source>
          <target state="translated">圣典代表</target>
        </trans-unit>
        <trans-unit id="ed877e5c7f10c31f466df09c23df16788f087cc2" translate="yes" xml:space="preserve">
          <source>CANONICAL_NAME</source>
          <target state="translated">CANONICAL_NAME</target>
        </trans-unit>
        <trans-unit id="e520869852c82bbce05b6c5dc47274d3b3a11987" translate="yes" xml:space="preserve">
          <source>CATEGORIES</source>
          <target state="translated">CATEGORIES</target>
        </trans-unit>
        <trans-unit id="980aeb7f8f581c6b66ed59bbbed49733515b10e6" translate="yes" xml:space="preserve">
          <source>CAVEAT</source>
          <target state="translated">CAVEAT</target>
        </trans-unit>
        <trans-unit id="6567e0b0a7daf3c098913aa924483cfe44852131" translate="yes" xml:space="preserve">
          <source>CAVEAT FOR GREAT CIRCLE FORMULAS</source>
          <target state="translated">大圈公式的退让。</target>
        </trans-unit>
        <trans-unit id="8ae97560e6c967ffcb76f6cd835c75b45c6b2d57" translate="yes" xml:space="preserve">
          <source>CAVEAT ON PRECEDENCE</source>
          <target state="translated">关于先决条件的警告</target>
        </trans-unit>
        <trans-unit id="1c968ba436040f2ef7532a90991da165ff0512dd" translate="yes" xml:space="preserve">
          <source>CAVEAT: The thread signalling capability provided by this module does not actually send signals via the OS. It</source>
          <target state="translated">注意:该模块提供的线程信号能力实际上并不通过操作系统发送信号。它</target>
        </trans-unit>
        <trans-unit id="ce611c3a23df37ff734feee69c06233d5c9abfb4" translate="yes" xml:space="preserve">
          <source>CAVEAT: Though BOM in utf8 (\xEF\xBB\xBF) is valid, it is meaningless and as of this writing Encode suite just leave it as is (\x{FeFF}).</source>
          <target state="translated">CAVEAT:尽管utf8中的BOM(xEF\xBB\xBF)是有效的,但它是没有意义的,在写这篇文章的时候,Encode套件只是让它保持原样(\x{FeFF})。</target>
        </trans-unit>
        <trans-unit id="5ea0a6fefc9f66fb07ad0567375a2c4308c1f112" translate="yes" xml:space="preserve">
          <source>CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.</source>
          <target state="translated">注意:与UTF-(16|32)不同的是,utf8中的BOM不是自动剥离的。</target>
        </trans-unit>
        <trans-unit id="0852d6090cb36f8c92fc678e7c0ed0101951986e" translate="yes" xml:space="preserve">
          <source>CAVEATS</source>
          <target state="translated">CAVEATS</target>
        </trans-unit>
        <trans-unit id="afa50a96d52c4af6173a5b3dcf9e10a0a47c02ab" translate="yes" xml:space="preserve">
          <source>CAVEATS AND LIMITATIONS</source>
          <target state="translated">退让和限制</target>
        </trans-unit>
        <trans-unit id="8db2d4672c0bb6f4ea12967ef5822987358da334" translate="yes" xml:space="preserve">
          <source>CAVEATS and NOTES</source>
          <target state="translated">免责声明和说明</target>
        </trans-unit>
        <trans-unit id="422f720e7d72716b7017e69268406be073cfc7c1" translate="yes" xml:space="preserve">
          <source>CGI</source>
          <target state="translated">CGI</target>
        </trans-unit>
        <trans-unit id="41a4605be9cd5708c0812fcf96a67b02ae213ace" translate="yes" xml:space="preserve">
          <source>CGI.pm</source>
          <target state="translated">CGI.pm</target>
        </trans-unit>
        <trans-unit id="313c83d1d2e8c998d1416c76ceb327085bafcc5a" translate="yes" xml:space="preserve">
          <source>CHANGED IN PERL 5.6</source>
          <target state="translated">PERL 5.6中的变化</target>
        </trans-unit>
        <trans-unit id="15a7fa79c2e880d7c668e6f0bb63190d52852647" translate="yes" xml:space="preserve">
          <source>CHANGED in 3.18</source>
          <target state="translated">在3.18中改变了</target>
        </trans-unit>
        <trans-unit id="a2feb6ed0257c21c6672793ee2f94eaadc10c72c" translate="yes" xml:space="preserve">
          <source>CHANGES</source>
          <target state="translated">CHANGES</target>
        </trans-unit>
        <trans-unit id="77e515bcbeea42a381522b3f02fc083d411a62f5" translate="yes" xml:space="preserve">
          <source>CHARACTER CLASSES</source>
          <target state="translated">角色类别</target>
        </trans-unit>
        <trans-unit id="a375cca9c609e8591d1c22cf8e8a8c4bbd0e6f6f" translate="yes" xml:space="preserve">
          <source>CHARMAP starts the character map section. Each line has a form as follows:</source>
          <target state="translated">CHARMAP开始字符图部分。每一行的形式如下。</target>
        </trans-unit>
        <trans-unit id="1fbd3cbf6697996c51d6a64a08ee8b874fefe67b" translate="yes" xml:space="preserve">
          <source>CHARNAME</source>
          <target state="translated">CHARNAME</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="0a228e95208b8ea7acb00589cdd0f311e92f3483" translate="yes" xml:space="preserve">
          <source>CHECKSUM FUNCTIONS</source>
          <target state="translated">CHECKSUM函数</target>
        </trans-unit>
        <trans-unit id="0d2dc3d6989d0491c087fdf8b26389f6609dba54" translate="yes" xml:space="preserve">
          <source>CLASS METHODS</source>
          <target state="translated">类别方法</target>
        </trans-unit>
        <trans-unit id="3a8f000aa3840296550580880a88660b74717610" translate="yes" xml:space="preserve">
          <source>CLASS-&amp;gt;safe_quote ITEM</source>
          <target state="translated">CLASS-&amp;gt; safe_quote项目</target>
        </trans-unit>
        <trans-unit id="2a5520b8514a16a64037e86c211cbd6b6bfdc1cb" translate="yes" xml:space="preserve">
          <source>CLASSES</source>
          <target state="translated">CLASSES</target>
        </trans-unit>
        <trans-unit id="eb2ed6b6d36f266377a9e30f6e145c7fdae07a3f" translate="yes" xml:space="preserve">
          <source>CLONEf_CLONE_HOST - This is a win32 thing, it is ignored on unix, it tells perls win32host code (which is c++) to clone itself, this is needed on win32 if you want to run two threads at the same time, if you just want to do some stuff in a separate perl interpreter and then throw it away and return to the original one, you don't need to do anything.</source>
          <target state="translated">CLONEf_CLONE_HOST-这是一个win32的东西,在unix上它是被忽略的,它告诉perls win32host代码(就是c++)来克隆自己,如果你想同时运行两个线程,在win32上需要这个,如果你只是想在一个单独的perl解释器中做一些事情,然后扔掉它,回到原来的那个,你不需要做任何事情。</target>
        </trans-unit>
        <trans-unit id="5dd06954f8504852be625e8b13f9f38ba4df5c2d" translate="yes" xml:space="preserve">
          <source>CLONEf_COPY_STACKS - is used to, well, copy the stacks also, without it we only clone the data and zero the stacks, with it we copy the stacks and the new perl interpreter is ready to run at the exact same point as the previous one. The pseudo-fork code uses COPY_STACKS while the threads-&amp;gt;create doesn't.</source>
          <target state="translated">CLONEf_COPY_STACKS-用来复制堆栈，没有它，我们仅克隆数据并将堆栈归零，因此我们复制堆栈，新的perl解释器可以在与上一个完全相同的位置运行。伪叉代码使用COPY_STACKS，而threads-&amp;gt; create则不使用。</target>
        </trans-unit>
        <trans-unit id="496d69294e21b9e9459d9ae5f134da2961a69331" translate="yes" xml:space="preserve">
          <source>CLONEf_KEEP_PTR_TABLE - perl_clone keeps a ptr_table with the pointer of the old variable as a key and the new variable as a value, this allows it to check if something has been cloned and not clone it again but rather just use the value and increase the refcount. If KEEP_PTR_TABLE is not set then perl_clone will kill the ptr_table using the function &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; , reason to keep it around is if you want to dup some of your own variable who are outside the graph perl scans, example of this code is in threads.xs create.</source>
          <target state="translated">CLONEf_KEEP_PTR_TABLE-perl_clone保留一个ptr_table，其中将旧变量的指针作为键，将新变量的值作为值，这使它可以检查是否已克隆某些内容，而不是再次克隆它，而是仅使用该值并增加引用计数。如果未设置KEEP_PTR_TABLE，则perl_clone将使用函数 &lt;code&gt;ptr_table_free(PL_ptr_table); PL_ptr_table = NULL;&lt;/code&gt; 杀死ptr_table；PL_ptr_table = NULL; ，保留它的原因是如果您想复制自己的一些不在图形perl扫描范围内的变量，此代码的示例在thread.xs create中。</target>
        </trans-unit>
        <trans-unit id="439fbcbebff5d3e18e9cd1652b960a8b5958c8fb" translate="yes" xml:space="preserve">
          <source>CMD.EXE</source>
          <target state="translated">CMD.EXE</target>
        </trans-unit>
        <trans-unit id="b7f8b1aaa4e3518d65a63cc4b574d3a502b21354" translate="yes" xml:space="preserve">
          <source>CMD_ERROR</source>
          <target state="translated">CMD_ERROR</target>
        </trans-unit>
        <trans-unit id="b9c1aaaf65573c7e15b93b6d826729e7711cf242" translate="yes" xml:space="preserve">
          <source>CNAME</source>
          <target state="translated">CNAME</target>
        </trans-unit>
        <trans-unit id="8a81c4f5d7ebf0af1540db862699627a91092359" translate="yes" xml:space="preserve">
          <source>CODE EXAMPLES</source>
          <target state="translated">代码示例</target>
        </trans-unit>
        <trans-unit id="e00c531b83778b8e9867578bc4976f46546c5a61" translate="yes" xml:space="preserve">
          <source>CODE REFERENCES</source>
          <target state="translated">参考代码</target>
        </trans-unit>
        <trans-unit id="440677eb0b9f2ced4b57b4cf4a1f2a4041acaf2f" translate="yes" xml:space="preserve">
          <source>CODE reference. The subroutine should return a hash reference. The hash may contain further attributes, e.g. {LIBS =&amp;gt; ...}, that have to be determined by some evaluation method.</source>
          <target state="translated">CODE参考。该子例程应返回一个哈希引用。散列可以包含必须通过某种评估方法确定的其他属性，例如{LIBS =&amp;gt; ...}。</target>
        </trans-unit>
        <trans-unit id="2f975202aa1b4783c29e4937429d2b66fab5169e" translate="yes" xml:space="preserve">
          <source>CODE: directive is used which sets ST(0) explicitly.</source>
          <target state="translated">CODE:使用的是显式设置ST(0)的指令。</target>
        </trans-unit>
        <trans-unit id="3a38ee1d9bd08c8be0112c20a3c4f3c5309ce957" translate="yes" xml:space="preserve">
          <source>COMMAND.COM</source>
          <target state="translated">COMMAND.COM</target>
        </trans-unit>
        <trans-unit id="c13bbfcc6932afed8045a8c6d2be122bbea2f4a3" translate="yes" xml:space="preserve">
          <source>COMMON CHARACTER CODE SETS</source>
          <target state="translated">常用字符代码集</target>
        </trans-unit>
        <trans-unit id="3565dc34b7a16c1ebb52c1be4a3b9554d589b634" translate="yes" xml:space="preserve">
          <source>COMMON MISTAKES</source>
          <target state="translated">常见误区</target>
        </trans-unit>
        <trans-unit id="d3bd9328431af889713253c0fe82cf459fd62fdd" translate="yes" xml:space="preserve">
          <source>COMMON PITFALLS</source>
          <target state="translated">常见弊端</target>
        </trans-unit>
        <trans-unit id="3b75e36fb6f8799ec17d763957648965ceb0bf19" translate="yes" xml:space="preserve">
          <source>COMMON PROBLEMS</source>
          <target state="translated">常见的问题</target>
        </trans-unit>
        <trans-unit id="3631d60b3c3dad75e7023cf75ede2d8db90dced0" translate="yes" xml:space="preserve">
          <source>COMMON QUESTIONS</source>
          <target state="translated">常见问题:</target>
        </trans-unit>
        <trans-unit id="5931c475df95ba4c0e69e8680b4b2746d7dcadbd" translate="yes" xml:space="preserve">
          <source>COMPATIBILITY</source>
          <target state="translated">COMPATIBILITY</target>
        </trans-unit>
        <trans-unit id="1b93c2f6af1a728937d801492e8514e231fe859d" translate="yes" xml:space="preserve">
          <source>COMPILING AND INSTALLING PERL ON PLAN 9</source>
          <target state="translated">在PLAN 9上编译和安装PERL。</target>
        </trans-unit>
        <trans-unit id="a3dbb0f2d743369125c33547e4a98f6e69c718ea" translate="yes" xml:space="preserve">
          <source>COMPRESS/UNCOMPRESS</source>
          <target state="translated">COMPRESS/UNCOMPRESS</target>
        </trans-unit>
        <trans-unit id="dbbd6e677093ab33626116ddbe95a8116b822da0" translate="yes" xml:space="preserve">
          <source>CONCEPTS</source>
          <target state="translated">CONCEPTS</target>
        </trans-unit>
        <trans-unit id="ce2288334f1137f427c025bf4db30086aa2e6ccd" translate="yes" xml:space="preserve">
          <source>CONCLUSION</source>
          <target state="translated">CONCLUSION</target>
        </trans-unit>
        <trans-unit id="54b45ea0b830c111f200238254cbe142d992ceb9" translate="yes" xml:space="preserve">
          <source>CONCURRENT ACCESS TO FILES</source>
          <target state="translated">协同访问文件</target>
        </trans-unit>
        <trans-unit id="b6e52e4d80314fc8a5ba1a7faeb4aa6cd672bec0" translate="yes" xml:space="preserve">
          <source>CONFIGURATION</source>
          <target state="translated">CONFIGURATION</target>
        </trans-unit>
        <trans-unit id="0bcdf5cc47cad9c41938edcc7524d271413daa98" translate="yes" xml:space="preserve">
          <source>CONFIGURE PERL ON CYGWIN</source>
          <target state="translated">在CYGWIN上配置PERL。</target>
        </trans-unit>
        <trans-unit id="86446751ae319594b5e453b782ebdfc8c4bf543b" translate="yes" xml:space="preserve">
          <source>CONFIGURING</source>
          <target state="translated">CONFIGURING</target>
        </trans-unit>
        <trans-unit id="65df4be803801cf76d0b33102b49347c0f49a265" translate="yes" xml:space="preserve">
          <source>CONSTANTS</source>
          <target state="translated">CONSTANTS</target>
        </trans-unit>
        <trans-unit id="9d4cd9e346a27cff016ae855f03e070521487596" translate="yes" xml:space="preserve">
          <source>CONSTRUCT</source>
          <target state="translated">CONSTRUCT</target>
        </trans-unit>
        <trans-unit id="6ed66fd18a1b175704db533d3865fa2679863e6d" translate="yes" xml:space="preserve">
          <source>CONSTRUCTOR</source>
          <target state="translated">CONSTRUCTOR</target>
        </trans-unit>
        <trans-unit id="740fabb870d6ed652cd56a6f6b4cabc2048431f9" translate="yes" xml:space="preserve">
          <source>CONTACT</source>
          <target state="translated">CONTACT</target>
        </trans-unit>
        <trans-unit id="6eb1660530253dbbb9bc0adce6c7c2db98f6c11e" translate="yes" xml:space="preserve">
          <source>CONTRIBUTED MODULES</source>
          <target state="translated">贡献模块</target>
        </trans-unit>
        <trans-unit id="c00c0afca84109e3fb2b98c8209ef559a912b256" translate="yes" xml:space="preserve">
          <source>CONTRIBUTORS</source>
          <target state="translated">CONTRIBUTORS</target>
        </trans-unit>
        <trans-unit id="3c270e7e648d60e989f665180ac5841d2f501b46" translate="yes" xml:space="preserve">
          <source>CONTROLLING LOOKUP FAILURE</source>
          <target state="translated">控制查找失败。</target>
        </trans-unit>
        <trans-unit id="56e1ec5824af8dff3fb44acbb1f5889b6031d924" translate="yes" xml:space="preserve">
          <source>CONVENTIONS</source>
          <target state="translated">CONVENTIONS</target>
        </trans-unit>
        <trans-unit id="bb5de08378fdc79cf1e8f681e4066f1cb85bb028" translate="yes" xml:space="preserve">
          <source>CONVERSIONS</source>
          <target state="translated">CONVERSIONS</target>
        </trans-unit>
        <trans-unit id="e1146aff355e08a86787f760b889571c858e8593" translate="yes" xml:space="preserve">
          <source>COOKBOOK</source>
          <target state="translated">COOKBOOK</target>
        </trans-unit>
        <trans-unit id="9510141c24a403496c1dfba8b0ab986988f95879" translate="yes" xml:space="preserve">
          <source>COORDINATE SYSTEMS</source>
          <target state="translated">协调系统</target>
        </trans-unit>
        <trans-unit id="c51ce576d0d85de4e554620a3b7e0dd309045090" translate="yes" xml:space="preserve">
          <source>COP Hint Hashes</source>
          <target state="translated">COP Hint Hashes</target>
        </trans-unit>
        <trans-unit id="22ad88b10bee537423c13139a4d2b08d579efc3e" translate="yes" xml:space="preserve">
          <source>COP Hint Reading</source>
          <target state="translated">COP提示阅读</target>
        </trans-unit>
        <trans-unit id="e352fc138c5e488dc34254c3ee2e99e3e9aaf288" translate="yes" xml:space="preserve">
          <source>COPYRIGHT</source>
          <target state="translated">COPYRIGHT</target>
        </trans-unit>
        <trans-unit id="9c7e4e94b44caac6a4f40ca3467d6883ed67cf24" translate="yes" xml:space="preserve">
          <source>COPYRIGHT &amp;amp; LICENSE</source>
          <target state="translated">版权和许可</target>
        </trans-unit>
        <trans-unit id="fd93171470739cb1a4e64e6ea953d8c1dd9e7c3a" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMER</source>
          <target state="translated">版权和免责声明</target>
        </trans-unit>
        <trans-unit id="aed47af09308ae3a4fa8a24efc25bc20b8d6091d" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND DISCLAIMERS</source>
          <target state="translated">版权和免责声明</target>
        </trans-unit>
        <trans-unit id="0524ce058903ad04ed18326112dd9695f4ac4f56" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENCE</source>
          <target state="translated">版权和许可</target>
        </trans-unit>
        <trans-unit id="d7f1de266854e2b8d4c927372f1242e7739925ed" translate="yes" xml:space="preserve">
          <source>COPYRIGHT AND LICENSE</source>
          <target state="translated">版权和许可</target>
        </trans-unit>
        <trans-unit id="8c9b991a9d45dee993d0ee634ba8eafd7815c6a3" translate="yes" xml:space="preserve">
          <source>COPYRIGHT and LICENSE</source>
          <target state="translated">版权和许可</target>
        </trans-unit>
        <trans-unit id="6d917c2df32bb3f8fb6b5f8e529bb779c3dca6f7" translate="yes" xml:space="preserve">
          <source>CORE</source>
          <target state="translated">CORE</target>
        </trans-unit>
        <trans-unit id="9f2a7e4446d753ffa86ebd32d2855d851f9cf12a" translate="yes" xml:space="preserve">
          <source>CORE - Namespace for Perl's core routines</source>
          <target state="translated">CORE-Perl核心例程的命名空间。</target>
        </trans-unit>
        <trans-unit id="ea0b6538392d829d8b749d944b7acd94dee0ddb6" translate="yes" xml:space="preserve">
          <source>CPAN</source>
          <target state="translated">CPAN</target>
        </trans-unit>
        <trans-unit id="a6110e98d6d5509cfa9c7e73794ab71e46a695de" translate="yes" xml:space="preserve">
          <source>CPAN - query, download and build perl modules from CPAN sites</source>
          <target state="translated">CPAN-从CPAN站点查询、下载和构建perl模块。</target>
        </trans-unit>
        <trans-unit id="f5cb991183e9576ae99c7af8774c4d59270235f0" translate="yes" xml:space="preserve">
          <source>CPAN TESTERS AND PERL SMOKERS</source>
          <target state="translated">CPAN测试员和PERL吸烟者。</target>
        </trans-unit>
        <trans-unit id="b04380d2ad945f75e3aa967dafb36ed58ba766cd" translate="yes" xml:space="preserve">
          <source>CPAN Testers</source>
          <target state="translated">CPAN测试器</target>
        </trans-unit>
        <trans-unit id="01505e76b90321ebd4493c61034cb8a884911e63" translate="yes" xml:space="preserve">
          <source>CPAN also keeps track of what it has done within the current session and doesn't try to build a package a second time regardless of whether it succeeded or not. It does not repeat a test run if the test has been run successfully before. Same for install runs.</source>
          <target state="translated">CPAN也会跟踪它在当前会话中所做的工作,无论是否成功,它都不会尝试第二次构建一个包。如果测试之前已经成功运行,它不会重复测试运行。安装运行也是如此。</target>
        </trans-unit>
        <trans-unit id="d978419581e9be6ec9c55f53ba43e4e7f68766bd" translate="yes" xml:space="preserve">
          <source>CPAN can now help you select a &quot;good&quot; mirror, based on which ones have the lowest 'ping' round-trip times. From the shell, use the command 'o conf init urllist' and allow CPAN to automatically select mirrors for you.</source>
          <target state="translated">CPAN 现在可以帮助您选择一个 &quot;好 &quot;的镜像,基于哪些镜像的 &quot;ping &quot;往返时间最低。在shell中,使用 &quot;o conf init urllist &quot;命令,让CPAN为您自动选择镜像。</target>
        </trans-unit>
        <trans-unit id="9f419c26e2ea47eba870171b0304a0f12d770bcb" translate="yes" xml:space="preserve">
          <source>CPAN can provide the best examples. &lt;a href=&quot;simple&quot;&gt;Test::Simple&lt;/a&gt;, &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test::Exception&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test::Differences&lt;/a&gt; all use Test::Builder.</source>
          <target state="translated">CPAN可以提供最好的例子。&lt;a href=&quot;simple&quot;&gt;Test :: Simple&lt;/a&gt;，&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;，&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Exception&quot;&gt;Test :: Exception&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Differences&quot;&gt;Test :: Differences&lt;/a&gt;都使用Test :: Builder。</target>
        </trans-unit>
        <trans-unit id="9b25cd0f5375c5eab72f3ffe3e62897e52e03cea" translate="yes" xml:space="preserve">
          <source>CPAN checks whether an install is needed and prints</source>
          <target state="translated">CPAN检查是否需要安装,并打印出</target>
        </trans-unit>
        <trans-unit id="d5ac7dd05001d7d37e2f43d1797c997c4df20e68" translate="yes" xml:space="preserve">
          <source>CPAN has several JAPH programs at &lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh&lt;/a&gt;.</source>
          <target state="translated">CPAN在&lt;a href=&quot;http://www.cpan.org/misc/japh&quot;&gt;http://www.cpan.org/misc/japh上&lt;/a&gt;有几个JAPH程序。</target>
        </trans-unit>
        <trans-unit id="73829bcf0ad0c4b896f34810c840c5f0243a137e" translate="yes" xml:space="preserve">
          <source>CPAN module &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">CPAN模块 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Regex::Set&quot;&gt;Unicode::Regex::Set&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec0e8e76dd47186c4a257a69793cc4b0fbd9812e" translate="yes" xml:space="preserve">
          <source>CPAN packages can be digitally signed by authors and thus verified with the security provided by strong cryptography. The exact mechanism is defined in the Module::Signature module. While this is generally considered a good thing, it is not always convenient to the end user to install modules that are signed incorrectly or where the key of the author is not available or where some prerequisite for Module::Signature has a bug and so on.</source>
          <target state="translated">CPAN包可以由作者进行数字签名,从而用强密码学提供的安全性进行验证。具体机制在Module::Signature模块中定义。虽然一般认为这是一件好事,但对于最终用户来说,如果安装的模块签名不正确,或者是作者的密钥不可用,或者是Module::Signature的某些前提条件存在bug等等,就不一定方便了。</target>
        </trans-unit>
        <trans-unit id="b51337fb370844b9eff5cf2f0d2334791161629e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network, a multi-gigabyte archive replicated on hundreds of machines all over the world. CPAN contains tens of thousands of modules and extensions, source code and documentation, designed for</source>
          <target state="translated">CPAN是Comprehensive Perl Archive Network的缩写,是一个在全世界数百台机器上复制的多GB档案。CPAN包含了数以万计的模块和扩展、源代码和文档,这些模块和扩展的设计是为</target>
        </trans-unit>
        <trans-unit id="4a083d1c70360c499c212a22f42c02ebc10a2b7e" translate="yes" xml:space="preserve">
          <source>CPAN stands for Comprehensive Perl Archive Network; it's a globally replicated trove of Perl materials, including documentation, style guides, tricks and traps, alternate ports to non-Unix systems and occasional binary distributions for these. Search engines for CPAN can be found at &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;</source>
          <target state="translated">CPAN代表综合Perl存档网络；它是Perl材料的全球复制品，包括文档，样式指南，技巧和陷阱，非Unix系统的备用端口以及偶尔的二进制发行版。可以在&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;上找到CPAN的搜索引擎。</target>
        </trans-unit>
        <trans-unit id="11b7513cf5ed0783e222931555703c39249404ca" translate="yes" xml:space="preserve">
          <source>CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be asked any questions at all (assuming the modules you are installing are nice about obeying that variable as well):</source>
          <target state="translated">CPAN使用ExtUtils::MakeMaker的prompt()函数来询问它的问题,所以如果你设置了PERL_MM_USE_DEFAULT环境变量,你应该不会被问到任何问题(假设你正在安装的模块也很好地服从了这个变量)。</target>
        </trans-unit>
        <trans-unit id="763ab2cd14f13622b64f1d364ae89ff5e930c5e0" translate="yes" xml:space="preserve">
          <source>CPAN version is currently maintained by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;.</source>
          <target state="translated">CPAN版本当前由S&amp;eacute;bastienAperghis-Tramoni &amp;lt;sebastien@aperghis.net&amp;gt;维护。</target>
        </trans-unit>
        <trans-unit id="d022fca84f913595d0e465957aa3ec07aa26e29a" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden制作的CPAN版本&amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="df1b7ad617e594d1fcea7ef95394577f7d4285ee" translate="yes" xml:space="preserve">
          <source>CPAN version produced by Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;.</source>
          <target state="translated">由Jerry D. Hedden &amp;lt;jdhedden AT cpan DOT org&amp;gt;生产的CPAN版本。</target>
        </trans-unit>
        <trans-unit id="a3c7ec93761c4b99669cfe3abe56f987f4d86e7b" translate="yes" xml:space="preserve">
          <source>CPAN, or the Comprehensive Perl Archive Network &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, is a replicated, worldwide repository of Perl software. See &lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;What is CPAN?&lt;/a&gt;.</source>
          <target state="translated">CPAN或综合Perl存档网络&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;是Perl软件的全球复制源。请参阅&lt;a href=&quot;#What-modules-and-extensions-are-available-for-Perl%3f-What-is-CPAN%3f&quot;&gt;什么是CPAN？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d24df83c42548921d5e891bad0ec265b58c5632b" translate="yes" xml:space="preserve">
          <source>CPAN.pm</source>
          <target state="translated">CPAN.pm</target>
        </trans-unit>
        <trans-unit id="df07d81df98f66bb5cc686dd3a7b7369a164da96" translate="yes" xml:space="preserve">
          <source>CPAN.pm can introduce some randomness when using hosts for download that are configured in the urllist parameter. Enter a numeric value between 0 and 1 to indicate how often you want to let CPAN.pm try a random host from the urllist. A value of one specifies to always use a random host as the first try. A value of zero means no randomness at all. Anything in between specifies how often, on average, a random host should be tried first.</source>
          <target state="translated">当使用 urllist 参数中配置的主机进行下载时,CPAN.pm 会引入一些随机性。输入一个介于 0 和 1 之间的数值来表示你想让 CPAN.pm 多久尝试一次 urllist 中的随机主机。值为 1 表示总是使用随机主机作为第一次尝试。值为 0 表示完全没有随机性。任何介于两者之间的值都表示平均每隔多长时间应该先尝试一次随机主机。</target>
        </trans-unit>
        <trans-unit id="8be548e1857808a4c33f06e8483679790bde10ef" translate="yes" xml:space="preserve">
          <source>CPAN.pm can limit the size of the disk area for keeping the build directories with all the intermediate files.</source>
          <target state="translated">CPAN.pm可以限制磁盘区域的大小,以便保留包含所有中间文件的构建目录。</target>
        </trans-unit>
        <trans-unit id="f21743f9fae507577e1ebe77ee42077c588936ab" translate="yes" xml:space="preserve">
          <source>CPAN.pm can store customized build environments based on regular expressions for distribution names. These are YAML files where the default options for CPAN.pm and the environment can be overridden and dialog sequences can be stored that can later be executed by an Expect.pm object. The CPAN.pm distribution comes with some prefab YAML files that cover sample distributions that can be used as blueprints to store your own prefs. Please check out the distroprefs/ directory of the CPAN.pm distribution to get a quick start into the prefs system.</source>
          <target state="translated">CPAN.pm可以基于分发名称的正则表达式来存储自定义的构建环境,这些都是YAML文件,CPAN.pm和环境的默认选项可以被覆盖,对话序列可以存储在以后由Expect.pm对象执行。这些都是YAML文件,在这些文件中,CPAN.pm和环境的默认选项可以被重写,并且可以存储对话序列,这些对话序列可以在以后被Expect.pm对象执行。CPAN.pm发行版附带了一些预制的YAML文件,这些文件涵盖了样本发行版,可以作为蓝本来存储你自己的prefs。请查看CPAN.pm发行版的distroprefs/目录,以快速进入prefs系统。</target>
        </trans-unit>
        <trans-unit id="fe8999832e8cb3e24c5ee5786438c2eb7045f528" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. By default it uses Cwd::cwd, but if for some reason this doesn't work on your system, configure alternatives according to the following table:</source>
          <target state="translated">CPAN.pm经常改变当前的工作目录,需要确定自己的当前工作目录。默认情况下,它使用Cwd::cwd,但如果由于某些原因,这在你的系统中不起作用,请根据下表配置替代方案。</target>
        </trans-unit>
        <trans-unit id="110953d17daedc5ab884b800e79aa6017f230c3c" translate="yes" xml:space="preserve">
          <source>CPAN.pm changes the current working directory often and needs to determine its own current working directory. Per default it uses Cwd::cwd but if this doesn't work on your system for some reason, alternatives can be configured according to the following table:</source>
          <target state="translated">CPAN.pm经常改变当前工作目录,因此需要确定自己的当前工作目录。默认情况下,它使用Cwd::cwd,但如果由于某些原因,这在你的系统中不起作用,可以根据下表配置替代方案。</target>
        </trans-unit>
        <trans-unit id="316ae9b3e749a01c06c792f2cfcc80c4846f19f6" translate="yes" xml:space="preserve">
          <source>CPAN.pm ignores SIGPIPE. If the user sets &lt;code&gt;inactivity_timeout&lt;/code&gt; , a SIGALRM is used during the run of the &lt;code&gt;perl Makefile.PL&lt;/code&gt; or &lt;code&gt;perl
Build.PL&lt;/code&gt; subprocess. A SIGALRM is also used during module version parsing, and is controlled by &lt;code&gt;version_timeout&lt;/code&gt; .</source>
          <target state="translated">CPAN.pm忽略SIGPIPE。如果用户设置 &lt;code&gt;inactivity_timeout&lt;/code&gt; ，则在运行 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 或 &lt;code&gt;perl Build.PL&lt;/code&gt; 子进程期间将使用SIGALRM 。在模块版本解析期间还使用了SIGALRM，并由 &lt;code&gt;version_timeout&lt;/code&gt; 控制。</target>
        </trans-unit>
        <trans-unit id="190c010b5387bba4ea2b42cb563bd4dbf19face7" translate="yes" xml:space="preserve">
          <source>CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are in the cpan-shell, it is intended that you can press &lt;code&gt;^C&lt;/code&gt; anytime and return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell to clean up and leave the shell loop. You can emulate the effect of a SIGTERM by sending two consecutive SIGINTs, which usually means by pressing &lt;code&gt;^C&lt;/code&gt; twice.</source>
          <target state="translated">CPAN.pm为SIGINT和SIGTERM安装信号处理程序。当您在cpan-shell中时，可以随时按 &lt;code&gt;^C&lt;/code&gt; 并返回到cpan-shell提示符。 SIGTERM将导致cpan-shell清理并离开shell循环。您可以通过发送两个连续的SIGINT来模拟SIGTERM的效果，这通常意味着两次按 &lt;code&gt;^C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74c9de97c18d0f26d42b5dbeeae85623299ae97e" translate="yes" xml:space="preserve">
          <source>CPAN.pm is regularly tested to run under 5.005 and assorted newer versions. It is getting more and more difficult to get the minimal prerequisites working on older perls. It is close to impossible to get the whole Bundle::CPAN working there. If you're in the position to have only these old versions, be advised that CPAN is designed to work fine without the Bundle::CPAN installed.</source>
          <target state="translated">CPAN.pm定期测试在5.005和各种新版本下运行。要让最小的先决条件在老版本的 perls 上运行越来越难了。要让整个 Bundle::CPAN 在那里工作几乎是不可能的。如果您只有这些旧版本,请注意,CPAN 的设计是为了在没有安装 Bundle::CPAN 的情况下也能正常工作。</target>
        </trans-unit>
        <trans-unit id="9dede3b8abe89d4a573f74c512265cae8a956106" translate="yes" xml:space="preserve">
          <source>CPAN.pm will then fetch the index files from one of the CPAN sites that come at the beginning of urllist. It will later check for each module to see whether there is a local copy of the most recent version.</source>
          <target state="translated">CPAN.pm 会从 urllist 开头的 CPAN 站点中获取索引文件。稍后它将检查每个模块是否有最新版本的本地副本。</target>
        </trans-unit>
        <trans-unit id="2867ea997c1ecbeaa882b9d340cc76b94bdae145" translate="yes" xml:space="preserve">
          <source>CPAN.pm works nicely without network access, too. If you maintain machines that are not networked at all, you should consider working with &lt;code&gt;file:&lt;/code&gt; URLs. You'll have to collect your modules somewhere first. So you might use CPAN.pm to put together all you need on a networked machine. Then copy the $CPAN::Config-&amp;gt;{keep_source_where} (but not $CPAN::Config-&amp;gt;{build_dir}) directory on a floppy. This floppy is kind of a personal CPAN. CPAN.pm on the non-networked machines works nicely with this floppy. See also below the paragraph about CD-ROM support.</source>
          <target state="translated">CPAN.pm在没有网络访问的情况下也能很好地工作。如果维护的机器根本没有联网，则应考虑使用 &lt;code&gt;file:&lt;/code&gt; URL。您必须首先在某个地方收集模块。因此，您可以使用CPAN.pm将所有需要的内容汇总到网络计算机上。然后将$ CPAN :: Config-&amp;gt; {keep_source_where}（而不是$ CPAN :: Config-&amp;gt; {build_dir}）目录复制到软盘上。该软盘有点像个人CPAN。未联网的计算机上的CPAN.pm可以很好地与此软盘配合使用。另请参见以下有关CD-ROM支持的段落。</target>
        </trans-unit>
        <trans-unit id="64b36001560d3fac13b876398b3f1a59def99f26" translate="yes" xml:space="preserve">
          <source>CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution inherit this method. It prints the data structure associated with an object. Useful for debugging. Note: the data structure is considered internal and thus subject to change without notice.</source>
          <target state="translated">CPAN::Author、CPAN::Bundle、CPAN::Module 和 CPAN::Distribution 继承了这个方法。它打印与对象相关联的数据结构。对调试很有用。注意:数据结构被认为是内部结构,因此可能会在不通知的情况下发生变化。</target>
        </trans-unit>
        <trans-unit id="2446a32cd0ff78f16b4c1f3133beeac56c5f5898" translate="yes" xml:space="preserve">
          <source>CPAN::Debug</source>
          <target state="translated">CPAN::Debug</target>
        </trans-unit>
        <trans-unit id="3cc1933835ca0280363968e304f73c0a15112e4c" translate="yes" xml:space="preserve">
          <source>CPAN::Debug - internal debugging for CPAN.pm</source>
          <target state="translated">CPAN::Debug-CPAN.pm的内部调试。</target>
        </trans-unit>
        <trans-unit id="8d7cc75d89d8c3bb9bd4511533d5eed2ec9484af" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs</source>
          <target state="translated">CPAN::Distroprefs</target>
        </trans-unit>
        <trans-unit id="80ea37d944a5515b88dd77f972d31b6df3134129" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs -- read and match distroprefs</source>
          <target state="translated">CPAN::Distroprefs --读取和匹配distroprefs。</target>
        </trans-unit>
        <trans-unit id="5bcd04a88f701c432b5a1ff104f6c8a0d02960ee" translate="yes" xml:space="preserve">
          <source>CPAN::Distroprefs::Pref objects represent individual distroprefs documents. They are constructed automatically as part of &lt;code&gt;success&lt;/code&gt; results from &lt;code&gt;find()&lt;/code&gt; .</source>
          <target state="translated">CPAN :: Distroprefs :: Pref对象代表各个Distroprefs文档。它们是 &lt;code&gt;find()&lt;/code&gt; &lt;code&gt;success&lt;/code&gt; 结果的一部分而自动构建。</target>
        </trans-unit>
        <trans-unit id="a2f3edd9da9fa97ece6eafd83608b4b243b452a0" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime</source>
          <target state="translated">CPAN::FirstTime</target>
        </trans-unit>
        <trans-unit id="78dc35292a9ffa84e8778b2bc228974b2a98a06d" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime - Utility for CPAN::Config file Initialization</source>
          <target state="translated">CPAN::FirstTime-用于CPAN::Config文件初始化的实用工具。</target>
        </trans-unit>
        <trans-unit id="e737cd6e08d40b3a667635e5cb83727e8679bd6f" translate="yes" xml:space="preserve">
          <source>CPAN::FirstTime::init()</source>
          <target state="translated">CPAN::FirstTime::init()</target>
        </trans-unit>
        <trans-unit id="85ea935cb2e14666fd64cb017917705b1d6fede5" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig</source>
          <target state="translated">CPAN::HandleConfig</target>
        </trans-unit>
        <trans-unit id="24310cde90de0fb64790326e96a727677d4e7601" translate="yes" xml:space="preserve">
          <source>CPAN::HandleConfig - internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN::HandleConfig-CPAN.pm的内部配置处理。</target>
        </trans-unit>
        <trans-unit id="64057ceb28c792089f8152cbd3da3bcade5223e9" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify</source>
          <target state="translated">CPAN::Kwalify</target>
        </trans-unit>
        <trans-unit id="a2e5f91adff087cfa00a37e97d84ee7727243629" translate="yes" xml:space="preserve">
          <source>CPAN::Kwalify - Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN::Kwalify-CPAN.pm和Kwalify.pm之间的接口。</target>
        </trans-unit>
        <trans-unit id="8dcc2e6edc3eadab9e78355482bf7252fe18e3ff" translate="yes" xml:space="preserve">
          <source>CPAN::Nox</source>
          <target state="translated">CPAN::Nox</target>
        </trans-unit>
        <trans-unit id="0b944fc036709f45e2abf674dd21a2de916a71a8" translate="yes" xml:space="preserve">
          <source>CPAN::Nox - Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">CPAN::Nox-围绕CPAN.pm的封装器,无需使用任何XS模块。</target>
        </trans-unit>
        <trans-unit id="cff38ba28ab3cfea4d0464d49309db8969faf6ef" translate="yes" xml:space="preserve">
          <source>CPAN::Queue</source>
          <target state="translated">CPAN::Queue</target>
        </trans-unit>
        <trans-unit id="e3a09726a6ba57409ab3f10ea87af46541484c9f" translate="yes" xml:space="preserve">
          <source>CPAN::Queue - internal queue support for CPAN.pm</source>
          <target state="translated">CPAN::Queue-对CPAN.pm的内部队列支持</target>
        </trans-unit>
        <trans-unit id="349e923ec9cc993c3c5c400728886a4cd805bc87" translate="yes" xml:space="preserve">
          <source>CPAN::SQLite is a layer between the index files that are downloaded from the CPAN and CPAN.pm that speeds up metadata queries and reduces memory consumption of CPAN.pm considerably.</source>
          <target state="translated">CPAN::SQLite是介于从CPAN下载的索引文件和CPAN.pm之间的一层,它可以加快元数据查询的速度,并大大降低CPAN.pm的内存消耗。</target>
        </trans-unit>
        <trans-unit id="b47dcd8919f1f65cec06b9c2d7f965e75c2b1219" translate="yes" xml:space="preserve">
          <source>CPAN::Shell</source>
          <target state="translated">CPAN::Shell</target>
        </trans-unit>
        <trans-unit id="23798a7b15a5d75dd8c6bdfc98d7078c277c16e8" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip</source>
          <target state="translated">CPAN::Tarzip</target>
        </trans-unit>
        <trans-unit id="814fdd5396978409421856089181c07c58c4c4cf" translate="yes" xml:space="preserve">
          <source>CPAN::Tarzip - internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN::Tarzip-内部处理CPAN.pm的tar压缩文件。</target>
        </trans-unit>
        <trans-unit id="4901e7156541948e262f8f5d98071d2c7b3b87e3" translate="yes" xml:space="preserve">
          <source>CPAN::Version</source>
          <target state="translated">CPAN::Version</target>
        </trans-unit>
        <trans-unit id="30cd4b0821f4765c0d8295e7726cfae9b7fab40e" translate="yes" xml:space="preserve">
          <source>CPAN::Version - utility functions to compare CPAN versions</source>
          <target state="translated">CPAN::Version-用于比较CPAN版本的实用功能。</target>
        </trans-unit>
        <trans-unit id="ec4a1634792e6ece098aa09e476bc1d9ef4268d0" translate="yes" xml:space="preserve">
          <source>CPAN::anycwd($path): Note on config variable getcwd</source>
          <target state="translated">CPAN::anycwd($path)。关于配置变量getcwd的说明</target>
        </trans-unit>
        <trans-unit id="6bf4457df819c8d2b082c5c17c609ae27bb6a63b" translate="yes" xml:space="preserve">
          <source>CPAN::shell([$prompt, $command]) Starting Interactive Mode</source>
          <target state="translated">CPAN::shell([$prompt,$command])启动交互模式</target>
        </trans-unit>
        <trans-unit id="4ffdbed7690fc2f38db76dd54cf504d79c06ee88" translate="yes" xml:space="preserve">
          <source>CPANMINUS</source>
          <target state="translated">CPANMINUS</target>
        </trans-unit>
        <trans-unit id="0300a08f28f15d52b8c0f31d868e80fadb408109" translate="yes" xml:space="preserve">
          <source>CPANPLUS</source>
          <target state="translated">CPANPLUS</target>
        </trans-unit>
        <trans-unit id="4a2648ee2c7cdfe4f04963290c94c0f73b1a0296" translate="yes" xml:space="preserve">
          <source>CPU seconds is, in UNIX terms, the user time plus the system time of the process itself, as opposed to the real (wallclock) time and the time spent by the child processes. Less than 0.1 seconds is not accepted (-0.01 as the count, for example, will cause a fatal runtime exception).</source>
          <target state="translated">CPU秒,用UNIX术语来说,就是用户时间加上进程本身的系统时间,与实际(挂钟)时间和子进程花费的时间不同。小于0.1秒是不被接受的(例如,-0.01作为计数,将导致致命的运行时异常)。</target>
        </trans-unit>
        <trans-unit id="8eabeaf9c51703b78032cab60996509e2a9fbc29" translate="yes" xml:space="preserve">
          <source>CPU time</source>
          <target state="translated">CPU时间</target>
        </trans-unit>
        <trans-unit id="ceae75038d81d55818f9c7099cc499bef29e500c" translate="yes" xml:space="preserve">
          <source>CREATING A SOURCE FILTER AS A SEPARATE EXECUTABLE</source>
          <target state="translated">创建一个源过滤器作为一个独立的可执行文件。</target>
        </trans-unit>
        <trans-unit id="8f5fc61f95a802dc2f2c87590b81afa3dc2d9f36" translate="yes" xml:space="preserve">
          <source>CREATION</source>
          <target state="translated">CREATION</target>
        </trans-unit>
        <trans-unit id="338f52baadf832c435e6693a6b1e770c010b5681" translate="yes" xml:space="preserve">
          <source>CREDITS</source>
          <target state="translated">CREDITS</target>
        </trans-unit>
        <trans-unit id="4b79357f1f7c4a8b8c01c419e8cd32de82816fa7" translate="yes" xml:space="preserve">
          <source>CROSS-COMPILATION</source>
          <target state="translated">CROSS-COMPILATION</target>
        </trans-unit>
        <trans-unit id="5ff3994b10db2ad29d009f4ea60878f1dbf5c21e" translate="yes" xml:space="preserve">
          <source>CURRENT BUILD INSTRUCTIONS</source>
          <target state="translated">目前的建设说明</target>
        </trans-unit>
        <trans-unit id="f132b454c07ac52e508f217f0add8bd7ce5fa710" translate="yes" xml:space="preserve">
          <source>CUSTOM ALIASES</source>
          <target state="translated">自定义字母缩写(Custom ALIASES)</target>
        </trans-unit>
        <trans-unit id="566216bf858af2148e9f96bcf3257d2d54bc9983" translate="yes" xml:space="preserve">
          <source>CUSTOM TRANSLATORS</source>
          <target state="translated">定制翻译</target>
        </trans-unit>
        <trans-unit id="095d16308375c60700e556f5b8f5796ca1925951" translate="yes" xml:space="preserve">
          <source>CV Manipulation Functions</source>
          <target state="translated">CV操作功能</target>
        </trans-unit>
        <trans-unit id="2b943e6acf60a6fb581a6a5d00e315120f0f582e" translate="yes" xml:space="preserve">
          <source>CV reference counts and CvOUTSIDE</source>
          <target state="translated">CV参考数和CvOUTSIDE数。</target>
        </trans-unit>
        <trans-unit id="0c42c13d714fd16e36f14c85f7c7898781594d12" translate="yes" xml:space="preserve">
          <source>CV's can have CvPADLIST(cv) set to point to a PADLIST. This is the CV's scratchpad, which stores lexical variables and opcode temporary and per-thread values.</source>
          <target state="translated">CV的可以将CvPADLIST(cv)设置为指向一个PADLIST。这是CV的scratchpad,它存储词汇变量和操作码临时值和每线程值。</target>
        </trans-unit>
        <trans-unit id="ddb00c36c6d4c35daa72fdd0b44d9c728b39bcfa" translate="yes" xml:space="preserve">
          <source>C_FILE</source>
          <target state="translated">C_FILE</target>
        </trans-unit>
        <trans-unit id="575569dbcc2f1973e29e715e813fbf5f343f083a" translate="yes" xml:space="preserve">
          <source>C_SUBNAME</source>
          <target state="translated">C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="49dd0ee71a9f8c8e59007d14c22f8f02a232442a" translate="yes" xml:space="preserve">
          <source>Cache Manager</source>
          <target state="translated">缓存管理器</target>
        </trans-unit>
        <trans-unit id="a9fca3e43fd40d529fa1de2b124c4181a70bcb17" translate="yes" xml:space="preserve">
          <source>Cache metadata (yes/no)?</source>
          <target state="translated">缓存元数据(是/否)?</target>
        </trans-unit>
        <trans-unit id="36e2cd82188ed6fa0e4b613f6e68c50033b4f7eb" translate="yes" xml:space="preserve">
          <source>Cache size for build directory (in MB)?</source>
          <target state="translated">构建目录的缓存大小(MB)?</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="4216adaca29295eaea61f0fa24c35227b02c6845" translate="yes" xml:space="preserve">
          <source>Caching and deferred writing are inappropriate if you want the same file to be accessed simultaneously from more than one process. Other optimizations performed internally by this module are also incompatible with concurrent access. A future version of this module will support a &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; option that enables safe concurrent access.</source>
          <target state="translated">如果希望从多个进程中同时访问同一文件，则缓存和延迟写入是不合适的。此模块在内部执行的其他优化也与并发访问不兼容。该模块的未来版本将支持 &lt;code&gt;concurrent =&amp;gt; 1&lt;/code&gt; 选项，该选项可实现安全的并发访问。</target>
        </trans-unit>
        <trans-unit id="66d425679370669a060d7b12eda4e17f2fb01bea" translate="yes" xml:space="preserve">
          <source>Caching is off by default, as it can (usually slightly) decrease accuracy and does not usually noticeably affect runtimes.</source>
          <target state="translated">缓存在默认情况下是关闭的,因为它可以(通常会稍微)降低精度,而且通常不会明显影响运行时间。</target>
        </trans-unit>
        <trans-unit id="81c8c72b5e27066945946d422a802165663f5930" translate="yes" xml:space="preserve">
          <source>Caesarean ciphers</source>
          <target state="translated">剖腹产密码器</target>
        </trans-unit>
        <trans-unit id="f76942716d4c2528f7cd94b85c359f606e3e15f5" translate="yes" xml:space="preserve">
          <source>Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to &quot;even&quot;.</source>
          <target state="translated">计算PI到N位数(包括点前的3)。结果根据当前的四舍五入模式进行四舍五入,默认为 &quot;偶数&quot;。</target>
        </trans-unit>
        <trans-unit id="ba16d2dfddf095e54ae25bc218255c71ce5afa48" translate="yes" xml:space="preserve">
          <source>Calculate digests of files</source>
          <target state="translated">计算文件的摘要</target>
        </trans-unit>
        <trans-unit id="6edac12b6f864eee888f0c08f462e84fff153f20" translate="yes" xml:space="preserve">
          <source>Calculate the N'th root of $x.</source>
          <target state="translated">计算$x的N'th根。</target>
        </trans-unit>
        <trans-unit id="f7dc98fbb7b43c855859dedd630f45c56ad2bc12" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of $x, modifying $x in place.</source>
          <target state="translated">计算$x的弧切线,原地修改$x。</target>
        </trans-unit>
        <trans-unit id="49fd3457ed632359ca2520e72d6632cb278658b7" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tangens of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place.</source>
          <target state="translated">计算 &lt;code&gt;$y&lt;/code&gt; 的反正切值除以 &lt;code&gt;$x&lt;/code&gt; ，就地修改$ y。</target>
        </trans-unit>
        <trans-unit id="4f94eb38f838a42af1307713af2f7a6e7542c447" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of $x, modifying $x in place. See also &lt;a href=&quot;#batan2()&quot;&gt;batan2()&lt;/a&gt;.</source>
          <target state="translated">计算$ x的反正切值，修改$ x。另请参见&lt;a href=&quot;#batan2()&quot;&gt;batan2（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="982777a50f0c3516dc7b84208808f54a3e72dbea" translate="yes" xml:space="preserve">
          <source>Calculate the arcus tanges of &lt;code&gt;$y&lt;/code&gt; divided by &lt;code&gt;$x&lt;/code&gt; , modifying $y in place. See also &lt;a href=&quot;#batan()&quot;&gt;batan()&lt;/a&gt;.</source>
          <target state="translated">计算 &lt;code&gt;$y&lt;/code&gt; 反正切值除以 &lt;code&gt;$x&lt;/code&gt; ，就地修改$ y。另请参见&lt;a href=&quot;#batan()&quot;&gt;batan（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8312c24fc6c367f7ba0626e0df9859355b1ba267" translate="yes" xml:space="preserve">
          <source>Calculate the cosinus of $x, modifying $x in place.</source>
          <target state="translated">计算$x的余弦,原地修改$x。</target>
        </trans-unit>
        <trans-unit id="01c8c185c9d12673e45f702a2f9d36653ab1f38e" translate="yes" xml:space="preserve">
          <source>Calculate the sinus of $x, modifying $x in place.</source>
          <target state="translated">计算$x的正弦,将$x修改到位。</target>
        </trans-unit>
        <trans-unit id="049cf6157b6ee1c242c2800800be8ef0165625bc" translate="yes" xml:space="preserve">
          <source>Calculate the square root of $x.</source>
          <target state="translated">计算$x的平方根。</target>
        </trans-unit>
        <trans-unit id="d5c08bd3d571674414934d46e315d05c1e757d23" translate="yes" xml:space="preserve">
          <source>Calculates the N'th root of &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">计算 &lt;code&gt;$x&lt;/code&gt; 第N个根。</target>
        </trans-unit>
        <trans-unit id="2470f12a5e304e7422bd1a2f8c0e1abfd2982a1d" translate="yes" xml:space="preserve">
          <source>Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:</source>
          <target state="translated">计算k上的二项式系数n,也叫 &quot;选择 &quot;函数。其结果相当于:</target>
        </trans-unit>
        <trans-unit id="34e97fbd408b8eed5635c834b2854c0be8cb6dbf" translate="yes" xml:space="preserve">
          <source>Calculates the expression &lt;code&gt;e ** $x&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">计算表达式 &lt;code&gt;e ** $x&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是欧拉数。</target>
        </trans-unit>
        <trans-unit id="416b7a310945db184afb57b971e8e098dac1fa18" translate="yes" xml:space="preserve">
          <source>Calculates the factorial of $x. For instance:</source>
          <target state="translated">计算$x的阶乘。例如:</target>
        </trans-unit>
        <trans-unit id="62fb105cdba4cb5918fb1ee8f5656956e6874fed" translate="yes" xml:space="preserve">
          <source>Calculates the maximum command size the OS can exec. Effectively, this is the max size of a shell command line.</source>
          <target state="translated">计算操作系统可以执行的最大命令大小。实际上,这就是shell命令行的最大大小。</target>
        </trans-unit>
        <trans-unit id="fd42bdc4343d55afb259e24e240b92c18465e03e" translate="yes" xml:space="preserve">
          <source>Calculates two integers A and B so that A/B is equal to &lt;code&gt;e ** $x&lt;/code&gt; , where &lt;code&gt;e&lt;/code&gt; is Euler's number.</source>
          <target state="translated">计算两个整数A和B，以使A / B等于 &lt;code&gt;e ** $x&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是欧拉数。</target>
        </trans-unit>
        <trans-unit id="0037c314d771bc8eaa4953dbcb986cc7bf547ac0" translate="yes" xml:space="preserve">
          <source>Calendar of Perl Events</source>
          <target state="translated">Perl活动日历</target>
        </trans-unit>
        <trans-unit id="afd632ce2019ef9ec38232fb5195ec297239dcfa" translate="yes" xml:space="preserve">
          <source>Calendar time for December 12, 1995, at 10:30 am.</source>
          <target state="translated">日历时间为1995年12月12日上午10:30。</target>
        </trans-unit>
        <trans-unit id="a7a5d5cba867fa341140666997ab9bfd6cadc129" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; and return a list of two sockets created, or an empty list on failure.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;../functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; 并返回创建的两个套接字的列表，或者返回失败的空列表。</target>
        </trans-unit>
        <trans-unit id="6b6b5d06a5f85554364bcd897b8c29e92093294d" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;start&lt;/code&gt; immediately before adding any results to the aggregator. Among other times it records the start time for the test run.</source>
          <target state="translated">在将任何结果添加到聚合器之前，立即调用 &lt;code&gt;start&lt;/code&gt; 。在其他时间中，它会记录测试运行的开始时间。</target>
        </trans-unit>
        <trans-unit id="bab90a1ca7bed318a773f1cd868353d680619794" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;stop&lt;/code&gt; immediately after adding all test results to the aggregator.</source>
          <target state="translated">将所有测试结果添加到聚合器后，立即 &lt;code&gt;stop&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="e0f1fdfb2231f4e8ba5ad2172306eb394d414cf5" translate="yes" xml:space="preserve">
          <source>Call all the registered block hooks for type</source>
          <target state="translated">调用所有已注册的类型为</target>
        </trans-unit>
        <trans-unit id="d63876fa9d1b98c3c63563764cf54bc05c244034" translate="yes" xml:space="preserve">
          <source>Call the system level poll routine. If TIMEOUT is not specified then the call will block. Returns the number of handles which had events happen, or -1 on error.</source>
          <target state="translated">调用系统级轮询例程。如果没有指定TIMEOUT,则调用将被阻塞。返回发生事件的句柄数,如果出错,则返回-1。</target>
        </trans-unit>
        <trans-unit id="707d41981449a7ac1f49727761a071399e9047fa" translate="yes" xml:space="preserve">
          <source>Call this function to signal to a stash that it has been assigned to another spot in the stash hierarchy. &lt;code&gt;stash&lt;/code&gt; is the stash that has been assigned. &lt;code&gt;oldstash&lt;/code&gt; is the stash it replaces, if any. &lt;code&gt;gv&lt;/code&gt; is the glob that is actually being assigned to.</source>
          <target state="translated">调用此函数以通知存储已将其分配给存储层次结构中的另一个位置。 &lt;code&gt;stash&lt;/code&gt; 是已分配的储存。 &lt;code&gt;oldstash&lt;/code&gt; 是它替代的存储库（如果有）。 &lt;code&gt;gv&lt;/code&gt; 是实际分配给的glob。</target>
        </trans-unit>
        <trans-unit id="897a2466922f6de52dc65c0d77a98544c7fb349a" translate="yes" xml:space="preserve">
          <source>CallSubPV</source>
          <target state="translated">CallSubPV</target>
        </trans-unit>
        <trans-unit id="ade75b74553b436dc4fbae17ff916436ba41a1b5" translate="yes" xml:space="preserve">
          <source>CallSubSV</source>
          <target state="translated">CallSubSV</target>
        </trans-unit>
        <trans-unit id="9c55daf6e61f9dc1556f1ec913e0ca99b7e0ea38" translate="yes" xml:space="preserve">
          <source>Callback Functions</source>
          <target state="translated">回调功能</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="e2492d7f90f5ff291923cb9e3820556cd26e7081" translate="yes" xml:space="preserve">
          <source>Callbacks may also be added like this:</source>
          <target state="translated">也可以添加这样的回调。</target>
        </trans-unit>
        <trans-unit id="0b30b959e54d6077a0087fde2fbe95f232d8abe1" translate="yes" xml:space="preserve">
          <source>Called after debug API inits itself.</source>
          <target state="translated">在debug API自启动后被调用。</target>
        </trans-unit>
        <trans-unit id="7ce9b93a40160290fff58c32f9bc646588fa275b" translate="yes" xml:space="preserve">
          <source>Called before &lt;code&gt;process_args&lt;/code&gt; to prepend the contents of an rc file to the options.</source>
          <target state="translated">在 &lt;code&gt;process_args&lt;/code&gt; 之前调用，以将rc文件的内容添加到选项之前。</target>
        </trans-unit>
        <trans-unit id="712b31fe99457d34e411f45757dac056dcd534cd" translate="yes" xml:space="preserve">
          <source>Called by &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt; so that the class has a chance to initialize the converter. Internally it sets the &lt;code&gt;batch_mode&lt;/code&gt; property to true and sets &lt;code&gt;batch_mode_current_level()&lt;/code&gt; , but Pod::Simple::XHTML does not currently use those features. Subclasses might, though.</source>
          <target state="translated">由&lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt;调用，以便该类有机会初始化转换器。在内部，它将 &lt;code&gt;batch_mode&lt;/code&gt; 属性设置为true，并设置 &lt;code&gt;batch_mode_current_level()&lt;/code&gt; ，但是Pod :: Simple :: XHTML当前不使用这些功能。但是，子类可以。</target>
        </trans-unit>
        <trans-unit id="d44d9ba6e8c865877532df9753c9657e69186427" translate="yes" xml:space="preserve">
          <source>Called by &lt;code&gt;close_test&lt;/code&gt; to clear the line showing test progress, or the parallel test ruler, prior to printing the final test result.</source>
          <target state="translated">在打印最终测试结果之前，由 &lt;code&gt;close_test&lt;/code&gt; 调用以清除显示测试进度的行或并行测试标尺。</target>
        </trans-unit>
        <trans-unit id="83de9bce1b7b2bd7be455db4ac0ff451b79c596a" translate="yes" xml:space="preserve">
          <source>Called by Perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. This is only responsible for freeing private data; Perl will handle releasing anything else contained in the &lt;code&gt;regexp&lt;/code&gt; structure.</source>
          <target state="translated">当Perl释放正则表达式模式时由Perl调用，以便引擎可以释放正则 &lt;code&gt;regexp&lt;/code&gt; 结构的 &lt;code&gt;pprivate&lt;/code&gt; 成员指向的任何资源。这仅负责释放私人数据；Perl将处理释放 &lt;code&gt;regexp&lt;/code&gt; 结构中包含的任何其他内容。</target>
        </trans-unit>
        <trans-unit id="192f5069ea69d61876f992ae04cbfebd42365fdf" translate="yes" xml:space="preserve">
          <source>Called by Test::Harness before any test output is generated.</source>
          <target state="translated">在产生任何测试输出之前被Test::Harness调用。</target>
        </trans-unit>
        <trans-unit id="252637df9babf3148f5feaeda72912f2045c6976" translate="yes" xml:space="preserve">
          <source>Called by init_main.</source>
          <target state="translated">由 init_main 调用。</target>
        </trans-unit>
        <trans-unit id="4cdb9b50857f3ef3652ef325b6cf3d72fa3622a7" translate="yes" xml:space="preserve">
          <source>Called by init_main. Initializes PERL_*</source>
          <target state="translated">被 init_main 调用.初始化PERL_*.</target>
        </trans-unit>
        <trans-unit id="803f7311292b6dbe520d9001028a74a3740ad58e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up ABSPERL, PERL, FULLPERL and all the *PERLRUN* permutations.</source>
          <target state="translated">由 init_main 调用。设置ABSPERL、PERL、FULLPERL和所有*PERLRUN*的组合。</target>
        </trans-unit>
        <trans-unit id="3f68bdd2c8090ffda024fb7a301dcec75150221e" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INSTALL_* variables (except INSTALLDIRS) and *PREFIX.</source>
          <target state="translated">由 init_main 调用。设置所有 INSTALL_*变量 (除了 INSTALLDIRS)和 *PREFIX。</target>
        </trans-unit>
        <trans-unit id="e5e9ec66a22e81bfffe8ba34ae133177fa3495b6" translate="yes" xml:space="preserve">
          <source>Called by init_main. Sets up all INST_* variables except those related to XS code. Those are handled in init_xs.</source>
          <target state="translated">由init_main调用。设置所有 INST_*变量,除了那些与 XS 代码相关的变量。这些变量由init_xs处理。</target>
        </trans-unit>
        <trans-unit id="1f0c75a0f13f487e51a8d6aa8f296a671eded4fd" translate="yes" xml:space="preserve">
          <source>Called by init_others, and calls ext ExtUtils::Liblist. See &lt;a href=&quot;liblist&quot;&gt;ExtUtils::Liblist&lt;/a&gt; for details.</source>
          <target state="translated">由init_others调用，并调用ext ExtUtils :: Liblist。有关详细信息，请参见&lt;a href=&quot;liblist&quot;&gt;ExtUtils :: Liblist&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa989d1b35e9dfa1af106d6dbfbb5e0924c7a182" translate="yes" xml:space="preserve">
          <source>Called by staticmake. Defines how to write the Makefile to produce a static new perl.</source>
          <target state="translated">由 staticmake 调用。定义如何编写Makefile来生成一个静态的新perl。</target>
        </trans-unit>
        <trans-unit id="a7da98d82f41c03c342a989f11faab94693c6c57" translate="yes" xml:space="preserve">
          <source>Called by the harness for each line of TAP it receives.</source>
          <target state="translated">由线束对它收到的每一行TAP进行调用。</target>
        </trans-unit>
        <trans-unit id="567cd3e87bf8931281fcaa23e35e2da3fe139b11" translate="yes" xml:space="preserve">
          <source>Called by the harness when it needs to create a &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. Override in a subclass to provide an alternative scheduler. &lt;code&gt;make_scheduler&lt;/code&gt; is passed the list of tests that was passed to &lt;code&gt;aggregate_tests&lt;/code&gt; .</source>
          <target state="translated">由线束在需要创建&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;时调用。重写子类以提供替代的调度程序。 &lt;code&gt;make_scheduler&lt;/code&gt; 传递了传递给 &lt;code&gt;aggregate_tests&lt;/code&gt; 的测试列表。</target>
        </trans-unit>
        <trans-unit id="496f62a4d27b344cea2367c44afc046f7d3e616c" translate="yes" xml:space="preserve">
          <source>Called in list context, returns a list consisting of all the keys of the named hash, or in Perl 5.12 or later only, the indices of an array. Perl releases prior to 5.12 will produce a syntax error if you try to use an array argument. In scalar context, returns the number of keys or indices.</source>
          <target state="translated">在列表上下文中调用,返回一个由命名的哈希的所有键组成的列表,或者在Perl 5.12或更高版本中,只返回一个数组的索引。如果使用数组参数,5.12 之前的 Perl 版本会产生语法错误。在标量上下文中,返回键或索引的数量。</target>
        </trans-unit>
        <trans-unit id="467bfe2c2b5fcadd2c658d71f62e583886879a81" translate="yes" xml:space="preserve">
          <source>Called just before exit.</source>
          <target state="translated">出门前打了电话。</target>
        </trans-unit>
        <trans-unit id="56f111d681d8f9bb2b8ea3bbe2cb68fe1cbd1b6b" translate="yes" xml:space="preserve">
          <source>Called to close a test session.</source>
          <target state="translated">调用来关闭一个测试环节。</target>
        </trans-unit>
        <trans-unit id="0fea40ea6e66a6d129222181dca9ffffa1dc50aa" translate="yes" xml:space="preserve">
          <source>Called to create a new test session. A test session looks like this:</source>
          <target state="translated">调用来创建一个新的测试会话。一个测试会话是这样的。</target>
        </trans-unit>
        <trans-unit id="bec535037f1a075b8ca545622477cf0f336b95f2" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and ${^MATCH}, as well as the numbered capture groups (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...).</source>
          <target state="translated">调用以获取/设置 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$'&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 及其等效名称$ {^ PREMATCH}，$ {^ POSTMATCH}和$ {^ MATCH}以及编号的捕获组（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...）。</target>
        </trans-unit>
        <trans-unit id="f05cab34d068a722bc12f2e226cde25cd9659c30" translate="yes" xml:space="preserve">
          <source>Called to get/set the value of &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; , as well as by some utility functions in &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">调用以获取/设置 &lt;code&gt;%+&lt;/code&gt; 和 &lt;code&gt;%-&lt;/code&gt; 的值，以及&lt;a href=&quot;re&quot;&gt;re中的&lt;/a&gt;一些实用程序函数。</target>
        </trans-unit>
        <trans-unit id="8ca1fbe0a0f38d437dca54b642d9f31c3ccb8f90" translate="yes" xml:space="preserve">
          <source>Called when API must show a message (warnings, errors etc.).</source>
          <target state="translated">当API必须显示信息(警告、错误等)时调用。</target>
        </trans-unit>
        <trans-unit id="f94cf1c0617789052abd6d872abe927053b4b0cd" translate="yes" xml:space="preserve">
          <source>Called when a job is complete to unlock it. If a callback has been registered with &lt;code&gt;on_finish&lt;/code&gt; , it calls it. Otherwise, it does nothing.</source>
          <target state="translated">作业完成以解锁时调用。如果回调已在 &lt;code&gt;on_finish&lt;/code&gt; 中注册，它将调用它。否则，它什么都不做。</target>
        </trans-unit>
        <trans-unit id="c5516c9265ba63c86e3ef82397e79274838607cf" translate="yes" xml:space="preserve">
          <source>Called when execution stops (w/ args file, line).</source>
          <target state="translated">当执行停止时调用(w/args file,line)。</target>
        </trans-unit>
        <trans-unit id="145748d07108bcdb9c427172d1270877727239ed" translate="yes" xml:space="preserve">
          <source>Called when the layer is popped from the stack. A layer will normally be popped after &lt;code&gt;Close()&lt;/code&gt; is called. But a layer can be popped without being closed if the program is dynamically managing layers on the stream. In such cases &lt;code&gt;Popped()&lt;/code&gt; should free any resources (buffers, translation tables, ...) not held directly in the layer's struct. It should also &lt;code&gt;Unread()&lt;/code&gt; any unconsumed data that has been read and buffered from the layer below back to that layer, so that it can be re-provided to what ever is now above.</source>
          <target state="translated">从堆栈中弹出图层时调用。通常在调用 &lt;code&gt;Close()&lt;/code&gt; 之后会弹出一个图层。但是，如果程序正在动态管理流中的图层，则可以不关闭而弹出图层。在这种情况下， &lt;code&gt;Popped()&lt;/code&gt; 应该释放任何不直接保存在该层的结构中的资源（缓冲区，转换表等）。它还应该 &lt;code&gt;Unread()&lt;/code&gt; 从下一层读回并缓冲到该层的所有未消耗数据，以便可以将其重新提供给现在的上一层。</target>
        </trans-unit>
        <trans-unit id="939127156e81551fd5a7e818b4482a513aebb0f8" translate="yes" xml:space="preserve">
          <source>Called while stopped (can be a client event loop).</source>
          <target state="translated">在停止时调用(可以是客户端事件循环)。</target>
        </trans-unit>
        <trans-unit id="aac1bcb8d7dddba4603f778cf3da3d2bb22b9d64" translate="yes" xml:space="preserve">
          <source>Called without parameters, or with the first argument false, hash marks are suppressed. If the first argument is true but not a reference to a file handle glob, then \*STDERR is used. The second argument is the number of bytes per hash mark printed, and defaults to 1024. In all cases the return value is a reference to an array of two: the filehandle glob reference and the bytes per hash mark.</source>
          <target state="translated">在没有参数或第一个参数为假的情况下调用,会抑制哈希标记。如果第一个参数为真,但不是对文件句柄glob的引用,则使用\*STDERR。第二个参数是每个散列标记的字节数,默认为1024。在所有情况下,返回值都是对一个数组的引用:文件句柄glob引用和每个哈希标记的字节数。</target>
        </trans-unit>
        <trans-unit id="e216eb70c5a18b158cc8c755c284c444b41dcf38" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt; inside a thread causes the whole application to terminate. Because of this, the use of &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; inside threaded code, or in modules that might be used in threaded applications, is strongly discouraged.</source>
          <target state="translated">在线程内调用&lt;a href=&quot;functions/exit&quot;&gt;exit EXPR&lt;/a&gt;会导致整个应用程序终止。因此，强烈建议不要在线程代码或可能在线程应用程序中使用的模块中使用 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1f81bd75479e40b9c0318383b0b5ea0cddb02d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;flush&lt;/code&gt; returns the array to immediate-write mode. If you wish to discard the deferred writes, you may call &lt;code&gt;-&amp;gt;discard&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;flush&lt;/code&gt; . Note that in some cases, some of the data will have been written already, and it will be too late for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; to discard all the changes. Support for &lt;code&gt;-&amp;gt;discard&lt;/code&gt; may be withdrawn in a future version of &lt;code&gt;Tie::File&lt;/code&gt; .</source>
          <target state="translated">调用 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 将使阵列返回立即写入模式。如果您希望丢弃延迟的写入，则可以调用 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 而不是 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 。请注意，在某些情况下，某些数据将已经被写入，并且 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 放弃所有更改将为时已晚。在将来的 &lt;code&gt;Tie::File&lt;/code&gt; 版本中可能会取消对 &lt;code&gt;-&amp;gt;discard&lt;/code&gt; 的支持。</target>
        </trans-unit>
        <trans-unit id="b218ac14d28e4eba90c2438d62379a52be6547e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already detached thread will cause an error to be thrown.</source>
          <target state="translated">在已经分离的线程上调用 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 会引发错误。</target>
        </trans-unit>
        <trans-unit id="66b0f01a2dc8c4ec0ab9ed2203d7fa7fc14d740a" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; on an already joined thread will cause an error to be thrown.</source>
          <target state="translated">在已加入的线程上调用 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 会引发错误。</target>
        </trans-unit>
        <trans-unit id="5013e17c5c2bf4d76b64a60f93a3e6d87ce580e9" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; in a thread indicates an abnormal exit for the thread. Any &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler in the thread will be called first, and then the thread will exit with a warning message that will contain any arguments passed in the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">在线程中调用 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 表示该线程异常退出。线程中的任何 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 处理函数都将首先被调用，然后线程将退出并显示一条警告消息，其中包含在 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 调用中传递的所有参数。</target>
        </trans-unit>
        <trans-unit id="432a891f5fe2a318db5e9ee1a582e0b88a0dccd1" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;attributes::get()&lt;/code&gt; from within the scope of a null package declaration &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; for an unblessed variable reference will not provide any starting package name for the 'fetch' method lookup. Thus, this circumstance will not result in a method call for package-defined attributes. A named subroutine knows to which symbol table entry it belongs (or originally belonged), and it will use the corresponding package. An anonymous subroutine knows the package name into which it was compiled (unless it was also compiled with a null package declaration), and so it will use that package name.</source>
          <target state="translated">从空包声明 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt; ;&lt;/code&gt; 的范围内调用 &lt;code&gt;attributes::get()&lt;/code&gt; ；对于无穷大的变量，引用将不会为'fetch'方法查找提供任何起始包名称。因此，这种情况不会导致对程序包定义的属性进行方法调用。命名子例程知道它属于（或最初属于）哪个符号表条目，它将使用相应的包。匿名子例程知道将其编译到的程序包名称（除非它也使用空程序包声明进行编译），因此它将使用该程序包名称。</target>
        </trans-unit>
        <trans-unit id="33bb3644bf1e13b2cbec6a1bd85b13b8d5473401" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;finalize&lt;/code&gt; on a child with open children will &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">打电话给有开放性孩子的孩子 &lt;code&gt;finalize&lt;/code&gt; 将 &lt;code&gt;croak&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a05e36379b2d12e2a61d8dca60e3236620cfbdd1" translate="yes" xml:space="preserve">
          <source>Calling Configure</source>
          <target state="translated">调用配置</target>
        </trans-unit>
        <trans-unit id="858cb737d2c8f0a72b951ab4ea78b7b78f817737" translate="yes" xml:space="preserve">
          <source>Calling Conventions and Magic Autogeneration</source>
          <target state="translated">呼叫协议和魔法自动生成</target>
        </trans-unit>
        <trans-unit id="5a077d29f5340a5b715ff2d0b7446d09abed736c" translate="yes" xml:space="preserve">
          <source>Calling Perl Routines from within C Programs</source>
          <target state="translated">从C程序中调用Perl例程</target>
        </trans-unit>
        <trans-unit id="da4bd907e548514c9e5225dea46a70baeae7e05d" translate="yes" xml:space="preserve">
          <source>Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is complete. It is removed from the list of 'exported' FILE *s, and the associated PerlIO * should revert to its original behaviour.</source>
          <target state="translated">调用PerlIO_releaseFILE通知PerlIO对FILE *的所有使用已经完成。它从 &quot;导出 &quot;的FILE *s列表中被移除,相关的PerlIO *应该恢复到原来的行为。</target>
        </trans-unit>
        <trans-unit id="4f10f9c81f6874964032fb54a94909bb2041ccaa" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;find(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;find(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">调用Pod :: Simple :: Search-&amp;gt; find（...）是Pod :: Simple :: Search-&amp;gt; new-&amp;gt; find（...）的缩写。即，使用具有默认属性值的一次性对象。</target>
        </trans-unit>
        <trans-unit id="63b53fa8f0a187ed1ffd0c16a376efb544cfcb62" translate="yes" xml:space="preserve">
          <source>Calling Pod::Simple::Search-&amp;gt;search(...) is short for Pod::Simple::Search-&amp;gt;new-&amp;gt;search(...). That is, a throwaway object with default attribute values is used.</source>
          <target state="translated">调用Pod :: Simple :: Search-&amp;gt; search（...）是Pod :: Simple :: Search-&amp;gt; new-&amp;gt; search（...）的缩写。即，使用具有默认属性值的一次性对象。</target>
        </trans-unit>
        <trans-unit id="ae570393756fa33aae649a93468e74ad3aa690b1" translate="yes" xml:space="preserve">
          <source>Calling a Perl method from C is fairly straightforward. The following things are required:</source>
          <target state="translated">从C语言中调用Perl方法是相当直接的。需要做以下事情。</target>
        </trans-unit>
        <trans-unit id="4f751357fb4ae38f84e904fc36d9db5113b5aaaf" translate="yes" xml:space="preserve">
          <source>Calling a Perl subroutine from your C program</source>
          <target state="translated">从你的C程序中调用一个Perl子程序</target>
        </trans-unit>
        <trans-unit id="c40cbac274b56e1beac728d697b23cc2ad8b3e30" translate="yes" xml:space="preserve">
          <source>Calling a method on an object is written as &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; .</source>
          <target state="translated">在对象上调用方法的方式为 &lt;code&gt;$object-&amp;gt;method&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="effd5ea5d1271fcf8d367de7457fffef004c2411" translate="yes" xml:space="preserve">
          <source>Calling a subroutine as &lt;code&gt;&amp;amp;foo&lt;/code&gt; with no trailing parentheses ignores the prototype of &lt;code&gt;foo&lt;/code&gt; and passes it the current value of the argument list, &lt;code&gt;@_&lt;/code&gt; . Here's an example; the &lt;code&gt;bar&lt;/code&gt; subroutine calls &lt;code&gt;&amp;amp;foo&lt;/code&gt; , which prints its arguments list:</source>
          <target state="translated">调用无尾括号的 &lt;code&gt;&amp;amp;foo&lt;/code&gt; 子例程会忽略 &lt;code&gt;foo&lt;/code&gt; 的原型，并将参数列表 &lt;code&gt;@_&lt;/code&gt; 的当前值传递给它。这是一个例子。该 &lt;code&gt;bar&lt;/code&gt; 子程序调用 &lt;code&gt;&amp;amp;foo&lt;/code&gt; ，这显示它的参数列表：</target>
        </trans-unit>
        <trans-unit id="83a5a40c5745b90b08565729f9c8b41d859bfba5" translate="yes" xml:space="preserve">
          <source>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle &lt;code&gt;_&lt;/code&gt; . It still refers to the result of the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; or unoverloaded filetest.</source>
          <target state="translated">调用重载的filetest运算符不会影响与特殊文件句柄 &lt;code&gt;_&lt;/code&gt; 关联的stat值。它仍然引用最后一个 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 或unloaded filetest的结果。</target>
        </trans-unit>
        <trans-unit id="013392383aeb8f3aaeaada77da8e78bbc103974c" translate="yes" xml:space="preserve">
          <source>Calling either function on a string that already is in the desired state is a no-op.</source>
          <target state="translated">在一个已经处于所需状态的字符串上调用这两个函数都是不行的。</target>
        </trans-unit>
        <trans-unit id="ac9d89d6b846180f08777572deb7332f87bf19f8" translate="yes" xml:space="preserve">
          <source>Calling exec() within a pseudo-process actually spawns the requested executable in a separate process and waits for it to complete before exiting with the same exit status as that process. This means that the process ID reported within the running executable will be different from what the earlier Perl fork() might have returned. Similarly, any process manipulation functions applied to the ID returned by fork() will affect the waiting pseudo-process that called exec(), not the real process it is waiting for after the exec().</source>
          <target state="translated">在伪进程中调用exec(),实际上是在一个单独的进程中生成所请求的可执行文件,并等待其完成,然后以与该进程相同的退出状态退出。这意味着在运行中的可执行文件中报告的进程ID将与之前Perl fork()可能返回的不同。同样,任何应用于fork()返回的ID的进程操作函数都会影响调用exec()的等待伪进程,而不是它在exec()之后等待的真正进程。</target>
        </trans-unit>
        <trans-unit id="40ade94f7a99e61011be8ace5918982f9630cfc9" translate="yes" xml:space="preserve">
          <source>Calling the Debugger</source>
          <target state="translated">调用调试器</target>
        </trans-unit>
        <trans-unit id="2ca81641ec6217e87de3fa52de37358174c935e6" translate="yes" xml:space="preserve">
          <source>Calling the subroutine with trailing parentheses, with or without arguments, does not use the current &lt;code&gt;@_&lt;/code&gt; . Changing the example to put parentheses after the call to &lt;code&gt;foo&lt;/code&gt; changes the program:</source>
          <target state="translated">带有或不带有参数的带尾括号的子例程不会使用当前的 &lt;code&gt;@_&lt;/code&gt; 。将示例更改为在对 &lt;code&gt;foo&lt;/code&gt; 的调用后加上括号可更改程序：</target>
        </trans-unit>
        <trans-unit id="492d320490c0c1bea0a0670c56d499e8b857ba1c" translate="yes" xml:space="preserve">
          <source>Calling this function repeatedly will create a FILE * on each call (and will push an :stdio layer each time as well).</source>
          <target state="translated">反复调用这个函数会在每次调用时创建一个FILE *(并且每次也会推送一个:stdio层)。</target>
        </trans-unit>
        <trans-unit id="bc6008c1e7f7d9345b7132b8abf50b8ba6fadc50" translate="yes" xml:space="preserve">
          <source>Calling this function will cause any temp files or temp directories that are registered for removal to be removed. This happens automatically when the process exits but can be triggered manually if the caller is sure that none of the temp files are required. This method can be registered as an Apache callback.</source>
          <target state="translated">调用此函数将导致任何注册为删除的临时文件或临时目录被删除。这将在进程退出时自动发生,但如果调用者确定不需要临时文件,也可以手动触发。这个方法可以被注册为Apache的回调。</target>
        </trans-unit>
        <trans-unit id="b2c554dbf8d391703907c916da0c8b2d2b667cbb" translate="yes" xml:space="preserve">
          <source>Calling this on the root builder is a no-op.</source>
          <target state="translated">在根基建树上调用这个是不行的。</target>
        </trans-unit>
        <trans-unit id="2e765d5d5aa54eb2d852bc799f3a264f32d02c18" translate="yes" xml:space="preserve">
          <source>Calling with ampersand syntax and through references does not work for the following functions, as they have special syntax that cannot always be translated into a simple list (e.g., &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">对于以下函数，使用＆语法和通过引用进行调用不适用于以下函数，因为它们具有的特殊语法无法始终转换为简单列表（例如 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="fd4f026ec1a5607feec9a1e107752900730638f9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; turning off the ending tests. This is needed as otherwise it will trip out because we've run more tests than we strictly should have and it'll register any failures we had that we were testing for as real failures.</source>
          <target state="translated">调用 &lt;code&gt;Test::Builder-&amp;gt;no_ending&lt;/code&gt; 关闭结束测试。这是必需的，否则它将跳闸，因为我们运行的测试超出了我们应有的严格标准，并且会将我们测试过的所有失败记录为真正的失败。</target>
        </trans-unit>
        <trans-unit id="590c7d6e88adb5bddf3d8f642e0126b6c862bc26" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once. Does not handle 'set' magic on the destination SV.</source>
          <target state="translated">呼叫 &lt;code&gt;sv_setsv&lt;/code&gt; 如果DSV是不一样的SSV。可能会多次评估参数。不处理目标SV上的&amp;ldquo;设置&amp;rdquo;魔法。</target>
        </trans-unit>
        <trans-unit id="ecc1c1a42047512bf4698d979850ea62424810ba" translate="yes" xml:space="preserve">
          <source>Calls Cwd::cwd</source>
          <target state="translated">调用Cwd::cwd。</target>
        </trans-unit>
        <trans-unit id="c904982ef90b628587f5e1c223b066f40097484e" translate="yes" xml:space="preserve">
          <source>Calls Cwd::fastcwd</source>
          <target state="translated">调用Cwd::fastcwd。</target>
        </trans-unit>
        <trans-unit id="8c1ba5cb44af7e4a4c20a5047a781fc7e8a8fc22" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getcwd</source>
          <target state="translated">调用Cwd::getcwd。</target>
        </trans-unit>
        <trans-unit id="206e7aa2eb36edf2b309bbc5748aac00256c2321" translate="yes" xml:space="preserve">
          <source>Calls Cwd::getdcwd</source>
          <target state="translated">调用Cwd::getdcwd。</target>
        </trans-unit>
        <trans-unit id="780a41207facdbbb71db04db90d90ec1fa2163f5" translate="yes" xml:space="preserve">
          <source>Calls a non-destructive version of &lt;code&gt;sv_setsv&lt;/code&gt; if dsv is not the same as ssv. May evaluate arguments more than once.</source>
          <target state="translated">如果dsv 与 &lt;code&gt;sv_setsv&lt;/code&gt; 则调用sv_setsv 的非破坏性版本。可能会多次评估参数。</target>
        </trans-unit>
        <trans-unit id="4ff2ef8b2188043c87a9c12a3c9cbf04635b332b" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">在FILEHANDLE上调用flock（2）或其仿真。成功返回true，失败返回false。如果在未实现flock（2），fcntl（2）锁定或lockf（3）的计算机上使用，则会产生致命错误。 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 是Perl的可移植文件锁定接口，尽管它仅锁定整个文件，而不是记录。</target>
        </trans-unit>
        <trans-unit id="bb35c1fa57137cad992f4edf7e56c85897367e17" translate="yes" xml:space="preserve">
          <source>Calls flock(2), or an emulation of it, on FILEHANDLE. Returns true for success, false on failure. Produces a fatal error if used on a machine that doesn't implement flock(2), fcntl(2) locking, or lockf(3). &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; is Perl's portable file-locking interface, although it locks entire files only, not records.</source>
          <target state="translated">在FILEHANDLE上调用flock（2）或其仿真。成功返回true，失败返回false。如果在未实现flock（2），fcntl（2）锁定或lockf（3）的计算机上使用，则会产生致命错误。 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 是Perl的可移植文件锁定接口，尽管它仅锁定整个文件，而不是记录。</target>
        </trans-unit>
        <trans-unit id="773f4cafc0f3777dd34c2b664ecf08fdcad62645" translate="yes" xml:space="preserve">
          <source>Calls install() with arguments to copy a module from blib/ to the default site installation location.</source>
          <target state="translated">调用install(),其参数是将一个模块从blib/复制到默认的站点安装位置。</target>
        </trans-unit>
        <trans-unit id="f72e847b0819bcbc3ab49dbf4b9ab2bb349a665c" translate="yes" xml:space="preserve">
          <source>Calls makeaperl.</source>
          <target state="translated">呼叫使aperl。</target>
        </trans-unit>
        <trans-unit id="37943b6a726d9d0c50758cce3c190484f78dfe2c" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a list context.</source>
          <target state="translated">在列表上下文中调用Perl子程序。</target>
        </trans-unit>
        <trans-unit id="bb7f57720f3817b40ff0bbe8ea59e47c2d2ab29e" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a scalar context. This is the default context flag setting for all the</source>
          <target state="translated">在标量上下文中调用Perl子程序。这是所有的</target>
        </trans-unit>
        <trans-unit id="73962f3f75b41688efacfc0da40dee4461b9fec3" translate="yes" xml:space="preserve">
          <source>Calls the Perl subroutine in a void context.</source>
          <target state="translated">在void上下文中调用Perl子程序。</target>
        </trans-unit>
        <trans-unit id="f29d60ee63be0b6e387efbeaa174ef5a3adf4ba4" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgctl(2). You'll probably have to say</source>
          <target state="translated">调用System V IPC函数msgctl(2)。您可能会说</target>
        </trans-unit>
        <trans-unit id="be9988a6d42da7c4020e6a5f954992f1c4491de0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">调用系统V IPC函数msgget（2）。返回消息队列ID，或在出错时 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::Msg&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="98b9f73da86e0e6b472bbcb69f309820842a2666" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgget(2). Returns the message queue id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::Msg&lt;/code&gt; .</source>
          <target state="translated">调用系统V IPC函数msgget（2）。返回消息队列ID，或在出错时 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::Msg&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="bc2abfdb7a6e8deeeb37c01f08b5371f84b9260b" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">调用系统V IPC函数msgrcv，以将消息队列ID中的消息接收到最大消息大小为SIZE的变量VAR中。请注意，收到消息时，消息类型（本机长整数）将是VAR中的第一件事，其次是实际消息。该包装可打开 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 。污染变量。如果成功，则返回true；如果错误，则返回false。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="948f348f6fa98a8010bd8fc9ae4ccc04726f6c57" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgrcv to receive a message from message queue ID into variable VAR with a maximum message size of SIZE. Note that when a message is received, the message type as a native long integer will be the first thing in VAR, followed by the actual message. This packing may be opened with &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; . Taints the variable. Returns true if successful, false on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and the documentation for &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; .</source>
          <target state="translated">调用系统V IPC函数msgrcv，以将消息队列ID中的消息接收到最大消息大小为SIZE的变量VAR中。请注意，收到消息时，消息类型（本机长整数）将是VAR中的第一件事，其次是实际消息。该包装可打开 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;(&quot;l! a*&quot;)&lt;/code&gt; 。污染变量。如果成功，则返回true；如果错误，则返回false。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 的文档。</target>
        </trans-unit>
        <trans-unit id="c5afcee05064a60e928b37ea8427c6294d37aba0" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数msgsnd将消息MSG发送到消息队列ID。MSG必须以本机长整数消息类型开头，后跟实际消息的长度，最后是消息本身。可以使用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 实现这种打包。如果成功，则返回true；如果错误，则返回false。另请参阅 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="11394b0f70e6027e810e867a48b7248721c79467" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function msgsnd to send the message MSG to the message queue ID. MSG must begin with the native long integer message type, be followed by the length of the actual message, and then finally the message itself. This kind of packing can be achieved with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; . Returns true if successful, false on error. See also the &lt;code&gt;IPC::SysV&lt;/code&gt; and &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数msgsnd将消息MSG发送到消息队列ID。MSG必须以本机长整数消息类型开头，后跟实际消息的长度，最后是消息本身。可以使用 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;l! a*&quot;, $type, $message)&lt;/code&gt; 实现这种打包。如果成功，则返回true；如果错误，则返回false。另请参阅 &lt;code&gt;IPC::SysV&lt;/code&gt; 和 &lt;code&gt;IPC::SysV::Msg&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="6019e00f804cda82d4ccc726e831f656c990eb13" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semctl(2). You'll probably have to say</source>
          <target state="translated">调用System V IPC函数semctl(2)。你可能不得不说</target>
        </trans-unit>
        <trans-unit id="5f610b5b4eaf02b0f729a98fdbc4342fbee172a9" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数semget（2）。返回信号灯ID，或在错误时返回未定义的值。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; ， &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="315be1c7490d0b06d562bb984c8930c31052ce5c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semget(2). Returns the semaphore id, or the undefined value on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt;, &lt;code&gt;IPC::SysV&lt;/code&gt; , &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数semget（2）。返回信号灯ID，或在错误时返回未定义的值。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;， &lt;code&gt;IPC::SysV&lt;/code&gt; ， &lt;code&gt;IPC::SysV::Semaphore&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="ef274fb91ef606897494225538343bd9782c7288" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">调用System V IPC函数semop（2）进行信号量操作，例如信令和等待。 OPSTRING必须是打包的semop结构数组。每个semop结构都可以用 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 。 OPSTRING的长度表示信号量操作的数量。如果成功，则返回true；如果错误，则返回false。例如，以下代码在信号灯ID $ semid的信号灯$ semnum上等待：</target>
        </trans-unit>
        <trans-unit id="e0c44ed833fa28db0acecadac8e6a6c1fb4ee6ed" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function semop(2) for semaphore operations such as signalling and waiting. OPSTRING must be a packed array of semop structures. Each semop structure can be generated with &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; . The length of OPSTRING implies the number of semaphore operations. Returns true if successful, false on error. As an example, the following code waits on semaphore $semnum of semaphore id $semid:</source>
          <target state="translated">调用System V IPC函数semop（2）进行信号量操作，例如信令和等待。 OPSTRING必须是打包的semop结构数组。每个semop结构都可以用 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;s!3&quot;, $semnum, $semop, $semflag)&lt;/code&gt; 。 OPSTRING的长度表示信号量操作的数量。如果成功，则返回true；如果错误，则返回false。例如，以下代码在信号灯ID $ semid的信号灯$ semnum上等待：</target>
        </trans-unit>
        <trans-unit id="c7ffce30c16d2adb19634cb73edd07b139d51d58" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmctl. You'll probably have to say</source>
          <target state="translated">调用System V IPC函数shmctl。你可能不得不说</target>
        </trans-unit>
        <trans-unit id="b0bc62f7fa862b27b2de307fc455c072f03da35c" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数shmget。返回共享内存段的ID，或在出错时 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。另请参见&lt;a href=&quot;perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="4c305f2b321c34aa679da0caad314dcb3d11fcda" translate="yes" xml:space="preserve">
          <source>Calls the System V IPC function shmget. Returns the shared memory segment id, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error. See also &lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;SysV IPC in perlipc&lt;/a&gt; and &lt;code&gt;IPC::SysV&lt;/code&gt; documentation.</source>
          <target state="translated">调用系统V IPC函数shmget。返回共享内存段的ID，或在出错时 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。另请参见&lt;a href=&quot;../perlipc#SysV-IPC&quot;&gt;perlipc中的SysV IPC&lt;/a&gt;和 &lt;code&gt;IPC::SysV&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="171e1908f8052943b22ba1224601d2782bb8861e" translate="yes" xml:space="preserve">
          <source>Calls the external command cwd.</source>
          <target state="translated">调用外部命令cwd。</target>
        </trans-unit>
        <trans-unit id="3c0dfe2a93186d77d26e8574e4df98dbb4f6b11b" translate="yes" xml:space="preserve">
          <source>Calls the reports() method on the associated distribution object.</source>
          <target state="translated">调用关联分发对象上的reports()方法。</target>
        </trans-unit>
        <trans-unit id="e80219f44739d96f5e20c3cf29ed7bd7ff8e792b" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">调用指定为列表第一个元素的系统调用，并将其余元素作为参数传递给系统调用。如果未实现，则会引发异常。参数的解释如下：如果给定的参数是数字，则该参数作为int传递。如果不是，则传递指向字符串值的指针。您有责任确保将字符串预扩展足够长的时间，以接收可能写入字符串的任何结果。您不能将字符串文字（或其他只读字符串）用作 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 的参数，因为Perl必须假定可能会写入任何字符串指针。如果您的整数参数不是文字，并且从未在数字上下文中进行解释，则可能需要添加 &lt;code&gt;0&lt;/code&gt; 他们强迫他们看起来像数字。这模拟 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数（反之亦然）：</target>
        </trans-unit>
        <trans-unit id="14adf48ff5b79cf02eb35e0df8ee02d1dedea8a0" translate="yes" xml:space="preserve">
          <source>Calls the system call specified as the first element of the list, passing the remaining elements as arguments to the system call. If unimplemented, raises an exception. The arguments are interpreted as follows: if a given argument is numeric, the argument is passed as an int. If not, the pointer to the string value is passed. You are responsible to make sure a string is pre-extended long enough to receive any result that might be written into a string. You can't use a string literal (or other read-only string) as an argument to &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; because Perl has to assume that any string pointer might be written through. If your integer arguments are not literals and have never been interpreted in a numeric context, you may need to add &lt;code&gt;0&lt;/code&gt; to them to force them to look like numbers. This emulates the &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function (or vice versa):</source>
          <target state="translated">调用指定为列表第一个元素的系统调用，并将其余元素作为参数传递给系统调用。如果未实现，则会引发异常。参数的解释如下：如果给定的参数是数字，则该参数作为int传递。如果不是，则传递指向字符串值的指针。您有责任确保将字符串预扩展足够长的时间，以接收可能写入字符串的任何结果。您不能将字符串文字（或其他只读字符串）用作 &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 的参数，因为Perl必须假定可能会写入任何字符串指针。如果您的整数参数不是文字，并且从未在数字上下文中进行解释，则可能需要添加 &lt;code&gt;0&lt;/code&gt; 他们强迫他们看起来像数字。这模拟 &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 函数（反之亦然）：</target>
        </trans-unit>
        <trans-unit id="4689606e99f2e0dc6a1ba0af906a041a8988cfda" translate="yes" xml:space="preserve">
          <source>Calls to external programs</source>
          <target state="translated">呼叫外部程序</target>
        </trans-unit>
        <trans-unit id="b9f578265a3254a0619351c53e86631e90149c66" translate="yes" xml:space="preserve">
          <source>Calls user-supplied functions for conversion. For &lt;code&gt;OUTPUT&lt;/code&gt; (XSUB to Perl), a function named &lt;code&gt;XS_pack_$ntype&lt;/code&gt; is called with the output Perl scalar and the C variable to convert from. &lt;code&gt;$ntype&lt;/code&gt; is the normalized C type that is to be mapped to Perl. Normalized means that all &lt;code&gt;*&lt;/code&gt; are replaced by the string &lt;code&gt;Ptr&lt;/code&gt; . The return value of the function is ignored.</source>
          <target state="translated">调用用户提供的函数进行转换。对于 &lt;code&gt;OUTPUT&lt;/code&gt; （从XSUB到Perl），将调用名为 &lt;code&gt;XS_pack_$ntype&lt;/code&gt; 的函数，并使用输出Perl标量和C变量进行转换。 &lt;code&gt;$ntype&lt;/code&gt; 是要映射到Perl的规范化C类型。规范化意味着所有 &lt;code&gt;*&lt;/code&gt; 被字符串 &lt;code&gt;Ptr&lt;/code&gt; 替换。该函数的返回值将被忽略。</target>
        </trans-unit>
        <trans-unit id="adb92c1608308898a1811cd12d916df49f9c32f4" translate="yes" xml:space="preserve">
          <source>CamelBones ( &lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt; ) is a Perl interface to Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that CPAN.pm doesn't know how to install, but installation is via the standard OSX package installer. The Perl API is, again, very close to the ObjC API it's wrapping, and the documentation just tells you how to translate from one to the other.</source>
          <target state="translated">CamelBones（&lt;a href=&quot;http://camelbones.sourceforge.net&quot;&gt;http://camelbones.sourceforge.net&lt;/a&gt;）是Mac OS X的Cocoa GUI工具包的Perl界面，因此可用于在Mac OS X上生成本机GUI。它不在CPAN上，因为它需要使用CPAN的框架.pm不知道如何安装，但是通过标准OSX软件包安装程序进行安装。同样，Perl API与它包装的ObjC API非常接近，并且文档仅告诉您如何从一种翻译到另一种。</target>
        </trans-unit>
        <trans-unit id="80701e22e30b3906cffd903f13b0b88b4269184d" translate="yes" xml:space="preserve">
          <source>CamelGrayBig.BMP</source>
          <target state="translated">CamelGrayBig.BMP</target>
        </trans-unit>
        <trans-unit id="e06a2487ce9da8707485d167c86e4cec108412be" translate="yes" xml:space="preserve">
          <source>Can I do [task] in Perl?</source>
          <target state="translated">我可以在Perl中做[任务]吗?</target>
        </trans-unit>
        <trans-unit id="17260f8bf54a1e0a6921ffbe29352d30c7eb0d7e" translate="yes" xml:space="preserve">
          <source>Can I get a BNF/yacc/RE for the Perl language?</source>
          <target state="translated">我可以得到一个用于Perl语言的BNF/yacc/RE吗?</target>
        </trans-unit>
        <trans-unit id="3a800859ea9403fd88df5aa63fab2b1ed9bba4be" translate="yes" xml:space="preserve">
          <source>Can I use Perl regular expressions to match balanced text?</source>
          <target state="translated">我可以使用 Perl 正则表达式来匹配平衡文本吗?</target>
        </trans-unit>
        <trans-unit id="2289a974ae52b9e29f0b401490ee2c25637b7437" translate="yes" xml:space="preserve">
          <source>Can I use Unicode in my Perl sources?</source>
          <target state="translated">我可以在Perl的源代码中使用Unicode吗?</target>
        </trans-unit>
        <trans-unit id="32e50e864db1746776899a01caf14e13d2d4a291" translate="yes" xml:space="preserve">
          <source>Can I use perl to run a telnet or ftp session?</source>
          <target state="translated">我可以使用perl来运行telnet或ftp会话吗?</target>
        </trans-unit>
        <trans-unit id="14d0ae1165be9b8566f8406ca14230c7961f4848" translate="yes" xml:space="preserve">
          <source>Can I write useful Perl programs on the command line?</source>
          <target state="translated">我可以在命令行上编写有用的Perl程序吗?</target>
        </trans-unit>
        <trans-unit id="35df49ce9c972c29af7bf8e861531cb5efb30472" translate="yes" xml:space="preserve">
          <source>Can also be called as an instance method.</source>
          <target state="translated">也可以作为实例方法调用。</target>
        </trans-unit>
        <trans-unit id="4ba8c255d770ca0f7b72beded6916ada06108fbe" translate="yes" xml:space="preserve">
          <source>Can also be used to set &lt;code&gt;$TODO&lt;/code&gt; to a new value while returning the old value:</source>
          <target state="translated">还可以用于将 &lt;code&gt;$TODO&lt;/code&gt; 设置为新值，同时返回旧值：</target>
        </trans-unit>
        <trans-unit id="91cc357ede21e8f86848e6eae7e811a215ba08ce" translate="yes" xml:space="preserve">
          <source>Can be constructed using &lt;code&gt;pod2latex&lt;/code&gt; .</source>
          <target state="translated">可以使用 &lt;code&gt;pod2latex&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="fa58e7bcf2882cbd00cc88fa0dc03c0cd52468bb" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether code references are turned into perl source code. If set to a true value, &lt;code&gt;B::Deparse&lt;/code&gt; will be used to get the source of the code reference. Using this option will force using the Perl implementation of the dumper, since the fast XSUB implementation doesn't support it.</source>
          <target state="translated">可以设置为布尔值，以控制是否将代码引用转换为perl源代码。如果设置为真值，则 &lt;code&gt;B::Deparse&lt;/code&gt; 将用于获取代码引用的源。使用此选项将强制使用转储程序的Perl实现，因为快速的XSUB实现不支持它。</target>
        </trans-unit>
        <trans-unit id="6c627856437742bf2a91768641f29dacbba9c49e" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are dumped in sorted order. A true value will cause the keys of all hashes to be dumped in Perl's default sort order. Can also be set to a subroutine reference which will be called for each hash that is dumped. In this case &lt;code&gt;Data::Dumper&lt;/code&gt; will call the subroutine once for each hash, passing it the reference of the hash. The purpose of the subroutine is to return a reference to an array of the keys that will be dumped, in the order that they should be dumped. Using this feature, you can control both the order of the keys, and which keys are actually used. In other words, this subroutine acts as a filter by which you can exclude certain keys from being dumped. Default is 0, which means that hash keys are not sorted.</source>
          <target state="translated">可以设置为布尔值以控制是否按排序顺序转储哈希键。值为true会导致所有哈希的键都按照Perl的默认排序顺序转储。也可以设置为子例程引用，该引用将为每个转储的哈希调用。在这种情况下， &lt;code&gt;Data::Dumper&lt;/code&gt; 将为每个哈希调用一次子例程，并将其引用传递给哈希。子例程的目的是按应转储的顺序返回对将要转储的键的数组的引用。使用此功能，您可以控制按键的顺序以及实际使用的按键。换句话说，此子例程充当筛选器，通过该筛选器，您可以排除某些键不被转储。默认值为0，这表示哈希键不排序。</target>
        </trans-unit>
        <trans-unit id="7fb27ddb4917ba511f5c8620ff526bf1f7bf1e63" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to control whether hash keys are quoted. A defined false value will avoid quoting hash keys when it looks like a simple string. Default is 1, which will always enclose hash keys in quotes.</source>
          <target state="translated">可以设置为一个布尔值来控制是否引用哈希键。如果定义为false,则当哈希键看起来像一个简单的字符串时,将避免使用引号。默认值为1,将始终用引号括住哈希键。</target>
        </trans-unit>
        <trans-unit id="88c46add64294e8210c672da2183abe0ed447bfc" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value to enable deep copies of structures. Cross-referencing will then only be done when absolutely essential (i.e., to break reference cycles). Default is 0.</source>
          <target state="translated">可以设置为布尔值,以启用结构的深度拷贝。然后,只有在绝对必要的情况下才会进行交叉引用(即打破引用周期)。默认值为0。</target>
        </trans-unit>
        <trans-unit id="67a33f1bf6a1de539cc6aeb590a56729f0fa737c" translate="yes" xml:space="preserve">
          <source>Can be set to a boolean value which controls whether the pure Perl implementation of &lt;code&gt;Data::Dumper&lt;/code&gt; is used. The &lt;code&gt;Data::Dumper&lt;/code&gt; module is a dual implementation, with almost all functionality written in both pure Perl and also in XS ('C'). Since the XS version is much faster, it will always be used if possible. This option lets you override the default behavior, usually for testing purposes only. Default is 0, which means the XS implementation will be used if possible.</source>
          <target state="translated">可以设置为一个布尔值，该值控制是否使用 &lt;code&gt;Data::Dumper&lt;/code&gt; 的纯Perl实现。该 &lt;code&gt;Data::Dumper&lt;/code&gt; 模块是双实现，写在这两个纯Perl和也XS（&amp;ldquo;C&amp;rdquo;）几乎所有功能。由于XS版本要快得多，因此将尽可能使用它。此选项使您可以覆盖默认行为，通常仅出于测试目的。默认值为0，这意味着将尽可能使用XS实现。</target>
        </trans-unit>
        <trans-unit id="cb22428de8a3ede5e563a5e4f65611da085b8c2a" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will emit a method call for any objects that are to be dumped using the syntax &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; . Note that this means that the method specified will have to perform any modifications required on the object (like creating new state within it, and/or reblessing it in a different package) and then return it. The client is responsible for making sure the method can be called via the object, and that it returns a valid object. Defaults to an empty string.</source>
          <target state="translated">可以设置为方法名称，也可以设置为空字符串以禁用该功能。 Data :: Dumper将使用 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;(DATA, CLASS)-&amp;gt;METHOD()&lt;/code&gt; 语法对要转储的任何对象发出方法调用。请注意，这意味着指定的方法将必须对对象执行所需的任何修改（例如在对象中创建新状态，和/或在不同的包中重新赋予它状态），然后将其返回。客户端负责确保可以通过对象调用该方法，并返回有效的对象。默认为空字符串。</target>
        </trans-unit>
        <trans-unit id="585673e874a0b17703c1a10f7dfc47aff5c9f0ec" translate="yes" xml:space="preserve">
          <source>Can be set to a method name, or to an empty string to disable the feature. Data::Dumper will invoke that method via the object before attempting to stringify it. This method can alter the contents of the object (if, for instance, it contains data allocated from C), and even rebless it in a different package. The client is responsible for making sure the specified method can be called via the object, and that the object ends up containing only perl data types after the method has been called. Defaults to an empty string.</source>
          <target state="translated">可以设置为一个方法名,或者设置为一个空字符串来禁用该功能。Data::Dumper 将在尝试将其字符串化之前通过对象调用该方法。这个方法可以改变对象的内容(例如,如果它包含从C中分配的数据),甚至可以在不同的包中重新无视它。客户端负责确保指定的方法可以通过对象被调用,并且在方法被调用后,对象最终只包含perl数据类型。默认为一个空字符串。</target>
        </trans-unit>
        <trans-unit id="6ee2759a6426aff4b67b4db8b27a81f5748f17a4" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which recursion into a structure will throw an exception. This is intended as a security measure to prevent perl running out of stack space when dumping an excessively deep structure. Can be set to 0 to remove the limit. Default is 1000.</source>
          <target state="translated">可以设置为一个正整数,指定向结构体递归的深度,超过这个深度就会抛出异常。这是为了防止在转储过深的结构体时,perl耗尽栈空间而采取的安全措施。可以设置为0来取消这个限制。默认值是1000。</target>
        </trans-unit>
        <trans-unit id="4bf42f1af137c40c87a30e672fa92d800507f75f" translate="yes" xml:space="preserve">
          <source>Can be set to a positive integer that specifies the depth beyond which we don't venture into a structure. Has no effect when &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; is set. (Useful in debugger when we often don't want to see more than enough). Default is 0, which means there is no maximum depth.</source>
          <target state="translated">可以设置为一个正整数，该整数指定我们不冒险进入结构的深度。设置 &lt;code&gt;Data::Dumper::Purity&lt;/code&gt; 时不起作用。（当我们经常不想看到足够多的内容时，在调试器中很有用）。默认值为0，表示没有最大深度。</target>
        </trans-unit>
        <trans-unit id="1b8ab4925558b8a13bc55bec7e3f47e1da66a3e2" translate="yes" xml:space="preserve">
          <source>Can be set to a regular expression. Only files with names that match the expression will be read.</source>
          <target state="translated">可以设置为正则表达式。只有名称符合表达式的文件才会被读取。</target>
        </trans-unit>
        <trans-unit id="b4c1fc7bc4091447e126bb9cbc6311ac8f682f2f" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies an alternative to the &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; builtin operator used to create objects. A function with the specified name should exist, and should accept the same arguments as the builtin. Default is &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以设置为字符串，该字符串指定用于创建对象的 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 内置运算符的替代形式。具有指定名称的函数应该存在，并且应接受与内置函数相同的参数。默认为 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a994c4b88b43caa5b752fd46ef7324627d9d83c6" translate="yes" xml:space="preserve">
          <source>Can be set to a string that specifies the separator between hash keys and values. To dump nested hash, array and scalar values to JavaScript, use: &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; . Implementing &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; in JavaScript is left as an exercise for the reader. A function with the specified name exists, and accepts the same arguments as the builtin.</source>
          <target state="translated">可以设置为字符串，该字符串指定哈希键和值之间的分隔符。要将嵌套的哈希，数组和标量值转储到JavaScript，请使用： &lt;code&gt;$Data::Dumper::Pair = ' : ';&lt;/code&gt; 。留给JavaScript 实施 &lt;code&gt;&lt;a href=&quot;../functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 作为练习。存在具有指定名称的函数，并且该函数接受与内置函数相同的参数。</target>
        </trans-unit>
        <trans-unit id="9e933a47e6aaf6dd73210fa86f1269378f8318bc" translate="yes" xml:space="preserve">
          <source>Can be trimmed if you compile for one access method.</source>
          <target state="translated">如果你为一种访问方法编译,可以进行裁剪。</target>
        </trans-unit>
        <trans-unit id="717d201646a10747b3a920b5eaa1592483e5445b" translate="yes" xml:space="preserve">
          <source>Can call croak() if an error occurs.</source>
          <target state="translated">如果发生错误,可以调用croak()。</target>
        </trans-unit>
        <trans-unit id="610ece97ddb84d598c6d8556f131f1844efd48bc" translate="yes" xml:space="preserve">
          <source>Can call croak() if there is a security anomaly during the stat() comparison.</source>
          <target state="translated">如果在stat()比较过程中出现安全异常,可以调用croak()。</target>
        </trans-unit>
        <trans-unit id="512d893f80ec4605f408cd9d8d3b090f641b1bc5" translate="yes" xml:space="preserve">
          <source>Can only be applied to process handles returned for processes spawned using &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; or pseudo processes created with &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. (Win32)</source>
          <target state="translated">仅适用于使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, ...)&lt;/code&gt; 生成的进程或使用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 创建的伪进程返回的进程句柄。（Win32的）</target>
        </trans-unit>
        <trans-unit id="acc17adc87dae58e0d71e7b8a46715c51db69dd0" translate="yes" xml:space="preserve">
          <source>Can use any of the methods described above but for further customization one needs to override some of the methods:</source>
          <target state="translated">可以使用上述任何一种方法,但如果要进一步定制,需要覆盖一些方法。</target>
        </trans-unit>
        <trans-unit id="6e5e0a8f8265c585a4f386242ed86595f0f740c3" translate="yes" xml:space="preserve">
          <source>Can we do the same with an XSUB</source>
          <target state="translated">我们可以用XSUB做同样的事情吗?</target>
        </trans-unit>
        <trans-unit id="d71b162349ad8d3cc1b62ad26a21aad2924ff2d2" translate="yes" xml:space="preserve">
          <source>Can't move directories between directories on different logical volumes. (Win32)</source>
          <target state="translated">无法在不同逻辑卷上的目录之间移动目录。(Win32)</target>
        </trans-unit>
        <trans-unit id="d5c61e930ba2ace5562dbc01d87ff2dccd871bad" translate="yes" xml:space="preserve">
          <source>Cancel output to the file handle. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">取消输出到文件句柄。 &lt;code&gt;$parser&lt;/code&gt; 读取的任何POD 均不受影响。</target>
        </trans-unit>
        <trans-unit id="56c9d54018682f033ce26d5d28cbd53bef40aa76" translate="yes" xml:space="preserve">
          <source>Cancel output to the output string. Any POD read by the &lt;code&gt;$parser&lt;/code&gt; is not effected.</source>
          <target state="translated">取消输出到输出字符串。 &lt;code&gt;$parser&lt;/code&gt; 读取的任何POD 均不受影响。</target>
        </trans-unit>
        <trans-unit id="cf5ab48928c6227aa52c3d012c2701389449d7d8" translate="yes" xml:space="preserve">
          <source>Canned Filters</source>
          <target state="translated">罐装过滤器</target>
        </trans-unit>
        <trans-unit id="1bbd1f5144cc25ff3e79e713323aaa5805fc1bb3" translate="yes" xml:space="preserve">
          <source>Cannot start &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt;</source>
          <target state="translated">无法启动 &lt;code&gt;find.exe &quot;pattern&quot; file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f9378da13e876924853515ac330a0589ab874eb" translate="yes" xml:space="preserve">
          <source>Cannot start find.exe &quot;pattern&quot; file</source>
          <target state="translated">无法启动find.exe &quot;模式 &quot;文件。</target>
        </trans-unit>
        <trans-unit id="07f4ae991f88e569288a303eea482424b54e133d" translate="yes" xml:space="preserve">
          <source>Canonical Equivalence in Applications - UTN #5</source>
          <target state="translated">应用中的正则等价-UTN #5</target>
        </trans-unit>
        <trans-unit id="b8dabeba508ec88a0783430634fb6a91f3d06c7d" translate="yes" xml:space="preserve">
          <source>Canonical order does not imply network order; those are two orthogonal settings.</source>
          <target state="translated">规范顺序并不意味着网络顺序,那是两个正交的设置。</target>
        </trans-unit>
        <trans-unit id="747ae3c9036b2b9d0c1bdc3f6a1c392c7794eed3" translate="yes" xml:space="preserve">
          <source>Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.) You can refer to them by absolute number (using &lt;code&gt;&quot;$1&quot;&lt;/code&gt; instead of &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , etc); or by name via the &lt;code&gt;%+&lt;/code&gt; hash, using &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt;.</source>
          <target state="translated">捕获组的内容是动态范围内的，并在模式之外可供您使用，直到封闭块结束或下一次成功匹配为止，以先到者为准。（请参阅&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn中的复合语句&lt;/a&gt;。）您可以按绝对数字引用它们（使用 &lt;code&gt;&quot;$1&quot;&lt;/code&gt; 代替 &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 等）；或通过 &lt;code&gt;%+&lt;/code&gt; 散列使​​用 &lt;code&gt;&quot;$+{&lt;i&gt;name&lt;/i&gt;}&quot;&lt;/code&gt; ，使用&amp;ldquo; $ + { &lt;i&gt;name&lt;/i&gt; }&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="311dff8ce71dc0b4b0666e7280ad010d93e7918a" translate="yes" xml:space="preserve">
          <source>Capture groups</source>
          <target state="translated">捕获组</target>
        </trans-unit>
        <trans-unit id="17d5baafa6da919c16c090df56e9fd9d7a565715" translate="yes" xml:space="preserve">
          <source>Capture groups are numbered from left to right, but inside this construct the numbering is restarted for each branch.</source>
          <target state="translated">采集组从左到右编号,但在这个构造里面,每个分支的编号都是重新开始的。</target>
        </trans-unit>
        <trans-unit id="ee0771c31053343949dda6efc584e44e5297b9a9" translate="yes" xml:space="preserve">
          <source>Captured groups are numbered according to their</source>
          <target state="translated">捕获的组别按其编号</target>
        </trans-unit>
        <trans-unit id="f7b4920b8aa7c1586544c28d9c8886e52d98ca56" translate="yes" xml:space="preserve">
          <source>Capturing parenthesis that work just like perl</source>
          <target state="translated">捕捉小括号,就像perl一样工作。</target>
        </trans-unit>
        <trans-unit id="4ea8cbac41ff9a96e8d9db8e075354ecd6a9f99e" translate="yes" xml:space="preserve">
          <source>Care must be taken when making changes to make sure that you handle UTF-8 properly, both at compile time and at execution time, including when the string and pattern are mismatched.</source>
          <target state="translated">在进行修改时必须注意确保正确处理UTF-8,无论是在编译时还是在执行时,包括字符串和模式不匹配时。</target>
        </trans-unit>
        <trans-unit id="04617e457add86a7b016a256cae6724b67e05962" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">应谨慎使用时，应考虑 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 的形式 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 。它是</target>
        </trans-unit>
        <trans-unit id="f12898eb208465f617f9b5c3dd913e72b7c63a92" translate="yes" xml:space="preserve">
          <source>Care should be taken when using the &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. It is</source>
          <target state="translated">应谨慎使用时，应考虑 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 的形式 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 。它是</target>
        </trans-unit>
        <trans-unit id="d00ed6d0c5ac45de00f179782815edeefadfc67b" translate="yes" xml:space="preserve">
          <source>Carp</source>
          <target state="translated">Carp</target>
        </trans-unit>
        <trans-unit id="d88a6c87d4e1376b298c703f4fc38df13d24c117" translate="yes" xml:space="preserve">
          <source>Carp - alternative warn and die for modules</source>
          <target state="translated">鲤鱼 ----模块的替代警告和死亡</target>
        </trans-unit>
        <trans-unit id="4cac758eff9ae8b1951cfa88daf6efd8e4c9f9dd" translate="yes" xml:space="preserve">
          <source>Carp gives two ways to control this.</source>
          <target state="translated">鲤鱼给出了两种控制方式。</target>
        </trans-unit>
        <trans-unit id="bca0e3c0ab768e90d91b7158f9afa5173ab39d46" translate="yes" xml:space="preserve">
          <source>Case 2 is also deceptive in that you're accessing a variable called %hashref, not dereferencing through $hashref to the hash it's presumably referencing. That would be case 3.</source>
          <target state="translated">情况2也是有欺骗性的,因为你访问的是一个叫做%hashref的变量,而不是通过$hashref去引用它可能引用的哈希值。那就是情况3了。</target>
        </trans-unit>
        <trans-unit id="298d6337ccd66315823554fe2294fb2258cef971" translate="yes" xml:space="preserve">
          <source>Case Mappings/SpecialCasing</source>
          <target state="translated">Case Mappings/SpecialCasing</target>
        </trans-unit>
        <trans-unit id="12c50192a130e9814d8ea8606bd466ad9981e92e" translate="yes" xml:space="preserve">
          <source>Case and abbreviations</source>
          <target state="translated">大小写和缩略语</target>
        </trans-unit>
        <trans-unit id="71820be5979516bbf68abefb91861f6a5f447350" translate="yes" xml:space="preserve">
          <source>Case translation operators use the Unicode case translation tables.</source>
          <target state="translated">大小写翻译操作员使用Unicode大小写翻译表。</target>
        </trans-unit>
        <trans-unit id="9fc0b2fddd3396951a95310fbd8003b367dba5dd" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input parameters (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">在输入参数中将忽略大小写，空格，连字符和下划线（在老式的，以老式形式存在的常规类别属性值 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; _ &amp;rdquo;（最好写为 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ）中，尾随下划线除外）。</target>
        </trans-unit>
        <trans-unit id="9c97ea35c0c010d6bc3fa3e2766ca1eeed20cb95" translate="yes" xml:space="preserve">
          <source>Case, white space, hyphens, and underscores are ignored in the input property name (except for the trailing underscore in the old-form grandfathered-in general category property value &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ).</source>
          <target state="translated">在输入属性名称中将忽略大小写，空格，连字符和下划线（在老式的，以老式形式存在的常规类别属性值 &lt;code&gt;&quot;L_&quot;&lt;/code&gt; ，尾随下划线除外，最好将其写为 &lt;code&gt;&quot;LC&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5913a3e508c3f58147c3a7ea4922d97aeb2d10bc" translate="yes" xml:space="preserve">
          <source>Casefolding is the process of mapping strings to a form where case differences are erased; comparing two strings in their casefolded form is effectively a way of asking if two strings are equal, regardless of case.</source>
          <target state="translated">大小写折叠是将字符串映射到一个消除大小写差异的形式的过程;比较两个字符串的大小写形式实际上是询问两个字符串是否相等的一种方式,而不管大小写。</target>
        </trans-unit>
        <trans-unit id="3efae3773aea3e6418118bae37722e49dd2d43fd" translate="yes" xml:space="preserve">
          <source>Cases 1 and 2 above behave identically: they run the code contained in the variable $x. (Although case 2 has misleading double quotes making the reader wonder what else might be happening (nothing is).) Cases 3 and 4 likewise behave in the same way: they run the code &lt;code&gt;'$x'&lt;/code&gt; , which does nothing but return the value of $x. (Case 4 is preferred for purely visual reasons, but it also has the advantage of compiling at compile-time instead of at run-time.) Case 5 is a place where normally you</source>
          <target state="translated">上面的情况1和2的行为相同：它们运行变量$ x中包含的代码。（尽管情况2带有误导性的双引号，使读者想知道还会发生什么（什么都没发生。）情况3和4同样以相同的方式运行：它们运行代码 &lt;code&gt;'$x'&lt;/code&gt; ，除了返回值外，它什么也不做$ x。（出于纯粹的视觉原因，首选案例4，但也具有在编译时而不是在运行时进行编译的优势。）案例5是通常您需要在其中放置代码的地方。</target>
        </trans-unit>
        <trans-unit id="fce28c3834b46c5817fa1ba652ddba28baf2570f" translate="yes" xml:space="preserve">
          <source>Casting between function pointers and data pointers</source>
          <target state="translated">在函数指针和数据指针之间进行转换。</target>
        </trans-unit>
        <trans-unit id="6f9e423b5bc8680aa5b16ed1908f25312d66ad7e" translate="yes" xml:space="preserve">
          <source>Casting pointers to integers or casting integers to pointers</source>
          <target state="translated">将指针投向整数或将整数投向指针。</target>
        </trans-unit>
        <trans-unit id="499253af5f67ae889bc3aabf24d35d8ba82de0e2" translate="yes" xml:space="preserve">
          <source>Casts I to the internal I32 type used by that perl.</source>
          <target state="translated">将I转为该perl使用的内部I32类型。</target>
        </trans-unit>
        <trans-unit id="c174d6be41280356a91ddfdde65f079878120639" translate="yes" xml:space="preserve">
          <source>Catch stopped child processes.</source>
          <target state="translated">抓住停止的子进程。</target>
        </trans-unit>
        <trans-unit id="c2d335ad7e81fdf6a55a7304c8fd31f60f0fc162" translate="yes" xml:space="preserve">
          <source>Catchall routine to clean up problem MM[SK]/Make macros. Expands macros in any directory specification, in order to avoid juxtaposing two VMS-syntax directories when MM[SK] is run. Also expands expressions which are all macro, so that we can tell how long the expansion is, and avoid overrunning DCL's command buffer when MM[KS] is running.</source>
          <target state="translated">清理MM[SK]/Make宏问题的Catchall例程。扩充任意目录规格的宏,以避免MM[SK]运行时将两个VMS语法目录并列。还可以扩展都是宏的表达式,这样我们就可以知道扩展的时间有多长,避免在MM[KS]运行时占用DCL的命令缓冲区。</target>
        </trans-unit>
        <trans-unit id="6b5024a9f7f3c46574351ad45dcdeceef2016767" translate="yes" xml:space="preserve">
          <source>Categories of modules range from text manipulation to network protocols to database integration to graphics. A categorized list of modules is also available from CPAN.</source>
          <target state="translated">模块的类别从文本处理到网络协议、数据库集成到图形。CPAN还提供了一个分类的模块清单。</target>
        </trans-unit>
        <trans-unit id="337a8f7bd3bdbf4fe42f0b9d4b42a95657d8e9f9" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_COLLATE&lt;/code&gt; : Collation</source>
          <target state="translated">类别 &lt;code&gt;LC_COLLATE&lt;/code&gt; ：整理</target>
        </trans-unit>
        <trans-unit id="beec9c5a8a3b1200e13a31c08cab20f387038371" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_CTYPE&lt;/code&gt; : Character Types</source>
          <target state="translated">类别 &lt;code&gt;LC_CTYPE&lt;/code&gt; ：字符类型</target>
        </trans-unit>
        <trans-unit id="38233af031be21177bea3a81f92c8363621b4861" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_MONETARY&lt;/code&gt; : Formatting of monetary amounts</source>
          <target state="translated">类别 &lt;code&gt;LC_MONETARY&lt;/code&gt; ：货币格式</target>
        </trans-unit>
        <trans-unit id="19550402e5a1f045b848054b7a9e298b524aa833" translate="yes" xml:space="preserve">
          <source>Category &lt;code&gt;LC_NUMERIC&lt;/code&gt; : Numeric Formatting</source>
          <target state="translated">类别 &lt;code&gt;LC_NUMERIC&lt;/code&gt; ：数字格式</target>
        </trans-unit>
        <trans-unit id="d6caa2ce2c0ba347d49ead269d4ac916346dc572" translate="yes" xml:space="preserve">
          <source>Category Hierarchy</source>
          <target state="translated">类别层次结构</target>
        </trans-unit>
        <trans-unit id="ad6f8c0088808eee492b45306c0d1b94608c6f08" translate="yes" xml:space="preserve">
          <source>Category LC_COLLATE: Collation</source>
          <target state="translated">类别LC_COLLATE。整理</target>
        </trans-unit>
        <trans-unit id="a51fd3f6ab56831c7fdec8dd63db4d84c5e5ddfb" translate="yes" xml:space="preserve">
          <source>Category LC_CTYPE: Character Types</source>
          <target state="translated">类别 LC_CTYPE。字符类型</target>
        </trans-unit>
        <trans-unit id="7682ad4955d10f9cf4cc9354213c179454f72007" translate="yes" xml:space="preserve">
          <source>Category LC_MONETARY: Formatting of monetary amounts</source>
          <target state="translated">类别 LC_MONETARY:货币金额的格式化。</target>
        </trans-unit>
        <trans-unit id="07571e7937ae3f96671e4cd556a4abc903111a57" translate="yes" xml:space="preserve">
          <source>Category LC_NUMERIC: Numeric Formatting</source>
          <target state="translated">类别 LC_NUMERIC:数字格式化</target>
        </trans-unit>
        <trans-unit id="85dc017dda24f39d24e2b45c927b49e37ad2e173" translate="yes" xml:space="preserve">
          <source>Causes symbolic links to be followed. Since directory trees with symbolic links (followed) may contain files more than once and may even have cycles, a hash has to be built up with an entry for each file. This might be expensive both in space and time for a large directory tree. See &lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt; and &lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt; below. If either</source>
          <target state="translated">导致遵循符号链接。由于带有符号链接（后接）的目录树可能包含多个文件，甚至可能包含循环，因此必须为每个文件建立一个带有条目的哈希。对于大型目录树而言，这在空间和时间上可能都是昂贵的。请参阅下面的&lt;a href=&quot;#follow_fast&quot;&gt;follow_fast&lt;/a&gt;和&lt;a href=&quot;#follow_skip&quot;&gt;follow_skip&lt;/a&gt;。如果有</target>
        </trans-unit>
        <trans-unit id="d8a6af2ce96fea0e83364432bebd24ee2a299a63" translate="yes" xml:space="preserve">
          <source>Causes the script to sleep for (integer) EXPR seconds, or forever if no argument is given. Returns the integer number of seconds actually slept.</source>
          <target state="translated">使脚本休眠(整数)EXPR秒,如果没有给定参数,则永远休眠。返回实际睡眠的整数秒数。</target>
        </trans-unit>
        <trans-unit id="adc5b4e7301cfc17b319d4424a90aed30a644658" translate="yes" xml:space="preserve">
          <source>Causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">使该模块使用Time::HiRes模块,允许后续调用ping()返回毫秒数。</target>
        </trans-unit>
        <trans-unit id="37cbf6da85f81293291a3c0f70bd83d035bcf72f" translate="yes" xml:space="preserve">
          <source>Causing infinite loops etc.</source>
          <target state="translated">造成无限循环等。</target>
        </trans-unit>
        <trans-unit id="b643ecf0f138f7f21c8987e5e43245e6d526028e" translate="yes" xml:space="preserve">
          <source>Causing signals (especially SIGFPE and SIGALARM) to affect your process.</source>
          <target state="translated">导致信号(特别是SIGFPE和SIGALARM)影响你的进程。</target>
        </trans-unit>
        <trans-unit id="f78acd3020c7919c3876959d6358cd31ff6af003" translate="yes" xml:space="preserve">
          <source>Caution : use this option only if you know that your coderefs will be properly reconstructed by &lt;code&gt;B::Deparse&lt;/code&gt; .</source>
          <target state="translated">警告：仅当您知道 &lt;code&gt;B::Deparse&lt;/code&gt; 将正确重构您的代码引用时，才使用此选项。</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="6c45fe1a67bfe92ba6c4b2119ad5a8061d201ed7" translate="yes" xml:space="preserve">
          <source>Caveat: this is a bit of a kludge. In particular note that if anything that appears on STDERR looks like a test result the test harness will get confused. Use this option only if you understand the consequences and can live with the risk.</source>
          <target state="translated">注意:这有点笨手笨脚。特别要注意的是,如果STDERR上出现的任何东西看起来像测试结果,测试线束就会感到困惑。只有在您了解后果并能承受风险的情况下才使用该选项。</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="ff751acd8ebba60eb35fa0124046207c1b17cdf6" translate="yes" xml:space="preserve">
          <source>Caveats mentioned in the description of &lt;code&gt;$!&lt;/code&gt; generally apply to &lt;code&gt;$^E&lt;/code&gt; , also.</source>
          <target state="translated">注意事项中提到的 &lt;code&gt;$!&lt;/code&gt; 一般适用于 &lt;code&gt;$^E&lt;/code&gt; ，也。</target>
        </trans-unit>
        <trans-unit id="2480f4a426ee72a3f6daf975f41b3976cd3d2933" translate="yes" xml:space="preserve">
          <source>Caveats:</source>
          <target state="translated">Caveats:</target>
        </trans-unit>
        <trans-unit id="f904f3f198a1560f6503e45c25c6ea2281d83a7a" translate="yes" xml:space="preserve">
          <source>Central America</source>
          <target state="translated">中美洲</target>
        </trans-unit>
        <trans-unit id="09fe478d9ba3d71f7c5e36ee02ee955b6c719e87" translate="yes" xml:space="preserve">
          <source>Centralized management of resources</source>
          <target state="translated">资源的集中管理</target>
        </trans-unit>
        <trans-unit id="e7fb0f6eb972f6f903d5d8421fe8c063e2da1bee" translate="yes" xml:space="preserve">
          <source>Cerebral C and C++ programmers should take note of the following:</source>
          <target state="translated">脑洞大开的C和C++程序员应该注意以下几点。</target>
        </trans-unit>
        <trans-unit id="098ac784d3c3bb2be5336c055d431de5a978080e" translate="yes" xml:space="preserve">
          <source>Certain Perl operations that are set-up within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; retain that effect even outside the scope. These include:</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 范围内设置的某些Perl操作即使在范围之外也可以保持这种效果。这些包括：</target>
        </trans-unit>
        <trans-unit id="e445bdfbac84e85f57db984a7caae903e4414a5a" translate="yes" xml:space="preserve">
          <source>Certain SV types are considered 'special'. They're represented by B::SPECIAL and are referred to by a number from the specialsv_list. This array maps that number back to the name of the SV (like 'Nullsv' or '&amp;amp;PL_sv_undef').</source>
          <target state="translated">某些SV类型被视为&amp;ldquo;特殊&amp;rdquo;。它们由B :: SPECIAL表示，并由specialsv_list中的数字引用。该数组将该数字映射回SV的名称（例如'Nullsv'或'＆PL_sv_undef'）。</target>
        </trans-unit>
        <trans-unit id="8edd6c5378e389e68c51d5a29d8332712fb8e453" translate="yes" xml:space="preserve">
          <source>Certain Win32 programs called from cygwin programs might need some environment variable, such as e.g. ADODB needs %COMMONPROGRAMFILES%. Call Cygwin::sync_winenv() to copy all Win32 environment variables to your process and note that cygwin will warn on every encounter of non-POSIX paths.</source>
          <target state="translated">某些从cygwin程序中调用的Win32程序可能需要一些环境变量,例如:ADODB需要%COMMONPROGRAMFILES%。调用Cygwin::sync_winenv()将所有的Win32环境变量复制到你的进程中,注意,每遇到非POSIX路径,cygwin都会发出警告。</target>
        </trans-unit>
        <trans-unit id="0c5660d59e9ee01e56352c20048bf93f027e41cc" translate="yes" xml:space="preserve">
          <source>Certain built-in Unix features help prevent this most of the time. For instance, filehandles have a &quot;close on exec&quot; flag, which is set</source>
          <target state="translated">某些内置的Unix特性在大多数情况下有助于防止这种情况的发生。例如,文件柄有一个 &quot;close on exec &quot;标志,它被设置为</target>
        </trans-unit>
        <trans-unit id="fd014b85703f4f23ce05ad07fc9ca7afcd931605" translate="yes" xml:space="preserve">
          <source>Certain code points are considered problematic. These are Unicode surrogates, Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF. By default these are considered regular code points, but certain situations warrant special handling for them. If &lt;code&gt;flags&lt;/code&gt; contains UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as malformations and handled as such. The flags UTF8_DISALLOW_SURROGATE, UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal Unicode maximum) can be set to disallow these categories individually.</source>
          <target state="translated">某些代码点被认为是有问题的。这些是Unicode替代，Unicode非字符和高于Unicode最大值0x10FFFF的代码点。默认情况下，这些被视为常规代码点，但是在某些情况下需要对其进行特殊处理。如果 &lt;code&gt;flags&lt;/code&gt; 包含UTF8_DISALLOW_ILLEGAL_INTERCHANGE，则所有这三个类都将被视为格式错误并按此类进行处理。可以将标志UTF8_DISALLOW_SURROGATE，UTF8_DISALLOW_NONCHAR和UTF8_DISALLOW_SUPER（表示在合法的Unicode最大值之上）设置为单独禁止这些类别。</target>
        </trans-unit>
        <trans-unit id="b02926fb30feba66eb4b4ce45a0942f1b38d9143" translate="yes" xml:space="preserve">
          <source>Certain file systems have a limited ability to store the times on a file at the expected level of precision. For example, the FAT and HPFS filesystem are unable to create dates on files with a finer granularity than two seconds. This is a limitation of the filesystems, not of utime().</source>
          <target state="translated">某些文件系统在文件上存储时间的能力有限,无法达到预期的精确程度。例如,FAT 和 HPFS 文件系统无法在文件上创建比两秒更精确的日期。这是文件系统的限制,而不是 utime()的限制。</target>
        </trans-unit>
        <trans-unit id="37d5dc51bb3f3e8f5f3c6c97dff5e509bb4e1f21" translate="yes" xml:space="preserve">
          <source>Certain glyph variations for character display are standardized. This lists the non-Unihan ones; the Unihan ones are also not used by Perl, and are in a separate Unicode data base &lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</source>
          <target state="translated">用于字符显示的某些字形变化已标准化。这列出了非Unihan的；Perl也不使用Unihan，而是在单独的Unicode数据库中&lt;a href=&quot;http://www.unicode.org/ivd&quot;&gt;http://www.unicode.org/ivd&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0b6cb7913f706e7a5eacb52a20195ab75fdb53c" translate="yes" xml:space="preserve">
          <source>Certain internal algorithms used in the implementation of Perl can be attacked by choosing the input carefully to consume large amounts of either time or space or both. This can lead into the so-called</source>
          <target state="translated">在Perl的实现中使用的某些内部算法可以通过仔细选择输入来攻击,以消耗大量的时间或空间,或者两者兼而有之。这可能导致进入所谓的</target>
        </trans-unit>
        <trans-unit id="96a386c331a35cc383e0fb0a983cc8532170d5c8" translate="yes" xml:space="preserve">
          <source>Certain internal hooks can be also set using the &lt;code&gt;%SIG&lt;/code&gt; hash. The routine indicated by &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; is called when a warning message is about to be printed. The warning message is passed as the first argument. The presence of a &lt;code&gt;__WARN__&lt;/code&gt; hook causes the ordinary printing of warnings to &lt;code&gt;STDERR&lt;/code&gt; to be suppressed. You can use this to save warnings in a variable, or turn warnings into fatal errors, like this:</source>
          <target state="translated">某些内部挂钩也可以使用 &lt;code&gt;%SIG&lt;/code&gt; 哈希设置。当要打印警告消息时，将调用 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 指示的例程。警告消息作为第一个参数传递。 &lt;code&gt;__WARN__&lt;/code&gt; 挂钩的存在导致禁止向 &lt;code&gt;STDERR&lt;/code&gt; 常规打印警告。您可以使用此命令将警告保存在变量中，或将警告变成致命错误，如下所示：</target>
        </trans-unit>
        <trans-unit id="b64cf21b984a47fe95b3c69dcb71d4d0db67b02a" translate="yes" xml:space="preserve">
          <source>Certain properties are accessible also via core function calls. These are:</source>
          <target state="translated">某些属性也可以通过核心函数调用访问。这些属性是:</target>
        </trans-unit>
        <trans-unit id="d27dc694c4a5fbe7b1d7b9b68b009abd079b8811" translate="yes" xml:space="preserve">
          <source>Certain signals like SEGV, ILL, and BUS are generated by virtual memory addressing errors and similar &quot;faults&quot;. These are normally fatal: there is little a Perl-level handler can do with them. So Perl delivers them immediately rather than attempting to defer them.</source>
          <target state="translated">某些信号,如SEGV、ILL和BUS,是由虚拟内存寻址错误和类似的 &quot;故障 &quot;产生的。这些信号通常是致命的:Perl 级别的处理程序对它们几乎无能为力。所以Perl会立即提供这些信号,而不是试图推迟它们。</target>
        </trans-unit>
        <trans-unit id="536f525355145c06eb27b43dd05eceed140e4f71" translate="yes" xml:space="preserve">
          <source>Cf. &lt;a href=&quot;#Prerequisites&quot;&gt;Prerequisites&lt;/a&gt;.</source>
          <target state="translated">cf. &lt;a href=&quot;#Prerequisites&quot;&gt;先决条件&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33b90248a63c8f592d9dd961a96f1170c6b169a4" translate="yes" xml:space="preserve">
          <source>Ch. 15 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">频道 15 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 由Larry Wall，汤姆&amp;middot;克里斯蒂安森，则被Jon Orwant; O'Reilly＆Associates; 书号0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="9fe7a1219b8f1fb95786f557bb47edce5064d4db" translate="yes" xml:space="preserve">
          <source>Ch. 15, pp. 403 of &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp;amp; Associates; ISBN 0-596-00027-8</source>
          <target state="translated">频道 Larry Wall，Tom Christiansen，Jon Orwant的《 &lt;code&gt;Programming Perl (3rd Edition)&lt;/code&gt; 第15页第403页；O'Reilly＆Associates; 书号0-596-00027-8</target>
        </trans-unit>
        <trans-unit id="d493056c1da57a03b23c818e0ed106583a75e9df" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for meta data about the source. This defaults to an empty hashref. See &lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt; for more info.</source>
          <target state="translated">链接获取器/设置器以获取有关源的元数据。默认为空的hashref。有关更多信息，请参见&lt;a href=&quot;#assemble_meta&quot;&gt;assemble_meta&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d37cf9e27bcdb9224f76d171f3ec04e137833197" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the configuration of the available source handlers. This is a hashref keyed on handler class whose values contain config to be passed onto the handlers during detection &amp;amp; creation. Class names may be fully qualified or abbreviated, eg:</source>
          <target state="translated">链接getter / setter以配置可用的源处理程序。这是一个键入在处理程序类上的hashref，该哈希值的值包含要在检测和创建过程中传递给处理程序的config。类名可以完全限定或缩写，例如：</target>
        </trans-unit>
        <trans-unit id="b8e3ffd2df81751de57a2fcbade1ad6be4b71309" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the flag that dictates whether STDOUT and STDERR should be merged (where appropriate). Defaults to undef.</source>
          <target state="translated">链式获取器/设置器,用于决定是否合并STDOUT和STDERR的标志。默认值为undef。</target>
        </trans-unit>
        <trans-unit id="fa3fa390f5b11b8da2cbd991e38fe6758bc14f24" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line arguments that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">链式getter/setter,用于传递给源的命令行参数列表(如果合适)。默认值为undef。</target>
        </trans-unit>
        <trans-unit id="6875662647c6f1815155ad787b4b2ddda071cbb4" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the list of command-line switches that should be passed to the source (where appropriate). Defaults to undef.</source>
          <target state="translated">链式获取器/设置器,用于获取应传递给源的命令行开关列表(如果合适)。默认值为undef。</target>
        </trans-unit>
        <trans-unit id="484c910049e12d13347861a5be23f00c8321a0d6" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the raw TAP source. This is a reference, as it may contain large amounts of data (eg: raw TAP).</source>
          <target state="translated">原始TAP源的链式获取器/设置器。这是一个参考,因为它可能包含大量的数据(例如:原始TAP)。</target>
        </trans-unit>
        <trans-unit id="74174c42fd62072d6ee5d0a7398fa78f44559dff" translate="yes" xml:space="preserve">
          <source>Chaining getter/setter for the source's configuration, if any has been provided by the user. How it's used is up to you. This defaults to an empty hashref. See &lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt; for more info.</source>
          <target state="translated">如果源提供了配置，则链接源的getter / setter。如何使用取决于您。默认为空的hashref。有关更多信息，请参见&lt;a href=&quot;#config_for&quot;&gt;config_for&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="930947c88d29b6f085064df238c19e6c783d2627" translate="yes" xml:space="preserve">
          <source>Change and/or examine calling process's signal mask. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; and &lt;code&gt;oldsigset&lt;/code&gt; arguments. Consult your system's &lt;code&gt;sigprocmask&lt;/code&gt; manpage for details.</source>
          <target state="translated">更改和/或检查呼叫过程的信号掩码。它将 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 对象用于 &lt;code&gt;sigset&lt;/code&gt; 和 &lt;code&gt;oldsigset&lt;/code&gt; 参数。有关详细信息，请查阅系统的 &lt;code&gt;sigprocmask&lt;/code&gt; 手册页。</target>
        </trans-unit>
        <trans-unit id="47d396cd087a5a418e7353a4c45e6745ef5c9209" translate="yes" xml:space="preserve">
          <source>Change directory to /</source>
          <target state="translated">更改目录为/</target>
        </trans-unit>
        <trans-unit id="6b35e50e6231ecd47c51f9d0f60727b3553c64b4" translate="yes" xml:space="preserve">
          <source>Change directory to the parent of the current directory.</source>
          <target state="translated">将目录改为当前目录的父目录。</target>
        </trans-unit>
        <trans-unit id="6eba8b030681c63dbaca5c083fcb141f12c78bec" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode.</source>
          <target state="translated">将$file的模式改为$mode。</target>
        </trans-unit>
        <trans-unit id="61d995589ae611e0f4742d3a0cee92270e9ce91b" translate="yes" xml:space="preserve">
          <source>Change mode of $file to $mode. The mode can be a string or a number which is interpreted as octal whether or not a leading 0 is given.</source>
          <target state="translated">将$file的模式改为$mode。mode可以是字符串或数字,无论是否有前导0,都会被解释为八进制。</target>
        </trans-unit>
        <trans-unit id="3a726567b511b7efb1456c7410856f0769212a35" translate="yes" xml:space="preserve">
          <source>Change owner $file to $uname and $gname.</source>
          <target state="translated">将所有者$file改为$uname和$gname。</target>
        </trans-unit>
        <trans-unit id="c8ee54b2a4c58db1f595c468254073b721477b33" translate="yes" xml:space="preserve">
          <source>Change owner of $file to $user. If a $group is given that is changed as well. You can also pass a single parameter with a colon separating the use and group as in 'root:wheel'.</source>
          <target state="translated">将$file的所有者改为$user。如果给定了$group,也会被改变。你也可以像'root:wheel'那样,用冒号分隔使用和组,传递一个单一参数。</target>
        </trans-unit>
        <trans-unit id="aad1746f9b9be805d4a6fb33e7166d4914a6f334" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate object &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">更改deflate对象 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d7824dc2aeadd89378b9289a40f5baa46baf4c" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$d&lt;/code&gt; .</source>
          <target state="translated">更改放气流 &lt;code&gt;$d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11138eabf6401374fb6ae86928421d28ef54011" translate="yes" xml:space="preserve">
          <source>Change settings for the deflate stream &lt;code&gt;$gz&lt;/code&gt; .</source>
          <target state="translated">更改放气流 &lt;code&gt;$gz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc239982b98cfe5d4bf5a6e97925df8bb9b66869" translate="yes" xml:space="preserve">
          <source>Change style of array and hash dump. If true, short array may be printed on one line.</source>
          <target state="translated">改变数组和哈希转储的样式。如果为真,短数组可以打印在一行。</target>
        </trans-unit>
        <trans-unit id="fc31075534bc4e1f585b7495788835ad53a5ed8b" translate="yes" xml:space="preserve">
          <source>Change style of string dump. Default value of &lt;code&gt;tick&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; , one can enable either double-quotish dump, or single-quotish by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;. By default, characters with high bit set are printed</source>
          <target state="translated">更改字符串转储的样式。 &lt;code&gt;tick&lt;/code&gt; 的默认值是 &lt;code&gt;auto&lt;/code&gt; ，可以通过将其设置为 &lt;code&gt;&quot;&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 来启用双引号转储或单引号。默认情况下，会打印设置了高位的字符</target>
        </trans-unit>
        <trans-unit id="f62e18a300604c2d0b5ad8fe35bb69d2aa22ab89" translate="yes" xml:space="preserve">
          <source>Change the line reading:</source>
          <target state="translated">改变行读。</target>
        </trans-unit>
        <trans-unit id="0d5ba9e028e71b7c3b6cfe8c3482bc252c2e3c53" translate="yes" xml:space="preserve">
          <source>Change the size of code list window (default is 10 lines).</source>
          <target state="translated">改变代码列表窗口的大小(默认为10行)。</target>
        </trans-unit>
        <trans-unit id="569c8a1e53a15c2ffb329e7aa5e5500846bb9b87" translate="yes" xml:space="preserve">
          <source>Change the style of array and hash output. If &lt;code&gt;compactDump&lt;/code&gt; , short array may be printed on one line.</source>
          <target state="translated">更改数组和哈希输出的样式。如果为 &lt;code&gt;compactDump&lt;/code&gt; ，则短数组可以打印在一行上。</target>
        </trans-unit>
        <trans-unit id="1ddcd6267b5132268c1d3a6f92ad7c15283dd197" translate="yes" xml:space="preserve">
          <source>Change the style of string dump. The default value for &lt;code&gt;quote&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt; ; one can enable double-quotish or single-quotish format by setting it to &lt;code&gt;&quot;&lt;/code&gt; or &lt;code&gt;'&lt;/code&gt;, respectively. By default, characters with their high bit set are printed verbatim.</source>
          <target state="translated">更改字符串转储的样式。为默认值 &lt;code&gt;quote&lt;/code&gt; 为 &lt;code&gt;auto&lt;/code&gt; ; 可以通过将双引号或单引号格式分别设置为 &lt;code&gt;&quot;&lt;/code&gt; 或 &lt;code&gt;'&lt;/code&gt; 来启用双引号或单引号格式。默认情况下，逐字打印高位设置的字符。</target>
        </trans-unit>
        <trans-unit id="38de6175abf6da26b6853e84b1888d7d917d0994" translate="yes" xml:space="preserve">
          <source>Change this to</source>
          <target state="translated">改为</target>
        </trans-unit>
        <trans-unit id="0558571d851a8433aad3815610abfaf16dab150e" translate="yes" xml:space="preserve">
          <source>Change to an empty directory, and create a placeholder &amp;lt;Makefile.PL&amp;gt;:</source>
          <target state="translated">转到一个空目录，并创建一个占位符&amp;lt;Makefile.PL&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="bbbe466cbb3d9bd600f9492fe6485ab273c48d8c" translate="yes" xml:space="preserve">
          <source>Change to the &lt;code&gt;./pod&lt;/code&gt; directory of the build tree, download the Perl logo</source>
          <target state="translated">转到构建树的 &lt;code&gt;./pod&lt;/code&gt; 目录，下载Perl徽标</target>
        </trans-unit>
        <trans-unit id="862ce088bc8e3f533e4bd14af7a6130330f00504" translate="yes" xml:space="preserve">
          <source>Change to the directory of extraction.</source>
          <target state="translated">改为提取的目录。</target>
        </trans-unit>
        <trans-unit id="1a08104f60eb079d49d12cd925f4ebbd076f6abd" translate="yes" xml:space="preserve">
          <source>Change to the extension directory where its source files are present.</source>
          <target state="translated">改为其源文件所在的扩展目录。</target>
        </trans-unit>
        <trans-unit id="622a8441b6e400617adf70d8d715f1f671124897" translate="yes" xml:space="preserve">
          <source>Change to the installation directory (most probably ADE:), and extract the binary distribution:</source>
          <target state="translated">改为安装目录(最可能是ADE:),并解压二进制发行版。</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d82ce619d11521a894a962f613af5bfbbfd623ad" translate="yes" xml:space="preserve">
          <source>Changes / enhancements you plan to make in the future.</source>
          <target state="translated">您计划在未来做出的改变/改进。</target>
        </trans-unit>
        <trans-unit id="4371a5117e6fef40651394dbe58dc03dbb87745b" translate="yes" xml:space="preserve">
          <source>Changes EQUALIZE_TIMESTAMP to set revision date of target file to one second later than source file, since MMK interprets precisely equal revision dates for a source and target file as a sign that the target needs to be updated.</source>
          <target state="translated">修改了EQUALIZE_TIMESTAMP,将目标文件的修订日期设置为比源文件晚一秒,因为MMK将源文件和目标文件的修订日期精确相等解释为目标文件需要更新的标志。</target>
        </trans-unit>
        <trans-unit id="4d2ce6a709b5b2cac8d8c837247b977c30d65233" translate="yes" xml:space="preserve">
          <source>Changes are always applied directly to the main development branch, called &quot;blead&quot;. Some patches may be backported to a maintenance branch. If you think your patch is appropriate for the maintenance branch (see &lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;MAINTENANCE BRANCHES in perlpolicy&lt;/a&gt;), please explain why when you submit it.</source>
          <target state="translated">更改始终直接应用于主要开发分支，称为&amp;ldquo;缺陷&amp;rdquo;。某些补丁可能会反向移植到维护分支。如果您认为您的补丁程序适合于维护部门（请参见&lt;a href=&quot;perlpolicy#MAINTENANCE-BRANCHES&quot;&gt;perlolicy中的MAINTENANCE BRANCHES&lt;/a&gt;），请在提交时说明原因。</target>
        </trans-unit>
        <trans-unit id="1aa5832c7b70a5878149d5b5588b7d55b7c3bff5" translate="yes" xml:space="preserve">
          <source>Changes for h2xs as of Perl 5.8.x by Renee Baecker</source>
          <target state="translated">h2xs 在 Perl 5.8.x 时的变化,作者 Renee Baecker。</target>
        </trans-unit>
        <trans-unit id="62a553e5ccf5c46fdfc0ab8ea84db2a7f76cbebc" translate="yes" xml:space="preserve">
          <source>Changes how to run the linker.</source>
          <target state="translated">改变链接器的运行方式。</target>
        </trans-unit>
        <trans-unit id="f786f1f1a07415a1d8f2db0065ca900fcd53b8f6" translate="yes" xml:space="preserve">
          <source>Changes in code reference aliasing</source>
          <target state="translated">代码参考别名的变化</target>
        </trans-unit>
        <trans-unit id="be9cab3f4b47428605082907ec95e1b8c3df99df" translate="yes" xml:space="preserve">
          <source>Changes that might break existing code, either on the perl or C level</source>
          <target state="translated">可能会破坏现有代码的改动,无论是perl还是C语言层面的改动</target>
        </trans-unit>
        <trans-unit id="db0ec37c30cf600ec53fc96678818cec2782658c" translate="yes" xml:space="preserve">
          <source>Changes the access and modification times on each file of a list of files. The first two elements of the list must be the NUMERIC access and modification times, in that order. Returns the number of files successfully changed. The inode change time of each file is set to the current time. For example, this code has the same effect as the Unix touch(1) command when the files</source>
          <target state="translated">更改文件列表中每个文件的访问和修改时间。列表中的前两个元素必须是NUMERIC访问和修改时间,按顺序排列。返回成功修改的文件数。每个文件的inode修改时间设置为当前时间。例如,这段代码与Unix touch(1)命令的效果一样,当文件的</target>
        </trans-unit>
        <trans-unit id="4b4b4c86467333f8b7a7b80f4a01e7d1918a1a32" translate="yes" xml:space="preserve">
          <source>Changes the name of a file; an existing file NEWNAME will be clobbered. Returns true for success, false otherwise.</source>
          <target state="translated">更改文件名,现有文件NEWNAME将被删除。改名成功返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="e8b1fed7eb953f32d4b671261c0f298f432b77d6" translate="yes" xml:space="preserve">
          <source>Changes the owner (and group) of a list of files. The first two elements of the list must be the</source>
          <target state="translated">更改文件列表的所有者(和组)。列表中的前两个元素必须是</target>
        </trans-unit>
        <trans-unit id="1c7b4f13f0f9f250ad54a523828fe1dadc6bd8b6" translate="yes" xml:space="preserve">
          <source>Changes the path separator with .</source>
          <target state="translated">用.改变路径分隔符。</target>
        </trans-unit>
        <trans-unit id="2250a43272b4d912fcb35a54a90fbad3a0416b17" translate="yes" xml:space="preserve">
          <source>Changes the permissions of a list of files. The first element of the list must be the numeric mode, which should probably be an octal number, and which definitely should</source>
          <target state="translated">更改一个文件列表的权限。列表的第一个元素必须是数字模式,可能应该是一个八进制数,而且肯定应该是</target>
        </trans-unit>
        <trans-unit id="9bd248973528630e1bf213ec672fc9ef7ebeb306" translate="yes" xml:space="preserve">
          <source>Changes the style of printout of strings. Possible values are &lt;code&gt;unctrl&lt;/code&gt; and &lt;code&gt;quote&lt;/code&gt; .</source>
          <target state="translated">更改字符串打印输出的样式。可能的值为 &lt;code&gt;unctrl&lt;/code&gt; 和 &lt;code&gt;quote&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e08e00af7afee19133f68fcfa5c4f8c0f8fe0ac1" translate="yes" xml:space="preserve">
          <source>Changes the value of specified keys and returns the changed part.</source>
          <target state="translated">更改指定键的值并返回更改后的部分。</target>
        </trans-unit>
        <trans-unit id="3647bf8ac5df1429e21c0b23760ce2722ca59762" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果可能，将工作目录更改为EXPR。如果省略EXPR，则更改为 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 指定的目录（如果已设置）；如果不是， &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 指定的目录。（在VMS中，还检查了变量 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; ，如果设置了该变量，则使用该变量。）如果都未设置，则 &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 不执行任何操作。成功返回true，否则返回false。请参见 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 下的示例。</target>
        </trans-unit>
        <trans-unit id="f1086b5985822b0db7454ba706dee00d51c0ece8" translate="yes" xml:space="preserve">
          <source>Changes the working directory to EXPR, if possible. If EXPR is omitted, changes to the directory specified by &lt;code&gt;$ENV{HOME}&lt;/code&gt; , if set; if not, changes to the directory specified by &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; . (Under VMS, the variable &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; is also checked, and used if it is set.) If neither is set, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; does nothing. It returns true on success, false otherwise. See the example under &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果可能，将工作目录更改为EXPR。如果省略EXPR，则更改为 &lt;code&gt;$ENV{HOME}&lt;/code&gt; 指定的目录（如果已设置）；如果不是， &lt;code&gt;$ENV{LOGDIR}&lt;/code&gt; 指定的目录。（在VMS中，还检查了变量 &lt;code&gt;$ENV{SYS$LOGIN}&lt;/code&gt; ，如果设置了该变量，则使用该变量。）如果都未设置，则 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 不执行任何操作。成功返回true，否则返回false。请参见 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 下的示例。</target>
        </trans-unit>
        <trans-unit id="7fabf30bdd6213704e83eeade8922d6faf64b5fd" translate="yes" xml:space="preserve">
          <source>Changes to the array are reflected in the file immediately.</source>
          <target state="translated">数组的变化会立即反映在文件中。</target>
        </trans-unit>
        <trans-unit id="6803890e536e93e672442636eafadf71854a5e67" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution associated with this module has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">更改到与该模块相关的发行版已解压的目录,并在那里打开一个子shell。退出子shell会返回。</target>
        </trans-unit>
        <trans-unit id="e4202a82c344d58c60462a8105e61b62b6fab966" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and opens a subshell there. Exiting the subshell returns.</source>
          <target state="translated">更改到解压发行版的目录,并在那里打开一个子shell。退出子shell会返回。</target>
        </trans-unit>
        <trans-unit id="b8731050a8a7a9f8df1483a6a44fb58459c692c8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make clean&lt;/code&gt; there.</source>
          <target state="translated">更改其中分布拆封的目录，然后运行 &lt;code&gt;make clean&lt;/code&gt; 那里。</target>
        </trans-unit>
        <trans-unit id="2cf85dcec97c298d42a66cbcf92705947c20dbb8" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs &lt;code&gt;make test&lt;/code&gt; there.</source>
          <target state="translated">更改已解压缩发行版并运行的目录，然后在此处 &lt;code&gt;make test&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce66a23f208dbab005ac63aadf6ed1d3fdec95de" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs something like</source>
          <target state="translated">改为解压发行版所在的目录,并运行类似于</target>
        </trans-unit>
        <trans-unit id="936a954c5967e4fb0f809c16524179a6172e7265" translate="yes" xml:space="preserve">
          <source>Changes to the directory where the distribution has been unpacked and runs the external command &lt;code&gt;make install&lt;/code&gt; there. If &lt;code&gt;make&lt;/code&gt; has not yet been run, it will be run first. A &lt;code&gt;make test&lt;/code&gt; is issued in any case and if this fails, the install is cancelled. The cancellation can be avoided by letting &lt;code&gt;force&lt;/code&gt; run the &lt;code&gt;install&lt;/code&gt; for you.</source>
          <target state="translated">更改到已解压缩发行版并运行外部命令的目录，然后在此处 &lt;code&gt;make install&lt;/code&gt; 。如果尚未运行 &lt;code&gt;make&lt;/code&gt; ，它将首先运行。一个 &lt;code&gt;make test&lt;/code&gt; 是在任何情况下发布，如果失败，将被取消安装。可以通过 &lt;code&gt;force&lt;/code&gt; 为您运行 &lt;code&gt;install&lt;/code&gt; 来避免取消操作。</target>
        </trans-unit>
        <trans-unit id="3d3b3f1bc0445ad3c7b600875f43d2f0c065a2c3" translate="yes" xml:space="preserve">
          <source>Changing parts of a string via the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator. (We avoid use of this term to mean &lt;b&gt;variable interpolation&lt;/b&gt;.)</source>
          <target state="translated">通过 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 运算符更改字符串的一部分。（我们避免使用该术语来表示&lt;b&gt;变量插值&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="d7a71579d5e34f224f4b7a44cf8dcd2dbcaa9c26" translate="yes" xml:space="preserve">
          <source>Changing the BTREE sort order</source>
          <target state="translated">改变BTREE的排序顺序</target>
        </trans-unit>
        <trans-unit id="e17474358ec9689585fdd62efb80f2dbb797c7f5" translate="yes" xml:space="preserve">
          <source>Changing the case of a scalar, that is, using &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\l&lt;/code&gt; in double-quotish contexts, such as regular expression substitutions.</source>
          <target state="translated">更改标量的大小写，即在双引号上下文（例如正则表达式 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 使用uc（）， &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\L&lt;/code&gt; ， &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\l&lt;/code&gt; 替换。</target>
        </trans-unit>
        <trans-unit id="df6f7a30e2f621822d21b001b70407e472b19e52" translate="yes" xml:space="preserve">
          <source>Changing the program's locale should be avoided by XS code. Nevertheless, certain non-Perl libraries called from XS, such as &lt;code&gt;Gtk&lt;/code&gt; do so. When this happens, Perl needs to be told that the locale has changed. Use this function to do so, before returning to Perl.</source>
          <target state="translated">XS代码应避免更改程序的语言环境。尽管如此，某些从XS调用的非Perl库（例如 &lt;code&gt;Gtk&lt;/code&gt; )还是这样做。发生这种情况时，需要告知Perl语言环境已更改。返回Perl之前，请使用此功能。</target>
        </trans-unit>
        <trans-unit id="c8e1948c28b77c30e8fb57b5aff7a3dda34db561" translate="yes" xml:space="preserve">
          <source>Character Class Tests</source>
          <target state="translated">角色类测试</target>
        </trans-unit>
        <trans-unit id="09d5ec3fa8dfa6626f64711e08afb866161e2c4e" translate="yes" xml:space="preserve">
          <source>Character Classes and other Special Escapes</source>
          <target state="translated">角色类和其他特殊的逃生方式</target>
        </trans-unit>
        <trans-unit id="34a9fd5b966d1c074e2cee0432c22ae8d6ad1a1d" translate="yes" xml:space="preserve">
          <source>Character Data</source>
          <target state="translated">字符数据</target>
        </trans-unit>
        <trans-unit id="f710e107c2984efab355453a12a4c6ea080f5d29" translate="yes" xml:space="preserve">
          <source>Character Encoding Scheme</source>
          <target state="translated">字符编码方案</target>
        </trans-unit>
        <trans-unit id="4cf0ae92275a457503e6f1502570311bf8750725" translate="yes" xml:space="preserve">
          <source>Character Encodings for Input and Output</source>
          <target state="translated">输入和输出的字符编码</target>
        </trans-unit>
        <trans-unit id="20ec21ca7596ab8473642f9e0c8182b338e1d924" translate="yes" xml:space="preserve">
          <source>Character Escapes</source>
          <target state="translated">人物逃亡</target>
        </trans-unit>
        <trans-unit id="70a24f05bd3a1beeddb3d790c2d17711c420ebac" translate="yes" xml:space="preserve">
          <source>Character Ranges</source>
          <target state="translated">字符范围</target>
        </trans-unit>
        <trans-unit id="d2f44b6bf2d1636aa1643ea45ee60f381bdc2aa5" translate="yes" xml:space="preserve">
          <source>Character Ranges and Classes</source>
          <target state="translated">字符范围和类别</target>
        </trans-unit>
        <trans-unit id="def6212f0e6caec39a85ca7bef2c8e9c647d0bd2" translate="yes" xml:space="preserve">
          <source>Character and block devices. devmajor and devminor should specify the major and minor device numbers.</source>
          <target state="translated">devmajor和devminor应指定主要和次要器件的编号。</target>
        </trans-unit>
        <trans-unit id="fae5ab4ae64b19dd3884a0674108f420e439509e" translate="yes" xml:space="preserve">
          <source>Character case changing</source>
          <target state="translated">字符大小写变化</target>
        </trans-unit>
        <trans-unit id="5c948c7ed34065b8008d26ee3576913d72d9cc02" translate="yes" xml:space="preserve">
          <source>Character class.</source>
          <target state="translated">角色类。</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">角色类</target>
        </trans-unit>
        <trans-unit id="b8d7eaa1fb86bcd30ed62dcabd2cca16ff64d891" translate="yes" xml:space="preserve">
          <source>Character classes also have ordinary and special characters, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; and are matched using an escape:</source>
          <target state="translated">字符类也具有普通字符和特殊字符，但是字符类内部的普通字符和特殊字符集与字符类外部的字符集不同。字符类的特殊字符为 &lt;code&gt;-]\^$&lt;/code&gt; ，并使用转义符进行匹配：</target>
        </trans-unit>
        <trans-unit id="334bc0b92c2c74eb72d0f1cbef4062f7de8fe371" translate="yes" xml:space="preserve">
          <source>Character classes in regular expressions match based on the character properties specified in the Unicode properties database.</source>
          <target state="translated">正则表达式中的字符类根据Unicode属性数据库中指定的字符属性进行匹配。</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">角色分类</target>
        </trans-unit>
        <trans-unit id="0c5cbf9ae05984cb96206744590414bbd855ee84" translate="yes" xml:space="preserve">
          <source>Character code set ID 0037 is a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 0037 is used in North American English locales on the OS/400 operating system that runs on AS/400 computers. CCSID 0037 differs from ISO 8859-1 in 236 places; in other words they agree on only 20 code point values.</source>
          <target state="translated">字符代码集ID 0037是ASCII加拉丁-1字符(即ISO 8859-1)到EBCDIC集的映射。0037用于在AS/400计算机上运行的OS/400操作系统上的北美英语地区。CCSID 0037与ISO 8859-1有236处不同,换句话说,它们只在20个码点值上一致。</target>
        </trans-unit>
        <trans-unit id="40746c1bc8caca4e8597fe4115baf09938eb4d04" translate="yes" xml:space="preserve">
          <source>Character code set ID 1047 is also a mapping of the ASCII plus Latin-1 characters (i.e. ISO 8859-1) to an EBCDIC set. 1047 is used under Unix System Services for OS/390 or z/OS, and OpenEdition for VM/ESA. CCSID 1047 differs from CCSID 0037 in eight places, and from ISO 8859-1 in 236.</source>
          <target state="translated">字符编码集ID 1047也是ASCII加Latin-1字符(即ISO 8859-1)到EBCDIC集的映射。1047在OS/390或z/OS的Unix系统服务和VM/ESA的OpenEdition下使用。CCSID 1047与CCSID 0037有八处不同,与ISO 8859-1有236处不同。</target>
        </trans-unit>
        <trans-unit id="d32256dddf94c58de00208fb12aedf2f63688834" translate="yes" xml:space="preserve">
          <source>Character encodings in Perl</source>
          <target state="translated">Perl中的字符编码</target>
        </trans-unit>
        <trans-unit id="704c519e45bb20896b1cac037d9dc1f99d2661e9" translate="yes" xml:space="preserve">
          <source>Character ranges in regular expression bracketed character classes ( e.g., &lt;code&gt;/[a-z]/&lt;/code&gt; ) and in the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (also known as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) operator are not magically Unicode-aware. What this means is that &lt;code&gt;[A-Za-z]&lt;/code&gt; will not magically start to mean &quot;all alphabetic letters&quot; (not that it does mean that even for 8-bit characters; for those, if you are using locales (&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), use &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ; and if not, use the 8-bit-aware property &lt;code&gt;\p{alpha}&lt;/code&gt; ).</source>
          <target state="translated">用括号括起来的正则表达式字符类（例如 &lt;code&gt;/[a-z]/&lt;/code&gt; ）和 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （也称为 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）运算符中的字符范围都不具备Unicode意识。这意味着 &lt;code&gt;[A-Za-z]&lt;/code&gt; 不会神奇地开始表示&amp;ldquo;所有字母&amp;rdquo;（不是意味着即使对于8位字符；对于那些，如果您使用的是语言环境（&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;），请使用 &lt;code&gt;/[[:alpha:]]/&lt;/code&gt; ；否则，请使用8位感知属性 &lt;code&gt;\p{alpha}&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="562694c8fa3ccd4702e9b5a3b83e76744b7e6c8c" translate="yes" xml:space="preserve">
          <source>Character set modifier behavior prior to Perl 5.14</source>
          <target state="translated">Perl 5.14之前的字符集修饰符行为</target>
        </trans-unit>
        <trans-unit id="e156811acff779a0efdf0149cf0ae9a427195a9d" translate="yes" xml:space="preserve">
          <source>Character set modifiers</source>
          <target state="translated">字符集修改器</target>
        </trans-unit>
        <trans-unit id="5b676207ec8a3106cd8805847b93ca527620baf4" translate="yes" xml:space="preserve">
          <source>Character sets and character encoding</source>
          <target state="translated">字符集和字符编码</target>
        </trans-unit>
        <trans-unit id="0dd9c6f6d08e52935fa08236378969d99f092384" translate="yes" xml:space="preserve">
          <source>Characters in Pod documents may be conveyed either as literals, or by number in E&amp;lt;n&amp;gt; codes, or by an equivalent mnemonic, as in E&amp;lt;eacute&amp;gt; which is exactly equivalent to E&amp;lt;233&amp;gt;. The numbers are the Latin1/Unicode values, even on EBCDIC platforms.</source>
          <target state="translated">Pod文档中的字符可以按原义或E &amp;lt;n&amp;gt;代码中的数字或等效的助记符（如与E &amp;lt;233&amp;gt;完全相同的E &amp;lt;eacute&amp;gt;）来传递。即使在EBCDIC平台上，数字也是Latin1 / Unicode值。</target>
        </trans-unit>
        <trans-unit id="dcec8944860f789b80b281bc04ffb139e54ea11c" translate="yes" xml:space="preserve">
          <source>Characters may be literals or any of the escape sequences accepted in double-quoted strings. But there is no interpolation, so &lt;code&gt;&quot;$&quot;&lt;/code&gt; and &lt;code&gt;&quot;@&quot;&lt;/code&gt; are treated as literals. A hyphen at the beginning or end, or preceded by a backslash is considered a literal. Escape sequence details are in &lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;the table near the beginning of this section&lt;/a&gt;. It is a bug in Perl v5.22 that something like</source>
          <target state="translated">字符可以是文字，也可以是双引号字符串中可接受的任何转义序列。但是没有内插，因此将 &lt;code&gt;&quot;$&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 视为文字。开头或结尾或前面加反斜杠的连字符被视为文字。转义序列的详细信息在&lt;a href=&quot;#Quote-and-Quote-like-Operators&quot;&gt;本节开头附近的表格中&lt;/a&gt;。Perl v5.22中的一个错误是</target>
        </trans-unit>
        <trans-unit id="9963f5cdbae1775d9f83906b3a5cbef411c1ebf6" translate="yes" xml:space="preserve">
          <source>Characters may be specified using a metacharacter syntax much like that used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a form feed, etc. More generally, \</source>
          <target state="translated">可以使用元字符语法来指定字符,这与C语言中使用的元字符语法非常相似。&quot;/n &quot;表示换行符,&quot;/t &quot;表示制表符,&quot;/r &quot;表示回车符,&quot;/f &quot;表示换行符,等等。更一般地说,\</target>
        </trans-unit>
        <trans-unit id="6677fa2bd945e79a1181804df0a34874fe2d47f6" translate="yes" xml:space="preserve">
          <source>Characters that are not coded in logical order and to be rearranged. If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or less than 11, default is:</source>
          <target state="translated">未按逻辑顺序编码并要重新排列的字符。如果 &lt;code&gt;UCA_Version&lt;/code&gt; 等于或小于11，则默认值为：</target>
        </trans-unit>
        <trans-unit id="87ac5130c826b6e80d3a59535b9d6400acad5f5d" translate="yes" xml:space="preserve">
          <source>Characters that may carry a special meaning inside a character class are: &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</source>
          <target state="translated">在字符类中可能带有特殊含义的字符是 &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;[&lt;/code&gt; 和 &lt;code&gt;]&lt;/code&gt; ，下面将对其进行讨论。它们有时可以用反斜杠转义，尽管有时不需要这样做，在这种情况下可以省略反斜杠。</target>
        </trans-unit>
        <trans-unit id="d4dafb52fa02eb41cdb895328b5e1fe67da8f211" translate="yes" xml:space="preserve">
          <source>Charles Bailey</source>
          <target state="translated">Charles Bailey</target>
        </trans-unit>
        <trans-unit id="5e62c89e7209c56822c7a94ca2800f8e7a4f3ee5" translate="yes" xml:space="preserve">
          <source>Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</source>
          <target state="translated">Charles Bailey bailey@cor.newman.upenn.edu Craig Berry craigberry@mac.com Dan Sugalski dan@sidhe.org John Malmberg wb8tyw@qsl.net</target>
        </trans-unit>
        <trans-unit id="22cb7bacebab63abf9230cfeb35ec01ffa449880" translate="yes" xml:space="preserve">
          <source>Charles Wilson &amp;lt;cwilson@ece.gatech.edu&amp;gt;, Eric Fifer &amp;lt;egf7@columbia.edu&amp;gt;, alexander smishlajev &amp;lt;als@turnhere.com&amp;gt;, Steven Morlock &amp;lt;newspost@morlock.net&amp;gt;, Sebastien Barre &amp;lt;Sebastien.Barre@utc.fr&amp;gt;, Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;, Gerrit P. Haase &amp;lt;gp@familiehaase.de&amp;gt;, Reini Urban &amp;lt;rurban@cpan.org&amp;gt;, Jan Dubois &amp;lt;jand@activestate.com&amp;gt;, Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;.</source>
          <target state="translated">查尔斯&amp;middot;威尔逊（c。 .fr&amp;gt;，Teun Burgers &amp;lt;burgers@ecn.nl&amp;gt;，Gerrit P.Haase &amp;lt;gp@familiehaase.de&amp;gt;，Reini Urban &amp;lt;rurban@cpan.org&amp;gt;，Jan Dubois &amp;lt;jand@activestate.com&amp;gt;，Jerry D.Hedden &amp;lt;jdhedden@cpan.org&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="7f45f4145d31345768a09969013e2d6f185c06a1" translate="yes" xml:space="preserve">
          <source>Chdir to the djgpp subdirectory of perl toplevel and type the following commands:</source>
          <target state="translated">Chdir到perl toplevel的djgpp子目录,然后输入以下命令。</target>
        </trans-unit>
        <trans-unit id="8940df58b96cd7c07fc9ea07120c785f6f8a4a5c" translate="yes" xml:space="preserve">
          <source>Check a remote host for reachability</source>
          <target state="translated">检查远程主机的可到达性</target>
        </trans-unit>
        <trans-unit id="d7a845256cebed69e9f121b044f6c493f63a9f2a" translate="yes" xml:space="preserve">
          <source>Check for correct syntax of hyperlinks &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . See &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt; for details.</source>
          <target state="translated">检查超链接 &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; 正确语法。有关详细信息，请参见&lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abb3f832fd190f3b3ed53530b24afb5eea0c92cc" translate="yes" xml:space="preserve">
          <source>Check for duplicate declarations: report any of:</source>
          <target state="translated">检查是否有重复申报:报告任何一项。</target>
        </trans-unit>
        <trans-unit id="958d7ef30eb1cb4c2c9bdb613326b0eabb0fd9a1" translate="yes" xml:space="preserve">
          <source>Check for malformed or non-existing entities &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; .</source>
          <target state="translated">检查格式不正确或不存在的实体 &lt;code&gt;E&amp;lt;...&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e9bacd3ffc2516115599a71ea7b04dc011ace75" translate="yes" xml:space="preserve">
          <source>Check for proper balancing of &lt;code&gt;=begin&lt;/code&gt; and &lt;code&gt;=end&lt;/code&gt; . The contents of such a block are generally ignored, i.e. no syntax checks are performed.</source>
          <target state="translated">检查 &lt;code&gt;=begin&lt;/code&gt; 和 &lt;code&gt;=end&lt;/code&gt; 的适当平衡。通常忽略此类块的内容，即不执行语法检查。</target>
        </trans-unit>
        <trans-unit id="4cf90762a2de5be38eed8acc089a711c78e01421" translate="yes" xml:space="preserve">
          <source>Check for proper nesting and balancing of &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; and &lt;code&gt;=back&lt;/code&gt; .</source>
          <target state="translated">检查 &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; 和 &lt;code&gt;=back&lt;/code&gt; 的正确嵌套和平衡。</target>
        </trans-unit>
        <trans-unit id="1bb965418973274267147c8cc4fc0522a33ac593" translate="yes" xml:space="preserve">
          <source>Check for same nested interior-sequences (e.g. &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">检查相同的嵌套内部序列（例如 &lt;code&gt;L&amp;lt;...L&amp;lt;...&amp;gt;...&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eacd44b00e12dfbcc0672a7ce6d8176f78df3437" translate="yes" xml:space="preserve">
          <source>Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.</source>
          <target state="translated">检查cur_env.je_ret的情况0或3,只在eval上下文中使用。</target>
        </trans-unit>
        <trans-unit id="cb0d6f75515a999669b8c1d54704fc6c80c44584" translate="yes" xml:space="preserve">
          <source>Check for unresolved document-internal links. This check may also reveal misspelled links that seem to be internal links but should be links to something else.</source>
          <target state="translated">检查未解决的文档内部链接。这项检查还可能会发现拼写错误的链接,这些链接似乎是内部链接,但应该是指向其他东西的链接。</target>
        </trans-unit>
        <trans-unit id="d6fabbaa68065f92237c60138ecddb521d11db66" translate="yes" xml:space="preserve">
          <source>Check if all required arguments have been provided</source>
          <target state="translated">检查是否提供了所有必要的参数</target>
        </trans-unit>
        <trans-unit id="f79df82175c5eb3e95e2c6cd96c98c735fe9a6fb" translate="yes" xml:space="preserve">
          <source>Check if the archive contains a certain file. It will return true if the file is in the archive, false otherwise.</source>
          <target state="translated">检查存档是否包含某个文件。如果文件在存档中,则返回true,否则返回false。</target>
        </trans-unit>
        <trans-unit id="1a3059c728f920e1399329e5c1ad9c928030d581" translate="yes" xml:space="preserve">
          <source>Check out the MLDBM module, available on CPAN in the directory</source>
          <target state="translated">查看MLDBM模块,可在CPAN的目录中找到。</target>
        </trans-unit>
        <trans-unit id="ca159b8d6ca8bc89a6d10a26dae1e203c859a67d" translate="yes" xml:space="preserve">
          <source>Check that a hash is in an internally consistent state.</source>
          <target state="translated">检查哈希是否处于内部一致状态。</target>
        </trans-unit>
        <trans-unit id="6c679ad8ca10d169e6a7df72723849d47a11c40b" translate="yes" xml:space="preserve">
          <source>Check that some temporary files did not make into the perl install tree. Run something like this</source>
          <target state="translated">检查一些临时文件是否没有进入perl安装树。运行类似这样的程序</target>
        </trans-unit>
        <trans-unit id="9defd6564bb9099fa189d5588407b66bb7555daa" translate="yes" xml:space="preserve">
          <source>Check that you have &lt;b&gt;BSD&lt;/b&gt; libraries and headers installed, and - optionally - Berkeley DB headers and libraries, and crypt.</source>
          <target state="translated">检查是否已安装&lt;b&gt;BSD&lt;/b&gt;库和标头，以及-可选-Berkeley DB标头和库以及crypt。</target>
        </trans-unit>
        <trans-unit id="1cfcc4548a2343eadc2629dda5508ccfded48bd5" translate="yes" xml:space="preserve">
          <source>Check that you have link386 installed. It comes standard with OS/2, but may be not installed due to customization. If typing</source>
          <target state="translated">检查你是否安装了link386。它是OS/2的标准配置,但可能因为定制而没有安装。如果输入</target>
        </trans-unit>
        <trans-unit id="79d08dd23471c409ed3ca7645ef7d274508c7b47" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;Benchmark&lt;/code&gt; docs for further useful techniques.</source>
          <target state="translated">查看 &lt;code&gt;Benchmark&lt;/code&gt; 文档，了解更多有用的技术。</target>
        </trans-unit>
        <trans-unit id="14e9adf4a018a86aa09ce8983af2c630914d716c" translate="yes" xml:space="preserve">
          <source>Check the CPAN Testers if a module should work with your platform but it doesn't behave as you'd expect, or you aren't sure whether or not a module will work under your platform. If the module you want isn't listed there, you can test it yourself and let CPAN Testers know, you can join CPAN Testers, or you can request it be tested.</source>
          <target state="translated">如果一个模块应该和你的平台一起工作,但它的行为并不像你所期望的那样,或者你不确定一个模块是否能在你的平台下工作,请检查CPAN测试者。如果你想要的模块没有在那里列出,你可以自己测试并让CPAN测试人员知道,你可以加入CPAN测试人员,或者你可以要求测试它。</target>
        </trans-unit>
        <trans-unit id="5173a90532c2701f8f8cdb88adc2b6f4e6723f22" translate="yes" xml:space="preserve">
          <source>Check the PerlIO::via:: namespace on CPAN for examples of PerlIO layers implemented in Perl. To give you an idea how simple the implementation of a PerlIO layer can look, a simple example is included here.</source>
          <target state="translated">查看CPAN上的PerlIO::via::命名空间,了解在Perl中实现PerlIO层的例子。为了让你了解PerlIO层的实现有多简单,这里有一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="1c7b70cf85fde5d10a4d6750e595901816be3c74" translate="yes" xml:space="preserve">
          <source>Check the Pod syntax of a document</source>
          <target state="translated">检查文档的Pod语法</target>
        </trans-unit>
        <trans-unit id="f91480d26f728c8f70780347d46c3882a8821adf" translate="yes" xml:space="preserve">
          <source>Check the contents of the distribution. Read the module's documentation, looking for reasons why you might have trouble using it with MacPerl. Look for</source>
          <target state="translated">检查发行版的内容。阅读该模块的文档,寻找在 MacPerl 中使用该模块时可能出现问题的原因。寻找</target>
        </trans-unit>
        <trans-unit id="9e48cf52c63c2d0f64a711912719de261c9edcba" translate="yes" xml:space="preserve">
          <source>Check the validity of the stream if</source>
          <target state="translated">检查流的有效性,如果</target>
        </trans-unit>
        <trans-unit id="e9e8967b00a81a9d723ab21648f7d0d7f4c57338" translate="yes" xml:space="preserve">
          <source>Checkcc.U</source>
          <target state="translated">Checkcc.U</target>
        </trans-unit>
        <trans-unit id="82a2acac5750a7cb12b97634f29af8ec944c5757" translate="yes" xml:space="preserve">
          <source>Checking the environment entails either looking ahead on the trail, looking behind, or both. &lt;code&gt;^&lt;/code&gt; looks behind, to see that there are no characters before. &lt;code&gt;$&lt;/code&gt; looks ahead, to see that there are no characters after. &lt;code&gt;\b&lt;/code&gt; looks both ahead and behind, to see if the characters on either side differ in their &quot;word-ness&quot;.</source>
          <target state="translated">检查环境需要朝前看，向后看或两者兼有。 &lt;code&gt;^&lt;/code&gt; 向后看，看看之前没有字符。 &lt;code&gt;$&lt;/code&gt; 向前看，看后面没有字符。 &lt;code&gt;\b&lt;/code&gt; 向前和向后看，以查看两边的字符的&amp;ldquo;词性&amp;rdquo;是否不同。</target>
        </trans-unit>
        <trans-unit id="223804327875b075a53dd25f4221175abf389942" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;. Tests:</source>
          <target state="translated">检查 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 。测试：</target>
        </trans-unit>
        <trans-unit id="3a60535c47ae3686d1195136cbe426251f2f931d" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; on a filehandle just opened for write - I do not know why this should or should not work.</source>
          <target state="translated">检查刚刚打开以进行写操作的文件句柄上的 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate()&lt;/a&gt;&lt;/code&gt; -我不知道为什么应该或不应该这样做。</target>
        </trans-unit>
        <trans-unit id="564e49285a0398ab07e0e7063594b4b39a5abcbe" translate="yes" xml:space="preserve">
          <source>Checks &lt;code&gt;atime&lt;/code&gt; and &lt;code&gt;mtime&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; - unfortunately, HPFS provides only 2sec time granularity (for compatibility with FAT?).</source>
          <target state="translated">检查 &lt;code&gt;atime&lt;/code&gt; 和 &lt;code&gt;mtime&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; （？与FAT兼容性）不幸的是，HPFS仅提供2秒的时间粒度。</target>
        </trans-unit>
        <trans-unit id="e7aa1e4bbcb9ef8e50cbb1ca2e0aa94d40c33e10" translate="yes" xml:space="preserve">
          <source>Checks for VMS directory spec as well as Unix separators.</source>
          <target state="translated">检查VMS目录规范以及Unix分隔符。</target>
        </trans-unit>
        <trans-unit id="3af941bd688efd7585a7f0e144f9af47e846d7a5" translate="yes" xml:space="preserve">
          <source>Checks for the perl program under several common perl extensions.</source>
          <target state="translated">检查几种常见的perl扩展下的perl程序。</target>
        </trans-unit>
        <trans-unit id="f3d96161e784b66068319a1db708dc0748d310a2" translate="yes" xml:space="preserve">
          <source>Checks if a group with the given name has matched something.</source>
          <target state="translated">检查是否有与给定名称相匹配的组。</target>
        </trans-unit>
        <trans-unit id="1b64ff69951ab67fee8d9d86a7a4cf97007ecbf7" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated inside of recursion.</source>
          <target state="translated">检查表达式是否在递归中被评估。</target>
        </trans-unit>
        <trans-unit id="c6dad515448c742f2dc10676e5ccdb019e7a0c22" translate="yes" xml:space="preserve">
          <source>Checks if the expression has been evaluated while executing directly inside of the n-th capture group. This check is the regex equivalent of</source>
          <target state="translated">检查表达式是否在第n个捕获组内部直接执行时被评估。这个检查相当于regex的</target>
        </trans-unit>
        <trans-unit id="29b9caf4fecb2c45031e3e282976736db6a59c9c" translate="yes" xml:space="preserve">
          <source>Checks if the numbered capturing group has matched something.</source>
          <target state="translated">检查编号的捕获组是否有匹配的东西。</target>
        </trans-unit>
        <trans-unit id="7915221a7e3c9b01fb693fd7e47a678921143862" translate="yes" xml:space="preserve">
          <source>Checks if two arrays are equivalent. This is a deep check, so multi-level structures are handled correctly.</source>
          <target state="translated">检查两个数组是否相等。这是一个深度检查,所以多级结构会被正确处理。</target>
        </trans-unit>
        <trans-unit id="e40bfce6a6d81449f234a025589a2a5b020bf9fa" translate="yes" xml:space="preserve">
          <source>Checks to make sure the $module or $object can do these @methods (works with functions, too).</source>
          <target state="translated">检查以确保$module或$object可以执行这些@methods(也适用于函数)。</target>
        </trans-unit>
        <trans-unit id="55b2f57a95767c489c56b01d1268c9dfc91fb618" translate="yes" xml:space="preserve">
          <source>Checks to see if an SV is tainted. Returns TRUE if it is, FALSE if not.</source>
          <target state="translated">检查SV是否被污染。如果是,返回TRUE,如果不是,返回FALSE。</target>
        </trans-unit>
        <trans-unit id="d3c0b5dd82119b45805bc8cb1d101b8d9a91fd41" translate="yes" xml:space="preserve">
          <source>Checks to see if the current operating system is one of the given flavors.</source>
          <target state="translated">检查当前的操作系统是否是给定的风味之一。</target>
        </trans-unit>
        <trans-unit id="963de9ea3a8bb874b459828c02df2b61c6ee5c78" translate="yes" xml:space="preserve">
          <source>Checks to see if the given &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; . Also checks to make sure the object was defined in the first place. Handy for this sort of thing:</source>
          <target state="translated">检查给定的 &lt;code&gt;$object-&amp;gt;isa($class)&lt;/code&gt; 。还要检查以确保首先定义了对象。对于这种事情很方便：</target>
        </trans-unit>
        <trans-unit id="ac6373448a4e97de67ddcff713361ab246705ca8" translate="yes" xml:space="preserve">
          <source>Checks whether the pattern matches (or does not match, for the '!' variants).</source>
          <target state="translated">检查模式是否匹配(或不匹配,对于'!'变体)。</target>
        </trans-unit>
        <trans-unit id="acfac0fe5ba60bfef12b9f1265f8a0428c3029f8" translate="yes" xml:space="preserve">
          <source>Checksum field for the tar header</source>
          <target state="translated">焦油头的校验和字段</target>
        </trans-unit>
        <trans-unit id="607b7fc55b056c24f1c8cacc3987ff9e25b1dcc5" translate="yes" xml:space="preserve">
          <source>Children's times are only included for terminated children.</source>
          <target state="translated">儿童时间只包括终止的儿童。</target>
        </trans-unit>
        <trans-unit id="189da622f3fbd822d1e732459ee0eddbbb7cd8ef" translate="yes" xml:space="preserve">
          <source>China-based Chinese Encodings</source>
          <target state="translated">中国的中文编码</target>
        </trans-unit>
        <trans-unit id="d48a6b368170de01eb1a86e009fcbab8bf75cbe6" translate="yes" xml:space="preserve">
          <source>Chip Salzenberg &amp;lt;</source>
          <target state="translated">Chip Salzenberg &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f92e3f195464d519a284541bb4d50a0a8112bfbe" translate="yes" xml:space="preserve">
          <source>Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)</source>
          <target state="translated">选择一个合理且一致的版本编号方案(X.YY是常见的Perl模块编号方案)。</target>
        </trans-unit>
        <trans-unit id="26d5375b27ee62ca78bfa742d3f1dc585cc2baa3" translate="yes" xml:space="preserve">
          <source>Choose an appropriate license (GPL/Artistic is a good default)</source>
          <target state="translated">选择合适的许可证(GPL/Artistic是一个很好的默认值)。</target>
        </trans-unit>
        <trans-unit id="80fb4b6e80ff447b460548828bfa4306c5610812" translate="yes" xml:space="preserve">
          <source>Choose an appropriate name</source>
          <target state="translated">选择一个合适的名称</target>
        </trans-unit>
        <trans-unit id="d82893eb0e9cc35f7e43c5d3e352d8ca738e05ba" translate="yes" xml:space="preserve">
          <source>Choose mnemonic identifiers. If you can't remember what mnemonic means, you've got a problem.</source>
          <target state="translated">选择记忆性标识符。如果你记不住助记符的意思,那你就有问题了。</target>
        </trans-unit>
        <trans-unit id="ed88e1b0d9bb812c4891cf57f9140a2970de186a" translate="yes" xml:space="preserve">
          <source>Choose wisely.</source>
          <target state="translated">明智的选择。</target>
        </trans-unit>
        <trans-unit id="f68f3e0f920c046e7af5038b0261d7ac2b4646da" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">切掉字符串的最后一个字符并返回切碎的字符。它比 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 更有效，因为它既不扫描也不复制字符串。如果省略VARIABLE，则砍 &lt;code&gt;$_&lt;/code&gt; 。如果VARIABLE是一个哈希，它将对哈希的值（而不是其键）进行砍除，从而重置流程中的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="06caa54c979ede41f81e5b2bef50565e9d2ae230" translate="yes" xml:space="preserve">
          <source>Chops off the last character of a string and returns the character chopped. It is much more efficient than &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; because it neither scans nor copies the string. If VARIABLE is omitted, chops &lt;code&gt;$_&lt;/code&gt; . If VARIABLE is a hash, it chops the hash's values, but not its keys, resetting the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; iterator in the process.</source>
          <target state="translated">切掉字符串的最后一个字符并返回切碎的字符。它比 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s/.$//s&lt;/a&gt;&lt;/code&gt; 更有效，因为它既不扫描也不复制字符串。如果省略VARIABLE，则砍 &lt;code&gt;$_&lt;/code&gt; 。如果VARIABLE是一个哈希，它将对哈希的值（而不是其键）进行砍除，从而重置流程中的 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="26d10419c85d39f36202cd562489c0cca977e3fc" translate="yes" xml:space="preserve">
          <source>Circular References</source>
          <target state="translated">循环参考</target>
        </trans-unit>
        <trans-unit id="29285dd5c7a27e978de25c300eb6e17434a810c3" translate="yes" xml:space="preserve">
          <source>Civility is simple: stick to the facts while avoiding demeaning remarks and sarcasm. It is not enough to be factual. You must also be civil. Responding in kind to incivility is not acceptable.</source>
          <target state="translated">礼貌很简单:坚持事实,同时避免贬低和讽刺。光是实事求是是不够的。你还必须做到文明。对不文明行为作出善意的回应是不可接受的。</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="1e7fb31960aaba1258b4feeaa688fcb9336dfe6f" translate="yes" xml:space="preserve">
          <source>Class Creation at Compile Time</source>
          <target state="translated">在编译时创建类</target>
        </trans-unit>
        <trans-unit id="3d9f77136533c6ff7b7e86c9e68a8e0e99ad867e" translate="yes" xml:space="preserve">
          <source>Class Methods</source>
          <target state="translated">类方法</target>
        </trans-unit>
        <trans-unit id="3fda1907fb10f41774bfaecce153bd2dcb1991b7" translate="yes" xml:space="preserve">
          <source>Class Names as Strings</source>
          <target state="translated">类名为字符串</target>
        </trans-unit>
        <trans-unit id="f3e7ba90394996375a075b54692b14d58b442ff0" translate="yes" xml:space="preserve">
          <source>Class method for use inside a thread to change its own behavior for &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在线程内部使用的用于更改 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 自身行为的类方法。</target>
        </trans-unit>
        <trans-unit id="a38175b54007e6872fad46c411f63af989070306" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to detach itself.</source>
          <target state="translated">允许线程自我分离的类方法。</target>
        </trans-unit>
        <trans-unit id="0e0095b85b575f8ed03afeaf1d333c819ad78615" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to determine whether or not it is detached.</source>
          <target state="translated">允许线程确定是否脱离的类方法。</target>
        </trans-unit>
        <trans-unit id="e73d227a516617a6441904d7cb0de003fa8faaff" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own</source>
          <target state="translated">类方法,允许线程获得自己的</target>
        </trans-unit>
        <trans-unit id="4898ddb7865314fdb26c20ddf401c39b5082833c" translate="yes" xml:space="preserve">
          <source>Class method that allows a thread to obtain its own ID.</source>
          <target state="translated">允许线程获得自己的ID的类方法。</target>
        </trans-unit>
        <trans-unit id="fddf8c93c0000670b5cdf682b97e468968024e66" translate="yes" xml:space="preserve">
          <source>Class method to return the current thread's context. This returns the same value as running &lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt; inside the current thread's entry point function.</source>
          <target state="translated">返回当前线程上下文的类方法。这将返回与在当前线程的入口点函数内运行&lt;a href=&quot;functions/wantarray&quot;&gt;wantarray&lt;/a&gt;相同的值。</target>
        </trans-unit>
        <trans-unit id="61e8fdd13a105e0002eef0663431494746684737" translate="yes" xml:space="preserve">
          <source>Class::Accessor</source>
          <target state="translated">Class::Accessor</target>
        </trans-unit>
        <trans-unit id="394e591256dfedee8ffcd71362b2ad76a446733c" translate="yes" xml:space="preserve">
          <source>Class::C3</source>
          <target state="translated">Class::C3</target>
        </trans-unit>
        <trans-unit id="6d45f04ee3b770e5707c62b830d994b42f571d44" translate="yes" xml:space="preserve">
          <source>Class::Struct</source>
          <target state="translated">Class::Struct</target>
        </trans-unit>
        <trans-unit id="2ea8699f7b748850b0a3f5be8865468e94f1fe28" translate="yes" xml:space="preserve">
          <source>Class::Struct - declare struct-like datatypes as Perl classes</source>
          <target state="translated">Class::Struct-将类似结构的数据类型声明为Perl类。</target>
        </trans-unit>
        <trans-unit id="eabd5b700d02e72052a5dba7a49163d27d89c51a" translate="yes" xml:space="preserve">
          <source>Class::Tiny</source>
          <target state="translated">Class::Tiny</target>
        </trans-unit>
        <trans-unit id="77e7593f3ad030d22758c56fb1b2215a3db2ee44" translate="yes" xml:space="preserve">
          <source>Classes and inherited methods.</source>
          <target state="translated">类和继承的方法。</target>
        </trans-unit>
        <trans-unit id="1161f577bbba62479b9f81c878cce8a1b390e9a9" translate="yes" xml:space="preserve">
          <source>Classes based on the &lt;code&gt;id()&lt;/code&gt; function (and hence classes based on &lt;code&gt;idhash()&lt;/code&gt; and &lt;code&gt;fieldhash()&lt;/code&gt; ) show a peculiar behavior in that the class name can be used like an object. Specifically, methods that set or read data associated with an object continue to work as class methods, just as if the class name were an object, distinct from all other objects, with its own data. This object may be called the</source>
          <target state="translated">基于 &lt;code&gt;id()&lt;/code&gt; 函数的类（以及基于 &lt;code&gt;idhash()&lt;/code&gt; 和 &lt;code&gt;fieldhash()&lt;/code&gt; 的类）表现出特殊的行为，因为类名可以像对象一样使用。具体来说，设置或读取与对象关联的数据的方法将继续作为类方法工作，就像类名是一个具有所有数据的对象（不同于所有其他对象）一样。该对象可以称为</target>
        </trans-unit>
        <trans-unit id="6fe3306e3ca4485e41a1374bad73dbf1cbd32c97" translate="yes" xml:space="preserve">
          <source>Clean out some extra dll.{base,exp} files which might be generated by gcc. Otherwise, take out all *.pdb files.</source>
          <target state="translated">清理一些可能由gcc生成的多余的dll.{base,exp}文件。否则,把所有的*.pdb文件都删除。</target>
        </trans-unit>
        <trans-unit id="44fff3c8b56cfdff2a4b1fd6a798cd0eef5df63b" translate="yes" xml:space="preserve">
          <source>Clean package to evaluate code in</source>
          <target state="translated">洁净的软件包,以评估代码</target>
        </trans-unit>
        <trans-unit id="10cfbcf1f47828bf537936a130691a497387fb6d" translate="yes" xml:space="preserve">
          <source>Clean up some OS specific files. Plus the temp file used to shorten a lot of commands. And the name mangler database.</source>
          <target state="translated">清理一些操作系统特有的文件。加上用来缩短很多命令的临时文件。还有名字管理器数据库。</target>
        </trans-unit>
        <trans-unit id="81ba7eebd7e241b8a0d3ee0f0dc83f6dcb213ac0" translate="yes" xml:space="preserve">
          <source>Cleaning Up Your Path</source>
          <target state="translated">清理你的道路</target>
        </trans-unit>
        <trans-unit id="c39c68e4f213f84f2b2c6b1480b516f413b3ce6f" translate="yes" xml:space="preserve">
          <source>Cleanup VOS core files</source>
          <target state="translated">清理VOS核心文件</target>
        </trans-unit>
        <trans-unit id="89d75847cf7d1968a70859baea6df0822891a7f0" translate="yes" xml:space="preserve">
          <source>Cleanup at end of scope during compilation: set the max seq number for lexicals in this scope and warn of any lexicals that never got introduced.</source>
          <target state="translated">在编译过程中,在作用域结束时进行清理:设置这个作用域中词汇的最大序列数,并警告任何从未被引入的词汇。</target>
        </trans-unit>
        <trans-unit id="090755b1798e39d1824b0b1af3f46d5a518ba79a" translate="yes" xml:space="preserve">
          <source>Clear (remove, delete, ...) all values from the tied array associated with object</source>
          <target state="translated">清理(删除、删除......)与对象相关的绑定数组中的所有值。</target>
        </trans-unit>
        <trans-unit id="f3388c6c3c8ea1834f8402fd24982f91fd19df77" translate="yes" xml:space="preserve">
          <source>Clear all cached times.</source>
          <target state="translated">清除所有缓存时间。</target>
        </trans-unit>
        <trans-unit id="d49faf737a36f02abafb6ec88b142fb354d6f3ff" translate="yes" xml:space="preserve">
          <source>Clear all values from the tied hash</source>
          <target state="translated">清除绑定哈希中的所有值</target>
        </trans-unit>
        <trans-unit id="716a5cc3044dab9309ffffc76efde99c4966f639" translate="yes" xml:space="preserve">
          <source>Clear an SV: call any destructors, free up any memory used by the body, and free the body itself. The SV's head is</source>
          <target state="translated">清理一个SV:调用任何破坏者,释放本体使用的任何内存,释放本体本身。SV的头部是</target>
        </trans-unit>
        <trans-unit id="1f45c3303d209b593f661cc5395c426e8611e2fe" translate="yes" xml:space="preserve">
          <source>Clear end-of-file and error indicators. Should call &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; to set the &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags, which may suffice.</source>
          <target state="translated">清除文件结束和错误指示符。应该调用 &lt;code&gt;PerlIOBase_clearerr()&lt;/code&gt; 来设置 &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; 标志，这可能就足够了。</target>
        </trans-unit>
        <trans-unit id="c704c7949a89c5080ffdb34efe24fd104216362a" translate="yes" xml:space="preserve">
          <source>Clear out all the active components of a CV. This can happen either by an explicit &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; , or by the reference count going to zero. In the former case, we keep the CvOUTSIDE pointer, so that any anonymous children can still follow the full lexical scope chain.</source>
          <target state="translated">清除简历的所有活动组件。这可以通过显式的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 或引用计数变为零来发生。在前一种情况下，我们保留CvOUTSIDE指针，以便任何匿名子代仍可以遵循完整的词法作用域链。</target>
        </trans-unit>
        <trans-unit id="8b91d04ce711fbc4bae58028f0e5981dcdbd67ba" translate="yes" xml:space="preserve">
          <source>Clear something magical that the SV represents. See &lt;code&gt;sv_magic&lt;/code&gt; .</source>
          <target state="translated">清除SV所代表的魔法。参见 &lt;code&gt;sv_magic&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b01d4c4067d3dfce27d55a2e8d3ed5071a36b77" translate="yes" xml:space="preserve">
          <source>Clear the cached time for COUNT rounds of the null loop.</source>
          <target state="translated">清除null循环的count轮的缓存时间。</target>
        </trans-unit>
        <trans-unit id="46dd73c2f90db1a664404bb49713a30b15f4ee3a" translate="yes" xml:space="preserve">
          <source>Clear the default .SUFFIXES and put in our own list.</source>
          <target state="translated">清除默认的.SUFFIXES,并放入我们自己的列表中。</target>
        </trans-unit>
        <trans-unit id="1b8e52e2f767f085e79c243fc87322fea735897b" translate="yes" xml:space="preserve">
          <source>Clear the given handle's error indicator. Returns -1 if the handle is invalid, 0 otherwise.</source>
          <target state="translated">清除给定句柄的错误指示器。如果句柄无效,返回-1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="c4550ae4c0426155ad5abb566d892619b67766b1" translate="yes" xml:space="preserve">
          <source>Clear the pointed to pad value on scope exit. (i.e. the runtime action of 'my')</source>
          <target state="translated">在作用域退出时清除指向的pad值。(即'my'的运行时操作)</target>
        </trans-unit>
        <trans-unit id="57a12ccd13dcf014dfc25137bea182ded0f98ac8" translate="yes" xml:space="preserve">
          <source>Clears a slot in the current scratchpad which corresponds to &lt;code&gt;sv&lt;/code&gt; at the end of</source>
          <target state="translated">清除当前暂存器中与 &lt;code&gt;sv&lt;/code&gt; 末尾对应的插槽</target>
        </trans-unit>
        <trans-unit id="3ef31da8d602e77684482123705889bd007979e0" translate="yes" xml:space="preserve">
          <source>Clears an array, making it empty. Does not free the memory the av uses to store its list of scalars. If any destructors are triggered as a result, the av itself may be freed when this function returns.</source>
          <target state="translated">清除一个数组,使其为空。不会释放av用于存储其标量列表的内存。如果因此触发了任何析构函数,那么当这个函数返回时,av本身可能会被释放。</target>
        </trans-unit>
        <trans-unit id="8cd338daf3e28d8a698a54a756c5a2c73cce2208" translate="yes" xml:space="preserve">
          <source>Clears any placeholders from a hash. If a restricted hash has any of its keys marked as readonly and the key is subsequently deleted, the key is not actually deleted but is marked by assigning it a value of &amp;amp;PL_sv_placeholder. This tags it so it will be ignored by future operations such as iterating over the hash, but will still allow the hash to have a value reassigned to the key at some future point. This function clears any such placeholder keys from the hash. See Hash::Util::lock_keys() for an example of its use.</source>
          <target state="translated">从哈希中清除所有占位符。如果受限制的哈希表的任何键都标记为只读，并且该键随后被删除，则该键实际上并没有删除，而是通过为其分配值＆PL_sv_placeholder进行标记。这会对其进行标记，因此将来的操作（例如遍历哈希）将被忽略，但仍将允许哈希在将来的某个时刻将值重新分配给键。此函数从哈希中清除所有此类占位符键。有关其用法的示例，请参见Hash :: Util :: lock_keys（）。</target>
        </trans-unit>
        <trans-unit id="8694e0be1c305fe59f17048c06b457a918bbcd82" translate="yes" xml:space="preserve">
          <source>Clears the internal table of &quot;seen&quot; references and returns the object itself.</source>
          <target state="translated">清除 &quot;所见 &quot;引用的内部表,并返回对象本身。</target>
        </trans-unit>
        <trans-unit id="47b31851c74e0f5ebbb3dfaea28b4822609aa2b8" translate="yes" xml:space="preserve">
          <source>Client Callback Methods</source>
          <target state="translated">客户端回调方法</target>
        </trans-unit>
        <trans-unit id="37da5860354a7f86a5ca376c0d24243e5da20032" translate="yes" xml:space="preserve">
          <source>Clients of &lt;b&gt;Pod::Parser&lt;/b&gt; should use the following methods to access instance data fields:</source>
          <target state="translated">&lt;b&gt;Pod :: Parser的&lt;/b&gt;客户端应使用以下方法访问实例数据字段：</target>
        </trans-unit>
        <trans-unit id="b6d24920f2b48bf829e8a23e9a90dfdd3440760d" translate="yes" xml:space="preserve">
          <source>Clone a CV, making a lexical closure.</source>
          <target state="translated">克隆一个CV,做一个词性封闭。</target>
        </trans-unit>
        <trans-unit id="5f979b64a2e1385f3005f3cb2103d9f2baf2955c" translate="yes" xml:space="preserve">
          <source>Clone the state variables associated with running and compiling pads.</source>
          <target state="translated">克隆与运行和编译pads相关的状态变量。</target>
        </trans-unit>
        <trans-unit id="8a76336a32c405fad8ce65baf95c160bc7bd1714" translate="yes" xml:space="preserve">
          <source>Cloning an interpreter</source>
          <target state="translated">克隆一个口译员</target>
        </trans-unit>
        <trans-unit id="4b55eaddcc64cc03fb97cb5cfdc6e4a0b7e1eab8" translate="yes" xml:space="preserve">
          <source>Close the data connection and get a response from the FTP server. Returns</source>
          <target state="translated">关闭数据连接,并获得FTP服务器的响应。返回</target>
        </trans-unit>
        <trans-unit id="1c0a792433b635cbfbf3a9fa1132f2f138428c0e" translate="yes" xml:space="preserve">
          <source>Close the file associated with the object and disassociate the file from the handle. Done automatically on destroy.</source>
          <target state="translated">关闭与对象相关联的文件,并使文件与句柄脱离关系。销毁时自动完成。</target>
        </trans-unit>
        <trans-unit id="19ff0b1a9c29ac2abd677ef11d03ad865001d751" translate="yes" xml:space="preserve">
          <source>Close the file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">关闭文件。它使用文件描述符，例如通过调用 &lt;code&gt;POSIX::open&lt;/code&gt; 获得的文件描述符。</target>
        </trans-unit>
        <trans-unit id="6557bfb4a242f6c8d48bf95461a4833d7849fd1a" translate="yes" xml:space="preserve">
          <source>Close the handle</source>
          <target state="translated">关闭手柄</target>
        </trans-unit>
        <trans-unit id="bb4472090f184d3ee362c8c35a0ec02ede037401" translate="yes" xml:space="preserve">
          <source>Close the network connection for this ping object. The network connection is also closed by &quot;undef $p&quot;. The network connection is automatically closed if the ping object goes out of scope (e.g. $p is local to a subroutine and you leave the subroutine).</source>
          <target state="translated">关闭这个ping对象的网络连接。网络连接也会被 &quot;undef $p &quot;关闭。如果ping对象超出了范围,网络连接会自动关闭(例如,$p是一个子程序的本地程序,而你离开了这个子程序)。</target>
        </trans-unit>
        <trans-unit id="190ae3f86d0557b4127e04bcfb326cc6d030a90a" translate="yes" xml:space="preserve">
          <source>Close the stream. Should normally call &lt;code&gt;PerlIOBase_close()&lt;/code&gt; to flush itself and close layers below, and then deallocate any data structures (buffers, translation tables, ...) not held directly in the data structure.</source>
          <target state="translated">关闭流。通常应该调用 &lt;code&gt;PerlIOBase_close()&lt;/code&gt; 刷新自身并关闭下面的层，然后取消分配未直接保存在数据结构中的任何数据结构（缓冲区，转换表等）。</target>
        </trans-unit>
        <trans-unit id="31da48802b39a62004814937a9e31811a752be6b" translate="yes" xml:space="preserve">
          <source>Closely associated with the &lt;code&gt;//g&lt;/code&gt; modifier is the &lt;code&gt;\G&lt;/code&gt; anchor. The &lt;code&gt;\G&lt;/code&gt; anchor matches at the point where the previous &lt;code&gt;//g&lt;/code&gt; match left off. &lt;code&gt;\G&lt;/code&gt; allows us to easily do context-sensitive matching:</source>
          <target state="translated">与 &lt;code&gt;//g&lt;/code&gt; 修饰符紧密相关的是 &lt;code&gt;\G&lt;/code&gt; 锚。所述 &lt;code&gt;\G&lt;/code&gt; 在其中先前的点锚匹配 &lt;code&gt;//g&lt;/code&gt; 匹配不放过。 &lt;code&gt;\G&lt;/code&gt; 使我们可以轻松地进行上下文相关的匹配：</target>
        </trans-unit>
        <trans-unit id="ed2c86b22aa0e19fdc594e6bdac3be5d440f77af" translate="yes" xml:space="preserve">
          <source>Closely associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the</source>
          <target state="translated">与匹配变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，... 密切相关的是</target>
        </trans-unit>
        <trans-unit id="4c6e55c513c3700cb482b5228ee114dea0eb2014" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">关闭由 &lt;code&gt;&lt;a href=&quot;functions/opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 打开的目录，并返回该系统调用的成功。</target>
        </trans-unit>
        <trans-unit id="1718bbd298f85e4f92aa5e14dbae95e752272e78" translate="yes" xml:space="preserve">
          <source>Closes a directory opened by &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; and returns the success of that system call.</source>
          <target state="translated">关闭由 &lt;code&gt;&lt;a href=&quot;opendir&quot;&gt;opendir&lt;/a&gt;&lt;/code&gt; 打开的目录，并返回该系统调用的成功。</target>
        </trans-unit>
        <trans-unit id="c738bf1c5aeadafd66d4f3177f0ec53c7a05eef3" translate="yes" xml:space="preserve">
          <source>Closes the compressed file. Any pending data is flushed to the file before it is closed.</source>
          <target state="translated">关闭压缩文件。在关闭文件之前,所有待处理的数据都会被刷新到文件中。</target>
        </trans-unit>
        <trans-unit id="b1d528fd6e4e57f9b4f4824f906e152d2b52aa44" translate="yes" xml:space="preserve">
          <source>Closes the current compressed data stream and starts a new one.</source>
          <target state="translated">关闭当前的压缩数据流,并开始一个新的压缩数据流。</target>
        </trans-unit>
        <trans-unit id="51e188a428b2b9dba319c461ba18765571b8c558" translate="yes" xml:space="preserve">
          <source>Closes the file or pipe associated with the filehandle, flushes the IO buffers, and closes the system file descriptor. Returns true if those operations succeed and if no error was reported by any PerlIO layer. Closes the currently selected filehandle if the argument is omitted.</source>
          <target state="translated">关闭与filehandle相关联的文件或管道,刷新IO缓冲区,并关闭系统文件描述符。如果这些操作成功,并且没有任何PerlIO层报告错误,则返回true。如果参数被省略,则关闭当前选择的文件柄。</target>
        </trans-unit>
        <trans-unit id="fea628f203f0d9f7135eed7983ec3d8792beb442" translate="yes" xml:space="preserve">
          <source>Closes the log file and returns true on success.</source>
          <target state="translated">关闭日志文件,成功后返回true。</target>
        </trans-unit>
        <trans-unit id="d2bbc309bbe5a51ba61bf619d197d1239e2eb8ce" translate="yes" xml:space="preserve">
          <source>Closes the output file/buffer.</source>
          <target state="translated">关闭输出文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="ba43eac7b65017fd2089f1e6bc015f1ec8c511e2" translate="yes" xml:space="preserve">
          <source>Closing any piped filehandle causes the parent process to wait for the child to finish, then returns the status value in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">关闭任何管道文件句柄会使父进程等待子进程完成，然后以 &lt;code&gt;$?&lt;/code&gt; 返回状态值。和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4dcf08fb56e6d72fb32ed7e1eabe87691436e56" translate="yes" xml:space="preserve">
          <source>Closing bracket for XSUB arguments. This is usually handled by &lt;code&gt;xsubpp&lt;/code&gt; . See &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; for other uses.</source>
          <target state="translated">XSUB参数的右括号。通常由 &lt;code&gt;xsubpp&lt;/code&gt; 处理。有关其他用途，请参见 &lt;code&gt;PUSHMARK&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="737b7e3ad0d2423ad5a8db0c5d04ee20b1d52475" translate="yes" xml:space="preserve">
          <source>Closing bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">轻型回调的右括号。请参阅&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcall中的轻量级回调&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c2745a4c8776a0e5fafe11f0f22ec70fe0d72258" translate="yes" xml:space="preserve">
          <source>Closing bracket for temporaries on a callback. See &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调临时文件的结束括号。请参阅 &lt;code&gt;SAVETMPS&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ba349d3ba72088b84c46b90a7f642094300bd0d" translate="yes" xml:space="preserve">
          <source>Closing bracket on a callback. See &lt;code&gt;ENTER&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">回调上的右括号。请参阅 &lt;code&gt;ENTER&lt;/code&gt; 和&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23a4c843ad3bbdd040a62a1e5a6170f0fcb264c5" translate="yes" xml:space="preserve">
          <source>Closing the read end of a pipe before the process writing to it at the other end is done writing results in the writer receiving a SIGPIPE. If the other end can't handle that, be sure to read all the data before closing the pipe.</source>
          <target state="translated">在另一端向管道写入的进程完成写入之前,关闭管道的读端,会导致写入者收到一个SIGPIPE。如果另一端无法处理,一定要在关闭管道之前读完所有数据。</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="b6d86b58c6ea474356b305c2ad2f3387941bd459" translate="yes" xml:space="preserve">
          <source>Closures are documented in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">封闭记录在&lt;a href=&quot;perlref&quot;&gt;perlref中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="07e50ba612fbe1c93f394383c8388d370e33f827" translate="yes" xml:space="preserve">
          <source>Closures are most often used in programming languages where you can have the return value of a function be itself a function, as you can in Perl. Note that some languages provide anonymous functions but are not capable of providing proper closures: the Python language, for example. For more information on closures, check out any textbook on functional programming. Scheme is a language that not only supports but encourages closures.</source>
          <target state="translated">闭包最常用于编程语言中,在这些语言中,你可以让函数的返回值本身就是一个函数,就像在Perl中一样。请注意,有些语言提供了匿名函数,但并不能提供适当的闭包:例如 Python 语言。关于闭包的更多信息,请查阅任何一本函数式编程的教科书。Scheme 是一种不仅支持而且鼓励闭包的语言。</target>
        </trans-unit>
        <trans-unit id="625dad30655b90e54e26f3f025084dbfc6f7497b" translate="yes" xml:space="preserve">
          <source>Closures are often used for less esoteric purposes. For example, when you want to pass in a bit of code into a function:</source>
          <target state="translated">闭包通常用于不那么深奥的目的。例如,当你想把一段代码传入一个函数中时。</target>
        </trans-unit>
        <trans-unit id="5161af4a1cac3a1b9b45f56c8dea0b53f7bfbecc" translate="yes" xml:space="preserve">
          <source>Co-existence with stdio</source>
          <target state="translated">与stdio共存</target>
        </trans-unit>
        <trans-unit id="6517f8be2c6a95c643a9a9b5bb9a2d69ac206184" translate="yes" xml:space="preserve">
          <source>Cocoa</source>
          <target state="translated">Cocoa</target>
        </trans-unit>
        <trans-unit id="95c99c8aeaa2e8fc96be370bcb2d2ba452daba68" translate="yes" xml:space="preserve">
          <source>Code &lt;code&gt;x&lt;/code&gt; skips a byte, since we don't need the count yet. Code &lt;code&gt;n&lt;/code&gt; takes care of the 16-bit big-endian integer address, and &lt;code&gt;C&lt;/code&gt; unpacks the record type. Being at offset 4, where the data begins, we need the count. &lt;code&gt;X4&lt;/code&gt; brings us back to square one, which is the byte at offset 0. Now we pick up the count, and zoom forth to offset 4, where we are now fully furnished to extract the exact number of data bytes, leaving the trailing checksum byte alone.</source>
          <target state="translated">代码 &lt;code&gt;x&lt;/code&gt; 跳过一个字节，因为我们还不需要计数。代码 &lt;code&gt;n&lt;/code&gt; 负责16位的big-endian整数地址， &lt;code&gt;C&lt;/code&gt; 则解压缩记录类型。在数据开始的偏移量4处，我们需要计数。 &lt;code&gt;X4&lt;/code&gt; 使我们回到平方1，即偏移量0处的字节。现在，我们开始计数并放大到偏移量4，在此位置，我们已经准备好提取确切的数据字节数，剩下尾随的校验和字节。单独。</target>
        </trans-unit>
        <trans-unit id="88ed008dc7a2ff797ab17a3de73dfdb055a98c4d" translate="yes" xml:space="preserve">
          <source>Code blocks such as &lt;code&gt;(?{BLOCK})&lt;/code&gt; are handled by temporarily passing control back to the perl parser, in a similar way that an interpolated array subscript expression such as &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; would be.</source>
          <target state="translated">像 &lt;code&gt;(?{BLOCK})&lt;/code&gt; 这样的代码块是通过将控制权暂时传回perl解析器来处理的，其方式类似于插值数组下标表达式，例如 &lt;code&gt;&quot;foo$array[1+f(&quot;[xyz&quot;)]bar&quot;&lt;/code&gt; 会。</target>
        </trans-unit>
        <trans-unit id="762d66380b843da111702ccfbb2c67a26389d7e3" translate="yes" xml:space="preserve">
          <source>Code evaluation</source>
          <target state="translated">代码评估</target>
        </trans-unit>
        <trans-unit id="37d37b9a8d116d9e1ae5c945c68e058e2feb14aa" translate="yes" xml:space="preserve">
          <source>Code expressions are zero-width assertions, and the value they return depends on their environment. There are two possibilities: either the code expression is used as a conditional in a conditional expression &lt;code&gt;(?(condition)...)&lt;/code&gt;, or it is not. If the code expression is a conditional, the code is evaluated and the result (i.e., the result of the last statement) is used to determine truth or falsehood. If the code expression is not used as a conditional, the assertion always evaluates true and the result is put into the special variable &lt;code&gt;$^R&lt;/code&gt; . The variable &lt;code&gt;$^R&lt;/code&gt; can then be used in code expressions later in the regexp. Here are some silly examples:</source>
          <target state="translated">代码表达式是零宽度的断言，它们返回的值取决于其环境。有两种可能性：将代码表达式用作条件表达式 &lt;code&gt;(?(condition)...)&lt;/code&gt; 中的条件表达式，否则不使用。如果代码表达式是有条件的，则对代码求值，然后使用结果（即最后一条语句的结果）确定真假。如果未将代码表达式用作条件表达式，则断言始终为true，并将结果放入特殊变量 &lt;code&gt;$^R&lt;/code&gt; 。变量 &lt;code&gt;$^R&lt;/code&gt; 随后可以在正则表达式中的代码表达式中使用。这是一些愚蠢的例子：</target>
        </trans-unit>
        <trans-unit id="16588d7ea09d6c8a62bccdc2d6ce591ced66cdbf" translate="yes" xml:space="preserve">
          <source>Code expressions, conditional expressions, and independent expressions are</source>
          <target state="translated">代码表达式、条件表达式和独立表达式是指</target>
        </trans-unit>
        <trans-unit id="0d4a4669a2b66538a054bb02710d7250ecbe4161" translate="yes" xml:space="preserve">
          <source>Code for &lt;code&gt;constant()&lt;/code&gt; s regenerated by Nicholas Clark &amp;lt;</source>
          <target state="translated">Nicholas Clark &amp;lt;生成的 &lt;code&gt;constant()&lt;/code&gt; 代码</target>
        </trans-unit>
        <trans-unit id="d3cbaac4d40358f731935693702135f199e63c95" translate="yes" xml:space="preserve">
          <source>Code is executed in the caller's package.</source>
          <target state="translated">代码在调用者的包中执行。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
