<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="25bc3d27f1f1d3400779cec866f02e11e267bcde" translate="yes" xml:space="preserve">
          <source>How do I handle linked lists?</source>
          <target state="translated">如何处理链接列表?</target>
        </trans-unit>
        <trans-unit id="22ab3c17d49644f7643e768f33f866efb0521ae5" translate="yes" xml:space="preserve">
          <source>How do I install a &quot;DEVELOPER RELEASE&quot; of a module?</source>
          <target state="translated">如何安装模块的 &quot;Developer RELEASE&quot;?</target>
        </trans-unit>
        <trans-unit id="51ca5bd4b613176b7121cb512580f3d074cc9e12" translate="yes" xml:space="preserve">
          <source>How do I install a module and all its dependencies from the commandline, without being prompted for anything, despite my CPAN configuration (or lack thereof)?</source>
          <target state="translated">我如何从命令行安装一个模块及其所有的依赖关系,而不被提示任何内容,尽管我的CPAN配置(或没有)?</target>
        </trans-unit>
        <trans-unit id="332f266fa06f1a0ab802b1da5c10c6890675f4de" translate="yes" xml:space="preserve">
          <source>How do I install a module from CPAN?</source>
          <target state="translated">如何从CPAN安装模块?</target>
        </trans-unit>
        <trans-unit id="125fb980d7aaa7ca2242befa5648bc32166dc7e6" translate="yes" xml:space="preserve">
          <source>How do I install a module into my home directory?</source>
          <target state="translated">如何将模块安装到我的主目录中?</target>
        </trans-unit>
        <trans-unit id="d861f5b4b26ce38782c487c2b8f360184457002f" translate="yes" xml:space="preserve">
          <source>How do I keep from installing man pages?</source>
          <target state="translated">如何防止安装人页?</target>
        </trans-unit>
        <trans-unit id="63d92a5148bd9660c144884977d59745697a0930" translate="yes" xml:space="preserve">
          <source>How do I keep my $VERSION up to date without resetting it manually?</source>
          <target state="translated">如何在不手动重置的情况下保持$VERSION的更新?</target>
        </trans-unit>
        <trans-unit id="779b60119e9ac89f1b4bb8ccca7aa17790f78529" translate="yes" xml:space="preserve">
          <source>How do I keep my own module/library directory?</source>
          <target state="translated">如何保存自己的模块/库目录?</target>
        </trans-unit>
        <trans-unit id="712ff90db628f146b683448ab9a743ea57d1a8f1" translate="yes" xml:space="preserve">
          <source>How do I keep persistent data across program calls?</source>
          <target state="translated">如何在程序调用中保持数据的持久性?</target>
        </trans-unit>
        <trans-unit id="a20b09e11bad429f8e02c602624e45b441c22369" translate="yes" xml:space="preserve">
          <source>How do I look up a hash element by value?</source>
          <target state="translated">如何按值查询哈希元素?</target>
        </trans-unit>
        <trans-unit id="fc81f211ace7f04a35490b5be3fe4452ee1626e9" translate="yes" xml:space="preserve">
          <source>How do I make a system() exit on control-C?</source>
          <target state="translated">如何让control-C上的system()退出?</target>
        </trans-unit>
        <trans-unit id="58c641789837b76dd9abee18041837a328da4bf8" translate="yes" xml:space="preserve">
          <source>How do I make a temporary file name?</source>
          <target state="translated">如何制作临时文件名?</target>
        </trans-unit>
        <trans-unit id="f0fab6b039e898671e7205067775272f3896476e" translate="yes" xml:space="preserve">
          <source>How do I make sure users can't enter values into a form that causes my CGI script to do bad things?</source>
          <target state="translated">如何确保用户不能在表单中输入值,导致我的CGI脚本做坏事?</target>
        </trans-unit>
        <trans-unit id="717678bc544dca5a8699132ee02462800aee62d3" translate="yes" xml:space="preserve">
          <source>How do I make two or more XS files coexist in the same directory?</source>
          <target state="translated">如何使两个或两个以上的XS文件共存于同一目录中?</target>
        </trans-unit>
        <trans-unit id="9e83c97b2d0052618a071494ce58ad0aa5de46bd" translate="yes" xml:space="preserve">
          <source>How do I manipulate arrays of bits?</source>
          <target state="translated">如何操作比特数组?</target>
        </trans-unit>
        <trans-unit id="f91d0deef997d3bfa3ece796fb840e0045a0792b" translate="yes" xml:space="preserve">
          <source>How do I match XML, HTML, or other nasty, ugly things with a regex?</source>
          <target state="translated">如何用regex匹配XML、HTML或其他讨厌的、丑陋的东西?</target>
        </trans-unit>
        <trans-unit id="9e10d6b9fcc0dce9241e02f9e3f41bcdabf8cf6b" translate="yes" xml:space="preserve">
          <source>How do I match a regular expression that's in a variable?</source>
          <target state="translated">如何匹配变量中的正则表达式?</target>
        </trans-unit>
        <trans-unit id="5d4e304caa9da74ae39c7e0f1bc8a660a934e36b" translate="yes" xml:space="preserve">
          <source>How do I merge two hashes?</source>
          <target state="translated">如何合并两个哈希值?</target>
        </trans-unit>
        <trans-unit id="e98a867a19e12d012764c76bf6e04f0613af63d6" translate="yes" xml:space="preserve">
          <source>How do I modify the shadow password file on a Unix system?</source>
          <target state="translated">如何修改Unix系统上的影子密码文件?</target>
        </trans-unit>
        <trans-unit id="c7095e8729e8a7f2287429c858bc0e6162426248" translate="yes" xml:space="preserve">
          <source>How do I multiply matrices?</source>
          <target state="translated">矩阵怎么乘法?</target>
        </trans-unit>
        <trans-unit id="9460689c66cd7c2602f152fc7b62b5a75f54acdd" translate="yes" xml:space="preserve">
          <source>How do I open a file without blocking?</source>
          <target state="translated">如何不被屏蔽地打开文件?</target>
        </trans-unit>
        <trans-unit id="9724c57d7e62b1229f27e461cfe00d869c775e7e" translate="yes" xml:space="preserve">
          <source>How do I pack arrays of doubles or floats for XS code?</source>
          <target state="translated">如何在XS代码中打包双数组或浮动数组?</target>
        </trans-unit>
        <trans-unit id="4400dc02ad15b6fc00f373b7446035015d4ee6bf" translate="yes" xml:space="preserve">
          <source>How do I pad a string with blanks or pad a number with zeroes?</source>
          <target state="translated">如何在字符串中垫上空格或在数字中垫上零?</target>
        </trans-unit>
        <trans-unit id="d0e3e8a036359d14fc456cf2c14236b5f608bd62" translate="yes" xml:space="preserve">
          <source>How do I parse a mail header?</source>
          <target state="translated">如何解析邮件头?</target>
        </trans-unit>
        <trans-unit id="9e0cafd923d528d129dae6e8757b0045ebfe45d2" translate="yes" xml:space="preserve">
          <source>How do I perform an operation on a series of integers?</source>
          <target state="translated">如何对一系列整数进行操作?</target>
        </trans-unit>
        <trans-unit id="0ea5e302520f6bb39c41ab5c626ec6b77bff9c77" translate="yes" xml:space="preserve">
          <source>How do I permute N elements of a list?</source>
          <target state="translated">如何对一个列表中的N个元素进行置换?</target>
        </trans-unit>
        <trans-unit id="2bb4f19e6e2b56ae1fd37e0d6e014e129c77c2b4" translate="yes" xml:space="preserve">
          <source>How do I prevent &quot;object version X.XX does not match bootstrap parameter Y.YY&quot; errors?</source>
          <target state="translated">如何防止 &quot;对象版本X.XX与bootstrap参数Y.YY不匹配 &quot;的错误?</target>
        </trans-unit>
        <trans-unit id="5b942fa715d105d63d048d010625e34a4e15cc06" translate="yes" xml:space="preserve">
          <source>How do I print out or copy a recursive data structure?</source>
          <target state="translated">如何打印出或复制递归数据结构?</target>
        </trans-unit>
        <trans-unit id="0cee12c0d629b76061795de4e8ea8e8aad20c9a2" translate="yes" xml:space="preserve">
          <source>How do I print something out in color?</source>
          <target state="translated">如何打印出彩色的东西?</target>
        </trans-unit>
        <trans-unit id="8c5e011ff87e317620443254f20726209e4d5142" translate="yes" xml:space="preserve">
          <source>How do I print to more than one file at once?</source>
          <target state="translated">如何同时打印到多个文件?</target>
        </trans-unit>
        <trans-unit id="8e6e30c99d7d46a63b6dd2a8de7f090b5c3b78f8" translate="yes" xml:space="preserve">
          <source>How do I process an entire hash?</source>
          <target state="translated">如何处理整个哈希值?</target>
        </trans-unit>
        <trans-unit id="271b9d3d652ec230aba0c388cad00cfb6ec4cadb" translate="yes" xml:space="preserve">
          <source>How do I process each word on each line?</source>
          <target state="translated">如何处理每一行的每个字?</target>
        </trans-unit>
        <trans-unit id="067d5b88bfca3ed1b6b7d97cd252f5dd16cbb5b2" translate="yes" xml:space="preserve">
          <source>How do I process/modify each element of an array?</source>
          <target state="translated">如何处理/修改数组中的每个元素?</target>
        </trans-unit>
        <trans-unit id="4b013be3c59b874a12db528d39cfb66ea2b4d285" translate="yes" xml:space="preserve">
          <source>How do I profile my Perl programs?</source>
          <target state="translated">如何对我的Perl程序进行配置文件?</target>
        </trans-unit>
        <trans-unit id="907ce6af6f55d655a78f0e8c0ae363954d37ba4f" translate="yes" xml:space="preserve">
          <source>How do I put a &quot;-?&quot; option into a Getopt::Long?</source>
          <target state="translated">如何在Getopt::Long中加入&quot;-?&quot;选项?</target>
        </trans-unit>
        <trans-unit id="c7fe97c54150572fb4431657021f14d59fd4861f" translate="yes" xml:space="preserve">
          <source>How do I put a password on my web pages?</source>
          <target state="translated">如何在网页上设置密码?</target>
        </trans-unit>
        <trans-unit id="aabceca15e4a4d5d9ca824c2b010057c5ffb938d" translate="yes" xml:space="preserve">
          <source>How do I randomly update a binary file?</source>
          <target state="translated">如何随机更新二进制文件?</target>
        </trans-unit>
        <trans-unit id="be52f21f6d10d6ab8f3f91d7f9754bf001810264" translate="yes" xml:space="preserve">
          <source>How do I read and write the serial port?</source>
          <target state="translated">如何对串口进行读写?</target>
        </trans-unit>
        <trans-unit id="88cf95522fd81b968df3c101e350990093c3aa09" translate="yes" xml:space="preserve">
          <source>How do I read email?</source>
          <target state="translated">如何阅读邮件?</target>
        </trans-unit>
        <trans-unit id="f7f8ec70d59120dd78e53b84aba791742e9edd1e" translate="yes" xml:space="preserve">
          <source>How do I read just one key without waiting for a return key?</source>
          <target state="translated">如何只读一个键而不等待返回键?</target>
        </trans-unit>
        <trans-unit id="b3ea24ef99830bfeddb0edd113b634795cbe4cbc" translate="yes" xml:space="preserve">
          <source>How do I recompress using a different compression?</source>
          <target state="translated">如何使用不同的压缩方式重新压缩?</target>
        </trans-unit>
        <trans-unit id="90d36808740d961fdd3bc4db24c2ee814f31ee7c" translate="yes" xml:space="preserve">
          <source>How do I redefine a builtin function, operator, or method?</source>
          <target state="translated">如何重新定义一个内置函数、操作符或方法?</target>
        </trans-unit>
        <trans-unit id="64b8d2bb065ca77fe0dc5f5fef705f4b317c4fca" translate="yes" xml:space="preserve">
          <source>How do I redirect to another page?</source>
          <target state="translated">如何重定向到其他页面?</target>
        </trans-unit>
        <trans-unit id="0261e937b4173727b02c00645ba76e6a415fae20" translate="yes" xml:space="preserve">
          <source>How do I reformat a paragraph?</source>
          <target state="translated">如何重新安排段落的格式?</target>
        </trans-unit>
        <trans-unit id="0eeeab64d2dc7e3dd771f347a9a11591454f54b3" translate="yes" xml:space="preserve">
          <source>How do I remove HTML from a string?</source>
          <target state="translated">如何从字符串中删除HTML?</target>
        </trans-unit>
        <trans-unit id="7190f2c95452c7e338420c52915e20b7f528657f" translate="yes" xml:space="preserve">
          <source>How do I remove consecutive pairs of characters?</source>
          <target state="translated">如何删除连续的字符对?</target>
        </trans-unit>
        <trans-unit id="d5da8d0925bfcf1ec95ecac71470e320a20303f5" translate="yes" xml:space="preserve">
          <source>How do I reset an each() operation part-way through?</source>
          <target state="translated">如何在中途重置each()操作?</target>
        </trans-unit>
        <trans-unit id="344b42394088d6a1b32ccef3d8e8decb8e4c01b4" translate="yes" xml:space="preserve">
          <source>How do I reverse a string?</source>
          <target state="translated">如何反串?</target>
        </trans-unit>
        <trans-unit id="c109790cdec5d8d7c505dc674edb8df7914a81e2" translate="yes" xml:space="preserve">
          <source>How do I select a random element from an array?</source>
          <target state="translated">如何从一个数组中选择一个随机元素?</target>
        </trans-unit>
        <trans-unit id="199c93de57e75c85ebb9d101614dabcde24b6614" translate="yes" xml:space="preserve">
          <source>How do I select a random line from a file?</source>
          <target state="translated">如何从文件中随机选择一行?</target>
        </trans-unit>
        <trans-unit id="39ccafc4ea9b3fd7b952612609873f9c549c7c42" translate="yes" xml:space="preserve">
          <source>How do I send email?</source>
          <target state="translated">如何发送电子邮件?</target>
        </trans-unit>
        <trans-unit id="56fc4c1960e173cac75e9d994591b6be91c2c2f5" translate="yes" xml:space="preserve">
          <source>How do I set CPU limits?</source>
          <target state="translated">如何设置CPU限制?</target>
        </trans-unit>
        <trans-unit id="73ae95585e094adfdbb75ef9f256a18859cff476" translate="yes" xml:space="preserve">
          <source>How do I set a file's timestamp in perl?</source>
          <target state="translated">如何在perl中设置文件的时间戳?</target>
        </trans-unit>
        <trans-unit id="7015da22cf6dfd7afb1594ce5e8862f937d3b755" translate="yes" xml:space="preserve">
          <source>How do I set the time and date?</source>
          <target state="translated">如何设置时间和日期?</target>
        </trans-unit>
        <trans-unit id="36b77dc941cd48cd98a47f8dbd2c57de165d3aa2" translate="yes" xml:space="preserve">
          <source>How do I shuffle an array randomly?</source>
          <target state="translated">如何随机洗牌一个数组?</target>
        </trans-unit>
        <trans-unit id="c56fb4f98404c5161610269f73993e7de95a3de7" translate="yes" xml:space="preserve">
          <source>How do I skip some return values?</source>
          <target state="translated">如何跳过一些返回值?</target>
        </trans-unit>
        <trans-unit id="f999ee460d48e77fd71574c2f54756bd21091885" translate="yes" xml:space="preserve">
          <source>How do I sort a hash (optionally by value instead of key)?</source>
          <target state="translated">我如何对哈希进行排序(可以选择用值代替键)?</target>
        </trans-unit>
        <trans-unit id="3557025618ab23a2cf788475e1bcca26065db241" translate="yes" xml:space="preserve">
          <source>How do I sort an array by (anything)?</source>
          <target state="translated">如何通过(任何东西)对一个数组进行排序?</target>
        </trans-unit>
        <trans-unit id="11e9e959693213fc786f53e3eeef7ea5001cbb5a" translate="yes" xml:space="preserve">
          <source>How do I start a process in the background?</source>
          <target state="translated">如何在后台启动一个进程?</target>
        </trans-unit>
        <trans-unit id="e8df49adcf72001a3aba0a320e673d15d1fbff49" translate="yes" xml:space="preserve">
          <source>How do I store complex data structures with DB_File?</source>
          <target state="translated">如何使用DB_File存储复杂的数据结构?</target>
        </trans-unit>
        <trans-unit id="d0810d8592d3996c240e80dd3d6e5421e650a5a9" translate="yes" xml:space="preserve">
          <source>How do I strip blank space from the beginning/end of a string?</source>
          <target state="translated">如何从字符串的开头/结尾处去除空格?</target>
        </trans-unit>
        <trans-unit id="8ae8648605278dba0e8e66d1aa18bb02cd9cbee2" translate="yes" xml:space="preserve">
          <source>How do I substitute case-insensitively on the LHS while preserving case on the RHS?</source>
          <target state="translated">如何在保留RHS上的大小写的同时,在LHS上进行不敏感的替换?</target>
        </trans-unit>
        <trans-unit id="32d79b5f1ff74cbc3bfb77b42941e7971f7cd494" translate="yes" xml:space="preserve">
          <source>How do I tell the difference between errors from the shell and perl?</source>
          <target state="translated">如何区分shell和perl的错误?</target>
        </trans-unit>
        <trans-unit id="402cd06b394cf67e3d76498ee9b3e9b9d87437a0" translate="yes" xml:space="preserve">
          <source>How do I temporarily block warnings?</source>
          <target state="translated">如何临时屏蔽警告?</target>
        </trans-unit>
        <trans-unit id="c0789eca0c8fd61b4175e61db4aa71f599404e50" translate="yes" xml:space="preserve">
          <source>How do I test whether two arrays or hashes are equal?</source>
          <target state="translated">如何测试两个数组或哈希值是否相等?</target>
        </trans-unit>
        <trans-unit id="e84b81ceb7f858ca3fa98015c2c4dfea66af9e8b" translate="yes" xml:space="preserve">
          <source>How do I timeout a slow event?</source>
          <target state="translated">如何对慢速事件进行超时处理?</target>
        </trans-unit>
        <trans-unit id="4865802f290eeeec02fbec1851daaa986a328389" translate="yes" xml:space="preserve">
          <source>How do I transfer files in binary mode ?</source>
          <target state="translated">如何以二进制模式传输文件?</target>
        </trans-unit>
        <trans-unit id="e46e5cb6feaa9bdc58f6ceead41bdfe807157710" translate="yes" xml:space="preserve">
          <source>How do I trap control characters/signals?</source>
          <target state="translated">如何捕捉控制字符/信号?</target>
        </trans-unit>
        <trans-unit id="d2dd15b6c1b33b3c86eddf841d0c83120333ce34" translate="yes" xml:space="preserve">
          <source>How do I traverse a directory tree?</source>
          <target state="translated">如何遍历目录树?</target>
        </trans-unit>
        <trans-unit id="e9dd0c064f83a182ab0d7dad0b56b72fe36b708b" translate="yes" xml:space="preserve">
          <source>How do I unescape a string?</source>
          <target state="translated">如何解除对字符串的转义?</target>
        </trans-unit>
        <trans-unit id="de74f402e85f9eee7aa46222792929c66c3f3ab7" translate="yes" xml:space="preserve">
          <source>How do I use MIME to make an attachment to a mail message?</source>
          <target state="translated">我如何使用MIME来制作邮件附件?</target>
        </trans-unit>
        <trans-unit id="d3ed87430fcbcc3ae6919edba6458d4a0ecbd944" translate="yes" xml:space="preserve">
          <source>How do I use a module without installing it?</source>
          <target state="translated">如何在不安装模块的情况下使用模块?</target>
        </trans-unit>
        <trans-unit id="ec6da1c1f95c027b2d1444208c25f958dcd9f486" translate="yes" xml:space="preserve">
          <source>How do I use a regular expression to strip C-style comments from a file?</source>
          <target state="translated">如何使用正则表达式从文件中剥离C式注释?</target>
        </trans-unit>
        <trans-unit id="a8b6bf66c7856a15f241de6c0802175e07cd63b3" translate="yes" xml:space="preserve">
          <source>How do I use all this in extensions?</source>
          <target state="translated">如何在扩展中使用这些东西?</target>
        </trans-unit>
        <trans-unit id="b826b48e54f42be4d7b4af41a8de11eb743f6b7a" translate="yes" xml:space="preserve">
          <source>How do I use an SQL database?</source>
          <target state="translated">如何使用SQL数据库?</target>
        </trans-unit>
        <trans-unit id="2bdd87983f12ab09515439198b26c02b64e724f4" translate="yes" xml:space="preserve">
          <source>How do I validate input?</source>
          <target state="translated">如何验证输入?</target>
        </trans-unit>
        <trans-unit id="26964c4f36b19d9f1a78d8688cbdbdb4cea51cb7" translate="yes" xml:space="preserve">
          <source>How do I verify a credit card checksum?</source>
          <target state="translated">如何验证信用卡校验码?</target>
        </trans-unit>
        <trans-unit id="4f3796bf485f2eb722b7ed35a129d4469581633e" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;; however, since &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">我们该怎么做呢？您可能首先考虑使用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; ; 但是，由于 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 折叠了空白字段，因此您永远不会知道记录是收入还是支出。哎呀。好吧，您可以始终使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="103fbca18a8de8029a50cc2b1c4a72ca20bf5fba" translate="yes" xml:space="preserve">
          <source>How do we do it? You might think first to use &lt;code&gt;split&lt;/code&gt;; however, since &lt;code&gt;split&lt;/code&gt; collapses blank fields, you'll never know whether a record was income or expenditure. Oops. Well, you could always use &lt;code&gt;substr&lt;/code&gt;:</source>
          <target state="translated">我们该怎么做呢？您可能首先考虑使用 &lt;code&gt;split&lt;/code&gt; ; 但是，由于 &lt;code&gt;split&lt;/code&gt; 折叠了空白字段，因此您永远不会知道记录是收入还是支出。哎呀。好吧，您可以始终使用 &lt;code&gt;substr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="adb503b87f7ea09a8ed712efab2105d52de66798" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt; ? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">我们如何知道 &lt;code&gt;U&lt;/code&gt; 是否是 &lt;code&gt;pat&lt;/code&gt; 中的第一个格式？好吧，如果我们有一个指向 &lt;code&gt;pat&lt;/code&gt; 开头的指针，那么，如果看到一个 &lt;code&gt;U&lt;/code&gt; ,我们可以测试我们是否仍在字符串的开头。因此，这是 &lt;code&gt;pat&lt;/code&gt; 的设置位置：</target>
        </trans-unit>
        <trans-unit id="0b8d788126db97a55dce37692218aca769c60ab7" translate="yes" xml:space="preserve">
          <source>How do we know if the &lt;code&gt;U&lt;/code&gt; is the first format in the &lt;code&gt;pat&lt;/code&gt;? Well, if we have a pointer to the start of &lt;code&gt;pat&lt;/code&gt; then, if we see a &lt;code&gt;U&lt;/code&gt; we can test whether we're still at the start of the string. So, here's where &lt;code&gt;pat&lt;/code&gt; is set up:</source>
          <target state="translated">我们如何知道 &lt;code&gt;U&lt;/code&gt; 是否是 &lt;code&gt;pat&lt;/code&gt; 中的第一个格式？好吧，如果我们有一个指向 &lt;code&gt;pat&lt;/code&gt; 开头的指针，那么，如果看到一个 &lt;code&gt;U&lt;/code&gt; ,我们可以测试我们是否仍在字符串的开头。因此，这是 &lt;code&gt;pat&lt;/code&gt; 的设置位置：</target>
        </trans-unit>
        <trans-unit id="41c2d105be109eed3cac8eac59cfe5a2af927614" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">我们如何准备解决此问题？首先，我们找到有问题的代码- &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 发生在运行时，因此它将位于其中一个</target>
        </trans-unit>
        <trans-unit id="5d7d9138e293d0199d65703623c0ff89dd97e453" translate="yes" xml:space="preserve">
          <source>How do we prepare to fix this up? First we locate the code in question - the &lt;code&gt;pack&lt;/code&gt; happens at runtime, so it's going to be in one of the</source>
          <target state="translated">我们如何准备解决此问题？首先，我们找到有问题的代码- &lt;code&gt;pack&lt;/code&gt; 发生在运行时，因此它将位于其中一个</target>
        </trans-unit>
        <trans-unit id="24a7f470a36048c277bd60a862a28514c120a416" translate="yes" xml:space="preserve">
          <source>How do you know that you've made the right decisions? Have you picked an interface design that will cause problems later? Have you picked the most appropriate name? Do you have any questions?</source>
          <target state="translated">你怎么知道你的决策是正确的?你是否选择了一个以后会引起问题的界面设计?你选择了最合适的名字吗?你有什么问题吗?</target>
        </trans-unit>
        <trans-unit id="41a4f1d575f0f11ff6874b18c40b76daeb66d4c2" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; ? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">您如何打印出来？为什么不说只 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; @AoA&lt;/code&gt; 呢？您如何排序？如何将其传递给函数或从函数中取回其中之一？是物体吗？您可以将其保存到磁盘以供日后阅读吗？您如何访问该矩阵的整个行或列？所有值都必须是数字吗？</target>
        </trans-unit>
        <trans-unit id="7a08ef652d92b58fe7f054cbc142a1867f296373" translate="yes" xml:space="preserve">
          <source>How do you print it out? Why can't you say just &lt;code&gt;print @AoA&lt;/code&gt;? How do you sort it? How can you pass it to a function or get one of these back from a function? Is it an object? Can you save it to disk to read back later? How do you access whole rows or columns of that matrix? Do all the values have to be numeric?</source>
          <target state="translated">您如何打印出来？为什么不说只 &lt;code&gt;print @AoA&lt;/code&gt; 呢？您如何排序？如何将其传递给函数或从函数中取回其中之一？是物体吗？您可以将其保存到磁盘以供日后阅读吗？您如何访问该矩阵的整行或整列？所有值都必须是数字吗？</target>
        </trans-unit>
        <trans-unit id="0db30a52c84584239974d26d09f54763e3e6b602" translate="yes" xml:space="preserve">
          <source>How do you want to capitalize those words?</source>
          <target state="translated">这些字要怎么大写?</target>
        </trans-unit>
        <trans-unit id="057ea76fe6b43747bac035e0aa618c75b67755d7" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">用 &lt;code&gt;P&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 如何工作？想象一下缓冲区中的一些指针即将被解包：如果它不是空指针（它将巧妙地产生 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值），我们就有一个起始地址-但是那又是什么呢？Perl无法知道此&amp;ldquo;固定长度字符串&amp;rdquo;有多长，因此由您决定将实际大小指定为 &lt;code&gt;P&lt;/code&gt; 之后的显式长度。</target>
        </trans-unit>
        <trans-unit id="7cb23bf82dfe8e718e7ef8eacd292b571d084be2" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;P&lt;/code&gt; work? Imagine some pointer in the buffer about to be unpacked: If it isn't the null pointer (which will smartly produce the &lt;code&gt;undef&lt;/code&gt; value) we have a start address - but then what? Perl has no way of knowing how long this &quot;fixed length string&quot; is, so it's up to you to specify the actual size as an explicit length after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;P&lt;/code&gt; &lt;code&gt;unpack&lt;/code&gt; 如何工作？想象一下缓冲区中的一些指针即将被解包：如果它不是空指针（将巧妙地产生 &lt;code&gt;undef&lt;/code&gt; 值），那么我们就有一个起始地址-但是那又是什么呢？Perl无法知道此&amp;ldquo;固定长度字符串&amp;rdquo;有多长，因此由您决定将实际大小指定为 &lt;code&gt;P&lt;/code&gt; 之后的显式长度。</target>
        </trans-unit>
        <trans-unit id="9905196a168946e4c1e199eb5d4a39f1df926922" translate="yes" xml:space="preserve">
          <source>How does C3 work</source>
          <target state="translated">C3是如何工作的</target>
        </trans-unit>
        <trans-unit id="ec67f8e66f8cd607856093fe73d4e05432e16189" translate="yes" xml:space="preserve">
          <source>How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?</source>
          <target state="translated">Perl与Java、Python、REX、Scheme或Tcl等其他语言相比如何?</target>
        </trans-unit>
        <trans-unit id="1c4f7191bdf4e77d9f3df9d3633a24eb4798422b" translate="yes" xml:space="preserve">
          <source>How does Perl store UTF-8 strings?</source>
          <target state="translated">Perl如何存储UTF-8字符串?</target>
        </trans-unit>
        <trans-unit id="d6555d1bc4e0774734c01cf5a9778e9667013a49" translate="yes" xml:space="preserve">
          <source>How does UTF-8 represent Unicode characters?</source>
          <target state="translated">UTF-8如何表示Unicode字符?</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">它是如何工作的?</target>
        </trans-unit>
        <trans-unit id="7cc6d699d794fc3ac271d46b893bbe5d8af9561d" translate="yes" xml:space="preserve">
          <source>How does the HAS_QUUX become defined where it needs to be? Well, if Foonix happens to be Unixy enough to be able to run the Configure script, and Configure has been taught about detecting and testing quux(), the HAS_QUUX will be correctly defined. In other platforms, the corresponding configuration step will hopefully do the same.</source>
          <target state="translated">如何定义HAS_QUUX?好吧,如果Foonix刚好是Unixy,能够运行Configure脚本,并且Configure已经学会了检测和测试quux(),HAS_QUUX就会被正确定义。在其他平台上,相应的配置步骤希望也能做到这一点。</target>
        </trans-unit>
        <trans-unit id="a7654b1f75662fbb39441273d3ed984d7a322d6a" translate="yes" xml:space="preserve">
          <source>How far up the call stack should &lt;code&gt;$Test&lt;/code&gt; look when reporting where the test failed.</source>
          <target state="translated">报告测试失败的位置时， &lt;code&gt;$Test&lt;/code&gt; 应该看多远的调用堆栈。</target>
        </trans-unit>
        <trans-unit id="085217ef4c6745e3415b3c7e78584430d39a3a20" translate="yes" xml:space="preserve">
          <source>How field hashes work</source>
          <target state="translated">字段哈希如何工作</target>
        </trans-unit>
        <trans-unit id="1dd6a17cb4033f4f74df1bb6912b8a28a8074084" translate="yes" xml:space="preserve">
          <source>How it works</source>
          <target state="translated">运作方式</target>
        </trans-unit>
        <trans-unit id="debefefe9570a7f478b45607468c1f04ecf9084c" translate="yes" xml:space="preserve">
          <source>How long to wait for child processes and threads before aborting.</source>
          <target state="translated">子进程和线程要等多长时间才会中止。</target>
        </trans-unit>
        <trans-unit id="5aeac53e476a9bc19466fb717cce28dc3a661453" translate="yes" xml:space="preserve">
          <source>How many bits fit in the NaN depends on what kind of floating points are being used, but on the most common platforms (64-bit IEEE 754, or the x86 80-bit long doubles) there are 51 and 61 bits available, respectively. (There would be 52 and 62, but the quiet/signaling bit of NaNs takes away one.) However, because of the floating-point-to- integer-and-back conversions, please test carefully whether you get back what you put in. If your integers are only 32 bits wide, you probably should not rely on more than 32 bits of payload.</source>
          <target state="translated">NaN中适合多少位取决于使用什么样的浮点数,但在最常见的平台上(64位IEEE 754,或x86的80位长倍数),分别有51位和61位可用。(本来有52和62位,但NaNs的安静/信号位拿走了一位)。然而,由于浮点数到整数再到回数的转换,请仔细测试你是否能拿回你投入的东西。如果你的整数只有32位宽,你可能不应该依赖超过32位的有效载荷。</target>
        </trans-unit>
        <trans-unit id="0c8392c4bc182245c6112422d8ac379f29dc0269" translate="yes" xml:space="preserve">
          <source>How many days shall we keep statistics about downloads?</source>
          <target state="translated">我们要统计多少天的下载量?</target>
        </trans-unit>
        <trans-unit id="a2df7a98d6c586141cd04b6aa0105c17934a6b57" translate="yes" xml:space="preserve">
          <source>How many items shall we keep in the statistics about downloads?</source>
          <target state="translated">我们应该在下载统计中保留多少项目?</target>
        </trans-unit>
        <trans-unit id="a4c476d15c4f91ec82f82f8c5a4b611455926ad6" translate="yes" xml:space="preserve">
          <source>How many things you have to skip over when moving from the beginning of a string or array to a specific position within it. Thus, the minimum offset is zero, not one, because you don&amp;rsquo;t skip anything to get to the first item.</source>
          <target state="translated">从字符串或数组的开头移至字符串中的特定位置时，您必须跳过多少件事。因此，最小偏移量为零，而不是一个，因为您无需跳过任何内容即可获得第一项。</target>
        </trans-unit>
        <trans-unit id="e8f69207ec93ea9ac0d7bd7d78ad22c5fad82d93" translate="yes" xml:space="preserve">
          <source>How much memory will an X kb tar file need?</source>
          <target state="translated">一个X kb的tar文件需要多少内存?</target>
        </trans-unit>
        <trans-unit id="06d061df76ab13c25cd39004271d0f48f24f772c" translate="yes" xml:space="preserve">
          <source>How multiple interpreters and concurrency are supported</source>
          <target state="translated">如何支持多解释器和并发性</target>
        </trans-unit>
        <trans-unit id="6077b2c6a621300c72c26286304312a48389905e" translate="yes" xml:space="preserve">
          <source>How often are new versions of Perl released?</source>
          <target state="translated">Perl 的新版本多久发布一次?</target>
        </trans-unit>
        <trans-unit id="09667313848c3831b4f83a58be79ca17489cfe27" translate="yes" xml:space="preserve">
          <source>How stable is Perl?</source>
          <target state="translated">Perl的稳定性如何?</target>
        </trans-unit>
        <trans-unit id="83c34a283446a710c37e72f2a9adb47d8902892c" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">字符串的求值方式完全取决于系统上的命令解释器。在大多数平台上，如果要按字面意义对待外壳元字符，则必须保护它们。在实践中，这很难做到，因为尚不清楚如何转义哪些字符。请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;，以获取有关干净安全的手动 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 示例，以安全地模拟反引号。</target>
        </trans-unit>
        <trans-unit id="9eed5100d867c777939bb5769caf179997d17506" translate="yes" xml:space="preserve">
          <source>How that string gets evaluated is entirely subject to the command interpreter on your system. On most platforms, you will have to protect shell metacharacters if you want them treated literally. This is in practice difficult to do, as it's unclear how to escape which characters. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for a clean and safe example of a manual &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; to emulate backticks safely.</source>
          <target state="translated">字符串的求值方式完全取决于系统上的命令解释器。在大多数平台上，如果要按字面意义对待外壳元字符，则必须保护它们。实际上这很难做到，因为不清楚如何转义哪些字符。请参阅&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;，以获取有关安全地模拟反引号的手动 &lt;code&gt;fork()&lt;/code&gt; 和 &lt;code&gt;exec()&lt;/code&gt; 的干净而安全的示例。</target>
        </trans-unit>
        <trans-unit id="1c335ff6cb2a45884654c99fc61e53c7a376324b" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;declare()&lt;/code&gt; a dotted-decimal version</source>
          <target state="translated">如何 &lt;code&gt;declare()&lt;/code&gt; 点分十进制版本</target>
        </trans-unit>
        <trans-unit id="e0814da3e299e49d2449969ad142f5bd55fcc256" translate="yes" xml:space="preserve">
          <source>How to &lt;code&gt;parse()&lt;/code&gt; a version</source>
          <target state="translated">如何 &lt;code&gt;parse()&lt;/code&gt; 版本</target>
        </trans-unit>
        <trans-unit id="32e58ed61895689f9ea71e1d65dd7b363842c21f" translate="yes" xml:space="preserve">
          <source>How to Eat an Egg on a Net</source>
          <target state="translated">网购鸡蛋怎么吃</target>
        </trans-unit>
        <trans-unit id="1e92c63bea5bacbfe17288aa9b727bd5b57d76ef" translate="yes" xml:space="preserve">
          <source>How to Export</source>
          <target state="translated">如何出口</target>
        </trans-unit>
        <trans-unit id="c94aa75d1f562c0c7126364d18c31a48ccae10ce" translate="yes" xml:space="preserve">
          <source>How to Import</source>
          <target state="translated">如何导入</target>
        </trans-unit>
        <trans-unit id="66e5306e1ee37b9c8432fab22e675761fdae05d9" translate="yes" xml:space="preserve">
          <source>How to build it - possible changes to Makefile.PL etc.</source>
          <target state="translated">如何构建它--可能对Makefile.PL等进行修改。</target>
        </trans-unit>
        <trans-unit id="276af2b0e47e1128b2d6988024c5aa973d55b3ad" translate="yes" xml:space="preserve">
          <source>How to check for a legal version string</source>
          <target state="translated">如何检查合法版本字符串</target>
        </trans-unit>
        <trans-unit id="200eebf37528bcbed0445247c76a5eb54f9e1c23" translate="yes" xml:space="preserve">
          <source>How to compare version objects</source>
          <target state="translated">如何比较版本对象</target>
        </trans-unit>
        <trans-unit id="ca504da3ad384a1782b8a80c01519809d8213b8a" translate="yes" xml:space="preserve">
          <source>How to contribute to the perlfaq</source>
          <target state="translated">如何为perlfaq做贡献</target>
        </trans-unit>
        <trans-unit id="d80ee544d5d5799659326d52d976ff8d1a12d506" translate="yes" xml:space="preserve">
          <source>How to contribute to this document</source>
          <target state="translated">如何为本文件做出贡献</target>
        </trans-unit>
        <trans-unit id="98f26a635f2b0eee95797f21034bacde6a2960b0" translate="yes" xml:space="preserve">
          <source>How to convert a module from decimal to dotted-decimal</source>
          <target state="translated">如何将模块从十进制转换为点阵十进制?</target>
        </trans-unit>
        <trans-unit id="59750c3fc03389b5d7028878d6d502ec39f41a63" translate="yes" xml:space="preserve">
          <source>How to create a new module</source>
          <target state="translated">如何创建一个新模块</target>
        </trans-unit>
        <trans-unit id="4b6cf27d781b549a9ad503d5e122d5adb52f744e" translate="yes" xml:space="preserve">
          <source>How to declare() a dotted-decimal version</source>
          <target state="translated">如何声明()一个点阵十进制版本</target>
        </trans-unit>
        <trans-unit id="117233b2c5097bb47b4e325f79c07984d73d5ef7" translate="yes" xml:space="preserve">
          <source>How to get a package, unwrap it, and make a change before building it?</source>
          <target state="translated">如何拿到包裹,拆开包装,进行修改后再建?</target>
        </trans-unit>
        <trans-unit id="581ecead393f1357725f2a7ad157c2752daf62ea" translate="yes" xml:space="preserve">
          <source>How to install it.</source>
          <target state="translated">如何安装。</target>
        </trans-unit>
        <trans-unit id="6a513660bb1d74aac4457f5e1ad35cd324a50563" translate="yes" xml:space="preserve">
          <source>How to parse() a version</source>
          <target state="translated">如何解析()一个版本</target>
        </trans-unit>
        <trans-unit id="745ad195185248d449699ab965e2e195908cc3f7" translate="yes" xml:space="preserve">
          <source>How to release and distribute a module.</source>
          <target state="translated">如何发布和分发一个模块。</target>
        </trans-unit>
        <trans-unit id="fac65371d245ce74fd54b584511aa21b655f4973" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">如何报告错误。 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 说对任何POD格式化错误都抛出异常。 &lt;code&gt;stderr&lt;/code&gt; 说要报告有关标准错误的错误，但不要引发异常。 &lt;code&gt;pod&lt;/code&gt; 说在结果文档中包括POD ERRORS部分，以总结错误。 &lt;code&gt;none&lt;/code&gt; 完全忽略POD错误。</target>
        </trans-unit>
        <trans-unit id="d8e06e503e624ee14cb08fcb7aa8200b1d1a33be" translate="yes" xml:space="preserve">
          <source>How to report errors. &lt;code&gt;die&lt;/code&gt; says to throw an exception on any POD formatting error. &lt;code&gt;stderr&lt;/code&gt; says to report errors on standard error, but not to throw an exception. &lt;code&gt;pod&lt;/code&gt; says to include a POD ERRORS section in the resulting documentation summarizing the errors. &lt;code&gt;none&lt;/code&gt; ignores POD errors entirely, as much as possible.</source>
          <target state="translated">如何报告错误。 &lt;code&gt;die&lt;/code&gt; 说对任何POD格式化错误抛出异常。 &lt;code&gt;stderr&lt;/code&gt; 说要报告有关标准错误的错误，但不要引发异常。 &lt;code&gt;pod&lt;/code&gt; 说在结果文档中包括POD ERRORS部分，以总结错误。 &lt;code&gt;none&lt;/code&gt; 会尽可能地完全忽略POD错误。</target>
        </trans-unit>
        <trans-unit id="d7d2e49b42408e54cf7a34c3e80635f480f9c4a8" translate="yes" xml:space="preserve">
          <source>How to use Field Hashes</source>
          <target state="translated">如何使用领域哈希值</target>
        </trans-unit>
        <trans-unit id="fc1ff928efd359368d94e6d36c9ac3ed9b57df61" translate="yes" xml:space="preserve">
          <source>How to use ppport.h</source>
          <target state="translated">如何使用pport.h</target>
        </trans-unit>
        <trans-unit id="76a1aee9e2d87dca5af8b9f3523a520421f66d36" translate="yes" xml:space="preserve">
          <source>How to use the perlfaq</source>
          <target state="translated">如何使用perlfaq</target>
        </trans-unit>
        <trans-unit id="3f24180ceba0ec0cc68f9d5c0e1e26d52c83ce1f" translate="yes" xml:space="preserve">
          <source>How you access/control keyboards, screens, and pointing devices (&quot;mice&quot;) is system-dependent. Try the following modules:</source>
          <target state="translated">如何访问/控制键盘、屏幕和指向设备(&quot;鼠标&quot;)取决于系统。请尝试以下模块。</target>
        </trans-unit>
        <trans-unit id="4bc300db17dcedeb6194b557a3ba400e45f35668" translate="yes" xml:space="preserve">
          <source>How you choose to license your work is a personal decision. The general mechanism is to assert your Copyright and then make a declaration of how others may copy/use/modify your work.</source>
          <target state="translated">你如何选择许可你的作品是个人的决定,一般的机制是维护你的版权,然后声明他人如何复制/使用/修改你的作品。一般的机制是维护您的版权,然后声明他人如何复制/使用/修改您的作品。</target>
        </trans-unit>
        <trans-unit id="eb2f13a23bf4830d2fc62239cefe549717cd58f6" translate="yes" xml:space="preserve">
          <source>How your various pieces of data relate to each other and what shape they make when you put them all together, as in a rectangular table or a triangular tree.</source>
          <target state="translated">你的各种数据之间的关系,以及当你把它们放在一起时,它们会变成什么形状,如长方形的表格或三角形的树。</target>
        </trans-unit>
        <trans-unit id="49e45b77d6ea8c9934575389c7d37f20873b7d78" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;change()&lt;/code&gt; inherited from &lt;code&gt;Unicode::Collate&lt;/code&gt; allows such a tailoring that is reserved by &lt;code&gt;locale&lt;/code&gt;. Examples:</source>
          <target state="translated">但是，从 &lt;code&gt;Unicode::Collate&lt;/code&gt; 继承的 &lt;code&gt;change()&lt;/code&gt; 允许进行这种由 &lt;code&gt;locale&lt;/code&gt; 保留的剪裁。例子：</target>
        </trans-unit>
        <trans-unit id="e1a5d362bff5ef9a53ac39d40f0d72384a7a7980" translate="yes" xml:space="preserve">
          <source>However &lt;code&gt;entry&lt;/code&gt; is allowed, even if it is used for &lt;code&gt;locale&lt;/code&gt; support, to add or override mappings.</source>
          <target state="translated">但是，即使该 &lt;code&gt;entry&lt;/code&gt; 用于 &lt;code&gt;locale&lt;/code&gt; 支持，也允许该条目添加或覆盖映射。</target>
        </trans-unit>
        <trans-unit id="d3b89735ac32202767302de6090cfe3b522ac706" translate="yes" xml:space="preserve">
          <source>However adding a Time::Piece object to another Time::Piece object will cause a runtime error.</source>
          <target state="translated">然而,将一个Time::Piece对象添加到另一个Time::Piece对象中会导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="30f041c654fc533b28dcc332c81f8669c3b80359" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt; ), even though the same text in &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt; .</source>
          <target state="translated">但是，不会替换 &lt;code&gt;\&lt;/code&gt; 后跟一个字符的任何其他组合，而是仅将其跳过，以便在下一步将它们解析为正则表达式。如 &lt;code&gt;\c&lt;/code&gt; 被跳过在该步骤中， &lt;code&gt;@&lt;/code&gt; 的 &lt;code&gt;\c@&lt;/code&gt; 在RE中可能视为一个阵列的符号（例如 &lt;code&gt;@foo&lt;/code&gt; ），即使在相同的文字 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq//&lt;/a&gt;&lt;/code&gt; 给出了内插 &lt;code&gt;\c@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9fa46c7dac1006200659c34da5fea0149776dd8d" translate="yes" xml:space="preserve">
          <source>However any other combinations of &lt;code&gt;\&lt;/code&gt; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &lt;code&gt;\c&lt;/code&gt; is skipped at this step, &lt;code&gt;@&lt;/code&gt; of &lt;code&gt;\c@&lt;/code&gt; in RE is possibly treated as an array symbol (for example &lt;code&gt;@foo&lt;/code&gt;), even though the same text in &lt;code&gt;qq//&lt;/code&gt; gives interpolation of &lt;code&gt;\c@&lt;/code&gt;.</source>
          <target state="translated">但是，不会替换 &lt;code&gt;\&lt;/code&gt; 后跟一个字符的任何其他组合，而是仅将其跳过，以便在接下来的步骤中将它们解析为正则表达式。如 &lt;code&gt;\c&lt;/code&gt; 被跳过在该步骤中， &lt;code&gt;@&lt;/code&gt; 的 &lt;code&gt;\c@&lt;/code&gt; 在RE中可能视为一个阵列的符号（例如 &lt;code&gt;@foo&lt;/code&gt; ），即使在相同的文字 &lt;code&gt;qq//&lt;/code&gt; 给出了内插 &lt;code&gt;\c@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16e29f719714863d70b942d575046dbb5cba98f5" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">但是，调用这些方法只会影响上面可以返回数据连接的方法的使用。它们对 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;put_unique&lt;/code&gt; 方法以及不需要数据连接的方法没有影响。</target>
        </trans-unit>
        <trans-unit id="de13c057041819bc6b844abfeff87d29540cb81e" translate="yes" xml:space="preserve">
          <source>However calling these methods only affects the use of the methods above that can return a data connection. They have no effect on methods &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;put_unique&lt;/code&gt; and those that do not require data connections.</source>
          <target state="translated">但是，调用这些方法只会影响上面可以返回数据连接的方法的使用。它们对方法 &lt;code&gt;get&lt;/code&gt; ， &lt;code&gt;put&lt;/code&gt; ， &lt;code&gt;put_unique&lt;/code&gt; 和不需要数据连接的方法没有影响。</target>
        </trans-unit>
        <trans-unit id="4dd9e96cfe2926dfabdbc85765517e42ef1d89e7" translate="yes" xml:space="preserve">
          <source>However if you use them for methods it is up to you to figure out how to make inheritance work.)</source>
          <target state="translated">然而,如果你把它们用于方法,那就得靠你自己去想办法让继承发挥作用了)。)</target>
        </trans-unit>
        <trans-unit id="3eb546f277a4853248567d6d99dbadcec1483c0f" translate="yes" xml:space="preserve">
          <source>However it is possible to :</source>
          <target state="translated">然而,它是可以:</target>
        </trans-unit>
        <trans-unit id="b048a4ce1b3f69d17018ba3c836a5e60080a819e" translate="yes" xml:space="preserve">
          <source>However the parent classes are set, the package's &lt;code&gt;@ISA&lt;/code&gt; variable will contain a list of those parents. This is simply a list of scalars, each of which is a string that corresponds to a package name.</source>
          <target state="translated">但是，设置了父类后，程序包的 &lt;code&gt;@ISA&lt;/code&gt; 变量将包含这些父类的列表。这只是一个标量列表，每个标量是一个与包名称相对应的字符串。</target>
        </trans-unit>
        <trans-unit id="ba3e62d1138ee32c59c072f255ef49bd8748a854" translate="yes" xml:space="preserve">
          <source>However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</source>
          <target state="translated">然而其他样式的四舍五入的结果是不一样的,如果紧靠四舍五入位右边的数字(跳过小数点)是5,如果5之后没有数字,或者没有0以外的数字,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="4fbf8823a3b3cfa62eaf7d0dd429a9afbd37439d" translate="yes" xml:space="preserve">
          <source>However the test engine bleeds these message to screen in unexpected moments. Two messages of this kind</source>
          <target state="translated">然而测试引擎会在意想不到的时刻将这些消息流到屏幕上。这类信息有两条</target>
        </trans-unit>
        <trans-unit id="ef8fc937e43b67ff40714fcd8d7fd4e3c6c06fbf" translate="yes" xml:space="preserve">
          <source>However you should never rely on the numerical position of any opcode within the opset. In other words both sides of a bit vector operator should be opsets returned from Opcode functions.</source>
          <target state="translated">然而,你永远不应该依赖任何操作码在操作集中的数值位置。换句话说,位向量运算符的两边应该是Opcode函数返回的运算集。</target>
        </trans-unit>
        <trans-unit id="553943043c049c659e40aebd03db5306b0148501" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;sudo&lt;/code&gt; sets the real user or group ID to that of the target identity, not just the effective ID as set-id bits do. As a result, Perl can't detect that it is running under &lt;code&gt;sudo&lt;/code&gt;, and so won't automatically take its own security precautions such as turning on taint mode. Where &lt;code&gt;sudo&lt;/code&gt; configuration dictates exactly which command can be run, the approved command may include a &lt;code&gt;-T&lt;/code&gt; option to perl to enable taint mode.</source>
          <target state="translated">但是， &lt;code&gt;sudo&lt;/code&gt; 会将真实用户或组ID设置为目标身份的ID，而不仅仅是有效ID（如set-id位那样）。结果，Perl无法检测到它正在 &lt;code&gt;sudo&lt;/code&gt; 下运行，因此不会自动采取自己的安全措施，例如打开taint模式。在 &lt;code&gt;sudo&lt;/code&gt; 配置确切指示可以运行哪个命令的情况下，批准的命令可能包括perl的 &lt;code&gt;-T&lt;/code&gt; 选项以启用污点模式。</target>
        </trans-unit>
        <trans-unit id="98648e73024116127cb39bd5de118b8a0a2cc6ca" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">但是，Filter :: Simple足够聪明，可以注意到您现有的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 并使用它来做正确的事。也就是说，如果您在使用Filter :: Simple的程序包中显式定义了 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程，则在安装任何过滤器后仍会立即调用该 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="f6d3a8dddc21154e6d620bf1f1a45edff899ff21" translate="yes" xml:space="preserve">
          <source>However, Filter::Simple is smart enough to notice your existing &lt;code&gt;import&lt;/code&gt; and Do The Right Thing with it. That is, if you explicitly define an &lt;code&gt;import&lt;/code&gt; subroutine in a package that's using Filter::Simple, that &lt;code&gt;import&lt;/code&gt; subroutine will still be invoked immediately after any filter you install.</source>
          <target state="translated">但是，Filter :: Simple足够聪明，可以注意到您现有的 &lt;code&gt;import&lt;/code&gt; 并使用它来做正确的事。也就是说，如果您在使用Filter :: Simple的程序包中显式定义了 &lt;code&gt;import&lt;/code&gt; 子例程，则在安装任何过滤器后仍将立即调用该 &lt;code&gt;import&lt;/code&gt; 子例程。</target>
        </trans-unit>
        <trans-unit id="c4b48fb21a2bbb8cdba9c4ae239ab0a9635d85aa" translate="yes" xml:space="preserve">
          <source>However, Perl supports Unicode, see &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">但是，Perl支持Unicode，请参阅&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0a6f0fb90e2229030c78d6a2fabfcae7c71bc14e" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nbsp_for_S&lt;/code&gt; option which, if enabled, will suppress all S events, and instead change all spaces in the content to non-breaking spaces. This is intended for formatters that output to a format that has no code that means the same as S&amp;lt;...&amp;gt;, but which has a code/character that means non-breaking space.</source>
          <target state="translated">但是，Pod :: Simple（可能是所有派生的解析器）提供了 &lt;code&gt;nbsp_for_S&lt;/code&gt; 选项，如果启用该选项，它将禁止所有S事件，而是将内容中的所有空格更改为不间断空格。这适用于格式化程序，该格式化程序输出的格式没有与S &amp;lt;...&amp;gt;相同的代码，但具有表示不间断空格的代码/字符。</target>
        </trans-unit>
        <trans-unit id="ebf2ba42f69a41e6f42882a675ee34d4602093f3" translate="yes" xml:space="preserve">
          <source>However, Pod::Simple (and presumably all derived parsers) offers the &lt;code&gt;nix_X_codes&lt;/code&gt; option which, if enabled, will suppress all X events and ignore their content. For formatters/processors that don't use X events, this is presumably quite useful.</source>
          <target state="translated">但是，Pod :: Simple（可能是所有派生的解析器）提供了 &lt;code&gt;nix_X_codes&lt;/code&gt; 选项，如果启用该选项，它将禁止所有X事件并忽略其内容。对于不使用X事件的格式化程序/处理器，这大概很有用。</target>
        </trans-unit>
        <trans-unit id="6aacf8e8d0ef0c63358a4dd55406f6405076e03d" translate="yes" xml:space="preserve">
          <source>However, a dynamically loaded Perl extension is forced to use some symbols from the perl executable, e.g., to know how to find the arguments to the functions: the arguments live on the perl internal evaluation stack. The solution is to put the main code of the interpreter into a DLL, and make the</source>
          <target state="translated">然而,一个动态加载的Perl扩展不得不使用perl可执行文件中的一些符号,例如,要知道如何找到函数的参数:参数活在perl内部的评估栈中。解决的办法是把解释器的主要代码放到一个 DLL 中,然后把它的</target>
        </trans-unit>
        <trans-unit id="cb42fd65a00722a5c95e1e740839f3eb31964f36" translate="yes" xml:space="preserve">
          <source>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</source>
          <target state="translated">然而,错误地应用空间到NBSP的替换可能(错误地)产生与此相当的东西。</target>
        </trans-unit>
        <trans-unit id="81448f13f8166a4612eb5d956580cdb8ee3e6da5" translate="yes" xml:space="preserve">
          <source>However, a value assigned to &lt;code&gt;$(&lt;/code&gt; must be a single number used to set the real gid. So the value given by &lt;code&gt;$(&lt;/code&gt; should</source>
          <target state="translated">但是，分配给 &lt;code&gt;$(&lt;/code&gt; 的值必须是用于设置实际gid的单个数字。因此 &lt;code&gt;$(&lt;/code&gt; 给定的值应</target>
        </trans-unit>
        <trans-unit id="2623bb5aade26c0a0ddb97e7e99b8d0d79bed6e1" translate="yes" xml:space="preserve">
          <source>However, anyone particularly interested in getting the full value of the treelet, can just traverse the content of the treeleet @$treelet_object. To wit:</source>
          <target state="translated">然而,任何特别想得到树状小树的全部价值的人,可以直接遍历树状小树的内容@$treelet_object。即</target>
        </trans-unit>
        <trans-unit id="120fef724fd1ad9704e66311dce9e65e6c74f159" translate="yes" xml:space="preserve">
          <source>However, as an 80% solution it is still effective, as it has caught bugs in the past.</source>
          <target state="translated">不过,作为80%的解决方案,它还是很有效的,因为它过去也抓过BUG。</target>
        </trans-unit>
        <trans-unit id="9b024ed706553b3e26fb5776910e94a5d18ec48c" translate="yes" xml:space="preserve">
          <source>However, be aware this will delete ALL untracked content. You can use</source>
          <target state="translated">然而,请注意,这将删除所有未被跟踪的内容。您可以使用</target>
        </trans-unit>
        <trans-unit id="dc3b493b7bf70efb7fa8d258ead45b41c49f7ae9" translate="yes" xml:space="preserve">
          <source>However, because there are</source>
          <target state="translated">然而,由于有</target>
        </trans-unit>
        <trans-unit id="4c76c10ddfa1b1106d8945288c840e976b5200f2" translate="yes" xml:space="preserve">
          <source>However, before calling Configure, you need to check if using adb is a viable choice in the first place. Because Android doesn't have a</source>
          <target state="translated">不过,在调用Configure之前,你需要先检查一下使用adb是否是一个可行的选择。因为Android没有一个</target>
        </trans-unit>
        <trans-unit id="fa4c0892873afe913676eee2f3455aa2ddb34a7e" translate="yes" xml:space="preserve">
          <source>However, between perl v5.10.0 and v5.24.0, it could be used lexically by writing &lt;code&gt;my $_&lt;/code&gt;. Making &lt;code&gt;$_&lt;/code&gt; refer to the global &lt;code&gt;$_&lt;/code&gt; in the same scope was then possible with &lt;code&gt;our $_&lt;/code&gt;. This experimental feature was removed and is now a fatal error, but you may encounter it in older code.</source>
          <target state="translated">但是，在perl v5.10.0和v5.24.0之间，可以通过编写 &lt;code&gt;my $_&lt;/code&gt; 在词法上使用它。制作 &lt;code&gt;$_&lt;/code&gt; 引用全局 &lt;code&gt;$_&lt;/code&gt; 在同一范围内当时可能与 &lt;code&gt;our $_&lt;/code&gt; 。此实验性功能已被删除，现在是一个致命错误，但是您可能会在较早的代码中遇到它。</target>
        </trans-unit>
        <trans-unit id="fd72d7b069cc72d81b73b3f8597e881a55bd64a6" translate="yes" xml:space="preserve">
          <source>However, calling any &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; methods in such an &lt;code&gt;END&lt;/code&gt; block will most likely</source>
          <target state="translated">但是，最有可能在此类 &lt;code&gt;END&lt;/code&gt; 块中调用任何&lt;a href=&quot;threads&quot;&gt;线程&lt;/a&gt;方法</target>
        </trans-unit>
        <trans-unit id="4d2c94143c1c2488e5582ae3924e1321e1fc2e29" translate="yes" xml:space="preserve">
          <source>However, everything referenced by the returned value is a fresh copy in the joining thread, even if a returned object had in the child thread been a copy of something that previously existed in the parent thread. After joining, the parent will therefore have a duplicate of each such object. This sometimes matters, especially if the object gets mutated; this can especially matter for private data to which a returned subroutine provides access.</source>
          <target state="translated">然而,在加入线程中,所有被返回值引用的东西都是一个新的副本,即使返回的对象在子线程中是父线程中先前存在的东西的副本。因此,在加入之后,父线程将拥有每个这样的对象的副本。这有时很重要,特别是当对象被突变时;这对于返回的子程序提供访问权限的私有数据来说尤其重要。</target>
        </trans-unit>
        <trans-unit id="c314b40d0f00ce73038bbcc98e7f0ca7b1457690" translate="yes" xml:space="preserve">
          <source>However, for the following, the items are already shared, so their references are added directly to the queue, and no cloning takes place:</source>
          <target state="translated">但是,对于下面的项目来说,这些项目已经是共享的,所以它们的引用会直接添加到队列中,而不会发生克隆。</target>
        </trans-unit>
        <trans-unit id="bdc1303f64a141ea4136f512c4911ecba9b92d10" translate="yes" xml:space="preserve">
          <source>However, for the one-off simple case where I don't want to pull out a full templating system, I'll use a string that has two Perl scalar variables in it. In this example, I want to expand &lt;code&gt;$foo&lt;/code&gt; and &lt;code&gt;$bar&lt;/code&gt; to their variable's values:</source>
          <target state="translated">但是，对于一次性的简单情况，我不想使用完整的模板系统，我将使用其中包含两个Perl标量变量的字符串。在此示例中，我想将 &lt;code&gt;$foo&lt;/code&gt; 和 &lt;code&gt;$bar&lt;/code&gt; 扩展为其变量的值：</target>
        </trans-unit>
        <trans-unit id="5ff029079aabc6f922c78c4701467310a318c5e3" translate="yes" xml:space="preserve">
          <source>However, if a Perl script begins with the Unicode &lt;code&gt;BOM&lt;/code&gt; (UTF-16LE, UTF16-BE, or UTF-8), or if the script looks like non-&lt;code&gt;BOM&lt;/code&gt; -marked UTF-16 of either endianness, Perl will correctly read in the script as the appropriate Unicode encoding. (&lt;code&gt;BOM&lt;/code&gt; -less UTF-8 cannot be effectively recognized or differentiated from ISO 8859-1 or other eight-bit encodings.)</source>
          <target state="translated">但是，如果Perl脚本以Unicode &lt;code&gt;BOM&lt;/code&gt; （UTF-16LE，UTF16-BE或UTF-8）开头，或者该脚本看起来像是非 &lt;code&gt;BOM&lt;/code&gt; 表标记的任一字节序的UTF-16，则Perl会正确读取脚本作为适当的Unicode编码。（无 &lt;code&gt;BOM&lt;/code&gt; 的 UTF-8无法有效识别或与ISO 8859-1或其他八位编码区分开。）</target>
        </trans-unit>
        <trans-unit id="7a530119f7016cecda2473b0ac614ce58e818515" translate="yes" xml:space="preserve">
          <source>However, if a particular species of quote character is included in the delimiter specification, then that type of quote will be correctly handled. for example, if &lt;code&gt;$text&lt;/code&gt; is:</source>
          <target state="translated">但是，如果定界符规范中包含特殊种类的引号字符，则将正确处理该类型的引号。例如，如果 &lt;code&gt;$text&lt;/code&gt; 为：</target>
        </trans-unit>
        <trans-unit id="9e2ebae72b3d33fdf44dedb85d641ca00f3f57a1" translate="yes" xml:space="preserve">
          <source>However, if all you want to do is change your time zone, you can probably get away with setting an environment variable:</source>
          <target state="translated">然而,如果你只想改变时区,你也许可以通过设置一个环境变量来解决。</target>
        </trans-unit>
        <trans-unit id="e12d8527d56fa8ab8e8667f75a93e6392109725d" translate="yes" xml:space="preserve">
          <source>However, if hitting EOF is an expected and normal event, you do not want to exit simply because you have run out of input. Instead, you probably just want to exit an input loop. You can then test to see if an actual error has caused the loop to terminate, and act accordingly:</source>
          <target state="translated">然而,如果打到EOF是一个预期和正常的事件,你不希望仅仅因为你已经用完了输入而退出。相反,你可能只是想退出一个输入循环。然后,您可以测试是否有实际错误导致循环终止,并采取相应的行动。</target>
        </trans-unit>
        <trans-unit id="29e1fafc250caebd597211caeac2164bfd06193d" translate="yes" xml:space="preserve">
          <source>However, if the &lt;code&gt;]&lt;/code&gt; is the</source>
          <target state="translated">但是，如果 &lt;code&gt;]&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="8b420ee9db4dd8d8741d24e9570ff42a7cdea42c" translate="yes" xml:space="preserve">
          <source>However, if the command contained arguments that contained whitespace, stringifying the command would lose the significance of the whitespace. Therefore, &lt;code&gt;IPC::Cmd&lt;/code&gt; will quote any arguments containing whitespace in your command if the command is passed as an arrayref and contains special characters.</source>
          <target state="translated">但是，如果命令包含包含空格的参数，则对命令进行字符串化将失去空格的意义。因此，如果命令作为arrayref传递并且包含特殊字符，则 &lt;code&gt;IPC::Cmd&lt;/code&gt; 将在命令中引用任何包含空格的参数。</target>
        </trans-unit>
        <trans-unit id="6cc1c4bf7e539678ba51b5fda046a8f31ec28dde" translate="yes" xml:space="preserve">
          <source>However, if the data can't be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</source>
          <target state="translated">但是,如果数据不能被解析为有效的Perl,那么就会以未解释的字符串形式传递。例如</target>
        </trans-unit>
        <trans-unit id="713c4744650ad1f6870512c16d626634ea8370be" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">但是，如果输入文本在变量中传递，则该变量的 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 值将更新为指向提取的文本之后的第一个字符。这意味着在列表上下文中，可以像正则表达式一样使用各种子例程。例如：</target>
        </trans-unit>
        <trans-unit id="95b66c82de22ae75797335cbe11c9ea09bb6550e" translate="yes" xml:space="preserve">
          <source>However, if the input text was passed in a variable, that variable's &lt;code&gt;pos&lt;/code&gt; value is updated to point at the first character after the extracted text. That means that in a list context the various subroutines can be used much like regular expressions. For example:</source>
          <target state="translated">但是，如果输入文本在变量中传递，则该变量的 &lt;code&gt;pos&lt;/code&gt; 值将更新为指向提取的文本之后的第一个字符。这意味着在列表上下文中，可以像正则表达式一样使用各种子例程。例如：</target>
        </trans-unit>
        <trans-unit id="755d5a289c3e42c14904a4a718307f0b6e480799" translate="yes" xml:space="preserve">
          <source>However, if the kernel set-id script feature isn't disabled, Perl will complain loudly that your set-id script is insecure. You'll need to either disable the kernel set-id script feature, or put a C wrapper around the script. A C wrapper is just a compiled program that does nothing except call your Perl program. Compiled programs are not subject to the kernel bug that plagues set-id scripts. Here's a simple wrapper, written in C:</source>
          <target state="translated">然而,如果内核的set-id脚本功能没有被禁用,Perl会大声抱怨你的set-id脚本不安全。你需要禁用内核 set-id 脚本功能,或者在脚本周围加上一个 C 封装器。C包装器只是一个编译程序,除了调用你的Perl程序之外,什么都不做。编译后的程序不会受到困扰set-id脚本的内核错误的影响。这里有一个简单的封装程序,用C语言写的。</target>
        </trans-unit>
        <trans-unit id="cbc9ddee054ab9351fcec45d24db4192d4d2775c" translate="yes" xml:space="preserve">
          <source>However, if the list element is itself a variable, it appears that you can change a list element. However, the list element is the variable, not the data. You're not changing the list element, but something the list element refers to. The list element itself doesn't change: it's still the same variable.</source>
          <target state="translated">但是,如果列表元素本身是一个变量,似乎可以改变列表元素。但是,列表元素是变量,而不是数据,你改变的不是列表元素,而是列表元素所引用的东西。你不是在改变列表元素,而是在改变列表元素所指向的东西。列表元素本身并没有改变:它仍然是同一个变量。</target>
        </trans-unit>
        <trans-unit id="1ff33c873357001776962a640d53584ca4867e68" translate="yes" xml:space="preserve">
          <source>However, if the string value associated with &amp;lt;reject&amp;gt; is &quot;MAX&quot;, then &lt;code&gt;extract_tagged&lt;/code&gt; returns the complete text up to the point of failure. If the string is &quot;PARA&quot;, &lt;code&gt;extract_tagged&lt;/code&gt; returns only the first paragraph after the tag (up to the first line that is either empty or contains only whitespace characters). If the string is &quot;&quot;, the the default behaviour (i.e. failure) is reinstated.</source>
          <target state="translated">但是，如果与&amp;lt;reject&amp;gt;关联的字符串值是&amp;ldquo; MAX&amp;rdquo;，则 &lt;code&gt;extract_tagged&lt;/code&gt; 返回直到失败点为止的完整文本。如果字符串为&amp;ldquo; PARA&amp;rdquo;，则 &lt;code&gt;extract_tagged&lt;/code&gt; 仅返回标记后的第一段（直到第一行为空或仅包含空格字符）。如果字符串为&amp;ldquo;&amp;rdquo;，则将恢复默认行为（即失败）。</target>
        </trans-unit>
        <trans-unit id="a40e24fb0252cc9815324344313381a888c122c8" translate="yes" xml:space="preserve">
          <source>However, if there is no matching &lt;code&gt;}&lt;/code&gt;, Perl doesn't know if it was mistakenly omitted, or if &lt;code&gt;[^\n]{&lt;/code&gt; was desired, and raises this error. If you meant the former, add the right brace; if you meant the latter, escape the brace with a backslash, like so: &lt;code&gt;\N\{&lt;/code&gt;</source>
          <target state="translated">但是，如果没有匹配的 &lt;code&gt;}&lt;/code&gt; ，Perl将不知道是否错误地省略了它，或者是否需要 &lt;code&gt;[^\n]{&lt;/code&gt; 并引发了此错误。如果您的意思是前者，请添加右大括号；如果您的意思是后者，请使用反斜杠将括号转义，例如： &lt;code&gt;\N\{&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4db7ce89f0ac0ff04237db2ffe65056106401da4" translate="yes" xml:space="preserve">
          <source>However, if you have fixed sized records, then you might do something more like this:</source>
          <target state="translated">然而,如果你有固定大小的记录,那么你可能会做一些更像这样的事情。</target>
        </trans-unit>
        <trans-unit id="f0a31e0971a11a0c1d822f02efd0eb4f79c74f3a" translate="yes" xml:space="preserve">
          <source>However, if you set &quot;_AUTO =&amp;gt; 1&quot; in the %Lexicon in, ThisProject/I18N/en.pm (assuming that English (en) is the language that all your programmers will be using for this project's internal message keys), then you don't ever have to go adding lines like this</source>
          <target state="translated">但是，如果在ThisProject / I18N / en.pm的％Lexicon中设置&amp;ldquo; _AUTO =&amp;gt; 1&amp;rdquo;（假设英语（en）是您的所有程序员将用于该项目的内部消息键的语言），则您不必去添加这样的行</target>
        </trans-unit>
        <trans-unit id="a09363cd76b1dde7e3a57d25fdf3272ced3af2ab" translate="yes" xml:space="preserve">
          <source>However, if you want the old behavior (and think carefully about that because it's a weird side effect), you can pass a hash slice instead. Perl 5.004 didn't make this a special case:</source>
          <target state="translated">然而,如果你想要旧的行为(仔细考虑一下,因为这是一个奇怪的副作用),你可以传递一个哈希片来代替。Perl 5.004并没有把这个作为特殊情况。</target>
        </trans-unit>
        <trans-unit id="e5e7624dee9866ac2811666ebfbf093d8c557c15" translate="yes" xml:space="preserve">
          <source>However, if you'd like to override that just for perl, execute something like the following in</source>
          <target state="translated">然而,如果你想覆盖这一点,只是为了perl,执行下面的内容</target>
        </trans-unit>
        <trans-unit id="c9bcfc80dafa07d27c313feb7344f54609aa72b0" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt; , you can produce a diff like this:</source>
          <target state="translated">但是，如果您不使用git，仍然可以生成合适的补丁。您将需要Perl源的原始副本以进行比较。搬运工更喜欢统一的差异。使用GNU &lt;code&gt;diff&lt;/code&gt; ，您可以产生一个这样的差异：</target>
        </trans-unit>
        <trans-unit id="d3945c60d94533987656e9ddcf44eefd8a3f5cf4" translate="yes" xml:space="preserve">
          <source>However, if you're not using git, you can still produce a suitable patch. You'll need a pristine copy of the Perl source to diff against. The porters prefer unified diffs. Using GNU &lt;code&gt;diff&lt;/code&gt;, you can produce a diff like this:</source>
          <target state="translated">但是，如果您不使用git，则仍然可以生成合适的补丁。您将需要Perl源的原始副本以进行比较。搬运工更喜欢统一的差异。使用GNU &lt;code&gt;diff&lt;/code&gt; ，您可以生成如下所示的diff：</target>
        </trans-unit>
        <trans-unit id="912422cfe6349f661271a697889a1ce04bbb7530" translate="yes" xml:space="preserve">
          <source>However, in list context, the line input operator returns all of the lines as a list. The first line goes into &lt;code&gt;@array[1]&lt;/code&gt; and the rest of the lines mysteriously disappear:</source>
          <target state="translated">但是，在列表上下文中，行输入运算符将所有行作为列表返回。第一行进入 &lt;code&gt;@array[1]&lt;/code&gt; ，其余各行神秘地消失：</target>
        </trans-unit>
        <trans-unit id="a4cbc737f6445190a51915b10ef52747baeb38d6" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt; : it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt; ) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt; . Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">但是，在使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 的情况下：它会影响命令输出的信息性消息，警告消息和错误消息的语言（换句话说，它类似于 &lt;code&gt;LC_MESSAGES&lt;/code&gt; ），但它的优先级高于 &lt;code&gt;LC_ALL&lt;/code&gt; 。而且，它不是单个值，而是一个&amp;ldquo;路径&amp;rdquo;（&amp;ldquo;：&amp;rdquo;分隔列表）</target>
        </trans-unit>
        <trans-unit id="7b6e0b1c8600ac9825ba07e5dbd49e2921e845b8" translate="yes" xml:space="preserve">
          <source>However, in the case you are using &lt;code&gt;LANGUAGE&lt;/code&gt;: it affects the language of informational, warning, and error messages output by commands (in other words, it's like &lt;code&gt;LC_MESSAGES&lt;/code&gt;) but it has higher priority than &lt;code&gt;LC_ALL&lt;/code&gt;. Moreover, it's not a single value but instead a &quot;path&quot; (&quot;:&quot;-separated list) of</source>
          <target state="translated">但是，在使用 &lt;code&gt;LANGUAGE&lt;/code&gt; 的情况下：它会影响命令输出的信息性消息，警告消息和错误消息的语言（换句话说，它类似于 &lt;code&gt;LC_MESSAGES&lt;/code&gt; ），但它的优先级高于 &lt;code&gt;LC_ALL&lt;/code&gt; 。而且，它不是单个值，而是一个&amp;ldquo;路径&amp;rdquo;（&amp;ldquo;：&amp;rdquo;分隔列表）</target>
        </trans-unit>
        <trans-unit id="264a100caceb32bafbc7cc09c2eb6cec03b010a6" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">但是，这确实意味着不能使用 &lt;code&gt;is_deeply()&lt;/code&gt; 之类的函数来测试字符串重载对象的内部。在这种情况下，我建议使用&lt;a href=&quot;Test::Deep&quot;&gt;Test :: Deep&lt;/a&gt;，它包含用于复杂数据结构的更灵活的测试功能。</target>
        </trans-unit>
        <trans-unit id="fdfb88ca6aeb7caca106e8a86ebad4a7bd611554" translate="yes" xml:space="preserve">
          <source>However, it does mean that functions like &lt;code&gt;is_deeply()&lt;/code&gt; cannot be used to test the internals of string overloaded objects. In this case I would suggest &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test::Deep&lt;/a&gt; which contains more flexible testing functions for complex data structures.</source>
          <target state="translated">但是，这确实意味着不能使用 &lt;code&gt;is_deeply()&lt;/code&gt; 之类的函数来测试字符串重载对象的内部。在这种情况下，我建议使用&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Deep&quot;&gt;Test :: Deep&lt;/a&gt;，它包含用于复杂数据结构的更灵活的测试功能。</target>
        </trans-unit>
        <trans-unit id="4b56d396ba6f1980056b816ee33f44e386574d54" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">但是，重要的是要记住，除非操作系统的线程允许，否则Perl线程无法神奇地执行操作。因此，如果您的系统在 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 上阻止了整个过程，那么Perl通常也会这样做。</target>
        </trans-unit>
        <trans-unit id="13d58a858b7bda780cb252aafbed51984ace596c" translate="yes" xml:space="preserve">
          <source>However, it is important to remember that Perl threads cannot magically do things unless your operating system's threads allow it. So if your system blocks the entire process on &lt;code&gt;sleep()&lt;/code&gt;, Perl usually will, as well.</source>
          <target state="translated">但是，请务必记住，除非操作系统的线程允许，否则Perl线程无法神奇地执行操作。因此，如果您的系统在 &lt;code&gt;sleep()&lt;/code&gt; 上阻止了整个过程，那么Perl通常也会这样做。</target>
        </trans-unit>
        <trans-unit id="9d9bc751c2a736800a6ded071584d5744291603c" translate="yes" xml:space="preserve">
          <source>However, it is possible to set up attribute handlers that are called at other points in the program's compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</source>
          <target state="translated">然而,可以通过明确说明希望调用属性处理程序的阶段,来设置在程序编译或执行的其他阶段调用的属性处理程序。例如</target>
        </trans-unit>
        <trans-unit id="9f3f862372589763b899aeb3b91931550dc55057" translate="yes" xml:space="preserve">
          <source>However, it may happen that parsing must be restarted at the beginning when various circumstances occur along the way. An example is if the program turns out to be so large that there are jumps in it that won't fit in the normal 16 bits available. There are two special regops that can hold bigger jump destinations, BRANCHJ and LONGBRANCH. The parse is restarted, and these are used instead of the normal shorter ones. Whenever restarting the parse is required, the function returns failure and sets a flag as to what needs to be done. This is passed up to the top level routine which takes the appropriate action and restarts from scratch. In the case of needing longer jumps, the &lt;code&gt;RExC_use_BRANCHJ&lt;/code&gt; flag is set in the &lt;code&gt;RExC_state_t&lt;/code&gt; structure, which the functions know to inspect before deciding how to do branches.</source>
          <target state="translated">但是，可能会发生各种情况，必须在开始时重新开始分析。一个例子是，如果程序太大，以至于其中的跳转不适合正常的16位可用。有两个可以容纳更大跳跃目标的特殊区域，即BRANCHJ和LONGBRANCH。重新开始解析，并使用它们代替普通的较短的解析。每当需要重新启动解析时，该函数都会返回失败并设置一个有关需要完成的标志。这将传递到顶层例程，该顶层例程将采取适当的措施并从头开始重新启动。在需要较长的跳跃的情况下， &lt;code&gt;RExC_use_BRANCHJ&lt;/code&gt; 标志的设置 &lt;code&gt;RExC_state_t&lt;/code&gt; 结构，功能在决定如何进行分支之前需要检查。</target>
        </trans-unit>
        <trans-unit id="495f4657c76d2b9516ad67652bc58b23f23940a2" translate="yes" xml:space="preserve">
          <source>However, it would be unwise to write tests such as:</source>
          <target state="translated">然而,编写这样的测试是不明智的。</target>
        </trans-unit>
        <trans-unit id="b30399fa602102d2334ab528f7c1b9ececea8d0d" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt; :</source>
          <target state="translated">但是，不可能按此顺序&lt;b&gt;执行&lt;/b&gt;操作：例如，必须先找到 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值，然后再将它们加在一起。因此，运行op树的另一个线程是执行顺序：每个op都有一个 &lt;code&gt;op_next&lt;/code&gt; 字段，该字段指向要运行的下一个op，因此遵循这些指针可以告诉我们perl如何执行代码。我们可以使用 &lt;code&gt;B::Terse&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 选项以此顺序遍历树：</target>
        </trans-unit>
        <trans-unit id="3c7146a5076741d60fd0b54759165e4d154c0a24" translate="yes" xml:space="preserve">
          <source>However, it's impossible to &lt;b&gt;perform&lt;/b&gt; the operations in this order: you have to find the values of &lt;code&gt;$b&lt;/code&gt; and &lt;code&gt;$c&lt;/code&gt; before you add them together, for instance. So, the other thread that runs through the op tree is the execution order: each op has a field &lt;code&gt;op_next&lt;/code&gt; which points to the next op to be run, so following these pointers tells us how perl executes the code. We can traverse the tree in this order using the &lt;code&gt;exec&lt;/code&gt; option to &lt;code&gt;B::Terse&lt;/code&gt;:</source>
          <target state="translated">但是，按此顺序&lt;b&gt;执行&lt;/b&gt;操作是不可能的：例如，必须先将 &lt;code&gt;$b&lt;/code&gt; 和 &lt;code&gt;$c&lt;/code&gt; 的值相加，然后才能将它们加在一起。因此，运行op树的另一个线程是执行顺序：每个op都有一个 &lt;code&gt;op_next&lt;/code&gt; 字段，该字段指向要运行的下一个op，因此遵循这些指针可以告诉我们perl如何执行代码。我们可以使用 &lt;code&gt;B::Terse&lt;/code&gt; 的 &lt;code&gt;exec&lt;/code&gt; 选项按此顺序遍历树：</target>
        </trans-unit>
        <trans-unit id="ae9a82c6ab7917617f6a85766c8d2b1d78c8def0" translate="yes" xml:space="preserve">
          <source>However, it's possible to have distinct files in different directories that intentionally has the same name, just differing in case, that should be reported. Hence, you may force the behavior by setting this to true or false.</source>
          <target state="translated">然而,有可能在不同的目录下有不同的文件,故意有相同的名称,只是不同的情况下,应该报告。因此,你可以通过将此设置为true或false来强制该行为。</target>
        </trans-unit>
        <trans-unit id="5a3fd83f97cb972df229bb4d55a4c188b477d626" translate="yes" xml:space="preserve">
          <source>However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings. Here's a simple example being:</source>
          <target state="translated">然而,长期的经验表明,通过使用可能匹配零长度子串的重复子表达式,可以大大简化许多编程任务。这里有一个简单的例子是。</target>
        </trans-unit>
        <trans-unit id="d855fdc3242b3ecead3a30530ccd98509a636a5c" translate="yes" xml:space="preserve">
          <source>However, not everything you can write in Perl code can be written in the above shorthand system -- not by a long shot. For example, consider the Italian translator from the beginning of this article, who wanted the Italian for &quot;I didn't find any files&quot; as a special case, instead of &quot;I found 0 files&quot;. That couldn't be specified (at least not easily or simply) in our shorthand system, and it would have to be written out in full, like this:</source>
          <target state="translated">然而,并不是所有在Perl代码中可以写的东西都可以用上述速记系统来写--远非如此。例如,考虑一下本文开头的意大利语翻译,他想把 &quot;我没有找到任何文件 &quot;的意大利语作为特例,而不是 &quot;我找到0个文件&quot;。这在我们的速记系统中是无法具体说明的(至少不容易或不简单),必须像这样完整地写出来。</target>
        </trans-unit>
        <trans-unit id="ccc9947a9b58d2f4b1cd78cbf550721e43e5ecea" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt; . If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">但是，请注意， &lt;code&gt;sv_unmagic&lt;/code&gt; 从 &lt;code&gt;SV&lt;/code&gt; 中删除了某种特定 &lt;code&gt;type&lt;/code&gt; 所有魔法。如果只想删除基于魔术虚拟表的某种魔术 &lt;code&gt;type&lt;/code&gt; ，请改用 &lt;code&gt;sv_unmagicext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="755c4cc30c87595f07d149af2b7b703fd4c79822" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;sv_unmagic&lt;/code&gt; removes all magic of a certain &lt;code&gt;type&lt;/code&gt; from the &lt;code&gt;SV&lt;/code&gt;. If you want to remove only certain magic of a &lt;code&gt;type&lt;/code&gt; based on the magic virtual table, use &lt;code&gt;sv_unmagicext&lt;/code&gt; instead:</source>
          <target state="translated">但是，请注意， &lt;code&gt;sv_unmagic&lt;/code&gt; 从 &lt;code&gt;SV&lt;/code&gt; 中删除了某种特定 &lt;code&gt;type&lt;/code&gt; 所有魔法。如果您只想删除基于魔术虚拟表的某种魔术 &lt;code&gt;type&lt;/code&gt; ，请改用 &lt;code&gt;sv_unmagicext&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a0770ad99650293f49eefd8e2631959530003f02" translate="yes" xml:space="preserve">
          <source>However, note that &lt;code&gt;use encoding&lt;/code&gt; actually had three distinct effects:</source>
          <target state="translated">但是，请注意， &lt;code&gt;use encoding&lt;/code&gt; 实际上具有三个不同的效果：</target>
        </trans-unit>
        <trans-unit id="3714710035618507b561178df5f82b541c8974c8" translate="yes" xml:space="preserve">
          <source>However, note that even as the specified layers are &quot;pushed on top&quot; for open() and binmode(), this doesn't mean that the effects are limited to the &quot;top&quot;: PerlIO layers can be very 'active' and inspect and affect layers also deeper in the stack. As an example there is a layer called &quot;raw&quot; which repeatedly &quot;pops&quot; layers until it reaches the first layer that has declared itself capable of handling binary data. The &quot;pushed&quot; layers are processed in left-to-right order.</source>
          <target state="translated">但是,请注意,即使指定的层被 &quot;推到 &quot;open()和binmode()的顶部,这并不意味着影响仅限于 &quot;顶部&quot;。PerlIO 层可以非常 &quot;活跃&quot;,并检查和影响堆栈深处的层。举个例子,有一个叫做 &quot;raw &quot;的层,它反复 &quot;弹出 &quot;层,直到它到达第一个声明自己能够处理二进制数据的层。被 &quot;弹出 &quot;的层按照从左到右的顺序进行处理。</target>
        </trans-unit>
        <trans-unit id="e68001f4c648450ca168ec0cde1c3f91a0e8624c" translate="yes" xml:space="preserve">
          <source>However, on Windows systems this isn't quite true prior to Visual Studio 15, at which point Microsoft fixed a bug. A race can occur if you use the following operations on earlier Windows platforms:</source>
          <target state="translated">然而,在Windows系统上,这在Visual Studio 15之前并不完全正确,此时微软修复了一个bug。如果在早期的Windows平台上使用以下操作,可能会发生竞赛。</target>
        </trans-unit>
        <trans-unit id="237e671ead4e4f448bac6dfef4927434cec18095" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; . This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">但是，在较早的Perls上，或者如果您将字符串传递给功能范围之外的子例程，则可以通过执行 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 将编码更改为UTF-8来强制执行Unicode规则。可以在任何字符串上安全地使用它，因为它可以检查并且不会更改已经升级的字符串。</target>
        </trans-unit>
        <trans-unit id="84e3115d2c9ec337c66cb9d3c294ddc900febcb1" translate="yes" xml:space="preserve">
          <source>However, on earlier Perls, or if you pass strings to subroutines outside the feature's scope, you can force Unicode rules by changing the encoding to UTF-8 by doing &lt;code&gt;utf8::upgrade($string)&lt;/code&gt;. This can be used safely on any string, as it checks and does not change strings that have already been upgraded.</source>
          <target state="translated">但是，在较早的Perls上，或者如果您将字符串传递给功能范围之外的子例程，则可以通过执行 &lt;code&gt;utf8::upgrade($string)&lt;/code&gt; 将编码更改为UTF-8来强制执行Unicode规则。可以在任何字符串上安全地使用它，因为它会检查并且不会更改已升级的字符串。</target>
        </trans-unit>
        <trans-unit id="9d790ef4b7b652054f8ef9f08eabcfceb4c9c9d7" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt; ):</source>
          <target state="translated">但是，只有双引号会&amp;ldquo;插值&amp;rdquo;变量和特殊字符，例如换行符（ &lt;code&gt;\n&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="e743ca902ceb7982199b34d10b972ebd948b6061" translate="yes" xml:space="preserve">
          <source>However, only double quotes &quot;interpolate&quot; variables and special characters such as newlines (&lt;code&gt;\n&lt;/code&gt;):</source>
          <target state="translated">但是，只有双引号会&amp;ldquo;插值&amp;rdquo;变量和特殊字符，例如换行符（ &lt;code&gt;\n&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="cf4f7d0c2e35a50b2d5589c3de0999f54d0755a9" translate="yes" xml:space="preserve">
          <source>However, other accidents of history have made Perl a well-accepted language for design of server-side programs (generally in CGI form) for Web site interfaces. Localization of static pages in Web sites is trivial, feasible either with simple language-negotiation features in servers like Apache, or with some kind of server-side inclusions of language-appropriate text into layout templates. However, I think that the localization of Perl-based search systems (or other kinds of dynamic content) in Web sites, be they public or access-restricted, is where Maketext will see the greatest use.</source>
          <target state="translated">然而,历史上的其他意外使Perl成为设计服务器端程序(一般是CGI形式)的网站界面的一种广为接受的语言。网站中静态页面的本地化是很简单的,可以通过Apache等服务器中简单的语言协商功能,或者通过服务器端在布局模板中加入一些适合语言的文本来实现。然而,我认为,在网站中基于Perl的搜索系统(或其他类型的动态内容)的本地化,无论是公开的还是限制访问的,都是Maketext的最大用途。</target>
        </trans-unit>
        <trans-unit id="5f40951889d3378b60336de3c7c19a48f84efe15" translate="yes" xml:space="preserve">
          <source>However, over the years, changes in gcc, GNU ld, and Solaris ld have made it difficult to automatically detect which ld ultimately gets called. You may have to manually edit config.sh and add the -Wl,-E flags yourself, or else run Configure interactively and add the flags at the appropriate prompts.</source>
          <target state="translated">然而,多年来,gcc、GNU ld和Solaris ld的变化使得自动检测最终被调用的ld变得很困难。你可能需要手动编辑config.sh,然后自己添加-Wl,-E标志,或者交互式运行Configure,在适当的提示下添加标志。</target>
        </trans-unit>
        <trans-unit id="fed61c8dd1afaf8e79d8960756c0fdb435ad95dc" translate="yes" xml:space="preserve">
          <source>However, people often either forget to add &lt;code&gt;BEGIN&lt;/code&gt;, or mistakenly group &lt;code&gt;use_ok&lt;/code&gt; with other tests in a single &lt;code&gt;BEGIN&lt;/code&gt; block, which can create subtle differences in execution order.</source>
          <target state="translated">但是，人们常常忘记添加 &lt;code&gt;BEGIN&lt;/code&gt; ，或者错误地将 &lt;code&gt;use_ok&lt;/code&gt; 与其他测试分组在单个 &lt;code&gt;BEGIN&lt;/code&gt; 块中，这会在执行顺序上产生细微的差异。</target>
        </trans-unit>
        <trans-unit id="7abae8990eb0eaeb22dbcaa2121181a9c3213635" translate="yes" xml:space="preserve">
          <source>However, since I am running a very recent Hurd snapshot, in which a lot of bugs that were exposed by the Perl test suite have been fixed, you may encounter more failures. Likely candidates are: &quot;op/stat&quot;, &quot;lib/io_pipe&quot;, &quot;lib/io_sock&quot;, &quot;lib/io_udp&quot; and &quot;lib/time&quot;.</source>
          <target state="translated">然而,由于我运行的是最近的Hurd快照,其中很多Perl测试套件暴露的bug已经被修复,你可能会遇到更多的故障。可能的原因是 &quot;op/stat&quot;,&quot;lib/io_pipe&quot;,&quot;lib/io_sock&quot;,&quot;lib/io_udp &quot;和 &quot;lib/time&quot;。</target>
        </trans-unit>
        <trans-unit id="0a2932991138cff6cda965e1aa59120419d51793" translate="yes" xml:space="preserve">
          <source>However, since prototype checking happens at compile time, the assignment above happens too late to be of much use. You could address this by putting the whole loop of assignments within a BEGIN block, forcing it to occur during compilation.</source>
          <target state="translated">然而,由于原型检查是在编译时进行的,所以上面的赋值发生得太晚,没有什么用处。你可以把整个赋值循环放在一个BEGIN块中,迫使它在编译时发生,来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="f30360d0680e8617d8855ae3da4bf95cb66d3a40" translate="yes" xml:space="preserve">
          <source>However, since the name is not used by perl except as the return value of &lt;code&gt;caller&lt;/code&gt;, for stack traces or similar, there is no actual requirement that the name be syntactically valid as a perl function name. This could be used to attach extra information that could be useful in debugging stack traces.</source>
          <target state="translated">但是，由于Perl不会使用该名称，而是将其用作 &lt;code&gt;caller&lt;/code&gt; 的返回值（用于堆栈跟踪或类似操作），因此没有实际要求将该名称作为Perl函数名称在语法上有效。这可以用来附加额外的信息，这些信息可能在调试堆栈跟踪中很有用。</target>
        </trans-unit>
        <trans-unit id="f5dc0373ab5a69dc9065fd1361f3fe68378bd857" translate="yes" xml:space="preserve">
          <source>However, some people find that code harder to read than writing it with parentheses:</source>
          <target state="translated">然而,有些人觉得这种代码比用括号写的更难读。</target>
        </trans-unit>
        <trans-unit id="b290a654499ed3de25fe105a7a5f328394110489" translate="yes" xml:space="preserve">
          <source>However, strings composed purely of ASCII code points (&lt;code&gt;0x00&lt;/code&gt;..&lt;code&gt;0x7F&lt;/code&gt;) will</source>
          <target state="translated">但是，仅由ASCII码点（ &lt;code&gt;0x00&lt;/code&gt; .. &lt;code&gt;0x7F&lt;/code&gt; ）组成的字符串将</target>
        </trans-unit>
        <trans-unit id="e33f317ee43849ba21e4562b2cfcaf42b63f23a8" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; to a &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt; , shows up:</source>
          <target state="translated">但是，如果行尾不是换行符，那将不起作用。您可以将 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 更改为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 这样就可以计算输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; 出现的次数：</target>
        </trans-unit>
        <trans-unit id="9245af6fccc9a0ce411947a6accfc71a28fd8594" translate="yes" xml:space="preserve">
          <source>However, that doesn't work if the line ending isn't a newline. You might change that &lt;code&gt;tr///&lt;/code&gt; to a &lt;code&gt;s///&lt;/code&gt; so you can count the number of times the input record separator, &lt;code&gt;$/&lt;/code&gt;, shows up:</source>
          <target state="translated">但是，如果行尾不是换行符，那将不起作用。您可以将 &lt;code&gt;tr///&lt;/code&gt; 更改为 &lt;code&gt;s///&lt;/code&gt; 这样就可以计算输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; 出现的次数：</target>
        </trans-unit>
        <trans-unit id="ff8d86d9a6fdf31c1cce87bc99b477e123d4270e" translate="yes" xml:space="preserve">
          <source>However, the &lt;b&gt;.ph&lt;/b&gt; files almost double in size when built using &lt;b&gt;-h&lt;/b&gt;.</source>
          <target state="translated">但是，使用&lt;b&gt;-h&lt;/b&gt;构建时，&lt;b&gt;.ph&lt;/b&gt;文件的大小几乎增加了一倍。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf442c2f732fb4fe8240d9ec730b9c9278986a2a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;Filter =&amp;gt; 1&lt;/code&gt; flavor of &lt;code&gt;use encoding&lt;/code&gt; will</source>
          <target state="translated">然而， &lt;code&gt;Filter =&amp;gt; 1&lt;/code&gt; 味道的 &lt;code&gt;use encoding&lt;/code&gt; 意愿</target>
        </trans-unit>
        <trans-unit id="dbf1c5152a0ddfa7cc0b45d1130d02f94e11246a" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;W&lt;/code&gt; specifier does operate on whole characters, as does the &lt;code&gt;U&lt;/code&gt; specifier.</source>
          <target state="translated">但是， &lt;code&gt;W&lt;/code&gt; 标识符和 &lt;code&gt;U&lt;/code&gt; 标识符对整个字符都起作用。</target>
        </trans-unit>
        <trans-unit id="3da026c415acace03626d9fb7e1ee90aa243fe42" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">但是，以上用法将在整个程序中创建全局变量，这是不好的编程习惯。 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 创建了词法范围变量。变量的作用域是定义它们的块（即，用大括号括起来的一堆语句）。</target>
        </trans-unit>
        <trans-unit id="38d3383a6acfe85a3e5c76aa619706a45144742d" translate="yes" xml:space="preserve">
          <source>However, the above usage will create global variables throughout your program, which is bad programming practice. &lt;code&gt;my&lt;/code&gt; creates lexically scoped variables instead. The variables are scoped to the block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.</source>
          <target state="translated">但是，以上用法将在整个程序中创建全局变量，这是不好的编程习惯。 &lt;code&gt;my&lt;/code&gt; 创建了词法范围变量。变量的作用域是在其中定义它们的块（即，由大括号包围的一堆语句）。</target>
        </trans-unit>
        <trans-unit id="a041fd9ed4a1cc9a27e266960cf76f5cd2574980" translate="yes" xml:space="preserve">
          <source>However, the behaviour it enables is always performed by &lt;code&gt;IO::Socket::IP&lt;/code&gt;.</source>
          <target state="translated">但是，它启用的行为始终由 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="643bcb3d157afa153f651f6fc7ccfed78f3e704a" translate="yes" xml:space="preserve">
          <source>However, the call in:</source>
          <target state="translated">然而,叫进来的。</target>
        </trans-unit>
        <trans-unit id="5357a547fd30e714675256546afb934f7d52ca74" translate="yes" xml:space="preserve">
          <source>However, the ever-increasing internationalization of the Web (whether measured in terms of amount of content, of numbers of content writers or programmers, or of size of content audiences) makes it increasingly likely that the interface to the average Web-based dynamic content service will be localized for two or maybe three languages. It is my hope that Maketext will make that task as simple as possible, and will remove previous barriers to localization for languages dissimilar to English.</source>
          <target state="translated">然而,随着网络国际化程度的不断提高(无论是从内容的数量,内容作者或程序员的数量,还是内容受众的规模来衡量),使得基于网络的动态内容服务的界面越来越有可能被本地化为两种或三种语言。我希望Maketext能使这项任务尽可能简单,并消除以前对英语以外的语言进行本地化的障碍。</target>
        </trans-unit>
        <trans-unit id="30ecfcc25810d7a7cdf5b6a2a73a83af471c9442" translate="yes" xml:space="preserve">
          <source>However, the generated Perl function is called in very C-ish style:</source>
          <target state="translated">然而,生成的Perl函数是以非常C的风格调用的。</target>
        </trans-unit>
        <trans-unit id="be1c834c7d4d71f52243b42559f80aabe198a844" translate="yes" xml:space="preserve">
          <source>However, the matching position of the input variable would be set to &quot;exit;&quot; (i.e.</source>
          <target state="translated">然而,输入变量的匹配位置将被设置为 &quot;exit;&quot;(即。</target>
        </trans-unit>
        <trans-unit id="25bf3d063af8542ff55fc69607480626e4cfa1dd" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized or assigned to. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">但是,这种分片的结果不能被局部化或分配到。这些在其他方面与使用@符号的哈希分片非常一致。</target>
        </trans-unit>
        <trans-unit id="d95f0313fce5fa0d84ae8a729df3c8f4e82e2159" translate="yes" xml:space="preserve">
          <source>However, the result of such a slice cannot be localized, deleted or used in assignment. These are otherwise very much consistent with hash slices using the @ symbol.</source>
          <target state="translated">但是,这种分片的结果不能被局部化、删除或用于赋值。这些在其他方面与使用@符号的哈希分片非常一致。</target>
        </trans-unit>
        <trans-unit id="c017b28f94bbc1527d3a99433c0d70601c0484be" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt; .</source>
          <target state="translated">但是，快捷方式要求您准确指定两个命令行参数 &lt;code&gt;indirs&lt;/code&gt; 和 &lt;code&gt;outdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b66f8dabd20676d1be94167c3e3005cd50687163" translate="yes" xml:space="preserve">
          <source>However, the shortcut requires that you specify exactly two command-line arguments, &lt;code&gt;indirs&lt;/code&gt; and &lt;code&gt;outdir&lt;/code&gt;.</source>
          <target state="translated">但是，快捷方式要求您确切指定两个命令行参数 &lt;code&gt;indirs&lt;/code&gt; 和 &lt;code&gt;outdir&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8789f7d9a0995a0db12e65eee11cc6c52128e982" translate="yes" xml:space="preserve">
          <source>However, the use of bare v-strings to initialize version objects is &lt;b&gt;strongly&lt;/b&gt; discouraged in all circumstances. Also, bare v-strings are not completely supported in any version of Perl prior to 5.8.1.</source>
          <target state="translated">但是，&lt;b&gt;强烈&lt;/b&gt;建议在所有情况下都不要使用裸露的v字符串初始化版本对象。同样，5.8.1之前的任何版本的Perl都不完全支持裸v字符串。</target>
        </trans-unit>
        <trans-unit id="5988e176ff20437ccf0016e7e2f8d1b308901fa5" translate="yes" xml:space="preserve">
          <source>However, the way a programmer should think about references is not so much in terms of the bare reference count, but in terms of</source>
          <target state="translated">然而,程序员对引用的思考方式不应该是裸露的引用数,而应该是以</target>
        </trans-unit>
        <trans-unit id="174d3b644e004445441e24cae4b9fd65f9fed124" translate="yes" xml:space="preserve">
          <source>However, their are many, many other differences. For example, this works in Perl 5:</source>
          <target state="translated">然而,他们还有很多很多的不同之处。例如,这在Perl 5中就可以工作。</target>
        </trans-unit>
        <trans-unit id="431ca5f68339a06fd3a547e35432cecf8dddda74" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt; . They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt; . Prior to v5.20, It is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; --</source>
          <target state="translated">但是，在某些情况下，这种情况会恶化。某些Perl构造仅用于Unicode，例如 &lt;code&gt;\p{Alpha}&lt;/code&gt; 。他们假设0xD7始终具有其Unicode含义（或EBCDIC平台上的等效含义）。由于Latin1是Unicode的子集，而0xD7是Latin1和Unicode中的乘法符号，因此 &lt;code&gt;\p{Alpha}&lt;/code&gt; 将永远不会与之匹配，而与语言环境无关。 &lt;code&gt;\N{...}&lt;/code&gt; 也会发生类似的问题。在v5.20之前，因此在普通 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 区域设置中使用 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\N{}&lt;/code&gt; 是个坏主意-</target>
        </trans-unit>
        <trans-unit id="bfffc2a487e4695cb332617a58fbff944ca5de8f" translate="yes" xml:space="preserve">
          <source>However, there are places where this breaks down. Certain Perl constructs are for Unicode only, such as &lt;code&gt;\p{Alpha}&lt;/code&gt;. They assume that 0xD7 always has its Unicode meaning (or the equivalent on EBCDIC platforms). Since Latin1 is a subset of Unicode and 0xD7 is the multiplication sign in both Latin1 and Unicode, &lt;code&gt;\p{Alpha}&lt;/code&gt; will never match it, regardless of locale. A similar issue occurs with &lt;code&gt;\N{...}&lt;/code&gt;. Prior to v5.20, it is therefore a bad idea to use &lt;code&gt;\p{}&lt;/code&gt; or &lt;code&gt;\N{}&lt;/code&gt; under plain &lt;code&gt;use locale&lt;/code&gt;--</source>
          <target state="translated">但是，在某些情况下，这种情况会恶化。某些Perl构造仅适用于Unicode，例如 &lt;code&gt;\p{Alpha}&lt;/code&gt; 。他们假设0xD7始终具有其Unicode含义（或EBCDIC平台上的等效含义）。由于Latin1是Unicode的子集，而0xD7是Latin1和Unicode中的乘法符号，因此 &lt;code&gt;\p{Alpha}&lt;/code&gt; 将永远不会与之匹配，而与语言环境无关。 &lt;code&gt;\N{...}&lt;/code&gt; 也会发生类似的问题。在v5.20之前，因此在普通 &lt;code&gt;use locale&lt;/code&gt; 下使用 &lt;code&gt;\p{}&lt;/code&gt; 或 &lt;code&gt;\N{}&lt;/code&gt; 是个坏主意-</target>
        </trans-unit>
        <trans-unit id="79a79d341666f9d08432041587a457666ea4e643" translate="yes" xml:space="preserve">
          <source>However, there is a third way: perl DLL exports the main() function and several callbacks to customize the search path. Below is a complete example of a &quot;Perl loader&quot; which</source>
          <target state="translated">然而,还有第三种方法:perl DLL导出main()函数和几个回调来定制搜索路径。下面是一个完整的 &quot;Perl加载器 &quot;的例子,它的作用是</target>
        </trans-unit>
        <trans-unit id="167fa8624f523d65d674923630d20eace6f440ad" translate="yes" xml:space="preserve">
          <source>However, there is one other function which manipulates the reference count of its argument. The &lt;code&gt;newRV_inc&lt;/code&gt; function, you will recall, creates a reference to the specified argument. As a side effect, it increments the argument's reference count. If this is not what you want, use &lt;code&gt;newRV_noinc&lt;/code&gt; instead.</source>
          <target state="translated">但是，还有另一个函数可操纵其参数的引用计数。该 &lt;code&gt;newRV_inc&lt;/code&gt; 功能，你会记得，创建到指定参数的引用。副作用是，它增加了参数的引用计数。如果这不是您想要的，请改用 &lt;code&gt;newRV_noinc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a934c497d33c3b96a41f7573fdbc88756bd17bf7" translate="yes" xml:space="preserve">
          <source>However, these filepaths appear in the list returned by &lt;code&gt;standard_typemap_locations()&lt;/code&gt; in reverse order,</source>
          <target state="translated">但是，这些文件路径以相反的顺序出现在 &lt;code&gt;standard_typemap_locations()&lt;/code&gt; 返回的列表中，</target>
        </trans-unit>
        <trans-unit id="78acaa936efa9d2893b28f11a288123a0f9298ff" translate="yes" xml:space="preserve">
          <source>However, these two XSUBs provide almost identical generated C code: &lt;b&gt;xsubpp&lt;/b&gt; compiler is smart enough to figure out the &lt;code&gt;CODE:&lt;/code&gt; section from the first two lines of the description of XSUB. What about &lt;code&gt;OUTPUT:&lt;/code&gt; section? In fact, that is absolutely the same! The &lt;code&gt;OUTPUT:&lt;/code&gt; section can be removed as well,</source>
          <target state="translated">但是，这两个&lt;b&gt;XSUB&lt;/b&gt;提供了几乎相同的生成C代码：&lt;b&gt;xsubpp&lt;/b&gt;编译器足够聪明，可以从XSUB描述的前两行找出 &lt;code&gt;CODE:&lt;/code&gt; 部分。什么 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分？实际上，那绝对是一样的！的 &lt;code&gt;OUTPUT:&lt;/code&gt; 部分也可被移除，</target>
        </trans-unit>
        <trans-unit id="84b8501e3adfdc161bae2d83215ead9cfc2ea49b" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;a href=&quot;File::Spec::Unix#canonpath%28%29&quot;&gt;&quot;canonpath()&quot; in File::Spec::Unix&lt;/a&gt;. If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">但是，这种方法仅限于&amp;ldquo; root&amp;rdquo;之后的第一个参数（同样，请参见&lt;a href=&quot;File::Spec::Unix#canonpath%28%29&quot;&gt;File :: Spec :: Unix中的&amp;ldquo; canonpath（）&amp;rdquo;&lt;/a&gt;。如果有更多参数在目录树中向上移动，则无效的路径将超出root可以创建。</target>
        </trans-unit>
        <trans-unit id="8993e8546f1a446361af9208f62149f37c72c7da" translate="yes" xml:space="preserve">
          <source>However, this approach is limited to the first arguments following &quot;root&quot; (again, see &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ). If there are more arguments that move up the directory tree, an invalid path going beyond root can be created.</source>
          <target state="translated">但是，这种方法仅限于&amp;ldquo; root&amp;rdquo;之后的第一个参数（同样，请参见 &lt;code&gt;Unix-&amp;gt;canonpath()&lt;/code&gt; ）。如果有更多的参数在目录树中上移，则可以创建超出根目录的无效路径。</target>
        </trans-unit>
        <trans-unit id="5458eab9c28fdf9d40e7593c2500908102783b51" translate="yes" xml:space="preserve">
          <source>However, this feature was undeprecated in Perl 5.24.</source>
          <target state="translated">然而,这个特性在Perl 5.24中是未被解释的。</target>
        </trans-unit>
        <trans-unit id="f01b858fc25bd1ebdcf816e174585aed80aab581" translate="yes" xml:space="preserve">
          <source>However, this function may return a Unicode string if the environment variable being expanded hasn't been assigned to via %ENV. Access to %ENV is currently always using byte semantics.</source>
          <target state="translated">但是,如果被扩展的环境变量没有通过%ENV分配到,这个函数可能返回一个Unicode字符串。目前对%ENV的访问总是使用字节语义。</target>
        </trans-unit>
        <trans-unit id="7865ef8ee24a1f53476e6455eeebeda223f24ca5" translate="yes" xml:space="preserve">
          <source>However, this only does what you mean if &lt;code&gt;$init_fields&lt;/code&gt; is indeed a hash reference. The condition &lt;code&gt;$init_fields ~~ $REQUIRED_FIELDS&lt;/code&gt; also allows the strings &lt;code&gt;&quot;name&quot;&lt;/code&gt;, &lt;code&gt;&quot;rank&quot;&lt;/code&gt;, &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; as well as any array reference that contains &lt;code&gt;&quot;name&quot;&lt;/code&gt; or &lt;code&gt;&quot;rank&quot;&lt;/code&gt; or &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; anywhere to pass through.</source>
          <target state="translated">但是，仅当 &lt;code&gt;$init_fields&lt;/code&gt; 确实是哈希引用时，这才符合您的意思。条件 &lt;code&gt;$init_fields ~~ $REQUIRED_FIELDS&lt;/code&gt; 也允许字符串 &lt;code&gt;&quot;name&quot;&lt;/code&gt; ， &lt;code&gt;&quot;rank&quot;&lt;/code&gt; ， &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; 以及任何包含 &lt;code&gt;&quot;name&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;rank&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;serial_num&quot;&lt;/code&gt; 数组引用在任何地方传递。</target>
        </trans-unit>
        <trans-unit id="29b29d0e56857b797fbe9046c1637ec13ba0255e" translate="yes" xml:space="preserve">
          <source>However, this produces a list of temporary integer values as long as the original list of strings, only to reduce it down to a single value again. We can compute the same result more efficiently by using &lt;code&gt;reduce&lt;/code&gt; with a code block that accumulates lengths by writing this instead as:</source>
          <target state="translated">但是，这将生成一个与字符串原始列表一样长的临时整数值列表，只是将其再次减小为单个值。通过将 &lt;code&gt;reduce&lt;/code&gt; 与代码块结合使用，我们可以更有效地计算相同的结果，该代码块通过将其写成以下代码来累积长度：</target>
        </trans-unit>
        <trans-unit id="a498e0a44f0f9f8fbe6e40968d0b21c8d56b2479" translate="yes" xml:space="preserve">
          <source>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</source>
          <target state="translated">但是,这个请求被忽略了,因为现在的代码使用低级数学库直接存储数字部分。</target>
        </trans-unit>
        <trans-unit id="6b7469fc2b44cf29dd35f31f1f2fa503b7de276c" translate="yes" xml:space="preserve">
          <source>However, this silent upgrading can easily cause problems, if you happen to mix unicode strings with non-Latin1 data -- i.e. byte-strings encoded in UTF-8 or other encodings. The error will not manifest until the combined string is written to output, at which time it would be impossible to see where did the silent upgrading occur.</source>
          <target state="translated">然而,如果你碰巧将unicode字符串与非Latin1数据--即UTF-8或其他编码的字节字符串--混合在一起,这种无声升级很容易造成问题。这个错误不会表现出来,直到合并后的字符串被写入输出,这时就不可能看到哪里发生了无声升级。</target>
        </trans-unit>
        <trans-unit id="1c442891dca9145a3b9c79c668f4b9ec23f39a60" translate="yes" xml:space="preserve">
          <source>However, this still does not guarantee that these DLL may be loaded. The reason is the mangling of the name of the</source>
          <target state="translated">但是,这仍然不能保证这些DLL可以被加载。其原因是将DLL的名称弄错了。</target>
        </trans-unit>
        <trans-unit id="2084b9ad89039a2ea6c4200ac2905bee170c22b7" translate="yes" xml:space="preserve">
          <source>However, to help ease understanding, it is suggested that you place a &quot;&amp;amp;&quot; next to the variable name and away from the variable type), and place a &quot;*&quot; near the variable type, but away from the variable name (as in the call to foo above). By doing so, it is easy to understand exactly what will be passed to the C function; it will be whatever is in the &quot;last column&quot;.</source>
          <target state="translated">但是，为帮助您理解，建议您在变量名旁边放置一个&amp;ldquo;＆&amp;rdquo;并远离变量类型），并在变量类型附近放置一个&amp;ldquo; *&amp;rdquo;，但要远离变量名称（例如上面对foo的调用）。这样，很容易准确地了解将传递给C函数的内容。这将是&amp;ldquo;最后一列&amp;rdquo;中的内容。</target>
        </trans-unit>
        <trans-unit id="ae3f94bdf7ac1269b60e51c2ce0911730992c14a" translate="yes" xml:space="preserve">
          <source>However, under some circumstances, this behavior may be excessively slow. For example, suppose you have a million-record file, and you want to do:</source>
          <target state="translated">然而,在某些情况下,这种行为可能会过于缓慢。例如,假设你有一个百万记录的文件,而你想做。</target>
        </trans-unit>
        <trans-unit id="37cab8dafbfef6134cbae52136465a602af12595" translate="yes" xml:space="preserve">
          <source>However, unless you tell &lt;code&gt;Memoize&lt;/code&gt; that these calls are equivalent, it will not know that, and it will compute the values for these invocations of your function separately, and store them separately.</source>
          <target state="translated">但是，除非您告诉 &lt;code&gt;Memoize&lt;/code&gt; 这些调用是等效的，否则它将不会知道，并且它将分别计算函数的这些调用的值，并将它们分别存储。</target>
        </trans-unit>
        <trans-unit id="142779c491fb94a0d076da32b3296ae6b26999c0" translate="yes" xml:space="preserve">
          <source>However, up through v5.20, Perl initialized things on start-up so that &lt;code&gt;LC_NUMERIC&lt;/code&gt; was set to the &quot;C&quot; locale. But if any code anywhere changed it, it would stay changed. This means that your module can't count on &lt;code&gt;LC_NUMERIC&lt;/code&gt; being something in particular, and you can't expect floating point numbers (including version strings) to have dots in them. If you don't allow for a non-dot, your code could break if anyone anywhere changed the locale. For this reason, v5.22 changed the behavior so that Perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the &quot;C&quot; locale except around the operations internally where it should be something else. Misbehaving XS code will always be able to change the locale anyway, but the most common instance of this is checked for and handled.</source>
          <target state="translated">但是，从v5.20开始，Perl在启动时初始化了事情，因此 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 设置为&amp;ldquo; C&amp;rdquo;语言环境。但是，如果任何代码在任何地方进行了更改，它将保持不变。这意味着您的模块不能指望 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 特别重要，并且您不能期望浮点数（包括版本字符串）中包含点。如果您不允许使用非圆点，那么任何地方的任何人更改语言环境都可能会破坏您的代码。因此，v5.22更改了行为，以使Perl尝试将 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 保留在&amp;ldquo; C&amp;rdquo;语言环境中，但内部操作周围应保留其他内容。行为不当的XS代码始终总是能够更改语言环境，但是会检查并处理这种情况的最常见实例。</target>
        </trans-unit>
        <trans-unit id="068b747d32004750485efe98f8d1cbafa2e0e35a" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;&amp;amp;&lt;/code&gt; in the call still overrides the prototype of &lt;code&gt;foo&lt;/code&gt; if present:</source>
          <target state="translated">但是，在调用中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 仍会覆盖 &lt;code&gt;foo&lt;/code&gt; 的原型（如果存在）：</target>
        </trans-unit>
        <trans-unit id="f9fabcfc6b8511bdc0a7ecd34a3e04f701d2b56e" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt; , or &lt;code&gt;\x0D\x0A&lt;/code&gt; ) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;code&gt;Socket&lt;/code&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">但是，使用 &lt;code&gt;\015\012&lt;/code&gt; （或 &lt;code&gt;\cM\cJ&lt;/code&gt; 或 &lt;code&gt;\x0D\x0A&lt;/code&gt; ）可能既乏味又难看，并且会使维护代码的人感到困惑。因此， &lt;code&gt;Socket&lt;/code&gt; 模块为需要的人提供了正确的东西。</target>
        </trans-unit>
        <trans-unit id="bc2515b31d0fe90459c261be099beca3ae68dad0" translate="yes" xml:space="preserve">
          <source>However, using &lt;code&gt;\015\012&lt;/code&gt; (or &lt;code&gt;\cM\cJ&lt;/code&gt;, or &lt;code&gt;\x0D\x0A&lt;/code&gt;) can be tedious and unsightly, as well as confusing to those maintaining the code. As such, the &lt;a href=&quot;socket&quot;&gt;&lt;code&gt;Socket&lt;/code&gt;&lt;/a&gt; module supplies the Right Thing for those who want it.</source>
          <target state="translated">但是，使用 &lt;code&gt;\015\012&lt;/code&gt; （或 &lt;code&gt;\cM\cJ&lt;/code&gt; 或 &lt;code&gt;\x0D\x0A&lt;/code&gt; ）可能既乏味又难看，并且会使那些维护代码的人感到困惑。因此，&lt;a href=&quot;socket&quot;&gt; &lt;code&gt;Socket&lt;/code&gt; &lt;/a&gt;模块为需要的人提供了正确的东西。</target>
        </trans-unit>
        <trans-unit id="163537b4f5c11cd47e9722700a60c6c7ea0ade4a" translate="yes" xml:space="preserve">
          <source>However, using the code requires that you have a working C compiler and can use it to build and install a CPAN module. Here's a solution using the standard &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module, which is already on your system (assuming your system supports POSIX).</source>
          <target state="translated">但是，使用代码要求您具有有效的C编译器，并且可以使用它来构建和安装CPAN模块。这是使用标准&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块的解决方案，该模块已经在您的系统上（假设您的系统支持POSIX）。</target>
        </trans-unit>
        <trans-unit id="a4350da00ad3028f4efc1846f8fc750c07ee286a" translate="yes" xml:space="preserve">
          <source>However, when it's a list-context assignment and you're trying to use &lt;code&gt;||&lt;/code&gt; for control flow, you probably need &lt;code&gt;&quot;or&quot;&lt;/code&gt; so that the assignment takes higher precedence.</source>
          <target state="translated">但是，当它是一个列表上下文分配并且您尝试使用 &lt;code&gt;||&lt;/code&gt; 时。对于控制流，您可能需要使用 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 以便分配具有更高的优先级。</target>
        </trans-unit>
        <trans-unit id="b662692b6fa64e61f6a9c3f800af2536f40b3b4a" translate="yes" xml:space="preserve">
          <source>However, when you</source>
          <target state="translated">然而,当你</target>
        </trans-unit>
        <trans-unit id="41f9727ede39a1ce5211e24f06cf1afdd8d7ee83" translate="yes" xml:space="preserve">
          <source>However, you can change the way an object is smartmatched by overloading the &lt;code&gt;~~&lt;/code&gt; operator. This is allowed to extend the usual smartmatch semantics. For objects that do have an &lt;code&gt;~~&lt;/code&gt; overload, see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">但是，您可以通过重载 &lt;code&gt;~~&lt;/code&gt; 运算符来更改对象智能匹配的方式。这允许扩展通常的smartmatch语义。对于确实具有 &lt;code&gt;~~&lt;/code&gt; 重载的对象，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b89d0d284e64c095a60bef4f1dd049a654a9b8f4" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">但是，可以抑制 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 通过使用一个明确的，空的导入列表。这两个仍然在编译时发生：</target>
        </trans-unit>
        <trans-unit id="260fe9f97d0d69a65905fdc8f061356d4780ef04" translate="yes" xml:space="preserve">
          <source>However, you can suppress the &lt;code&gt;import&lt;/code&gt; by using an explicit, empty import list. Both of these still happen at compile-time:</source>
          <target state="translated">但是，可以抑制 &lt;code&gt;import&lt;/code&gt; 通过使用一个明确的，空的导入列表。这两个仍然在编译时发生：</target>
        </trans-unit>
        <trans-unit id="2eb959e8b316e23c060bb14a1aa10ea6663e7a66" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt; . We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">但是，在使用持久性解释器时，您必须对名称空间和变量作用域更加谨慎。在前面的示例中，我们一直在默认包 &lt;code&gt;main&lt;/code&gt; 中使用全局变量。我们确切地知道将运行什么代码，并假设我们可以避免变量冲突和令人讨厌的符号表增长。</target>
        </trans-unit>
        <trans-unit id="f80e0acb7e372dabc4a5f7b74c6498f8798ef7a3" translate="yes" xml:space="preserve">
          <source>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we've been using global variables in the default package &lt;code&gt;main&lt;/code&gt;. We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</source>
          <target state="translated">但是，在使用持久性解释器时，您必须对名称空间和变量作用域更加谨慎。在前面的示例中，我们一直在默认包 &lt;code&gt;main&lt;/code&gt; 中使用全局变量。我们确切地知道将运行什么代码，并假设我们可以避免变量冲突和令人讨厌的符号表增长。</target>
        </trans-unit>
        <trans-unit id="e66a879553ebe7b620fa37901232bfb863aa6d3d" translate="yes" xml:space="preserve">
          <source>However, you may know that you intend to use the results in a particular context, where some pragmas are already in scope. In this case, you use the &lt;b&gt;ambient_pragmas&lt;/b&gt; method to describe the assumptions you wish to make.</source>
          <target state="translated">但是，您可能知道您打算在特定的上下文中使用结果，其中某些杂物已经存在。在这种情况下，您可以使用&lt;b&gt;ambient_pragmas&lt;/b&gt;方法来描述您要进行的假设。</target>
        </trans-unit>
        <trans-unit id="13143a50c1533ee9fae63ea9ed2eae1b6ad85192" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">但是，如果您希望这意味着另一面有一个真实的人，那么您可能会不走运。使用&lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt;模块，另一个程序可以伪装成一个人。该程序甚至可能接近通过图灵测试。</target>
        </trans-unit>
        <trans-unit id="56cfa87ada9834b01835bf9c64cf509441054b7b" translate="yes" xml:space="preserve">
          <source>However, you might be out of luck if you expect that means there is a real person on the other side. With the &lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt; module, another program can pretend to be a person. The program might even come close to passing the Turing test.</source>
          <target state="translated">但是，如果您期望那意味着另一边有一个真实的人，那么您可能会不走运。使用&lt;a href=&quot;http://search.cpan.org/perldoc/Expect&quot;&gt;Expect&lt;/a&gt;模块，另一个程序可以伪装成一个人。该程序甚至可能接近通过图灵测试。</target>
        </trans-unit>
        <trans-unit id="a422dec568026043ae4e005023457a913a05b272" translate="yes" xml:space="preserve">
          <source>However, you must not do this, for example:</source>
          <target state="translated">但是,你千万不要这样做,比如说。</target>
        </trans-unit>
        <trans-unit id="e3a4e64a25b29be20841a60bc10f2c0bc37e06f9" translate="yes" xml:space="preserve">
          <source>However, you should &lt;b&gt;not&lt;/b&gt; blindly rely on perl always doing the right thing. Particularly, perl will mistakenly return true when you clear the hash by repeatedly calling DELETE until it is empty. You are therefore advised to supply your own SCALAR method when you want to be absolutely sure that your hash behaves nicely in scalar context.</source>
          <target state="translated">但是，你应该&lt;b&gt;不会&lt;/b&gt;一味依赖Perl的总是做正确的事。特别是，当您通过重复调用DELETE直到其为空而清除哈希时，perl将错误地返回true。因此，当您要绝对确保哈希在标量上下文中表现良好时，建议您提供自己的SCALAR方法。</target>
        </trans-unit>
        <trans-unit id="684d82ac83a5f8790e5e4368c88d7c77aa0309c6" translate="yes" xml:space="preserve">
          <source>Hub ID of the hub that is represented in the parent-child relationship.</source>
          <target state="translated">父子关系中所代表的枢纽ID。</target>
        </trans-unit>
        <trans-unit id="b42118b9b162322837f3cc4bb7657481f703e832" translate="yes" xml:space="preserve">
          <source>Hub subclasses (and some hub utility objects) live under this namespace. It is perfectly reasonable for third party distributions to add new hub subclasses in this namespace.</source>
          <target state="translated">集线器子类(和一些集线器实用对象)都在这个命名空间中。第三方发行版在这个命名空间中添加新的枢纽子类是完全合理的。</target>
        </trans-unit>
        <trans-unit id="2a802db1cd7382689ea166fa197e7bee4e5a74a9" translate="yes" xml:space="preserve">
          <source>Hub used by interceptor to grab results.</source>
          <target state="translated">拦截器用来抓取结果的枢纽。</target>
        </trans-unit>
        <trans-unit id="f64bf0d9364108763162c7fb9f03b312d24f14b0" translate="yes" xml:space="preserve">
          <source>Hub used by subtests</source>
          <target state="translated">子测试使用的枢纽</target>
        </trans-unit>
        <trans-unit id="59d2100593fec39720245432930b526325693698" translate="yes" xml:space="preserve">
          <source>Hugo van der Sanden &amp;lt;hv@crypt0.demon.co.uk&amp;gt;</source>
          <target state="translated">雨果&amp;middot;范德&amp;middot;桑登&amp;lt;hv@crypt0.demon.co.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="903a8361b68cfddd3da7251d755007dc0e94f5d3" translate="yes" xml:space="preserve">
          <source>Human readable description of the assertion.</source>
          <target state="translated">人可读的说法说明。</target>
        </trans-unit>
        <trans-unit id="3eba29a5d2ddda0020c1cac7fb53eb47535a92ce" translate="yes" xml:space="preserve">
          <source>Human readable description of the event.</source>
          <target state="translated">对事件的可读性描述:</target>
        </trans-unit>
        <trans-unit id="9606d069fe25297dd11df0cc8580ee8dbe3f85e7" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the plan being set. This is normally not rendered by most formatters except when the &lt;code&gt;skip&lt;/code&gt; field is also set.</source>
          <target state="translated">易于理解的计划设置说明。通常，大多数格式设置程序都不会呈现此格式，除非还设置了 &lt;code&gt;skip&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="bc1a79a67a1a08817e952e2d08177e5fbf4cba31" translate="yes" xml:space="preserve">
          <source>Human readable explanation for the special behavior.</source>
          <target state="translated">人类对特殊行为的可读解释。</target>
        </trans-unit>
        <trans-unit id="f687605c0577ef885ee45c1c086d0ad37ee205b5" translate="yes" xml:space="preserve">
          <source>Human readable explanation of why amnesty was granted.</source>
          <target state="translated">以人为本的方式解释为什么给予大赦。</target>
        </trans-unit>
        <trans-unit id="6b2aebac92e9a840f478fce4b6343c22b8d0ca60" translate="yes" xml:space="preserve">
          <source>Human readable string or data structure, this is the information to display. Formatters are free to render the structures however they please. This may contain a blessed object.</source>
          <target state="translated">人类可读的字符串或数据结构,这就是要显示的信息。格式化者可以自由地按照自己的意愿来呈现这些结构。这可能包含一个祝福对象。</target>
        </trans-unit>
        <trans-unit id="6a9d2d17793130f2e86c0885a2d78da3c7f24dc7" translate="yes" xml:space="preserve">
          <source>Human readable text for display.</source>
          <target state="translated">人可读的文字显示。</target>
        </trans-unit>
        <trans-unit id="f14e46ce7d094f9326167acc499698128651be85" translate="yes" xml:space="preserve">
          <source>Hungary</source>
          <target state="translated">Hungary</target>
        </trans-unit>
        <trans-unit id="1938ed7c63e01c8a596d909427e34650befec480" translate="yes" xml:space="preserve">
          <source>HvENAME</source>
          <target state="translated">HvENAME</target>
        </trans-unit>
        <trans-unit id="6d3ea3f5bd46317a0b128c10a43f2b6c88d4d4cb" translate="yes" xml:space="preserve">
          <source>HvENAMELEN</source>
          <target state="translated">HvENAMELEN</target>
        </trans-unit>
        <trans-unit id="867db34eff4673062e6b813ed04df520c5233a3d" translate="yes" xml:space="preserve">
          <source>HvENAMEUTF8</source>
          <target state="translated">HvENAMEUTF8</target>
        </trans-unit>
        <trans-unit id="df110dc29f38c56ef4eec2b4759e744b23e69e1f" translate="yes" xml:space="preserve">
          <source>HvFILL</source>
          <target state="translated">HvFILL</target>
        </trans-unit>
        <trans-unit id="d18ff5331b7e22893e39912957fedf5b97c67829" translate="yes" xml:space="preserve">
          <source>HvNAME</source>
          <target state="translated">HvNAME</target>
        </trans-unit>
        <trans-unit id="9c77eb3e074087eb866a360b06af707ee5df0f01" translate="yes" xml:space="preserve">
          <source>HvNAMELEN</source>
          <target state="translated">HvNAMELEN</target>
        </trans-unit>
        <trans-unit id="c5d2d62591fdff3694f9b23256ac71f286680b41" translate="yes" xml:space="preserve">
          <source>HvNAMEUTF8</source>
          <target state="translated">HvNAMEUTF8</target>
        </trans-unit>
        <trans-unit id="9711a7cfeff071972d36fdd6050e80bc9d749c0b" translate="yes" xml:space="preserve">
          <source>Hyperlinks</source>
          <target state="translated">Hyperlinks</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="68ea31ac882843ca3bb7347afdcbec874605911e" translate="yes" xml:space="preserve">
          <source>I almost always use keys that are themselves valid lexicon values. One notable exception is when the value is quite long. For example, to get the screenful of data that a command-line program might return when given an unknown switch, I often just use a brief, self-explanatory key such as &quot;_USAGE_MESSAGE&quot;. At that point I then go and immediately to define that lexicon entry in the ProjectClass::L10N::en lexicon (since English is always my &quot;project language&quot;):</source>
          <target state="translated">我几乎总是使用本身就是有效词典值的键。一个明显的例外是当值相当长时。例如,为了得到命令行程序在给定一个未知开关时可能返回的满屏数据,我经常只使用一个简短的、不言自明的键,如&quot;_USAGE_MESSAGE&quot;。这时,我就会立即去在ProjectClass::L10N::en词库中定义该词条(因为英语一直是我的 &quot;项目语言&quot;)。</target>
        </trans-unit>
        <trans-unit id="bd142ae3cc7adab96cfaa7558d02068b158e85c3" translate="yes" xml:space="preserve">
          <source>I am also usually active on IRC as 'autarch' on &lt;code&gt;irc://irc.perl.org&lt;/code&gt;.</source>
          <target state="translated">我通常也以 &lt;code&gt;irc://irc.perl.org&lt;/code&gt; 上的&amp;ldquo; autarch&amp;rdquo;身份活跃于IRC 。</target>
        </trans-unit>
        <trans-unit id="5e1174e9f9955c9e61d54f218d08d7285e0e0ae8" translate="yes" xml:space="preserve">
          <source>I am behind a SOCKS firewall, but the Firewall option does not work ?</source>
          <target state="translated">我在SOCKS防火墙后面,但防火墙选项不能使用?</target>
        </trans-unit>
        <trans-unit id="99b0de54116e38392536f989ded25ad9bceea24f" translate="yes" xml:space="preserve">
          <source>I am behind an FTP proxy firewall, but cannot access machines outside ?</source>
          <target state="translated">我在FTP代理防火墙后面,但不能访问外面的机器?</target>
        </trans-unit>
        <trans-unit id="a12498934a0d4cbe958ea9ae2277b44bccce11e2" translate="yes" xml:space="preserve">
          <source>I am not root, how can I install a module in a personal directory?</source>
          <target state="translated">我不是root,如何在个人目录下安装模块?</target>
        </trans-unit>
        <trans-unit id="720225fb87f4fceb999d3d3c67fa208ed54fe066" translate="yes" xml:space="preserve">
          <source>I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</source>
          <target state="translated">我相信代码中一定会有错误。如果你确实发现了任何错误,或者可以提出任何改进建议,我欢迎你的评论。</target>
        </trans-unit>
        <trans-unit id="f822dc00911ca2b5b17523234c19e71174239e30" translate="yes" xml:space="preserve">
          <source>I assume that each language class derives (directly or indirectly) from your project class, and also defines its @ISA, its %Lexicon, or both. But I anticipate no dire consequences if these assumptions do not hold.</source>
          <target state="translated">我假设每个语言类都从你的项目类派生出来(直接或间接),并且也定义了它的@ISA,%Lexicon,或者两者都有。但如果这些假设不成立,我预计不会有什么可怕的后果。</target>
        </trans-unit>
        <trans-unit id="aac2738433180b0fc7eec7ab6421ac5a20b62f00" translate="yes" xml:space="preserve">
          <source>I believe this issue is prevalent not only for Mac Indics but also in other Indic encodings, but the above were the only Indic encodings maps that I could find at &lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; .</source>
          <target state="translated">我相信这个问题不仅在Mac Indics中很普遍，在其他Indic编码中也很普遍，但是以上是我在&lt;a href=&quot;http://www.unicode.org/&quot;&gt;http://www.unicode.org/上&lt;/a&gt;可以找到的唯一Indic编码映射。</target>
        </trans-unit>
        <trans-unit id="e16283d3f67007c5d32c917f1aef8895827d0a69" translate="yes" xml:space="preserve">
          <source>I believe this issue is prevalent not only for Mac Indics but also in other Indic encodings, but the above were the only Indic encodings maps that I could find at &lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/&lt;/a&gt; .</source>
          <target state="translated">我相信这个问题不仅在Mac Indics中很普遍，在其他Indic编码中也很普遍，但是以上是我在&lt;a href=&quot;https://www.unicode.org/&quot;&gt;http://www.unicode.org/上&lt;/a&gt;可以找到的唯一Indic编码映射。</target>
        </trans-unit>
        <trans-unit id="7b4d37f069c57cb7de599233daad3bd27d0a8ebc" translate="yes" xml:space="preserve">
          <source>I can also pass callbacks to the constructor:</source>
          <target state="translated">我也可以将回调传递给构造函数。</target>
        </trans-unit>
        <trans-unit id="64bcef0f48a866ba703693e5fcdad43a764ad25a" translate="yes" xml:space="preserve">
          <source>I can also tell prove to save the results again so that it updates its idea of which tests failed:</source>
          <target state="translated">我也可以告诉证明再次保存结果,这样它就会更新它对哪些测试失败的想法。</target>
        </trans-unit>
        <trans-unit id="23d96c393b63a12dec2fe257877addccb84b91ed" translate="yes" xml:space="preserve">
          <source>I can incorporate these options into my own version of prove. It's pretty simple. Most of the work of prove is handled by App::Prove. The important code in prove is just:</source>
          <target state="translated">我可以将这些选项纳入到我自己的证明版本中。这很简单。prove的大部分工作都由App::Prove处理。prove中的重要代码只是。</target>
        </trans-unit>
        <trans-unit id="5f16057cfc74a8e91522c5a546d3a88bbd9af3c3" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">我可以想象各种各样的情况，在这些情况下，您只是不希望查找能够失败（因为失败通常意味着maketext会 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，尽管请参见下一节以更好地控制它）。但是在这种情况下，_AUTO词典应该是</target>
        </trans-unit>
        <trans-unit id="73e0e4b77d6bcf01d6041debc1a2e83d30fd057e" translate="yes" xml:space="preserve">
          <source>I can picture all sorts of circumstances where you just do not want lookup to be able to fail (since failing normally means that maketext throws a &lt;code&gt;die&lt;/code&gt;, although see the next section for greater control over that). But here's one circumstance where _AUTO lexicons are meant to be</source>
          <target state="translated">我可以想象各种各样的情况，在这些情况下，您只是不希望查找能够失败（因为失败通常意味着maketext会 &lt;code&gt;die&lt;/code&gt; ，但是请参见下一部分，以更好地控制它）。但是在这种情况下，_AUTO词典应该是</target>
        </trans-unit>
        <trans-unit id="08456af218bdc4a506b4e778d48d6e90d82b1d13" translate="yes" xml:space="preserve">
          <source>I can tell prove just to run the tests that are failing like this:</source>
          <target state="translated">我可以告诉证明只要运行这样失败的测试。</target>
        </trans-unit>
        <trans-unit id="c4089c61d9307c046d40cd9abd561382f7f03ee3" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use</source>
          <target state="translated">我不能将perl嵌入到我的程序中,也不能使用</target>
        </trans-unit>
        <trans-unit id="31d3f8a1fa15d729190062c1ddc4f7dd97a4bdd9" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use _perl.dll_ from my program.</source>
          <target state="translated">我不能将perl嵌入到我的程序中,也不能从我的程序中使用_perl.dll_。</target>
        </trans-unit>
        <trans-unit id="e0dabde4d7970f758fc132b87f569962de8417e4" translate="yes" xml:space="preserve">
          <source>I cannot embed perl into my program, or use perl.dll from my program.</source>
          <target state="translated">我无法将perl嵌入到我的程序中,也无法从我的程序中使用perl.dll。</target>
        </trans-unit>
        <trans-unit id="0dfdb8e8d03951e17fc904de692bb5bbd7335317" translate="yes" xml:space="preserve">
          <source>I cannot run external programs</source>
          <target state="translated">我无法运行外部程序</target>
        </trans-unit>
        <trans-unit id="993598ed9e1ff928aa61c98c2c0a4e51ef13499b" translate="yes" xml:space="preserve">
          <source>I cleaned it up a little.</source>
          <target state="translated">我把它清理了一下。</target>
        </trans-unit>
        <trans-unit id="03ed42e550b2837d803cc938a5c931b4a08219dc" translate="yes" xml:space="preserve">
          <source>I copied the Perl binary from one machine to another, but scripts don't work.</source>
          <target state="translated">我把Perl的二进制文件从一台机器复制到另一台机器上,但是脚本不能用。</target>
        </trans-unit>
        <trans-unit id="9327e89bd234d7a986b2da9100760b6e37c4547a" translate="yes" xml:space="preserve">
          <source>I could start up faster by delaying compilation until it should be needed, but this gets a &quot;panic: top_level&quot; when using the pragma form in Perl 5.001e.</source>
          <target state="translated">我可以通过将编译延迟到应该需要的时候再启动更快,但在Perl 5.001e中使用pragma形式时,这会得到 &quot;panic:top_level&quot;。</target>
        </trans-unit>
        <trans-unit id="88a201ad71d898eadaddaac681114556a0d035b9" translate="yes" xml:space="preserve">
          <source>I do not anticipate that you will need (or particularly want) to nest bracket groups, but you are welcome to email me with convincing (real-life) arguments to the contrary.</source>
          <target state="translated">我不预计你会需要(或特别想要)嵌套括号组,但欢迎你给我发邮件,提出令人信服的(现实生活中)相反的论点。</target>
        </trans-unit>
        <trans-unit id="3bb5142da6ee5443fb8a1f91f511fc41a8d23e27" translate="yes" xml:space="preserve">
          <source>I don't have a C compiler. How can I build my own Perl interpreter?</source>
          <target state="translated">我没有C编译器。我怎样才能建立自己的Perl解释器?</target>
        </trans-unit>
        <trans-unit id="d6d0389812dedc1090c3af8ee3195c2e1255c8d3" translate="yes" xml:space="preserve">
          <source>I foresee no problems with having multiple inheritance in your hierarchy of language classes. (As usual, however, Perl will complain bitterly if you have a cycle in the hierarchy: i.e., if any class is its own ancestor.)</source>
          <target state="translated">我预见到在你的语言类的层次结构中拥有多重继承没有问题。(不过,和往常一样,如果你的层次结构中有一个循环,即任何一个类都是它自己的祖先,Perl就会痛苦地抱怨。)</target>
        </trans-unit>
        <trans-unit id="371ea8fdbc8bb052c307098a6984a7c87ed2802d" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">当我从我的shell（恰好是bash）运行它时，我得到一个错误。看起来好像perl忘记了它具有 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; 函数，但是我的shebang行不是perl的路径，因此shell运行脚本，但出现错误。</target>
        </trans-unit>
        <trans-unit id="3b40ca07783bb532ad8480c512cbc6f6a04c95d1" translate="yes" xml:space="preserve">
          <source>I get an error when I run this from my shell (which happens to be bash). That may look like perl forgot it has a &lt;code&gt;print()&lt;/code&gt; function, but my shebang line is not the path to perl, so the shell runs the script, and I get the error.</source>
          <target state="translated">当我从我的shell（恰好是bash）运行它时，我得到一个错误。看起来好像perl忘记了它具有 &lt;code&gt;print()&lt;/code&gt; 函数，但是我的shebang行不是perl的路径，因此shell运行脚本，但我得到了错误。</target>
        </trans-unit>
        <trans-unit id="25b36e7f52406231ec7c4381f27e5a02ba4d1de4" translate="yes" xml:space="preserve">
          <source>I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?</source>
          <target state="translated">我抓了源码并尝试编译,但gdbm/dynamic loading/malloc/linking/...失败了。我怎样才能让它工作?</target>
        </trans-unit>
        <trans-unit id="d3f27f69fc434f23222da72a1a4ed476958555fb" translate="yes" xml:space="preserve">
          <source>I have heard of one other type of firewall which requires a login to the firewall with an account, then a second login with &lt;code&gt;user@hostname&lt;/code&gt;. You can still use Net::FTP to traverse these firewalls, but a more manual approach must be taken, eg</source>
          <target state="translated">我听说过另一种类型的防火墙，它要求使用帐户登录到防火墙，然后使用 &lt;code&gt;user@hostname&lt;/code&gt; 进行第二次登录。您仍然可以使用Net :: FTP穿越这些防火墙，但是必须采取更手动的方法，例如</target>
        </trans-unit>
        <trans-unit id="12aeb2257dccbb467ef10e49ef5687a5f072930e" translate="yes" xml:space="preserve">
          <source>I have no clue what this does. Strips function prefixes?</source>
          <target state="translated">我不知道这是干什么的。剥离函数前缀?</target>
        </trans-unit>
        <trans-unit id="0cb0121fc9974d9d1b5aed90c164d431509f7248" translate="yes" xml:space="preserve">
          <source>I have seen scripts call a method message, but cannot find it documented ?</source>
          <target state="translated">我见过脚本调用一个方法消息,但找不到它的文档 ?</target>
        </trans-unit>
        <trans-unit id="fc30870b270d5fd5a0e0ca93284b0967a0e43a00" translate="yes" xml:space="preserve">
          <source>I have supposed that since this module is concerned with file I/O, almost all normal use of it will be heavily I/O bound. This means that the time to maintain complicated data structures inside the module will be dominated by the time to actually perform the I/O. When there was an opportunity to spend CPU time to avoid doing I/O, I usually tried to take it.</source>
          <target state="translated">我推测,由于这个模块关注的是文件I/O,所以几乎所有正常使用的模块都会有大量的I/O绑定,这意味着模块内部维护复杂数据结构的时间会被实际执行I/O的时间所占据。这意味着在模块内部维护复杂数据结构的时间将被实际执行I/O的时间所支配。当有机会花费CPU时间来避免做I/O的时候,我通常会尽量抓住这个机会。</target>
        </trans-unit>
        <trans-unit id="9f890badb47c01638de767ac6be14f492fbbfa01" translate="yes" xml:space="preserve">
          <source>I installed a Bundle and had a couple of fails. When I retried, everything resolved nicely. Can this be fixed to work on first try?</source>
          <target state="translated">我安装了一个Bundle,但出现了几次失败。当我重试时,一切都解决得很好。能否解决这个问题,使其在第一次尝试时就能正常工作?</target>
        </trans-unit>
        <trans-unit id="f93fb27a66a374179e4455b8d8985c2d226a8af1" translate="yes" xml:space="preserve">
          <source>I installed a new version of module X but CPAN keeps saying, I have the old version installed</source>
          <target state="translated">我安装了一个新版本的模块X,但CPAN一直说,我安装了旧版本的模块X</target>
        </trans-unit>
        <trans-unit id="ce465a8fc00712ba52e5306e95737f3b12576087" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of popups</source>
          <target state="translated">我不知道如何找出弹出窗口的状态。</target>
        </trans-unit>
        <trans-unit id="50ca6fc19f7270831b580874499d55acf40e475f" translate="yes" xml:space="preserve">
          <source>I know of no way to find out the state of redirection of popups to the disk</source>
          <target state="translated">我不知道有什么办法可以查到弹出窗口的重定向到磁盘的状态。</target>
        </trans-unit>
        <trans-unit id="74eeceb13c393c687a92a5cda3bd40599b660cd1" translate="yes" xml:space="preserve">
          <source>I lost track; what encoding is the internal format really?</source>
          <target state="translated">我不知道,内部格式到底是什么编码?</target>
        </trans-unit>
        <trans-unit id="d25ced27930e65857371f29ffd1a913f02b5e4b7" translate="yes" xml:space="preserve">
          <source>I love it when a plan comes together</source>
          <target state="translated">我爱它,当一个计划一起</target>
        </trans-unit>
        <trans-unit id="606078fbab11616b11caaa1df541827c0df787a2" translate="yes" xml:space="preserve">
          <source>I maintain a mailing list on which I occasionally announce new versions of Memoize. The list is for announcements only, not discussion. To join, send an empty message to mjd-perl-memoize-request@Plover.com.</source>
          <target state="translated">我维护了一个邮件列表,偶尔会在上面公布Memoize的新版本。该列表只用于发布公告,不用于讨论。要加入,请发送空消息到 mjd-perl-memoize-request@Plover.com。</target>
        </trans-unit>
        <trans-unit id="8c678b32e1afc117e7298e7cd70848ce65ee6435" translate="yes" xml:space="preserve">
          <source>I need to tell prove to use my My::TAP::Harness. If My::TAP::Harness is on Perl's @INC include path I can</source>
          <target state="translated">我需要告诉证明使用我的My::TAP::Harness。如果 My::TAP::Harness 在 Perl 的 @INC 包含路径上,我可以</target>
        </trans-unit>
        <trans-unit id="92c1a5ec60a557a8f6b6b470a96e90910a56e1c7" translate="yes" xml:space="preserve">
          <source>I pointed out that &lt;code&gt;Memoize&lt;/code&gt; uses a hash, and that looking up a number in the hash is necessarily going to take a lot longer than a single multiplication. There really is no way to speed up the &lt;code&gt;square&lt;/code&gt; function.</source>
          <target state="translated">我指出， &lt;code&gt;Memoize&lt;/code&gt; 使用散列，并且在散列中查找数字必然比单倍乘法花费更长的时间。确实没有办法加快 &lt;code&gt;square&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="05b0f6d7121204753b37fe3a1f3d86b9576db3c7" translate="yes" xml:space="preserve">
          <source>I presume that it would be only the exceptional Web site that gets localized for English</source>
          <target state="translated">我猜想,只有特殊的网站才会被本地化为英文。</target>
        </trans-unit>
        <trans-unit id="44584b7f38a4c7c497d3af92b7cb4267fde694f9" translate="yes" xml:space="preserve">
          <source>I promised to give you 90% of the benefit with 10% of the details, and that means I left out 90% of the details. Now that you have an overview of the important parts, it should be easier to read the &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; manual page, which discusses 100% of the details.</source>
          <target state="translated">我答应给您90％的收益以及10％的细节，这意味着我遗漏了90％的细节。现在，您已经掌握了重要部分的概述，应该更容易阅读&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;手册页面，该页面讨论了100％的详细信息。</target>
        </trans-unit>
        <trans-unit id="fe86a2ccd7bbbde333da23b987f2e2e4802f719a" translate="yes" xml:space="preserve">
          <source>I put a regular expression into $/ but it didn't work. What's wrong?</source>
          <target state="translated">我在$/中输入了一个正则表达式,但是没有成功。怎么了?</target>
        </trans-unit>
        <trans-unit id="73511fb1b7957dad066b5bf11010746dfb956b61" translate="yes" xml:space="preserve">
          <source>I recommend reading all of these:</source>
          <target state="translated">我推荐大家阅读这些。</target>
        </trans-unit>
        <trans-unit id="b7928600b482b60ec404a555ac7072bbe1486616" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">我之所以在上面说&amp;ldquo;堆栈的一部分&amp;rdquo;，是因为PP代码不一定会使整个堆栈成其自身：如果您的函数调用了另一个函数，则只希望公开针对被调用函数的参数，而不是（不必公开） ），让它获取您自己的数据。我们这样做的方法是让&amp;ldquo;虚拟&amp;rdquo;堆栈底部暴露于每个功能。标记堆栈将书签保留到每个函数可以使用的参数堆栈中的位置。例如，当处理绑定变量时（内部使用&amp;ldquo; P&amp;rdquo;魔术），Perl必须调用方法来访问绑定变量。但是，我们需要将公开给方法的参数与公开给原始函数的参数（存储或提取或任何可能的参数）分开。这里'大致如何实现捆绑 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ；看到 &lt;code&gt;av_push&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="3b74357799ff3a807572f0228d6475d4cbcdbf36" translate="yes" xml:space="preserve">
          <source>I say &quot;your portion of the stack&quot; above because PP code doesn't necessarily get the whole stack to itself: if your function calls another function, you'll only want to expose the arguments aimed for the called function, and not (necessarily) let it get at your own data. The way we do this is to have a &quot;virtual&quot; bottom-of-stack, exposed to each function. The mark stack keeps bookmarks to locations in the argument stack usable by each function. For instance, when dealing with a tied variable, (internally, something with &quot;P&quot; magic) Perl has to call methods for accesses to the tied variables. However, we need to separate the arguments exposed to the method to the argument exposed to the original function - the store or fetch or whatever it may be. Here's roughly how the tied &lt;code&gt;push&lt;/code&gt; is implemented; see &lt;code&gt;av_push&lt;/code&gt; in</source>
          <target state="translated">我之所以说上面的&amp;ldquo;堆栈的一部分&amp;rdquo;，是因为PP代码不一定会使整个堆栈成其自身：如果您的函数调用了另一个函数，则只希望公开针对被调用函数的参数，而不是（必要时） ），让它获取您自己的数据。我们这样做的方法是使&amp;ldquo;虚拟&amp;rdquo;堆栈底部暴露于每个功能。标记堆栈将书签保留到每个函数可以使用的参数堆栈中的位置。例如，当处理绑定变量时（内部使用&amp;ldquo; P&amp;rdquo;魔术），Perl必须调用方法来访问绑定变量。但是，我们需要将方法公开的参数与原始函数公开的参数（存储或提取或可能的其他参数）分开。这里'大致如何实现捆绑 &lt;code&gt;push&lt;/code&gt; ；看 &lt;code&gt;av_push&lt;/code&gt; in</target>
        </trans-unit>
        <trans-unit id="bd010707291df43195b163d13725276025549dad" translate="yes" xml:space="preserve">
          <source>I still don't get locking. I just want to increment the number in the file. How can I do this?</source>
          <target state="translated">我还是不明白锁定。我只是想增加文件中的数字。如何才能做到这一点?</target>
        </trans-unit>
        <trans-unit id="0c3fa205e2bf9a49a23f4b51209de0f9232902bf" translate="yes" xml:space="preserve">
          <source>I think it would help to give some concrete examples to make it easier to understand the API. Of course I agree that the API has to be concise, but since there is no second document that is more of a guide, I think that it'd make it easier to start with the doc which is an API, but has examples in it in places where things are unclear, to a person who is not a PerlIO guru (yet).</source>
          <target state="translated">我认为给出一些具体的例子会有助于让人们更容易理解API。当然,我同意 API 必须简明扼要,但由于没有第二份文档更像是一份指南,我认为对于一个不是 PerlIO 大师的人来说,从文档开始会更容易,因为文档是 API,但在不清楚的地方提供了例子。</target>
        </trans-unit>
        <trans-unit id="09ffd110a6022c3eacd4a506a275e7c45f272e0d" translate="yes" xml:space="preserve">
          <source>I think that keys as lexicon values makes the completed lexicon entries more readable:</source>
          <target state="translated">我认为将键作为词条值,可以使完成的词条更易读。</target>
        </trans-unit>
        <trans-unit id="794953983b61d639901830159ca78a40665adca3" translate="yes" xml:space="preserve">
          <source>I used 'lynx' to fetch a file, but its contents is all wrong!</source>
          <target state="translated">我用'猞猁'取了一个文件,但它的内容全错了!</target>
        </trans-unit>
        <trans-unit id="14dcb94db4c292bdfbf0b5c851ca4df4a4bf4c31" translate="yes" xml:space="preserve">
          <source>I want to clean up my mess, and install a new perl along with all modules I have. How do I go about it?</source>
          <target state="translated">我想清理一下我的烂摊子,然后把我所有的模块一起安装一个新的perl。我该怎么做呢?</target>
        </trans-unit>
        <trans-unit id="3ae9e2275243ec65b397ebef16d91a7d431148ac" translate="yes" xml:space="preserve">
          <source>I want to log my test results in a database so I can track them over time. To do this I override the summary method in TAP::Harness. I start with a simple prototype that dumps the results as a YAML document:</source>
          <target state="translated">我想把我的测试结果记录在数据库中,这样我就可以随着时间的推移追踪它们。为了做到这一点,我覆盖了TAP::Harness中的摘要方法。我从一个简单的原型开始,将结果转储为一个YAML文档。</target>
        </trans-unit>
        <trans-unit id="0c2d698fc768ffb8cd382c1370e66993c67187ee" translate="yes" xml:space="preserve">
          <source>I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?</source>
          <target state="translated">我在一个perl脚本中{改变了目录,修改了环境}。为什么我退出脚本的时候,修改就消失了?怎样才能让我的修改可见?</target>
        </trans-unit>
        <trans-unit id="8d4b0ae21d1479e72399aeb9631081d458e4ae16" translate="yes" xml:space="preserve">
          <source>I&amp;lt;bar&amp;gt;</source>
          <target state="translated">I&amp;lt;bar&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3bb667cf6d485cf87366e4fa5d3fb7627b160f2b" translate="yes" xml:space="preserve">
          <source>I'll define the</source>
          <target state="translated">我将定义</target>
        </trans-unit>
        <trans-unit id="5cc9daab4dbfbc15ce11a2a71cb8dfe5485782e2" translate="yes" xml:space="preserve">
          <source>I'm afraid that we're not quite through with the alignment catch yet. The hydra raises another ugly head when you pack arrays of structures:</source>
          <target state="translated">恐怕我们还没有完成对准的捕捉。九头蛇会在你装上数组结构的时候,提出另一个丑陋的头。</target>
        </trans-unit>
        <trans-unit id="f883cc87b6710df9317db1561fdc26ada281ddbe" translate="yes" xml:space="preserve">
          <source>I'm frequently irritated with the CPAN shell's inability to help me select a good mirror.</source>
          <target state="translated">我经常为CPAN壳无法帮助我选择好的镜子而恼火。</target>
        </trans-unit>
        <trans-unit id="70a3ef0517de91698e88a243cc2feee12ba385a3" translate="yes" xml:space="preserve">
          <source>I'm having trouble matching over more than one line. What's wrong?</source>
          <target state="translated">我在多条线上匹配有问题。怎么了?</target>
        </trans-unit>
        <trans-unit id="8b9d03c166b0dec7e59491eb481c804d58495438" translate="yes" xml:space="preserve">
          <source>I'm not totally sure that locale names map satisfactorily to language tags. Think REAL hard about how you use this. YOU HAVE BEEN WARNED.</source>
          <target state="translated">我不太确定locale名称是否能令人满意地映射到语言标签。仔细想想你如何使用这个。你已经被警告了。</target>
        </trans-unit>
        <trans-unit id="73daa2b6bdc84827d06ade0cf82b30946cb9ce40" translate="yes" xml:space="preserve">
          <source>I'm offering this port &quot;as is&quot;. You can ask me questions, but I can't guarantee I'll be able to answer them. There are some excellent books available on the Perl language; consult a book seller.</source>
          <target state="translated">我 &quot;原封不动 &quot;地提供这个端口。您可以向我提出问题,但我不能保证一定能回答。有一些关于 Perl 语言的优秀书籍,请向书商咨询。</target>
        </trans-unit>
        <trans-unit id="4357a589e4e3b7a00e21bb3c83ca3b640b5e0ab8" translate="yes" xml:space="preserve">
          <source>I'm ok, you're not ok.</source>
          <target state="translated">我没事,你有事。</target>
        </trans-unit>
        <trans-unit id="108bd315655f1ba897c01059e340ad678da6e2f4" translate="yes" xml:space="preserve">
          <source>I'm sure most of us have seen code which looks like, (or worse than), this:</source>
          <target state="translated">我相信我们大多数人都见过类似(或比这更糟糕)的代码。</target>
        </trans-unit>
        <trans-unit id="2f2f2a41a5729ebdf99d33e9a94c056bfe6a7622" translate="yes" xml:space="preserve">
          <source>I'm using WinZip, or some other non-POSIX client, and files are not being extracted properly!</source>
          <target state="translated">我使用的是WinZip,或者其他一些非POSIX客户端,文件无法正常解压!</target>
        </trans-unit>
        <trans-unit id="76c00e4567fd7637d5e9878ed4c5f66e616b88b8" translate="yes" xml:space="preserve">
          <source>I've considered making all the above functions that output language tags return all those tags strictly in lowercase. Having all your language tags in lowercase does make some things easier. But you might as well just lowercase as you like, or call &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; where appropriate.</source>
          <target state="translated">我考虑过将上述所有输出语言标签的函数严格地以小写形式返回所有这些标签。将所有语言标签都使用小写确实会使某些事情变得更容易。但是您也可以根据需要 &lt;code&gt;encode_language_tag($lang1)&lt;/code&gt; 小写字母，或者在适当的地方调用encode_language_tag（$ lang1）。</target>
        </trans-unit>
        <trans-unit id="88c5fcd7802546df837a3bf463ca41dcbe3c282a" translate="yes" xml:space="preserve">
          <source>I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?</source>
          <target state="translated">我看了perlembed、perlguts等,但我的C程序中无法嵌入perl,我到底做错了什么?</target>
        </trans-unit>
        <trans-unit id="4dfe11ac55007ac0949167eaeb2efbe8ea5b1f5d" translate="yes" xml:space="preserve">
          <source>I/O</source>
          <target state="translated">I/O</target>
        </trans-unit>
        <trans-unit id="c880785e491d41fc494e4fbfcd55e995f2687586" translate="yes" xml:space="preserve">
          <source>I/O Operators</source>
          <target state="translated">I/O操作员</target>
        </trans-unit>
        <trans-unit id="1bd45ae6f90a489462015faa36411b1a7a88b1e2" translate="yes" xml:space="preserve">
          <source>I/O control operations for disk devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Most of these are to be used on physical drive devices like &lt;code&gt;&quot;//./PhysicalDrive0&quot;&lt;/code&gt;. However, &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; and &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; should only be used on a single-partition device like &lt;code&gt;&quot;//./C:&quot;&lt;/code&gt;. Also, &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; is documented as having been superseded but is still useful when used on a floppy device like &lt;code&gt;&quot;//./A:&quot;&lt;/code&gt;.</source>
          <target state="translated">磁盘设备的I / O控制操作。在 &lt;code&gt;DeviceIoControl&lt;/code&gt; 的 &lt;code&gt;$uIoControlCode&lt;/code&gt; 参数中使用。其中大多数将在物理驱动器设备上使用，例如 &lt;code&gt;&quot;//./PhysicalDrive0&quot;&lt;/code&gt; 。但是， &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; 和 &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; 仅应在单分区设备上使用，例如 &lt;code&gt;&quot;//./C:&quot;&lt;/code&gt; 。同样， &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; 被记录为已被取代，但在诸如 &lt;code&gt;&quot;//./A:&quot;&lt;/code&gt; 类的软盘设备上使用时仍然有用。</target>
        </trans-unit>
        <trans-unit id="0a4882a6a30b4583bba173c6035cc140752a4ec0" translate="yes" xml:space="preserve">
          <source>I/O control operations for generic storage devices. Used in the &lt;code&gt;$uIoControlCode&lt;/code&gt; argument to &lt;code&gt;DeviceIoControl&lt;/code&gt;. Includes &lt;code&gt;IOCTL_STORAGE_CHECK_VERIFY&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_MEDIA_REMOVAL&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_EJECT_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_LOAD_MEDIA&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RESERVE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_RELEASE&lt;/code&gt;, &lt;code&gt;IOCTL_STORAGE_FIND_NEW_DEVICES&lt;/code&gt;, and &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt;.</source>
          <target state="translated">通用存储设备的I / O控制操作。在 &lt;code&gt;DeviceIoControl&lt;/code&gt; 的 &lt;code&gt;$uIoControlCode&lt;/code&gt; 参数中使用。包括 &lt;code&gt;IOCTL_STORAGE_CHECK_VERIFY&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_MEDIA_REMOVAL&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_EJECT_MEDIA&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_LOAD_MEDIA&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_RESERVE&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_RELEASE&lt;/code&gt; ， &lt;code&gt;IOCTL_STORAGE_FIND_NEW_DEVICES&lt;/code&gt; 和 &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fa930eaf91e1f81994700657728c3a757afb3cf" translate="yes" xml:space="preserve">
          <source>I/O flow (the actual 5 minute tutorial)</source>
          <target state="translated">I/O流程(实际5分钟教程)</target>
        </trans-unit>
        <trans-unit id="ae9cf1f9e1227f9dff6b41ea1e5f80cc2ae055d8" translate="yes" xml:space="preserve">
          <source>I/O layer</source>
          <target state="translated">输入/输出层</target>
        </trans-unit>
        <trans-unit id="46fc5fcf49da9b0ec975af77958aa41975a1fe45" translate="yes" xml:space="preserve">
          <source>I/O redirection and backgrounding</source>
          <target state="translated">I/O重定向和背景</target>
        </trans-unit>
        <trans-unit id="30d63bddfa4212ccce60957ddceaf4fa37417d27" translate="yes" xml:space="preserve">
          <source>I/O timeout value</source>
          <target state="translated">I/O超时值</target>
        </trans-unit>
        <trans-unit id="8571fe32abe041d9dce3d7d7c47b858f248fa514" translate="yes" xml:space="preserve">
          <source>I18N AND L10N</source>
          <target state="translated">I18N和L10N</target>
        </trans-unit>
        <trans-unit id="e6b903dcac2bbc1b40e43d5e333946755137d36f" translate="yes" xml:space="preserve">
          <source>I18N::Charset</source>
          <target state="translated">I18N::Charset</target>
        </trans-unit>
        <trans-unit id="de5d730fbdbbf0183cf0f4683f1a73058ef3481c" translate="yes" xml:space="preserve">
          <source>I18N::Collate</source>
          <target state="translated">I18N::Collate</target>
        </trans-unit>
        <trans-unit id="01ad2dd6dde49d7565416cd97f4d499093f9d249" translate="yes" xml:space="preserve">
          <source>I18N::Collate - compare 8-bit scalar data according to the current locale</source>
          <target state="translated">I18N::Collate-根据当前locale比较8位标量数据。</target>
        </trans-unit>
        <trans-unit id="e106875b328699ace6767aa9c5ecab5bca3b0bd8" translate="yes" xml:space="preserve">
          <source>I18N::LangTags</source>
          <target state="translated">I18N::LangTags</target>
        </trans-unit>
        <trans-unit id="169f8297167d0e993d7316faae039b48a7c3bab1" translate="yes" xml:space="preserve">
          <source>I18N::LangTags - functions for dealing with RFC3066-style language tags</source>
          <target state="translated">I18N::LangTags-用于处理 RFC3066 风格的语言标签的函数。</target>
        </trans-unit>
        <trans-unit id="921275b7d99f260593561350c7678a20816444ed" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect</source>
          <target state="translated">I18N::LangTags::Detect</target>
        </trans-unit>
        <trans-unit id="778875cc577b876aab7ab802d4648cdcd4ee6cae" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::Detect - detect the user's language preferences</source>
          <target state="translated">I18N::LangTags::Detect-检测用户的语言偏好。</target>
        </trans-unit>
        <trans-unit id="c04ea1622f377702e175508a3a481907575a2f47" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List</source>
          <target state="translated">I18N::LangTags::List</target>
        </trans-unit>
        <trans-unit id="020bb812c335fc278093b15a03a292e40918c844" translate="yes" xml:space="preserve">
          <source>I18N::LangTags::List -- tags and names for human languages</source>
          <target state="translated">I18N::LangTags::List ----人类语言的标签和名称。</target>
        </trans-unit>
        <trans-unit id="e3646198e54c82833384221bb49e8cf11f385f8f" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo</source>
          <target state="translated">I18N::Langinfo</target>
        </trans-unit>
        <trans-unit id="75f77bed8de0aee0770843a55893169b79d25155" translate="yes" xml:space="preserve">
          <source>I18N::Langinfo - query locale information</source>
          <target state="translated">I18N::Langinfo-本地查询信息。</target>
        </trans-unit>
        <trans-unit id="fde9493a25e191231f11e09ab4dbdd30b2b2a8bf" translate="yes" xml:space="preserve">
          <source>I18N:Collate obsolete</source>
          <target state="translated">I18N:整理过时的</target>
        </trans-unit>
        <trans-unit id="0afef78a7afa599e29cd712fed951b6314ade53c" translate="yes" xml:space="preserve">
          <source>I18n and l10n</source>
          <target state="translated">I18n和l10n</target>
        </trans-unit>
        <trans-unit id="3886f65f7123288c1155f83462ecaa6186be5aba" translate="yes" xml:space="preserve">
          <source>I64 (8.2 and later)</source>
          <target state="translated">I64(8.2及以后)</target>
        </trans-unit>
        <trans-unit id="f7d467a87245290159a1b6af42928666730653f6" translate="yes" xml:space="preserve">
          <source>IANA</source>
          <target state="translated">IANA</target>
        </trans-unit>
        <trans-unit id="0e13c62333772940b082221be7ca7762de31a069" translate="yes" xml:space="preserve">
          <source>IBM XL C for AIX</source>
          <target state="translated">IBM XL C for AIX</target>
        </trans-unit>
        <trans-unit id="c8afdae11327e149f5501c448b30becf77bc4954" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ for AIX</source>
          <target state="translated">IBM XL C/C++for AIX</target>
        </trans-unit>
        <trans-unit id="90317bc062fe454cff88014258aea7e36e9b3afc" translate="yes" xml:space="preserve">
          <source>IBM calls its implementation of long doubles 128-bit, but it is not the IEEE 128-bit (&quot;quadruple precision&quot;) which would give 116 bit of mantissa (nor it is implemented in hardware), instead it's a special software implementation called &quot;double-double&quot;, which gives 106 bits of mantissa.</source>
          <target state="translated">IBM把它对长双倍的实现称为128位,但它并不是IEEE 128位(&quot;四倍精度&quot;),这样可以得到116位的口令(也不是在硬件中实现的),而是一种特殊的软件实现,称为 &quot;双倍&quot;,可以得到106位的口令。</target>
        </trans-unit>
        <trans-unit id="896c500f28ef7df0fbbd0268cb9652b7cfe0014c" translate="yes" xml:space="preserve">
          <source>IBM uses the AIX system Perl (V5.6.0 on AIX 5.1 and V5.8.2 on AIX 5.2 / 5.3 and 6.1; V5.8.8 on AIX 5.3 TL11 and AIX 6.1 TL4; V5.10.1 on AIX 7.1) for some AIX system scripts. If you switch the links in /usr/bin from the AIX system Perl (/usr/opt/perl5) to the newly build Perl then you get the same features as with the IBM AIX system Perl if the threaded options are used.</source>
          <target state="translated">IBM使用AIX系统Perl(AIX 5.1上的V5.6.0和AIX 5.2/5.3和6.1上的V5.8.2;AIX 5.3 TL11和AIX 6.1 TL4上的V5.8.8;AIX 7.1上的V5.10.1)来编写一些AIX系统脚本。如果将/usr/bin中的链接从AIX系统Perl(/usr/opt/perl5)切换到新构建的Perl中,那么如果使用线程选项,就可以获得与IBM AIX系统Perl相同的功能。</target>
        </trans-unit>
        <trans-unit id="ade9d724c5b212d6e78013557f35ac5c64927377" translate="yes" xml:space="preserve">
          <source>ICU Character Mapping Tables &lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</source>
          <target state="translated">ICU字符映射表&lt;a href=&quot;http://site.icu-project.org/charts/charset&quot;&gt;http://site.icu-project.org/charts/charset&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92d0be3756020c7fb70f5f8d43b6e18e96de1472" translate="yes" xml:space="preserve">
          <source>ICU Home Page &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</source>
          <target state="translated">ICU主页&lt;a href=&quot;http://www.icu-project.org/&quot;&gt;http://www.icu-project.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b3a4d066585cb49384b262b020e538f42a1f2ef" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU：转化数据&lt;a href=&quot;http://www.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="821bf81957decc27fcaa8150194992b2c603308d" translate="yes" xml:space="preserve">
          <source>ICU:Conversion Data &lt;a href=&quot;https://ssl.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</source>
          <target state="translated">ICU：转化数据&lt;a href=&quot;https://ssl.icu-project.org/userguide/conversion-data.html&quot;&gt;http://www.icu-project.org/userguide/conversion-data.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="46c5f048dbe4176fe265d2a79feb829754221b1e" translate="yes" xml:space="preserve">
          <source>IDENTIFYING CHARACTER CODE SETS</source>
          <target state="translated">识别字符代码集。</target>
        </trans-unit>
        <trans-unit id="98eebf3bdf415d089af03ec0debc7c66f797a900" translate="yes" xml:space="preserve">
          <source>IETF Policy on Character Sets and Languages</source>
          <target state="translated">IETF字符集和语言政策</target>
        </trans-unit>
        <trans-unit id="db4d48e5feaf920779dd2373b4efffa265df836a" translate="yes" xml:space="preserve">
          <source>IFS access</source>
          <target state="translated">综合筹资战略准入</target>
        </trans-unit>
        <trans-unit id="6a5d66d70494ee5ff5a453f224b81868447c393b" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION</source>
          <target state="translated">IMPLEMENTATION</target>
        </trans-unit>
        <trans-unit id="282613097967896b3e57bca75eb0bce558486a26" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION DETAILS</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="0e35eae7c0731d3856fc41389b70ba2d34677ec0" translate="yes" xml:space="preserve">
          <source>IMPLEMENTATION NOTE</source>
          <target state="translated">执行说明</target>
        </trans-unit>
        <trans-unit id="00f6ac93461571c87bf08a0fa480109344a9be63" translate="yes" xml:space="preserve">
          <source>IMPLICIT LOADING</source>
          <target state="translated">暗示性加载</target>
        </trans-unit>
        <trans-unit id="2af61b8a92b859239b57341d2094b6ce58292a8a" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE 2: Attempting to bypass the normal stringification rules by manually applying &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; and &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; will sometimes yield surprising results:</source>
          <target state="translated">重要说明2：尝试通过手动应用&lt;a href=&quot;version#numify%28%29&quot;&gt;numify（）&lt;/a&gt;和&lt;a href=&quot;version#normal%28%29&quot;&gt;normal（）&lt;/a&gt;绕过常规字符串化规则有时会产生令人惊讶的结果：</target>
        </trans-unit>
        <trans-unit id="d100fb60d3feed237cfa4b32f5da84abc315f27f" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: As shown above, if your Decimal version contains more than 3 significant digits after the decimal place, it will be split on each multiple of 3, so 1.0003 is equivalent to v1.0.300, due to the need to remain compatible with Perl's own 5.005_03 == 5.5.30 interpretation. Any trailing zeros are ignored for mathematical comparison purposes.</source>
          <target state="translated">重要提示:如上图所示,如果您的十进制版本在小数点后包含了超过3位的重要数字,那么它将被分割成3的每一个倍数,所以1.0003相当于v1.0.300,这是因为需要与Perl自己的5.005_03 ==5.5.30解释保持兼容。任何尾部的零都会被忽略,以便进行数学比较。</target>
        </trans-unit>
        <trans-unit id="5d6d142ce7a912c87993ee95b67742ac2fb602f1" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: There is one exceptional cases shown in the above table where the &quot;initializer&quot; is not stringwise equivalent to the stringified representation. If you use the &lt;code&gt;qv&lt;/code&gt;() operator on a version without a leading 'v' &lt;b&gt;and&lt;/b&gt; with only a single decimal place, the stringified output will have a leading 'v', to preserve the sense. See the &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; operator for more details.</source>
          <target state="translated">重要说明：上表中显示了一种特殊情况，其中&amp;ldquo;初始化程序&amp;rdquo;与字符串表示形式在字符串上不等效。如果在没有前导&amp;ldquo; v&amp;rdquo;&lt;b&gt;且&lt;/b&gt;仅保留小数位的版本上使用 &lt;code&gt;qv&lt;/code&gt; （）运算符，则字符串化输出将具有前导&amp;ldquo; v&amp;rdquo;，以保持其含义。有关更多详细信息，请参见&lt;a href=&quot;#qv%28%29&quot;&gt;&amp;ldquo; qv（）&amp;rdquo;&lt;/a&gt;运算符。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bb759641a6b8b6611a890056cf82c280511d2e9e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: This may mean that code which searches for a specific string (to determine whether a given module is available) may need to be changed. It is always better to use the built-in comparison implicit in &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, rather than manually poking at &lt;code&gt;class-&amp;gt;VERSION&lt;/code&gt; and then doing a comparison yourself.</source>
          <target state="translated">重要说明：这可能意味着搜索特定字符串（以确定给定模块是否可用）的代码可能需要更改。总是最好使用 &lt;code&gt;use&lt;/code&gt; 或 &lt;code&gt;require&lt;/code&gt; 隐式的内置比较，而不是手动在 &lt;code&gt;class-&amp;gt;VERSION&lt;/code&gt; 上戳然后自己进行比较。</target>
        </trans-unit>
        <trans-unit id="926527594f94772fcf38d60a2b632b1bb4c3c38c" translate="yes" xml:space="preserve">
          <source>IMPORTANT!</source>
          <target state="translated">IMPORTANT!</target>
        </trans-unit>
        <trans-unit id="c2e68d710cae68fae1b4d1132f818132a6f1837f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: if you use this &lt;code&gt;-S&lt;/code&gt; switch, be sure to delete the CONFIG environment variable before running the script:</source>
          <target state="translated">重要说明：如果使用此 &lt;code&gt;-S&lt;/code&gt; 开关，请确保在运行脚本之前删除CONFIG环境变量：</target>
        </trans-unit>
        <trans-unit id="8d0c22f22ac148bf746659a76f51a0cce8f4070e" translate="yes" xml:space="preserve">
          <source>IMPORTS</source>
          <target state="translated">IMPORTS</target>
        </trans-unit>
        <trans-unit id="7696e648752c3c28012375bdb960a19fe39b8205" translate="yes" xml:space="preserve">
          <source>IMPORTS THE FUNCTIONS</source>
          <target state="translated">导入功能</target>
        </trans-unit>
        <trans-unit id="6a09657af85954f963dea9fb1156c8ea7994677c" translate="yes" xml:space="preserve">
          <source>IN6ADDR_ANY, IN6ADDR_LOOPBACK</source>
          <target state="translated">IN6ADDR_ANY,IN6ADDR_LOOPBACK。</target>
        </trans-unit>
        <trans-unit id="8b4b83ea115334b0957635d43569bbc4350f1369" translate="yes" xml:space="preserve">
          <source>INADDR_ANY, INADDR_BROADCAST, INADDR_LOOPBACK, INADDR_NONE</source>
          <target state="translated">INADDR_ANY,INADDR_BROADCAST,INADDR_LOOPBACK,INADDR_NONE。</target>
        </trans-unit>
        <trans-unit id="ff3c82a6fc602d03a66e45a7aa9a2ebf5c59e91e" translate="yes" xml:space="preserve">
          <source>INC</source>
          <target state="translated">INC</target>
        </trans-unit>
        <trans-unit id="3c49bdd8d8e33e31f0c17fbcb306d09e8c131ead" translate="yes" xml:space="preserve">
          <source>INCLUDE_EXT</source>
          <target state="translated">INCLUDE_EXT</target>
        </trans-unit>
        <trans-unit id="648fb0ddc69c6bf59cfae2b4b521d2eea5687df1" translate="yes" xml:space="preserve">
          <source>INCREMENTAL PARSING</source>
          <target state="translated">递增式搜索</target>
        </trans-unit>
        <trans-unit id="cbe356b54ea95780c909073ac988ee31715e5615" translate="yes" xml:space="preserve">
          <source>INDIVIDUAL RESULTS</source>
          <target state="translated">单独的结果</target>
        </trans-unit>
        <trans-unit id="87d0fcde0a601e06d986c8740283892296dbb885" translate="yes" xml:space="preserve">
          <source>INHERITANCE</source>
          <target state="translated">INHERITANCE</target>
        </trans-unit>
        <trans-unit id="bc46a4e0420d357db7bfbcb7b5fcbc613dc48c1b" translate="yes" xml:space="preserve">
          <source>INIT</source>
          <target state="translated">INIT</target>
        </trans-unit>
        <trans-unit id="59990b467aae79667fd3fe1156086a0a147fb594" translate="yes" xml:space="preserve">
          <source>INIT HOOKS</source>
          <target state="translated">入职培训</target>
        </trans-unit>
        <trans-unit id="c335a27a082cc8d17dd36dc0eda3086cb0c9baaa" translate="yes" xml:space="preserve">
          <source>INSTALL</source>
          <target state="translated">INSTALL</target>
        </trans-unit>
        <trans-unit id="bcfd83b3c8dcdbc242801037551b58c708467a92" translate="yes" xml:space="preserve">
          <source>INSTALL PERL ON CYGWIN</source>
          <target state="translated">在CYGWIN上安装PERL</target>
        </trans-unit>
        <trans-unit id="b3642e83164b0035941a17dcaac1e8efc8ccc9e9" translate="yes" xml:space="preserve">
          <source>INSTALLARCHLIB</source>
          <target state="translated">INSTALLARCHLIB</target>
        </trans-unit>
        <trans-unit id="9d09dba09f4e15504911bf4a5e67189762904dd8" translate="yes" xml:space="preserve">
          <source>INSTALLATION</source>
          <target state="translated">INSTALLATION</target>
        </trans-unit>
        <trans-unit id="e5f21f5cfe15896cc57e4f66a25de31e67f38e54" translate="yes" xml:space="preserve">
          <source>INSTALLBIN</source>
          <target state="translated">INSTALLBIN</target>
        </trans-unit>
        <trans-unit id="a8dc0b332a8b3a30e1a3bfbf06a9ca622fa8b35a" translate="yes" xml:space="preserve">
          <source>INSTALLDIRS</source>
          <target state="translated">INSTALLDIRS</target>
        </trans-unit>
        <trans-unit id="16fff6f9fc1411630b91667c135606baff1eac91" translate="yes" xml:space="preserve">
          <source>INSTALLING PERL IN OPENVOS</source>
          <target state="translated">在OPENVOS中安装PERL。</target>
        </trans-unit>
        <trans-unit id="7f052cc6553ecac6e3df0d0b879d905d556954d5" translate="yes" xml:space="preserve">
          <source>INSTALLMAN1DIR</source>
          <target state="translated">INSTALLMAN1DIR</target>
        </trans-unit>
        <trans-unit id="0e681f5032851ed30a543a900ac579e142841900" translate="yes" xml:space="preserve">
          <source>INSTALLMAN3DIR</source>
          <target state="translated">INSTALLMAN3DIR</target>
        </trans-unit>
        <trans-unit id="5933a08af3c7bebbbe6c3b67d67acaea7b113126" translate="yes" xml:space="preserve">
          <source>INSTALLPRIVLIB</source>
          <target state="translated">INSTALLPRIVLIB</target>
        </trans-unit>
        <trans-unit id="0c644278acf33a9a81880f74ea11f3e383631b34" translate="yes" xml:space="preserve">
          <source>INSTALLSCRIPT</source>
          <target state="translated">INSTALLSCRIPT</target>
        </trans-unit>
        <trans-unit id="54fcbd0bdcbf148e12836065934bc12897303524" translate="yes" xml:space="preserve">
          <source>INSTALLSITEARCH</source>
          <target state="translated">INSTALLSITEARCH</target>
        </trans-unit>
        <trans-unit id="89655a121385e7efe5f2cdc5a6d3add0eebb0223" translate="yes" xml:space="preserve">
          <source>INSTALLSITEBIN</source>
          <target state="translated">INSTALLSITEBIN</target>
        </trans-unit>
        <trans-unit id="933a51e99c70b3ad9b7b202ddc1482a7c0f44d60" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB</source>
          <target state="translated">INSTALLSITELIB</target>
        </trans-unit>
        <trans-unit id="df84db65783bcfd646d621819ed5a53534ed4081" translate="yes" xml:space="preserve">
          <source>INSTALLSITELIB=i:\perl\lib</source>
          <target state="translated">INSTALLSITELIB=i:\perl\lib</target>
        </trans-unit>
        <trans-unit id="26ed8090363cf70046fb05d12bd5b73ad1feec3a" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN1DIR</source>
          <target state="translated">INSTALLSITEMAN1DIR</target>
        </trans-unit>
        <trans-unit id="1df2b4517a777a7e926d6a7992d6ee2806c0c778" translate="yes" xml:space="preserve">
          <source>INSTALLSITEMAN3DIR</source>
          <target state="translated">INSTALLSITEMAN3DIR</target>
        </trans-unit>
        <trans-unit id="ce3a6803fc962f8355f8305d4755ca6b09a83fff" translate="yes" xml:space="preserve">
          <source>INSTALLSITESCRIPT</source>
          <target state="translated">INSTALLSITESCRIPT</target>
        </trans-unit>
        <trans-unit id="8fee1b3f92888427d17dfd354d028dcbcbc0ee9c" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORARCH</source>
          <target state="translated">INSTALLVENDORARCH</target>
        </trans-unit>
        <trans-unit id="8b9cc74bd95a4dcfb94e960cfd6efdacf510a333" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORBIN</source>
          <target state="translated">INSTALLVENDORBIN</target>
        </trans-unit>
        <trans-unit id="c8fe30115e9bf08d3e86930e4100d4ce2c1a6393" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORLIB</source>
          <target state="translated">INSTALLVENDORLIB</target>
        </trans-unit>
        <trans-unit id="e80dab2a62b5932a7c992c9d56713d5afabb5666" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN1DIR</source>
          <target state="translated">INSTALLVENDORMAN1DIR</target>
        </trans-unit>
        <trans-unit id="635ef78bb9259eec612010b989a90be923912f75" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORMAN3DIR</source>
          <target state="translated">INSTALLVENDORMAN3DIR</target>
        </trans-unit>
        <trans-unit id="64618110e901d3a5a0394dcdad64f11844b60749" translate="yes" xml:space="preserve">
          <source>INSTALLVENDORSCRIPT</source>
          <target state="translated">INSTALLVENDORSCRIPT</target>
        </trans-unit>
        <trans-unit id="f1bd7855c675170fd5743049f5030b83e6d9486c" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE</source>
          <target state="translated">INSTALL_BASE</target>
        </trans-unit>
        <trans-unit id="972644501aef360867a4520d3945803529f2cc3e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE can be passed into Makefile.PL to change where your module will be installed. INSTALL_BASE is more like what everyone else calls &quot;prefix&quot; than PREFIX is.</source>
          <target state="translated">INSTALL_BASE 可以传递到 Makefile.PL 中来改变模块的安装位置。INSTALL_BASE比PREFIX更像大家所说的 &quot;前缀&quot;。</target>
        </trans-unit>
        <trans-unit id="964f70f55608056234ee8f272195661f239be038" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE in MakeMaker and &lt;code&gt;--install_base&lt;/code&gt; in Module::Build (as of 0.28) install to the same location. If you want MakeMaker and Module::Build to install to the same location simply set INSTALL_BASE and &lt;code&gt;--install_base&lt;/code&gt; to the same location.</source>
          <target state="translated">MakeMaker中的INSTALL_BASE和Module :: Build中的 &lt;code&gt;--install_base&lt;/code&gt; （自0.28起）安装到同一位置。如果要将MakeMaker和Module :: Build安装到同一位置，只需将INSTALL_BASE和 &lt;code&gt;--install_base&lt;/code&gt; 设置到同一位置。</target>
        </trans-unit>
        <trans-unit id="c3f863f63a3576929f3be4a5b8b4b41019807a08" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE tells these tools to put your modules into</source>
          <target state="translated">INSTALL_BASE会告诉这些工具把你的模块放到</target>
        </trans-unit>
        <trans-unit id="7b883de1f22bd64a8fb3db547deeba102b803a0e" translate="yes" xml:space="preserve">
          <source>INSTALL_BASE was added in 6.31.</source>
          <target state="translated">在6.31中增加了INSTALL_BASE。</target>
        </trans-unit>
        <trans-unit id="886581b5b89b6e85f222ace37294af35562883c9" translate="yes" xml:space="preserve">
          <source>INST_ARCHLIB</source>
          <target state="translated">INST_ARCHLIB</target>
        </trans-unit>
        <trans-unit id="8a2379bc7653dd5379a3e78bb80106b03ea038a2" translate="yes" xml:space="preserve">
          <source>INST_BIN</source>
          <target state="translated">INST_BIN</target>
        </trans-unit>
        <trans-unit id="b3767b1163f565cbd5848c1ada0a99e721fdaa0f" translate="yes" xml:space="preserve">
          <source>INST_LIB</source>
          <target state="translated">INST_LIB</target>
        </trans-unit>
        <trans-unit id="391959e82830797dda34f122ffd715943af1eafc" translate="yes" xml:space="preserve">
          <source>INST_MAN1DIR</source>
          <target state="translated">INST_MAN1DIR</target>
        </trans-unit>
        <trans-unit id="eb72524f0c074de5e6da6ca437d4e86dc340dc3b" translate="yes" xml:space="preserve">
          <source>INST_MAN3DIR</source>
          <target state="translated">INST_MAN3DIR</target>
        </trans-unit>
        <trans-unit id="0e2cba5b7722f5d7d798d0a11841e1fc5d220d67" translate="yes" xml:space="preserve">
          <source>INST_SCRIPT</source>
          <target state="translated">INST_SCRIPT</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="325df994199a5a3b5bfde97c65a8f35d498e9bab" translate="yes" xml:space="preserve">
          <source>INTERNAL FORMAT</source>
          <target state="translated">内部格式</target>
        </trans-unit>
        <trans-unit id="f2ee4f9d199f048c10a5b49f80f81e925ff271d9" translate="yes" xml:space="preserve">
          <source>INTERNAL VARIABLE TYPES</source>
          <target state="translated">内部变量类型</target>
        </trans-unit>
        <trans-unit id="ae880205d974d478a4f8301ed9ed724acfe764dd" translate="yes" xml:space="preserve">
          <source>INTERNALS</source>
          <target state="translated">INTERNALS</target>
        </trans-unit>
        <trans-unit id="0270ca97abe5bddc53ed95fb7179da4406621a18" translate="yes" xml:space="preserve">
          <source>INTRODUCTION</source>
          <target state="translated">INTRODUCTION</target>
        </trans-unit>
        <trans-unit id="0f6bca99bbb2a730f1c35f8aa2b2773658a27931" translate="yes" xml:space="preserve">
          <source>INTUIT</source>
          <target state="translated">INTUIT</target>
        </trans-unit>
        <trans-unit id="ce753ef37866a2969f587c295482b688037bd94e" translate="yes" xml:space="preserve">
          <source>IN_LOCALE</source>
          <target state="translated">IN_LOCALE</target>
        </trans-unit>
        <trans-unit id="4e3731a31894b7187bb76565396bb61a32a82161" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_COMPILETIME</source>
          <target state="translated">IN_LOCALE_COMPILETIME</target>
        </trans-unit>
        <trans-unit id="b36325353ec225c227d7b482dcf439805cffb50a" translate="yes" xml:space="preserve">
          <source>IN_LOCALE_RUNTIME</source>
          <target state="translated">IN_LOCALE_RUNTIME</target>
        </trans-unit>
        <trans-unit id="9d8fb39373007c2c84580d473e2a6e10a1f4c15d" translate="yes" xml:space="preserve">
          <source>IO</source>
          <target state="translated">IO</target>
        </trans-unit>
        <trans-unit id="9703b620b98df0424c1d2891029b0a53270adadc" translate="yes" xml:space="preserve">
          <source>IO - load various IO modules</source>
          <target state="translated">IO--加载各种IO模块</target>
        </trans-unit>
        <trans-unit id="8218c7c584e2e73f83429a7a715ed0c77b1e9143" translate="yes" xml:space="preserve">
          <source>IO Functions</source>
          <target state="translated">IO功能</target>
        </trans-unit>
        <trans-unit id="8e8c7b4a7985c2b9c9f4e596a14848275f335be5" translate="yes" xml:space="preserve">
          <source>IO Redirect</source>
          <target state="translated">IO重定向</target>
        </trans-unit>
        <trans-unit id="1a4992825d003b9237bfbb2d1eeebbc4148368e7" translate="yes" xml:space="preserve">
          <source>IO layers (like '%s') unavailable</source>
          <target state="translated">IO层(如'%s')不可用。</target>
        </trans-unit>
        <trans-unit id="95153958c8a3fc0d7cc0242c39911001df17f39d" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO ::样式接口到&lt;a href=&quot;Compress::Zlib&quot;&gt;Compress :: Zlib&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2e82ec6ecdf1d506a4bc4471deaf660ec582141" translate="yes" xml:space="preserve">
          <source>IO:: style interface to &lt;a href=&quot;compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO ::样式接口到&lt;a href=&quot;compress/zlib&quot;&gt;Compress :: Zlib&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d76ad5f2ab8e85a14e373d86896f0b50ad94632d" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base</source>
          <target state="translated">IO::Compress::Base</target>
        </trans-unit>
        <trans-unit id="f7a823195ba1022235bbaa930f5dacd9dcd2cde3" translate="yes" xml:space="preserve">
          <source>IO::Compress::Base - Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress::Base-IO::Compress模块的基类。</target>
        </trans-unit>
        <trans-unit id="2246092601d71db730b1277537bdfeb99922692b" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2</source>
          <target state="translated">IO::Compress::Bzip2</target>
        </trans-unit>
        <trans-unit id="4c110e2dd18855a5ac17fa0ff96df45279296253" translate="yes" xml:space="preserve">
          <source>IO::Compress::Bzip2 - Write bzip2 files/buffers</source>
          <target state="translated">IO::Compress::Bzip2-写入bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="faeedf86bc5c3bf443dc7cb32aca40a75c1a61b1" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate</source>
          <target state="translated">IO::Compress::Deflate</target>
        </trans-unit>
        <trans-unit id="a24fa13516822c712bdf720b0c4b0786c457612f" translate="yes" xml:space="preserve">
          <source>IO::Compress::Deflate - Write RFC 1950 files/buffers</source>
          <target state="translated">IO::Compress::Deflate-写入RFC 1950文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="f27ab19280760fb919a1e3287acc4b2ced04c845" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ</source>
          <target state="translated">IO::Compress::FAQ</target>
        </trans-unit>
        <trans-unit id="7dd8dce39506e0315c95f5807e0b2eb0d3b042f5" translate="yes" xml:space="preserve">
          <source>IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress</source>
          <target state="translated">IO::Compress::FAQ --关于IO::Compress的常见问题。</target>
        </trans-unit>
        <trans-unit id="c7fa9683b439c9ad1a7266191cc46683626bdae6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip</source>
          <target state="translated">IO::Compress::Gzip</target>
        </trans-unit>
        <trans-unit id="9e41ceaa77fd713ed3c8d8b1bfe6a609a7ddcea6" translate="yes" xml:space="preserve">
          <source>IO::Compress::Gzip - Write RFC 1952 files/buffers</source>
          <target state="translated">IO::Compress::Gzip-写入RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="3205da05670e0698dd32ff4811dcf7e209aab757" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate</source>
          <target state="translated">IO::Compress::RawDeflate</target>
        </trans-unit>
        <trans-unit id="94bf2f893b55a2f57dfacc0d6c1e83c0ef44793d" translate="yes" xml:space="preserve">
          <source>IO::Compress::RawDeflate - Write RFC 1951 files/buffers</source>
          <target state="translated">IO::Compress::RawDeflate-写入RFC 1951文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="7015e5f6eae1214c2df0155ccaef808cdc7d0769" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip</source>
          <target state="translated">IO::Compress::Zip</target>
        </trans-unit>
        <trans-unit id="b05cb1e00a4226cff2f721fcd3f609b4ad94b38c" translate="yes" xml:space="preserve">
          <source>IO::Compress::Zip - Write zip files/buffers</source>
          <target state="translated">IO::Compress::Zip-写入zip文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="4bf7c8cfd258e92c5a7a288432da2eb725c5d32c" translate="yes" xml:space="preserve">
          <source>IO::Dir</source>
          <target state="translated">IO::Dir</target>
        </trans-unit>
        <trans-unit id="f3b94128fba8d6583679638179ef4a0530bdd5d3" translate="yes" xml:space="preserve">
          <source>IO::Dir - supply object methods for directory handles</source>
          <target state="translated">IO::Dir-为目录句柄提供对象方法</target>
        </trans-unit>
        <trans-unit id="1287d92d070eaf8f54116ae56a21bfe69917a99d" translate="yes" xml:space="preserve">
          <source>IO::File</source>
          <target state="translated">IO::File</target>
        </trans-unit>
        <trans-unit id="aef399115f05d82a203fb89d5e657a748c3e82de" translate="yes" xml:space="preserve">
          <source>IO::File - supply object methods for filehandles</source>
          <target state="translated">IO::File-为filehandles提供对象方法。</target>
        </trans-unit>
        <trans-unit id="85678e755d6fdd386f63c43333047c282a85eb74" translate="yes" xml:space="preserve">
          <source>IO::Handle</source>
          <target state="translated">IO::Handle</target>
        </trans-unit>
        <trans-unit id="d2ccf931b06cca09cc21fc6e3f7adaeb42eedc30" translate="yes" xml:space="preserve">
          <source>IO::Handle - supply object methods for I/O handles</source>
          <target state="translated">IO::Handle-为I/O句柄提供对象方法。</target>
        </trans-unit>
        <trans-unit id="33e6674e03fd1f9387dffec88a9442f12eb239c1" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_formfeed(EXPR)</source>
          <target state="translated">IO::Handle-&amp;gt;format_formfeed(EXPR)</target>
        </trans-unit>
        <trans-unit id="4328314a142bc495dbcedc8dec821af05b31bc33" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;format_line_break_characters EXPR</source>
          <target state="translated">IO :: Handle-&amp;gt; format_line_break_characters EXPR</target>
        </trans-unit>
        <trans-unit id="6e5d46bf8e867cd748990f3121e29b41bc040337" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;input_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; input_record_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="88d38bb7198b1035ad2fe3e3a4c8b631ea81ae89" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_field_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_field_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="960c5c651b09566f1754a215a5295869a49e219e" translate="yes" xml:space="preserve">
          <source>IO::Handle-&amp;gt;output_record_separator( EXPR )</source>
          <target state="translated">IO :: Handle-&amp;gt; output_record_separator（EXPR）</target>
        </trans-unit>
        <trans-unit id="7d7436d4629d382e64fc528a233e4705d021fb55" translate="yes" xml:space="preserve">
          <source>IO::Pipe</source>
          <target state="translated">IO::Pipe</target>
        </trans-unit>
        <trans-unit id="00e90fb1e0a6527593ec48869ad8bdd4be4727ec" translate="yes" xml:space="preserve">
          <source>IO::Pipe - supply object methods for pipes</source>
          <target state="translated">IO::Pipe-为管道提供对象方法。</target>
        </trans-unit>
        <trans-unit id="7411852690ce77d3e52c0392cb140a1da3c8926a" translate="yes" xml:space="preserve">
          <source>IO::Poll</source>
          <target state="translated">IO::Poll</target>
        </trans-unit>
        <trans-unit id="4af10858345e94c5247f732b4f8aeefb3d3033f8" translate="yes" xml:space="preserve">
          <source>IO::Poll - Object interface to system poll call</source>
          <target state="translated">IO::Poll-系统轮询调用的对象接口。</target>
        </trans-unit>
        <trans-unit id="a68be240586077bf55c7114e0c2dd0a3089b0b00" translate="yes" xml:space="preserve">
          <source>IO::Seekable</source>
          <target state="translated">IO::Seekable</target>
        </trans-unit>
        <trans-unit id="aca83121c079f3f44793e1fb400037048e6c0ec3" translate="yes" xml:space="preserve">
          <source>IO::Seekable - supply seek based methods for I/O objects</source>
          <target state="translated">IO::Seekable-为I/O对象提供基于寻求的方法。</target>
        </trans-unit>
        <trans-unit id="a4d83b02d49f96871e2c2e3d92dc1e0d34ec01f3" translate="yes" xml:space="preserve">
          <source>IO::Select</source>
          <target state="translated">IO::Select</target>
        </trans-unit>
        <trans-unit id="f909f3c8685d0640556ffd855c6e6b3161826eb6" translate="yes" xml:space="preserve">
          <source>IO::Select - OO interface to the select system call</source>
          <target state="translated">IO::Select-用于选择系统调用的OO接口。</target>
        </trans-unit>
        <trans-unit id="77ccdb7781ae721df7a63530341f8d0e30eb9ba3" translate="yes" xml:space="preserve">
          <source>IO::Socket</source>
          <target state="translated">IO::Socket</target>
        </trans-unit>
        <trans-unit id="bcf86f1138a4fa3de29dc58d70750df124a76378" translate="yes" xml:space="preserve">
          <source>IO::Socket - Object interface to socket communications</source>
          <target state="translated">IO::Socket-套接字通信的对象接口。</target>
        </trans-unit>
        <trans-unit id="d9cad026ce1354129e7518abf6e60742a423f5cd" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET</source>
          <target state="translated">IO::Socket::INET</target>
        </trans-unit>
        <trans-unit id="21c7e3d3993af799697bb17b584159010291f1ca" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET - Object interface for AF_INET domain sockets</source>
          <target state="translated">IO::Socket::INET-AF_INET域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="847540cd1ff5e36f63fe89cede6f91a6c8dc3cc9" translate="yes" xml:space="preserve">
          <source>IO::Socket::INET INCOMPATIBILITES</source>
          <target state="translated">IO::Socket::INET INCOMPATIBILITES</target>
        </trans-unit>
        <trans-unit id="90c6a2e029e8c8c79ed477acabec06a520b7120a" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP</source>
          <target state="translated">IO::Socket::IP</target>
        </trans-unit>
        <trans-unit id="f8d87248556e958244a0c1aaa8d71d0e3f955f2d" translate="yes" xml:space="preserve">
          <source>IO::Socket::IP version 0.25 or IO::Socket::INET6 version 2.62 is required for IPv6 support.</source>
          <target state="translated">支持IPv6需要IO::Socket::IP版本0.25或IO::Socket::INET6版本2.62。</target>
        </trans-unit>
        <trans-unit id="ef92351b8f3537bb6cc9713b22a0a29a3dd06aa7" translate="yes" xml:space="preserve">
          <source>IO::Socket::SSL version 2.007 or higher is required for SSL support.</source>
          <target state="translated">支持SSL需要IO::Socket::SSL 2.007或更高版本。</target>
        </trans-unit>
        <trans-unit id="8d370bee8efab5b347f028125483323b0c8ed6d8" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX</source>
          <target state="translated">IO::Socket::UNIX</target>
        </trans-unit>
        <trans-unit id="fd6fc205eb14f250173655f91ae8e3991e80a0fc" translate="yes" xml:space="preserve">
          <source>IO::Socket::UNIX - Object interface for AF_UNIX domain sockets</source>
          <target state="translated">IO::Socket::UNIX-AF_UNIX域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="d387a4118fc41f5c91b925119de8c6c9b651a7b5" translate="yes" xml:space="preserve">
          <source>IO::Socket::atmark not implemented on this architecture</source>
          <target state="translated">IO::Socket::atmark在这个架构上没有实现。</target>
        </trans-unit>
        <trans-unit id="cc9efdf30a325c69f4eff01ffa74edfa8d13285c" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate</source>
          <target state="translated">IO::Uncompress::AnyInflate</target>
        </trans-unit>
        <trans-unit id="3f52359b31109c62a3cfec4235eb32afa54b7e76" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer</source>
          <target state="translated">IO::Uncompress::AnyInflate-解压基于zlib(zip,gzip)的文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="9bcf772c56ff61361b8adfe8ed0930e47dd806cc" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress</source>
          <target state="translated">IO::Uncompress::AnyUncompress</target>
        </trans-unit>
        <trans-unit id="da915e62cd2924afaf5bdf41d62bf124d1816c96" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer</source>
          <target state="translated">IO::Uncompress::AnyUncompress-解压gzip、zip、bzip2或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="a94c8d52ccfd5a43c50325b3be6e5dc8c0de211d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2, xz, lzma, lzip, lzf or lzop file/buffer</source>
          <target state="translated">IO::Uncompress::AnyUncompress-解压gzip,zip,bzip2,xz,lzma,lzip,lzf或lzop文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="5b9d98befeabd4f68c0ee5ed490ad9ef9466ce0b" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base</source>
          <target state="translated">IO::Uncompress::Base</target>
        </trans-unit>
        <trans-unit id="6dd0aef5e96daa96cabb662e679bcaf3f782ff34" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Base - Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress::Base-IO::Uncompress模块的基类。</target>
        </trans-unit>
        <trans-unit id="47626e73b0c552496671b93615517289c7a72139" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2</source>
          <target state="translated">IO::Uncompress::Bunzip2</target>
        </trans-unit>
        <trans-unit id="558fc1d47555183743c62caa50f8fea7e57150e4" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Bunzip2 - Read bzip2 files/buffers</source>
          <target state="translated">IO::Uncompress::Bunzip2-读取bzip2文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="c56a044dac563ce20e270b6dad9d51e1ed4d67b5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip</source>
          <target state="translated">IO::Uncompress::Gunzip</target>
        </trans-unit>
        <trans-unit id="6858dbc4b4fa294b4bc17de10e3aec6d95c7a29d" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Gunzip - Read RFC 1952 files/buffers</source>
          <target state="translated">IO::Uncompress::Gunzip-读取RFC 1952文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="bdd707a0a7c129500d87baf2238a9f12252dc1a6" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate</source>
          <target state="translated">IO::Uncompress::Inflate</target>
        </trans-unit>
        <trans-unit id="9ea3fd5cd65551930396ea883f6b4523a57e56f5" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Inflate - Read RFC 1950 files/buffers</source>
          <target state="translated">IO::Uncompress::Inflate-读取RFC 1950文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="2387ca346858e6f631ae40207df5832845bfa4d3" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate</source>
          <target state="translated">IO::Uncompress::RawInflate</target>
        </trans-unit>
        <trans-unit id="0d1105cd05d8ddcb7bbad73158149f37cd425d0a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::RawInflate - Read RFC 1951 files/buffers</source>
          <target state="translated">IO::Uncompress::RawInflate-读取RFC1951文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="eb25986effc3adf3d081252f8af9cf0ffcfb3a8a" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip</source>
          <target state="translated">IO::Uncompress::Unzip</target>
        </trans-unit>
        <trans-unit id="7aed8f7e034916e56f4674cc0310d37a446ee94f" translate="yes" xml:space="preserve">
          <source>IO::Uncompress::Unzip - Read zip files/buffers</source>
          <target state="translated">IO::Uncompress::Unzip-读取zip文件/缓冲区。</target>
        </trans-unit>
        <trans-unit id="f4c4eb93eddc35e78414020ae5db828e1e7864b8" translate="yes" xml:space="preserve">
          <source>IO::Zlib</source>
          <target state="translated">IO::Zlib</target>
        </trans-unit>
        <trans-unit id="d04446e459b1e71b578f998f8ab90764c4b0f8e3" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;../compress/zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib- &lt;a href=&quot;../compress/zlib&quot;&gt;压缩:: Zlib的&lt;/a&gt; IO ::样式接口</target>
        </trans-unit>
        <trans-unit id="1a833dc84965b791c8180a7f9bca2ad00d4ae502" translate="yes" xml:space="preserve">
          <source>IO::Zlib - IO:: style interface to &lt;a href=&quot;Compress::Zlib&quot;&gt;Compress::Zlib&lt;/a&gt;</source>
          <target state="translated">IO :: Zlib-&lt;a href=&quot;Compress::Zlib&quot;&gt;压缩:: Zlib的&lt;/a&gt;IO ::样式接口</target>
        </trans-unit>
        <trans-unit id="d3f1ff5ae16f8f008a024c94a2871ed43a079e29" translate="yes" xml:space="preserve">
          <source>IO::Zlib::READ: NBYTES must be specified</source>
          <target state="translated">IO::Zlib::READ:必须指定NBYTES。</target>
        </trans-unit>
        <trans-unit id="b518756109da5b44c543995580fa7fa3fe28da6b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::WRITE: too long LENGTH</source>
          <target state="translated">IO::Zlib::WRITE:太长了 LENGTH</target>
        </trans-unit>
        <trans-unit id="16afa17f59e61e732bb594e1d07367170d0e3516" translate="yes" xml:space="preserve">
          <source>IO::Zlib::getlines: must be called in list context</source>
          <target state="translated">IO::Zlib::getlines:必须在列表上下文中调用。</target>
        </trans-unit>
        <trans-unit id="744b77ff3abbf3b6e1e64e30f7190f2e0e168879" translate="yes" xml:space="preserve">
          <source>IO::Zlib::gzopen_external: mode '...' is illegal</source>
          <target state="translated">IO::Zlib::gzopen_external:mode '...' is illegal</target>
        </trans-unit>
        <trans-unit id="c2ece9d22f9b2c053955dd1211c105cea7756474" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: '...' is illegal</source>
          <target state="translated">IO::Zlib::import。'...'是非法的</target>
        </trans-unit>
        <trans-unit id="84556d1d56bdf3da066fa6199f9990e8d2a4eaa9" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: ':gzip_external' requires an argument</source>
          <target state="translated">IO::Zlib::import。':gzip_external'需要一个参数。</target>
        </trans-unit>
        <trans-unit id="f33a6e3d14094a99186bbb131dd967ca442a99e2" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read' '...' is illegal</source>
          <target state="translated">IO::Zlib::import。'gzip_read' '...' 是非法的。</target>
        </trans-unit>
        <trans-unit id="430510c63254c938fe8a419081620b44e9a63369" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_read_open' requires an argument</source>
          <target state="translated">IO::Zlib::导入。'gzip_read_open'需要一个参数。</target>
        </trans-unit>
        <trans-unit id="5ef06ad0f4357c011fb32988808d09f0b27277a4" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' '...' is illegal</source>
          <target state="translated">IO::Zlib::导入。'gzip_write_open' '...' 是非法的。</target>
        </trans-unit>
        <trans-unit id="48cbd51a10bd74c633549cef79628135e981981b" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: 'gzip_write_open' requires an argument</source>
          <target state="translated">IO::Zlib::import。'gzip_write_open'需要一个参数。</target>
        </trans-unit>
        <trans-unit id="27cde92750a3d48d656e69ded8901f66e2e3f4c3" translate="yes" xml:space="preserve">
          <source>IO::Zlib::import: no Compress::Zlib and no external gzip</source>
          <target state="translated">IO::Zlib::import:没有Compress::Zlib,也没有外部gzip。</target>
        </trans-unit>
        <trans-unit id="baefedf7f6990fe793b903ceae7ef91bfaf79c09" translate="yes" xml:space="preserve">
          <source>IO::Zlib::open: needs a filename</source>
          <target state="translated">IO::Zlib::open:需要一个文件名。</target>
        </trans-unit>
        <trans-unit id="ea424d38af72dd1366a08aad1f47eca3e7ec3d24" translate="yes" xml:space="preserve">
          <source>IP</source>
          <target state="translated">IP</target>
        </trans-unit>
        <trans-unit id="e66f01e3abb1a4678f130fa0379ceec3adaec42e" translate="yes" xml:space="preserve">
          <source>IP protocol constants to use as the third argument to socket(), the level argument to getsockopt() or setsockopt(), or the value of the &lt;code&gt;SO_PROTOCOL&lt;/code&gt; socket option.</source>
          <target state="translated">IP协议常量，用作socket（）的第三个参数，getsockopt（）或setsockopt（）的level参数，或 &lt;code&gt;SO_PROTOCOL&lt;/code&gt; 套接字选项的值。</target>
        </trans-unit>
        <trans-unit id="061b6bad243fee6cf3f9b677d21494fee55f1c64" translate="yes" xml:space="preserve">
          <source>IPA</source>
          <target state="translated">IPA</target>
        </trans-unit>
        <trans-unit id="f4aa7e6cdf843e01253be3fd2becaee731842f78" translate="yes" xml:space="preserve">
          <source>IPC</source>
          <target state="translated">IPC</target>
        </trans-unit>
        <trans-unit id="d54b59c534e736687131e3ec256172d1adbc895d" translate="yes" xml:space="preserve">
          <source>IPC AND CONCURRENCY</source>
          <target state="translated">IPC和一致性</target>
        </trans-unit>
        <trans-unit id="b9e5cff8767ed4c7882144c6f5c7afd4a74a2869" translate="yes" xml:space="preserve">
          <source>IPC drivers live in this namespace. It is fine to create new IPC drivers and to put them in this namespace.</source>
          <target state="translated">IPC驱动程序存在于这个命名空间中。创建新的IPC驱动程序并将它们放在这个命名空间中是可以的。</target>
        </trans-unit>
        <trans-unit id="25bb80888fafae35a8c04a482f4c52ba12354860" translate="yes" xml:space="preserve">
          <source>IPC::Cmd</source>
          <target state="translated">IPC::Cmd</target>
        </trans-unit>
        <trans-unit id="4aa727aa3bbf49a23200ff9a15dd661ace7ba750" translate="yes" xml:space="preserve">
          <source>IPC::Cmd - finding and running system commands made easy</source>
          <target state="translated">IPC::Cmd-让查找和运行系统命令变得更容易。</target>
        </trans-unit>
        <trans-unit id="9e94bec610bda8b6d6dba9768e7c89860ea7cbd2" translate="yes" xml:space="preserve">
          <source>IPC::Cmd allows you to run commands platform independently, interactively if desired, but have them still work.</source>
          <target state="translated">IPC::Cmd允许你独立地运行命令平台,如果需要的话,可以交互式地运行,但仍然可以工作。</target>
        </trans-unit>
        <trans-unit id="55a4e391e67ff1bdcc3e16ba0fb5ae458ce57904" translate="yes" xml:space="preserve">
          <source>IPC::Msg</source>
          <target state="translated">IPC::Msg</target>
        </trans-unit>
        <trans-unit id="6b32de39850adb752165f60b3bda5f0d97f34ff3" translate="yes" xml:space="preserve">
          <source>IPC::Msg - SysV Msg IPC object class</source>
          <target state="translated">IPC::Msg-SysV Msg IPC对象类</target>
        </trans-unit>
        <trans-unit id="9dd902f8639b58e7edb7b6f8c06c22ac41c9ca2e" translate="yes" xml:space="preserve">
          <source>IPC::Open2</source>
          <target state="translated">IPC::Open2</target>
        </trans-unit>
        <trans-unit id="699765d9577f1c1501174faba27f2ca1f61d47cd" translate="yes" xml:space="preserve">
          <source>IPC::Open2 - open a process for both reading and writing using open2()</source>
          <target state="translated">IPC::Open2-使用open2()打开一个读写进程。</target>
        </trans-unit>
        <trans-unit id="6e80951681402ceb79b82897f2cb2015d59ab625" translate="yes" xml:space="preserve">
          <source>IPC::Open3</source>
          <target state="translated">IPC::Open3</target>
        </trans-unit>
        <trans-unit id="cbebbea4476633d292dae0e9b37d3ff0220e8a12" translate="yes" xml:space="preserve">
          <source>IPC::Open3 - open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">IPC::Open3-使用open3()打开一个进程进行读、写和错误处理。</target>
        </trans-unit>
        <trans-unit id="e9c314ea8a55f232d58be815a30ee23b54cdb80b" translate="yes" xml:space="preserve">
          <source>IPC::Run</source>
          <target state="translated">IPC::Run</target>
        </trans-unit>
        <trans-unit id="5696dbec647d54eae7948ff758da75aceb6e7bdd" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore</source>
          <target state="translated">IPC::Semaphore</target>
        </trans-unit>
        <trans-unit id="4ac3e2f97ecebc0c9df272394b412c2bc0e4c139" translate="yes" xml:space="preserve">
          <source>IPC::Semaphore - SysV Semaphore IPC object class</source>
          <target state="translated">IPC::Semaphore-SysV Semaphore IPC对象类。</target>
        </trans-unit>
        <trans-unit id="eaac05351199d5338d0c67774a49f0ff5b08ddcd" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem</source>
          <target state="translated">IPC::SharedMem</target>
        </trans-unit>
        <trans-unit id="b67329129b7437abd470390d9b8de8b506578731" translate="yes" xml:space="preserve">
          <source>IPC::SharedMem - SysV Shared Memory IPC object class</source>
          <target state="translated">IPC::SharedMem-SysV共享内存IPC对象类。</target>
        </trans-unit>
        <trans-unit id="cac6bf077ecf12b8c4774537cb90121c12f40546" translate="yes" xml:space="preserve">
          <source>IPC::SysV</source>
          <target state="translated">IPC::SysV</target>
        </trans-unit>
        <trans-unit id="4a65a5b9999ec2f5bcb9aefce9ed4d2ebb83e351" translate="yes" xml:space="preserve">
          <source>IPC::SysV - System V IPC constants and system calls</source>
          <target state="translated">IPC::SysV-系统 V IPC 常量和系统调用。</target>
        </trans-unit>
        <trans-unit id="eb04f21953f498789cba10742ad8acc6a3a6d8ee" translate="yes" xml:space="preserve">
          <source>IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning the output looks like '13' on STDOUT and '24' on STDERR, instead of</source>
          <target state="translated">IPC::[Run|Open3]将首先读取所有的STDOUT,然后再读取所有的STDERR,这意味着输出在STDOUT上是'13',在STDERR上是'24',而非</target>
        </trans-unit>
        <trans-unit id="c31963d765721dcd50b3ac6ea7828e71081eb9d0" translate="yes" xml:space="preserve">
          <source>IPPROTO_IP, IPPROTO_IPV6, IPPROTO_TCP, ...</source>
          <target state="translated">IPPROTO_IP,IPPROTO_IPV6,IPPROTO_TCP,...。</target>
        </trans-unit>
        <trans-unit id="d605f8c901e4d72b551c09d9a4925d13cd9fbbb6" translate="yes" xml:space="preserve">
          <source>IPTOS_LOWDELAY, IPTOS_THROUGHPUT, IPTOS_RELIABILITY, ...</source>
          <target state="translated">IPTOS_LOWDELAY,IPTOS_THROUGHPUT,IPTOS_RELIABILITY,...。</target>
        </trans-unit>
        <trans-unit id="b69eb35e4d4802a904ccf4f4eadf16b1c7831980" translate="yes" xml:space="preserve">
          <source>IPV6_ADD_MEMBERSHIP, IPV6_MTU, IPV6_V6ONLY, ...</source>
          <target state="translated">IPV6_ADD_MEMBERSHIP,IPV6_MTU,IPV6_V6ONLY,...</target>
        </trans-unit>
        <trans-unit id="5dcc16ca06e8e1e2d76e2715098a08de9cb62845" translate="yes" xml:space="preserve">
          <source>IP_OPTIONS, IP_TOS, IP_TTL, ...</source>
          <target state="translated">IP_OPTIONS,IP_TOS,IP_TTL,...</target>
        </trans-unit>
        <trans-unit id="52736177bb0ddc7186d53ccc0e904a6fc38535ec" translate="yes" xml:space="preserve">
          <source>IP_PMTUDISC_WANT, IP_PMTUDISC_DONT, ...</source>
          <target state="translated">IP_PMTUDISC_WANT,IP_PMTUDISC_DONT,...。</target>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="e845e309f2bc4605301c4c8195c02b9ee45aab86" translate="yes" xml:space="preserve">
          <source>IRIX 6.5 documentation on syslog, &lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&lt;/a&gt;</source>
          <target state="translated">Syslog上的IRIX 6.5文档，&lt;a href=&quot;http://techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi?coll=0650&amp;amp;db=man&amp;amp;fname=3c+syslog&quot;&gt;http：&lt;/a&gt; //techpubs.sgi.com/library/tpl/cgi-bin/getdoc.cgi？coll = 0650＆db = man＆fname = 3c + syslog</target>
        </trans-unit>
        <trans-unit id="9e349cb6fd67b0b7af90f7902a26799f4b980ca8" translate="yes" xml:space="preserve">
          <source>IRIX documentation on syslog, &lt;a href=&quot;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&quot;&gt;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&lt;/a&gt;</source>
          <target state="translated">Syslog上的IRIX文档，&lt;a href=&quot;http://nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&quot;&gt;http：//nixdoc.net/man-pages/IRIX/man3/syslog.3c.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="407683774352e467c08d20959c8dcea8f6ef7fa7" translate="yes" xml:space="preserve">
          <source>ISIRI 3342, Iran System, ISIRI 2900 [Farsi]</source>
          <target state="translated">ISIRI 3342,伊朗系统,ISIRI 2900[法西语]</target>
        </trans-unit>
        <trans-unit id="4f325d995b6d028ccc75771b1679537b623521c4" translate="yes" xml:space="preserve">
          <source>ISO</source>
          <target state="translated">ISO</target>
        </trans-unit>
        <trans-unit id="f776e0bcef88f6053e04b30cd9568a2f517c3848" translate="yes" xml:space="preserve">
          <source>ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it. Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.</source>
          <target state="translated">ISO 6429标准可向ISO收费索取;本单元的作者不拥有该标准的副本。由于ISO 6429的原始材料是ECMA-048,而后者是免费提供的,因此似乎没有什么理由获得ISO标准。</target>
        </trans-unit>
        <trans-unit id="3353e215f71b71f7414efad5057c41576384753e" translate="yes" xml:space="preserve">
          <source>ISO 8859</source>
          <target state="translated">ISO 8859</target>
        </trans-unit>
        <trans-unit id="8fb0773017f88d072a29c4af9bf4189cc9c9a466" translate="yes" xml:space="preserve">
          <source>ISO 8859-1 (Latin-1)</source>
          <target state="translated">ISO 8859-1(拉丁文-1)</target>
        </trans-unit>
        <trans-unit id="58189607ac5de761659ad85bfe08184fa60a5f97" translate="yes" xml:space="preserve">
          <source>ISO codes for country sub-divisions (states, counties, provinces, etc), as defined in ISO 3166-2. This module is not part of the Locale-Codes distribution, but is available from CPAN in CPAN/modules/by-module/Locale/</source>
          <target state="translated">ISO 3166-2中定义的国家分区(州、县、省等)的ISO代码。该模块不属于Locale-Codes发行版,但可从CPAN/modules/by-module/Locale/中获得。</target>
        </trans-unit>
        <trans-unit id="2ee43903e014e67bbc02a16177f46410f4c5e2d5" translate="yes" xml:space="preserve">
          <source>ISO-2022</source>
          <target state="translated">ISO-2022</target>
        </trans-unit>
        <trans-unit id="0be641e76803b7f8b2767005594a25c505dcb463" translate="yes" xml:space="preserve">
          <source>ISO-2022-CN [RFC1922]</source>
          <target state="translated">ISO-2022-CN[RMF1922]。</target>
        </trans-unit>
        <trans-unit id="e2562b9e7af09019f9f6f2808d127ef571d29778" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-1 (RFC2237) is a superset of ISO-2022-JP (RFC1468) which adds support for JIS X 0212-1990. That means you can use the same code to decode to utf8 but not vice versa.</source>
          <target state="translated">ISO-2022-JP-1(RFC2237)是ISO-2022-JP(RFC1468)的超集,增加了对JIS X 0212-1990的支持。这意味着您可以使用相同的代码来解码到utf8,但不能反过来。</target>
        </trans-unit>
        <trans-unit id="29cc7458d9efed7fe50460a3c77c7b87ac7a4db4" translate="yes" xml:space="preserve">
          <source>ISO-2022-JP-2 [RFC1554]</source>
          <target state="translated">ISO-2022-JIP-2[RFC1554]。</target>
        </trans-unit>
        <trans-unit id="63ffbc186932bc40f01e94ff7f5da5bf38a7154e" translate="yes" xml:space="preserve">
          <source>ISO-8859 and corresponding vendor mappings</source>
          <target state="translated">ISO-8859和相应的供应商映射。</target>
        </trans-unit>
        <trans-unit id="19de626ae38d6fda9f9525299d239d5c0047248b" translate="yes" xml:space="preserve">
          <source>ISO-8859-8-1 [Hebrew]</source>
          <target state="translated">ISO-8859-8-1 [希伯来文]</target>
        </trans-unit>
        <trans-unit id="846e5e5cfd7e004c49ed6ae8c1a88eb61f8816e2" translate="yes" xml:space="preserve">
          <source>ISO/IEC 10646 encoding form: Universal Character Set coded in two octets.</source>
          <target state="translated">ISO/IEC 10646编码形式。以两个八位数编码的通用字符集。</target>
        </trans-unit>
        <trans-unit id="13dc9cc90e3e41be961fd70df5f28ccfd86e620a" translate="yes" xml:space="preserve">
          <source>ISSUES</source>
          <target state="translated">ISSUES</target>
        </trans-unit>
        <trans-unit id="c5d9779f83f04a49a66dda9ed50dc9241b27d743" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_GREATER_THAN_UV_MAX bool IS_NUMBER_GREATER_THAN_UV_MAX</source>
          <target state="translated">本章主要介绍了如何使用本章的内容。</target>
        </trans-unit>
        <trans-unit id="d4f5693602a943228410c2db90175bdc9e162f71" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_INFINITY bool IS_NUMBER_INFINITY</source>
          <target state="translated">IS_NUMBER_INFINITY bool IS_NUMBER_INFINITY.</target>
        </trans-unit>
        <trans-unit id="ed51a22a984a7a3384cf7607e6083139f796bac6" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_IN_UV bool IS_NUMBER_IN_UV</source>
          <target state="translated">IS_NUMBER_IN_UV bool IS_NUMBER_IN_UV.</target>
        </trans-unit>
        <trans-unit id="3b619f91f9748472f17789ce360cdba95124ee65" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NAN bool IS_NUMBER_NAN</source>
          <target state="translated">IS_NUMBER_NAN bool IS_NUMBER_NAN.</target>
        </trans-unit>
        <trans-unit id="63251c261b533d85d9b19ec08396f8b333d44ea2" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NEG bool IS_NUMBER_NEG</source>
          <target state="translated">IS_NUMBER_NEG bool IS_NUMBER_NEG.</target>
        </trans-unit>
        <trans-unit id="13d56a5e4d44a907f0379be77749d8420d47b899" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT</source>
          <target state="translated">IS_NUMBER_NOT_INT</target>
        </trans-unit>
        <trans-unit id="6c84053d4886e789ea8b111c5248970e59a2046c" translate="yes" xml:space="preserve">
          <source>IS_NUMBER_NOT_INT will be set with IS_NUMBER_IN_UV if trailing decimals were seen (in which case *valuep gives the true value truncated to an integer), and IS_NUMBER_NEG if the number is negative (in which case *valuep holds the absolute value). IS_NUMBER_IN_UV is not set if e notation was used or the number is larger than a UV.</source>
          <target state="translated">如果看到尾数为小数,IS_NUMBER_NOT_INT将与IS_NUMBER_IN_UV一起设置(在这种情况下,*valuep给出了截断为整数的真值),如果数字为负数,IS_NUMBER_NEG将与IS_NUMBER_IN_UV一起设置(在这种情况下,*valuep持有绝对值)。如果使用了e符号或者数字大于UV,则不设置IS_NUMBER_IN_UV。</target>
        </trans-unit>
        <trans-unit id="a41c9a62c208bda09b6e0e4693fb0c85b4373197" translate="yes" xml:space="preserve">
          <source>IS_SAFE_SYSCALL</source>
          <target state="translated">IS_SAFE_SYSCALL</target>
        </trans-unit>
        <trans-unit id="e849c5f96439c1fe622e4ace3225dd079d5ce0bc" translate="yes" xml:space="preserve">
          <source>ITEM</source>
          <target state="translated">ITEM</target>
        </trans-unit>
        <trans-unit id="e98fda145e73c44d41ee1cf81a9942997f60dc03" translate="yes" xml:space="preserve">
          <source>ITEM...</source>
          <target state="translated">ITEM...</target>
        </trans-unit>
        <trans-unit id="81355db038b4c2e62588bc2f02426816803c8b50" translate="yes" xml:space="preserve">
          <source>ITEMHASH</source>
          <target state="translated">ITEMHASH</target>
        </trans-unit>
        <trans-unit id="932eaaf5a36529c34a7868b56cba634f534f39b4" translate="yes" xml:space="preserve">
          <source>IV</source>
          <target state="translated">IV</target>
        </trans-unit>
        <trans-unit id="af7024f6a1aba1b8353a4f8d081230e10f559e67" translate="yes" xml:space="preserve">
          <source>IVX</source>
          <target state="translated">IVX</target>
        </trans-unit>
        <trans-unit id="3776b457f4a64c1c2e929c3beb97e225d7174238" translate="yes" xml:space="preserve">
          <source>Iain Truskett. Updated by the Perl 5 Porters.</source>
          <target state="translated">Iain Truskett。由 Perl 5 Porters 更新。</target>
        </trans-unit>
        <trans-unit id="18334cc78787c9bf930719c033735bf066a1783e" translate="yes" xml:space="preserve">
          <source>Idaho</source>
          <target state="translated">Idaho</target>
        </trans-unit>
        <trans-unit id="d3280028436889a62f2d1e26e6623a3b63327bf8" translate="yes" xml:space="preserve">
          <source>Idea by Tony Bowden and Paul Johnson, code by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;, wardrobe by Calvin Klein.</source>
          <target state="translated">Tony Bowden和Paul Johnson的创意，Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;的代码，Calvin Klein的衣柜。</target>
        </trans-unit>
        <trans-unit id="38eaa27bde2babc938a1d3f61f24a4c3c9ee9393" translate="yes" xml:space="preserve">
          <source>Ideally, all instances of &lt;code&gt;PL_sub_generation++&lt;/code&gt; in perl source outside of</source>
          <target state="translated">理想情况下，perl源代码中 &lt;code&gt;PL_sub_generation++&lt;/code&gt; 之外的所有实例</target>
        </trans-unit>
        <trans-unit id="e4477a644f309bbba5035bb03dd4d512f954eb2e" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code.</source>
          <target state="translated">理想情况下，所有这些运算符将完全忽略 &lt;code&gt;:utf8&lt;/code&gt; 状态，仅使用字节，但这将导致静默破坏现有代码。</target>
        </trans-unit>
        <trans-unit id="501684b206c21ec5483e8cb92e79c26ad4af36ca" translate="yes" xml:space="preserve">
          <source>Ideally, all of these operators would completely ignore the &lt;code&gt;:utf8&lt;/code&gt; state, working only with bytes, but this would result in silently breaking existing code. To avoid this a future version of perl will throw an exception when any of sysread(), recv(), syswrite() or send() are called on handle with the &lt;code&gt;:utf8&lt;/code&gt; layer.</source>
          <target state="translated">理想情况下，所有这些运算符将完全忽略 &lt;code&gt;:utf8&lt;/code&gt; 状态，仅使用字节，但这将导致静默破坏现有代码。为避免这种情况，当在 &lt;code&gt;:utf8&lt;/code&gt; 层的句柄上调用sysread（），recv（），syswrite（）或send（）中的任何一个时，perl的将来版本将引发异常。</target>
        </trans-unit>
        <trans-unit id="b72ac1e7c6fddbcf97426592a619f53420c1c124" translate="yes" xml:space="preserve">
          <source>Ideally, someone who's slightly familiar with your module should be able to refresh their memory without hitting &quot;page down&quot;. As your reader continues through the document, they should receive a progressively greater amount of knowledge.</source>
          <target state="translated">理想的情况是,对你的模块稍微熟悉的人应该能够在不点击 &quot;向下翻页 &quot;的情况下刷新他们的记忆。当你的读者继续浏览文档时,他们应该会逐渐接受更多的知识。</target>
        </trans-unit>
        <trans-unit id="6760494b3e87b72d6f704a16dfd8c909bfd06f21" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;&quot;lrint&quot;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#lrint&quot;&gt;&amp;ldquo; lrint&amp;rdquo;&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="71c30d178b22c94b418adae6de96d27ac6651de9" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#lrint&quot;&gt;lrint&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#lrint&quot;&gt;林特&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="c269c4512ac345c8ac0e6a3f0761757db1ece435" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;grok_number_flags()&lt;/code&gt; with &lt;code&gt;flags&lt;/code&gt; set to zero.</source>
          <target state="translated">与 &lt;code&gt;grok_number_flags()&lt;/code&gt; 相同，且 &lt;code&gt;flags&lt;/code&gt; 设置为零。</target>
        </trans-unit>
        <trans-unit id="189f7c8820b5d91329256424f9abd34533abf5d2" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt; , but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">与 &lt;code&gt;has_errors&lt;/code&gt; 相同，但是如果任何TODO测试意外成功，也返回true。这更类似于&amp;ldquo;警告&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0e295a166224f4ec773840e576cbbb4eea64c35a" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;has_errors&lt;/code&gt;, but also returns true if any TODO tests unexpectedly succeeded. This is more akin to &quot;warnings&quot;.</source>
          <target state="translated">与 &lt;code&gt;has_errors&lt;/code&gt; 相同，但是如果任何TODO测试意外成功，则也返回true。这更类似于&amp;ldquo;警告&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="49923c15da594194a42e0f23479dad9afb3e6e18" translate="yes" xml:space="preserve">
          <source>Identical to &lt;code&gt;seek OFFSET, WHENCE&lt;/code&gt;,</source>
          <target state="translated">等同于 &lt;code&gt;seek OFFSET, WHENCE&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="725851e6339b491e1de8826e667b9695d8cea364" translate="yes" xml:space="preserve">
          <source>Identical to grok_number_flags() with flags set to zero.</source>
          <target state="translated">与grok_number_flags()相同,但flags设置为0。</target>
        </trans-unit>
        <trans-unit id="9052a2716f89fc7937386d07b0ec6eb570325f21" translate="yes" xml:space="preserve">
          <source>Identifier parsing</source>
          <target state="translated">识别解析</target>
        </trans-unit>
        <trans-unit id="c9e9b7fc2f9e092c9b1b92a7e63d7d890ea86035" translate="yes" xml:space="preserve">
          <source>Identifier too long</source>
          <target state="translated">识别符太长</target>
        </trans-unit>
        <trans-unit id="96bd1c9d626bb40d98db0e06c9d88504407f597b" translate="yes" xml:space="preserve">
          <source>Identifies _POSIX_ARG_MAX as a constant sub, optimized to an IV. Although POSIX isn't entirely consistent across platforms, this is likely to be present in virtually all of them.</source>
          <target state="translated">将 _POSIX_ARG_MAX 识别为一个常量子,优化为 IV。虽然POSIX在各个平台上并不完全一致,但几乎所有的平台都可能存在这种情况。</target>
        </trans-unit>
        <trans-unit id="651807fc401b8332ec409deb81843bccbd052364" translate="yes" xml:space="preserve">
          <source>Identifies md5 as an XS function. The export is needed so that BC can find it in main.</source>
          <target state="translated">将md5标识为XS函数。需要导出,以便BC能在main中找到它。</target>
        </trans-unit>
        <trans-unit id="c85a93ef2b6eb1be3e8769838c333c812af4359a" translate="yes" xml:space="preserve">
          <source>Identify a remote machine name. The auto-login process searches the .netrc file for a machine token that matches the remote machine specified. Once a match is made, the subsequent .netrc tokens are processed, stopping when the end of file is reached or an- other machine or a default token is encountered.</source>
          <target state="translated">确定一个远程机器名称。自动登录过程会在.netrc文件中搜索与指定的远程机器相匹配的机器令牌,一旦匹配,就会处理后续的.netrc令牌,在文件结束或遇到其他机器或默认令牌时停止。一旦匹配,后续的.netrc标记就会被处理,当文件结束或遇到其他机器或默认标记时就会停止。</target>
        </trans-unit>
        <trans-unit id="ad36a5ddf7af0b9b2aadce75c61491b0c464af3b" translate="yes" xml:space="preserve">
          <source>Identify a user on the remote machine. If this token is present, the auto-login process will initiate a login using the specified name.</source>
          <target state="translated">识别远程机器上的用户。如果有此标记,自动登录过程将使用指定的名称发起登录。</target>
        </trans-unit>
        <trans-unit id="93ca58cc90c1952df3129b0ab2a244d796f9ba81" translate="yes" xml:space="preserve">
          <source>Identify and return the FQDN of the current host.</source>
          <target state="translated">识别并返回当前主机的FQDN。</target>
        </trans-unit>
        <trans-unit id="1b3b4987c2d4674f5207d125a1368bf151a6aeb4" translate="yes" xml:space="preserve">
          <source>Identify the C functions which use some inband info as an indication of failure. They may be candidates to return undef or an empty list in case of failure. If the failure may be detected without a call to the C function, you may want to use an INIT: section to report the failure. For failures detectable after the C function returns one may want to use a POSTCALL: section to process the failure. In more complicated cases use CODE: or PPCODE: sections.</source>
          <target state="translated">识别那些使用一些带内信息作为失败指示的C函数。它们可能是在失败时返回undef或空列表的候选函数。如果在没有调用C函数的情况下就能检测到失败,你可能需要使用INIT:部分来报告失败。对于在C函数返回后可以检测到的失败,可能要使用POSTCALL:部分来处理失败。在更复杂的情况下,使用CODE:或PPCODE:部分。</target>
        </trans-unit>
        <trans-unit id="b1d8de6657b1cd9ff03db4bb8c676352163c1ab9" translate="yes" xml:space="preserve">
          <source>Identify the C functions with input/output or output parameters. The XSUBs for these functions may be able to return lists to Perl.</source>
          <target state="translated">识别具有输入/输出或输出参数的C函数。这些函数的XSUB可以向Perl返回列表。</target>
        </trans-unit>
        <trans-unit id="90f84ba2bf147a844b20d38f482ee57bb2e58f7e" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; , and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">在C函数参数列表中标识指针并返回值。某些指针可用于实现输入/输出或输出参数，它们可以在XS中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 一元运算符进行处理，并且可能使用NO_INIT关键字进行处理。其他一些则需要处理 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; 之类的类型，并且需要确定在这种情况下有用的Perl转换将执行的操作。当语义清晰时，建议将翻译放入类型映射文件中。</target>
        </trans-unit>
        <trans-unit id="02c745f2a38f59b1173a4d016d93fc6da4107dea" translate="yes" xml:space="preserve">
          <source>Identify the pointers in the C function parameter lists and return values. Some pointers may be used to implement input/output or output parameters, they can be handled in XS with the &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator, and, possibly, using the NO_INIT keyword. Some others will require handling of types like &lt;code&gt;int *&lt;/code&gt;, and one needs to decide what a useful Perl translation will do in such a case. When the semantic is clear, it is advisable to put the translation into a typemap file.</source>
          <target state="translated">在C函数参数列表中标识指针并返回值。某些指针可用于实现输入/输出或输出参数，它们可以在XS中使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 一元运算符进行处理，并且可能使用NO_INIT关键字进行处理。其他一些则需要处理 &lt;code&gt;int *&lt;/code&gt; 之类的类型，并且需要确定在这种情况下有用的Perl转换将执行的操作。当语义清晰时，建议将翻译内容放入类型映射文件中。</target>
        </trans-unit>
        <trans-unit id="b3f574cc58fec6b5a326569871a9bc4c7e511150" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt; .)</source>
          <target state="translated">确定C函数使用的结构。在许多情况下，将T_PTROBJ类型映射用于这些结构可能会有所帮助，以便Perl可以将它们作为受祝福的对象进行操作。（这由 &lt;code&gt;h2xs -x&lt;/code&gt; 自动处理。）</target>
        </trans-unit>
        <trans-unit id="010ff5be16a493cb47c53ed9163162ed618b8c47" translate="yes" xml:space="preserve">
          <source>Identify the structures used by the C functions. In many cases it may be helpful to use the T_PTROBJ typemap for these structures so they can be manipulated by Perl as blessed objects. (This is handled automatically by &lt;code&gt;h2xs -x&lt;/code&gt;.)</source>
          <target state="translated">确定C函数使用的结构。在许多情况下，将T_PTROBJ类型映射用于这些结构可能会有所帮助，以便Perl可以将它们作为受祝福的对象进行操作。（这由 &lt;code&gt;h2xs -x&lt;/code&gt; 自动处理。）</target>
        </trans-unit>
        <trans-unit id="7cadfb291553bfe2fe292f1f1bdcc23146b4ce0c" translate="yes" xml:space="preserve">
          <source>Identify which values are used by only the C and XSUB functions themselves, say, when a parameter to a function should be a contents of a global variable. If Perl does not need to access the contents of the value then it may not be necessary to provide a translation for that value from C to Perl.</source>
          <target state="translated">确定哪些值只被C和XSUB函数本身使用,比如说,当一个函数的参数应该是一个全局变量的内容时。如果Perl不需要访问该值的内容,那么可能不需要为该值提供从C到Perl的翻译。</target>
        </trans-unit>
        <trans-unit id="56f43be29163ab63b1344b6e022e099866950791" translate="yes" xml:space="preserve">
          <source>Identifying DLLs</source>
          <target state="translated">识别DLL</target>
        </trans-unit>
        <trans-unit id="82508a1705f3161aa990aa2c93c5670f8e0880f2" translate="yes" xml:space="preserve">
          <source>Identity of objects returned from threads</source>
          <target state="translated">从线程返回的对象的身份</target>
        </trans-unit>
        <trans-unit id="322518cb4fde79b98b609332667667f3d3c4e560" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">基于Idhash的内向外实现,具有显式对象注册表。不需要destructor,对象是线程安全的。</target>
        </trans-unit>
        <trans-unit id="bc58745f8a36f6c13d8394fd39a743ccc1e12aee" translate="yes" xml:space="preserve">
          <source>Idhash-based inside-out implementation. Like &lt;code&gt;Name_id&lt;/code&gt; it needs a &lt;code&gt;DESTROY&lt;/code&gt; method and would need &lt;code&gt;CLONE&lt;/code&gt; for thread support.</source>
          <target state="translated">基于Idhash的由内而外的实现。像 &lt;code&gt;Name_id&lt;/code&gt; 一样，它需要 &lt;code&gt;DESTROY&lt;/code&gt; 方法，并且需要 &lt;code&gt;CLONE&lt;/code&gt; 来支持线程。</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="37c8800e90368fca825ac19f3c1c00b3997debbb" translate="yes" xml:space="preserve">
          <source>If $ENV{'PERLIO_DEBUG'} is not set PerlIO_debug() is a no-op.</source>
          <target state="translated">如果 $ENV{'PERLIO_DEBUG'}没有被设置为 PerlIO_debug()则为无操作。</target>
        </trans-unit>
        <trans-unit id="34dc71088c30578327b9b7bd86a2add6dfe92c0b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set (see below), it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">如果$Term::ANSIColor::AUTOLOCAL被设置(见下文),它优先于$Term::ANSIColor::AUTORESET,并且后者被忽略。</target>
        </trans-unit>
        <trans-unit id="d7df1e43ea1f957f59393ae695f2cf9b6d2d606b" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, each sequence of color constants will be implicitly preceded by LOCALCOLOR. In other words, the following:</source>
          <target state="translated">如果设置了$Term::ANSIColor::AUTOLOCAL,则每个颜色常量序列都会隐含在LOCALCOLOR前面。换句话说,如下。</target>
        </trans-unit>
        <trans-unit id="9886d30e7ae4310a71b5b389e615e24f477c9c12" translate="yes" xml:space="preserve">
          <source>If $Term::ANSIColor::AUTOLOCAL is set, it takes precedence over $Term::ANSIColor::AUTORESET, and the latter is ignored.</source>
          <target state="translated">如果$Term::ANSIColor::AUTOLOCAL被设置,它优先于$Term::ANSIColor::AUTORESET,而后者被忽略。</target>
        </trans-unit>
        <trans-unit id="00b4b93a6e7c56aaf9898bc10e1ac72d3a78d804" translate="yes" xml:space="preserve">
          <source>If $base doesn't have a trailing colon, the last element of $base is assumed to be a filename. This filename is ignored. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">如果$base没有尾部的冒号,那么$base的最后一个元素被认为是一个文件名。这个文件名会被忽略。否则,所有的路径元素都被假定为目录。</target>
        </trans-unit>
        <trans-unit id="e44a850613a15c52040db7b75a563e3363f3a945" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ base不存在或''，则$ base设置为当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="1ac0ec7cd3bc97fc5c257fe4a45200d456c5936a" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then $base is set to the current working directory. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ base不存在或''，则$ base设置为当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="845e455de01e5f024d6cd4c4973aa19e89db7d23" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在$ base或''，则使用&lt;a href=&quot;../../cwd&quot;&gt;cwd（）&lt;/a&gt;。如果$ base是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../../cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5c40ff51bf83072e14de8451f609e067639c21f4" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt; is used. If $base is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在$ base或''，则使用&lt;a href=&quot;cwd&quot;&gt;cwd（）&lt;/a&gt;。如果$ base是相对的，则使用&lt;a href=&quot;#rel2abs%28%29&quot;&gt;&amp;ldquo; rel2abs（）&amp;rdquo;&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b9272bd7bdd63c187d96603ba9d632df6f83a5a3" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果不存在$ base或''，则使用当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="b66c3e7b074813162992aae05acc57abf750bc24" translate="yes" xml:space="preserve">
          <source>If $base is not present or '', then the current working directory is used. If $base is relative, then it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ base或''不存在，则使用当前工作目录。如果$ base是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="1e5fe1a187e17b34fb3d5857b8fec9a663cd647f" translate="yes" xml:space="preserve">
          <source>If $chld_in begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. If $chld_out or $chld_err begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that filehandle. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="translated">如果$ chld_in以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头，则$ chld_in将在父级中关闭，而子级将直接从中读取。如果$ chld_out或$ chld_err以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子级将直接将输出发送到该文件句柄。在这两种情况下，都将使用&lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup（2）&lt;/a&gt;而不是制作的&lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe（2）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3eeec7a0508f8bfb175a7dfc1c9f776420700e6b" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; , then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a dup(2) instead of a pipe(2) made.</source>
          <target state="translated">如果$ chld_out是字符串（即，裸字文件句柄而不是glob或引用），并且它以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子级将直接将输出发送到该文件句柄。如果$ chld_in是以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头的字符串，则$ chld_in将在父级中关闭，而子级将直接从中读取。在这两种情况下，都将使用dup（2）而不是使用pipe（2）。</target>
        </trans-unit>
        <trans-unit id="bb5d964b870841cdc4d8247b114d6ed7feacad03" translate="yes" xml:space="preserve">
          <source>If $chld_out is a string (that is, a bareword filehandle rather than a glob or a reference) and it begins with &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt;, then the child will send output directly to that file handle. If $chld_in is a string that begins with &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt;, then $chld_in will be closed in the parent, and the child will read from it directly. In both cases, there will be a &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt; instead of a &lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe(2)&lt;/a&gt; made.</source>
          <target state="translated">如果$ chld_out是字符串（即，裸字文件句柄而不是glob或引用），并且它以 &lt;code&gt;&amp;gt;&amp;amp;&lt;/code&gt; 开头，则子级将直接将输出发送到该文件句柄。如果$ chld_in是以 &lt;code&gt;&amp;lt;&amp;amp;&lt;/code&gt; 开头的字符串，则$ chld_in将在父级中关闭，而子级将直接从中读取。在这两种情况下，都将使用&lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup（2）&lt;/a&gt;而不是制作的&lt;a href=&quot;http://man.he.net/man2/pipe&quot;&gt;pipe（2）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44fc8fa9695e13537785e072991da9317e572016" translate="yes" xml:space="preserve">
          <source>If $device is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">如果给定了$device,则在发送ping包之前,用这个设备来绑定源端点。我相信目前只有超级用户权限和udp和icmp协议才能使用这个功能。</target>
        </trans-unit>
        <trans-unit id="c0ccd65f83616cd6cb2edfc67d2ca291d582e3dc" translate="yes" xml:space="preserve">
          <source>If $dont_execute is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">如果$dont_execute为true,它将只打印它要做的事情,而不实际执行。默认为false。</target>
        </trans-unit>
        <trans-unit id="4487f23cdc43d77eefda03ffdb355fcd16d21554" translate="yes" xml:space="preserve">
          <source>If $dry_run is true it will only print what it was going to do without actually doing it. Default is false.</source>
          <target state="translated">如果$dry_run为true,它将只打印它要做的事情,而不实际做。默认为false。</target>
        </trans-unit>
        <trans-unit id="18c02a1762fa9a8596890767dac4fd996ccee7b8" translate="yes" xml:space="preserve">
          <source>If $file is not given, output goes to STDOUT.</source>
          <target state="translated">如果没有给定$file,输出将进入STDOUT。</target>
        </trans-unit>
        <trans-unit id="d0d307167134c6f267f7b1e5ea27d0a25a9d1edd" translate="yes" xml:space="preserve">
          <source>If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.</source>
          <target state="translated">如果$lang1不是有效的语言标签,在列表上下文中返回空列表,在标量上下文中返回undef。</target>
        </trans-unit>
        <trans-unit id="6adb44f6d344c97f88c0df71861fe153cb8933a6" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, F(0) to F(12), are returned:</source>
          <target state="translated">如果$n是-12,则返回F(0)到F(12)的值。</target>
        </trans-unit>
        <trans-unit id="88b3052cab9399b49f31b3d6abdfc51fc8199576" translate="yes" xml:space="preserve">
          <source>If $n is -12, the following values, L(0) to L(-12), are returned:</source>
          <target state="translated">如果$n是-12,则返回L(0)到L(-12)的值。</target>
        </trans-unit>
        <trans-unit id="5ee23960e33f02c0ec76877b3b88bcea62b52eb5" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt; . Defaults to true.</source>
          <target state="translated">如果$ options {allow_variables}为true，它将使 &lt;code&gt;'$(FOO)'&lt;/code&gt; 使变量保持不变。如果为假，它们将像其他 &lt;code&gt;$&lt;/code&gt; 一样被转义。默认为true。</target>
        </trans-unit>
        <trans-unit id="5af890a74a4e63465dd086ae3936bc7cc991986f" translate="yes" xml:space="preserve">
          <source>If $options{allow_variables} is true it will leave &lt;code&gt;'$(FOO)'&lt;/code&gt; make variables untouched. If false they will be escaped like any other &lt;code&gt;$&lt;/code&gt;. Defaults to true.</source>
          <target state="translated">如果$ options {allow_variables}为true，它将使 &lt;code&gt;'$(FOO)'&lt;/code&gt; 使变量保持不变。如果为假，它们将像其他任何 &lt;code&gt;$&lt;/code&gt; 一样被转义。默认为true。</target>
        </trans-unit>
        <trans-unit id="7e4290bb3a94a4f28c693632b42d671f5b272d5b" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt; .</source>
          <target state="translated">如果$ opts {allow_variables}为true，将不会转义 &lt;code&gt;$(...)&lt;/code&gt; 形式的make变量。其他 &lt;code&gt;$&lt;/code&gt; 将。默认值是转义所有 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45a9cc1fe09732d92a99ea0ef6a79df5a1201010" translate="yes" xml:space="preserve">
          <source>If $opts{allow_variables} is true, make variables of the form &lt;code&gt;$(...)&lt;/code&gt; will not be escaped. Other &lt;code&gt;$&lt;/code&gt; will. Default is to escape all &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">如果$ opts {allow_variables}为true，将不会转义 &lt;code&gt;$(...)&lt;/code&gt; 形式的make变量。其他 &lt;code&gt;$&lt;/code&gt; 将。默认值是转义所有 &lt;code&gt;$&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="855199c44e171a04babf60aa36fe8d5f139967b6" translate="yes" xml:space="preserve">
          <source>If $opts{append} is true the $file will be appended to rather than overwritten. Default is to overwrite.</source>
          <target state="translated">如果$opts{append}为真,则$file将被追加而不是覆盖。默认是覆盖。</target>
        </trans-unit>
        <trans-unit id="6f940e23e748b82cd99453c8e14fb88e03638ce9" translate="yes" xml:space="preserve">
          <source>If $path and $base appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return $path. Note that previous versions of this module ignored the volume of $base, which resulted in garbage results part of the time.</source>
          <target state="translated">如果$path和$base出现在两个不同的卷上,我们将不尝试解析这两个路径,而只是返回$path。需要注意的是,这个模块以前的版本忽略了$base的卷,这导致了部分时间的垃圾结果。</target>
        </trans-unit>
        <trans-unit id="cbae8edca75030504736a7e9ba0e1664c9973d5c" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath%28%29&quot;&gt;&quot;canonpath()&quot;&lt;/a&gt;.</source>
          <target state="translated">如果$ path是绝对的，则将其清理并使用&lt;a href=&quot;#canonpath%28%29&quot;&gt;&amp;ldquo; canonpath（）&amp;rdquo;&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="850236350e7bb82f14f3904d51572fc6195796da" translate="yes" xml:space="preserve">
          <source>If $path is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath()&quot;&gt;canonpath()&lt;/a&gt;.</source>
          <target state="translated">如果$ path是绝对的，则将其清理并使用&lt;a href=&quot;#canonpath()&quot;&gt;canonpath（）&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="8dd162a4e3a5b7fb03319f43889033f3ce26c0ac" translate="yes" xml:space="preserve">
          <source>If $path is already absolute, it is returned and $base is ignored.</source>
          <target state="translated">如果$path已经是绝对值,则返回,忽略$base。</target>
        </trans-unit>
        <trans-unit id="886dc2f5228118ff9d61b100bc53fdb8e15c29aa" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果$ path是相对的，则使用&lt;a href=&quot;#rel2abs%28%29&quot;&gt;&amp;ldquo; rel2abs（）&amp;rdquo;将&lt;/a&gt;其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="777c7fd35866ed59635fd89f40d3d520a0dbf9c9" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../../cwd&quot;&gt;cwd()&lt;/a&gt;.</source>
          <target state="translated">如果$ path是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../../cwd&quot;&gt;cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7ca3a7041ed2c9c63e8a6e3a8ccf54b7c562514d" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt; . This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ path是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="e06af1fee89e76c48b343a46105f41869071f188" translate="yes" xml:space="preserve">
          <source>If $path is relative, it is converted to absolute form using &lt;code&gt;rel2abs()&lt;/code&gt;. This means that it is taken to be relative to the current working directory.</source>
          <target state="translated">如果$ path是相对的，则使用 &lt;code&gt;rel2abs()&lt;/code&gt; 将其转换为绝对形式。这意味着它被认为是相对于当前工作目录的。</target>
        </trans-unit>
        <trans-unit id="5254527bc2e7fffb01bf04870bf9b3803ac84a3a" translate="yes" xml:space="preserve">
          <source>If $skip is undefined then the skip file will be autodetected and used if it is found. If $skip is a reference to an array then it is assumed the array contains the list of patterns, if $skip is a true non reference it is assumed to be the filename holding the list of patterns, any other value of $skip is taken to mean that no install filtering should occur.</source>
          <target state="translated">如果$skip是未定义的,那么跳过文件将被自动检测,并在找到时使用。如果$skip是一个数组的引用,那么它被认为是数组包含了模式列表,如果$skip是一个真正的非引用,那么它被认为是持有模式列表的文件名,任何其他的$skip值都被认为意味着不应该发生安装过滤。</target>
        </trans-unit>
        <trans-unit id="8fa5810ef2976d0d9f6da3cb5784a5117836d30e" translate="yes" xml:space="preserve">
          <source>If $tos is given, this ToS is configured into the socket.</source>
          <target state="translated">如果给定了$tos,这个ToS就会配置到socket中。</target>
        </trans-unit>
        <trans-unit id="92f994b9259d086e448ddc0c57c689110cb3a4ae" translate="yes" xml:space="preserve">
          <source>If $uninstall_shadows is true any differing versions throughout @INC will be uninstalled. This is &quot;make install UNINST=1&quot;</source>
          <target state="translated">如果$uninstall_shadows为真,那么整个@INC中任何不同的版本都会被卸载。这就是 &quot;make install UNINST=1&quot;</target>
        </trans-unit>
        <trans-unit id="d25dc89b5c8f1043b2555a0a5b1ef64713bc4410" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false.</source>
          <target state="translated">如果$verbose为true,将打印出每个被删除的文件。默认为false。</target>
        </trans-unit>
        <trans-unit id="bcca2238b940008ca2f6edea6b116ca4f08340a0" translate="yes" xml:space="preserve">
          <source>If $verbose is true, will print out each file removed. Default is false. This is &quot;make install VERBINST=1&quot;. $verbose values going up to 5 show increasingly more diagnostics output.</source>
          <target state="translated">如果$verbose为true,将打印出每个被删除的文件。默认为false。这就是 &quot;make install VERBINST=1&quot;。$verbose的值上升到5,会显示越来越多的诊断输出。</target>
        </trans-unit>
        <trans-unit id="769e2245fa144a60a2da225854d87529340273af" translate="yes" xml:space="preserve">
          <source>If &amp;lt;tos&amp;gt; is given, this ToS is configured into the socket.</source>
          <target state="translated">如果给出&amp;lt;tos&amp;gt;，则此ToS已配置到套接字中。</target>
        </trans-unit>
        <trans-unit id="fe6210a09cf838e292147ff60a09be55f53fc7bf" translate="yes" xml:space="preserve">
          <source>If 'pattern' is an empty string, the last</source>
          <target state="translated">如果'pattern'是一个空字符串,则最后的</target>
        </trans-unit>
        <trans-unit id="0ebb8bcb9771923015eb97e7f45b5b7f4e5fde8a" translate="yes" xml:space="preserve">
          <source>If 0 is given as the version number, then any version is supported.</source>
          <target state="translated">如果给出0作为版本号,则支持任何版本。</target>
        </trans-unit>
        <trans-unit id="1ce161c1d1a95615015e87f6deb5c4e15fba876e" translate="yes" xml:space="preserve">
          <source>If 0, allows</source>
          <target state="translated">如果为0,允许</target>
        </trans-unit>
        <trans-unit id="e3e28f04766a1a5f37a30a978712cb8019a0f8ec" translate="yes" xml:space="preserve">
          <source>If 0, perl ignores setlocale() failing. May be useful with some strange</source>
          <target state="translated">如果为0,perl忽略setlocale()失败。可能对一些奇怪的</target>
        </trans-unit>
        <trans-unit id="0fcc1cd2f54ca974c2f03b70436631faa5fcbfff" translate="yes" xml:space="preserve">
          <source>If 0, perl would not warn of in case of unwarranted free(). With older perls this might be useful in conjunction with the module DB_File, which was buggy when dynamically linked and OMF-built.</source>
          <target state="translated">如果为0,那么perl就不会在出现不正当的free()时发出警告。对于旧版的perl来说,这个功能可能会和DB_File模块一起使用,因为DB_File模块在动态链接和OMF构建的时候是有bug的。</target>
        </trans-unit>
        <trans-unit id="0184b287a86a499460e472243734776163d62a28" translate="yes" xml:space="preserve">
          <source>If 0, then you have specified the G_DISCARD flag.</source>
          <target state="translated">如果为0,则说明你已经指定了G_DISCARD标志。</target>
        </trans-unit>
        <trans-unit id="59622b7a1ad0df9c79750964aae25dbf7a4a54d5" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section</source>
          <target state="translated">如果为1,那么Perl子程序实际返回的项目将被存储在Perl堆栈中----------------------------------段</target>
        </trans-unit>
        <trans-unit id="f287e1183da76005aad8b01623d1574c97f08bac" translate="yes" xml:space="preserve">
          <source>If 1, then the item actually returned by the Perl subroutine will be stored on the Perl stack - the section &lt;a href=&quot;#Returning-a-Scalar&quot;&gt;&quot;Returning a Scalar&quot;&lt;/a&gt; shows how to access this value on the stack. Remember that regardless of how many items the Perl subroutine returns, only the last one will be accessible from the stack - think of the case where only one value is returned as being a list with only one element. Any other items that were returned will not exist by the time control returns from the</source>
          <target state="translated">如果为1，则Perl子例程实际返回的项目将存储在Perl堆栈上- &lt;a href=&quot;#Returning-a-Scalar&quot;&gt;&amp;ldquo;返回标量&amp;rdquo;部分&lt;/a&gt;显示了如何在堆栈上访问此值。请记住，无论Perl子例程返回多少项，都只能从堆栈中访问最后一个-考虑以下情况：只有一个值被返回为只有一个元素的列表。控件返回的时间之前，返回的任何其他项目将不存在。</target>
        </trans-unit>
        <trans-unit id="dea4460b4f37611ed7726bdc86a6a203f8857086" translate="yes" xml:space="preserve">
          <source>If 1. and 2. didn't work, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for anything looking like UTF-8, and if any found, &lt;code&gt;:utf8&lt;/code&gt; is used as the default encoding for the open pragma.</source>
          <target state="translated">如果1.和2.不起作用，则将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LANG&lt;/code&gt; （按此顺序）匹配看起来像UTF-8的任何内容，如果找到，则将 &lt;code&gt;:utf8&lt;/code&gt; 用作打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="564ba04f0c77bd18f1de6b5d8d1c4de41e90203f" translate="yes" xml:space="preserve">
          <source>If 1. didn't work but we are under the locale pragma, the environment variables &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LANG&lt;/code&gt; (in that order) are matched for encodings (the part after &quot;&lt;code&gt;.&lt;/code&gt;&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</source>
          <target state="translated">如果1.无效，但我们在语言环境下进行编译，则将环境变量 &lt;code&gt;LC_ALL&lt;/code&gt; 和 &lt;code&gt;LANG&lt;/code&gt; （按此顺序）与编码（&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo; 后的部分，如果有的话）匹配，如果找到，则使用作为打开的编译指示的默认编码。</target>
        </trans-unit>
        <trans-unit id="3a1afd51d6a3da0d6403cee52200d8b304585c08" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, the current chunk will not be discarded. If the current chunk has not been entirely consumed, then it will not be discarded regardless of the flag.</source>
          <target state="translated">如果&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&amp;ldquo;PL_parser-&amp;gt; bufptr&amp;rdquo;&lt;/a&gt;所指向的当前组块（即，当前组块已被完全消耗），一般在当前组块将在新的块被读入的同时被丢弃的最末端，如果 &lt;code&gt;flags&lt;/code&gt; 设置了 &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; 位，将不会丢弃当前块。如果当前块还没有被完全消耗，那么无论该标志如何，都不会将其丢弃。</target>
        </trans-unit>
        <trans-unit id="5cc7e264f1e9eeedc8d7e2b14c1a68dd77cae7b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt; is pointing to the very end of the current chunk (i.e., the current chunk has been entirely consumed), normally the current chunk will be discarded at the same time that the new chunk is read in. If</source>
          <target state="translated">如果&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;指向当前块的末尾（即，当前块已被完全消耗），通常在读取新块的同时，将丢弃当前块。</target>
        </trans-unit>
        <trans-unit id="ab9b9dc2a96c1b74c9cadb45dfb3263c99d73a6b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; can read the file but cannot compile it, it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets an error message in &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; cannot read the file, it returns undef and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; to the error. Always check &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; first, as compilation could fail in a way that also sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;. If the file is successfully compiled, &lt;a href=&quot;#do-EXPR&quot;&gt;&lt;code&gt;do&lt;/code&gt;&lt;/a&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">如果&lt;a href=&quot;#do-EXPR&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;可以读取文件但无法编译，则它返回&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;并在&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;设置一条错误消息。如果&lt;a href=&quot;#do-EXPR&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;无法读取文件，它将返回undef并设置&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;错误。请务必先检查&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;，因为编译可能会失败，同时也会设置&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;。如果文件已成功编译，则&lt;a href=&quot;#do-EXPR&quot;&gt; &lt;code&gt;do&lt;/code&gt; &lt;/a&gt;返回最后一个求值表达式的值。</target>
        </trans-unit>
        <trans-unit id="5bf2b0be95e3bf2e4bd6ed03a9822036447b6309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; encounters an operating system error, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set with the corresponding error message. It can be helpful to check &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; and dies if the result is not defined.</source>
          <target state="translated">如果&lt;a href=&quot;#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;遇到操作系统错误，则&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;将设置相应的错误消息。检查&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;可能会有所帮助！当您从不信任的文件句柄（例如tty或套接字）中读取内容时。下面的示例使用&lt;a href=&quot;#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;的运算符形式，如果未定义结果，则死亡。</target>
        </trans-unit>
        <trans-unit id="878d2594c5d9d20b43a7cfef25e3d9ca8c531de7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; operator. However, there are a few situations where programs are likely to want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;srand($seed)&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; after a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">如果未显式调用&lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt;，则在首次使用&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;运算符时将不使用参数隐式调用它。但是，在某些情况下，程序可能希望调用&lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt;。一种是生成可预测的结果，通常用于测试或调试。在这里，您使用 &lt;code&gt;srand($seed)&lt;/code&gt; ，每次都使用相同的 &lt;code&gt;$seed&lt;/code&gt; 。另一种情况是，您可能想在&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;后调用&lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt;，以避免子进程与父进程共享相同的种子值（因此彼此共享）。</target>
        </trans-unit>
        <trans-unit id="d10fb228e7791a04f02a88f131ae6798266242b1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt;&lt;code&gt;lstat&lt;/code&gt;&lt;/a&gt;, or filetest are returned. Example:</source>
          <target state="translated">如果&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;传递了包含下划线的特殊文件句柄，则不会执行任何stat，但是会返回最后一个&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lstat-FILEHANDLE&quot;&gt; &lt;code&gt;lstat&lt;/code&gt; &lt;/a&gt;或filetest中stat结构的当前内容。例子：</target>
        </trans-unit>
        <trans-unit id="baa00f7897b1c66fe0a596f5bb93527533128be4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (or &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">如果&lt;a href=&quot;../../term/ansicolor&quot;&gt;找不到Term :: ANSIColor&lt;/a&gt;（如果在Windows下运行则为&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;），则测试将无颜色运行。</target>
        </trans-unit>
        <trans-unit id="42a72e58cfc32531fbd4fab5178d34e628485bf7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../cpan/meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">如果安装了&lt;a href=&quot;../cpan/meta&quot;&gt;CPAN :: Meta&lt;/a&gt;，MakeMaker将自动生成</target>
        </trans-unit>
        <trans-unit id="e5d244370ef566711e04ba5145e26efe3e9b271c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN::Meta&lt;/a&gt; is installed, MakeMaker will automatically generate</source>
          <target state="translated">如果安装了&lt;a href=&quot;CPAN::Meta&quot;&gt;CPAN :: Meta&lt;/a&gt;，MakeMaker将自动生成</target>
        </trans-unit>
        <trans-unit id="f3a37900ec3a9e29958a45c25ea701d35b6e343f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO::Socket::IP&lt;/a&gt; 0.25 or later is installed, HTTP::Tiny will use it instead of &lt;a href=&quot;IO::Socket::INET&quot;&gt;IO::Socket::INET&lt;/a&gt; for transparent support for both IPv4 and IPv6.</source>
          <target state="translated">如果安装了&lt;a href=&quot;IO::Socket::IP&quot;&gt;IO :: Socket :: IP&lt;/a&gt; 0.25或更高版本，HTTP :: Tiny将使用它而不是&lt;a href=&quot;IO::Socket::INET&quot;&gt;IO :: Socket :: INET&lt;/a&gt;来透明支持IPv4和IPv6。</target>
        </trans-unit>
        <trans-unit id="cd755112fc59cf8f24f51046f0dfaee1c7bd92bf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; cannot be found (and &lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32::Console::ANSI&lt;/a&gt; if running under Windows) tests will be run without color.</source>
          <target state="translated">如果&lt;a href=&quot;Term::ANSIColor&quot;&gt;找不到Term :: ANSIColor&lt;/a&gt;（如果在Windows下运行，则为&lt;a href=&quot;Win32::Console::ANSI&quot;&gt;Win32 :: Console :: ANSI&lt;/a&gt;），则测试将无颜色运行。</target>
        </trans-unit>
        <trans-unit id="4a94e167e7f1c0794c5a0b78b8cee155e32baf87" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;umask(2)&lt;/a&gt; is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">如果您的系统上未实现&lt;a href=&quot;http://man.he.net/man2/umask&quot;&gt;umask（2），&lt;/a&gt;并且您试图限制对以下文件的访问</target>
        </trans-unit>
        <trans-unit id="66c3ec58f6b5e85635c3d7dfd311e4342f5aba20" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">如果&lt;a href=&quot;locale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;（包括 &lt;code&gt;use locale ':not_characters'&lt;/code&gt; ）已生效并且已调用&lt;a href=&quot;posix#setlocale&quot;&gt; &lt;code&gt;POSIX::setlocale&lt;/code&gt; &lt;/a&gt;，则用于格式化浮点数的小数点分隔符的字符会受到 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境的影响。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="108eca6848696cd0de287a231d549cff82edd6aa" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will take the current width of your screen from this environment variable, if available. It overrides terminal width information in TERMCAP.</source>
          <target state="translated">如果给出&lt;b&gt;-t&lt;/b&gt;，则&lt;b&gt;pod2text&lt;/b&gt;将使用此环境变量（如果可用）获取屏幕的当前宽度。它会覆盖TERMCAP中的端子宽度信息。</target>
        </trans-unit>
        <trans-unit id="fc2c6665b79caef5aa91e98d089e901b7263b1c2" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;-t&lt;/b&gt; is given, &lt;b&gt;pod2text&lt;/b&gt; will use the contents of this environment variable if available to determine the correct formatting sequences for your current terminal device.</source>
          <target state="translated">如果指定了&lt;b&gt;-t&lt;/b&gt;，则&lt;b&gt;pod2text&lt;/b&gt;将使用此环境变量的内容（如果有）来确定当前终端设备的正确格式顺序。</target>
        </trans-unit>
        <trans-unit id="9c867f84603d2f4182710d040ee18f9885c092cc" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt; , with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt; , which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt; , or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">如果不存在&lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt;，则它会通过将第一个参数的 &lt;code&gt;[_1]&lt;/code&gt; 插值，第二个参数的 &lt;code&gt;[_2]&lt;/code&gt; 插值来实现最小化的本地化功能。插值函数（如 &lt;code&gt;[quant,_1]&lt;/code&gt; )被视为 &lt;code&gt;[_1]&lt;/code&gt; ,具有唯一的例外 &lt;code&gt;[tense,_1,X]&lt;/code&gt; ，这将附加 &lt;code&gt;ing&lt;/code&gt; 到 &lt;code&gt;_1&lt;/code&gt; 当X是 &lt;code&gt;present&lt;/code&gt; ，或追加 &lt;code&gt;ed&lt;/code&gt; 到&amp;lt;_1&amp;gt;否则。</target>
        </trans-unit>
        <trans-unit id="3da75cd17f8484e1cc0ad4bbfd2ed5b8f369d8c3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;Locale::Maketext::Lexicon&lt;/b&gt; is not present, it implements a minimal localization function by simply interpolating &lt;code&gt;[_1]&lt;/code&gt; with the first argument, &lt;code&gt;[_2]&lt;/code&gt; with the second, etc. Interpolated function like &lt;code&gt;[quant,_1]&lt;/code&gt; are treated as &lt;code&gt;[_1]&lt;/code&gt;, with the sole exception of &lt;code&gt;[tense,_1,X]&lt;/code&gt;, which will append &lt;code&gt;ing&lt;/code&gt; to &lt;code&gt;_1&lt;/code&gt; when X is &lt;code&gt;present&lt;/code&gt;, or appending &lt;code&gt;ed&lt;/code&gt; to &amp;lt;_1&amp;gt; otherwise.</source>
          <target state="translated">如果不存在&lt;b&gt;Locale :: Maketext :: Lexicon&lt;/b&gt;，则它会通过将第一个参数的 &lt;code&gt;[_1]&lt;/code&gt; 插值，第二个参数的 &lt;code&gt;[_2]&lt;/code&gt; 插值来实现最小化的本地化功能。插值函数（如 &lt;code&gt;[quant,_1]&lt;/code&gt; )被视为 &lt;code&gt;[_1]&lt;/code&gt; ,具有唯一的例外 &lt;code&gt;[tense,_1,X]&lt;/code&gt; ，这将附加 &lt;code&gt;ing&lt;/code&gt; 到 &lt;code&gt;_1&lt;/code&gt; 当X是 &lt;code&gt;present&lt;/code&gt; ，或追加 &lt;code&gt;ed&lt;/code&gt; 到&amp;lt;_1&amp;gt;否则。</target>
        </trans-unit>
        <trans-unit id="3079127a0d6aa2996f8f83dac436403e0868d7e3" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; .</source>
          <target state="translated">如果&lt;b&gt;所有&lt;/b&gt;这些都成立，那么您需要在 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 的最终调用（仅最终调用）上将 &lt;code&gt;$eof&lt;/code&gt; 参数设置为true 。</target>
        </trans-unit>
        <trans-unit id="0055cca9e96f566b053907d319402c20f817d1a7" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;all&lt;/b&gt; of these are the case, then you need to set the &lt;code&gt;$eof&lt;/code&gt; parameter to true on the final call (and only the final call) to &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt;.</source>
          <target state="translated">如果&lt;b&gt;所有&lt;/b&gt;这些都成立，那么您需要在 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; 的最终调用（仅最终调用）上将 &lt;code&gt;$eof&lt;/code&gt; 参数设置为true 。</target>
        </trans-unit>
        <trans-unit id="21045907ee178d775e967c06cc19006db36b57f1" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">如果&lt;b&gt;pod2man&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man&lt;/a&gt;和&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着什么的信息。</target>
        </trans-unit>
        <trans-unit id="1304e40e4e83fe3d3333f01173ec1c6d1e1c6f99" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2man&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean.</source>
          <target state="translated">如果&lt;b&gt;pod2man&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;和&lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着什么的信息。</target>
        </trans-unit>
        <trans-unit id="f3c086d017a2724c073cdc0c004a469d39ebb70e" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">如果&lt;b&gt;pod2text&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt;和&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着的信息。在内部，它还可以产生以下诊断信息：</target>
        </trans-unit>
        <trans-unit id="f4176eb0fb0948998c97b4edf835cbf5dcd8f3b5" translate="yes" xml:space="preserve">
          <source>If &lt;b&gt;pod2text&lt;/b&gt; fails with errors, see &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt; and &lt;a href=&quot;pod/simple&quot;&gt;Pod::Simple&lt;/a&gt; for information about what those errors might mean. Internally, it can also produce the following diagnostics:</source>
          <target state="translated">如果&lt;b&gt;pod2text&lt;/b&gt;因错误而失败，请参阅&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;和&lt;a href=&quot;pod/simple&quot;&gt;Pod :: Simple&lt;/a&gt;以获得有关这些错误可能意味着的信息。在内部，它还可以产生以下诊断信息：</target>
        </trans-unit>
        <trans-unit id="988f5c207e367599a6818bf91e93811516af5517" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; is optional. With the &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt; , to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no interpolation is performed on the</source>
          <target state="translated">如果 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 是分隔符，则首字母 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 是可选的。使用 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 时,您可以将任意一对非空白（ASCII）字符用作分隔符。这对于匹配包含 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 路径名特别有用，以避免LTS（倾斜牙签综合症）。如果是 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 是定界符，则应用仅匹配一次规则，以 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 下面。如果 &lt;code&gt;&quot;'&quot;&lt;/code&gt; （单引号）是定界符，则不会对</target>
        </trans-unit>
        <trans-unit id="6b9a8e2c3960de18a19c42696e997f8ffea4a1fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;/&quot;&lt;/code&gt; is the delimiter then the initial &lt;code&gt;m&lt;/code&gt; is optional. With the &lt;code&gt;m&lt;/code&gt; you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain &lt;code&gt;&quot;/&quot;&lt;/code&gt;, to avoid LTS (leaning toothpick syndrome). If &lt;code&gt;&quot;?&quot;&lt;/code&gt; is the delimiter, then a match-only-once rule applies, described in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; below. If &lt;code&gt;&quot;'&quot;&lt;/code&gt; (single quote) is the delimiter, no variable interpolation is performed on the</source>
          <target state="translated">如果 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 是定界符，则首字母 &lt;code&gt;m&lt;/code&gt; 是可选的。使用 &lt;code&gt;m&lt;/code&gt; 时，可以将任意一对非空白（ASCII）字符用作分隔符。这对于匹配包含 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 路径名特别有用，以避免LTS（倾斜牙签综合症）。如果是 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 是定界符，则应用仅匹配一次规则，以 &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; 以下。如果 &lt;code&gt;&quot;'&quot;&lt;/code&gt; （单引号）是定界符，则不会在</target>
        </trans-unit>
        <trans-unit id="efd1c59bcbb68bd82e85d30cea7a785addeb35a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;&quot;B&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;T&quot;&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 和 &lt;code&gt;A'&lt;/code&gt; 重合： &lt;code&gt;AB&lt;/code&gt; 比更好的匹配 &lt;code&gt;AB'&lt;/code&gt; 如果 &lt;code&gt;&quot;B&quot;&lt;/code&gt; 是为了更好地匹配 &lt;code&gt;&quot;T&quot;&lt;/code&gt; 比 &lt;code&gt;B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc627db8f0150de994b80dc55cea56de1a9e2796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;A&quot;&lt;/code&gt; is a better match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 是一个更好的匹配 &lt;code&gt;&quot;S&quot;&lt;/code&gt; 比 &lt;code&gt;A'&lt;/code&gt; &lt;code&gt;AB&lt;/code&gt; 是不是更好的匹配 &lt;code&gt;A'B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4134f85a82aca95ee568f43289ebb0ed4545d2aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Died&quot;&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;$@&lt;/code&gt; 为空，则使用字符串 &lt;code&gt;&quot;Died&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1898954d30bb03694346f5c287c1a5d39827435" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$@&lt;/code&gt; is empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="translated">如果 &lt;code&gt;$@&lt;/code&gt; 为空，则使用字符串 &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd653baf1f66ef92b469ea572e07f68509c56382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ENV{PERL_DESTRUCT_LEVEL}&lt;/code&gt; is set to an integer greater than the value of &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; its value is used instead.</source>
          <target state="translated">如果 &lt;code&gt;$ENV{PERL_DESTRUCT_LEVEL}&lt;/code&gt; 设置为大于 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 值的整数，则使用其值。</target>
        </trans-unit>
        <trans-unit id="8349dcfb4261ce55d683cb8a5fd2171cf0fa3a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$Storable::Deparse&lt;/code&gt; and/or &lt;code&gt;$Storable::Eval&lt;/code&gt; are set to false values, then the value of &lt;code&gt;$Storable::forgive_me&lt;/code&gt; (see below) is respected while serializing and deserializing.</source>
          <target state="translated">如果 &lt;code&gt;$Storable::Deparse&lt;/code&gt; 和/或 &lt;code&gt;$Storable::Eval&lt;/code&gt; 设置为false值，则在序列化和反序列化时，将尊重 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; 的值（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="e98020b671aa605e805711cb6bc682413e70f748" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 出现的范围内是词法（因为已经用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 构造声明了它），则除了在列表元素上局部别名之外， &lt;code&gt;$_&lt;/code&gt; 还会在块内词法化；也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="4f7113393512805f0f59fa7b96e8b849e1995d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 是在该范围内的词汇 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 出现（因为它已被声明为不赞成 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 结构），那么，除了在本地别名列表元素， &lt;code&gt;$_&lt;/code&gt; 一直是块内词汇; 也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="cb93a45a461425fe55c63aa4556c32605c5c3edf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct) then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; i.e., it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 出现的范围内是词法（因为已经用 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 构造声明了它），则除了在列表元素上局部别名之外， &lt;code&gt;$_&lt;/code&gt; 还会在块内词法化；也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="25899b6abc79ff8d8c10640cbdc4955bb3e63743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$_&lt;/code&gt; is lexical in the scope where the &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; appears (because it has been declared with the deprecated &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; construct), then, in addition to being locally aliased to the list elements, &lt;code&gt;$_&lt;/code&gt; keeps being lexical inside the block; that is, it can't be seen from the outside, avoiding any potential side-effects.</source>
          <target state="translated">如果 &lt;code&gt;$_&lt;/code&gt; 是在该范围内的词汇 &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 出现（因为它已被声明为不赞成 &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt; $_&lt;/code&gt; 结构），那么，除了在本地别名列表元素， &lt;code&gt;$_&lt;/code&gt; 一直是块内词汇; 也就是说，从外面看不到它，避免了任何潜在的副作用。</target>
        </trans-unit>
        <trans-unit id="2bf18bea13d8e6a37cbbcfdc3ed1634945661fd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are scalars then after these statements</source>
          <target state="translated">如果 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 是标量，则在这些语句之后</target>
        </trans-unit>
        <trans-unit id="92cf042152ebf0550f54e6d7d3ad9a3448e3c104" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$a&lt;/code&gt; pointed to an array of two elements then we would see the following.</source>
          <target state="translated">如果 &lt;code&gt;$a&lt;/code&gt; 指向两个元素的数组，那么我们将看到以下内容。</target>
        </trans-unit>
        <trans-unit id="fee2f2e0ebac86e4349ab49b826ea37defd988af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt; , which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt; . &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">如果 &lt;code&gt;$aref&lt;/code&gt; 持有对数组的引用，则 &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; 是数组的第四个元素。不要将它与 &lt;code&gt;$aref[3]&lt;/code&gt; 混淆，后者是完全不同的数组的第四个元素，一个名为 &lt;code&gt;@aref&lt;/code&gt; 的数组。 &lt;code&gt;$aref&lt;/code&gt; 和 &lt;code&gt;@aref&lt;/code&gt; 是不相关的，就像 &lt;code&gt;$item&lt;/code&gt; 和 &lt;code&gt;@item&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="56cb4a03de2631e78fd42838b903ba847f7a9d3f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$aref&lt;/code&gt; holds a reference to an array, then &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; is the fourth element of the array. Don't confuse this with &lt;code&gt;$aref[3]&lt;/code&gt;, which is the fourth element of a totally different array, one deceptively named &lt;code&gt;@aref&lt;/code&gt;. &lt;code&gt;$aref&lt;/code&gt; and &lt;code&gt;@aref&lt;/code&gt; are unrelated the same way that &lt;code&gt;$item&lt;/code&gt; and &lt;code&gt;@item&lt;/code&gt; are.</source>
          <target state="translated">如果 &lt;code&gt;$aref&lt;/code&gt; 持有对数组的引用，则 &lt;code&gt;$aref-&amp;gt;[3]&lt;/code&gt; 是数组的第四个元素。不要将此与 &lt;code&gt;$aref[3]&lt;/code&gt; 混淆，后者是一个完全不同的数组的第四个元素，一个数组的名字叫 &lt;code&gt;@aref&lt;/code&gt; 。 &lt;code&gt;$aref&lt;/code&gt; 和 &lt;code&gt;@aref&lt;/code&gt; 是不相关的，就像 &lt;code&gt;$item&lt;/code&gt; 和 &lt;code&gt;@item&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="f9c98499f2d6c2b76ade873a689c1003108b5526" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$bFailIfExists&lt;/code&gt; is true and &lt;code&gt;$sNewFileName&lt;/code&gt; is the path to a file that already exists, then &lt;code&gt;CopyFile&lt;/code&gt; will fail. If &lt;code&gt;$bFailIfExists&lt;/code&gt; is false, then the copy of the &lt;code&gt;$sOldFileNmae&lt;/code&gt; file will overwrite the &lt;code&gt;$sNewFileName&lt;/code&gt; file if it already exists.</source>
          <target state="translated">如果 &lt;code&gt;$bFailIfExists&lt;/code&gt; 为true，并且 &lt;code&gt;$sNewFileName&lt;/code&gt; 是已存在文件的路径，则 &lt;code&gt;CopyFile&lt;/code&gt; 将失败。如果 &lt;code&gt;$bFailIfExists&lt;/code&gt; 为false，则 &lt;code&gt;$sOldFileNmae&lt;/code&gt; 文件的副本将覆盖 &lt;code&gt;$sNewFileName&lt;/code&gt; 文件（如果已存在）。</target>
        </trans-unit>
        <trans-unit id="de74274409753dd786fd5d63e5d1412ca957382c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not defined, Euler's number (e) is used:</source>
          <target state="translated">如果未定义 &lt;code&gt;$base&lt;/code&gt; ，则使用欧拉数（e）：</target>
        </trans-unit>
        <trans-unit id="0050f172fa605210fb670bacd9e4150d6ef91f04" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;$base&lt;/code&gt; 或''，则使用&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）&lt;/a&gt;。如果 &lt;code&gt;$base&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe7c38890e29ff157911650e99baf9d891029df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$base&lt;/code&gt; is not present or '', then &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt; is used. If &lt;code&gt;$base&lt;/code&gt; is relative, then it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;$base&lt;/code&gt; 或''，则使用&lt;a href=&quot;cwd&quot;&gt;Cwd :: cwd（）&lt;/a&gt;。如果 &lt;code&gt;$base&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs%28%29&quot;&gt;&amp;ldquo; rel2abs（）&amp;rdquo;&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7addd5930cc7a5f994dbe5d5d02d12cbcde98a29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$buffer&lt;/code&gt; consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &lt;code&gt;gunzip&lt;/code&gt; with the &lt;code&gt;MultiStream&lt;/code&gt; option in the &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; module if you need to deal with concatenated data streams.</source>
          <target state="translated">如果 &lt;code&gt;$buffer&lt;/code&gt; 由多个串联的gzip数据流组成，则只有第一个将被解压缩。如果您需要处理串联的数据流，请在 &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; 模块中将 &lt;code&gt;gunzip&lt;/code&gt; 与 &lt;code&gt;MultiStream&lt;/code&gt; 选项一起使用。</target>
        </trans-unit>
        <trans-unit id="92f8dcce322cf03e285482ec192e88b4162c7d25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, the corresponding callback will be disabled. There can only ever be one callback for a given key.</source>
          <target state="translated">如果 &lt;code&gt;$coderef&lt;/code&gt; 被省略或未定义，则相应的回调将被禁用。给定密钥只能有一个回调。</target>
        </trans-unit>
        <trans-unit id="7811262733e4fe0a3b5f69a60aebbea5b3943e0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;decode&lt;/code&gt; will only accept valid JSON texts.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false（默认值），则 &lt;code&gt;decode&lt;/code&gt; 将仅接受有效的JSON文本。</target>
        </trans-unit>
        <trans-unit id="7c1982a9afd1e57e2a8bcba28c638e592681686f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion, and tagged JSON values will cause a parse error in &lt;code&gt;decode&lt;/code&gt;, as if tags were not part of the grammar.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false（默认值），则 &lt;code&gt;encode&lt;/code&gt; 将不考虑这种类型的转换，并且标记的JSON值将在 &lt;code&gt;decode&lt;/code&gt; 导致解析错误，就像标记不是语法的一部分一样。</target>
        </trans-unit>
        <trans-unit id="1e48b0ec5233ac4e9e42a4dc42eb1f5c48b74c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will not consider this type of conversion.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false（默认值），则 &lt;code&gt;encode&lt;/code&gt; 将不考虑这种类型的转换。</target>
        </trans-unit>
        <trans-unit id="cdb7a77074d5d405efea88b2c7bbc5c701916dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters a blessed object that it cannot convert otherwise.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false（默认值），则 &lt;code&gt;encode&lt;/code&gt; 在遇到受祝福的对象时将引发异常，否则它将无法转换。</target>
        </trans-unit>
        <trans-unit id="04de0fcb5da7e078ae940e967073b0177355bd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false (the default), then &lt;code&gt;encode&lt;/code&gt; will throw an exception when it encounters anything it cannot encode as JSON.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false（默认值），则当遇到任何无法编码为JSON的内容时， &lt;code&gt;encode&lt;/code&gt; d将引发异常。</target>
        </trans-unit>
        <trans-unit id="3086280d8ee71ea70bdfcb2afb309beaf2d06527" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, no newlines or indenting will be produced, and the resulting JSON text is guaranteed not to contain any &lt;code&gt;newlines&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则不会产生换行符或缩进，并且保证结果JSON文本不包含任何 &lt;code&gt;newlines&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e975b01cc569dbba02de74e0b10f766fc4f3b4f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then JSON::PP does nothing.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则JSON :: PP不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="be336cd490e25871d5c5a043187b4c6b849802ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will croak if it isn't passed an arrayref or hashref, as JSON texts must either be an object or array. Likewise, &lt;code&gt;decode&lt;/code&gt; will croak if given something that is not a JSON object or array.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则未传递arrayref或hashref的 &lt;code&gt;encode&lt;/code&gt; 方法将崩溃，因为JSON文本必须是对象或数组。同样，如果给出的内容不是JSON对象或数组，则 &lt;code&gt;decode&lt;/code&gt; 也会发出嘶哑的声音。</target>
        </trans-unit>
        <trans-unit id="4552208ed349063bd809d4cf67b8cd611bca27cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not add any extra space at those places.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则 &lt;code&gt;encode&lt;/code&gt; 方法将不会在这些位置添加任何额外的空间。</target>
        </trans-unit>
        <trans-unit id="37e2d73b94d150c5d23686bd0382b4503285cd34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则除非JSON语法或其他标志要求，否则 &lt;code&gt;encode&lt;/code&gt; 方法将不会转义Unicode字符。</target>
        </trans-unit>
        <trans-unit id="f3902c5124259f16919978729c3ce2be1df8d80a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will not escape Unicode characters unless required by the JSON syntax or other flags. This results in a faster and more compact format.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则除非JSON语法或其他标志要求，否则 &lt;code&gt;encode&lt;/code&gt; 方法将不会转义Unicode字符。这样可以形成更快，更紧凑的格式。</target>
        </trans-unit>
        <trans-unit id="c86f85aa1caeceb3912119cb7b2d498b0a32493f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will output key-value pairs in the order Perl stores them (which will likely change between runs of the same script, and can change even within the same run from 5.18 onwards).</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则 &lt;code&gt;encode&lt;/code&gt; 方法将按Perl存储键值对的顺序输出键值对（在同一脚本的运行之间可能会更改，甚至从5.18开始，即使在同一运行中也可能更改）。</target>
        </trans-unit>
        <trans-unit id="13b52abf83b8965155f261b8d742e8a34398b89a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is false, then the &lt;code&gt;encode&lt;/code&gt; method will return the JSON string as a (non-encoded) Unicode string, while &lt;code&gt;decode&lt;/code&gt; expects thus a Unicode string. Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为false，则 &lt;code&gt;encode&lt;/code&gt; 方法将以（未编码的）Unicode字符串返回JSON字符串，而 &lt;code&gt;decode&lt;/code&gt; 期望为Unicode字符串。任何解码或编码（例如，对UTF-8或UTF-16）都需要自己完成，例如，使用编码模块。</target>
        </trans-unit>
        <trans-unit id="44ad37ba20b3a29620caccad5e3ecd7a88326558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), the string returned by &lt;code&gt;encode&lt;/code&gt; will be shrunk (i.e. downgraded if possible).</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则由 &lt;code&gt;encode&lt;/code&gt; 返回的字符串将被缩小（即，如果可能，将其降级）。</target>
        </trans-unit>
        <trans-unit id="bfb4e08bf1d863891f648ce2830c8c09f60cbc10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain JSON objects whose names don't begin and end with quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则 &lt;code&gt;decode&lt;/code&gt; 将接受无效的JSON文本，这些文本包含名称不以引号引起来的JSON对象。 &lt;code&gt;encode&lt;/code&gt; 将不会受到任何影响。</target>
        </trans-unit>
        <trans-unit id="246bb991806282f44448e175226c86c650ef5e28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain strings that begin and end with single quotation marks. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;decode&lt;/code&gt; 将接受无效的JSON文本，这些文本包含以单引号开头和结尾的字符串。 &lt;code&gt;encode&lt;/code&gt; 将不会受到任何影响。</target>
        </trans-unit>
        <trans-unit id="67308b350cc4783d9abd2fdf5b4a1f710199873e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept invalid JSON texts that contain unescaped [\x00-\x1f\x22\x5c] characters. &lt;code&gt;encode&lt;/code&gt; will not be affected in any way.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则 &lt;code&gt;decode&lt;/code&gt; 将接受包含未转义的[\ x00- \ x1f \ x22 \ x5c]字符的无效JSON文本。 &lt;code&gt;encode&lt;/code&gt; 将不会受到任何影响。</target>
        </trans-unit>
        <trans-unit id="7558d7379ca02e4f9b9f352b5ef01f5fb78976eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will accept some extensions to normal JSON syntax (see below). &lt;code&gt;encode&lt;/code&gt; will not be affected in anyway.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;decode&lt;/code&gt; 将接受常规JSON语法的某些扩展（请参见下文）。 &lt;code&gt;encode&lt;/code&gt; 将不会受到任何影响。</target>
        </trans-unit>
        <trans-unit id="8ace324f1a416d3e8da7b9e8dd1ed7db2c8c1dab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;decode&lt;/code&gt; will convert big integers Perl cannot handle as integer into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; objects and convert floating numbers into &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects. &lt;code&gt;encode&lt;/code&gt; will convert &lt;code&gt;Math::BigInt&lt;/code&gt; and &lt;code&gt;Math::BigFloat&lt;/code&gt; objects into JSON numbers.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则 &lt;code&gt;decode&lt;/code&gt; 将Perl无法将大整数转换为&lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigInt&lt;/a&gt;对象，并将浮点数转换为&lt;a href=&quot;Math::BigFloat&quot;&gt;Math :: BigFloat&lt;/a&gt;对象。 &lt;code&gt;encode&lt;/code&gt; 会将 &lt;code&gt;Math::BigInt&lt;/code&gt; 和 &lt;code&gt;Math::BigFloat&lt;/code&gt; 对象转换为JSON数字。</target>
        </trans-unit>
        <trans-unit id="82c0e8fb85aba2afac4d627a09a871fc06d122a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 将</target>
        </trans-unit>
        <trans-unit id="491263f59c01a4eaaa7f2c7452a1609d3f1f36ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt; will explicitly escape</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 将显式转​​义</target>
        </trans-unit>
        <trans-unit id="9f3f1412723a3ab4e362a57dd7e73738bb982d44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;FREEZE&lt;/code&gt; method on the object's class. If found, it will be used to serialise the object into a nonstandard tagged JSON value (that JSON decoders cannot decode).</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为真（或失踪），然后 &lt;code&gt;encode&lt;/code&gt; ，在遇到一个幸福的对象，将检查的可用性 &lt;code&gt;FREEZE&lt;/code&gt; 上对象的类方法。如果找到，它将用于将对象序列化为非标准标记的JSON值（JSON解码器无法解码）。</target>
        </trans-unit>
        <trans-unit id="a35a5f5496c5b2efdffca81661108891f4928274" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then &lt;code&gt;encode&lt;/code&gt;, upon encountering a blessed object, will check for the availability of the &lt;code&gt;TO_JSON&lt;/code&gt; method on the object's class. If found, it will be called in scalar context and the resulting scalar will be encoded instead of the object.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为真（或失踪），然后 &lt;code&gt;encode&lt;/code&gt; ，在遇到一个幸福的对象，将检查的可用性 &lt;code&gt;TO_JSON&lt;/code&gt; 在对象的类方法。如果找到，它将在标量上下文中调用，并且将对结果标量进行编码，而不是对对象进行编码。</target>
        </trans-unit>
        <trans-unit id="4aabc89dbe4a6bf91747a70a7f38abf24d998ff9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method can convert a non-reference into its corresponding string, number or null JSON value, which is an extension to RFC4627. Likewise, &lt;code&gt;decode&lt;/code&gt; will accept those JSON values instead of croaking.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 方法可以将非引用转换为其对应的字符串，数字或null JSON值，这是RFC4627的扩展。同样， &lt;code&gt;decode&lt;/code&gt; 将接受这些JSON值，而不是嘎吱作响。</target>
        </trans-unit>
        <trans-unit id="2bd9f62480de589dfa295edb699ae5c2e11f3633" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space after the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects and extra whitespace after the &lt;code&gt;,&lt;/code&gt; separating key-value pairs and array members.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为真（或丢失），则 &lt;code&gt;encode&lt;/code&gt; 方法将增加后的一个额外的可选的空间 &lt;code&gt;:&lt;/code&gt; 从值JSON对象和后多余的空白的分离键 &lt;code&gt;,&lt;/code&gt; 分离的键-值对和阵列成员。</target>
        </trans-unit>
        <trans-unit id="40417ce6845e6ec8b53c1d5a6af47798ccba201d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will add an extra optional space before the &lt;code&gt;:&lt;/code&gt; separating keys from values in JSON objects.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 方法将在 &lt;code&gt;:&lt;/code&gt; 分隔键和JSON对象中的值之前添加一个额外的可选空间。</target>
        </trans-unit>
        <trans-unit id="d08f5353e1c6dfda4e64411628e93b6243deb94f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the JSON result into UTF-8, as required by many protocols, while the &lt;code&gt;decode&lt;/code&gt; method expects to be handled an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any characters outside the range &lt;code&gt;0..255&lt;/code&gt;, they are thus useful for bytewise/binary I/O. In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32 encoding families, as described in RFC4627.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 方法将按照许多协议的要求将JSON结果编码为UTF-8，而 &lt;code&gt;decode&lt;/code&gt; 方法则期望将其处理为UTF-8编码的字符串。请注意，UTF-8编码的字符串不包含 &lt;code&gt;0..255&lt;/code&gt; 范围以外的任何字符，因此它们对于按字节/二进制I / O很有用。在将来的版本中，启用此选项可能会启用自动检测UTF-16和UTF-32编码系列，如RFC4627中所述。</target>
        </trans-unit>
        <trans-unit id="9cb7643219ec296a582847f0971f541d53b49849" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will encode the resulting JSON text as latin1 (or iso-8859-1), escaping any characters outside the code range &lt;code&gt;0..255&lt;/code&gt;. The resulting string can be treated as a latin1-encoded JSON text or a native Unicode string. The &lt;code&gt;decode&lt;/code&gt; method will not be affected in any way by this flag, as &lt;code&gt;decode&lt;/code&gt; by default expects Unicode, which is a strict superset of latin1.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则 &lt;code&gt;encode&lt;/code&gt; 方法将把生成的JSON文本编码为latin1（或iso-8859-1），转义代码范围 &lt;code&gt;0..255&lt;/code&gt; 外的任何字符。所得的字符串可以视为经latin1编码的JSON文本或本机Unicode字符串。该标志不会 &lt;code&gt;decode&lt;/code&gt; 方法产生任何影响，因为默认情况下， &lt;code&gt;decode&lt;/code&gt; 需要Unicode，这是latin1的严格超集。</target>
        </trans-unit>
        <trans-unit id="22d729ea73360087d038c168d6df4573c08be0b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not barf when it encounters a blessed reference that it cannot convert otherwise. Instead, a JSON &lt;code&gt;null&lt;/code&gt; value is encoded instead of the object.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则当遇到一个祝福的引用（否则它无法转换）时， &lt;code&gt;encode&lt;/code&gt; 方法将不会拒绝。取而代之的是，对JSON &lt;code&gt;null&lt;/code&gt; 值而不是对象进行编码。</target>
        </trans-unit>
        <trans-unit id="8120948e30627d79c4071787a445caabdb06a056" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will not generate characters outside the code range &lt;code&gt;0..127&lt;/code&gt; (which is ASCII). Any Unicode characters outside that range will be escaped using either a single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence, as per RFC4627. The resulting encoded JSON text can be treated as a native Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string, or any other superset of ASCII.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或丢失），则 &lt;code&gt;encode&lt;/code&gt; 方法将不会生成代码范围 &lt;code&gt;0..127&lt;/code&gt; （ASCII）之外的字符。根据RFC4627，将使用单个\ uXXXX（BMP字符）或双\ uHHHH \ uLLLLL转义序列转义该范围之外的所有Unicode字符。可以将生成的编码JSON文本视为本地Unicode字符串，ASCII编码，latin1编码或UTF-8编码的字符串或任何其他ASCII超集。</target>
        </trans-unit>
        <trans-unit id="5f442720c1ebc67a4d7d3134850e92ef85f78491" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will output JSON objects by sorting their keys. This is adding a comparatively high overhead.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 方法将通过对它们的键进行排序来输出JSON对象。这增加了相对较高的开销。</target>
        </trans-unit>
        <trans-unit id="f0fd8141083b0c1d8b81b6f4d6866a0fb5c4899a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$enable&lt;/code&gt; is true (or missing), then the &lt;code&gt;encode&lt;/code&gt; method will use a multiline format as output, putting every array member or object/hash key-value pair into its own line, indenting them properly.</source>
          <target state="translated">如果 &lt;code&gt;$enable&lt;/code&gt; 为true（或缺少），则 &lt;code&gt;encode&lt;/code&gt; 方法将使用多行格式作为输出，将每个数组成员或对象/哈希键/值对放入其自己的行中，并对其进行适当缩进。</target>
        </trans-unit>
        <trans-unit id="9c05ab0710c330ccfa58b05a1d99cb1930161cb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$fh&lt;/code&gt; is a filehandle, such as is returned by &lt;code&gt;IO::File&lt;/code&gt; or one of the other &lt;code&gt;IO&lt;/code&gt; modules, you may use:</source>
          <target state="translated">如果 &lt;code&gt;$fh&lt;/code&gt; 是文件句柄（例如 &lt;code&gt;IO::File&lt;/code&gt; 或其他 &lt;code&gt;IO&lt;/code&gt; 模块之一返回的），则可以使用：</target>
        </trans-unit>
        <trans-unit id="e3cb3fa6da7016a06a0ddc81b83c00820e64661b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$global&lt;/code&gt; is true then the driver should send the event to all hubs in all processes and threads.</source>
          <target state="translated">如果 &lt;code&gt;$global&lt;/code&gt; 为true，则驱动程序应将事件发送到所有进程和线程中的所有集线器。</target>
        </trans-unit>
        <trans-unit id="7412f2956d9be3c45dbde64ef1450e59ad2d04b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;&quot;register&quot;&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$id&lt;/code&gt; 是已注册对象的ID（请参见&lt;a href=&quot;#register&quot;&gt;&amp;ldquo; register&amp;rdquo;&lt;/a&gt;），则返回该对象，否则返回未定义的值。对于已注册的对象，这是 &lt;code&gt;id()&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="80cddfe7cac5da52e604c2e95ecabe44db020236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$id&lt;/code&gt; is the id of a registered object (see &lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;), returns the object, otherwise an undefined value. For registered objects this is the inverse function of &lt;code&gt;id()&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$id&lt;/code&gt; 是已注册对象的ID（请参见&lt;a href=&quot;#register&quot;&gt;register&lt;/a&gt;），则返回该对象，否则返回未定义的值。对于已注册的对象，这是 &lt;code&gt;id()&lt;/code&gt; 的反函数。</target>
        </trans-unit>
        <trans-unit id="cc434bb4b25d64e8d72b26a1167930b8ab9c02ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input&lt;/code&gt; 读取压缩数据。</target>
        </trans-unit>
        <trans-unit id="260df432afe5ea3f6b10347c137307e5145777ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input&lt;/code&gt; is a scalar reference, the compressed data will be read from &lt;code&gt;$$input&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$input&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input&lt;/code&gt; 读取压缩数据。</target>
        </trans-unit>
        <trans-unit id="1deee19e273a335c0c4f6a1643abcff33ad56b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; 读取输入数据。</target>
        </trans-unit>
        <trans-unit id="e61f15d9caa9af92bd7bab0101da2a2fc66fae53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a scalar reference, the input data will be read from &lt;code&gt;$$input_filename_or_reference&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是标量引用，则将从 &lt;code&gt;$$input_filename_or_reference&lt;/code&gt; 读取输入数据。</target>
        </trans-unit>
        <trans-unit id="442fe7b0ca25d4c885c4e854d9668346a5bb7269" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyinflate&lt;/code&gt; 都会假定它是一个</target>
        </trans-unit>
        <trans-unit id="9aa314fdcd8580313e8abf8e02f29427ab27b460" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyuncompress&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="18a54dcb23d30a160237fad9927225b0b52fd938" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;bunzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2674b9a8665c681ee519359fca9a33d0c649f2e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;bzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="8d40f68b3835780881ecdd758b0745e5d0346006" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;deflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4fe4284a3754ea968d5efe965b410a0bdc45da42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是一个由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;gunzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="54bfc13f24ab6d2f1fe87f0e4095f9cb61a84059" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;gzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="9bc5cf10f5ea974c9dba92b8ddcdee6c56efe154" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是受字符分隔的字符串&amp;ldquo;&amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo; &lt;code&gt;inflate&lt;/code&gt; 将假设它是一个</target>
        </trans-unit>
        <trans-unit id="8e074643e90fcbea02cb6c241eab28946a00d829" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;rawdeflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="c17eec5153adb41349f1323f8a2716fe9be3d4a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;rawinflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4ab52d4fbbd216b398b3cd45ad27a194f5b5a84f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;unzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="35a8f72eaee6c21d9a2ad219023a7a4de0558584" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;zip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2e1657129b850f80b9a61087ceca9451d92c60dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is an array reference, each element in the array must be a filename.</source>
          <target state="translated">如果 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 是数组引用，则数组中的每个元素必须是文件名。</target>
        </trans-unit>
        <trans-unit id="f6f55f2709b4c8b210fa8171af0e426a8189b01a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$locale_name&lt;/code&gt; is not available, fallback is selected in the following order:</source>
          <target state="translated">如果 &lt;code&gt;$locale_name&lt;/code&gt; 不可用，则按以下顺序选择回退：</target>
        </trans-unit>
        <trans-unit id="9bbc80ca8dd7a56323169258329eaced7ec9500d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$n&lt;/code&gt; is negative, returns the digit counting from left.</source>
          <target state="translated">如果 &lt;code&gt;$n&lt;/code&gt; 为负，则返回从左开始计数的数字。</target>
        </trans-unit>
        <trans-unit id="320bf336e74d67e7ea69246db25f2a4bdd482c4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$num_tests&lt;/code&gt; is omitted, the number of tests run will be used, like no_plan.</source>
          <target state="translated">如果省略 &lt;code&gt;$num_tests&lt;/code&gt; ，将使用运行的测试数量，如no_plan。</target>
        </trans-unit>
        <trans-unit id="9d696967ac485ed4d512d17c0805aaab2b3cb743" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$numeric&lt;/code&gt; is true, these will be given in numeric form rather than being resolved into names.</source>
          <target state="translated">如果 &lt;code&gt;$numeric&lt;/code&gt; 为true，则将以数字形式给出这些值，而不是解析为名称。</target>
        </trans-unit>
        <trans-unit id="dec7e6706afeeac3972bbf967d824b032cbdeb1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$olBytesRead&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, it will be set to the actual number of bytes read, though &lt;code&gt;length($opBuffer)&lt;/code&gt; can also be used to determine this.</source>
          <target state="translated">如果 &lt;code&gt;$olBytesRead&lt;/code&gt; 不是 &lt;code&gt;[]&lt;/code&gt; ，则将其设置为实际读取的字节数，尽管 &lt;code&gt;length($opBuffer)&lt;/code&gt; 也可以用来确定此值。</target>
        </trans-unit>
        <trans-unit id="2d1acd93b6a6ef1f8b92bfb6d087b55815058f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt; . Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是缓冲区并且启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有压缩数据将追加到 &lt;code&gt;$output&lt;/code&gt; 的末尾。否则，将在写入任何数据之前清除 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92afc15c575b4de234228583007cad12aa627fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a buffer and &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of &lt;code&gt;$output&lt;/code&gt;. Otherwise &lt;code&gt;$output&lt;/code&gt; will be cleared before any data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是缓冲区并且启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有压缩数据将追加到 &lt;code&gt;$output&lt;/code&gt; 的末尾。否则，将在写入任何数据之前清除 &lt;code&gt;$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8582554c9105fe0c715aaa06eeaea2d3fcfc688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a file or a filehandle, it must be seekable.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件或文件句柄，则它必须是可搜索的。</target>
        </trans-unit>
        <trans-unit id="430d11ebbae99eabba1b751c1fb7c8e38808dc22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件句柄，则通过调用将文件指针定位到文件末尾，以在将任何压缩数据写入到文件末尾之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="f05d0ea62b4bacb21e297df6978bb119d6575e37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filehandle, the file pointer will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件句柄，则通过调用将文件指针定位到文件末尾，以在将任何压缩数据写入到文件末尾之前进行 &lt;code&gt;seek&lt;/code&gt; 。否则，文件指针将不会被移动。</target>
        </trans-unit>
        <trans-unit id="6f34a91ef18a1100dcab801875430fa2964155e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a filename and &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是文件名并且启用了 &lt;code&gt;Append&lt;/code&gt; ，则该文件将以追加模式打开。否则，在将任何压缩数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="905a4b022cfd04d4344f06eb8d1d7814fe3b2e8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是标量引用，则压缩后的数据将存储在 &lt;code&gt;$$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a7576a43214d6e50502e7d58fdfce2630e01b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$output&lt;/code&gt; 是标量引用，则压缩后的数据将存储在 &lt;code&gt;$$output&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="130d5c72326e4e51651ab55caf6ff565c16bd2ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是标量引用，则压缩数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a39be39ddf44d7bf461e73a4324b038a6242f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the compressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是标量引用，则压缩数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6e6e43463d8cf9f8c4cc955f62290b2d79a9ce9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是一个标量引用，则未压缩的数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21a168ccb52122de1bd3352cd9d3af1687ee7454" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a scalar reference, the uncompressed data will be stored in &lt;code&gt;$$output_filename_or_reference&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是标量引用，则未压缩的数据将存储在 &lt;code&gt;$$output_filename_or_reference&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffed2a8f82140ef8dc0c4ed699c9112d9f907c47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyinflate&lt;/code&gt; 都将假定它是一个</target>
        </trans-unit>
        <trans-unit id="b9f151907f2e5c73c6d5a7f5e3827d63f2d086e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;anyuncompress&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;anyuncompress&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="eb784e91a1d15b001b3d17241bbd0f023fa0db31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bunzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;bunzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="308eaa4a6536e52e6cbbe3d9c09c32dfa80725fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;bzip2&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;bzip2&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="632c19749781b38310b67e8cb7d2da8bcbd87fa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;deflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;deflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4846f7304e22cdc9a232215f9939eddfa8d9211d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gunzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，那么 &lt;code&gt;gunzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="4f11ec72b95266da1fd717b81d461cc92a72f199" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;gzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;gzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="f099e710944546f4f6281f3a2de13a8288ffdd0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;inflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是受字符分隔的字符串&amp;ldquo;&amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo; &lt;code&gt;inflate&lt;/code&gt; 将假设它是一个</target>
        </trans-unit>
        <trans-unit id="cceae651ad537fbe024d4ffd9a457c78fec4fbd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawdeflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;rawdeflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="767601b4f86c38e1ce00ed67d4e6753dd438a660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;rawinflate&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串， &lt;code&gt;rawinflate&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="c227dd1ee1e8b9659ffdea7cebe0fc1ef9dd1a51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;unzip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;unzip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="2ae55891ab5b00668d1e680f825b4abc927f84c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a string that is delimited by the characters &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; &lt;code&gt;zip&lt;/code&gt; will assume that it is an</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是由字符&amp;ldquo; &amp;lt;&amp;rdquo;和&amp;ldquo;&amp;gt;&amp;rdquo;分隔的字符串，则 &lt;code&gt;zip&lt;/code&gt; 将假定它是一个</target>
        </trans-unit>
        <trans-unit id="a78a9fcfd00ce247c78fb42d76b95940b9310c9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the compressed data will be pushed onto the array.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是数组引用，则压缩后的数据将被压入数组。</target>
        </trans-unit>
        <trans-unit id="37e6606fa0b627f8a29d46dde4b8ebad46bd51a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an array reference, the uncompressed data will be pushed onto the array.</source>
          <target state="translated">如果 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 是数组引用，则未压缩的数据将被压入数组。</target>
        </trans-unit>
        <trans-unit id="46c17470e6cc4d6d06d981448409ffd8362d74b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;&quot;canonpath&quot;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是绝对的，则将其清除并使用&lt;a href=&quot;#canonpath&quot;&gt;&amp;ldquo; canonpath&amp;rdquo;&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="369470062bc6b67bd375785b11035d408478ab66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is absolute, it is cleaned up and returned using &lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是绝对的，则将其清理并使用&lt;a href=&quot;#canonpath&quot;&gt;canonpath&lt;/a&gt;返回。</target>
        </trans-unit>
        <trans-unit id="3c2c38c6381b06048880f2f47e06a03a66a2f0d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs%28%29&quot;&gt;&quot;rel2abs()&quot;&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs%28%29&quot;&gt;&amp;ldquo; rel2abs（）&amp;rdquo;将&lt;/a&gt;其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8992ca77fb991d344a3dd6a4f26aedbf1b0f1d7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$path&lt;/code&gt; is relative, it is converted to absolute form using &lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs()&lt;/a&gt;. This means that it is taken to be relative to &lt;a href=&quot;../cwd&quot;&gt;Cwd::cwd()&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$path&lt;/code&gt; 是相对的，则使用&lt;a href=&quot;#rel2abs()&quot;&gt;rel2abs（）&lt;/a&gt;将其转换为绝对形式。这意味着它被认为是相对于&lt;a href=&quot;../cwd&quot;&gt;Cwd :: cwd（）的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a33d4ccec3781b021129aedf529c68c428662f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$phase&lt;/code&gt; or &lt;code&gt;$type&lt;/code&gt; are undefined or otherwise invalid, an exception will be raised.</source>
          <target state="translated">如果 &lt;code&gt;$phase&lt;/code&gt; 或 &lt;code&gt;$type&lt;/code&gt; 未定义或无效，则将引发异常。</target>
        </trans-unit>
        <trans-unit id="529756014729906a36945c0c1d2b4d6306a5c66b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt; . The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt; , &lt;code&gt;$Config{libpth}&lt;/code&gt; , and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; . For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">如果 &lt;code&gt;$potential_libs&lt;/code&gt; 为空，则返回值为空。否则， &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的库（请参见Config.pm）将附加到 &lt;code&gt;$potential_libs&lt;/code&gt; 列表中。将在 &lt;code&gt;$potential_libs&lt;/code&gt; ， &lt;code&gt;$Config{libpth}&lt;/code&gt; 和 &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; 指定的目录中搜索这些库。对于找到的每个库，将生成一个用空格分隔的标准库路径名列表。</target>
        </trans-unit>
        <trans-unit id="a33dfa3cb51d3b667a9940aa0224c9aa9e3bd626" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$potential_libs&lt;/code&gt; is empty, the return value will be empty. Otherwise, the libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; (see Config.pm) will be appended to the list of &lt;code&gt;$potential_libs&lt;/code&gt;. The libraries will be searched for in the directories specified in &lt;code&gt;$potential_libs&lt;/code&gt;, &lt;code&gt;$Config{libpth}&lt;/code&gt;, and in &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt;. For each library that is found, a space-separated list of fully qualified library pathnames is generated.</source>
          <target state="translated">如果 &lt;code&gt;$potential_libs&lt;/code&gt; 为空，则返回值为空。否则，由 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定的库（请参见Config.pm）将附加到 &lt;code&gt;$potential_libs&lt;/code&gt; 列表中。将在 &lt;code&gt;$potential_libs&lt;/code&gt; ， &lt;code&gt;$Config{libpth}&lt;/code&gt; 和 &lt;code&gt;$Config{installarchlib}/CORE&lt;/code&gt; 指定的目录中搜索这些库。对于找到的每个库，将生成一个用空格分隔的标准库路径名列表。</target>
        </trans-unit>
        <trans-unit id="6e553e7605e3100f0e3fcb5a8fa623376f34f081" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">如果 &lt;code&gt;$priority&lt;/code&gt; 允许，则记录 &lt;code&gt;$message&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;($format, @args)&lt;/code&gt; ，并用$$ 替换$ message或 &lt;code&gt;$format&lt;/code&gt; 中的 &lt;code&gt;%m&lt;/code&gt; &lt;code&gt;&quot;$!&quot;&lt;/code&gt; （最新的错误消息）。</target>
        </trans-unit>
        <trans-unit id="853d4061f455f6e6d37a506979fa44f0b913548a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$priority&lt;/code&gt; permits, logs &lt;code&gt;$message&lt;/code&gt; or &lt;code&gt;sprintf($format, @args)&lt;/code&gt; with the addition that &lt;code&gt;%m&lt;/code&gt; in $message or &lt;code&gt;$format&lt;/code&gt; is replaced with &lt;code&gt;&quot;$!&quot;&lt;/code&gt; (the latest error message).</source>
          <target state="translated">如果 &lt;code&gt;$priority&lt;/code&gt; 允许，则记录 &lt;code&gt;$message&lt;/code&gt; 或 &lt;code&gt;sprintf($format, @args)&lt;/code&gt; ，并将$ message或 &lt;code&gt;$format&lt;/code&gt; 中的 &lt;code&gt;%m&lt;/code&gt; 替换为 &lt;code&gt;&quot;$!&quot;&lt;/code&gt; （最新的错误消息）。</target>
        </trans-unit>
        <trans-unit id="9f52d52d1ba29c4eacb016d029d5d02c84a30a69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是一个受祝福的引用，则将其受祝福的包的名称返回。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5e917878adcf725e243606546ded3ddf73b8c65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a blessed reference, the name of the package that it is blessed into is returned. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是一个有福的引用，则返回它有福的包的名称。否则，将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79e261aa8c38ef64f4ef56cc680e427a28531090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt; ). Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是引用，则所引用变量的基本Perl类型将以纯字符串形式返回（例如 &lt;code&gt;ARRAY&lt;/code&gt; 或 &lt;code&gt;HASH&lt;/code&gt; ）。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbc02c6f36c505398dff2d8f520950bd61427281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is a reference, the basic Perl type of the variable referenced is returned as a plain string (such as &lt;code&gt;ARRAY&lt;/code&gt; or &lt;code&gt;HASH&lt;/code&gt;). Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是引用，则所引用变量的基本Perl类型以纯字符串形式返回（例如 &lt;code&gt;ARRAY&lt;/code&gt; 或 &lt;code&gt;HASH&lt;/code&gt; ）。否则，将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fac5930e7537a0d644cf3490408ca500262cfef0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 被引用，则引用值的内部存储器地址将以纯整数形式返回。否则，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f8848e692246887d1670a841851026e0d0d247e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$ref&lt;/code&gt; is reference, the internal memory address of the referenced value is returned as a plain integer. Otherwise &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$ref&lt;/code&gt; 是引用，则将引用值的内部存储器地址作为纯整数返回。否则，将返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f2f6d4bd4dbef02b5adcb98b33be7311853de12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$result&lt;/code&gt; is undefined the corresponding parser has reached the end of its input (and will automatically be removed from the multiplexer).</source>
          <target state="translated">如果未定义 &lt;code&gt;$result&lt;/code&gt; 则相应的解析器已到达其输入的末尾（并将自动从多路复用器中删除）。</target>
        </trans-unit>
        <trans-unit id="78156973481681bf236b7a46f7e67281a60be7e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$string&lt;/code&gt; is given, then this string is appended to the already existing JSON fragment stored in the &lt;code&gt;$json&lt;/code&gt; object.</source>
          <target state="translated">如果给出了 &lt;code&gt;$string&lt;/code&gt; ，那么此字符串将附加到 &lt;code&gt;$json&lt;/code&gt; 对象中存储的已经存在的JSON片段中。</target>
        </trans-unit>
        <trans-unit id="3a340f9f260eea8720ddb9232a9ecfe918063812" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;-1&lt;/code&gt; ，在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="34f2ce5e748390e7ea9b7256361ae68fda804dd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="78ec8c638c3f85aaeb890b68130939aac53cb1a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt; , returns an empty list.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="fc1b67e1c3f6e66a8b72265ebfbfbd5b7ef792af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;-1&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;-1&lt;/code&gt; ，在列表上下文中返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="c201b05fbdc585a181de55865d16278affee3294" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns &lt;code&gt;undef&lt;/code&gt; in scalar context and an empty list in list context.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则在标量上下文中返回 &lt;code&gt;undef&lt;/code&gt; ，在列表上下文中返回空列表。</target>
        </trans-unit>
        <trans-unit id="0f2e1e8a9a6ad69b33dbc5f664836bb1347dcf06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; does not match any part of &lt;code&gt;$string&lt;/code&gt;, returns an empty list.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 任何部分都不匹配，则返回一个空列表。</target>
        </trans-unit>
        <trans-unit id="7dc9206b35b196b0963c771281e4b1c34fd9c295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的所有匹配项都将被 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ）并返回 &lt;code&gt;$count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46dcd3b846eff16d0953c63180197a9948d71b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则在标量上下文中，返回对匹配部分首次出现的&lt;b&gt;引用&lt;/b&gt;（如果匹配，则 &lt;code&gt;$match_ref&lt;/code&gt; 始终为true，因为每个引用均为&lt;b&gt;true&lt;/b&gt;）；在列表上下文中，返回匹配部分的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="c160da8add608824da0efecdea8fe8dbd7d4c55a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回所有匹配的部分（或标量上下文中的匹配计数）。</target>
        </trans-unit>
        <trans-unit id="c10bc187ce931b2a7b22530d13ae4fe64805817c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回标量上下文中匹配部分的第一个匹配项的位置；在列表上下文中，返回匹配部分的位置和长度的两元素列表。</target>
        </trans-unit>
        <trans-unit id="d649e7e5214d8eb5d7dfa63d2b26508aa3ec136c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt; , the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt; ) is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的第一个匹配项将由 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ），并返回 &lt;code&gt;$count&lt;/code&gt; （始终等于 &lt;code&gt;1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3fbde2ba093a3465cab9494d515f9997f56434f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, all the occurrences of the matching part are replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的所有匹配项都将被 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ）并返回 &lt;code&gt;$count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4911ca5dae8ff08a4b4cb6051ee9c7432277080b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, in scalar context, returns &lt;b&gt;a reference to&lt;/b&gt; the first occurrence of the matching part (&lt;code&gt;$match_ref&lt;/code&gt; is always true if matches, since every reference is &lt;b&gt;true&lt;/b&gt;); in list context, returns the first occurrence of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则在标量上下文中，返回对匹配部分首次出现的&lt;b&gt;引用&lt;/b&gt;（如果匹配，则 &lt;code&gt;$match_ref&lt;/code&gt; 始终为true，因为每个引用均为&lt;b&gt;true&lt;/b&gt;）；在列表上下文中，返回匹配部分的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="50330de1105cec13a916504977d0fffac051d470" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns all the matching parts (or matching count in scalar context).</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回所有匹配的部分（或标量上下文中的匹配计数）。</target>
        </trans-unit>
        <trans-unit id="b37346d5bdc4adf2f6aafd9b3124f4a5fcee52ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, returns the position of the first occurrence of the matching part in scalar context; in list context, returns a two-element list of the position and the length of the matching part.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则返回标量上下文中匹配部分的第一个匹配项的位置；在列表上下文中，返回匹配部分的位置和长度的两元素列表。</target>
        </trans-unit>
        <trans-unit id="7936ff462585086c63c3b202fca7c61f67f270da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$substring&lt;/code&gt; matches a part of &lt;code&gt;$string&lt;/code&gt;, the first occurrence of the matching part is replaced by &lt;code&gt;$replacement&lt;/code&gt; (&lt;code&gt;$string&lt;/code&gt; is modified) and &lt;code&gt;$count&lt;/code&gt; (always equals to &lt;code&gt;1&lt;/code&gt;) is returned.</source>
          <target state="translated">如果 &lt;code&gt;$substring&lt;/code&gt; 与 &lt;code&gt;$string&lt;/code&gt; 的一部分匹配，则匹配部分的第一个匹配项将由 &lt;code&gt;$replacement&lt;/code&gt; （修改 &lt;code&gt;$string&lt;/code&gt; ），并返回 &lt;code&gt;$count&lt;/code&gt; （始终等于 &lt;code&gt;1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="923955b556ee1c107b87425fc0d239520dd618a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$thing&lt;/code&gt; 引用一个对象，则此函数返回该对象已被祝福的包的名称。如果 &lt;code&gt;$thing&lt;/code&gt; 不包含对受祝福对象的引用，则受 &lt;code&gt;blessed&lt;/code&gt; 函数返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6339b1ca7faa12a87dd16d8376168402efc0b0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$thing&lt;/code&gt; refers to an object, then this function returns the name of the package the object has been blessed into. If &lt;code&gt;$thing&lt;/code&gt; doesn't contain a reference to a blessed object, the &lt;code&gt;blessed&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$thing&lt;/code&gt; 引用一个对象，则此函数返回该对象已被祝福的包的名称。如果 &lt;code&gt;$thing&lt;/code&gt; 不包含对受祝福对象的引用，则受 &lt;code&gt;blessed&lt;/code&gt; 函数返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62b5b827c9fa69b1b1193c08475c48b1b10adad6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; , you've got a successful test.</source>
          <target state="translated">如果 &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; 且 &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; ，则测试成功。</target>
        </trans-unit>
        <trans-unit id="762c2fef6e9c59f981f639aa3049b28356711a9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; and &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt;, you've got a successful test.</source>
          <target state="translated">如果 &lt;code&gt;$total-&amp;gt;{bad} == 0&lt;/code&gt; 且 &lt;code&gt;$total-&amp;gt;{max} &amp;gt; 0&lt;/code&gt; ，则测试成功。</target>
        </trans-unit>
        <trans-unit id="49c7b300af278a42c6325ca397a30c8b1a02bd5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$uOldFlags&lt;/code&gt; were the value of the handle's flags before the call to &lt;code&gt;SetHandleInformation&lt;/code&gt;, then the value of the handle's flags afterward would be:</source>
          <target state="translated">如果 &lt;code&gt;$uOldFlags&lt;/code&gt; 是在调用 &lt;code&gt;SetHandleInformation&lt;/code&gt; 之前句柄的标志的值，则此后句柄的标志的值将是：</target>
        </trans-unit>
        <trans-unit id="7e9127d14922a52db0d5d2508646de8dbb02dabc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar that has both numeric and string values, the result is true.</source>
          <target state="translated">如果 &lt;code&gt;$var&lt;/code&gt; 是同时具有数字和字符串值的标量，则结果为true。</target>
        </trans-unit>
        <trans-unit id="811b177adb678df1c7fcd2ebe9a8006c41328bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring the result is true.</source>
          <target state="translated">如果 &lt;code&gt;$var&lt;/code&gt; 是标为vstring的标量，则结果为true。</target>
        </trans-unit>
        <trans-unit id="a9caaf937ca561a040c20b5fbde0fec6da524973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$var&lt;/code&gt; is a scalar which was coded as a vstring, the result is true.</source>
          <target state="translated">如果 &lt;code&gt;$var&lt;/code&gt; 是被编码为vstring的标量，则结果为true。</target>
        </trans-unit>
        <trans-unit id="eea1e5cda1b021861102b8f6816c7f61a9adac01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; . '&lt;code&gt;NaN&lt;/code&gt; ' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">如果 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 非零，则它们必须是相对质数，即 &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; 。当不存在模乘逆时，将返回&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b5fcc92529718794debebbbd28d3a6b743f73817" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are non-zero, they must be relative primes, i.e., &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt;. '&lt;code&gt;NaN&lt;/code&gt;' is returned when no modular multiplicative inverse exists.</source>
          <target state="translated">如果 &lt;code&gt;$x&lt;/code&gt; 和 &lt;code&gt;$y&lt;/code&gt; 非零，则它们必须是相对质数，即 &lt;code&gt;bgcd($y, $mod)==1&lt;/code&gt; 。当不存在模乘逆时，将返回&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f1241f2fba2bddba0f0228a9100bb47c11034264" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 与缓冲区关联，则此方法无效，并且始终返回 &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9624e7af7def5be294a442f4173d4d3d6d7e212" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$z&lt;/code&gt; is associated with a buffer, this method has no effect and always returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;$z&lt;/code&gt; 与缓冲区关联，则此方法无效，并且始终返回 &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2e0c2819ecb9af14cc06d8987b7eee133a60fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%-&lt;/code&gt; is being operated on, if any.</source>
          <target state="translated">如果正在运行 &lt;code&gt;%+&lt;/code&gt; 或 &lt;code&gt;%-&lt;/code&gt; （如果有）。</target>
        </trans-unit>
        <trans-unit id="33759bad70947890a80808b87beeb0ad07a9f99a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is overloaded then the same implementation is used for both the</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 被重载，则对于</target>
        </trans-unit>
        <trans-unit id="2655a0d13879bb1273409b47214e136f442c0716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character.</source>
          <target state="translated">如果 &lt;code&gt;'-'&lt;/code&gt; 是字符类中的第一个或最后一个字符，则将其视为普通字符。</target>
        </trans-unit>
        <trans-unit id="3fbcc9b880c1850b742f9cae8dd87f58567ba57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt; , &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">如果 &lt;code&gt;'-'&lt;/code&gt; 是字符类中的第一个或最后一个字符，则将其视为普通字符；否则，将其视为普通字符。 &lt;code&gt;[-ab]&lt;/code&gt; ， &lt;code&gt;[ab-]&lt;/code&gt; 和 &lt;code&gt;[a\-b]&lt;/code&gt; 都是等效的。</target>
        </trans-unit>
        <trans-unit id="7642b1add676b77e55b012fe61fa0084ce5fe11b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'-'&lt;/code&gt; is the first or last character in a character class, it is treated as an ordinary character; &lt;code&gt;[-ab]&lt;/code&gt;, &lt;code&gt;[ab-]&lt;/code&gt; and &lt;code&gt;[a\-b]&lt;/code&gt; are all equivalent.</source>
          <target state="translated">如果 &lt;code&gt;'-'&lt;/code&gt; 是字符类中的第一个字符或最后一个字符，则将其视为普通字符；否则，将其视为普通字符。 &lt;code&gt;[-ab]&lt;/code&gt; ， &lt;code&gt;[ab-]&lt;/code&gt; 和 &lt;code&gt;[a\-b]&lt;/code&gt; 都是等效的。</target>
        </trans-unit>
        <trans-unit id="8b4ef209f3736a149a4cf48e4ad6ea5f08cb5ced" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl's fallback for the &lt;code&gt;++&lt;/code&gt; operator is to increment the reference itself.)</source>
          <target state="translated">如果 &lt;code&gt;'fallback'&lt;/code&gt; 为TRUE且未定义副本构造函数，则对于不基于标量的对象，Perl可能会默默地退回给简单的赋值-即对象引用的赋值。实际上，这将禁用复制构造函数机制，因为没有创建对象数据的新副本。几乎可以肯定这不是您想要的。（但是，这是一致的：例如，Perl对于 &lt;code&gt;++&lt;/code&gt; 运算符的后备方法是增加引用本身。）</target>
        </trans-unit>
        <trans-unit id="f876580a65734a569954c7e1c0d71566801b2a2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;'fallback'&lt;/code&gt; is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object's data is stored as, for example, an array of scalars, the following might be appropriate:</source>
          <target state="translated">如果未定义 &lt;code&gt;'fallback'&lt;/code&gt; 或TRUE，则可以自动生成副本构造函数，但仅适用于基于标量的对象。在其他情况下，需要明确定义。在将对象数据存储为例如标量数组的情况下，以下条件可能是合适的：</target>
        </trans-unit>
        <trans-unit id="aaf2bfa6a27ac22ef6886057189af7b7a1f09aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;//p&lt;/code&gt; ) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;.</source>
          <target state="translated">如果 &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; ,则该捕获组不匹配。 &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; 表示 &lt;code&gt;$&amp;amp;&lt;/code&gt; （或 &lt;code&gt;//p&lt;/code&gt; 下的 &lt;code&gt;${^MATCH}&lt;/code&gt; ）， &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; 匹配 &lt;code&gt;$$paren&lt;/code&gt; ，其中 &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="57dd1014f096fb43a6b9346ad9421342ded823ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; or &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; then that capture group did not match. &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; represents &lt;code&gt;$&amp;amp;&lt;/code&gt; (or &lt;code&gt;${^MATCH}&lt;/code&gt; under &lt;code&gt;/p&lt;/code&gt;) and &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; matches &lt;code&gt;$$paren&lt;/code&gt; where &lt;code&gt;$paren &lt;/code&gt;= 1&amp;gt;.</source>
          <target state="translated">如果 &lt;code&gt;-&amp;gt;offs[num].start&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;offs[num].end&lt;/code&gt; 为 &lt;code&gt;-1&lt;/code&gt; ,则该捕获组不匹配。 &lt;code&gt;-&amp;gt;offs[0].start/end&lt;/code&gt; 代表 &lt;code&gt;$&amp;amp;&lt;/code&gt; （或 &lt;code&gt;/p&lt;/code&gt; 下的 &lt;code&gt;${^MATCH}&lt;/code&gt; ）， &lt;code&gt;-&amp;gt;offs[paren].end&lt;/code&gt; 匹配 &lt;code&gt;$$paren&lt;/code&gt; ，其中 &lt;code&gt;$paren &lt;/code&gt; = 1&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="c6203f8ab9db59ac080a4fb390ff800c0d1e53c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt; . If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">如果 &lt;code&gt;-&lt;/code&gt; 不是公认的切换字母，则getopts（）支持参数 &lt;code&gt;--help&lt;/code&gt; 和 &lt;code&gt;--version&lt;/code&gt; 。如果定义了 &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; 和/或 &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; ，则将它们调用；否则，将调用它们。参数是输出文件句柄，选项处理程序包的名称，版本和开关字符串。如果未定义子例程，则尝试生成智能消息。为了获得最佳结果，请定义$ main :: VERSION。</target>
        </trans-unit>
        <trans-unit id="14cd49c88b8972d01c98fe1ff97e8e713aaa02a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt; is not a recognized switch letter, getopts() supports arguments &lt;code&gt;--help&lt;/code&gt; and &lt;code&gt;--version&lt;/code&gt;. If &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; and/or &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; are defined, they are called; the arguments are the output file handle, the name of option-processing package, its version, and the switches string. If the subroutines are not defined, an attempt is made to generate intelligent messages; for best results, define $main::VERSION.</source>
          <target state="translated">如果 &lt;code&gt;-&lt;/code&gt; 不是公认的切换字母，则getopts（）支持参数 &lt;code&gt;--help&lt;/code&gt; 和 &lt;code&gt;--version&lt;/code&gt; 。如果定义了 &lt;code&gt;main::HELP_MESSAGE()&lt;/code&gt; 和/或 &lt;code&gt;main::VERSION_MESSAGE()&lt;/code&gt; ，则将它们调用；否则，将调用它们。参数是输出文件句柄，选项处理软件包的名称，其版本和开关字符串。如果未定义子例程，则尝试生成智能消息；否则，将尝试生成智能消息。为了获得最佳结果，请定义$ main :: VERSION。</target>
        </trans-unit>
        <trans-unit id="7069d110eb31ac59c5fa5654832fee9ae99f4bc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-Strict&lt;/code&gt; is disabled, then &lt;code&gt;$string&lt;/code&gt; can contain any character except NULL. If any null characters are present, the field will be truncated at the first NULL.</source>
          <target state="translated">如果禁用 &lt;code&gt;-Strict&lt;/code&gt; ，则 &lt;code&gt;$string&lt;/code&gt; 可以包含除NULL之外的任何字符。如果存在任何空字符，则该字段将在第一个NULL处被截断。</target>
        </trans-unit>
        <trans-unit id="72b90d51b78e3f86c015e424f0a9c82ae7cdd392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:full&lt;/code&gt; is present, for expansion of &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt;, the string</source>
          <target state="translated">如果存在 &lt;code&gt;:full&lt;/code&gt; ，则对于 &lt;code&gt;\N{&lt;i&gt;CHARNAME&lt;/i&gt;}&lt;/code&gt; 扩展，该字符串</target>
        </trans-unit>
        <trans-unit id="34845b5a7409ae2ff88602a784737cd832c5bd71" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;:short&lt;/code&gt; is present, and</source>
          <target state="translated">如果 &lt;code&gt;:short&lt;/code&gt; 存在，并且</target>
        </trans-unit>
        <trans-unit id="51514fa7ee13d4abe63d9987d2badb1e9b04ad61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; 从堆栈顶部结束，则会报告最高上下文。</target>
        </trans-unit>
        <trans-unit id="b1ac9c6b50bb86cfe48d37ba1ee2e0f181649af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (not a string &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ) is passed explicitly as the value for this key, any normalization is not carried out (this may make tailoring easier if any normalization is not desired). Under &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , only contiguous contractions are resolved; e.g. even if &lt;code&gt;A-ring&lt;/code&gt; (and &lt;code&gt;A-ring-cedilla&lt;/code&gt; ) is ordered after &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;A-cedilla-ring&lt;/code&gt; would be primary equal to &lt;code&gt;A&lt;/code&gt; . In this point, &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is not&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; .</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （不是字符串 &lt;code&gt;&quot;undef&quot;&lt;/code&gt; ）显式传递为此键的值，则不会执行任何规范化（如果不需要任何规范化，这可能会使剪裁更加容易）。在 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，仅解决了连续收缩；例如即使 &lt;code&gt;A-ring&lt;/code&gt; （和 &lt;code&gt;A-ring-cedilla&lt;/code&gt; ）的后有序 &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;A-cedilla-ring&lt;/code&gt; 将初级等于 &lt;code&gt;A&lt;/code&gt; 。在这一点上， &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;不&lt;/b&gt;等于 &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3ebd4a416f2ed67a7f6e0321914f19253d4061" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, no file is read (but you can define collation elements via &lt;code&gt;entry&lt;/code&gt; ).</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则不会读取任何文件（但是您可以通过 &lt;code&gt;entry&lt;/code&gt; 定义归类元素）。</target>
        </trans-unit>
        <trans-unit id="311ed3b2b34ac0afe5f28bb9003642de34a3cf73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weight for Hangul syllables is treated as undefined without decomposition into Hangul Jamo. But definition of weight for Hangul syllables in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid.</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 作为此键的值显式传递，则将韩文音节的权重视为未定义，而不会分解为韩文Jamo。但是 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;entry&lt;/code&gt; 中韩语音节的权重定义仍然有效。</target>
        </trans-unit>
        <trans-unit id="a0847d602472c48d4557dcd264e5fd82c70ededc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; directive has a &lt;code&gt;:opd=FLAGS&lt;/code&gt; argument, this switches on debugging of opcode dispatch. &lt;code&gt;FLAGS&lt;/code&gt; should be a combination of &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; (see &lt;b&gt;-D&lt;/b&gt; flags in &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;). &lt;code&gt;:opd&lt;/code&gt; is a shortcut for &lt;code&gt;:opd=st&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Devel::Peek&lt;/code&gt; 指令具有 &lt;code&gt;:opd=FLAGS&lt;/code&gt; 参数，则将打开操作码调度的调试。 &lt;code&gt;FLAGS&lt;/code&gt; 应该是 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; 的组合（请参见&lt;a href=&quot;../perlrun&quot;&gt;perlrun中的&lt;/a&gt;&lt;b&gt;-D&lt;/b&gt;标志）。 &lt;code&gt;:opd&lt;/code&gt; 是 &lt;code&gt;:opd=st&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="dae0c23c00276e5219bdb2cdf7fffc6926c2f0f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 可以读取文件但无法编译，则它将返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并在 &lt;code&gt;$@&lt;/code&gt; 设置错误消息。如果 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 无法读取文件，它将返回undef并设置 &lt;code&gt;$!&lt;/code&gt; 错误。请务必先检查 &lt;code&gt;$@&lt;/code&gt; ，因为编译可能会失败，同时也会设置 &lt;code&gt;$!&lt;/code&gt; 。如果文件已成功编译，则 &lt;code&gt;&lt;a href=&quot;do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 返回最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="e753c27e9c7187898b162963067981265acf4ee7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; can read the file but cannot compile it, it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets an error message in &lt;code&gt;$@&lt;/code&gt; . If &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; cannot read the file, it returns undef and sets &lt;code&gt;$!&lt;/code&gt; to the error. Always check &lt;code&gt;$@&lt;/code&gt; first, as compilation could fail in a way that also sets &lt;code&gt;$!&lt;/code&gt; . If the file is successfully compiled, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; returns the value of the last expression evaluated.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 可以读取文件但无法编译，则它将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并在 &lt;code&gt;$@&lt;/code&gt; 设置错误消息。如果 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 无法读取文件，它将返回undef并设置 &lt;code&gt;$!&lt;/code&gt; 错误。请务必先检查 &lt;code&gt;$@&lt;/code&gt; ，因为编译可能会失败，同时也会设置 &lt;code&gt;$!&lt;/code&gt; 。如果文件已成功编译，则 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 返回最后计算的表达式的值。</target>
        </trans-unit>
        <trans-unit id="a29f1441f3fe81108d43067a84beeb2b3df06a0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">如果确实需要 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; ，请考虑使用以下命令：</target>
        </trans-unit>
        <trans-unit id="fbdbd42df3d8a3289f178b0b712d70c88452aff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 遇到操作系统错误，则 &lt;code&gt;$!&lt;/code&gt; 将设置相应的错误消息。检查 &lt;code&gt;$!&lt;/code&gt; 可能会有帮助！当您从不信任的文件句柄（例如tty或套接字）中读取内容时。下面的示例使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的运算符形式，如果未定义结果，则死亡。</target>
        </trans-unit>
        <trans-unit id="d241999daf1d6b5b1d790a94e12c3db4b7639b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向格式不正确的UTF-8字符并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="e0d74bacc686d5d25a69c27fe56691316eb86755" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value, if well-defined (or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向格式不正确的UTF-8字符并且启用了UTF8警告，则返回零，并将 &lt;code&gt;*retlen&lt;/code&gt; 设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义正确）（如果没有，则返回Unicode REPLACEMENT CHARACTER），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，该位置可以开始一个格式正确的字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="bd7ce6c8380ad430d911ba4aeab09bd5672c569b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; doesn't point to NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向检测到的一种 &lt;code&gt;*retlen&lt;/code&gt; ，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不指向NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="f087a32f599c70b71522f617c69df5af3084d9d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; points to one of the detected malformations, and UTF8 warnings are enabled, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) to -1. If those warnings are off, the computed value if well-defined (or the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and &lt;code&gt;*retlen&lt;/code&gt; is set (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. See &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt; for details on when the REPLACEMENT CHARACTER is returned.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 指向检测到的 &lt;code&gt;*retlen&lt;/code&gt; 之一，并且启用了UTF8警告，则返回零，并将* retlen设置为-1 （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL）。如果关闭了这些警告，则将静默返回计算值（如果定义良好）（或Unicode REPLACEMENT CHARACTER，如果不是），并设置 &lt;code&gt;*retlen&lt;/code&gt; （如果 &lt;code&gt;retlen&lt;/code&gt; 不为NULL），则（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）为 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 中的下一个可能位置，可以开始一个非格式字符。有关&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;何时&lt;/a&gt;返回REPLACEMENT CHARACTER的详细信息，请参见utf8n_to_uvchr。</target>
        </trans-unit>
        <trans-unit id="5f4f6bcfdeca5ca3ce7d26db71a53789a3b67e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; is invoked as &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; or with no arguments (which really means &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; , see &lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;), Perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this, the Perl engine does:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 是作为 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; ' '&lt;/code&gt; 或没有参数调用的（这实际上意味着 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;(' ', $_)&lt;/code&gt; ，请参见&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;），Perl将设置此标志。然后，正则表达式引擎可以对其进行检查并设置SKIPWHITE和WHITE extflags。为此，Perl引擎执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5670ad2e09b0f96c2653919425d0503ae94298b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">如果未显式调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; ，则在首次使用 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 运算符时将不带参数地隐式调用它。但是，在某些情况下，程序可能希望调用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 。一种是生成可预测的结果，通常用于测试或调试。在这里，您使用 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; ，每次都使用相同的 &lt;code&gt;$seed&lt;/code&gt; 。另一种情况是，您可能希望在 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 之后调用srand（），以避免子进程与父进程共享相同的种子值（因此彼此共享）。</target>
        </trans-unit>
        <trans-unit id="cccd9e31f8fdf12513d7e9607d1902ac2bd43369" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 传递了包含下划线的特殊文件句柄，则不会执行任何stat，但是会返回最后 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 或filetest中stat结构的当前内容。例：</target>
        </trans-unit>
        <trans-unit id="3a943f3015131830c0ed79135dd6ffd5caeedbfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; is specified as an argument to &lt;code&gt;autodie&lt;/code&gt; , then it uses &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt; to do the heavy lifting. See the description of that module for more information.</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 指定为 &lt;code&gt;autodie&lt;/code&gt; 的参数，则它将使用&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;进行繁重的工作。有关更多信息，请参见该模块的描述。</target>
        </trans-unit>
        <trans-unit id="3a8b7802544453fc6ad5238177a90c2f0eccb634" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">如果有效的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （包括 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）已被调用，则已格式化POSIF :: setlocale（）的字符将受 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境影响。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="037fc9127a03dbcb60108531d797528430fc80ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; encounters an operating system error, &lt;code&gt;$!&lt;/code&gt; will be set with the corresponding error message. It can be helpful to check &lt;code&gt;$!&lt;/code&gt; when you are reading from filehandles you don't trust, such as a tty or a socket. The following example uses the operator form of &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; and dies if the result is not defined.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 遇到操作系统错误，则 &lt;code&gt;$!&lt;/code&gt; 将设置相应的错误消息。检查 &lt;code&gt;$!&lt;/code&gt; 可能会有帮助！当您从不信任的文件句柄（例如tty或套接字）中读取内容时。下面的示例使用 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的运算符形式，如果未定义结果，则死亡。</target>
        </trans-unit>
        <trans-unit id="2d7702ac9f2d2a81c61f2c22a4643a2b4934ac53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; is not called explicitly, it is called implicitly without a parameter at the first use of the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; operator. However, there are a few situations where programs are likely to want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt;. One is for generating predictable results, generally for testing or debugging. There, you use &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt;, with the same &lt;code&gt;$seed&lt;/code&gt; each time. Another case is that you may want to call &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; after a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; to avoid child processes sharing the same seed value as the parent (and consequently each other).</source>
          <target state="translated">如果未显式调用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; ，则在首次使用 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 运算符时将不带参数地隐式调用它。但是，在某些情况下，程序可能希望调用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; 。一种是生成可预测的结果，通常用于测试或调试。在这里，您使用 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand($seed)&lt;/a&gt;&lt;/code&gt; ，每次都使用相同的 &lt;code&gt;$seed&lt;/code&gt; 。另一种情况是，您可能希望在 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 之后调用srand（），以避免子进程与父进程共享相同的种子值（因此彼此共享）。</target>
        </trans-unit>
        <trans-unit id="0e39dea0f8d4bc40933767354a2f3ede98ed2f3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; is passed the special filehandle consisting of an underline, no stat is done, but the current contents of the stat structure from the last &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;, or filetest are returned. Example:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; 传递了包含下划线的特殊文件句柄，则不会执行任何stat，但是会返回最后 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; 或filetest中stat结构的当前内容。例：</target>
        </trans-unit>
        <trans-unit id="4d0fc4f120e9a470fc6f07be480b6e3ed0441ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; is in effect:</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 有效：</target>
        </trans-unit>
        <trans-unit id="acafe9c3ebbd6459bfa75fbfb2c2b7c67ce9bcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (including &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">如果有效的 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （包括 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）已被调用，则已格式化POSIF :: setlocale（）的字符将受 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境影响。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fa0102bfd20d7fca81e7a9229fd0c15e53ef801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@descriptions&lt;/code&gt; is given, these correspond to the keys used in each call to the add() method. Returns an array of the requested parsers (in the requested order) in list context or an array reference in scalar context.</source>
          <target state="translated">如果给出 &lt;code&gt;@descriptions&lt;/code&gt; ，则它们对应于对add（）方法的每次调用中使用的键。在列表上下文中返回请求的解析器​​数组（按请求的顺序），在标量上下文中返回数组引用。</target>
        </trans-unit>
        <trans-unit id="19fd000c86a54d51f5f77fda0d06393c9c4850ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A'&lt;/code&gt; coincide: &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;AB'&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; is a better match for &lt;code&gt;T&lt;/code&gt; than &lt;code&gt;B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;A'&lt;/code&gt; 重合： &lt;code&gt;AB&lt;/code&gt; 比更好的匹配 &lt;code&gt;AB'&lt;/code&gt; 如果 &lt;code&gt;B&lt;/code&gt; 为更好的匹配 &lt;code&gt;T&lt;/code&gt; 比 &lt;code&gt;B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1cdd4b8faba979c10f3007699d2ae7796c4a29c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a better match for &lt;code&gt;S&lt;/code&gt; than &lt;code&gt;A'&lt;/code&gt;, &lt;code&gt;AB&lt;/code&gt; is a better match than &lt;code&gt;A'B'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是更好的匹配 &lt;code&gt;S&lt;/code&gt; 比 &lt;code&gt;A'&lt;/code&gt; &lt;code&gt;AB&lt;/code&gt; 是不是更好的匹配 &lt;code&gt;A'B'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4156d315c54ceb2fee7698af8b63e714f0a2462c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all compressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any compressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有压缩数据将追加到输出缓冲区的末尾。否则，在将任何压缩数据写入输出缓冲区之前，将清除输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="949b457391fc5cf37099eaecff56b10b510ca113" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, all uncompressed data will be append to the end of the output buffer. Otherwise the output buffer will be cleared before any uncompressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则所有未压缩的数据将追加到输出缓冲区的末尾。否则，在将任何未压缩的数据写入输出缓冲区之前，将清除输出缓冲区。</target>
        </trans-unit>
        <trans-unit id="badd301fd65baa8719ba53ea1a80949656267442" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any compressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则文件将以追加模式打开。否则，在将任何压缩数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="1454be0505ecbcd6144a8007fb6e1b0593fddf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the file will be opened in append mode. Otherwise the contents of the file, if any, will be truncated before any uncompressed data is written to it.</source>
          <target state="translated">如果启用了 &lt;code&gt;Append&lt;/code&gt; ，则文件将以追加模式打开。否则，在将任何未压缩的数据写入文件之前，文件的内容（如果有）将被截断。</target>
        </trans-unit>
        <trans-unit id="65081513c33900b0638266063d522dfa1dd85637" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件的末尾，以在向其写入任何压缩数据之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="26fb68f8b046494190d2e776943c032f469c5adb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件末尾，以在将任何未压缩的数据写入文件之前进行 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。否则，文件指针将不会移动。</target>
        </trans-unit>
        <trans-unit id="61760816f1c2f85d9599ced573f084a05cf816ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any compressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件末尾，以在将任何压缩数据写入到文件句柄之前进行 &lt;code&gt;seek&lt;/code&gt; 。否则，文件指针将不会被移动。</target>
        </trans-unit>
        <trans-unit id="3a4c77f4cfed963d8872c1a7f3de19f7c8bb526f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Append&lt;/code&gt; is enabled, the filehandle will be positioned to the end of the file via a call to &lt;code&gt;seek&lt;/code&gt; before any uncompressed data is written to it. Otherwise the file pointer will not be moved.</source>
          <target state="translated">如果启用了&amp;ldquo; &lt;code&gt;Append&lt;/code&gt; ，则将通过调用将文件句柄定位到文件的末尾，以在将任何未压缩的数据写入文件之前进行 &lt;code&gt;seek&lt;/code&gt; 。否则，文件指针将不会被移动。</target>
        </trans-unit>
        <trans-unit id="a8cc3d0792e66bfb9901cb16087529158d209e53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyinflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在所有 &lt;code&gt;anyinflate&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="6e70bd36d1a537ad13b970c5e3018a8db164c8ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;anyuncompress&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;anyuncompress&lt;/code&gt; ，将导致所有输入和/或输出文件句柄都被关闭。</target>
        </trans-unit>
        <trans-unit id="c9769aa738284afde961b2f9bd816825ddcd7550" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bunzip2&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在 &lt;code&gt;bunzip2&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="45ce2b192ba4b06ccb81a9f97e89861c03acbbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;bzip2&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦 &lt;code&gt;bzip2&lt;/code&gt; 完成，它将导致所有输入和/或输出文件句柄都被关闭。</target>
        </trans-unit>
        <trans-unit id="931b26269125b502ee9a79f1079ca4ffe0db45ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;deflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果 &lt;code&gt;AutoClose&lt;/code&gt; 被指定，并且该值是真实的，它将导致所有的输入和/或输出的文件句柄一次被关闭 &lt;code&gt;deflate&lt;/code&gt; 已完成。</target>
        </trans-unit>
        <trans-unit id="e1fd436eb74e99c1011e676ef2d33a7ca8f221d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gunzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;gunzip&lt;/code&gt; 完成后，将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="88e88b090b73765991b48faaa8220edbbe4df365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;gzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; 且值为true，则一旦 &lt;code&gt;gzip&lt;/code&gt; 完成，将导致所有输入和/或输出文件句柄被关闭。</target>
        </trans-unit>
        <trans-unit id="a90d9e6b94ea9918e75047142b2356a3ca3ce954" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;inflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;inflate&lt;/code&gt; ，将导致所有输入和/或输出文件句柄被关闭。</target>
        </trans-unit>
        <trans-unit id="8a6b1372a509b879eaf5e2572538481635eccd1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawdeflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;rawdeflate&lt;/code&gt; 完成后，将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="49cd128d450ba32be8b448e6b5ad08dbf2c6fedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;rawinflate&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则将在 &lt;code&gt;rawinflate&lt;/code&gt; 完成后关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="c0389ec2b7c0d6d8486da6034ee7b237f00728a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;unzip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则一旦完成 &lt;code&gt;unzip&lt;/code&gt; 将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="b28f338327748e0ed3d3b45714c8c08b6240edf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AutoClose&lt;/code&gt; is specified, and the value is true, it will result in all input and/or output filehandles being closed once &lt;code&gt;zip&lt;/code&gt; has completed.</source>
          <target state="translated">如果指定了 &lt;code&gt;AutoClose&lt;/code&gt; ，并且该值为true，则在 &lt;code&gt;zip&lt;/code&gt; 完成后将关闭所有输入和/或输出文件句柄。</target>
        </trans-unit>
        <trans-unit id="2f369078e4170f80457a1f35c7563da5a1cc6678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Blocking&lt;/code&gt; is set to 0, the connection will be in nonblocking mode. If not specified it defaults to 1 (blocking mode).</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Blocking&lt;/code&gt; 设置为0，则连接将处于非阻止模式。如果未指定，则默认为1（阻止模式）。</target>
        </trans-unit>
        <trans-unit id="bb88f5eab4e448f2a5e55013144cf7297d82804e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;DATA&lt;/code&gt; ,则结果将指示服务器希望发送数据。然后必须使用&lt;a href=&quot;Net::Cmd&quot;&gt;Net :: Cmd中&lt;/a&gt;描述的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送数据。</target>
        </trans-unit>
        <trans-unit id="27ca4e9e26da273f75ec2f01acbae00f6340bacd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DATA&lt;/code&gt; is not specified then the result will indicate that the server wishes the data to be sent. The data must then be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods described in &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;DATA&lt;/code&gt; ,则结果将指示服务器希望发送数据。然后必须使用&lt;a href=&quot;cmd&quot;&gt;Net :: Cmd中&lt;/a&gt;描述的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送数据。</target>
        </trans-unit>
        <trans-unit id="1b9556c0d7129263a154caaea9b76ae15222d837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Digest::MD5&lt;/code&gt; is not available, it return a string with only &lt;code&gt;0&lt;/code&gt;'s.</source>
          <target state="translated">如果 &lt;code&gt;Digest::MD5&lt;/code&gt; 不可用，则返回只有 &lt;code&gt;0&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="a2e077eab3d667c955449b8c582fa6b4685309db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExactAddresses&lt;/code&gt; is passed to the constructor, then addresses should be a valid rfc2821-quoted address, although Net::SMTP will accept the address surrounded by angle brackets.</source>
          <target state="translated">如果将 &lt;code&gt;ExactAddresses&lt;/code&gt; 传递给构造函数，则尽管Net :: SMTP会接受用尖括号括起来的地址，但地址应该是用有效的rfc2821引用的地址。</target>
        </trans-unit>
        <trans-unit id="3d6f9a7de111ad6f15c5cac01bf2df035fda0020" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FH&lt;/code&gt; is specified then it is expected to be a valid filehandle and the result will be printed to it, on success a true value will be returned. If &lt;code&gt;FH&lt;/code&gt; is not specified then the return value, on success, will be a reference to an array containing the article requested, each entry in the array will contain one line of the article.</source>
          <target state="translated">如果指定了 &lt;code&gt;FH&lt;/code&gt; ，则它将被认为是有效的文件句柄，并且结果将被打印到该文件句柄，成功后将返回一个真值。如果未指定 &lt;code&gt;FH&lt;/code&gt; ,则成功返回值将是对包含所请求文章的数组的引用，该数组中的每个条目都将包含该文章的一行。</target>
        </trans-unit>
        <trans-unit id="dcf85df21ad4f13a17a67e275700748df1fd4365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Features&lt;/code&gt; method reports a feature &lt;code&gt;attribs&lt;/code&gt; as present, the method &lt;code&gt;Attribs&lt;/code&gt; is not dummy.</source>
          <target state="translated">如果&amp;ldquo; &lt;code&gt;Features&lt;/code&gt; 方法报告存在的特征 &lt;code&gt;attribs&lt;/code&gt; ，则该方法 &lt;code&gt;Attribs&lt;/code&gt; 不是虚拟的。</target>
        </trans-unit>
        <trans-unit id="4e81c8aad04f59a1692e53f2e58534a0dee91bde" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt; , which inherited from &lt;code&gt;Thing&lt;/code&gt; , then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;File&lt;/code&gt; 继承自 &lt;code&gt;DataSource&lt;/code&gt; ，而DataSource继承自 &lt;code&gt;Thing&lt;/code&gt; ，则Perl将在必要时继续查找&amp;ldquo;上链&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="01422e251ecb63e2630d1526d1b2fd71e7e35b64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; inherited from &lt;code&gt;DataSource&lt;/code&gt;, which inherited from &lt;code&gt;Thing&lt;/code&gt;, then Perl would keep looking &quot;up the chain&quot; if necessary.</source>
          <target state="translated">如果 &lt;code&gt;File&lt;/code&gt; 是从 &lt;code&gt;DataSource&lt;/code&gt; 继承而来的，而FileSource是从 &lt;code&gt;Thing&lt;/code&gt; 继承而来的，那么Perl会在必要时继续查找&amp;ldquo;上链&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="871f80a19c627be0f52c1b6ef1cd6cbad1358e34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">如果为 &lt;code&gt;FileHandle::open&lt;/code&gt; 提供了数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 运算符。为了方便起见， &lt;code&gt;FileHandle::import&lt;/code&gt; 尝试从Fcntl模块导入O_XXX常量。如果动态加载不可用，这可能会失败，但是FileHandle的其余部分仍然可以使用。</target>
        </trans-unit>
        <trans-unit id="e5d4678ebb21520018d8a8ac8a3ed168c69d444f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. For convenience, &lt;code&gt;FileHandle::import&lt;/code&gt; tries to import the O_XXX constants from the Fcntl module. If dynamic loading is not available, this may fail, but the rest of FileHandle will still work.</source>
          <target state="translated">如果为 &lt;code&gt;FileHandle::open&lt;/code&gt; 提供了数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;sysopen&lt;/code&gt; 运算符。为了方便起见， &lt;code&gt;FileHandle::import&lt;/code&gt; 尝试从Fcntl模块导入O_XXX常量。如果动态加载不可用，这可能会失败，但是FileHandle的其余部分仍将起作用。</target>
        </trans-unit>
        <trans-unit id="bb1f139d098c0a906b0eeef1ef6e5dc6d9836cd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">如果 &lt;code&gt;FileHandle::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或POSIX fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则使用基本的Perl &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 操作员。</target>
        </trans-unit>
        <trans-unit id="f576810c104d4cab1572ebfd5a073a5c50992b01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileHandle::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or a POSIX fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="translated">如果 &lt;code&gt;FileHandle::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或POSIX fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则它使用基本的Perl &lt;code&gt;open&lt;/code&gt; 操作员。</target>
        </trans-unit>
        <trans-unit id="a2feaf81d0c85e64b59f8f9c85179dcb22ae1819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GLOB_NOSORT&lt;/code&gt; is not in effect, sort filenames is alphabetical order (case does not matter) rather than in ASCII order.</source>
          <target state="translated">如果 &lt;code&gt;GLOB_NOSORT&lt;/code&gt; 无效，则排序文件名按字母顺序（大小写无关）而不是ASCII顺序。</target>
        </trans-unit>
        <trans-unit id="67e8ee96965d8f4239b93f54928c2446de8f1552" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt; to indicate whether the compiler is version 1 or 2. This is used in setting some of the default cflags. It is set to '' if not gcc.</source>
          <target state="translated">如果使用 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量保存 &lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt; 以指示编译器是版本1还是2。这用于设置某些默认cflag。如果不是gcc，则设置为&amp;ldquo;&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ee184683f7c3453d93a7bedbc7d10e7e2d4b99bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable holds the operating system and version used to compile gcc. It is set to '' if not gcc, or if nothing useful can be parsed as the os version.</source>
          <target state="translated">如果使用 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量保存用于编译gcc的操作系统和版本。如果不是gcc，或者如果没有有用的东西可以解析为os版本，则将其设置为。</target>
        </trans-unit>
        <trans-unit id="c7c81dd0bd77cba1c688390cdf8b5eb031575d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GNU&lt;/code&gt; cc (gcc) is used, this variable will enable (if set) the -ansi and -pedantic ccflags for building core files (through cflags script). (See</source>
          <target state="translated">如果使用了 &lt;code&gt;GNU&lt;/code&gt; cc（gcc），则此变量将启用（如果设置）-ansi和-pedantic ccflags以构建核心文件（通过cflags脚本）。（看到</target>
        </trans-unit>
        <trans-unit id="0efd17fe9103ee1aaae0dc765c4fdcda7599e53f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">如果给 &lt;code&gt;IO::File::open&lt;/code&gt; 一个包括 &lt;code&gt;:&lt;/code&gt; 字符的模式，它将所有三个参数传递给三参数 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="d9d2307f492ec346285f4361272b678878cc377e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a mode that includes the &lt;code&gt;:&lt;/code&gt; character, it passes all the three arguments to the three-argument &lt;code&gt;open&lt;/code&gt; operator.</source>
          <target state="translated">如果给 &lt;code&gt;IO::File::open&lt;/code&gt; 一个包含 &lt;code&gt;:&lt;/code&gt; 字符的模式，它将所有三个参数传递给三参数 &lt;code&gt;open&lt;/code&gt; 运算符。</target>
        </trans-unit>
        <trans-unit id="6b022840a97cd5dd7f3b791be6eab1e939aa4189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">如果 &lt;code&gt;IO::File::open&lt;/code&gt; 被赋予数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 运算符。权限默认为0666。</target>
        </trans-unit>
        <trans-unit id="648473154f696c7584f730b90fd7267a915b5e74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; is given a numeric mode, it passes that mode and the optional permissions value to the Perl &lt;code&gt;sysopen&lt;/code&gt; operator. The permissions default to 0666.</source>
          <target state="translated">如果给 &lt;code&gt;IO::File::open&lt;/code&gt; 一个数字模式，它将把该模式和可选的权限值传递给Perl &lt;code&gt;sysopen&lt;/code&gt; 运算符。权限默认为0666。</target>
        </trans-unit>
        <trans-unit id="53e83efe8c19dc0d9571afae7a20a9dcda69bd25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">如果 &lt;code&gt;IO::File::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或ANSI C fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则使用基本的Perl &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 运算符（但保护任何特殊字符）。</target>
        </trans-unit>
        <trans-unit id="a2b31024d2546cbe74c22838b7e8daa31b3fb8b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IO::File::open&lt;/code&gt; receives a Perl mode string (&quot;&amp;gt;&quot;, &quot;+&amp;lt;&quot;, etc.) or an ANSI C fopen() mode string (&quot;w&quot;, &quot;r+&quot;, etc.), it uses the basic Perl &lt;code&gt;open&lt;/code&gt; operator (but protects any special characters).</source>
          <target state="translated">如果 &lt;code&gt;IO::File::open&lt;/code&gt; 接收到Perl模式字符串（&amp;ldquo;&amp;gt;&amp;rdquo;，&amp;ldquo; + &amp;lt;&amp;rdquo;等）或ANSI C fopen（）模式字符串（&amp;ldquo; w&amp;rdquo;，&amp;ldquo; r +&amp;rdquo;等），则使用基本的Perl &lt;code&gt;open&lt;/code&gt; 运算符（但保护任何特殊字符）。</target>
        </trans-unit>
        <trans-unit id="25244641705396e9c5a0c603f886177852688f85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; is omitted, the file list is obtained from the manifest. The file list may include shell wildcards which will be expanded out.</source>
          <target state="translated">如果省略要 &lt;code&gt;LIST OF FILES TO TEST&lt;/code&gt; 的文件列表，则从清单中获取文件列表。文件列表可能包含将扩展的外壳通配符。</target>
        </trans-unit>
        <trans-unit id="bc047fe00993cc36f1bde2a682c140574f3968b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; has been specified then XFL is set to 2. If &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; has been specified then XFL is set to 4. Otherwise XFL is set to 0.</source>
          <target state="translated">如果指定了 &lt;code&gt;Level =&amp;gt; Z_BEST_SPEED&lt;/code&gt; 则XFL设置为2。如果指定了 &lt;code&gt;Level =&amp;gt; Z_BEST_COMPRESSION&lt;/code&gt; 则XFL设置为4。否则，XFL设置为0。</target>
        </trans-unit>
        <trans-unit id="0aa2ad74e8011287eeea7635ab9b549166e0107b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LimitOutput&lt;/code&gt; is enabled, the &lt;code&gt;ConsumeInput&lt;/code&gt; option will also be enabled.</source>
          <target state="translated">如果启用 &lt;code&gt;LimitOutput&lt;/code&gt; ，则 &lt;code&gt;ConsumeInput&lt;/code&gt; 选项也将启用。</target>
        </trans-unit>
        <trans-unit id="6b5272a0252e677f68469c99e247e850a281513f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Listen&lt;/code&gt; is defined then a listen socket is created, else if the socket type, which is derived from the protocol, is SOCK_STREAM then connect() is called. If the &lt;code&gt;Listen&lt;/code&gt; argument is given, but false, the queue size will be set to 5.</source>
          <target state="translated">如果定义了 &lt;code&gt;Listen&lt;/code&gt; ,则创建一个监听套接字，否则，如果从协议派生的套接字类型为SOCK_STREAM，则调用connect（）。如果给出 &lt;code&gt;Listen&lt;/code&gt; 参数，但为false，则队列大小将设置为5。</target>
        </trans-unit>
        <trans-unit id="119d044a27ad244e9922efb2919b95739dfc6f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; is a reference to a list of two message numbers and the second number in a range is less than or equal to the first then the range represents all messages in the group after the first message number.</source>
          <target state="translated">如果 &lt;code&gt;MESSAGE-SPEC&lt;/code&gt; 是对两个消息编号列表的引用，并且范围中的第二个编号小于或等于第一个，则范围表示第一个消息编号之后的组中的所有消息。</target>
        </trans-unit>
        <trans-unit id="983c80c65b5dc12e5941f3ad256f42dbd5aa351d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;Net::Cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">如果未指定 &lt;code&gt;MESSAGE&lt;/code&gt; ,则必须使用&lt;a href=&quot;Net::Cmd&quot;&gt;Net :: Cmd&lt;/a&gt;的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送消息</target>
        </trans-unit>
        <trans-unit id="8fae31070991ff1f03f3487ee3feed2b35c28afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MESSAGE&lt;/code&gt; is not specified then the message must be sent using the &lt;code&gt;datasend&lt;/code&gt; and &lt;code&gt;dataend&lt;/code&gt; methods from &lt;a href=&quot;cmd&quot;&gt;Net::Cmd&lt;/a&gt;</source>
          <target state="translated">如果未指定 &lt;code&gt;MESSAGE&lt;/code&gt; ,则必须使用&lt;a href=&quot;cmd&quot;&gt;Net :: Cmd&lt;/a&gt;的 &lt;code&gt;datasend&lt;/code&gt; 和 &lt;code&gt;dataend&lt;/code&gt; 方法发送消息</target>
        </trans-unit>
        <trans-unit id="b4f8b5e83cced9672fcf844844603c4b1519fbeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NEXT&lt;/code&gt; redispatching is used in the methods of a &quot;diamond&quot; class hierarchy:</source>
          <target state="translated">如果在&amp;ldquo;钻石&amp;rdquo;类层次结构的方法中使用了 &lt;code&gt;NEXT&lt;/code&gt; 重新分配：</target>
        </trans-unit>
        <trans-unit id="fa6cc1f17445fc581970662d0c27067922cd4606" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is a filename, the value of &lt;code&gt;$input&lt;/code&gt; will be used for the zip filename header field.</source>
          <target state="translated">如果未指定 &lt;code&gt;Name&lt;/code&gt; 且 &lt;code&gt;$input&lt;/code&gt; 参数为文件名，则 &lt;code&gt;$input&lt;/code&gt; 的值将用于zip文件名头字段。</target>
        </trans-unit>
        <trans-unit id="16fa552eaed310969186dcb3a6fc9c674d262d84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not specified and the &lt;code&gt;$input&lt;/code&gt; parameter is not a filename, no zip filename field will be created.</source>
          <target state="translated">如果未指定 &lt;code&gt;Name&lt;/code&gt; 且 &lt;code&gt;$input&lt;/code&gt; 参数不是文件名，则不会创建zip文件名字段。</target>
        </trans-unit>
        <trans-unit id="90ec1912df6897d3b8157fa885ee828e31fcb30c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_DENY&lt;/code&gt; is set, the module is loaded as if with &lt;code&gt;no&lt;/code&gt; rather than &lt;code&gt;use&lt;/code&gt;.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_LOADMOD_DENY&lt;/code&gt; ，则将模块加载为 &lt;code&gt;no&lt;/code&gt; 而不是 &lt;code&gt;use&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0d9c7a2c762fe5aa671ca88a1e57aa13b9aa7f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; is set, the module is loaded as if with an empty import list, as in &lt;code&gt;use Foo::Bar ()&lt;/code&gt;; this is the only circumstance in which the trailing optional arguments may be omitted entirely. Otherwise, if &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing arguments must consist of exactly one &lt;code&gt;OP*&lt;/code&gt;, containing the op tree that produces the relevant import arguments. Otherwise, the trailing arguments must all be &lt;code&gt;SV*&lt;/code&gt; values that will be used as import arguments; and the list must be terminated with &lt;code&gt;(SV*) NULL&lt;/code&gt;. If neither &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; nor &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; is set, the trailing &lt;code&gt;NULL&lt;/code&gt; pointer is needed even if no import arguments are desired. The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; argument is decremented. In addition, the &lt;code&gt;name&lt;/code&gt; argument is modified.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; ，则使用空的导入列表加载模块，如 &lt;code&gt;use Foo::Bar ()&lt;/code&gt; ;这是唯一可以完全省略尾随可选参数的情况。否则，如果设置了 &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; ，则尾随参数必须正好由一个 &lt;code&gt;OP*&lt;/code&gt; ，其中包含产生相关导入参数的op树。否则，尾随参数必须全部为将用作导入参数的 &lt;code&gt;SV*&lt;/code&gt; 值。并且列表必须以 &lt;code&gt;(SV*) NULL&lt;/code&gt; 终止。如果未设置 &lt;code&gt;PERL_LOADMOD_NOIMPORT&lt;/code&gt; 和 &lt;code&gt;PERL_LOADMOD_IMPORT_OPS&lt;/code&gt; ，则尾随 &lt;code&gt;NULL&lt;/code&gt; 即使不需要导入参数，也需要使用指针。每个指定的 &lt;code&gt;SV*&lt;/code&gt; 参数的引用计数都会减少。另外，对 &lt;code&gt;name&lt;/code&gt; 参数进行了修改。</target>
        </trans-unit>
        <trans-unit id="7150b29ccf2318861af577a7533fe5cd202a009c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_ALL&lt;/code&gt; is set then all input chars will be output using &lt;code&gt;\x01F1&lt;/code&gt; style escapes, otherwise if &lt;code&gt;PERL_PV_ESCAPE_NONASCII&lt;/code&gt; is set, only non-ASCII chars will be escaped using this style; otherwise, only chars above 255 will be so escaped; other non printable chars will use octal or common escaped patterns like &lt;code&gt;\n&lt;/code&gt;. Otherwise, if &lt;code&gt;PERL_PV_ESCAPE_NOBACKSLASH&lt;/code&gt; then all chars below 255 will be treated as printable and will be output as literals.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_ESCAPE_ALL&lt;/code&gt; ，则将使用 &lt;code&gt;\x01F1&lt;/code&gt; 样式转义符输出所有输入的字符，否则，如果设置了 &lt;code&gt;PERL_PV_ESCAPE_NONASCII&lt;/code&gt; ，将仅使用此样式转义非ASCII字符；否则，将使用\ x01F1样式转义。否则，只有255以上的字符会被转义；其他不可打印的字符将使用八进制或常见的转义模式，例如 &lt;code&gt;\n&lt;/code&gt; 。否则，如果 &lt;code&gt;PERL_PV_ESCAPE_NOBACKSLASH&lt;/code&gt; ,则所有低于255的字符都将被视为可打印字符，并将其输出为文字。</target>
        </trans-unit>
        <trans-unit id="fd6e934e5c2d97914014a2305fe6d83cca0f7a87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_FIRSTCHAR&lt;/code&gt; is set then only the first char of the string will be escaped, regardless of max. If the output is to be in hex, then it will be returned as a plain hex sequence. Thus the output will either be a single char, an octal escape sequence, a special escape like &lt;code&gt;\n&lt;/code&gt; or a hex value.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_ESCAPE_FIRSTCHAR&lt;/code&gt; ，则无论最大长度如何，仅将字符串的第一个字符转义。如果输出为十六进制，则将其作为普通十六进制序列返回。因此，输出将是单个字符，八进制转义序列，特殊转义（如 &lt;code&gt;\n&lt;/code&gt; 或十六进制值）。</target>
        </trans-unit>
        <trans-unit id="4556bf449af07632214df812c6e299c60c88a77e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_RE&lt;/code&gt; is set then the escape char used will be a &lt;code&gt;&quot;%&quot;&lt;/code&gt; and not a &lt;code&gt;&quot;\\&quot;&lt;/code&gt;. This is because regexes very often contain backslashed sequences, whereas &lt;code&gt;&quot;%&quot;&lt;/code&gt; is not a particularly common character in patterns.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_ESCAPE_RE&lt;/code&gt; ，则使用的转义字符将是 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 而不是 &lt;code&gt;&quot;\\&quot;&lt;/code&gt; 。这是因为正则表达式通常包含反斜杠序列，而 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 在模式中并不是特别常见的字符。</target>
        </trans-unit>
        <trans-unit id="3b287252fa0fadb9f209dd7e1ddcb194eaed64b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_PV_ESCAPE_UNI&lt;/code&gt; is set then the input string is treated as UTF-8 if &lt;code&gt;PERL_PV_ESCAPE_UNI_DETECT&lt;/code&gt; is set then the input string is scanned using &lt;code&gt;is_utf8_string()&lt;/code&gt; to determine if it is UTF-8.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_PV_ESCAPE_UNI&lt;/code&gt; ，则将输入字符串视为UTF-8；如果设置了 &lt;code&gt;PERL_PV_ESCAPE_UNI_DETECT&lt;/code&gt; ，则将使用 &lt;code&gt;is_utf8_string()&lt;/code&gt; 扫描输入字符串，以确定其是否为UTF-8。</target>
        </trans-unit>
        <trans-unit id="35533bcb02c546225ef493f044a6f536db7a71c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in</source>
          <target state="translated">如果在 &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; 位置设置了PERL_SCAN_ALLOW_UNDERSCORES</target>
        </trans-unit>
        <trans-unit id="927d1c982e9f33464297a28a964aa06b97d23586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt; then any or all pairs of digits may be separated from each other by a single underscore; also a single leading underscore is accepted.</source>
          <target state="translated">如果在 &lt;code&gt;*flags&lt;/code&gt; 中设置了 &lt;code&gt;PERL_SCAN_ALLOW_UNDERSCORES&lt;/code&gt; ，则任何或所有对数字都可以用单个下划线分隔；也接受单个下划线。</target>
        </trans-unit>
        <trans-unit id="52cb6eab9df9b80f7b8043595e084ea362a195f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt; . If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl
-MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; . If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 环境变量，它将用作比较意外多行结果的命令。如果安装了GNU diff，则可能需要将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;diff -u&lt;/code&gt; 。如果没有合适的程序，则可以安装 &lt;code&gt;Text::Diff&lt;/code&gt; 模块，然后将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; 。如果未设置 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; ,但是 &lt;code&gt;Algorithm::Diff&lt;/code&gt; 模块可用，那么它将用于显示多行结果中的差异。</target>
        </trans-unit>
        <trans-unit id="4e08ae53639fc6920187fdd8042110e8e1996f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; environment variable is set, it will be used as a command for comparing unexpected multiline results. If you have GNU diff installed, you might want to set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to &lt;code&gt;diff -u&lt;/code&gt;. If you don't have a suitable program, you might install the &lt;code&gt;Text::Diff&lt;/code&gt; module and then set &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; to be &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt;. If &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; isn't set but the &lt;code&gt;Algorithm::Diff&lt;/code&gt; module is available, then it will be used to show the differences in multiline results.</source>
          <target state="translated">如果设置了 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 环境变量，它将用作比较意外多行结果的命令。如果安装了GNU diff，则可能需要将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;diff -u&lt;/code&gt; 。如果没有合适的程序，则可以安装 &lt;code&gt;Text::Diff&lt;/code&gt; 模块，然后将 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; 设置为 &lt;code&gt;perl -MText::Diff -e 'print diff(@ARGV)'&lt;/code&gt; 。如果未设置 &lt;code&gt;PERL_TEST_DIFF&lt;/code&gt; ,但是 &lt;code&gt;Algorithm::Diff&lt;/code&gt; 模块可用，那么它将用于显示多行结果中的差异。</target>
        </trans-unit>
        <trans-unit id="8fb3ad782aee3a8db708fe40cb7ddcd44325815d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PadnameOUTER&lt;/code&gt; is set on the pad name, then that slot in the frame AV is a REFCNT'ed reference to a lexical from &quot;outside&quot;. Such entries are sometimes referred to as 'fake'. In this case, the name does not use 'low' and 'high' to store a cop_seq range, since it is in scope throughout. Instead 'high' stores some flags containing info about the real lexical (is it declared in an anon, and is it capable of being instantiated multiple times?), and for fake ANONs, 'low' contains the index within the parent's pad where the lexical's value is stored, to make cloning quicker.</source>
          <target state="translated">如果在 &lt;code&gt;PadnameOUTER&lt;/code&gt; 垫名称上设置了PadnameOUTER，则帧AV中的该插槽是从&amp;ldquo;外部&amp;rdquo;对词法的REFCNT引用。此类条目有时称为&amp;ldquo;伪造&amp;rdquo;。在这种情况下，该名称不使用&amp;ldquo;低&amp;rdquo;和&amp;ldquo;高&amp;rdquo;来存储cop_seq范围，因为它在整个范围内。取而代之的是，&amp;ldquo;高&amp;rdquo;存储一些标志，这些标志包含有关真实词法的信息（它是在一个匿名声明中声明的，并且能够被多次实例化吗？），对于伪造的ANON，&amp;ldquo;低&amp;rdquo;则将其包含在父级填充中的索引存储词法的值，以使克隆更快。</target>
        </trans-unit>
        <trans-unit id="dee3b30e6a54d64d92736caa387fa1fa00014452" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PerlIO_push&lt;/code&gt; was performed and open has failed, it must &lt;code&gt;PerlIO_pop&lt;/code&gt; itself, since if it's not, the layer won't be removed and may cause bad problems.</source>
          <target state="translated">如果执行了 &lt;code&gt;PerlIO_push&lt;/code&gt; 并且打开失败，则它必须是 &lt;code&gt;PerlIO_pop&lt;/code&gt; 本身，因为如果没有，则不会删除该层，并且可能会导致严重问题。</target>
        </trans-unit>
        <trans-unit id="e92add0536c750719a7004e9b389b82f89f36216" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Proto&lt;/code&gt; is not given and you specify a symbolic &lt;code&gt;PeerPort&lt;/code&gt; port, then the constructor will try to derive &lt;code&gt;Proto&lt;/code&gt; from the service name. As a last resort &lt;code&gt;Proto&lt;/code&gt; &quot;tcp&quot; is assumed. The &lt;code&gt;Type&lt;/code&gt; parameter will be deduced from &lt;code&gt;Proto&lt;/code&gt; if not specified.</source>
          <target state="translated">如果未提供 &lt;code&gt;Proto&lt;/code&gt; 并指定了符号 &lt;code&gt;PeerPort&lt;/code&gt; 端口，则构造函数将尝试从服务名称派生 &lt;code&gt;Proto&lt;/code&gt; 。作为最后的手段，假定 &lt;code&gt;Proto&lt;/code&gt; &amp;ldquo; tcp&amp;rdquo;。该 &lt;code&gt;Type&lt;/code&gt; 参数将被推断 &lt;code&gt;Proto&lt;/code&gt; 如果没有指定。</target>
        </trans-unit>
        <trans-unit id="fe5b8d2d2cf1b0bc68bdf3e0b890723eb0712304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SkipBad&lt;/code&gt; is true the &lt;code&gt;recipient&lt;/code&gt; will not return an error when a bad address is encountered and it will return an array of addresses that did succeed.</source>
          <target state="translated">如果 &lt;code&gt;SkipBad&lt;/code&gt; 为true，则 &lt;code&gt;recipient&lt;/code&gt; 在遇到错误的地址时将不会返回错误，并且将返回成功的地址数组。</target>
        </trans-unit>
        <trans-unit id="d0468225999e79fdda0c8dc21ac9ecaa76acd0e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Strict&lt;/code&gt; is enabled the following behaviour will be policed:</source>
          <target state="translated">如果启用&amp;ldquo; &lt;code&gt;Strict&lt;/code&gt; 将警告以下行为：</target>
        </trans-unit>
        <trans-unit id="b96d3e92a2737a01f8355b6b1112adb835436235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;TIMEOUT&lt;/code&gt; 丢失， &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或小于或等于0，则此调用的行为与 &lt;code&gt;dequeue_nb&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="c530cec74f6e8b7055d3fa3d9efe868ec89d0a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TIMEOUT&lt;/code&gt; is missing, &lt;code&gt;undef&lt;/code&gt;, or less than or equal to 0, then this call behaves the same as &lt;code&gt;dequeue_nb&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;TIMEOUT&lt;/code&gt; 丢失， &lt;code&gt;undef&lt;/code&gt; 或小于或等于0，则此调用的行为与 &lt;code&gt;dequeue_nb&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b3dbb2f4f8d2f84122800f9964093173fd31ae6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt; 's memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt; , the entire file will be rewritten in a single pass.</source>
          <target state="translated">如果 &lt;code&gt;Tie::File&lt;/code&gt; 的内存限制足够大，则所有写入将在内存中完成。然后，当您调用 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 时，整个文件将被一次重写。</target>
        </trans-unit>
        <trans-unit id="86295dc1bf1fa74a00cc2da2e3439e42c182b9ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Tie::File&lt;/code&gt;'s memory limit is large enough, all the writing will done in memory. Then, when you call &lt;code&gt;-&amp;gt;flush&lt;/code&gt;, the entire file will be rewritten in a single pass.</source>
          <target state="translated">如果 &lt;code&gt;Tie::File&lt;/code&gt; 的内存限制足够大，则所有写入将在内存中完成。然后，当您调用 &lt;code&gt;-&amp;gt;flush&lt;/code&gt; 时，整个文件将被一次重写。</target>
        </trans-unit>
        <trans-unit id="717bb6fc0375ed7c5d36f69b6a41d7203067aa19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is 26 or later, the &lt;code&gt;identical&lt;/code&gt; level is preferred; &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; and &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt;&lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; should be used.</source>
          <target state="translated">如果 &lt;code&gt;UCA_Version&lt;/code&gt; 为26或更高版本，则首选 &lt;code&gt;identical&lt;/code&gt; 级别；否则，默认为0 。 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1)&lt;/code&gt; 和 &lt;code&gt;Unicode::Collate-&amp;gt;new(identical =&amp;gt; 1,&lt;/code&gt; &lt;code&gt;variable =&amp;gt; &quot;non-ignorable&quot;, level =&amp;gt; 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02434c0e062f79bd3d8c8ef802e8385afcfb68a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UCA_Version&lt;/code&gt; is equal to or greater than 14, default is &lt;code&gt;[]&lt;/code&gt; (i.e. no rearrangement).</source>
          <target state="translated">如果 &lt;code&gt;UCA_Version&lt;/code&gt; 等于或大于14，则默认值为 &lt;code&gt;[]&lt;/code&gt; （即不重新排列）。</target>
        </trans-unit>
        <trans-unit id="b309f1cb237c3cb1331fc5e7c80d1a3dc5b1ba82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,则调试级别将设置为该类的默认调试级别。</target>
        </trans-unit>
        <trans-unit id="4e940cabf3eff6f96ef019a41252378fda2e834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;VALUE&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; then the debug level will be set to the default debug level for the class.</source>
          <target state="translated">如果 &lt;code&gt;VALUE&lt;/code&gt; 为 &lt;code&gt;undef&lt;/code&gt; ,则调试级别将设置为该类的默认调试级别。</target>
        </trans-unit>
        <trans-unit id="44072f8a4414482a73ce8e1b198996a838545678" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WHERE&lt;/code&gt; is given then the first &lt;code&gt;WHERE&lt;/code&gt; bytes of the file will not be transferred, and the remaining bytes will be appended to the local file if it already exists.</source>
          <target state="translated">如果 &lt;code&gt;WHERE&lt;/code&gt; 给出那么第一个 &lt;code&gt;WHERE&lt;/code&gt; 文件的字节将不得转让，如果它已经存在剩余字节将被追加到本地文件。</target>
        </trans-unit>
        <trans-unit id="ac99e0f8353a2cf6b3d40ee09fd4abe5de979195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;allow_tags&lt;/code&gt; is enabled, &lt;code&gt;JSON::PP&lt;/code&gt; will look up the &lt;code&gt;THAW&lt;/code&gt; method of the package/classname used during serialisation (it will not attempt to load the package as a Perl module). If there is no such method, the decoding will fail with an error.</source>
          <target state="translated">如果启用 &lt;code&gt;allow_tags&lt;/code&gt; ，则 &lt;code&gt;JSON::PP&lt;/code&gt; 将查找序列化过程中使用的包/类名的 &lt;code&gt;THAW&lt;/code&gt; 方法（它不会尝试将包作为Perl模块加载）。如果没有这样的方法，解码将失败并显示错误。</target>
        </trans-unit>
        <trans-unit id="3cdf8e9a5929ab26a43f519805188b99c5f0b522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;appendOutput&lt;/code&gt; 在构造函数bunzip2命令对象启用，未压缩数据将被追加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则将 &lt;code&gt;$output&lt;/code&gt; 截断，然后再将未压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="667286e52e2e632a32355f2300da667dd6bd7a78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the uncompressed data is written to it.</source>
          <target state="translated">如果 &lt;code&gt;appendOutput&lt;/code&gt; 在构造函数bunzip2命令对象启用，未压缩数据将被追加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则将 &lt;code&gt;$output&lt;/code&gt; 截断，然后再将未压缩的数据写入其中。</target>
        </trans-unit>
        <trans-unit id="f450b4455b8d11ffbd473a1bb2010cafedaed33e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt; . If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">如果在bzip2对象的构造函数中启用了 &lt;code&gt;appendOutput&lt;/code&gt; ，则压缩后的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则在将压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="096baeccf53db357601ffc253c8281b1e48c8ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;appendOutput&lt;/code&gt; is enabled in the constructor for the bzip2 object, the compressed data will be appended to &lt;code&gt;$output&lt;/code&gt;. If not enabled, &lt;code&gt;$output&lt;/code&gt; will be truncated before the compressed data is written to it.</source>
          <target state="translated">如果在bzip2对象的构造函数中启用了 &lt;code&gt;appendOutput&lt;/code&gt; ，则压缩后的数据将附加到 &lt;code&gt;$output&lt;/code&gt; 。如果未启用，则在将压缩数据写入 &lt;code&gt;$output&lt;/code&gt; 之前将其截断。</target>
        </trans-unit>
        <trans-unit id="1432fae77d6dafc174cc09ef9602a6c9c5caf4ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;block&lt;/code&gt; is null then the subroutine will have no body, and for the time being it will be an error to call it. This represents a forward subroutine declaration such as &lt;code&gt;sub foo ($$);&lt;/code&gt;. If &lt;code&gt;block&lt;/code&gt; is non-null then it provides the Perl code of the subroutine body, which will be executed when the subroutine is called. This body includes any argument unwrapping code resulting from a subroutine signature or similar. The pad use of the code must correspond to the pad attached to &lt;code&gt;PL_compcv&lt;/code&gt;. The code is not expected to include a &lt;code&gt;leavesub&lt;/code&gt; or &lt;code&gt;leavesublv&lt;/code&gt; op; this function will add such an op. &lt;code&gt;block&lt;/code&gt; is consumed by this function and will become part of the constructed subroutine.</source>
          <target state="translated">如果 &lt;code&gt;block&lt;/code&gt; 为null，则子例程将没有主体，并且暂时将其调用是错误的。这表示前向子例程声明，例如 &lt;code&gt;sub foo ($$);&lt;/code&gt; 。如果 &lt;code&gt;block&lt;/code&gt; 为非null，则它将提供子例程主体的Perl代码，该代码将在调用子例程时执行。该主体包括由子例程签名或类似结果产生的任何参数解包代码。该代码的填充使用必须与 &lt;code&gt;PL_compcv&lt;/code&gt; 附带的填充相对应。该代码不应包含 &lt;code&gt;leavesub&lt;/code&gt; 或 &lt;code&gt;leavesublv&lt;/code&gt; op。此功能将添加这样的操作。 &lt;code&gt;block&lt;/code&gt; 由该函数使用，并将成为构造的子例程的一部分。</target>
        </trans-unit>
        <trans-unit id="1b199e24b4ee7d3c552a01dcb6637c8cc3a9e1f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bundling_override&lt;/code&gt; is enabled, bundling is enabled as with &lt;code&gt;bundling&lt;/code&gt; but now long option names override option bundles.</source>
          <target state="translated">如果 &lt;code&gt;bundling_override&lt;/code&gt; 启用，捆绑与激活 &lt;code&gt;bundling&lt;/code&gt; ，但现在长选项名称覆盖选项包。</target>
        </trans-unit>
        <trans-unit id="54b90baea8c11dc735bd2168186bca9ee27f1a9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;caller()&lt;/code&gt; winds up off the top of the stack it report the highest context.</source>
          <target state="translated">如果 &lt;code&gt;caller()&lt;/code&gt; 从堆栈顶部结束，则会报告最高上下文。</target>
        </trans-unit>
        <trans-unit id="e3dc97ff755fb934bfd6f1a8ed830ff62cc4e40b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;consumeInput&lt;/code&gt; is enabled in the constructor for the bunzip2 object, &lt;code&gt;$input&lt;/code&gt; will have all compressed data removed from it after uncompression. On &lt;code&gt;BZ_OK&lt;/code&gt; return this will mean that &lt;code&gt;$input&lt;/code&gt; will be an empty string; when &lt;code&gt;BZ_STREAM_END&lt;/code&gt;&lt;code&gt;$input&lt;/code&gt; will either be an empty string or will contain whatever data immediately followed the compressed data stream.</source>
          <target state="translated">如果 &lt;code&gt;consumeInput&lt;/code&gt; 在构造函数bunzip2命令对象启用， &lt;code&gt;$input&lt;/code&gt; 将解压缩之后，从它删除了所有的压缩数据。在 &lt;code&gt;BZ_OK&lt;/code&gt; 返回上，这意味着 &lt;code&gt;$input&lt;/code&gt; 将是一个空字符串；当 &lt;code&gt;BZ_STREAM_END&lt;/code&gt; &lt;code&gt;$input&lt;/code&gt; 将为空字符串或包含紧随压缩数据流之后的任何数据。</target>
        </trans-unit>
        <trans-unit id="13672333fc5b967feaa626b683b8bcc04e6c7332" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;cv&lt;/code&gt; 是可以进行内联的常数子，则返回该子返回的常数值。否则，返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1dd05ec9d332008df8a7389201274fce30d7a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cv&lt;/code&gt; is a constant sub eligible for inlining, returns the constant value returned by the sub. Otherwise, returns NULL.</source>
          <target state="translated">如果 &lt;code&gt;cv&lt;/code&gt; 是可以进行内联的常数子，则返回该子返回的常数值。否则，返回NULL。</target>
        </trans-unit>
        <trans-unit id="ede33bdf6d08f63d2072630b001c1c1d527bfdbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; is given, this device is used to bind the source endpoint before sending the ping packet. I believe this only works with superuser privileges and with udp and icmp protocols at this time.</source>
          <target state="translated">如果指定了 &lt;code&gt;device&lt;/code&gt; ，则此设备用于在发送ping数据包之前绑定源端点。我相信目前这仅适用于超级用户特权以及udp和icmp协议。</target>
        </trans-unit>
        <trans-unit id="d37d86734f002378b0c0f7d856f9af361e68cbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;done_testing()&lt;/code&gt; is called twice, the second call will issue a failing test.</source>
          <target state="translated">如果两次调用 &lt;code&gt;done_testing()&lt;/code&gt; ，则第二次调用将发出失败的测试。</target>
        </trans-unit>
        <trans-unit id="a074a15a27ab0ac63397d85c19569d7f123797eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; .</source>
          <target state="translated">如果 &lt;code&gt;down()&lt;/code&gt; 尝试将计数器减小到零以下，它将阻塞直到计数器足够大。请注意，虽然可以从零开始计数创建信号量，但是任何 &lt;code&gt;up()&lt;/code&gt; 或 &lt;code&gt;down()&lt;/code&gt; 始终会将计数器更改至少一个，因此 &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; 与 &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; 相同down（1）。</target>
        </trans-unit>
        <trans-unit id="dc095b856cd7bbcf568ac5723a3a668cbf72bdda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;down()&lt;/code&gt; attempts to decrement the counter below zero, it blocks until the counter is large enough. Note that while a semaphore can be created with a starting count of zero, any &lt;code&gt;up()&lt;/code&gt; or &lt;code&gt;down()&lt;/code&gt; always changes the counter by at least one, and so &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; is the same as &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;down()&lt;/code&gt; 尝试将计数器递减到零以下，它将阻塞直到计数器足够大。请注意，虽然可以从零开始计数创建信号量，但是任何 &lt;code&gt;up()&lt;/code&gt; 或 &lt;code&gt;down()&lt;/code&gt; 始终会将计数器更改至少一个，因此 &lt;code&gt;$semaphore-&amp;gt;down(0)&lt;/code&gt; 与 &lt;code&gt;$semaphore-&amp;gt;down(1)&lt;/code&gt; 相同down（1）。</target>
        </trans-unit>
        <trans-unit id="bd2ee9c9e231a07f99e855dc49bb00a01e62f7c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e &amp;lt; s&lt;/code&gt; or if the scan would end up past &lt;code&gt;e&lt;/code&gt;, it raises a UTF8 warning and returns the number of valid characters.</source>
          <target state="translated">如果 &lt;code&gt;e &amp;lt; s&lt;/code&gt; 或扫描结束于 &lt;code&gt;e&lt;/code&gt; ，它将发出UTF8警告并返回有效字符数。</target>
        </trans-unit>
        <trans-unit id="b73e1156e34709c2cf87a897c0dfdd15558afa70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit()&lt;/code&gt; really is needed, then consider using the following:</source>
          <target state="translated">如果确实需要 &lt;code&gt;exit()&lt;/code&gt; ，请考虑使用以下命令：</target>
        </trans-unit>
        <trans-unit id="40ba804a2596516d0c1570f7f282c973ab9c2345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extract&lt;/code&gt; is called without a list of file names, the entire contents of the archive are extracted.</source>
          <target state="translated">如果在没有文件名列表的情况下调用了 &lt;code&gt;extract&lt;/code&gt; ，则将提取存档的全部内容。</target>
        </trans-unit>
        <trans-unit id="fd1942906fddd7c45d5614b21cfa194ab92d3708" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fallback&lt;/code&gt; is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</source>
          <target state="translated">如果两个操作数的 &lt;code&gt;fallback&lt;/code&gt; 均为TRUE，则对操作符执行通常的操作，将操作数视作适合操作符的数字，字符串或布尔值（请参见注释）。</target>
        </trans-unit>
        <trans-unit id="77c9ad5fa8afacb61183204af87e0582ca853195" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags &amp;amp; SV_SMAGIC&lt;/code&gt; is true, will call &lt;code&gt;SvSETMAGIC&lt;/code&gt;. If &lt;code&gt;flags &amp;amp; SV_HAS_TRAILING_NUL&lt;/code&gt; is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt;, and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt;, and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;flags &amp;amp; SV_SMAGIC&lt;/code&gt; 为true，则将调用 &lt;code&gt;SvSETMAGIC&lt;/code&gt; 。如果 &lt;code&gt;flags &amp;amp; SV_HAS_TRAILING_NUL&lt;/code&gt; 为true，则 &lt;code&gt;ptr[len]&lt;/code&gt; 必须为 &lt;code&gt;NUL&lt;/code&gt; ，并且将跳过重新分配（即，缓冲区实际上比 &lt;code&gt;len&lt;/code&gt; 长至少1个字节，并且已经满足存储在 &lt;code&gt;SvPVX&lt;/code&gt; 中的要求）。</target>
        </trans-unit>
        <trans-unit id="5fd52e0f8326669fc207b7050c548b0008ac0b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_SMAGIC is true, will call SvSETMAGIC. If &lt;code&gt;flags&lt;/code&gt; &amp;amp; SV_HAS_TRAILING_NUL is true, then &lt;code&gt;ptr[len]&lt;/code&gt; must be &lt;code&gt;NUL&lt;/code&gt; , and the realloc will be skipped (i.e. the buffer is actually at least 1 byte longer than &lt;code&gt;len&lt;/code&gt; , and already meets the requirements for storing in &lt;code&gt;SvPVX&lt;/code&gt; ).</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; ＆SV_SMAGIC为true，则将调用SvSETMAGIC。如果 &lt;code&gt;flags&lt;/code&gt; ＆SV_HAS_TRAILING_NUL为true，则 &lt;code&gt;ptr[len]&lt;/code&gt; 必须为 &lt;code&gt;NUL&lt;/code&gt; ，并且将跳过重新分配（即，缓冲区实际上比 &lt;code&gt;len&lt;/code&gt; 长至少1个字节，并且已经满足存储在 &lt;code&gt;SvPVX&lt;/code&gt; 中的要求）。</target>
        </trans-unit>
        <trans-unit id="0edc0d40cf1bae07e3194b59cda754464ac0af29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not include the &lt;code&gt;G_DISCARD&lt;/code&gt; flag then &lt;code&gt;hv_delete&lt;/code&gt; will create and return a mortal copy of the deleted value.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 不包括 &lt;code&gt;G_DISCARD&lt;/code&gt; 标志，则 &lt;code&gt;hv_delete&lt;/code&gt; 将创建并返回已删除值的最终副本。</target>
        </trans-unit>
        <trans-unit id="10df1aa8bd4f0824119d6cef9b8d19de3f0f48a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has SV_FORCE_UTF8_UPGRADE set, this function assumes that the PV will expand when converted to UTF-8, and skips the extra work of checking for that. Typically this flag is used by a routine that has already parsed the string and found such characters, and passes this information on so that the work doesn't have to be repeated.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 设置了SV_FORCE_UTF8_UPGRADE，则此函数假定PV转换为UTF-8时将展开，并跳过检查该标志的额外工作。通常，该标志由已解析字符串并找到此类字符的例程使用，并将此信息传递给该例程，因此不必重复工作。</target>
        </trans-unit>
        <trans-unit id="ad87c09509d32a63c00d8007a6c9913223d72fda" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;CV_NAME_NOTQUAL&lt;/code&gt; bit set, then the package name will not be included. If the first argument is neither a CV nor a GV, this flag is ignored (subject to change).</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 的 &lt;code&gt;CV_NAME_NOTQUAL&lt;/code&gt; 位置1，则不包含程序包名称。如果第一个参数既不是CV也不是GV，则将忽略此标志（可能会更改）。</target>
        </trans-unit>
        <trans-unit id="37b250f1c8aff9dcda9cab5ceb3c6ef02e048bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;SV_SMAGIC&lt;/code&gt; bit set, will &lt;code&gt;mg_set&lt;/code&gt; on &lt;code&gt;dsv&lt;/code&gt; afterwards if appropriate. &lt;code&gt;sv_catpvn&lt;/code&gt; and &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; are implemented in terms of this function.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 将 &lt;code&gt;SV_SMAGIC&lt;/code&gt; 位置1， &lt;code&gt;mg_set&lt;/code&gt; 在 &lt;code&gt;dsv&lt;/code&gt; 上进行mg_set（如果适用）。 &lt;code&gt;sv_catpvn&lt;/code&gt; 和 &lt;code&gt;sv_catpvn_nomg&lt;/code&gt; 是根据此功能实现的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
