<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b3c1ad83c7446d82ad768f4c14cbc6cf2bb28a0e" translate="yes" xml:space="preserve">
          <source>Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect. A sound principle is to use only ranges that begin from and end at either alphabets of equal case (a-e, A-E), or digits (0-4). Anything else is unsafe. If in doubt, spell out the character sets in full.</source>
          <target state="translated">还要注意的是,整个范围的概念在字符集之间是相当不可靠的--甚至在字符集内也可能会造成你可能没有想到的结果。一个合理的原则是只使用从字母开始和结束的范围,这些范围要么是大小写相同的字母(a-e,A-E),要么是数字(0-4)。其他的都是不安全的。如果有疑问,请完整地拼出字符集。</target>
        </trans-unit>
        <trans-unit id="e91fc700eef8c024136a19a3d1a25e4a4aec8312" translate="yes" xml:space="preserve">
          <source>Note also that there are some basic rules to using &quot;=over&quot; ... &quot;=back&quot; regions:</source>
          <target state="translated">还要注意的是,使用&quot;=over &quot;有一些基本规则......。&quot;=回 &quot;区域。</target>
        </trans-unit>
        <trans-unit id="f240a6fbb992211509f6bddbfc9324c218ab462f" translate="yes" xml:space="preserve">
          <source>Note also that this is a minimum setup; you might want to add other packages of &lt;b&gt;ADE&lt;/b&gt; (the</source>
          <target state="translated">另请注意，这是最低设置。您可能要添加其他&lt;b&gt;ADE&lt;/b&gt;软件包（</target>
        </trans-unit>
        <trans-unit id="8f0a8f1a21849e70b5e894c297b75fbda2be2da8" translate="yes" xml:space="preserve">
          <source>Note also that you &lt;b&gt;must&lt;/b&gt; consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value. (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)</source>
          <target state="translated">还要注意，您&lt;b&gt;必须&lt;/b&gt;将编码值视为原子值。也就是说，除了不透明，无法分析的字符串值之外，您不应将其视为任何其他内容。（随着语言标记标准随时间变化，编码方法的内部结构可能会在将来的版本中更改。）</target>
        </trans-unit>
        <trans-unit id="5bce497daf670728bb21a4272ea4f02098c78b3e" translate="yes" xml:space="preserve">
          <source>Note also the existence of &lt;code&gt;sv_catpvf&lt;/code&gt; and &lt;code&gt;sv_vcatpvfn&lt;/code&gt; , combining concatenation with formatting.</source>
          <target state="translated">还要注意 &lt;code&gt;sv_catpvf&lt;/code&gt; 和 &lt;code&gt;sv_vcatpvfn&lt;/code&gt; 的存在，将串联与格式化结合在一起。</target>
        </trans-unit>
        <trans-unit id="2c03a1bb63438d075c735c239a360c45cd5c5f8e" translate="yes" xml:space="preserve">
          <source>Note especially that &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; is</source>
          <target state="translated">请特别注意， &lt;code&gt;$cref-&amp;gt;&amp;amp;*&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="329f3fa12538d44b63cb4bc769615094799f44fc" translate="yes" xml:space="preserve">
          <source>Note for BSD users: setting &lt;code&gt;$0&lt;/code&gt; does not completely remove &quot;perl&quot; from the ps(1) output. For example, setting &lt;code&gt;$0&lt;/code&gt; to &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; (whether both the &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; prefix and the &quot; (perl)&quot; suffix are shown depends on your exact BSD variant and version). This is an operating system feature, Perl cannot help it.</source>
          <target state="translated">BSD用户注意：设置 &lt;code&gt;$0&lt;/code&gt; 不会完全从ps（1）输出中删除&amp;ldquo; perl&amp;rdquo;。例如，设置 &lt;code&gt;$0&lt;/code&gt; 至 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; 可能导致 &lt;code&gt;&quot;perl: foobar (perl)&quot;&lt;/code&gt; （无论这两个 &lt;code&gt;&quot;perl: &quot;&lt;/code&gt; 前缀和&amp;ldquo;（perl的）&amp;rdquo;后缀表示要看您的具体BSD变种和版本）。这是一个操作系统功能，Perl无法帮助它。</target>
        </trans-unit>
        <trans-unit id="7293fa6262cc45f7e2dbf5481215c1d362820f1d" translate="yes" xml:space="preserve">
          <source>Note for Linux and Debian GNU/kFreeBSD users: Before Perl v5.16.0 perl would emulate POSIX semantics on Linux systems using LinuxThreads, a partial implementation of POSIX Threads that has since been superseded by the Native POSIX Thread Library (NPTL).</source>
          <target state="translated">Linux和Debian GNU/kFreeBSD用户须知。在Perl v5.16.0之前,perl会在Linux系统上使用LinuxThreads来模拟POSIX语义,LinuxThreads是POSIX线程的部分实现,后来被NPTL所取代。</target>
        </trans-unit>
        <trans-unit id="7aea9b8c7cfe32358e543467b0f84f66f59444bc" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux用户注意事项：在v5.8.1和v5.16.0之间，Perl可以在使用LinuxThreads的少数Linux系统（和Debian GNU / kFreeBSD系统）使用非POSIX线程语义的情况下工作，此仿真已被删除。有关详细信息，请参见文档以获取&lt;a href=&quot;../perlvar#%24%24&quot;&gt;$$&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cbdce38416b294a5283ce0536b64d8889c65db49" translate="yes" xml:space="preserve">
          <source>Note for Linux users: Between v5.8.1 and v5.16.0 Perl would work around non-POSIX thread semantics the minority of Linux systems (and Debian GNU/kFreeBSD systems) that used LinuxThreads, this emulation has since been removed. See the documentation for &lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt; for details.</source>
          <target state="translated">Linux用户注意事项：在v5.8.1和v5.16.0之间，Perl可以在使用LinuxThreads的少数Linux系统（和Debian GNU / kFreeBSD系统）使用非POSIX线程语义的情况下工作，此仿真已被删除。有关详细信息，请参见文档以获取&lt;a href=&quot;perlvar#%24%24&quot;&gt;$$&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb69bfe72361defc6ffb1f69be5dc9409ce2ae2e" translate="yes" xml:space="preserve">
          <source>Note how the first and last entries are protected by quotes in order to protect the spaces.</source>
          <target state="translated">请注意,为了保护空格,第一条和最后一条是如何用引号保护的。</target>
        </trans-unit>
        <trans-unit id="b9400fb5715aebae33791834189bda7b7f0594aa" translate="yes" xml:space="preserve">
          <source>Note how the last three examples in the table above are treated specially by the parser. &lt;code&gt;mygrep()&lt;/code&gt; is parsed as a true list operator, &lt;code&gt;myrand()&lt;/code&gt; is parsed as a true unary operator with unary precedence the same as &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;mytime()&lt;/code&gt; is truly without arguments, just like &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt;. That is, if you say</source>
          <target state="translated">请注意解析器如何特别处理上表中的最后三个示例。 &lt;code&gt;mygrep()&lt;/code&gt; 被解析为真列表运算符， &lt;code&gt;myrand()&lt;/code&gt; 被解析为与 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 相同的一元优先级的真正一元运算符，而 &lt;code&gt;mytime()&lt;/code&gt; 确实没有参数，就像 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 一样。也就是说，如果你说</target>
        </trans-unit>
        <trans-unit id="32d61faf03809511f3cea1cbe82aa61f0b9ca92a" translate="yes" xml:space="preserve">
          <source>Note how we load the user pragma &lt;code&gt;myint&lt;/code&gt; with an empty list &lt;code&gt;()&lt;/code&gt; to prevent its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; being called.</source>
          <target state="translated">请注意，我们如何使用空列表 &lt;code&gt;()&lt;/code&gt; 加载用户pragma &lt;code&gt;myint&lt;/code&gt; 以防止其 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="25c06a27ee940fb1ce392065b6dccdd03fd73088" translate="yes" xml:space="preserve">
          <source>Note however that some built-ins can't have their syntax expressed by a prototype (such as &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;). If you override them you won't be able to fully mimic their original syntax.</source>
          <target state="translated">但是请注意，某些内置程序无法通过原型来表达其语法（例如 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ）。如果您覆盖它们，则将无法完全模仿其原始语法。</target>
        </trans-unit>
        <trans-unit id="210da70db6283ccd39e5584b10f4c87c0f89d9d6" translate="yes" xml:space="preserve">
          <source>Note however that to use some of these operators you need to have a sh-syntax shell installed (see &lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;, &lt;a href=&quot;#Frequently-asked-questions&quot;&gt;Frequently asked questions&lt;/a&gt;), and perl should be able to find it (see &lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;).</source>
          <target state="translated">但是请注意，要使用其中一些运算符，您需要安装sh语法shell（请参阅&lt;a href=&quot;#Pdksh&quot;&gt;Pdksh&lt;/a&gt;，&lt;a href=&quot;#Frequently-asked-questions&quot;&gt;常见问题&lt;/a&gt;），并且perl应该能够找到它（请参阅&lt;a href=&quot;#PERL_SH_DIR&quot;&gt;PERL_SH_DIR&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6cd6d4fe1827d7816f9b8f3e1b0034bce7c56311" translate="yes" xml:space="preserve">
          <source>Note however, that this function does an exact match using &lt;code&gt;eq&lt;/code&gt; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</source>
          <target state="translated">但是请注意，此函数在完整路径上使用 &lt;code&gt;eq&lt;/code&gt; 进行完全匹配。因此，它无法补偿不区分大小写的文件系统，也无法比较2条路径以查看它们是否指向同一基础文件。</target>
        </trans-unit>
        <trans-unit id="e19273a97b7ee5052886f577d9a46a4421684819" translate="yes" xml:space="preserve">
          <source>Note however, that you need to have</source>
          <target state="translated">但请注意,您需要有</target>
        </trans-unit>
        <trans-unit id="507e6816311ba5923485459a746f4c205372d3f9" translate="yes" xml:space="preserve">
          <source>Note if you specify &lt;code&gt;-&lt;/code&gt; as the command, in an analogous fashion to &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; the child process will just be the forked Perl process rather than an external command. This feature isn't yet supported on Win32 platforms.</source>
          <target state="translated">请注意，如果您指定 &lt;code&gt;-&lt;/code&gt; 作为命令，以类似的方式 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;-|&quot;)&lt;/code&gt; 则子进程将只是派生的Perl进程，而不是外部命令。Win32平台尚不支持此功能。</target>
        </trans-unit>
        <trans-unit id="da9342b413d4bbcd1dc6fe59e3ee28645b823224" translate="yes" xml:space="preserve">
          <source>Note in the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">请注意,在最后一个例子中,字符串的结尾被认为是一个字的边界。</target>
        </trans-unit>
        <trans-unit id="07e19a6ca0b876d2709ab0ec0dfc79383c491dc1" translate="yes" xml:space="preserve">
          <source>Note on ISO-2022-JP(-1)?</source>
          <target state="translated">关于ISO-2022-JP(-1)的说明?</target>
        </trans-unit>
        <trans-unit id="b88ed054c638a5f7768e2dd282a5e1b35bab783a" translate="yes" xml:space="preserve">
          <source>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See &lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;BUGS AND PITFALLS&lt;/a&gt;.</source>
          <target state="translated">关于步骤7的注意事项：某些运算符的语义取决于操作数的类型。由于无法指示Perl将操作数视为例如数字而不是字符串，因此这里的结果可能不是您期望的。请参阅&amp;ldquo;错误&lt;a href=&quot;#BUGS-AND-PITFALLS&quot;&gt;和失败&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15bc1023efea2381a2db802c419cf3e98569e03f" translate="yes" xml:space="preserve">
          <source>Note on the format of the urllist parameter</source>
          <target state="translated">关于urllist参数格式的说明。</target>
        </trans-unit>
        <trans-unit id="cc738b8cb2fe5493887c63f096423e4e822a4785" translate="yes" xml:space="preserve">
          <source>Note particularly that $x continues to refer to the value passed into newprint()</source>
          <target state="translated">请特别注意,$x仍然是指传入newprint()的值。</target>
        </trans-unit>
        <trans-unit id="977ff75717e2ad5549c27c1fec3fb1a8727cd2e9" translate="yes" xml:space="preserve">
          <source>Note several important features of this example. First of all, the</source>
          <target state="translated">请注意这个例子的几个重要特点。首先,</target>
        </trans-unit>
        <trans-unit id="99e506d24bb1d2d8c0953ced78837622f6175e3d" translate="yes" xml:space="preserve">
          <source>Note that &quot;&amp;lt;&amp;amp;STDIN&quot; makes a copy, but &quot;&amp;lt;&amp;amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</source>
          <target state="translated">请注意，&amp;ldquo; &amp;lt;＆STDIN&amp;rdquo;进行复制，而&amp;ldquo; &amp;lt;＆= STDIN&amp;rdquo;进行别名。这意味着，如果关闭别名句柄，则所有别名都将无法访问。复制的副本不是这样。</target>
        </trans-unit>
        <trans-unit id="760e35c71509b97a49875e6fc164a9d4be791312" translate="yes" xml:space="preserve">
          <source>Note that $x is still printed as having its true non-integer value of 5.8 since it wasn't operated on. And note too the wrap-around from the largest positive integer to the largest negative one. Also, arguments passed to functions and the values returned by them are &lt;b&gt;not&lt;/b&gt; affected by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; . E.g.,</source>
          <target state="translated">请注意，由于未操作$ x，因此其真实非整数值5.8仍被打印。还要注意从最大的正整数到最大的负整数的环绕。此外，参数传递给函数和由它们返回的值都&lt;b&gt;不会&lt;/b&gt;影响 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="e599f385e86c967c815cb5ac633fbf5c8b743e32" translate="yes" xml:space="preserve">
          <source>Note that &amp;lt;FILE&amp;gt; is</source>
          <target state="translated">请注意，&amp;lt;FILE&amp;gt;是</target>
        </trans-unit>
        <trans-unit id="f28b0b3d67592306ce241a091fd7fa4b9b9390b5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt; has been</source>
          <target state="translated">请注意，&lt;a href=&quot;#make_iterator&quot;&gt;make_iterator&lt;/a&gt;已被</target>
        </trans-unit>
        <trans-unit id="d5449cbba5d5e7a82db88f55e4440d98e4342ea0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt; is a special case where it must call &lt;code&gt;boot_DynaLoader&lt;/code&gt; directly.</source>
          <target state="translated">请注意，&lt;a href=&quot;../dynaloader&quot;&gt;DynaLoader&lt;/a&gt;是一种特殊情况，它必须直接调用 &lt;code&gt;boot_DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2b414b3045e4a13e62684509b81beee13f1a03b" translate="yes" xml:space="preserve">
          <source>Note that &lt;b&gt;-S&lt;/b&gt; switch supports scripts with additional extensions</source>
          <target state="translated">请注意，&lt;b&gt;-S&lt;/b&gt;开关支持带有其他扩展名的脚本</target>
        </trans-unit>
        <trans-unit id="df5cabe56a3fab1a8dfd7142a90c482f8fae0efd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; has lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">请注意， &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 优先级低于关系运算符，因此，例如在诸如</target>
        </trans-unit>
        <trans-unit id="522782427bfce1d8f14995dfc30aaa97199ffa5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; and that the second stage of &lt;code&gt;$&lt;/code&gt; interpolation in regular expressions will fall foul of the &lt;code&gt;$.&lt;/code&gt; if scripts are not careful.</source>
          <target state="translated">注意 &lt;code&gt;&quot;ADFS::HardDisk.$.File&quot; ne 'ADFS::HardDisk.$.File'&lt;/code&gt; 并且正则表达式中 &lt;code&gt;$&lt;/code&gt; 插值的第二阶段将与$产生冲突 &lt;code&gt;$.&lt;/code&gt; 如果脚本不小心。</target>
        </trans-unit>
        <trans-unit id="12ecea42a6af74c63b7121532319090437ea634b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&quot;|&quot;&lt;/code&gt; and &lt;code&gt;&quot;^&quot;&lt;/code&gt; have lower priority than relational operators, so for example the parentheses are essential in a test like</source>
          <target state="translated">请注意， &lt;code&gt;&quot;|&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;^&quot;&lt;/code&gt; 优先级低于关系运算符，因此例如在测试中括号是必不可少的</target>
        </trans-unit>
        <trans-unit id="79eafdbed824b09455353e30518fbddb877197c5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。同样，grep将别名返回到原始列表中，就像for循环的索引变量为列表元素别名一样。也就是说，修改grep返回的列表的元素（例如，在 &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或另一个 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 中）实际上会修改原始列表中的元素。在编写清晰的代码时通常应避免这种情况。</target>
        </trans-unit>
        <trans-unit id="922c04cd95d993e5139c2b97058698400e67f636" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Similarly, grep returns aliases into the original list, much as a for loop's index variable aliases the list elements. That is, modifying an element of a list returned by grep (for example, in a &lt;code&gt;foreach&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; or another &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;) actually modifies the element in the original list. This is usually something to be avoided when writing clear code.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。同样，grep将别名返回到原始列表中，就像for循环的索引变量为列表元素别名一样。也就是说，修改grep返回的列表的元素（例如，在 &lt;code&gt;foreach&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 或另一个 &lt;code&gt;&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 中）实际上会修改原始列表中的元素。在编写清晰的代码时通常应避免这种情况。</target>
        </trans-unit>
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。在大多数情况下，使用常规的 &lt;code&gt;foreach&lt;/code&gt; 循环会更清晰。另请参见&lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt;，以了解由原始列表中BLOCK或EXPR评估为true的那些项组成的数组。</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">请注意， &lt;code&gt;$_&lt;/code&gt; 是列表值的别名，因此可以用来修改LIST的元素。尽管这是有用且受支持的，但如果LIST的元素不是变量，则可能导致奇怪的结果。在大多数情况下，使用常规的 &lt;code&gt;foreach&lt;/code&gt; 循环会更清晰。另请参见&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;，以了解由原始列表中BLOCK或EXPR评估为true的那些项组成的数组。</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;$processed&lt;/code&gt; 可能为空（当 &lt;code&gt;$normalized&lt;/code&gt; 包含启动器或从最后一个启动器开始时），然后 &lt;code&gt;$unprocessed&lt;/code&gt; 应该等于整个 &lt;code&gt;$normalized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">请注意， &lt;code&gt;-s/a/b/&lt;/code&gt; 不会进行取反。话说 &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 仍正常工作，但是：只有下面一个负单字母解释为文件的测试。</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">请注意， &lt;code&gt;-s/a/b/&lt;/code&gt; 不会进行取反。话说 &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 仍正常工作，但是：只有下面一个负单字母解释为文件的测试。</target>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">注意 &lt;code&gt;:constants256&lt;/code&gt; 不包含其他常量，因此，如果要混合使用它们，则还必须包含 &lt;code&gt;:constants&lt;/code&gt; 。您可能要显式导入至少 &lt;code&gt;RESET&lt;/code&gt; ，如：</target>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 是每个测试的等待和退出状态的总和。如果这些值中的任何一个都不为零，则总计这些值仅是为了提供真实值。</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; 不在上面列出。如果在Time :: Piece对象上作为方法调用，它们将充当构造函数，并在当前时间返回新的Time :: Piece对象。换句话说：它们作为方法没有用。</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 将返回最后一个字符。要返回除最后一个字符以外的所有字符，请使用 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 不会调用您的 &lt;code&gt;END&lt;/code&gt; 块，也不会在您的对象上调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">请注意，如果在未实现fcntl（2）的计算机上使用 &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ，则会引发异常。请参阅Fcntl模块或fcntl（2）联机帮助页以了解系统上可用的功能。</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">注意，当使用普通文件句柄时，通常不需要 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 。提供该文件是为了使您可以在必要时控制对现有记录结构文件的I / O。您还可以在VMS :: Stdio扩展中使用 &lt;code&gt;vmsfopen&lt;/code&gt; 函数，以更好地控制具有不同记录结构的文件和设备的I / O。</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 将返回最后一个字符。要返回除最后一个字符以外的所有字符，请使用 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 不会调用您的 &lt;code&gt;END&lt;/code&gt; 块，也不会在您的对象上调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">请注意，如果在未实现fcntl（2）的计算机上使用 &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ，则会引发异常。请参阅Fcntl模块或fcntl（2）联机帮助页以了解系统上可用的功能。</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 在空白处拆分其参数，并将每个段视为单独的模式。这样， &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 会将所有文件与</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; 不适用于当前版本的EMX。</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 取决于fdopen（）C库函数。在许多Unix系统上，已知当文件描述符超过某个值（通常为255）时，fdopen（）会失败。如果您需要的文件描述符超过此值，请考虑使用POSIX :: open（）函数。</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">需要注意的是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 并&lt;b&gt;没有&lt;/b&gt;做正则表达式字符类，如 &lt;code&gt;\d&lt;/code&gt; 或 &lt;code&gt;\pL&lt;/code&gt; 。的 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 操作者是不等同于 &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; 实用程序。如果要在大小写之间映射字符串，请参见&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;和&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;，如果需要正则表达式，通常考虑使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 运算符。替换运算符右侧的 &lt;code&gt;\U&lt;/code&gt; ， &lt;code&gt;\u&lt;/code&gt; ， &lt;code&gt;\L&lt;/code&gt; 和 &lt;code&gt;\l&lt;/code&gt; 字符串插值转义将执行正确的大小写映射，但是 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; 不会（有时在旧版7位数据上除外）。</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">请注意，插值字符串中的 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 转换为大写，而插值字符串中的 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;\u&lt;/code&gt; 转换为区分大小写的语言的首字母大写（等同于不区分大小写的语言中的大写字母）。</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 在空白处拆分其参数，并将每个段视为单独的模式。这样， &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; 会将所有文件与</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 取决于fdopen（）C库函数。在许多Unix系统上，已知当文件描述符超过某个值（通常为255）时，fdopen（）会失败。如果您需要的文件描述符超过此值，请考虑使用POSIX :: open（）函数。</target>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">请注意， &lt;code&gt;Dump&lt;/code&gt; 不会报告</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">请注意， &lt;code&gt;END&lt;/code&gt; 代码块&lt;b&gt;不会&lt;/b&gt;在字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 的末尾执行：如果在字符串 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 中创建了任何 &lt;code&gt;END&lt;/code&gt; 代码块，它们将与该包中的其他任何 &lt;code&gt;END&lt;/code&gt; 代码块一样按LIFO顺序执行。在退出解释器之前。</target>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; 和 &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; 设置了全局变量，因此&lt;b&gt;任何&lt;/b&gt;新创建的数字都将&lt;b&gt;立即&lt;/b&gt;进行全局舍入。这意味着在上面的示例中， &lt;code&gt;bdiv()&lt;/code&gt; 的 &lt;code&gt;3&lt;/code&gt; 作为参数也将获得&lt;b&gt;5&lt;/b&gt;的精度。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;NULL&lt;/code&gt; 是有效的 &lt;code&gt;proto&lt;/code&gt; 并且将始终返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">请注意，无论如何都不会更改 &lt;code&gt;STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">请注意， &lt;code&gt;TAP::Parser&lt;/code&gt; 被设计为中央&amp;ldquo;制造者&amp;rdquo;-即：它负责在 &lt;code&gt;TAP::Parser::*&lt;/code&gt; 名称空间中创建大多数新对象。</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">请注意，即使所有类都隐式继承自 &lt;code&gt;UNIVERSAL&lt;/code&gt; 及其父级的方法， &lt;code&gt;UNIVERSAL&lt;/code&gt; （和 &lt;code&gt;UNIVERSAL&lt;/code&gt; 的MRO的任何成员）也不属于类的MRO 。</target>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">注意 &lt;code&gt;\N&lt;/code&gt; 有两个含义。当格式为 &lt;code&gt;\N{NAME}&lt;/code&gt; ，它与名称为 &lt;code&gt;NAME&lt;/code&gt; 的字符或字符序列匹配；并且类似地，当格式为 &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; ，它匹配Unicode代码点为</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;\N{...}&lt;/code&gt; 可以表示&lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;命名或编号字符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">注意 &lt;code&gt;\N{...}&lt;/code&gt; 是编译时；这是双引号字符串中使用的字符串常量的一种特殊形式；这意味着您不能在 &lt;code&gt;\N{...}&lt;/code&gt; 内部使用变量。如果您想要类似的运行时功能，请使用&lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame（）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">请注意 &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">请注意，在正则表达式（或双引号字符串）末尾单独使用 &lt;code&gt;\c\&lt;/code&gt; 无效。反斜杠后必须跟另一个字符。也就是说， &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; 表示 &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; 所有字符均为&amp;ldquo; &lt;i&gt;X&lt;/i&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">请注意，如果 &lt;code&gt;$thing&lt;/code&gt; 被祝福到名为&amp;ldquo; 0&amp;rdquo;的类中，则 &lt;code&gt;blessed($thing)&lt;/code&gt; 也将返回false 。这是可能的，但是很病态。除非您知道自己在做什么，否则不要创建名为&amp;ldquo; 0&amp;rdquo;的类。</target>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">请注意， &lt;code&gt;gen_delimited_pat&lt;/code&gt; 以前称为 &lt;code&gt;delimited_pat&lt;/code&gt; 。该名称可能仍会使用，但现在已弃用。</target>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">请注意， &lt;code&gt;make_source&lt;/code&gt; 和 &lt;code&gt;make_perl_source&lt;/code&gt; 已被</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">请注意，现在 &lt;code&gt;openlog()&lt;/code&gt; 需要三个参数，就像 &lt;code&gt;openlog(3)&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;size&lt;/code&gt; 是目标缓冲区的完整大小，如果有空间，结果将保证为 &lt;code&gt;NUL&lt;/code&gt; 终止。需要注意的是房间的 &lt;code&gt;NUL&lt;/code&gt; 应包括在 &lt;code&gt;size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">请注意， &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;tap&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">需要注意的是 &lt;code&gt;sv_magicext&lt;/code&gt; 将使事情 &lt;code&gt;sv_magic&lt;/code&gt; 不会。特别是，您可以向SvREADONLY SV添加魔术，并添加多个相同&amp;ldquo;操作&amp;rdquo;实例。</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">请注意， &lt;code&gt;sv_setref_pv&lt;/code&gt; 复制指针，而这会复制字符串。</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">请注意， &lt;code&gt;sv_setref_pvn&lt;/code&gt; 复制字符串，同时复制指针。</target>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">请注意，如果字符串包含不适合字节的字符，则 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 可能会失败。</target>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">请注意,=end命令必须与当前打开的=begin命令相匹配。也就是说,它们必须正确地嵌套。例如,这是有效的。</target>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">请注意，不鼓励不要映射到控制字符的ASCII字符，并且会生成警告（启用后），&lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c％c更清楚地写为％s&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">请注意，E &amp;lt;number&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">请注意，版本1.14之前的GNU tar不能很好地处理 &lt;code&gt;POSIX header prefix&lt;/code&gt; 。如果使用这样的版本，请考虑将 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 变量设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">请注意,GNU的gzip/gunzip与Info-ZIP的zip/unzip包是不同的。前者是一个简单的压缩工具;后者允许创建多文件档案。</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">需要注意的是,理想的散列质量得分应该是1,接近和低于1的数字表示散列效果好,明显高于1的数字表示得分差。在实践中,它应该是0.95到1.05左右。它的定义是:</target>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">需要注意的是,META文件应该是UTF-8编码的,只能是UTF-8编码。当转换字符串数据时,必须首先对其进行UTF-8解码。</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">请注意,MakeMaker实际上会根据它认为你使用的 &quot;make &quot;发出不同语法的makefile。因此,在Config.pm中出现以下值之一是很重要的。</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">请注意，Perl可以在ASCII或EBCDIC下编译并运行（请参见&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;）。大多数文档（甚至代码中的注释）都忽略了EBCDIC的可能性。对于几乎所有目的，差异都是透明的。例如，在EBCDIC下，使用UTF-EBCDIC而不是UTF-8来编码Unicode字符串，因此，每当本文档引用 &lt;code&gt;utf8&lt;/code&gt; （以及该名称的变体，包括函数名称）时，它也（实质上是透明的）表示 &lt;code&gt;UTF-EBCDIC&lt;/code&gt; 。但是，ASCII，EBCDIC和UTF编码之间的字符顺序有所不同，并且以UTF-EBCDIC编码的字符串可能比在UTF-8中占用更多的字节。</target>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">请注意,Perl认为词素簇是独立的字符,所以例如</target>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">需要注意的是,Perl并没有使用COMSPEC,因为COMSPEC在用户之间的差异性很大,导致了可移植性的问题。此外,Perl可以使用一个可能不适合交互式使用的shell,将COMSPEC设置为这样的shell可能会干扰其他程序的正常运行(这些程序通常在COMSPEC中寻找适合交互式使用的shell)。</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">请注意,Perl 支持最多只传递 14 个参数到你的 syscall 中,这在实践中应该(通常)已经足够了。</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">请注意，仅当OS / 2无法启动指定的应用程序时，Perl才会开始查找脚本，因此，如果存在可执行文件，则 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; 将不查找脚本</target>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">请注意，Pod作者可以在&amp;ldquo; L &amp;lt;text | name&amp;gt;&amp;rdquo;的&amp;ldquo; text&amp;rdquo;部分内使用格式代码（对于L &amp;lt;text | /&amp;ldquo; sec&amp;rdquo;&amp;gt;依此类推）。</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">需要注意的是,RFC 1951数据并不是单独使用压缩格式的好选择,尤其是当你想自动检测的时候。</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">注意,SHA-1和SHA-2使用的是</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">注意,TODO测试</target>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">请注意,Tie::File 只会关闭它在内部打开的任何文件柄。如果你像上面一样传递给它一个文件柄,你就 &quot;拥有 &quot;这个文件柄,并负责在你解开 @array 的绑定后关闭它。</target>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">请注意,&quot;=begin</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">请注意，空白行中不能有空白。因此， &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; 是一个段落，而 &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; 是两个段落。</target>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 可以用于使此类块提前退出。</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 将尽早退出此类障碍。</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，在这样的块内 &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 将有效地将其变成循环构造。</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 可以用于使此类块提前退出。</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此， &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 将尽早退出此类障碍。</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">注意，块本身在语义上与执行一次的循环相同。因此，在这样的块内 &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 将有效地将其变成循环构造。</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">请注意,以八进制转义表示的字符被 regex 引擎认为是没有特殊意义的字符,将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">请注意,用这些转义词表示的字符被regex引擎认为是一个没有特殊含义的字符,并将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">需要注意的是,以命名或编号字符表示的字符或字符序列,在regex引擎中被认为是没有特殊含义的字符,将 &quot;按原样 &quot;匹配。</target>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">请注意,一个格式以字母 &quot;a &quot;开头,如果且仅有它的属性需要通过添加多元素范围内的偏移量来调整。对于所有这些属性,只有当映射是一个整数的标量时,才应该调整一个条目。也就是说,它必须符合正则表达式。</target>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">需要注意的是,可以通过数值运算使标量同时具有字符串和数值内容。</target>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">请注意,共享变量可以保证如果两个或多个线程同时尝试修改它,变量的内部状态不会被破坏。但是,除此之外没有任何保证,这将在下一节中解释。</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">请注意，上面的副作用是 &lt;code&gt;mkpath&lt;/code&gt; 和 &lt;code&gt;rmtree&lt;/code&gt; 不再输出。这是由于 &lt;code&gt;Exporter&lt;/code&gt; 模块的工作方式。如果要迁移代码库以使用新界面，则必须明确列出所有内容。但这毕竟是一个好习惯。</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">请注意,根据 POSIX 1003.1-1996,FILENAME 可以有任意数量的斜杠。有些操作系统和文件系统并没有做到这一点,所以Perl会自动删除所有的尾部斜杠,以保证大家都满意。</target>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">请注意，所有C程序（包括用C编写的perl解释器）始终具有基础语言环境。该语言环境是&amp;ldquo; C&amp;rdquo;语言环境，除非通过调用&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）&lt;/a&gt;进行了更改。当Perl启动时，它将基础语言环境更改为&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;指示的语言环境。使用&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;模块或编写XS代码时，请记住，即使程序未明确更改基础语言环境，也可能是&amp;ldquo; C&amp;rdquo;以外的语言。</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">请注意，所有Perl API全局变量都必须使用 &lt;code&gt;PL_&lt;/code&gt; 前缀引用。同样，此处未列出的扩展程序切勿由扩展程序编写人员使用，并且可以在不另行通知的情况下进行更改或删除。与宏相同。提供了一些宏来与较旧的未经修饰的名称兼容，但是在将来的发行版中可能会禁用此支持。</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">注意,所有的访问都是只读的。你不能通过使用这个模块来修改内部结构。另外,请注意本模块创建的 B::OP 和 B::SV 对象只有在底层对象存在的时候才有效;它们的创建不会增加底层对象的引用次数。试图访问一个被释放的对象的字段会得到难以理解的结果,甚至更糟。</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">请注意,在显示以下简称时,所有非必要的下划线都会被删除。</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">请注意，以上所有内容在 &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; 范围内都被覆盖；但您应该仅将此杂注用于调试。</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">需要注意的是,%result的所有更新都是加法的,使用前不会清空哈希值,因此可以方便地将很多安装的状态结果进行汇总。</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">请注意，我们在此快速概述中所描述的只是使用&lt;b&gt;Pod :: Parser&lt;/b&gt;最简单，最直接的方法来进行基于流的解析。也可以使用&lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt;函数执行更复杂的基于树的解析。请参阅&lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;基于树的解析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">请注意，几乎所有属性都不受大小写敏感匹配的影响。也就是说，添加 &lt;code&gt;/i&lt;/code&gt; 正则表达式修饰符不会更改它们的匹配项。有两个受影响的集。第一组是 &lt;code&gt;Uppercase_Letter&lt;/code&gt; ， &lt;code&gt;Lowercase_Letter&lt;/code&gt; ，和 &lt;code&gt;Titlecase_Letter&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased_Letter&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。第二组是 &lt;code&gt;Uppercase&lt;/code&gt; ， &lt;code&gt;Lowercase&lt;/code&gt; ，和 &lt;code&gt;Titlecase&lt;/code&gt; ，所有这些匹配 &lt;code&gt;Cased&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; 匹配。 （这两个集合之间的区别在于，某些东西（例如罗马数字）同时使用大写和小写形式，因此它们是 &lt;code&gt;Cased&lt;/code&gt; ，但不视为字母，因此不是 &lt;code&gt;Cased_Letter&lt;/code&gt; 。它们实际上是 &lt;code&gt;Letter_Number&lt;/code&gt; 。）此集合还包括其子集 &lt;code&gt;PosixUpper&lt;/code&gt; 和 &lt;code&gt;PosixLower&lt;/code&gt; ，它们都在 &lt;code&gt;/i&lt;/code&gt; 下与 &lt;code&gt;PosixAlpha&lt;/code&gt; 相匹配。</target>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">注意，虽然 &lt;code&gt;$!&lt;/code&gt; 似乎是双值变量，它实际上是使用绑定标量实现的：</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">请注意,&quot;=over&quot;...&quot;=back &quot;区域应该有一些内容。&quot;=back &quot;区域应该有一些内容。也就是说,作者不应该有一个像这样的空区域。</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">请注意,一个INVARIANT字符(即非EBCDIC机器上的ASCII字符)是一个有效的UTF-8字符。</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">请注意,因为 &quot;使用vmsish &quot;而被编译成 &quot;hashhed &quot;的exit()或die(),在运行时调用vmsish::hashhed(0)并不能解除hush。</target>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">请注意，本文档（或&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;）中未记录的任何变量和函数仅供内部使用，因此如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">请注意，本手册页（或&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;）中未记录的任何变量和函数仅供内部使用，因此如有更改，恕不另行通知。</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">请注意， &lt;code&gt;\Q...\E&lt;/code&gt; 中的任何内容均不受 &lt;code&gt;/x&lt;/code&gt; 的影响。并注意 &lt;code&gt;/x&lt;/code&gt; 不会影响单个多字符构造中的空间解释。例如，在 &lt;code&gt;\x{...}&lt;/code&gt; ，无论使用 &lt;code&gt;/x&lt;/code&gt; 修饰符如何，都不能有空格。对于诸如 &lt;code&gt;{3}&lt;/code&gt; 或 &lt;code&gt;{5,}&lt;/code&gt; 之类的&lt;a href=&quot;#Quantifiers&quot;&gt;量词也是&lt;/a&gt;如此。同样， &lt;code&gt;(?:...)&lt;/code&gt; 在 &lt;code&gt;(&lt;/code&gt; ， &lt;code&gt;?&lt;/code&gt; 和 &lt;code&gt;:&lt;/code&gt; 之间不能有空格。在此类构造的任何分隔符内，允许的空间不受 &lt;code&gt;/x&lt;/code&gt; 的影响，而是取决于构造。例如， &lt;code&gt;\x{...}&lt;/code&gt; 不能有空格，因为十六进制数字中没有空格。但是，Unicode属性可以包含空格，因此在 &lt;code&gt;\p{...}&lt;/code&gt; 中可以存在遵循Unicode规则的空格，有关这些&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;属性&lt;/a&gt;，请参见perluniprops中可通过\ p {}和\ P {}访问的属性。</target>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">请注意，从Perl 5.14开始， &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; 会将命名序列插入双引号字符串中，而 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; 将返回此函数执行的相同字符串，但是还可以对未命名的字符名称进行操作，而无需知道哪些字符。请参阅&lt;a href=&quot;../charnames&quot;&gt;字符名&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">请注意,从Perl 5.20开始,变量名中的控制字符将被取消;从Perl 5.22开始,任何其他非图形字符也将被取消。</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">注意,atan2(0,0)的定义并不明确。</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">注意，一旦检测到属性（即在执行任何后续定义的 &lt;code&gt;BEGIN&lt;/code&gt; 块之前），便会立即处理为 &lt;code&gt;BEGIN&lt;/code&gt; 阶段安排的属性处理程序。</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">请注意，由于&lt;b&gt;-i&lt;/b&gt;在创建具有相同名称的新文件之前会重命名或删除原始文件，因此将不会保留Unix样式的软链接和硬链接。</target>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">请注意，由于多个扩展可能正在使用 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 或 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 魔术，因此，扩展必须格外小心以避免冲突，这一点很重要。通常，仅对具有扩展名的对象使用魔法就足够了。对于 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; 魔术，通常最好定义一个 &lt;code&gt;MGVTBL&lt;/code&gt; ，即使其所有字段都为 &lt;code&gt;0&lt;/code&gt; ，也可以使用其魔术虚拟表将各个 &lt;code&gt;MAGIC&lt;/code&gt; 指针识别为一种特殊的魔术。 &lt;code&gt;mg_findext&lt;/code&gt; 提供了一种简单的方法：</target>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">请注意，由于愚蠢的OS / 2限制，当您使用 &lt;code&gt;extproc&lt;/code&gt; 时，perl脚本的完整路径不可用，因此您不得不使用 &lt;code&gt;-S&lt;/code&gt; perl开关，并且脚本应位于 &lt;code&gt;PATH&lt;/code&gt; 上。顺带一提，如果您知道脚本的完整路径，则仍可以使用</target>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">请注意,因为这个渲染是在一个非线程的perl上完成的,所以前面例子中的PADOPs现在变成了SVOPs,一些(但不是全部)方括号被替换成了圆括号。这是一个微妙的功能,为线程和非线程perl上的渲染提供了一些视觉上的区别。</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">请注意,因为我们是在实数的近似值上进行操作,所以当仅仅是 &quot;太接近 &quot;上面列出的奇点时,就会发生这些错误。</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">请注意，Perl中的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 均使用C中的 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 直接实现。如果强制 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; （请参见&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;），则使用带符号的C整数，否则使用无符号的C整数。无论哪种方式，实现都不会产生比Perl所构建的整数类型（32位或64位）大的结果。</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">请注意， &lt;code&gt;hv_store&lt;/code&gt; 和 &lt;code&gt;hv_store_ent&lt;/code&gt; 都不会增加存储的 &lt;code&gt;val&lt;/code&gt; 的引用计数，这是调用者的责任。如果这些函数返回NULL值，则调用程序通常将必须减少 &lt;code&gt;val&lt;/code&gt; 的引用计数，以避免内存泄漏。</target>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">请注意,这两个路径都被假定为有一个符号来区分目录路径(带尾部':')和文件路径(不带尾部':')。</target>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">请注意， &lt;code&gt;CanonicalName&lt;/code&gt; 和 &lt;code&gt;FilterName&lt;/code&gt; 选项都可以修改用于zip文件名标头字段的值。</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">请注意，bsd_glob（）通过不将 &lt;code&gt;ENOENT&lt;/code&gt; 和 &lt;code&gt;ENOTDIR&lt;/code&gt; 视为错误而偏离了POSIX和FreeBSD glob（3）行为-尽管存在这些错误，bsd_glob（）仍将继续处理，除非设置了 &lt;code&gt;GLOB_ERR&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">请注意，在递归返回之后无法访问在递归内匹配的捕获组，因此捕获组的额外层是必需的。因此，即使 &lt;code&gt;$+{NAME}&lt;/code&gt; 被定义，也不会定义 &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">请注意，某些幂表达式不明确的：这些包括 &lt;code&gt;0**0&lt;/code&gt; ， &lt;code&gt;1**Inf&lt;/code&gt; ，和 &lt;code&gt;Inf**0&lt;/code&gt; 。不要期望这些特殊情况有任何特定的结果，这些结果取决于平台。</target>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">请注意,出于向后兼容的原因,128至255(含)的字符默认在内部不被编码为UTF-8。</target>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">请注意，不支持 &lt;code&gt;GNU Extended Header&lt;/code&gt; 功能的客户端将无法读取这些档案。这些客户端包括 &lt;code&gt;Solaris&lt;/code&gt; ， &lt;code&gt;Irix&lt;/code&gt; 和 &lt;code&gt;AIX&lt;/code&gt; 上的tar。</target>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">请注意,代码6(快速闪烁)和代码9(击穿)在ANSI X3.64和ECMA-048中指定,但大多数显示器和仿真器通常不支持,因此目前本模块不支持。ECMA-048还指定了大量的其他属性,包括字体变化、Fraktur字符、双下划线、框架、圈点和加线的一系列属性。由于这些属性都没有得到广泛的支持或有用,所以目前本模块也不支持这些属性。</target>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">请注意，将任意标量强制转换为纯PV可能会从中剥离有用数据。例如，如果SV是 &lt;code&gt;SvROK&lt;/code&gt; ，那么将减少引用对象的引用计数，并且可以将SV本身转换为带有包含诸如 &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; 的值的字符串缓冲区的 &lt;code&gt;SvPOK&lt;/code&gt; 标量。</target>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">请注意，connected（）认为半开式TCP套接字处于&amp;ldquo;已连接状态&amp;rdquo;。具体来说，connected（）不能区分&lt;b&gt;ESTABLISHED&lt;/b&gt;和&lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP状态。无论哪种情况，它都返回对等地址，而不是undef。因此，通常，connected（）不能用于可靠地了解对等方是否已启动正常关机，因为在大多数情况下（请参见下文），本地TCP状态机仍处于&lt;b&gt;CLOSE-WAIT&lt;/b&gt;状态，直到本地应用程序调用shutdown（）或close （）;仅在那时，connected（）才返回undef。</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">请注意,目前一些测试脚本在并行运行时可能会失败(最明显的是</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">请注意,define_alias()将不能覆盖编码的规范名。在尝试潜在的别名之前,编码会先按规范名查找。</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">请注意,尽管存在这个opag,但只使用:base_core ops仍然可以进行内存资源攻击。</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">请注意,点(</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">请注意,由于过度的偏执,如果$Getopt::Std::STANDARD_HELP_VERSION不是true(默认为false),那么消息会被打印在STDERR上,并且在消息被打印后继续处理。这与符合标准的行为相反,强烈建议将 $Getopt::Std::STANDARD_HELP_VERSION 设置为 true。</target>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">注意，每个 &lt;code&gt;pp_&lt;/code&gt; 函数都应返回一个指向下一个op的指针。对perl子程序（和eval块）的调用在同一runops循环中处理，并且不占用C堆栈上的额外空间。例如， &lt;code&gt;pp_entersub&lt;/code&gt; 和 &lt;code&gt;pp_entertry&lt;/code&gt; 只是将 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; 块结构推入上下文堆栈，其中包含子调用或eval之后的op地址。然后，它们返回该子块或eval块的第一个操作，因此该子块或eval的执行继续。稍后， &lt;code&gt;pp_leavesub&lt;/code&gt; 或 &lt;code&gt;pp_leavetry&lt;/code&gt; op弹出 &lt;code&gt;CxSUB&lt;/code&gt; 或 &lt;code&gt;CxEVAL&lt;/code&gt; ，从中检索返回op，然后将其返回。</target>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">请注意，当您将它们称为 &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; &lt;i&gt;what（value）&lt;/i&gt;时，它们都将返回 &lt;code&gt;$self&lt;/code&gt; 。这样一来，您就可以像这样将设置属性调用链接在一起：&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">请注意,尽管SunOS和Solaris是二进制兼容的,但这些值是不同的。去想吧。</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">请注意，由于不区分大小写的 &lt;code&gt;/i&lt;/code&gt; 正则表达式匹配而导致的失败的大小写转换操作将在此警告中显示为具有 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 操作（正则表达式引擎在后台调用该操作）。</target>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">请注意，冲洗会严重降低压缩率，因此只能用于终止解压缩（使用 &lt;code&gt;Z_FINISH&lt;/code&gt; ）或要创建压缩文件时使用。</target>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">请注意，对于控制字符（ &lt;code&gt;Gc=cc&lt;/code&gt; ），Unicode的数据文件具有字符串&amp;ldquo; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &amp;rdquo;，但是每个字符的真实名称都是空字符串。此函数返回该真实名称，即空字符串。（这些字符有名称，但它们被视为别名，而不是Name属性名称，并包含在 &lt;code&gt;Name_Alias&lt;/code&gt; 属性中。）</target>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">需要注意的是,对于较大的位串,使用两个参数的版本会更有效率。</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">请注意，对于更简单的测试要求，通常可以通过一次调用 &lt;code&gt;runtests&lt;/code&gt; 来替换上述代码。</target>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">请注意，对于 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; （无穷大且不是数字），&amp;ldquo;数字&amp;rdquo;的定义有些不寻常：字符串本身（如&amp;ldquo; Inf&amp;rdquo;）被视为数字，而其后的任何内容均被视为非数字。</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">请注意,格式会被当作昂子,每次调用write时都会被克隆(如果需要的话)。</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">请注意,冻结一个对象结构并立即解冻,实际上实现了对该结构的深度克隆。</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">请注意，从&lt;a href=&quot;../bigint&quot;&gt;Math :: BigInt&lt;/a&gt; v1.76开始，如果可能，将自动加载FastCalc。</target>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">请注意，在大型DBM文件上使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 功能时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来迭代大型DBM文件。例：</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">请注意，在大型对象（如DBM文件）上使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来对此进行迭代。例：</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">请注意，在大型DBM文件上使用 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 功能时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来迭代大型DBM文件。例：</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">请注意，在大型对象（如DBM文件）上使用 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 函数时，它们可能会返回巨大的列表。您可能更喜欢使用 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 函数来对此进行迭代。例：</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">请注意,当对大型对象(如 DBM 文件)使用诸如 keys()和 values()等函数时,可能会返回巨大的列表。你可能更喜欢使用each()函数来遍历这样的对象。例子:</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">请注意，glibc版本2.17之前的glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; 等存在错误。如果程序的当前基础语言环境是UTF-8，则它们将不允许精度为 &lt;code&gt;%.s&lt;/code&gt; 的格式创建不是有效UTF-8的字符串。发生的是， &lt;code&gt;%s&lt;/code&gt; 及其操作数只是被跳过而没有任何通知。&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">请注意,globbing只会列出明确要求的目录,例如FOO/*不会列出FOO/bar/Acme-Sthg-n.nn.tar.gz。这可能被认为是一个错误,在未来的版本中可能会被修改。</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">请注意，如果 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 需要外部数据才能工作，那么没有它就无法进行子例程调用。例如，标准调试器的 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 取决于 &lt;code&gt;$DB::deep&lt;/code&gt; 变量（它定义了在强制性中断之前可以进入调试器的递归深度的级别）。如果未定义 &lt;code&gt;$DB::deep&lt;/code&gt; ，则即使 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 存在，也无法进行子例程调用。</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">请注意，如果启用了 &lt;code&gt;CanonicalName&lt;/code&gt; ，则将标准化的文件名传递给该子文件。</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">请注意，如果重新编译在 &lt;code&gt;'strict'&lt;/code&gt; 中编译的模式，例如通过插值到 &lt;code&gt;'strict'&lt;/code&gt; 之外的另一个模式，则不会再次检查其严格性。这是因为，如果它在严格条件下工作，则必须在非严格条件下工作。</target>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">请注意，如果字符串参数以 &lt;code&gt;-&lt;/code&gt; 或 &lt;code&gt;--&lt;/code&gt; 开头，则将其视为选项。</target>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">请注意，如果将污点字符串添加到 &lt;code&gt;@INC&lt;/code&gt; ，则会报告以下问题：</target>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">注意,如果临时目录是你的当前目录,则不能删除。C</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">注意，如果使用初始化的标量变量，结果将不同： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; 禁止这种做法。</target>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">请注意，如果为单个POD文档解析了多个文件（也许是将来某个 &lt;code&gt;=include&lt;/code&gt; 指令的结果），则为每个解析的文件调用此方法。如果您希望每个文档执行一次某些初始化，则应使用&lt;b&gt;begin_pod（）&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">请注意，如果没有遇到错误， &lt;code&gt;$err&lt;/code&gt; 将引用一个空数组。这意味着 &lt;code&gt;$err&lt;/code&gt; 将始终以TRUE结尾；因此，您需要测试 &lt;code&gt;@$err&lt;/code&gt; 以确定是否发生错误。</target>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">需要注意的是,如果测试有一个尾随的计划,就不能为未计划的测试设置这个属性,因为在达到计划之前,我们不知道它是未计划的。</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">请注意，如果缓存是绑定的哈希，则 &lt;code&gt;flush_cache&lt;/code&gt; 将尝试在哈希上调用 &lt;code&gt;CLEAR&lt;/code&gt; 方法。如果没有 &lt;code&gt;CLEAR&lt;/code&gt; 方法，则将导致运行时错误。</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">请注意，如果已将文件句柄标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则将读取Unicode字符而不是字节（LENGTH，OFFSET和sysread（）的返回值使用Unicode字符）。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。请参见&lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;，&lt;a href=&quot;#open&quot;&gt;打开&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">请注意，如果已将文件句柄标记为 &lt;code&gt;:utf8&lt;/code&gt; ，则将读取Unicode字符而不是字节（LENGTH，OFFSET和sysread（）的返回值使用Unicode字符）。的 &lt;code&gt;:encoding(...)&lt;/code&gt; 层隐含介绍 &lt;code&gt;:utf8&lt;/code&gt; 层。请参见&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;，&lt;a href=&quot;open&quot;&gt;打开&lt;/a&gt;，以及 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 编译指示，&lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">请注意,如果输入的文本是一个只读字符串(即文字),则不会尝试删除提取的文本。</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">请注意，如果平台没有可用的或未启用的 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 和/或 &lt;code&gt;LC_MONETARY&lt;/code&gt; ，则哈希的相应元素将丢失。</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">需要注意的是,如果正则表达式被污染,那么当子程序的名称由污染的数据决定时,Perl会死掉而不是调用子程序。</target>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">请注意,如果PM模块的版本是一个NV(浮点数),它将被字符串化,可能会损失精度(目前砍到小数点后九位),因此它可能与XS模块的版本不匹配了。如果使用较长的版本号,建议引用$VERSION声明使其成为一个字符串。</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">请注意，如果我们和第29行之间有一个子例程调用，而我们想&lt;b&gt;单步执行&lt;/b&gt;，则可以使用' &lt;b&gt;s&lt;/b&gt; '命令，而要跳过它，则可以使用' &lt;b&gt;n&lt;/b&gt; '执行该子例程，但不能进入其中进行检查。但是，在这种情况下，我们仅继续执行第29行：</target>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">注意，如果上面有一个 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，即使在丢弃的行上也将执行它。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">请注意，如果上面的代码中包含一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，它将仅在正则表达式丢弃的行上执行（因为重做跳过了continue块）。连续块通常用于重置行计数器或 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; 。一次性比赛：</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">注意，如果上面有一个 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 块，即使在丢弃的行上也将执行它。如果省略了LABEL，则该命令引用最里面的封闭循环。从Perl 5.18.0开始可用的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; 格式允许在运行时计算标签名称，否则与 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">请注意，如果在尚未加载&lt;a href=&quot;../threads&quot;&gt;线程&lt;/a&gt;时导入该模块，则这些功能将全部变为无操作。这样就可以编写在线程和非线程环境中都可以使用的模块。</target>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">请注意，如果使用此运算符而不是在其内部进行替换，则其行为与 &lt;code&gt;(*PRUNE)&lt;/code&gt; 运算符完全相同。</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">请注意，如果使用gcc，则从Perl 5.9.5开始，将自动编译Perl核心源代码文件（位于源代码分发顶层的文件，而不是ext /下的扩展名）。 &lt;code&gt;-std=c89&lt;/code&gt; ， &lt;code&gt;-ansi&lt;/code&gt; ， &lt;code&gt;-pedantic&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 标志的选择（请参阅cflags.SH）。</target>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">请注意,如果你没有安装Module::Signature,则根本不会进行签名检查。</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">请注意,如果你不打算自己构建perl,可能会欺骗EMX来截断文件名。这是不支持的,请阅读EMX文档来了解如何做。</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">请注意,如果您有</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">请注意，如果您的脚本中的字节上有第八位（例如，在字符串文字中嵌入了Latin-1），则 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 会感到不满意，因为这些字节很可能不是格式正确的UTF-X。如果你想拥有在这种字节 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ，你可以禁用这个编译直到结束块（或文件，如果在顶层）的 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">需要注意的是,如果你把chdir'ed放到了临时目录中,而它随后被清理了(无论是在END块中还是作为对象销毁的一部分),那么你将从File::Path::rmtree()得到一个警告。</target>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">请注意，如果您要查找直到运行时才知道的字符串，则可以将整个循环作为字符串和 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 进行构建，以避免始终重新编译所有模式。再加上未定义 &lt;code&gt;$/&lt;/code&gt; 作为一个记录输入整个文件，这可能会非常快，通常比诸如fgrep（1）之类的专用程序要快。以下内容在文件列表（ &lt;code&gt;@files&lt;/code&gt; ）中扫描单词列表（ &lt;code&gt;@words&lt;/code&gt; ），并打印出包含匹配项的文件的名称：</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">请注意，如果您要查找直到运行时才知道的字符串，则可以将整个循环作为字符串和 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 进行构建，以避免始终重新编译所有模式。再加上未定义 &lt;code&gt;$/&lt;/code&gt; 作为一个记录输入整个文件，这可能会非常快，通常比诸如fgrep（1）之类的专用程序要快。以下内容在文件列表（ &lt;code&gt;@files&lt;/code&gt; ）中扫描单词列表（ &lt;code&gt;@words&lt;/code&gt; ），并打印出包含匹配项的文件的名称：</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">需要注意的是,如果你把一个标量的副本与一个弱引用,副本将是一个强引用。</target>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">请注意，如果您想将许多Pod文档批量转换为HTML，则应该看到模块&lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">请注意，如果要启用模块注册的警告类别（例如， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ），则必须先加载此模块。</target>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">请注意,如果你想把C-local environ数组中的任何元素传递给没有被fork/exec启动的子进程,或者没有运行C程序的子进程,你可以在当前进程中把它们 &quot;推广 &quot;为逻辑名,然后由所有子进程继承,方法是说</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">请注意，如果您使用的是Windows，甚至无法解决这个令人头疼的问题。即使Perl仿真 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; ，您仍然会被卡住，因为Windows没有argc / argv风格的API。</target>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">请注意,如果你的分叉子系统继承了系统文件描述符,比如STDIN和STDOUT,这些文件实际上是通过管道或套接字连接的,即使你退出了,那么远程服务器(比如,CGI脚本或从远程shell启动的后台作业)也不会认为你已经完成了。你应该重新打开那些</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">请注意,在Perl 5.17.3和更早的版本中,最后三个常量也用于变量的插入式变体。</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">请注意，在5.18之前的Perl版本中， &lt;code&gt;fallback&lt;/code&gt; 键的继承不受上述规则的约束。使用第一个过载祖先中的 &lt;code&gt;fallback&lt;/code&gt; 值。在5.18中已修复此问题，以遵循通常的继承规则。</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">请注意,在一些情况下,这种翻译不能完美地传回源代码中--例如,如果循环的初始化器声明了一个my变量,那么它在循环之外就不会有正确的作用域。</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">请注意,在列表上下文中,原始输入文本(第一个参数)的内容不会以任何方式被修改。</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">请注意，在所有情况下，&amp;ldquo; E &amp;lt;whatever&amp;gt;&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">注意，与&lt;a href=&quot;#EXAMPLE-1&quot;&gt;示例1&lt;/a&gt;，&lt;a href=&quot;#EXAMPLE-2&quot;&gt;示例2&lt;/a&gt;和&lt;a href=&quot;#EXAMPLE-3&quot;&gt;示例3相比&lt;/a&gt;，此描述不包含实际内容。</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">请注意，在此模块的较旧版本中，即使如上所述调用了实例方法， &lt;code&gt;error()&lt;/code&gt; 方法也将返回有效的全局值。此后已得到修复，并且 &lt;code&gt;Archive::Tar&lt;/code&gt; 多个实例现在具有单独的错误字符串。</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">请注意，在标量和void上下文中，此参数的值会自动重置为1（在 &lt;code&gt;-w&lt;/code&gt; 下，如果必须重置该参数，则会发出警告）。</target>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">请注意，在上述情况下， &lt;code&gt;thing($foo)&lt;/code&gt; 和 &lt;code&gt;thing($bar)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">请注意,install()没有给出有意义的返回值。参见 uptodate()。</target>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">请注意，任何方法（包括 &lt;code&gt;AUTOLOAD&lt;/code&gt; ）尝试重新分派任何不具有相同名称的方法都是致命错误。例如：</target>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">请注意,通常情况下,将INST_DRV和INST_TOP设置为之前构建时已经存在的路径来构建perl不是一个好主意。特别是,这可能会导致lib/ExtUtils/t/Embed.t测试出现问题,因为该测试试图构建一个测试程序,最终可能会针对已安装的perl的lib/CORE目录而不是被测试的目录构建。</target>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">请注意,引用 __CALLER__::Roo 标识符是很重要的,因为 perl 5.8 中的一个错误会拒绝解析它并导致一个未知的错误。</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">请注意,在一个信号处理程序中访问一个文件句柄是不可取的,因为这个信号已经中断了对同一句柄的I/O操作。虽然perl至少会努力避免崩溃,但并不能保证数据的完整性;例如,一些数据可能会被丢弃或写入两次。</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">请注意，在这种情况下不必调用 &lt;code&gt;PUSHMARK&lt;/code&gt; 。这是因为</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">请注意,创建一个包含已经链接到perl中的依赖库的库是可以的。</target>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">请注意，有可能在多个文件中的同一包中包含 &lt;code&gt;__DATA__&lt;/code&gt; 令牌，并且编译器在给定包中遇到的最后一个 &lt;code&gt;__DATA__&lt;/code&gt; 令牌是文件句柄可访问的令牌。这也适用于 &lt;code&gt;__END__&lt;/code&gt; 和main，即，如果&amp;ldquo; main&amp;rdquo;程序具有 &lt;code&gt;__END__&lt;/code&gt; ，但是该程序&amp;ldquo;需要&amp;rdquo;（_not_&amp;ldquo; use&amp;rdquo; d）的模块具有&amp;ldquo; package main&amp;rdquo;；声明后跟一个' &lt;code&gt;__DATA__&lt;/code&gt; '，然后将 &lt;code&gt;DATA&lt;/code&gt; 文件句柄设置为访问模块中 &lt;code&gt;__DATA__&lt;/code&gt; 之后的数据，而 &lt;code&gt;__END__&lt;/code&gt; 'main'程序中__END__令牌之后的数据，因为编译器遇到了'require'd文件以后。</target>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">需要注意的是,可以通过用Unicode数字来指定东西,并使用转换函数来编写这些可移植的代码。</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">请注意,除了import()和unimport()方法之外,在任何地方调用overload::constant()和overload::remove_constant()函数可能是没有意义的。在这些方法中,它们可以被调用为</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">请注意,无论如何,指定这些类型的范围并不是一个好主意。</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">请注意,它只确认了最低限度的结构(以免被可能包含额外哈希项的派生类所混淆)。</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">请注意,有些线路有测试号,有些线路没有测试号,这是完全可以接受的。但是,当发现有测试号时,必须按顺序排列。以下也是一个错误。</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">注意，有可能使Perl误以为 &lt;code&gt;//&lt;/code&gt; （空的正则表达式）实际上是 &lt;code&gt;//&lt;/code&gt; （定义或运算符）。 Perl通常对此非常好，但是某些病理情况可能会触发此情况，例如 &lt;code&gt;$x///&lt;/code&gt; （是 &lt;code&gt;($x) / (//)&lt;/code&gt; 或 &lt;code&gt;$x // /&lt;/code&gt; ？）并 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; （ &lt;code&gt;print $fh(//&lt;/code&gt; 或 &lt;code&gt;print($fh //&lt;/code&gt; ？）。在所有这些示例中，Perl都将假设您的定义是-或。如果您的意思是空的正则表达式，则只需使用括号或空格来消除歧义，甚至在前缀之前加上带 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 的空正则表达式（因此 &lt;code&gt;//&lt;/code&gt; 变为 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">请注意，就像在C中一样，Perl并没有定义变量&lt;b&gt;何时&lt;/b&gt;递增或递减。您只知道它将在返回值之前或之后的某个时间完成。这也意味着在同一条语句中两次修改变量将导致未定义的行为。避免使用以下语句：</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">请注意，仅因为哈希是以该顺序初始化的，并不意味着它以该顺序出现。请参阅&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;以获取有关如何安排输出顺序的示例。</target>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">请注意，像所有标点符号变量一样，当前不能在 &lt;code&gt;$^W&lt;/code&gt; 上使用my（），只能使用local（）。</target>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">请注意，宏 &lt;code&gt;ST(i)&lt;/code&gt; ， &lt;code&gt;XST_m*()&lt;/code&gt; 和 &lt;code&gt;XSRETURN*()&lt;/code&gt; 在CODE：部分和PPCODE：部分中均能很好地工作。</target>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">请注意，大多数Unicode字符没有分解，因此其分解类型为 &lt;code&gt;&quot;None&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">需要注意的是,多个 &quot;前端 &quot;可以同时接入这个调试API。这是为了方便使用命令行和GUI同时调试,调试调试器等。[听起来不错,但这需要一些严肃的支持 ----GSAR]</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">请注意，&lt;b&gt;-w&lt;/b&gt;标志或 &lt;code&gt;$^W&lt;/code&gt; 都不能用于禁用/启用默认警告。在这种情况下，它们仍然是必需的。</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">请注意，并非所有 &lt;code&gt;siginfo&lt;/code&gt; 值都同时有意义（例如，某些值仅对某些信号有效），并且从Perl角度来看，并非所有值都有意义，因此您应该查阅系统的 &lt;code&gt;sigaction&lt;/code&gt; ，还可能要查阅 &lt;code&gt;siginfo&lt;/code&gt; 文档。</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">请注意,并非所有终端类型都支持所有属性,有些终端可能不支持这些序列中的任何一个。尤其是深色和淡色、斜体、闪烁和隐藏经常不被执行。</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">请注意,并不是所有的显示器都符合 ISO 6429 标准,甚至不符合 X3.64 标准(或者甚至正在尝试符合)。这个模块在不符合这些转义序列的显示器上将无法正常工作,例如在 Windows NT 或 Windows 2000 下的 cmd.exe、4nt.exe 和 command.com。它们可能会被忽略,或者显示为一个ESC字符和一些明显的垃圾。</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">请注意,并不是所有Perl的功能在这些环境下都能使用。这取决于</target>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">注意,并不是所有的不兼容都能找到。</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">请注意，并非所有模块都可以在所有平台上使用。有关可移植性问题的更多信息，请参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;。阅读文档以查看该模块是否可以在您的系统上运行。基本上有三种类别的模块不能在所有平台上&amp;ldquo;开箱即用&amp;rdquo;地工作（有可能重叠）：</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">请注意，并非CPAN可用的所有扩展都可以在Windows环境中工作；您应在&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/上&lt;/a&gt;查看信息，然后再花太多精力在不容易构建的移植模块上。</target>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">请注意,numf是由quant调用的,用于串联所有量化的数字。</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">请注意，较旧的Pod格式化程序可能无法识别八进制或十六进制数字转义符，并且许多格式化程序无法可靠地渲染255以上的字符。（某些格式化程序甚至可能不得不使用Latin-1 / CP-1252字符的折衷渲染，例如渲染 &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; 只是一个普通的&amp;ldquo; e&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">需要注意的是,在Windows上,地址空间分配的粒度是64KB,因此,在Win32 Perl上设置比堆栈更小的堆栈不会节省更多的内存。</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">请注意，在输入（从字符串到数字）时，Perl接受许多形式的 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; 。忽略大小写，并且可以理解特定于Win32的形式（如 &lt;code&gt;1.#INF&lt;/code&gt; )，但在输出时 &lt;code&gt;Inf&lt;/code&gt; 值标准化为Inf和 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">请注意，在某些系统上，返回值为 &lt;code&gt;-1&lt;/code&gt; 可能意味着子进程正在自动获得。有关详细信息和其他示例，请参见&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">请注意，在某些系统上，返回值为 &lt;code&gt;-1&lt;/code&gt; 可能意味着子进程正在自动获得。有关详细信息和其他示例，请参见&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">注意,只有局部的变量变化才会被撤销。代码表达式执行的其他副作用是永久性的。因此</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">请注意,只有perl才能真正解析Perl,所以所有这样的CASE工具都有些不足,尤其是当你不像C程序员那样对Perl进行编程时。</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">注意,op_next不会被操作,节点也不会被释放,那是调用者的责任。它也不会为一个空列表等创建一个新的列表op;使用更高级别的函数,如op_append_elem()来处理。</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">请注意 pad_findlex()是递归的;它沿着 CV 链向上递归,然后向下返回,边走边添加假名条目。必须这样做,因为在 anon 原型中的假名必须在 xlow 中存储到父垫的索引。</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">请注意，当切掉不是简单变量的任何内容时，必须使用括号。这是因为 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 被解释为 &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; ，而不是您可能期望的 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 。同样， &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 被解释为 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">请注意，当切掉不是简单变量的任何内容时，必须使用括号。这是因为 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; 被解释为 &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; ，而不是您可能期望的 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; 。同样， &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; 被解释为 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">请注意，这段代码的一部分是在Adam Kennedy的允许下从&lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;派生的。</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">请注意,pod翻译器应该只看以pod指令开头的段落(这使解析更容易),而编译器实际上知道寻找pod转义,甚至在段落中间。这意味着以下秘密的东西将被编译器和翻译器忽略。</target>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">请注意,关于旧版本 Perl 中的 bug 的报告,尤其是那些表明你还没有测试过当前稳定版 Perl 的报告,很可能会比当前版本中的 bug 得到构建和维护 Perl 的志愿者的关注。</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">注意，将数组反转为自身（如 &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）将在任何可能的情况下保留不存在的元素。即，对于非魔术数组或具有 &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 方法的并列数组。</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">注意，将数组反转为自身（如 &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）将在任何可能的情况下保留不存在的元素。即，对于非魔术数组或具有 &lt;code&gt;EXISTS&lt;/code&gt; 和 &lt;code&gt;DELETE&lt;/code&gt; 方法的并列数组。</target>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">注意,rewinddir()在Windows上也有类似的限制,也不会强制readdir()再次读取目录。只有新打开的目录句柄才会反映目录的变化。</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">请注意,章节名称可能包含标记。例如,如果一个章节的开头是:</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">请注意,不能同时设置精度和准确度。</target>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">请注意,从Perl 5.10.0开始,a //也可以是</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">请注意，从Perl 5.8.1开始，单数v字符串（如 &lt;code&gt;v65&lt;/code&gt; ）不是 &lt;code&gt;=&amp;gt;&lt;/code&gt; 运算符（通常用于将哈希键与哈希值分开）之前的v字符串。而是将它们解释为文字字符串（'v65'）。它们是从Perl 5.6.0到Perl 5.8.0的v弦，但是造成的混乱和破损多于好。像 &lt;code&gt;v65.66&lt;/code&gt; 和 &lt;code&gt;65.66.67&lt;/code&gt; 这样的多数字v 字符串始终始终是v字符串。</target>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">需要注意的是,自Perl 5.16版本以来,这个功能就没有了,但在未来的版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">请注意，跳过空白仅适用于此构造的内部。构成初始 &lt;code&gt;(?[&lt;/code&gt; 。的结束字符之间 &lt;code&gt;])&lt;/code&gt; 之间的任何字符之间不得有任何空格。</target>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">请注意,有些URLs中含有十六进制ASCII码点,以克服字符或协议限制问题。例如,不是每个键盘上都有tilde字符,因此URL的形式是:。</target>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">请注意，函数的某些类型的参数/返回值可能会导致需要手工编辑的XSUB声明/ typemap条目。这样的对象可能是无法与指针（如 &lt;code&gt;long long&lt;/code&gt; ），函数的指针或数组之间进行转换的对象。另请参见&lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;-x的局限性部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">请注意，格式参数 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 中的空格不表示文字空格。如果您使用空格分隔数据，则可能需要 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">请注意,无论指定的LIMIT是多少,拆分为空字符串的EXPR总是产生零字段。</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">请注意,从Perl 5.7.2(也就是5.8.0)和AIX 4.3或更新版本开始,Perl在所谓的运行时链接模式中使用AIX本地动态加载接口,而不是在Perl 5.6.1和更早版本中使用的模拟接口,或者AIX 4.2和更早版本中使用的模拟接口。这一改变确实破坏了与早期 Perl 版本的编译模块的向后兼容性。这一改动是为了使Perl更符合其他应用程序的要求,比如Apache/mod_perl,它们使用的是AIX本地接口。这一改动也使得 Perl 扩展中可以使用带有静态构造函数和反构造函数的 C++代码,而使用仿真接口则是不可能的。</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">请注意,从Unicode 6.1开始,许多块名都有较短的同义词。这些名称总是以新的样式给出。</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">请注意,strtol()和strtoul()可能伪装成Strtol()、Strtoul()、Atol()、Atoul()。也要避免这些。</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">请注意</target>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">请注意， &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%b&lt;/code&gt; （星期几和一年中的月份的缩写）不一定是三个字符宽。</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">注意， &lt;code&gt;-L&lt;/code&gt; 和 &lt;code&gt;-l&lt;/code&gt; 前缀&lt;b&gt;不是必需的&lt;/b&gt;，但是希望扩展名可移植到Unix或OS / 2的作者应该使用前缀，因为Unix（-Unix）/ 2版本的ext（）要求使用它们。</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; 表单通常是可移植的。</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">请注意，可以使用 &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker选项将这些选项添加到MakeMaker生成的任何makefile中。</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">请注意， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 修饰符的特殊之处在于它们只能被启用，而不能被禁用，并且 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 修饰符是互斥的：指定一个取消指定其他修饰符，并且该结构中最多可以出现一个（或两个 &lt;code&gt;a&lt;/code&gt; ）。因此，例如， &lt;code&gt;(?-p)&lt;/code&gt; 在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 下编译时会发出警告； &lt;code&gt;(?-d:...)&lt;/code&gt; 和 &lt;code&gt;(?dl:...)&lt;/code&gt; 是致命错误。</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完毕后，$ ctx对象将自动 &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ，并可用于计算另一个摘要值。如果要计算摘要而不重置摘要状态，请调用$ ctx-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">请注意， &lt;code&gt;digest&lt;/code&gt; 操作实际上是破坏性的一次读取操作。执行完后， &lt;code&gt;Digest::MD5&lt;/code&gt; 对象将自动 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ，并可用于计算另一个摘要值。如果要计算摘要而不重置摘要状态，请调用$ md5-&amp;gt; clone-&amp;gt; digest。</target>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">请注意，其中的 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 宏</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">请注意， &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; 模式会使Pod :: Simple（et al）的运行速度变慢，因为＆Pod :: Simple :: DEBUG不再是常量子了，因此Pod :: Simple（et al）不会通过恒定折叠进行编译。</target>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">请注意，CPU秒是&lt;b&gt;最短的&lt;/b&gt;时间：CPU调度和其他操作系统因素可能会使尝试复杂化，从而花费更多时间。但是，基准测试输出还会告诉您每秒 &lt;code&gt;$code&lt;/code&gt; 运行的次数，这应该比实际花费的秒数更有趣。</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">注意,只要最后的操作是哈希或数组键查找或子程序名,EXPR可以任意复杂。</target>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">注意，G_KEEPERR标志不会传播到内部评估中；这些可能仍然设置 &lt;code&gt;$@&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">请注意，MAP_TARGET值*必须*带有&amp;ldquo; .exe&amp;rdquo;扩展名，否则您将不会创建&amp;ldquo; perl.exe&amp;rdquo;来替换 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">请注意,MD5算法已不如过去那么强大。自2005年以来,很容易产生产生相同MD5摘要的不同信息。似乎仍然很难生成产生特定摘要的电文,但对于依赖摘要来唯一识别电文的应用来说,转而采用更强的算法可能是明智之举。</target>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">请注意， &lt;code&gt;fread&lt;/code&gt; 和 &lt;code&gt;fwrite&lt;/code&gt; 的PerlIO等效项与其C库对应项略有不同：</target>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">请注意,Symbian文件系统是非常挑剔的:它强烈要求使用\而不是/。</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">请注意，上述实现将一个数组 &lt;code&gt;List::Util::shuffle()&lt;/code&gt; 替换为一个数组，这与List :: Util :: shuffle（）不同，后者需要一个列表并返回一个新的随机列表。</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">请注意,以上两个调用会非常啰嗦,因为默认情况下,可达到的内存和泄漏检查是启用的。如果你想只看到纯粹的错误,可以试试。</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">请注意，各个领域的实际含义还没有很好地标准化，不要期望任何伟大的可移植性。在 &lt;code&gt;$sysname&lt;/code&gt; 可能是操作系统的名称，该 &lt;code&gt;$nodename&lt;/code&gt; 可能是主机的名称， &lt;code&gt;$release&lt;/code&gt; 可能是操作系统的（主要）版本号， &lt;code&gt;$version&lt;/code&gt; 可能是（未成年人）版本号操作系统， &lt;code&gt;$machine&lt;/code&gt; 可能是硬件标识符。也许。</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">请注意,如果在至少1.50版本之前没有定义EU_INSTALL_ALWAYS,那么将支持别名EU_ALWAYS。请确保你使用正确的EU_INSTALL_ALWAYS。</target>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">请注意，分配 &lt;code&gt;$\ = $/&lt;/code&gt; 是在处理开关时完成的，因此，如果&lt;b&gt;-l&lt;/b&gt;开关后接&lt;b&gt;-0&lt;/b&gt;开关，则输入记录分隔符可以与输出记录分隔符不同：</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">注意，反斜杠本身是特殊的。如果要匹配反斜杠，则必须用反斜杠转义反斜杠： &lt;code&gt;/\\/&lt;/code&gt; 匹配单个反斜杠。</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">请注意,返回的base64编码字符串并没有被填充为4字节长的倍数。如果你想与其他base64编码的md5摘要互操作,你可能需要在结果中附加多余的字符串&quot;==&quot;。</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">请注意,在Perl中,即使你的代码块只有一行,大括号也是必须的。不过,有一个聪明的方法可以让你的单行条件块更像英语。</target>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">请注意，调用者负责在调用之前适当地增加 &lt;code&gt;val&lt;/code&gt; 的引用计数，并在函数返回NULL时递减它。</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">请注意，如果 &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; 序列中有嵌套格式代码，则该代码可能会分成多个段。在这种情况下，在 &lt;code&gt;handle_code&lt;/code&gt; 调用handle_code之间可能会发出其他标记标签。如果 &lt;code&gt;codes_in_verbatim&lt;/code&gt; 了codes_in_verbatim选项，则逐字记录部分也是如此。</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">请注意,该效果是编译时的,一旦定义后就不可更改。但是,子程序会被传递一个单一参数,如果大小写敏感匹配生效,则该参数为0,如果无大小写匹配生效,则该参数为非零。子程序可能会根据标志的值返回不同的值,一组值将不可改变地对所有大小写敏感匹配生效,另一组值则对所有大小写不敏感匹配生效。</target>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">请注意,在这种情况下,字符串中嵌入的单引号没有任何帮助,因为它们没有被指定为可接受的定界符,因此被视为非定界符(并被忽略)。</target>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">需要注意的是,用lockf(3)构建的仿真并不提供共享锁,它要求FILEHANDLE是以写的意图打开的。这些都是lockf(3)实现的语义。不过大部分系统都是用fcntl(2)锁来实现lockf(3)的,所以不同的语义应该不会影响到太多人。</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">请注意，编码本身&lt;b&gt;不是&lt;/b&gt;形式上有效的语言标签。还要注意，当前您不能从编码返回到它的编码语言标签。</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">请注意，扩展形式表示perl在内部处理此类构造的方式-该选项实际上关闭了B :: Deparse通常执行的反向翻译。另一方面，请注意 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; 与 &lt;code&gt;$x = $y&lt;/code&gt; ：前者在进行赋值之前将$ y的值转换为字符串。</target>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">请注意，仍然需要使用存储的路径进行提取（默认为unzip，将 &lt;code&gt;-d&lt;/code&gt; 指定为pkunzip）。但是，您需要知道在何处提取文件。您还需要手动更改</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">请注意,fcntl(2)对flock(3)的仿真要求FILEHANDLE以读意图打开,使用LOCK_SH,并要求以写意图打开,使用LOCK_EX。</target>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">请注意,同一指定名称下的文件不会被收录两次。</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">请注意,最后的字符串可能比pvlim长7个字符。</target>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">请注意，第一个参数是必需的。将从中解析节号，如果缺少则默认为1。第二个参数当前被忽略，因为&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt;当前在其页面中不包含可链接的ID或锚点名称。子类链接到另一个手册页HTTP服务器。</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">需要注意的是,上面第一条返回的是一个Time::Seconds对象,所以虽然检查该对象会打印出秒数(因为重载的缘故),但也可以通过Time::Seconds API获得该三角区的分、小时、天、周和年数。</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">请注意，这里的一般模式是访问器方法使用 &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; 读取属性的值，并使用 &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; 设置属性的值。对于每个访问器，我通常只提及一种或另一种语法，据我认为您实际上最有可能使用该语法。</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">请注意，全局变量 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; 在不支持 &lt;code&gt;parent&lt;/code&gt; 方法的较旧的Perl 上未定义，在支持该方法但没有 &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; 的Perl上被定义为false，否则为true。</target>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">请注意，此模块中的 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 实现无法提供对压缩文件/缓冲区的真正随机访问。它通过从当前文件偏移解压缩的数据/缓冲，直到它到达未压缩的偏移参数中指定要 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 。对于很小的文件，这可能是可以接受的行为。对于大文件，可能会导致无法接受的延迟。</target>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">请注意,嵌套类的初始化器可以指定为该类的一个对象,也可以指定为对初始化器的引用,这些初始化器被传递给嵌套结构的构造函数。</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">需要注意的是,闹钟和睡眠之间的交互作用是不明确的。</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">请注意,该函数返回的反转列表可能包括非Unicode码点,即任何高于0x10FFFF的码点。Unicode属性在这些码点上没有被定义。您可能希望更改输出,使其不包含这些代码。如果返回的非空列表中还没有这个值的话,只需在它的末尾加上0x110000;如果有的话,则弹出这个值;如</target>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">请注意，为 &lt;code&gt;Case_Folding&lt;/code&gt; 和 &lt;code&gt;Simple_Case_Folding&lt;/code&gt; 属性返回的反转映射不包括Turkic-locale映射。&lt;a href=&quot;#casefold()&quot;&gt;为此&lt;/a&gt;使用casefold（）。</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">注意,Unicode中最大的码点是U+10FFFF。</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">请注意,最后两个项目实际上是相互竞争的项目,都是为MS Windows提供完整的gcc工具链。</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">请注意,前面的&quot;:&quot;已从文件名中删除,所以</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">注意,和普通的关联数组一样,检索到的键的顺序是明显的随机顺序。</target>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">请注意，默认情况下不打印行。请参阅&lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt;以打印行。如果由于某种原因而无法打开以自变量命名的文件，则Perl会警告您，然后移至下一个文件。</target>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">请注意,该列表没有排序。</target>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">请注意,三参数版本的substr()返回的l值就像一颗 &quot;魔弹&quot;;每次分配到它时,它都会记住原始字符串的哪一部分被修改;例如。</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">需要注意的是,映射是Unicode数据文件中指定的映射,要想得到最终的分解,可能需要递归应用。</target>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">请注意，最小匹配量词 &lt;code&gt;*?&lt;/code&gt; ， &lt;code&gt;+?&lt;/code&gt; 和 &lt;code&gt;??&lt;/code&gt; 似乎是嵌套的量词，但不是。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">请注意，对于指数模量小于100的数字，由 &lt;code&gt;%e&lt;/code&gt; ， &lt;code&gt;%E&lt;/code&gt; ， &lt;code&gt;%g&lt;/code&gt; 和 &lt;code&gt;%G&lt;/code&gt; 产生的科学计数法中的指数位数是系统相关的：它可以是三个或更少（零填充）有必要的）。换句话说，十进制的1.23乘以99可以是&amp;ldquo; 1.23e99&amp;rdquo;或&amp;ldquo; 1.23e099&amp;rdquo;。对于 &lt;code&gt;%a&lt;/code&gt; 和 &lt;code&gt;%A&lt;/code&gt; 同样：指数或十六进制数字可能会浮动：特别是Perl配置选项&amp;ldquo; long double double&amp;rdquo;可能会引起意外。</target>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">请注意，与编写扩展名的常规方法相比，仅有的两个更改是在包含Perl标头之前附加了 &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; ，然后是 &lt;code&gt;dTHX;&lt;/code&gt; 在将调用Perl API的每个函数的开始处进行声明。（您会知道哪些函数需要此函数，因为C编译器会抱怨这些函数中有未声明的标识符。）XSUB本身不需要更改，因为XS（）宏已正确定义为在隐式上下文中传递如果需要的话。</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">请注意,odmask并不影响已经编译好的代码,它只会影响任何</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">请注意，如果有选项终止符（默认为 &lt;code&gt;--&lt;/code&gt; ），也会在 &lt;code&gt;@ARGV&lt;/code&gt; 中传递该选项。</target>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">请注意， &lt;code&gt;(?=regexp)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; 中的括号是不捕获的，因为它们是零宽度的断言。因此，在第二个正则表达式中，捕获的子字符串是整个正则表达式本身的子字符串。先行 &lt;code&gt;(?=regexp)&lt;/code&gt; 可以匹配任意正则表达式，但后向 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 仅适用于固定宽度（即固定长度的字符）的正则表达式。因此 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; 可以，但 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; 则不行。先行断言和后向断言的取反版本分别由 &lt;code&gt;(?!regexp)&lt;/code&gt; 和 &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; 表示。如果正则表达式可以</target>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">请注意，emacs的perl模式将适合 &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; （单引号），并且会使缩进和突出显示混乱。无论如何，您可能在新的Perl代码中使用了 &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; ，所以这不应该成为问题。</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">注意,占有式定语修饰语不能与非贪婪式修饰语结合。因为这样就没有意义了。请考虑下面的等价表。</target>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">请注意，该过程将针对使用的每个文件继续增长。另外，可能存在 &lt;code&gt;AUTOLOAD&lt;/code&gt; ed子例程和其他条件，这些条件会导致Perl的符号表增长。您可能需要添加一些逻辑来跟踪进程的大小，或者在一定数量的请求后重新启动自身，以确保将内存消耗降至最低。您还希望尽可能使用&lt;a href=&quot;functions/my&quot;&gt;我&lt;/a&gt;的变量。</target>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">请注意,算法的属性会随着时间的推移而改变,因为算法的分析和机器的增长速度越来越快。例如,如果你的应用程序依赖于 &quot;不可能 &quot;为不同的消息生成相同的摘要,那么明智的做法是,随着所使用的算法越来越弱,可以很容易地插入更强的算法。使用这里记录的接口应该可以使以后改变算法变得容易。</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">请注意,以&quot;_&quot;开头的键对 _AUTO 有免疫力的原因并不是因为下划线字符有什么神奇之处 --我只是想有一种方法让大多数词库键都可以自动,除了少数几个,我随意决定使用一个前导下划线作为信号来区分这几个。</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">注意，所述 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 受隐式范围约束。结果，任何新引入的词法变量或任何修改的捕获缓冲区内容在评估之后都会丢失。调试器是学习Perl的一个很好的环境，但是如果您交互式地尝试使用应该在相同范围内的材料，则将其放在一行中。</target>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">请注意,传递给</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">请注意，源代码是作为单个字符串传递的，因此任何使用 &lt;code&gt;^&lt;/code&gt; 或 &lt;code&gt;$&lt;/code&gt; 检测行边界的正则表达式都需要 &lt;code&gt;/m&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">请注意，特殊变量 &lt;code&gt;$^N&lt;/code&gt; 在代码块中特别有用，可以捕获变量中子匹配的结果，而不必跟踪嵌套括号的数量。例如：</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">请注意，指定的 &lt;code&gt;fail&lt;/code&gt; 行为也适用于嵌套标签。</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">需要注意的是,指定的定界符会自动变成quotemeta'd。</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">请注意，在 &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; 为true 的块中使用 &lt;code&gt;POPs&lt;/code&gt; 弹出堆栈。这是必要的，因为每当</target>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">请注意,无穷大的字符串化形式在不同的平台上有所不同:例如,它可以是任何一个</target>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">请注意，此处的语法为 &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; ，而不是 &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; 。换句话说，在代码表达式的情况下，我们不需要在条件周围加上多余的括号。</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">请注意， &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 中的标签名称没有以&amp;ldquo;：&amp;rdquo; 开头。</target>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">请注意,后面的斜杠是必须的。这将导致配置运行时出现一些无害的警告。</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">需要注意的是,受限操作的陷阱并不是原子性的:如</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">请注意，连字符两侧的两个字符不一定都是字母或数字。尽管不建议使用任何字符，但都可以。 &lt;code&gt;['-?]&lt;/code&gt; 包含一系列字符，但是大多数人不知道这意味着什么字符。此外，如果代码必须在使用不同字符集的平台（例如EBCDIC）上运行，则这些范围可能导致可移植性问题。</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">请注意，用户的参数也作为列表传递到插件的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 函数，例如：</target>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">请注意，每次执行 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时都会解析该值。如果省略EXPR，则求值 &lt;code&gt;$_&lt;/code&gt; 。此格式通常用于将EXPR文本的解析和后续执行延迟到运行时。</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">请注意，每次执行 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 时都会解析该值。如果省略EXPR，则求值 &lt;code&gt;$_&lt;/code&gt; 。此格式通常用于将EXPR文本的解析和后续执行延迟到运行时。</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">请注意， &lt;code&gt;RV&lt;/code&gt; 的值与我们对$ b进行字符串化时看到的数字一致。IV（）内的地址是保存 &lt;code&gt;SV&lt;/code&gt; 当前状态的 &lt;code&gt;X***&lt;/code&gt; 结构的地址。该地址在SV的生命周期内可能会更改。</target>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">请注意,这些值不会被复制,这意味着修改这些值会修改哈希的内容。</target>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">请注意，在编译正则表达式时，变量 &lt;code&gt;$z0&lt;/code&gt; 和 &lt;code&gt;$z1&lt;/code&gt; 不会被替换，就像代码表达式之外的普通变量一样。而是，在perl编译包含文字正则表达式模式的代码的同时，将整个代码块解析为perl代码。</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">注意,有不同的 &quot;长双倍&quot;。Perl会使用编译器所拥有的任何东西。</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">请注意，对于 &lt;code&gt;$0&lt;/code&gt; 的最大长度，存在特定于平台的限制。在最极端的情况下，它可能仅限于原始 &lt;code&gt;$0&lt;/code&gt; 占用的空间。</target>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">请注意，有很多事情不受当前语言环境的影响。任何文字字符都是给定平台的本机字符。因此，&amp;ldquo; A&amp;rdquo;表示在ASCII平台上的代码点65和EBCDIC上的193。如果该语言环境甚至具有&amp;ldquo; A&amp;rdquo;，则在该语言环境中它可能是也可能不是&amp;ldquo; A&amp;rdquo;。同样，特定字符的所有转义序列（例如 &lt;code&gt;\n&lt;/code&gt; 始终表示平台的本机字符。例如，这意味着正则表达式中的 &lt;code&gt;\N&lt;/code&gt; （每个字符，但换行符）都适用于平台字符集。</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">请注意，没有 &lt;code&gt;unlock()&lt;/code&gt; 函数-解锁变量的唯一方法是允许其超出范围。</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">请注意，不能保证 &lt;code&gt;SvPV()&lt;/code&gt; 的返回值等于 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 或 &lt;code&gt;SvPVX(sv)&lt;/code&gt; 包含有效数据，或者对 &lt;code&gt;SvPV(sv)&lt;/code&gt; 的连续调用每次都将返回相同的指针值。这是由于处理重载和&amp;ldquo;写时复制&amp;rdquo;之类的方式造成的。在这些情况下，返回值可能指向临时缓冲区或类似缓冲区。如果您绝对需要SvPVX字段有效（例如，如果您打算写入该字段），请参见&lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">请注意，不再需要导入Tie :: Cycle模块-Attribute :: Handlers会自动进行处理。您甚至可以通过将参数附加到类名，将参数传递给模块的 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 子例程。例如：</target>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">请注意，没有方法可以从C &amp;lt;：temp&amp;gt;对象获取文件句柄。对象本身充当文件句柄。对象isa C &amp;lt;：handle&amp;gt;和isa C &amp;lt;：seekable&amp;gt;，因此所有这些方法均可用。</target>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">请注意，定义给定类的多个子类没有错。这既常见又安全。例如，我们可以定义 &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; 和 &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; 类来区分不同类型的mp3文件。</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">请注意,这些配置选项仅用于生成</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">请注意,这些功能与*nix兼容,与94-95年的老端口不兼容。优先级是绝对的,从 32 到 -95,越低越快。0是默认的优先级。</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">请注意，这些函数使用 &lt;code&gt;SV*&lt;/code&gt; 键，从而简化了处理哈希结构的扩展代码的编写。这些功能还允许传递 &lt;code&gt;SV*&lt;/code&gt; 键来 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 功能，而不必强迫您对键进行字符串化（与之前的一组功能不同）。</target>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">请注意,这些宏只会在</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">需要注意的是,这些问题不应该阻碍实验,因为它们影响小程序的概率很低。</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">请注意,这些例程是</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">请注意,这些统计数据只是摘要。实际性能将取决于访问散列的真实命中率/失误率。如果你关注命中率,建议你使用以下方法来 &quot;放大 &quot;你的哈希值。</target>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">请注意，此API需要在成功解码 &lt;code&gt;NUL&lt;/code&gt; 字符和错误返回（除非设置了UTF8_CHECK_ONLY标志）之间进行歧义处理，因为在两种情况下均返回0。为了消除歧义，返回零时，请查看 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 的第一个字节是否也为0。如果是这样，则输入为 &lt;code&gt;NUL&lt;/code&gt; ; 如果不是，则输入有错误。</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">需要注意的是,现在当我们不产生以下问题时,这个问题就不那么严重了</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">请注意,这种行为与1.00版本的安全模块不同,在1.00版本中,根模块可以用来改变命名空间。该功能已被撤销,有待深入考虑。</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">请注意,转义换行的业务是特定于在调试器中输入的交互式命令。</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">请注意，该类还提供（但不导出）功能Pod :: Simple :: HTMLBatch :: go。这基本上只是 &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 的快捷方式。从命令行进行调用很方便。</target>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">请注意,这不会*崩溃</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">请注意,这并不尊重任何可能生效的locale;它根据平台的本地字符集进行匹配。</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">请注意,这个例子显示了词库的值,而其他例子没有显示(因为它们只在编译时显示)。</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">需要注意的是,这个函数不会</target>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">请注意,这个线束是</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">请注意,这个哈希值不包括数字(如 &quot;64 &quot;或 &quot;x981c&quot;)。</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">请注意，这是从 &lt;code&gt;1.36&lt;/code&gt; 版开始的向后不兼容的更改。</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">注意,这是一个单利运算符,而不是列表运算符。</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">请注意,这是一个实验性的功能,可能会在未来的 Perl 版本中被修改或删除。</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">需要注意的是,一般来说,这种情况不可能出现在那些遗产比较可疑的贝壳上,因为理论上来说,这些贝壳是不存在的。</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">请注意，这与 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; ，后者开始一个新的调度，该调度仅限于搜索当前类的祖先。 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; 可以回退当前类-在 &lt;code&gt;$self&lt;/code&gt; 其他祖先中寻找合适的方法-而 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; 不能。</target>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">请注意，这是罕见的情况下，你不能使用相同的模板为一个 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ，并 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; ，因为 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 不能确定一个重复计数 &lt;code&gt;()&lt;/code&gt; -group。</target>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">请注意,这是</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">请注意,这并不是一个真正意义上的英文单词,它只是连续的非空格字符的块。</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">请注意，此问题排除了许多Macintosh特定的CPAN模块（ &lt;code&gt;Mac::*&lt;/code&gt; ）的构建，因为所需的Apple框架不提供PPC64支持。同样，从Fink或Darwinports下载的文件也不可能提供64位支持。必须使用适当的编译器和链接器标志从源代码重建库。有关更多信息，请参阅Apple的</target>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">请注意,最后这个例子是</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">请注意,这意味着Perl希望其他软件也能以同样的方式工作:如果Perl一直认为STDIN应该是UTF-8,但从其他命令中传来的STDIN却不是UTF-8,那么Perl很可能会抱怨UTF-8格式错误。</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">请注意，这意味着内部模式无法引用外部定义的捕获组。（代码块本身可以使用 &lt;code&gt;$1&lt;/code&gt; 等来引用封闭模式的捕获组。）因此，尽管</target>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">请注意，此方法不会像 &lt;code&gt;on the fly&lt;/code&gt; 那样即时编写；在写出归档文件之前，它仍然将所有文件读入内存。如果有问题，请查阅下面的常见问题解答。</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">请注意,这个方法只是返回以'#'开头的注释。</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">请注意，这仅影响大多数算术和关系&lt;b&gt;运算符如何&lt;/b&gt;处理其操作数和结果，&lt;b&gt;而不影响&lt;/b&gt;如何处理所有数字。具体来说， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 其效果是，在计算算术运算符（+，-，*，/，％，+ =，-=，* =，/ =，％=和一元减）的结果之前，比较运算符（&amp;lt;，&amp;lt; =，&amp;gt;，&amp;gt; =，==，！=，&amp;lt;=&amp;gt;）和按位运算符（|，＆，^，&amp;lt;&amp;lt;，&amp;gt;&amp;gt;，| =，＆=，^ =，&amp;lt;&amp;lt; =，&amp;gt;&amp;gt; =），操作数的小数部分将被截断（或取整），结果的小数部分也将被截断。另外，操作数和结果的范围限于熟悉的二进制补码整数，即32位体系结构上的-（2 ** 31）..（2 ** 31-1）和-（2 ** 63）..（2 ** 63-1）在64位架构上。例如，此代码</target>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">请注意,这个选项在一次转换多个 POD 文件时可能没有用。Unix 命令的手册页的惯例是,即使命令不是大写的,手册页的标题也应该是全大写的。</target>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回一个AV*时,这个类型映射不会递减引用次数。也请参见:T_AVREF_REFCOUNT_FIXED。</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回一个HV*时,这个类型图不会递减引用数。也请参见......T_HVREF_REFCOUNT_FIXED。T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">请注意,当返回对SV*的引用时,这个类型图不会递减引用计数。也请参见......T_SVREF_REFCOUNT_FIXED。T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">请注意，此变量是在Perl 5.14.0中添加的。如果要在旧版本的Perl上检测全局销毁阶段，则可以使用CPAN上的 &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">请注意这个版本号与Storable模块本身的版本号不同。例如Storable v0.7创建文件的格式是v2.0,Storable v2.15创建文件的格式是v2.7。文件格式的版本号只有在增加了一些会使旧版本模块混淆的功能时才会递增。</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">请注意,这将不适用于因缺少依赖性而导致测试失败的发行版。另外,使用 &quot;强制 &quot;可以不考虑历史记录而运行测试。</target>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">请注意,这将产生类似的东西,但它更难读。</target>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">请注意，要创建Bzip2内容，必须安装模块 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">请注意，要创建Bzip2内容，必须安装模块 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 。如果在 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 不可用时尝试创建Bzip2内容，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">请注意，要创建LZMA内容，必须安装模块 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">请注意，要创建Lzma内容，必须安装模块 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 。如果在 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; 不可用时尝试创建Lzma内容，将引发致命错误。</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">请注意,要删除断点,请使用'B'。</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">请注意，终止选项处理仍需要双破折号 &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">请注意,将此属性转为true不会抑制一两种关于很少发生的不可恢复的错误的抱怨。</target>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">请注意，在低于5.8.0的Perls中，Perl使用标准C库的fdopen（）来实现 &lt;code&gt;=&lt;/code&gt; 功能。在许多Unix系统上，当文件描述符超过某个值（通常为255）时，fdopen（）失败。对于Perls 5.8.0和更高版本，（通常）PerlIO是默认值。</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">请注意,在Win32下</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">请注意,在bigint下,结果会被截断为一个整数。</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">请注意，在某些系统（例如OS / 2）下，可能会有不同类型的Perl可执行文件，其中一些可能支持fork，而有些则不支持。尝试将调用Perl的名称更改为 &lt;code&gt;perl_&lt;/code&gt; ， &lt;code&gt;perl__&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">请注意,不幸的是,上述常量都不能保证在特定平台上可用。为了安全起见,你可以用这样的评价来包装导入。</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">请注意，与 &lt;code&gt;\s&lt;/code&gt; （以及 &lt;code&gt;\d&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; ）不同， &lt;code&gt;\h&lt;/code&gt; 和 &lt;code&gt;\v&lt;/code&gt; 始终匹配相同的字符，而不考虑其他因素，例如有效的语言环境或源字符串是否为UTF-8格式。</target>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">请注意,1.00版本的安全模块支持第二个可选参数MASK。该功能已被撤销,等待更深入的考虑。使用下面描述的允许和拒绝方法。</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">请注意，我们现在必须通过循环值作为数组引用，由于 &lt;code&gt;autotie&lt;/code&gt; 机构传递 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 的参数作为一个列表的列表（如在铁::无论例子），</target>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">请注意，当指定一种不包括所有类别的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式时，Perl会忽略排除的类别。</target>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">请注意，当输出到禁用流模式的文件（ &lt;code&gt;Stream&lt;/code&gt; 为0）时，输出文件必须是可搜索的。</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">请注意，与该模块一起构建zlib源时，应忽略 &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 标志（位24、25和26）。</target>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">需要注意的是,当只有一个章节参数时,URL将仅仅是当前文档中一个章节的链接。</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">需要注意的是,当在Win32的默认构建配置中使用perl时(特别是当perl用PERL_IMPLICIT_SYS构建时),每个perl解释器都会维护自己的环境副本,只有主解释器会更新strftime看到的进程环境。</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">请注意，在Linux中使用线程时，这&lt;b&gt;不是&lt;/b&gt;退出线程的好方法，因为在Linux中，进程和线程是一回事（请注意：虽然在2003年初是这种情况，但有些项目正在进行使用Linux中的更多POSIXly语义）。如果不想从线程返回，请分离线程。</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">请注意，当您传递文件句柄时，压缩参数将被忽略，因为所有文件都将逐字打印到您的文件句柄中。如果希望使用文件句柄启用压缩，请改用 &lt;code&gt;IO::Zlib&lt;/code&gt; 或 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; 文件句柄。</target>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在信号（例如SIGALRM）发出信号后， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 是否重新启动取决于实现。参见&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;上的便携笔记 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">请注意，在信号（例如SIGALRM）发出信号后， &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 是否重新启动取决于实现。参见&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;上的便携笔记 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">请注意，尽管 &lt;code&gt;prove&lt;/code&gt; 接受测试（或要测试的事物）列表，但是 &lt;code&gt;new&lt;/code&gt; 具有一组相当丰富的参数。您可能需要仔细阅读此代码，以了解如何使用它们。</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">需要注意的是,虽然上述类别体系目前是严格的等级制度,但不应该假设。</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">需要注意的是,虽然线程本身是独立的执行线程,除非明确共享,否则Perl数据是线程私有的,但线程可以影响进程范围的状态,影响所有的线程。</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">请注意,虽然我们使用了一个漂亮的小脚本来获得这个值,但没有一个简单的方法来实现</target>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">请注意，在带括号的列表中， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符，例如，跳过初始值的分配：</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">请注意，在带括号的列表中， &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 可以用作虚拟占位符，例如，跳过初始值的分配：</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">请注意,在上述所有情况下,您可以通过检查&quot;=over&quot;...&quot;=back &quot;命令后的第一段(非&quot;=cut&quot;,非&quot;=pod&quot;)Pod段来确定哪种类型。&quot;=back&quot;,通过检查&quot;=over &quot;命令后的第一个(非&quot;=cut&quot;,非&quot;=pod&quot;)Pod段。</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">请注意,写是</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">请注意,您</target>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">请注意，您始终必须重新抛出已捕获的异常。使用这些宏，不可能只捕获异常并忽略它。如果必须忽略该异常，则必须使用 &lt;code&gt;call_*&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">请注意，您也可以在单个 &lt;code&gt;FILTER_ONLY&lt;/code&gt; 中应用两个或多个相同类型的过滤器。例如，这是一个仅在正则表达式中应用的简单宏预处理程序，并带有最终的调试过程，可打印出最终的源代码：</target>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">请注意，您还可以将 &lt;code&gt;batch_convert&lt;/code&gt; 作为类方法调用，如下所示：</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">请注意,您也可以使用:</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">请注意，您目前可以&lt;b&gt;不&lt;/b&gt;传递 &lt;code&gt;gzip&lt;/code&gt; 压缩的文件句柄，这是不符合开 &lt;code&gt;IO::Zlib&lt;/code&gt; ，一个 &lt;code&gt;bzip2&lt;/code&gt; 的压缩文件句柄，这是不符合开 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; ，也不包含完整的存档信息的字符串（压缩或未压缩）。这些功能虽然值得，但目前尚未实现。请参阅&amp;ldquo; &lt;code&gt;TODO&lt;/code&gt; 部分。</target>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">注意，您可以定义自己的属性。请参见&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicode中的用户定义字符属性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">请注意，您可以通过URL链接与 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; 匹配来区分其他链接。因此 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; 是URL，但 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; 不是URL 。</target>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">需要注意的是,你也可以通过使用C语言修改File::Temp打开的文件编码。</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">请注意，您可以使用 &lt;code&gt;ls&lt;/code&gt; 命令来列出此路径。</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">请注意,你可以用它来嵌套 &quot;todo &quot;测试。</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">请注意,如果你使用的是安全信号,你就不能可靠地阻断或解除阻断来自其自身信号处理程序的信号。其他信号可以被可靠地阻断或解除阻断。</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">需要注意的是,不能仅根据</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">请注意,你不能显式地解锁一个变量;你只能等待锁退出范围。这可以通过将变量锁定在一个块中来实现。</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">请注意，您无法使用以下命令测试&amp;ldquo; &lt;code&gt;NaN&lt;/code&gt; -ness&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">请注意,您不能在 @EXPORT 或 @EXPORT_OK 中使用标签。</target>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">请注意,你没有(重新)指定方法名。它迫使你总是使用与你开始使用的方法相同的方法名。</target>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">请注意，使用 &lt;code&gt;ARGV&lt;/code&gt; 文件句柄无法以这种方式处理 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 错误。在这种情况下，由于 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;ARGV&lt;/code&gt; 的处理方式不同，因此您必须自己打开 &lt;code&gt;@ARGV&lt;/code&gt; 的每个元素。</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">请注意，使用 &lt;code&gt;ARGV&lt;/code&gt; 文件句柄无法以这种方式处理 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 错误。在这种情况下，由于 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;ARGV&lt;/code&gt; 的处理方式不同，因此您必须自己打开 &lt;code&gt;@ARGV&lt;/code&gt; 的每个元素。</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">请注意,除了用于输出的短语外,你可能还有一些东西存储在词典中:例如,如果你的程序从键盘上接受输入,问一个&quot;(Y/N)&quot;的问题,你可能需要知道 &quot;Y[es]/N[o]&quot;在任何语言中的等价物是什么。你可能还需要知道答案 &quot;y &quot;和 &quot;n &quot;的等价物是什么。你可以将这些信息存储在词典中(比如说,在&quot;~answer_y &quot;和&quot;~answer_n &quot;这两个键下,长的形式是&quot;~answer_yes &quot;和&quot;~answer_no&quot;,其中&quot;~&quot;只是一个临时字符,目的是向程序员/翻译人员表明这些不是用于输出的短语)。</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">请注意，您可以在目录列表中混合使用目录和（非目录）文件，以通过 &lt;code&gt;wanted()&lt;/code&gt; 函数进行搜索。</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">请注意，如果您想翻译编码甚至脚本，在某些情况下用&amp;ldquo; after method&amp;rdquo; 覆盖 &lt;code&gt;maketext&lt;/code&gt; 方法可能会很有用：</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">请注意,您必须为 $new_name 指定一个 Unix 路径,因为根据 tar 标准,存档中的所有文件都必须是 Unix 路径。</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">请注意,您需要安装Module::Signature模块才能执行此操作。</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">请注意,你应该加载这个模块</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">请注意，由于 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 会捕获其他致命错误，因此对于确定是否实现了特定功能（例如 &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ）非常有用。这也是Perl的异常捕获机制，使用die运算符引发异常。</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">请注意，由于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 会捕获其他致命错误，因此对于确定是否实现了特定功能（例如 &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; ）非常有用。这也是Perl的异常捕获机制，使用die运算符引发异常。</target>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">注意，由于 &lt;code&gt;Cycle&lt;/code&gt; 属性在 &lt;code&gt;$data&lt;/code&gt; 变量中接收其参数，因此，如果给该属性一个参数列表，则 &lt;code&gt;$data&lt;/code&gt; 将由一个数组引用组成；否则，它将直接由单个参数组成。由于Tie :: Cycle要求将其循环值作为数组引用传递，因此这意味着我们需要将非数组引用参数包装在数组构造函数中：</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">请注意，出于历史兼容性，还可以使用 &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 代替 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">请注意，如果启用了选项 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 以及auto_abbrev，则可能的参数和选项设置为：</target>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">请注意,如果您希望以非交互方式运行Configure(详见INSTALL文档),要让它选择正确的提示文件,您需要在Configure命令行中提供参数-Dhintfile=riscos。</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">需要注意的是，如果你的代码是在推荐的运行 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; 编译，您将需要声明这些包变量 &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">请注意，与 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;unless&lt;/code&gt; ， &lt;code&gt;when&lt;/code&gt; 语句始终求值为空列表时，失败。</target>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">注意</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">注意 &lt;code&gt;!&lt;/code&gt; 之后 &lt;code&gt;l&lt;/code&gt; ：我们要确保打包一个长整数，因为它是由C编译器编译的。即使在现在，它也仅适用于编译器按上述方式对齐的平台。而且某个地方的人有一个平台却没有。[可能是Cray，其中 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 均为8个字节。:-)]</target>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">请注意，上面的 &lt;code&gt;$]&lt;/code&gt; 不是文字。替换要 &lt;code&gt;5.6.0&lt;/code&gt; 该条目的任何版本的perl，例如5.6.0。与Windows一样，路径必须用分号分隔。</target>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">请注意， &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; 表达式被 &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; 包围。其背后的思想与使 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate' 的经典习语相同：</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">请注意 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; s：自动生成会导致标准运算符的方法不变，例如 &lt;code&gt;-&lt;/code&gt; ，该标准运算符不会更改其两个操作数（用于实现更改操作数的运算符（&amp;ldquo; mutators&amp;rdquo;：此处为 &lt;code&gt;--&lt;/code&gt; 和 &lt;code&gt;-=&lt;/code&gt; ），Perl将undef作为第三个参数传递。这仍然被评估为FALSE，这与操作数没有被交换的事实相一致，但是在这些情况下，子例程有机会改变其行为。</target>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">请注意，LIST是整个前面的前缀，而不是一次一个元素，因此，前面的元素保持相同的顺序。使用 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 进行反向。</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">请注意，LIST是整个前面的前缀，而不是一次一个元素，因此，前面的元素保持相同的顺序。使用 &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; 进行反向。</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">注意对PERL_SET_CONTEXT()的调用。这些调用对于初始化全局状态是必要的,因为全局状态可以跟踪在运行它的特定进程或线程上哪个解释器是 &quot;当前 &quot;解释器。如果你有一个以上的解释器,并且以交错的方式在两个解释器上进行perl API调用,那么应该始终使用它。</target>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">请注意上面几个字节条目前用 &quot;*&quot;标记的空白。这些空白是由合法的UTF-8避免使用非最短编码造成的:从技术上讲,可以用不同的方式对一个代码点进行UTF-8-encode,但这是被明确禁止的,应该始终使用最短的编码(Perl也是这样做的)。</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">注意分号。除了内部代码没有立即执行之外， &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; 与其说是运算符，不如说是声明，就像 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; 。（但是，无论您执行该特定行多少次（除非您处于 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; ），$ coderef仍将引用</target>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">注意以下两种形式。</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">注意在上一个示例中使用 &lt;code&gt;$&lt;/code&gt; 代替 &lt;code&gt;\&lt;/code&gt; 。与&lt;b&gt;sed&lt;/b&gt;不同，我们使用\ &amp;lt;</target>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">注意这里有两个不同的步骤。1)你必须创建Wild.pm并把它放在你的perl lib目录下.2)你需要设置PERL5OPT环境变量。如果你想让argv扩展为默认值,只要在你的默认启动环境中设置PERL5OPT即可。</target>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">请注意，出于性能原因，此接口比 &lt;code&gt;gv_stashpvn&lt;/code&gt; 更为可取。</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">请注意,这是0级补丁的当前值,随时可能发生变化。</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">需要注意的是,这也可能会触发以下结构,如。</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">请注意,此举使得\x{D800}-\x{DFFF}变成了一个禁区,但perl并不禁止使用这个范围内的字符。对perl来说,从x{0000_0000}到x{ffff_ffff}的每一个字符。(*)是</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">注意仍在使用Perl 5.18或更早版本的用户：使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 或 &lt;code&gt;$'&lt;/code&gt; 将减慢程序中&lt;b&gt;所有&lt;/b&gt;正则表达式的使用。请向&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;查询 &lt;code&gt;@-&lt;/code&gt; 以查看不会导致变慢的等效表达式。参见&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt;。从Perl 5.10开始，还可以使用等效变量 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，但是要定义它们，则必须在 &lt;code&gt;/p&lt;/code&gt; （preserve）中指定修饰符。正则表达式。在Perl 5.20中，使用 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 没有速度差异。</target>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">还请注意,当在一个regex上使用/x修饰符时,任何包含当前模式定界符的注释都会导致regex立即终止。换句话说</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">但是,请注意,&quot;=begin&quot;。</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">但请注意,(与大多数其他OO语言不同)Perl并没有以任何方式确保或强制封装。如果你想让对象真正</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">但是请注意，格式代码和Z &amp;lt;&amp;gt;可以出现在L &amp;lt;...&amp;gt;的任何部分（即</target>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">但请注意,这并不总是适用于引用Perl代码。</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">但是,请注意,这限制了某些值的本地化;例如,以下语句在 perl 5.10.0 时死机,出现错误</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">请注意，顺便说一句，每个组中的项目用逗号分隔，而不是 &lt;code&gt;/\s*,\s*/&lt;/code&gt; -分隔。也就是说，您可能期望此支架组：</target>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">注意，可能未指定模块的版本，其值是 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此，如果要测试的是，则使用 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">请注意，从Perl 5.18开始，名称 &lt;code&gt;BELL&lt;/code&gt; 指的是Unicode字符U + 1F514，而不是传统的U + 0007。对于后者，请使用 &lt;code&gt;ALERT&lt;/code&gt; 或 &lt;code&gt;BEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">注意,在这两种情况下,tilde的扩展都是由MakeMaker完成的,而不是perl默认的,也不是由make完成的。</target>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下， &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; 不会导入这些常量。</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下，这些常量不是由 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; 导入的。</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下， &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 不会导入这些常量。</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">注意，默认情况下，这些常量不是由 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 导入的。</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">注意，出于性能原因，强烈建议在可能的 &lt;code&gt;gv_stashpvn&lt;/code&gt; 下使用 &lt;code&gt;gv_stashsv&lt;/code&gt; 代替gv_stashpvn。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注意：除非您是超级用户，并且&lt;b&gt;-U&lt;/b&gt;标志提供给Perl，否则 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会尝试删除目录。即使满足这些条件，也要警告取消目录链接可能会损坏文件系统。最后，许多操作系统不支持在目录上使用 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 。请改用 &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">注意：在此示例中不需要 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ： &lt;code&gt;strftime()&lt;/code&gt; 是POSIX函数，它使用标准的系统提供的 &lt;code&gt;libc&lt;/code&gt; 函数，该函数始终遵循当前的 &lt;code&gt;LC_TIME&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">注意：在某些示例中未显示 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ，因为它不是必需的： &lt;code&gt;strcoll()&lt;/code&gt; 和 &lt;code&gt;strxfrm()&lt;/code&gt; 是POSIX函数，它们使用标准的系统提供的 &lt;code&gt;libc&lt;/code&gt; 函数，这些函数始终遵循当前的 &lt;code&gt;LC_COLLATE&lt;/code&gt; 语言环境。</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注意：除非您是超级用户，并且&lt;b&gt;-U&lt;/b&gt;标志提供给Perl，否则 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会尝试删除目录。即使满足这些条件，也要警告取消目录链接可能会损坏文件系统。最后，许多操作系统不支持在目录上使用 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 。请改用 &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; 。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">注意： &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 将在图层中搜索一个stdio图层。如果找不到，它将调用 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 生成一个新的stdio &lt;code&gt;FILE&lt;/code&gt; 。如果需要，请仅致电 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">注意：要小心，不要修改 &lt;code&gt;@_&lt;/code&gt; 你打电话export_to_level前在所有-或使用你的包的人会变得非常不明原因的结果！</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注:在5.21.0之前,&quot;缺失 &quot;词汇警告类别在内部被定义为与 &quot;未初始化 &quot;类别相同。现在,它是一个独立的顶级类别。</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注:在 Perl 5.8.0 之前,词汇警告类 &quot;deprecated &quot;是 &quot;syntax &quot;类的一个子类。现在,它是一个独立的顶级类别。</target>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">注意：请勿在 &lt;code&gt;$code_point&lt;/code&gt; 使用浮点或负号。</target>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">注:FCC是唯一的,以及四种标准化形式(NF*)。</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">注意：FCD并不总是唯一的，因此复数形式可能彼此等效。 &lt;code&gt;FCD()&lt;/code&gt; 将返回这些等效形式之一。</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">注意：对于某些扩展，Dave Beazley的SWIG系统可能为创建扩展粘合代码提供了更为方便的机制。有关更多信息，请参见&lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">注意:从Mac OS X 10.6 &quot;Snow Leopard &quot;开始,Apple只支持基于Intel的硬件。这意味着你可以安全地跳过这一节,除非你有一台在ppc上运行的旧苹果电脑,或者希望创建一个向后兼容的perl二进制文件。</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">注意：如果字符串不在FCD中，则不能在FCC中。因此， &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; 应该返回 &lt;code&gt;NO&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">注意：如果启用 &lt;code&gt;Sparseseen&lt;/code&gt; ，则您不能依赖所看到的哈希的内容，因为它的内容将是实现细节！</target>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注意：许多人倾向于过度使用 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ，然后惊讶地发现数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; （零长度字符串）实际上是定义的值。例如，如果您说</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注意：许多人倾向于过度使用 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ，然后惊讶地发现数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;&quot;&quot;&lt;/code&gt; （零长度字符串）实际上是定义的值。例如，如果您说</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">注意：Perl的内置 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 函数返回四个值，以秒为单位。</target>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">注:有些人把这一点标点符号俗称为 &quot;呀呀呀 &quot;或 &quot;三点&quot;,但它的真正名称其实是一个省略号。</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">注意:从CPAN下载的某些模块可能需要NetWare相关的API才能在NetWare上构建。然而,其他模块可能会根据模块的类型,在有或没有细微改动的情况下顺利构建。</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">注意：在通过DEC的DFS访问的文件上使用文件访问测试（ &lt;code&gt;-r&lt;/code&gt; ， &lt;code&gt;-w&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; ）时，某些站点报告了问题。具体来说，由于DFS当前不提供对远程卷上文件的扩展文件标头的访问，因此尝试检查ACL失败，并且文件测试将使用 &lt;code&gt;$!&lt;/code&gt; 返回false 。指示该文件不存在。您可以在这些文件上使用 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; ，因为它仅检查基于UIC的保护，然后手动检查C编译器的定义的相应位</target>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">注意：一些供应商提供 &lt;code&gt;strtod()&lt;/code&gt; 和 &lt;code&gt;strtol()&lt;/code&gt; ,但不提供 &lt;code&gt;strtoul()&lt;/code&gt; 。其他确实提供 &lt;code&gt;strtoul()&lt;/code&gt; 的供应商将&amp;ldquo; -1&amp;rdquo;解析为有效值。</target>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">注意：迭代器（ &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ）和文件测试（ &lt;code&gt;'-X'&lt;/code&gt; ）正常运行：如果操作数不是受祝福的glob或IO引用，则将其转换为字符串（使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; 方法'， &lt;code&gt;'0+'&lt;/code&gt; 或 &lt;code&gt;'bool'&lt;/code&gt; ）解释为glob或文件名。</target>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">注意:关键字'lib'会在请求的库不能被加载时发出警告。要抑制警告,请使用'try'代替。</target>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">注意： &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 退货清单源自您当前的perl和您的当前安装。</target>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">注意：对于可以容纳一个字节的代码点使用区域设置规则的策略，对于不能容纳这些代码点的代码点使用Unicode规则的策略并非统一适用。v5.12之前的版本有点偶然。在v5.12中，除了括号中的字符类外，它相当一致地应用于正则表达式匹配；在v5.14中，它已扩展到所有正则表达式匹配项；并在v5.16中执行 &lt;code&gt;\L&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 之类的框操作。为了进行排序，到目前为止，在所有发行版中，系统的 &lt;code&gt;strxfrm()&lt;/code&gt; 函数都将被调用，并且所做的就是您得到的。</target>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">注意:这个功能是在5.57版本的Exporter中引入的,与perl 5.8.3一起发布。</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; 。除了 &lt;code&gt;U+FFFE&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注意：这等效于 &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; 。除 &lt;code&gt;U+FFFF&lt;/code&gt; 以外的任何其他字符都可以通过 &lt;code&gt;entry&lt;/code&gt; 来定制。</target>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">注意:只有当你运行zlib 1.0.6或更高版本时,此方法才可用。</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">注意：从Math :: BigInt 1.78版本开始需要此方法，但是所需的API版本号没有增加，因此有些较旧的库支持API版本1，但不支持 &lt;code&gt;_as_oct()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">注意:这需要安装Math::BigInt::GMP。</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">注意：当$ FTP_PASSIVE为true时， &lt;code&gt;ncftp&lt;/code&gt; 将不用于获取文件，因为只能为此二进制文件以交互方式设置被动模式</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">注意：在列表上下文中调用时，gistime返回的最后一个值$ isdst始终为 &lt;code&gt;0&lt;/code&gt; 。GMT中没有夏令时。</target>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意：也可以用于&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat之&lt;/a&gt;类的子类。每个类都有与Math :: BigInt分开的全局变量，但是可以将Math :: BigInt子类化，并将子类别名的全局变量替换为Math :: BigInt的别名。</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:对Math::BigFloat这样的子类也有效。每个类都有自己的 globals,与 Math::BigInt 分隔开来,但也可以将 Math::BigInt 子类化,并使子类的 globals 与 Math::BigInt 的 globals 别名。</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">注意:你必须修改你的man.conf文件来搜索/ade/lib/perl5/man/man3目录下的manpages,否则将找不到perl库的man页。</target>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">注意：您可能想改用&lt;a href=&quot;#accuracy()&quot;&gt;precision（）&lt;/a&gt;。随着&lt;a href=&quot;#accuracy()&quot;&gt;精度（）&lt;/a&gt;设置每个结果应具有的位数，用&lt;a href=&quot;#precision()&quot;&gt;精密（）&lt;/a&gt;你的地方设置在哪里轮！</target>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling&lt;/code&gt; 也将禁用 &lt;code&gt;bundling_override&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;bundling_override&lt;/code&gt; 也会禁用 &lt;code&gt;bundling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case&lt;/code&gt; 也将禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">注意：禁用 &lt;code&gt;ignore_case_always&lt;/code&gt; 也会同时禁用 &lt;code&gt;ignore_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">注：如果 &lt;code&gt;applypatch&lt;/code&gt; 安装程序和 &lt;code&gt;CPAN::Config&lt;/code&gt; 知道它&lt;b&gt;和&lt;/b&gt;补丁被写入 &lt;code&gt;makepatch&lt;/code&gt; 程序，然后 &lt;code&gt;CPAN.pm&lt;/code&gt; 让 &lt;code&gt;applypatch&lt;/code&gt; 应用补丁。无论 &lt;code&gt;makepatch&lt;/code&gt; 和 &lt;code&gt;applypatch&lt;/code&gt; 可从CPAN在 &lt;code&gt;JV/makepatch-*&lt;/code&gt; 分布。</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">注意:如果计算成本很高,或者哈希有很多元素,你可能想看看Schwartzian变换来缓存计算结果。</target>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">注意：在大多数情况下，尤其是&lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;，这不太合适。</target>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">注意：可以通过将 &lt;code&gt;fallback&lt;/code&gt; 设置为FALSE 来禁用本节中描述的行为（请参见&lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">注意：上一段描述了Perl基于标量自动为对象生成副本构造函数时发生的情况。对于其他情况，请参见&lt;a href=&quot;#Copy-Constructor&quot;&gt;复制构造函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">注意:这个配置变量已经过时了,并将在未来的CPAN.pm版本中被移除。它将被$LANG和$LC_*环境变量系列的约定所取代。</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">注意:这个功能还处于alpha状态,在CPAN.pm的未来版本中可能会改变。</target>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">注意:这是套接字函数家族的一个新成员,所以所有系统可能还不支持。如果系统不支持,试图使用此方法将中止程序。</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">注意:当use_sqlite开启且SQLLite正在运行时,不使用该机制。</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">注意:这种设置配置变量的方法往往比manpage提供了更多关于变量功能的解释。</target>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">注意:你可以在gdb部分定义最多20个转换快捷方式。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Compress::Zlib第1版用户须知。</target>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">实施Pod处理器的注意事项</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">虚空背景下什么都没有(显然)。</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">没有任何记载。</target>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">这里没有什么太不寻常的地方。如果你有可用的交叉编译器,你可以很容易地做到这一点;当以 Solaris x86 为目标时,通常的 Configure 调用看起来像这样。</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">没有任何作用--死。</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">还请注意,警告是在第一次使用对象的那一行报告的。</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">还要注意下面的 &lt;code&gt;grok_bin&lt;/code&gt; ， &lt;code&gt;grok_hex&lt;/code&gt; 和 &lt;code&gt;grok_oct&lt;/code&gt; 函数</target>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">注意这里的LEN是10。(在你的平台上可能会有所不同。)将字符串的长度延长到小于10的长度,然后进行替换。</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">请注意,&quot;private &quot;这个值在任何时候都不会被打印出来。这是因为 $var 只有在 lexical()函数的块中才有这个值,而且它被隐藏在被调用的子程序中。</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">请注意 &lt;code&gt;globmap&lt;/code&gt; 的两个参数如何都是由&amp;lt;&amp;gt;分隔的字符串。这样做是为了使它们看起来更像文件文件-只是语法糖，但是当您希望字符串在视觉上与众不同时，它可以派上用场。封闭的&amp;lt;&amp;gt;是可选的，因此您不必使用它们-实际上，globmap要做的第一件事就是删除这些定界符（如果存在）。</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">注意， &lt;code&gt;new&lt;/code&gt; 构造函数的返回值如何在 &lt;code&gt;while&lt;/code&gt; 循环中用作文件句柄？那就是所谓的</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">请注意，第二个替换在遇到&amp;ldquo; y&amp;rdquo;后如何立即停止匹配。该 &lt;code&gt;*?&lt;/code&gt; 量词有效地告诉正则表达式引擎尽快找到一个匹配项，并将控制权传递给下一行中的任何内容，就像玩马铃薯一样。</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">请注意，此（无原型）函数如何不在乎它是传递实标量还是数组。Perl将所有参数视为 &lt;code&gt;@_&lt;/code&gt; 中的一个大而长且平坦的参数列表。这是Perl的简单参数传递风格的一个亮点。该 &lt;code&gt;upcase()&lt;/code&gt; 函数将很好地工作良好，没有改变 &lt;code&gt;upcase()&lt;/code&gt; 的定义，即使我们给它这样的事情：</target>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">请注意，&amp;ldquo; hello&amp;rdquo;仅打印一次，因为当Perl看到最外面的 &lt;code&gt;(?:)*&lt;/code&gt; 的第六次迭代与零长度的字符串匹配时，它将停止 &lt;code&gt;*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">注意，在上面的代码中， &lt;code&gt;Dump()&lt;/code&gt; 仅打印元素10到13。以下代码将打印所有元素。</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">请注意，使用文件全局模​​式 &lt;code&gt;*.tar.gz&lt;/code&gt; 来匹配 &lt;code&gt;.tar.gz&lt;/code&gt; 文件，然后在替代文件中使用了非常相似的正则表达式来创建新文件名。</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">注意,由于默认的行为是在输入时如果没有默认层就不做任何转换,所以很容易误写代码,通过反复编码数据来不断扩充文件。</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">请注意，两次使用 &lt;code&gt;put&lt;/code&gt; 方法时，都使用变量 &lt;code&gt;$i&lt;/code&gt; 而不是文字值本身来指定记录索引。这是因为 &lt;code&gt;put&lt;/code&gt; 将通过该参数返回插入行的记录号。</target>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">请注意,在这些新的测试用例中,传递给 round 的参数是一个标量变量。你可能想知道是否可以对常量或文字进行舍入。为了看看会发生什么,暂时在Mytest.t中添加以下一行。</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">注意，必须定义变量 &lt;code&gt;ax&lt;/code&gt; 。这是因为 &lt;code&gt;ST&lt;/code&gt; 宏期望它存在。如果我们在XSUB中，则不必定义 &lt;code&gt;ax&lt;/code&gt; ，因为已经为我们定义了斧头。</target>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">请注意,只有仅有遗留代码点的字元(字符串或正则表达式)才会受到影响:如果你把数据混合在一起,像这样</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">请注意，核心 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 可能会舍入而不是截断。这意味着核心 &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; 可能比 &lt;code&gt;gettimeofday()&lt;/code&gt; 和 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; 晚一秒报告时间。</target>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">请注意，最终匹配将匹配 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;p&lt;/code&gt; ，而没有 &lt;code&gt;\G&lt;/code&gt; 锚的匹配将完成。另请注意，最终比赛并未更新 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 仅在 &lt;code&gt;/g&lt;/code&gt; 匹配项上更新。如果最终匹配确实匹配 &lt;code&gt;p&lt;/code&gt; ，那么最好是您运行的是Perl的旧版本（低于5.6.0版）。</target>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">请注意，外括号类型已更改，因此我们的访问语法也已更改。那是因为与C不同，在Perl中，您不能自由地交换数组及其引用。 $ ref_to_AoA是对数组的引用，而@AoA是适当的数组。同样， &lt;code&gt;$AoA[2]&lt;/code&gt; 不是数组，而是数组ref。那么你怎么能写这些：</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">请注意,程序员必须提供必要的C代码,以使真正的rpcb_gettime()函数被调用,并使返回值正确地放在参数栈中。</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">请注意，如果您查看的是平坦的世界地图，那么得出的方向可能会有些出乎意料：在这样的地图投影中，大圆圈通常看起来并不是最短的路线-例如，从欧洲或北美到亚洲的最短路线确实经常越过极地地区。 （常见的墨卡托投影没有&lt;b&gt;将&lt;/b&gt;大圆显示为直线：墨卡托投影中的直线是恒定方位线。）</target>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">请注意，这也会影响 &lt;code&gt;display_format&lt;/code&gt; 方法的返回值：在列表上下文中，将返回整个参数哈希值，而不仅仅是样式参数值。如果您一直在列表上下文中调用 &lt;code&gt;display_format&lt;/code&gt; 方法，则可能与早期版本不兼容。</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">请注意，此示例与上一示例的不同之处仅在于其引用计数。将此与下一个示例进行比较，在下一个示例中，我们转储 &lt;code&gt;$b&lt;/code&gt; 而不是 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">注意，我们不使用 &lt;code&gt;env&lt;/code&gt; 指针。通常将 &lt;code&gt;env&lt;/code&gt; 作为最终参数传递给 &lt;code&gt;perl_parse&lt;/code&gt; ，此处的env被 &lt;code&gt;NULL&lt;/code&gt; 取代，这意味着将使用当前环境。</target>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_c&lt;/code&gt; 不等于 &lt;code&gt;$rho_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">注意，当 &lt;code&gt;$z&lt;/code&gt; 不为0时， &lt;code&gt;$rho_s&lt;/code&gt; 不等于 &lt;code&gt;$rho_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">请注意，您可以选择使用 &lt;code&gt;sv_setpvn&lt;/code&gt; ， &lt;code&gt;newSVpvn&lt;/code&gt; 或 &lt;code&gt;newSVpv&lt;/code&gt; 来指定要分配的字符串的长度，也可以允许Perl通过使用 &lt;code&gt;sv_setpv&lt;/code&gt; 或将0指定为 &lt;code&gt;newSVpv&lt;/code&gt; 的第二个参数来计算长度。但是请注意，Perl将通过使用 &lt;code&gt;strlen&lt;/code&gt; 来确定字符串的长度，该长度取决于以 &lt;code&gt;NUL&lt;/code&gt; 字符结尾且不包含NUL的字符串。</target>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">注意 &lt;code&gt;OBJECT&lt;/code&gt; 属性。MakeMaker在以下位置生成以下变量</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">注意 &lt;code&gt;_&lt;/code&gt; 在上述 &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; ：该 &lt;code&gt;_&lt;/code&gt; 是一个神奇文件句柄，用于缓存来自前面的信息 &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; ，或filetest。</target>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">请注意， &lt;code&gt;Copy&lt;/code&gt; 和 &lt;code&gt;Move&lt;/code&gt; 参数的顺序与 &lt;code&gt;memcpy&lt;/code&gt; 和 &lt;code&gt;memmove&lt;/code&gt; 中使用的顺序不同。</target>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">注意最后两个:你有一个未定义的值,但有一个定义的键!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">注意这两行用&amp;ldquo; XXXXX&amp;rdquo;注释。如果检查类型映射文件（或部分）的第一部分，您会看到双精度类型为T_DOUBLE。在类型映射的INPUT部分中，通过在某个对象上调用例程SvNV，然后将其强制转换为double，然后将其分配给变量arg，来将变量T_DOUBLE分配给变量arg。类似地，在OUTPUT部分中，一旦arg具有最终值，则将其传递到sv_setnv函数，再传递回调用子例程。这两种功能在&lt;a href=&quot;perlguts&quot;&gt;perlguts中&lt;/a&gt;进行了解释；我们稍后将在参数堆栈的部分中进一步讨论&amp;ldquo; ST（0）&amp;rdquo;的含义。</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">请注意使用GV_ADD作为第二个参数。现在可以使用适合数据类型的例程来设置新变量。</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">请注意这些示例中的空白。此构造始终在其中启用 &lt;code&gt;/x&lt;/code&gt; 修饰符。</target>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">注意，我们使用 &lt;code&gt;Perl_pp_add&lt;/code&gt; 而不是 &lt;code&gt;pp_add&lt;/code&gt; -请参阅perlguts中的&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;内部函数&lt;/a&gt;。有了断点，我们可以运行程序：</target>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">Notify用于请求交付状态通知(DSN),但您的SMTP/ESMTP服务可能不会尊重这一请求,这取决于其版本和您网站的SMTP配置。</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">通知服务器,当前的消息应该被发送到所有给定的地址。每个地址都会作为一个单独的命令发送到服务器。如果任何一个地址的发送失败,那么这个过程就会被中止,并且会有一个叫做 &quot;S &quot;的命令。</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWare 从 File::Spec::Win32 继承了其 File::Spec 行为。</target>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">2007 年 11 月;作者:Christophe Grosjean:使 cmpthese 和 timestr 计算时间与样式参数一致,默认为 'all' 而不是 'noc' 了。</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">现在 &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; 总是20加上您传递的$ n，而 &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; 总是555加上传递的$ n。闭包中的$ addpiece会缠住。</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">现在， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; 可以在常量正则表达式（即没有任何运行时变量插值的表达式）中启用新的转义。如&lt;a href=&quot;overload&quot;&gt;重载中所述&lt;/a&gt;，此转换将仅对正则表达式的文字部分起作用。对于 &lt;code&gt;\Y|$re\Y|&lt;/code&gt; 此正则表达式的变量部分需要进行显式转换（但仅当应在$ re中启用 &lt;code&gt;\Y|&lt;/code&gt; 的特殊含义时）：</target>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">现在我将创建一个C程序。</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">现在，所有这些不同的功能似乎都独立存在。您可以调用red（），RED（），blue（），BLUE（），green（）等。此技术可节省编译时间和内存使用，并且不易出错，因为语法检查发生在编译时间。为了创建适当的闭包，匿名子例程中的所有变量都必须是词法，这一点至关重要。这就是 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on循环迭代变量的原因。</target>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">现在你要做的就是让。</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">现在举一个使用G_EVAL的例子。下面是一个Perl子程序,它计算2个参数的差值。如果计算结果是负数,子程序就会调用</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">现在由尼尔&amp;middot;鲍尔斯（Neil Bowers）维护&amp;lt;neilb@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">现在在几条线上建立一个on-the-fly对象(注意反斜杠)。</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">现在改成调用一个Perl子程序,而不是</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">现在检查 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; 是否对某些 &lt;code&gt;$n&lt;/code&gt; 是正确的。</target>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">现在到了聪明的地方。分类帐中仅是收入而非支出的行可能会在第46列结束。因此，我们不想告诉 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 模式&lt;b&gt;需要&lt;/b&gt;再找到12个字符；我们只会说&amp;ldquo;如果还有什么，那就把它拿走&amp;rdquo;。您可能会从正则表达式中猜到，这就是 &lt;code&gt;*&lt;/code&gt; 的含义：&amp;ldquo;使用剩余的所有内容&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">现在编译这个程序(我把它称为</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">现在编译。</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">现在考虑带指数的浮点数。这里的关键观察是</target>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">现在编辑 Mytest2.t 脚本,将测试次数改为 &quot;4&quot;,并在脚本末尾添加以下几行。</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">现在来看一个处理Perl子程序返回的项目的例子。</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">现在进行更复杂的操作： &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">现在，如果$ baz这样重载，则 &lt;code&gt;$baz&lt;/code&gt; 是对中间数组的引用的引用，该中间数组保留对实际数组和访问哈希的引用。访问哈希的tie（）ing对象是对实际数组的引用，因此</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">现在，如果我们看到一个 &lt;code&gt;U&lt;/code&gt; 出现在字符串的开头，则打开输出SV &lt;code&gt;cat&lt;/code&gt; 的 &lt;code&gt;UTF8&lt;/code&gt; 标志：</target>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">现在inner()只能从 outer()内部调用,因为匿名子程序的临时赋值。但是当它这样做的时候,在调用 outer 的时候,它可以从 outer()的作用域中正常访问词法变量 $x。</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">现在是建立静态链接的可执行文件的时候了。</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">现在发出一个所有 Perl Mongers 都喜欢的命令。</target>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">现在看起来真的像二维数组了!</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">现在是时候把你的数据结构打印出来了。你要怎么做呢?如果你只想要其中一个元素,这很简单。</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">现在只要输入任何合法的Perl代码,就会立即被评估。你还可以检查符号表,获取堆栈回溯,检查变量值,设置断点,以及其他典型的符号调试器中的操作。</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">现在让我们为我们的扩展添加一个子程序,它将接受一个单一的数字参数作为输入,如果数字是偶数则返回1,如果数字是奇数则返回0。</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">现在让我们继续表演吧!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">现在让我们看一下 &lt;code&gt;pp_pack&lt;/code&gt; ：将模式放入 &lt;code&gt;pat&lt;/code&gt; ，然后遍历该模式，将每个格式字符依次转换为 &lt;code&gt;datum_type&lt;/code&gt; 。然后，对于每个可能的格式字符，我们将模式中的其他参数（字段宽度，星号等）吞下，并将下一个输入的块转换为指定的格式，并将其添加到输出SV &lt;code&gt;cat&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">现在让我们做一个稍微复杂的例子。这次我们要调用Perl子例程 &lt;code&gt;LeftString&lt;/code&gt; ，它将带有 2个参数-一个字符串（$ s）和一个整数（$ n）。该子例程将只打印字符串的前$ n个字符。</target>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">现在让我们尝试一个更困难的模式。我们将添加一个量词，因此现在有了模式 &lt;code&gt;/foo+/&lt;/code&gt; 。我们将看到， &lt;code&gt;regbranch()&lt;/code&gt; 调用 &lt;code&gt;regpiece()&lt;/code&gt; 的两倍。</target>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">现在由Perl5 Porters维护。</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">现在$ c的数值为5。 &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; $ c的数值变为13。要使模块的用户绝缘，请添加方法</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">现在我们可以使用数组和哈希语法来访问一个对象。</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">现在我们可以将脚本的最后一行改为</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">现在可以通过以下方式完成脚本</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">现在执行与之前相同的步骤,从Makefile.PL文件生成一个Makefile,并运行make。</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">现在进程 &quot;A &quot;更新了数据库,并恰好改变了初始缓冲区中的一些数据。进程 &quot;A &quot;终止,将所有缓存数据冲到磁盘上,并释放数据库锁。此时磁盘上的数据库将正确反映进程 &quot;A &quot;所做的更改。</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">现在重新运行使重建我们新的共享库。</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">现在运行</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">现在在顶层的Makefile.PL上运行perl。注意它也在mylib目录下创建了一个Makefile。运行make,看它是否会cd到mylib目录下,然后在那里也运行make。</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">现在跑。</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">现在假设我们有一个以上的解释器实例同时运行。这是可行的，但 &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; 在构建perl时使用了Configure选项 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 或选项-Dusethreads -Duseithreads。默认情况下，启用这些Configure选项之一 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; 每个解释器全局变量PL_perl_destruct_level设置为 &lt;code&gt;1&lt;/code&gt; ，以便自动进行彻底清除并正确初始化解释器变量。即使您不打算同时运行两个或多个解释器，而是要顺序运行它们，如上例所示，建议您使用 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; 来构建perl 选项，否则在连续运行之间可能无法正确初始化某些解释器变量，并且您的应用程序可能崩溃。</target>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">现在看看你当前的目录。它看起来应该是这样的。</target>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">现在，UNTIE已经存在，类设计者可以确定类功能的哪些部分确实与 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 相关，哪些与被破坏的对象相关。对于给定的类，什么有意义，取决于是否保留内部引用，以便可以在对象上调用与领带无关的方法。但是在大多数情况下，将DESTROY中的功能转移到UNTIE方法可能很有意义。</target>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">现在基本的require()和子程序已经测试完毕,你可以使用</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">既然 &lt;code&gt;Sys::Syslog&lt;/code&gt; 支持&amp;ldquo;本机&amp;rdquo;机制，并且默认情况下已选择该机制，则不鼓励使用 &lt;code&gt;setlogsock()&lt;/code&gt; 函数，因为其他机制在操作系统之间的可移植性较低。建议使用此功能的模块和程序的作者，特别是其 &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; 形式setlogsock（&amp;ldquo; unix&amp;rdquo;）的作者，除非特别希望使用给定的机制（例如TCP或UDP连接到远程服务器），否则应删除所有出现的功能。主办）。</target>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">既然已经测试了Perl的核心，可以并且应该使用&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;。您还可以在测试中使用全套核心模块。</target>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">现在堆栈上有空间，可以使用 &lt;code&gt;PUSHs&lt;/code&gt; 宏将值压入堆栈。推入的值通常需要是&amp;ldquo;致命的&amp;rdquo;（请参阅&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;参考计数和死亡率&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">既然我们已经看到 &lt;code&gt;P&lt;/code&gt; 在起作用，那么我们不妨给 &lt;code&gt;p&lt;/code&gt; 旋转。为什么我们完全需要第二个模板代码来包装指针？答案在于一个简单的事实，即使用 &lt;code&gt;p&lt;/code&gt; 进行 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 保证以空终止的字符串开头于从缓冲区获取的地址，这意味着要返回的数据项的长度：</target>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">现在我们有了 &lt;code&gt;*foo{THING}&lt;/code&gt; 表示法，尽管仍然需要将typeglob用于将新的文件和目录句柄传递到函数中或从函数中传递出来，但它们并没有太多地用于文件句柄操作。这是因为 &lt;code&gt;*HANDLE{IO}&lt;/code&gt; 仅在将HANDLE用作句柄时才有效。换句话说，必须使用 &lt;code&gt;*FH&lt;/code&gt; 来创建新的符号表条目； &lt;code&gt;*foo{THING}&lt;/code&gt; 不能。如有疑问，请使用 &lt;code&gt;*FH&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">现在我们已经把这个模式存储为一个方便的字符串,我们可能会觉得很想把它作为其他模式的一部分。</target>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">现在我们已经介绍了线程的基本知识,是时候进行下一个主题了。数据 线程为数据访问引入了一些复杂的问题,而这些问题是非线程程序永远不需要担心的。</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">现在您知道了问题所在，该如何解决呢？在引入可选的UNTIE方法之前，唯一的方法是使用旧的 &lt;code&gt;-w&lt;/code&gt; 标志。它将发现您调用untie（）的所有实例，并且仍然有对绑定对象的有效引用。如果位于顶部附近的第二个脚本 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; 或与 &lt;code&gt;-w&lt;/code&gt; 标志一起运行，Perl将显示以下警告消息：</target>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">既然您了解了 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 如何查找带有裸词参数的文件，那么幕后还有一些额外的功能。在 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 之前查找&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">既然您了解了 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 如何查找带有裸词参数的文件，那么幕后还有一些额外的功能。在 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 之前查找&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">现在命令行可能是这样的。</target>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">现在输出中的元素之间没有空格，因为 &lt;code&gt;@animals&lt;/code&gt; 的元素只是成为要 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的列表的一部分：</target>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">现在，输出显示 &lt;code&gt;foo&lt;/code&gt; 没有从其调用方获取 &lt;code&gt;@_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">现在解析阶段已完成，完成的树表示Perl解释器执行我们的程序所需执行的操作。接下来，Perl在树上进行了一次尝试以寻求优化：现在将计算诸如 &lt;code&gt;3 + 4&lt;/code&gt; 常量表达式，并且优化器还将查看是否可以用单个操作替换任何多个操作。例如，要获取变量 &lt;code&gt;$foo&lt;/code&gt; ，而不是获取glob &lt;code&gt;*foo&lt;/code&gt; 并查看标量组件，优化器将操作树伪装成op树以使用直接查找所关注标量的函数。主要是优化 &lt;code&gt;peep&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">现在可以用下面的语句在Perl中使用rpcb_gettime()函数。</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">现在想想</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">现在把Perl解析器和单个文件之间的每个逻辑连接看作是一个</target>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">现在输入</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">现在，我们还需要创建一个类型映射，因为默认的Perl当前不支持 &lt;code&gt;const char *&lt;/code&gt; 类型。在上述功能之前，在您的XS代码中包括一个新的TYPEMAP部分：</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">现在我们可以看看第一个($key)变量。</target>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">现在我们可以把 &quot;a &quot;和 &quot;t &quot;匹配起来。</target>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">现在我们可以像使用其他内置函数一样使用该子程序。</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">现在我们有一个特例。该 &lt;code&gt;EXACT&lt;/code&gt; regop有 &lt;code&gt;regnext&lt;/code&gt; 的0。这是因为，如果它匹配它应该再次尝试匹配本身。该 &lt;code&gt;PLUS&lt;/code&gt; regop处理的实际故障 &lt;code&gt;EXACT&lt;/code&gt; regop并进行适当的操作（去regnode 6如果 &lt;code&gt;EXACT&lt;/code&gt; 至少一次匹配，或未能如果没有）。</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">现在，使脚本可执行（ &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ），运行脚本，我们应该看到以下输出：</target>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">现在我们把命令行选项传给Perl,让它去做。</target>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">现在我们跳过另一个角色,接下7个角色。</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">现在我们继续往下进入我们的子程序,这次我们不使用行号,而是使用子程序的名称,后面是现在熟悉的 &quot;v&quot;。</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">现在，我们将运行&amp;ldquo; &lt;code&gt;perl Makefile.PL&lt;/code&gt; &amp;rdquo;。这将创建一个真实的Makefile，满足需求。其输出如下所示：</target>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">现在我们就来测试一下,我们是否把开头的空间业务做对了。</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">现在我们终于可以开始使用了：我们已经编译了Perl字节代码，剩下要做的就是运行它。实际执行是通过以下 &lt;code&gt;runops_standard&lt;/code&gt; 中的runops_standard函数完成的</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">现在当你运行它的时候,perl会抱怨3个未声明的变量,我们会得到4个错误信息,因为一个变量被引用了两次。</target>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">现在你可以添加新的行了。那添加新的列呢?如果你只处理矩阵,通常使用简单赋值是最简单的。</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">现在，您可以检查 &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; 是否。首先将所有内容混为一谈可能是个好主意。</target>
        </trans-unit>
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">现在你可以编译Perl了。种类。</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">现在您可以生成二进制分布。这是通过运行CPAN分发 &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; 的测试来完成的。调整文件</target>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">现在您可以将文件重命名为</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">现在你可以用下面的(SDF)命令启动它。</target>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">现在你可以写</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">现在，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 之一写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">现在你可以了。</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">现在，您不能更改 &lt;code&gt;$PI&lt;/code&gt; ，这可能总体而言是一件好事。这与常量子例程不同，后者在编译时会进行优化。常量子例程是一种原型，不带任何参数并返回常量表达式。有关这些的详细信息，请参见&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; 附注是这些方便的速记。</target>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">现在你检查$is_tiny_prime[$some_number]。</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">现在你有了所有必要的</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">现在，您将整个POD文档作为一棵巨大的大型分析树。您甚至可以使用&lt;b&gt;-expand_seq&lt;/b&gt;选项来&lt;b&gt;解析文本，&lt;/b&gt;以插入各种不同的对象。只是不要期望&lt;b&gt;Pod :: Parser&lt;/b&gt;在那之后知道如何处理它们。那将需要在您的代码中。或者，您也可以插入任何喜欢的对象，只要它符合&lt;b&gt;Pod :: ParseTree&lt;/b&gt;接口即可。</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">现在，您可以在该句柄上使用 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 之类的函数。可能最常见的输入函数是看起来像运算符的函数：</target>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">现在你应该非常小心,外括号类型是一个圆括号,也就是括号。这是因为你要分配给一个@array,所以你需要括号。如果你想要有</target>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">现在,你已经准备好建立。</target>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">现在，您的IO将在ASCII分区上为ASCII，在EBCDIC分区上为EBCDIC。有关更多可能性，请参见PerlIO的文档（无 &lt;code&gt;Encode::&lt;/code&gt; ！）。</target>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">现在， &lt;code&gt;-h24&lt;/code&gt; 将选项 &lt;code&gt;h&lt;/code&gt; 设置为 &lt;code&gt;24&lt;/code&gt; ，但选项包（如 &lt;code&gt;-vxa&lt;/code&gt; 和 &lt;code&gt;-h24w80&lt;/code&gt; )被标记为错误。</target>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">现在， &lt;code&gt;-vax&lt;/code&gt; 将设置选项 &lt;code&gt;vax&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">现在，关于您可能要使用这些处理程序做什么：也许您想记录什么键对于哪个类失败了，然后消失。也许您不喜欢 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，而是想将错误消息发送到STDOUT（或任何位置），然后仅 &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">现在,由于顶层只包含引用,如果你试图用一个简单的print()函数打印出你的数组,你会得到一些看起来不太好的东西,就像这样。</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">现在,想想这个。</target>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">现在，即使 &lt;code&gt;[0-9]&lt;/code&gt; 也可能会困扰多次写入，因此，为了节省击键次数和使正则表达式更具可读性，Perl为常见字符类提供了几种缩写，如下所示。自从引入Unicode以来，除非 &lt;code&gt;//a&lt;/code&gt; 修饰符生效，否则这些字符类不仅仅匹配ASCII范围内的几个字符。</target>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">现在，如果 &lt;code&gt;junk&lt;/code&gt; 与我们要添加的字符串相同，我们可以直接从SV抓取字符串； &lt;code&gt;SvPVX&lt;/code&gt; 是SV中PV的地址。</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">现在,想象一下,我们要为一台具有不同字节顺序的机器打包数据。首先,我们必须弄清楚目标机器上的数据类型到底有多大。让我们假设长数据是32位宽,短数据是16位宽。然后你可以将模板重写为</target>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">现在,让我们扩展前面的例子,同时返回参数的和和差。</target>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">现在，相当多的人拥有Acme Transmogrifier，并且您不得不写一些东西从头开始谈论协议-您几乎可以肯定希望将其纳入模块中。调整级别取决于您：您可能希望类似于&lt;a href=&quot;net/smtp&quot;&gt;Net :: SMTP的&lt;/a&gt;协议级别的模块，然后与类似于&lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Send的&lt;/a&gt;更高级别的模块进行通信。选择是您的，但是您确实想为该服务器协议提供一个模块。</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">现在,就在你刚刚写完上面几行文字之后,你通常要打开ThisProject/I18N/en.pm文件,并立即添加一个条目。</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">现在,运行make将产生类似于这样的输出(为了清晰起见,一些长行被缩短,一些无关的行被删除)。</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">现在，假设您要搜索单个字符 &lt;code&gt;/GX/&lt;/code&gt; 。Perl不了解Martian，因此它将在&amp;ldquo;我是CVSGXX！&amp;rdquo;中找到两个字节&amp;ldquo; GX&amp;rdquo;。字符串，即使该字符不存在：它看起来像是因为&amp;ldquo; SG&amp;rdquo;在&amp;ldquo; XX&amp;rdquo;旁边，但是没有真正的&amp;ldquo; GX&amp;rdquo;。这是个大问题。</target>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">现在，假设您要在XS中使用Perlio图层。我们将使用perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; 函数作为示例。</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">现在,这就是我们的数据解析。我想我们现在可能要做的是把我们的收入和支出合计起来,然后在我们的分类账的末尾再加一行--用同样的格式--说明我们带来了多少钱,花了多少钱。</target>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">现在,以下对你的函数的调用都是完全等价的。</target>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">现在，在命令行上使用 &lt;code&gt;--verbose&lt;/code&gt; 将启用 &lt;code&gt;$verbose&lt;/code&gt; ，如预期的那样。但是它也被允许使用 &lt;code&gt;--noverbose&lt;/code&gt; ，它将通过将 &lt;code&gt;$verbose&lt;/code&gt; 的值设置为 &lt;code&gt;0&lt;/code&gt; 来禁用$ verbose。使用合适的默认值，程序可以找出 &lt;code&gt;$verbose&lt;/code&gt; 默认为false还是使用 &lt;code&gt;--noverbose&lt;/code&gt; 禁用。</target>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">现在，我们知道在标量上下文中， &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; 返回true或false值。但是，在列表上下文中，它返回匹配值 &lt;code&gt;($1,$2,$3)&lt;/code&gt; 。所以我们可以更紧凑地编写代码</target>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">现在，如果您不想将&amp;ldquo; and&amp;rdquo;大写怎么办？只需使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt;并继续处理下一个问题即可。:)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">现在,我们所做的就是在我们的脚本上启动内置的perl调试器。它停在第一行可执行代码处,等待输入。</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">现在,这是怎么回事?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">空的AV指针。</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">空的CV指针。</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">Null HV指针。</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">空SV指针。（在定义 &lt;code&gt;PERL_CORE&lt;/code&gt; 时不再可用。）</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">空字符指针。（在定义 &lt;code&gt;PERL_CORE&lt;/code&gt; 时不再可用。）</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">Nullops显示为 &lt;code&gt;ex-opname&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">运行的迭代次数。</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">要保存的行数?</target>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">有意义的数字的数量。前面的0不计算在内。当一个数中有0或尾数为0时,其准确度可能大于非零位数。例如,123.456的A为6,10203为5,123.0506为7,123.450000为8,0.000123为3。</target>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">使用次数以16位无符号整数形式存储,因此不能超过65535。</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">编号捕捉回调</target>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">数字周围不需要引号。</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">数字密度和宽度</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">括号中的数字表示该属性所匹配的Unicode码点总数。为强调这一点,那些完全不匹配代码点的属性也被列在表格后的单独部分。</target>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">160-255范围内的数字指的是Latin-1字符(Unicode也在此定义了,意义相同)。超过255的数字应理解为指Unicode字符。</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">数值字段</target>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">数值转换</target>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">数字功能</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">数字字元是以下列任何一种浮点或整数格式指定的。</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">数值运算符和数值转换</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Numify返回实例数据的字节数。</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-通往Perl编译器后端的通用接口。</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">对象方法</target>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">面向对象的基础知识</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">面向对象的接口(Object-ORIENTED INTERFACE)。</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK(比如说,这个系统依赖的模块构建在其他发行版的子目录中,或者被列为CPAN::Bundle中的依赖项,但在当前的架构上通过不同的方式支持该功能)。</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">好吧,相对于</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">好，这是一个开始，但是这些空间发生了什么？我们放了 &lt;code&gt;x&lt;/code&gt; ，不是吗？它不应该向前跳吗？让我们看一下&lt;a href=&quot;functions/pack&quot;&gt;包装上的内容&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">好了,让我们再来看看我们的一些数据,事实上,我们将包括标题,以及一个方便的尺子,以便我们可以跟踪我们的位置。</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">好吧，让我们咬一下子弹。这是通过插入模板代码 &lt;code&gt;x&lt;/code&gt; 来获得正确对齐的一种方法，该模板代码不会从列表中获取相应的项目：</target>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">好吧,最后一个其实是混淆Perl比赛的作品。 :-)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">好，接下来是什么？在日期和描述之间是空白列；我们想跳过那个。该 &lt;code&gt;x&lt;/code&gt; 模板的意思是&amp;ldquo;快进&amp;rdquo;，所以我们想其中的一个。接下来，我们还有另一组字符，从12到38。这又是27个字符，因此是 &lt;code&gt;A27&lt;/code&gt; 。（不要使该篱笆错误-在12到38之间有27个字符，而不是26。算上他们！）</target>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">好了,你知道了regexps的基础知识,你想知道更多。如果说匹配正则表达式类似于在树林里散步,那么第1部分讨论的工具就类似于拓扑图和指南针,是我们经常使用的基本工具。第2部分的大部分工具类似于信号枪和卫星电话。它们在徒步旅行中使用的频率并不高,但当我们被困时,它们可能是无价之宝。</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">好了,这就是C部分的工作。这就是C部分的工作。现在,在这个补丁准备就绪之前,我们必须做两件额外的事情:我们已经改变了 Perl 的行为,所以我们必须将这一改变记录下来;我们还必须提供一些回归测试,以确保我们的补丁能够工作,并且不会在其他地方产生错误。我们还必须提供更多的回归测试,以确保我们的补丁能够正常工作,并且不会在其他地方产生错误。</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">旧建筑说明</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">旧的PERL版本</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">一步步向前走</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">一步之遥</target>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">OO INTERFACE</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">OO接口</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">OO Perl</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perl相对简单，并且使用引用来实现，这些引用基于Perl的包概念知道它们属于哪种对象。但是，OO Perl在很大程度上超出了本文档的范围。阅读&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;和&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">OO系统总结</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">选择系统调用的OO接口</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">用户netrc文件的OO接口</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">OOP式</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">OP树</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">OP类缩略语</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">OP旗的缩写</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">OP标志可以是公共的,也可以是私有的。公共标志以一致的方式改变每个操作码的行为,用0或更多的单字符表示。</target>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">与《任择议定书》相关的课程</target>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION是LOCK_SH，LOCK_EX或LOCK_UN之一，可能与LOCK_NB结合使用。这些常量的传统值是1、2、8和4，但是如果从&lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt;模块中分别或通过使用 &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 标记将它们导入，则可以使用符号名。LOCK_SH请求共享锁，LOCK_EX请求排他锁，而LOCK_UN释放先前请求的锁。如果将LOCK_NB与LOCK_SH或LOCK_EX进行按位或运算，则 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 立即返回，而不是阻塞等待锁；检查退货状态以查看是否收到。</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATION是LOCK_SH，LOCK_EX或LOCK_UN之一，可能与LOCK_NB结合使用。这些常量的传统值是1、2、8和4，但是如果从&lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt;模块中分别或通过使用 &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 标记将它们导入，则可以使用符号名。LOCK_SH请求共享锁，LOCK_EX请求排他锁，而LOCK_UN释放先前请求的锁。如果将LOCK_NB与LOCK_SH或LOCK_EX进行按位或运算，则 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 立即返回，而不是阻塞等待锁；检查退货状态以查看是否收到。</target>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">运营商的差异</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">可选子程序/方法超标</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">备选方案和论点</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTS包含创建 &lt;code&gt;$z&lt;/code&gt; 对象时可用的任何选项。</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTS是下列选项的组合:</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">根据RFC3461,ORcpt也是SMTP DSN扩展的一部分。它是用来传递邮件第一次发送的原始收件人。生成DSN的机器会用这个地址通知发件人,因为他无法知道收件人是否会被邮件服务器重写。它的格式应该是RFC3461所要求的,xtext-encoded。</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">操作系统问题</target>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">操作系统调整了ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">操作系统级</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">与操作系统相关的参考资料</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS/2 _.INF_文件</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS/2是OS/2</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">OS/2工具箱</target>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390将支持 &lt;code&gt;#!&lt;/code&gt; shebang 2.8和更高版本中的技巧。对 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 和反引号的调用可以在所有S / 390系统上使用POSIX Shell语法。</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS/390,z/OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">其他组件</target>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">其他设施</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">其他功能</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">输出提示</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">逾越式方法</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">凌驾于核心功能之上的功能</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">课程概述</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">对象方法</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">对象导向并不是每个问题的最佳解决方案。在</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">面向对象的编码器</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">面向对象的时间对象</target>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">AF_INET域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">AF_UNIX域套接字的对象接口。</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">套接字通信的对象接口</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">系统轮询调用的对象接口</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">对象接口:</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">面向对象的接口</target>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">对象注册最好是在初始化对象时进行,以便与一个类一起使用。这样一来,每一个对象和每一个被初始化的字段都建立了垃圾回收和线程安全。</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">对象状态(即对象被祝福成的类)也被克隆。</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">对象有福,变量无福</target>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">代表POD输入段落、命令等的对象。</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">Obscure-设置缓冲区的字节数。已经废弃。只有当PerlIO_canset_cnt()返回true时才可以使用。目前只在doio.c中使用,强制将小于-1的字节数改为-1。也许应该是PerlIO_set_empty或类似的函数。如果 &quot;count &quot;是由指针和 &quot;limit &quot;推导出来的,那么这个调用实际上可能什么都不做,不要使用这个--使用PerlIO_set_empty或类似的函数。不要使用这个-使用 PerlIO_set_ptrcnt()。</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">过时的向后兼容功能</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">过时的、废弃的方法。自5.21版起不再使用。</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">过时。所有之前与之匹配的代码点都已移至 &quot;Script=Common&quot;。可以考虑使用 &quot;Script_Extensions=片假名 &quot;或 &quot;Script_Extensions=平假名&quot;(或两者)。</target>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">获取服务器的响应。成功时,返回状态码的最重要数字。如果失败,超时等。</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">获取所有活跃的新闻组的信息,结果是对哈希的引用,其中键是组名,每个值是对数组的引用。结果是一个哈希引用,其中键是组名,每个值是一个数组的引用。这个数组中的元素是:-该组中最后的文章编号,该组中的第一个文章编号和该组的任何信息标志。</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">获取 &lt;code&gt;stdin&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">获取stdout的属性。</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">获取所有指定消息的标题字段 &lt;code&gt;HEADER&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">获得时间上 &lt;code&gt;HOST&lt;/code&gt; ，或一些默认主机如果 &lt;code&gt;HOST&lt;/code&gt; 如在RFC867中定义未给出或没有定义，使用的协议。可选参数 &lt;code&gt;PROTOCOL&lt;/code&gt; 应该定义要使用的协议 &lt;code&gt;tcp&lt;/code&gt; 或 &lt;code&gt;udp&lt;/code&gt; 。结果将是ASCII字符串或</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">使用RFC868中定义的协议，在 &lt;code&gt;HOST&lt;/code&gt; 上获取时间，或者在未指定或未定义 &lt;code&gt;HOST&lt;/code&gt; 的情况下获取一些默认主机上的时间。可选参数 &lt;code&gt;PROTOCOL&lt;/code&gt; 应该定义要使用的协议 &lt;code&gt;tcp&lt;/code&gt; 或 &lt;code&gt;udp&lt;/code&gt; 。结果将是与time（）返回的单位相同的时间值，或者</target>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">显然，由于所有这些编码字符集下的 &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; ，这些方法中的第一个将无法将大多数ASCII平台与CCSID 0037、1047或POSIX-BC EBCDIC平台区分开。但也请注意，因为在旧版Macintosh（这是ASCII平台）上， &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; ,而 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; ，第二个 &lt;code&gt;$is_ascii&lt;/code&gt; 测试将在此处造成麻烦。</target>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">显然,这是以可以将指针类型化为无符号长指针为前提的,反之亦然,这经常有效,但不应被视为普遍规律。-现在我们有了这个指针,下一个问题是:我们如何才能把它用好呢?我们需要对某个C函数进行调用,在那里我们需要一个指针。我想到了read(2)系统调用。</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">显然,包含补丁的bug是最好的。如果你喜欢,你可以通过匿名签到最新版本的方式打补丁防出血。</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">显然,在OS/2 API签名的最后一种类型的情况下,如果用die()ing来表示失败,对用户来说肯定是更方便的:人们不需要检查$^E就知道出了问题。但是,如果由于某种原因,这种解决方案不可取,那么在调用这个OS/2 API之前,相关代码应该将$^E重置为0,这样这个Perl可访问函数的调用者就有机会区分成功但0-返回值和失败。(可以返回 undef 作为报告错误的另一种方式。)</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">显然，对 &lt;code&gt;complicated&lt;/code&gt; 的第二次调用是在浪费时间，而存储其返回值则是在浪费空间。指定 &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; 将使 &lt;code&gt;memoize&lt;/code&gt; 的使用标量和列表上下文返回值相同的高速缓存，从而使第二调用使用由第一次调用填充标缓存。 &lt;code&gt;complicated&lt;/code&gt; 最终仅被调用一次，并且随后的两个调用都从缓存中返回 &lt;code&gt;3&lt;/code&gt; ，而与调用上下文无关。</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">偶尔需要将被绑定的对象的引用传递给绑定它的TIESCALAR、TIEHASH等。</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">有时，程序员会希望仅在函数失败而不是单独的状态值的情况下返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 或空列表。rpcb_gettime（）函数提供了这种情况。如果函数成功，我们希望它返回时间，如果函数失败，我们希望返回undef。在下面的Perl代码中，$ timep的值将为undef或为有效时间。</target>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">有时，Attribute :: Handlers会费力地将数据参数（ &lt;code&gt;$_[4]&lt;/code&gt; ）转换为可用形式，然后再将其传递给处理程序。</target>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">有时，您不能仅使用 &lt;code&gt;/g&lt;/code&gt; 来使您可能想要的所有更改发生。这是两种常见情况：</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">八角形泄漏</target>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">在括号字符类之外的 &lt;code&gt;\000&lt;/code&gt; 格式的八进制转义符可能与旧的后向引用冲突（请参阅下面的&lt;a href=&quot;#Absolute-referencing&quot;&gt;绝对引用&lt;/a&gt;）。它们都由反斜杠和数字组成。因此，Perl必须使用启发式方法来确定它是反向引用还是八进制转义。Perl使用以下规则来消除歧义：</target>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">当然，&lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt;和&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;会告诉您更多信息。</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">当然， &lt;code&gt;Moose&lt;/code&gt; 不是完美的。</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">当然， &lt;code&gt;vianame&lt;/code&gt; ， &lt;code&gt;viacode&lt;/code&gt; 和 &lt;code&gt;string_vianame&lt;/code&gt; 也将被覆盖。</target>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">当然，在这里，Filter :: Simple在应用过滤器之前也必须知道您正在使用Exporter。几乎从来没有问题，但是如果您对此感到不安，可以通过确保 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; 始终位于 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 之前，确保一切正常。</target>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">当然，如果 &lt;code&gt;@ISA&lt;/code&gt; 仅包含 &lt;code&gt;DynaLoader&lt;/code&gt; ，则根本不需要 &lt;code&gt;@ISA&lt;/code&gt; 分配；此外，如果不是 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 使用更向后兼容</target>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">当然,如果类名用的是标量,Perl也会做对。</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">当然，如果仅遵循&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;的准则，就不需要重新格式化。在编写代码时格式化代码的习惯将有助于防止错误。您的编辑可以并且应该帮助您。 emacs的perl模式或更新的cperl模式可以为大多数（但不是全部）代码提供大量帮助，甚至更少的可编程编辑器也可以提供大量帮助。 Tom Christiansen和许多其他VI用户发誓在vi及其克隆中采用以下设置：</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">当然，在诸如 &lt;code&gt;$obj + 1&lt;/code&gt; 类的上下文中，Perl将调用 &lt;code&gt;$obj&lt;/code&gt; 的 &lt;code&gt;+&lt;/code&gt; 实现，而不是（在此示例中）使用numify方法 &lt;code&gt;'0+'&lt;/code&gt; 将 &lt;code&gt;$obj&lt;/code&gt; 转换为数字（这是因为没有为 &lt;code&gt;'+'&lt;/code&gt; 提供任何方法，并且&lt;a href=&quot;#fallback&quot;&gt;后备&lt;/a&gt;时间设置为TRUE）。</target>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">当然，在使用文字字符串的情况下，可以像使用字符串比较 &lt;code&gt;$string eq 'bert'&lt;/code&gt; 一样容易，这样会更高效。当我们在下面添加功能更强大的regexp工具时， &lt;code&gt;^...$&lt;/code&gt; regexp确实变得很有用。</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">当然，按照这个模块作者的愚见，我更倾向于使用现有的&lt;b&gt;Pod :: ParseTree&lt;/b&gt;对象，而不是简单的数组。这样，其中的所有内容（段落和序列）都将对所有解析树节点响应相同的核心接口。结果如下所示：</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">当然,根据不同的目的选择合适的分隔符串很重要。</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">当然,是否无视它们,由你来决定。</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">当然,我们可以直接用C语言写这种胶水代码,但是,这将是一项繁琐的工作,尤其是当我们需要为多个C函数写胶水,和/或对Perl堆栈纪律和其他类似的奥义不够熟悉的时候。XS在这里救了我们一命:与其用长手写这种胶水C代码,不如用更简洁的短手写一个</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">当然,测试1是$tests[0],等等。</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">当然,节省内存的最好方法是一开始就不做任何浪费内存的事情。良好的编程实践可以在很大程度上实现这一目标。</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">当然,这</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">当然,这需要底层调用支持缓冲器。参见上面关于缓冲区的说明。</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">当然,无论谁问你密码,你都要输入自己的密码,这是不明智的。</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">当然，除非您知道XSUB内某类型 &lt;code&gt;sometype **&lt;/code&gt; C数组中的元素数量，否则将难以解读 &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; 的返回值。由于所有细节都由XS作者（类型映射用户）决定，因此有几种解决方案，其中没有一种特别出色。最常见的解决方案是为N + 1个指针分配内存，并向第（N + 1）个分配 &lt;code&gt;NULL&lt;/code&gt; 以促进迭代。</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">当然，除非您的操作系统未实现access（），否则在这种情况下，编译指示将被忽略。最好不要在filetest编译指示处于活动状态的文件中使用 &lt;code&gt;_&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">当然,你根本不需要临时数组有名字。</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">在转换中,只需要字符串、布尔值或数字中的一个,因为每一个都可以从其他两个中的任何一个生成。</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">在这些属性中,两个重要的属性是 Pattern_Syntax 和 Pattern_White_Space。它们被Unicode设置的目的正是为了决定正则表达式模式中哪些字符应该被引用。任何可以在标识符中的字符都没有这些属性。</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">ISO 3166维护机构的官方主页。</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">顶级域名的官方来源。</target>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">偏移量包含 &lt;code&gt;program&lt;/code&gt; 中偏移量到 &lt;code&gt;precomp&lt;/code&gt; 字符串中的偏移量的映射。这仅由ActiveState的可视化正则表达式调试器使用。</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">通常情况下,允许用逗号分隔的值列表以及选项的多次出现是很有用的。使用Perl的split()和join()运算符就可以轻松实现。</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">为选项提供备用的助记符名称通常是用户友好的。例如 &lt;code&gt;--height&lt;/code&gt; 可以是用于替代名称 &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。可选名称中可以包含其他名称，以竖线 &lt;code&gt;|&lt;/code&gt; 分隔。字符。要实现以上示例：</target>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">通常，还会有另一条与语法错误相关的错误消息给出更多信息。（有时，打开&lt;b&gt;-w会&lt;/b&gt;有所帮助。）错误消息本身通常会告诉您在决定放弃时它在行中的位置。有时实际错误是在此之前的几个标记，因为Perl善于理解随机输入。有时行号可能会引起误解，并且一旦出现蓝月亮，找出导致错误的原因的唯一方法就是反复调用 &lt;code&gt;perl -c&lt;/code&gt; ，每次都切掉一半的程序以查看错误是否消失。是20个问题的控制论版本。</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">通常你想在主模块发行版中手动设置$VERSION,因为这是大家在CPAN上看到的版本,也许你想自定义一下。但是对于你的发行版中的其他模块来说,$VERSION其实只是一个记账的工具,重要的是每次模块被修改时它都会上升。手工做这个很麻烦,你经常会忘记。</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">哦,嗯。这不完全工作。让我们来看看发生了什么。</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">哦，最后一点建议：与您一起喝&lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;。当您返回时，我们希望它会被精心设计。</target>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">好吧,但是当你想真正看到你的数据时,在使用之前,那个动态变量里有什么呢?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">好吧,所以这不是很有趣,因为它没有找到那个特定的文件。但长篇大论的回答在这一页上是不合适的。</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">好的，因此可以有多个Test :: Builder对象，这就是您获取它的方式。如果要测试基于Test :: Builder的模块，则可以使用它代替 &lt;code&gt;new()&lt;/code&gt; ，但是否则您可能需要 &lt;code&gt;new&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">好吧,如果你坚持:&quot;内部格式 &quot;是utf8,不是UTF-8。当它不是其他编码时)。</target>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">面向字节的旧程序应该在适当的时候神奇地开始在面向字符的新数据上工作。</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">旧的面向字节的程序不应该自发地破坏他们过去工作的旧的面向字节的数据。</target>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">旧的perl可执行文件是在新的可执行文件运行时加载了为旧的可执行文件编译的扩展时被启动的(ouph!).在这种情况下,旧的可执行文件会得到一个转发器DLL而不是旧的perl DLL,所以会与新的perl DLL链接。在这种情况下,旧的可执行文件会得到一个转发器 DLL,而不是旧的 perl DLL,所以会与新的 perl DLL 链接。虽然不是直接致命的,但它会和新的可执行文件表现一样。这比显式启动一个旧的可执行文件的目的要好得多。</target>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">旧式与新式区块名称</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">旧的文档(和一些CPAN模块)鼓励这种语法,特别是对于构造函数,所以你可能仍然会在野外找到它。然而,我们鼓励你避免在新代码中使用它。</target>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">VOS的较早版本（OpenVOS 17.0之前的版本）将文件名限制为32个或更少的字符，禁止文件名以 &lt;code&gt;-&lt;/code&gt; 字符开头，并且禁止文件名包含任何与 &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; 匹配的字符。 &amp;lt;=&amp;gt;？//。</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">较早的翻译人员可能会在L &amp;lt;&amp;gt;链接周围添加措辞，例如， &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; 可能会成为&amp;ldquo; Foo :: Bar联机帮助页&amp;rdquo;。因此，如果您希望翻译后的文档明智地阅读，则不应编写 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; 类的东西。而是编写 &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; 或 &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 来控制链接的输出方式。</target>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">旧版本的CPAN.pm在构建目录下有所有tarballs的原始根目录。现在,这些目录名后面总是附加一些随机字符。为什么要这样做呢?</target>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">在这种情况下，本文档的旧版本建议使用 &lt;code&gt;void&lt;/code&gt; 返回值。已经发现，如果XSUB是，则可能导致段错误。</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">Olivier Mengue</target>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">忽略.xs文件中的 &lt;code&gt;constant()&lt;/code&gt; 以及.pm文件中的相应专用 &lt;code&gt;AUTOLOAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">省略所有自动加载功能。这与&lt;b&gt;-c&lt;/b&gt;相同，但也会从.pm文件中删除 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">只要不影响清晰度,就可以省略多余的标点符号。</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">省略XS部分。用于生成框架纯Perl模块。 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-f&lt;/code&gt; 隐式启用。</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">省略自动生成的存根POD部分。</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">省略了创建</target>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">从逻辑上讲，省略 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 部分等效于使用一个空的部分，因此 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 直接返回以检查循环顶部的条件。</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">从逻辑上讲，省略 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; 部分等效于使用一个空的部分，因此 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 直接返回以检查循环顶部的条件。</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">省略第一个参数（输入文本）意味着改为处理 &lt;code&gt;$_&lt;/code&gt; 。省略第二个参数（定括号）表示仅使用 &lt;code&gt;'{'&lt;/code&gt; 。省略第三个参数（前缀参数）在开始时意味着可选的空格。省略第四个参数（最外面的定界括号）表示第二个参数的值将用于最外面的定界符。</target>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">在AIX 4.2上使用xlC,我们继续。</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">在AIX 4.3上使用vac,我们继续。</target>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">在ASCII平台上，上面列出的结果字符是ASCII控件的完整集合。在EBCDIC平台上并非如此。有关ASCII与EBCDIC平台之间差异的完整讨论，请参见&lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdic&lt;/a&gt;中的&amp;ldquo; 运算符差异&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">在ASCII编码的平台上,可以使用以下方法将字符从可打印集之外剥离。</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">在类似DOS的平台上,如果程序不包含目录分隔符,则会先在当前目录中搜索,然后再在PATH上搜索。在Unix平台上,程序将严格在PATH上搜索。</target>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">在DOSISH系统中,反斜线是一个有效的目录分隔符。在这种情况下,使用反斜线作为引号字符(通过GLOB_QUOTE)会干扰反斜线作为目录分隔符的使用。最好的(最简单、最可移植的)解决方案是使用正斜线作为目录分隔符,而使用反斜线作为引号。然而,这并不符合这些系统的 &quot;常规做法&quot;。因此,作为对用户期望的一种让步,反斜线(在 GLOB_QUOTE 下)只引用 glob 元字符 '[',']','{','}','-','~'和反斜线本身。所有其他的反斜杠都会被原封不动地通过。</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">在EBCDIC平台上,Latin 1字符集中的字符被视为UTF-EBCDIC字符的一部分。</target>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">在v5.22之前的EBCDIC平台上，使用 &lt;code&gt;\N{U+...}&lt;/code&gt; 无法正常工作。</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">在EBCDIC平台上，内部Unicode编码形式为UTF-EBCDIC而不是UTF-8。区别在于，由于UTF-8是&amp;ldquo; ASCII安全的&amp;rdquo;，因为ASCII字符按原样编码为UTF-8，而UTF-EBCDIC是&amp;ldquo; EBCDIC安全的&amp;rdquo;，因为所有基本字符（包括所有那些具有ASCII等效项（例如 &lt;code&gt;&quot;A&quot;&lt;/code&gt; ， &lt;code&gt;&quot;0&quot;&lt;/code&gt; ， &lt;code&gt;&quot;%&quot;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">在perl v5.14.0及更高版本的Linux上，除了自arg.4.000起perl所做的那样，除了通过 &lt;code&gt;argv[0]&lt;/code&gt; 更改POSIX名称外，还将使用 &lt;code&gt;prctl(2)&lt;/code&gt; 设置旧进程名称。现在，读取遗留进程名称（例如ps，top和killall）的系统实用程序将在分配给 &lt;code&gt;$0&lt;/code&gt; 时识别您设置的名称。您提供的字符串将被截断为16个字节，这是Linux施加的限制。</target>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">在MSWin32上,每个线程都维护自己的环境变量集。</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">在MSWin32上,每个线程都维护自己的当前工作目录设置。</target>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">在Mac OS上,假设路径的最后一部分是文件名,除非$no_file为真或存在尾部分隔符&quot;:&quot;。</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">在Mac OS上,没有什么可做的。返回它所给的东西。</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">在OS/390或z/OS上,请参见以下内容</target>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">在关闭临时文件时会自动删除临时文件的操作系统上,调用此函数除了删除临时目录(可能包括临时文件)外,没有其他效果。</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">在PA-RISC上,你需要一个不同的编译器来处理32位应用和64位应用。在PA-RISC上,32位对象和64位对象不能混用。句号。HP C-ANSI-C或GNU gcc没有不同的行为。所以,如果你需要你的perl二进制文件使用64位库,比如Oracle-64bit,你必须构建一个64位的perl。</target>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">在POSIX系统上，该程序可能是GNU Make。在Microsoft Windows上，它将是Microsoft NMake，DMake或GNU Make。有关详细信息，请参见&lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt;参数部分。</target>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">在 5.7 之前的 Perl 版本中,值超过 255 的 Unicode 字符(如 lambda 或 emdash)无法传达。这个模块在这样的早期 Perl 版本下确实可以工作,但是在每个这样的字符的位置上,你会得到一个&quot;?&quot;。Latin-1 字符(字符 160-255)不受影响。</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">在路上</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">在Unix上,这些调用可能没有任何影响。在其他地方,它们会改变&quot;\n &quot;到CR,LF的翻译,并可能导致一个特殊的文本 &quot;文件结束 &quot;指示器被写入或在读取时兑现。在对句柄进行任何IO后进行调用的效果取决于实现。(它可能被忽略,也可能影响任何已经被缓冲的数据,或者只适用于后续数据。)</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">在Unix上。</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">在VMS上,默认情况下,%ENV哈希值的变化在perl退出后会持续存在。随后在同一进程中调用perl时,可能会无意中继承本应是临时的环境设置。</target>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">仅在VMS上,记录读取会绕过PerlIO层和任何相关的缓冲,所以不能在同一个文件柄上混合记录和非记录读取。只有当两种模式使用相同的缓冲层时,记录模式才会与行模式混合。</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">在VMS系统中,与环境变量绑定的数组是只读的。试图改变任何东西都会引起警告。</target>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">在VMS上，perl从 &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 逻辑名称确定UTC偏移量。虽然VMS时代开始在11月17日- 1858年00：00：00.00，将呼叫 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; 被调整得从01-JAN-00 1970年数补偿：00：00.00，就像Unix的。</target>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">在VMS上， &lt;code&gt;%ENV&lt;/code&gt; 哈希中的某些条目（如果以前不存在）在读取时使用它们的键来动态创建。已知 &lt;code&gt;$ENV{HOME}&lt;/code&gt; ， &lt;code&gt;$ENV{TERM}&lt;/code&gt; ， &lt;code&gt;$ENV{PATH}&lt;/code&gt; 和 &lt;code&gt;$ENV{USER}&lt;/code&gt; 是动态生成的。动态生成的特定名称可能会随VMS上C库的版本而变化，并且可能存在的名称比记录的名称更多。</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">在有卷概念的VMS上,这个字段将是空的,因为VMS文件规格被转换为绝对的UNIX格式,卷信息被透明地包含在内。</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">在VOS上,时间值是32位的量。</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">在Win32上， &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 需要打开文件以确定链接计数并更新可能已通过硬链接更改的属性。将 &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; 设置为真实值可通过不执行此操作来加快 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 的速度。（Win32的）</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">在Win32平台上,这</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">仅在Win32端口上，可以设置为Perl必须在内部用于执行&amp;ldquo;反引号&amp;rdquo;命令或system（）的备用Shell。在WindowsNT上默认为 &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; ，在Windows95 上默认为 &lt;code&gt;command.com /c&lt;/code&gt; 。该值被视为以空格分隔。在需要保护的任何字符（例如空格或反斜杠）之前都应加上另一个反斜杠。</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">在Win32上，此版本（5.14）中的默认值为&amp;ldquo; unix crlf&amp;rdquo;。Win32的&amp;ldquo; stdio&amp;rdquo;具有许多针对Perl IO的错误/错误功能，这在一定程度上取决于C编译器的版本和供应商。使用我们自己的 &lt;code&gt;crlf&lt;/code&gt; 层作为缓冲区可以避免这些问题，并使事情更加统一。所述 &lt;code&gt;crlf&lt;/code&gt; 层提供CRLF转换以及缓冲。</target>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">在WinNT上， &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 可以更改文件的用户和组ID。在Win9x上， &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; 是no-op，尽管由于没有安全模型，所以这是适当的。</target>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">在Windows上,如果URI是指向网络共享,这个值可能是空的,在这种情况下,'share'属性将被定义。此外,使用'|'作为':'的卷规格将在读取时转换为使用':'。</target>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">在Windows上，如果 &lt;code&gt;make_path&lt;/code&gt; 发出此警告，则可能意味着您已超出文件系统的最大路径长度。</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">在Windows上，只有 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 间接对象​​语法才能可靠地避免使用Shell；如果第一个生成失败，则 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 即使具有多个元素，也将退回到Shell。</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">在Windows上，只有 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 间接对象​​语法才能可靠地避免使用Shell；如果第一个生成失败，则 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; 即使具有多个元素，也将退回到Shell。</target>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">在Windows上，您可以使用&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;模块。为要影响的输出文件句柄创建对象后，调用 &lt;code&gt;Cls&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">在64位 &lt;code&gt;perl&lt;/code&gt; 上，对于那些真正长期运行的项目，您可以获得更大的日期：</target>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">在类似Unix的系统中,这些文档文件通常也会以manpages的形式出现,以便与</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">在一个二进制字符串上,你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">在新的安装中,它是 &quot;C:\\Windows CE Tools&quot;。在文件管理器中转到 &quot;C:\\Windows CE Tools&quot;,看看你的磁盘上是否存在 &quot;C:\\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot;。如果不存在,则需要将SDKROOT改为 &quot;C:\\Program Files\Windows CE Tools&quot;。</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">与此相关的是，如果您确实使用 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; ，那么您将需要在变量声明中使用 &lt;code&gt;dTARG&lt;/code&gt; ，以便 &lt;code&gt;*PUSH*&lt;/code&gt; 宏可以使用局部变量 &lt;code&gt;TARG&lt;/code&gt; 。另请参见 &lt;code&gt;dTARGET&lt;/code&gt; 和 &lt;code&gt;dXSTARG&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">成功匹配后， &lt;code&gt;$REGERROR&lt;/code&gt; 变量将设置为FALSE，而 &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为最后执行的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 模式的名称。有关更多详细信息，请参见下面的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 动词说明。</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">在一个文本字符串上,你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">在除MSWin32之外的所有平台上，当前工作目录的设置在所有线程之间共享，因此在一个线程中更改它（例如，使用 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; ）将影响应用程序中的所有线程。</target>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">在所有已发布的Solaris版本(8、9和10)上,你需要确保安装了以下软件包(此信息摘自Solaris FAQ)。</target>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">在某些平台上，例如Win32，OS / 2，VMS和AIX，有必要在调用链接器之前执行一些操作。该 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; 模块做到这一点，写创作动态扩展的共享库的过程中所使用的连接文件。写入的所有文件的名称将作为列表返回。</target>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">在某些平台上,例如Windows,并不是所有由stat()返回的字段都可以进行比较。例如,在C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新消息队列时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新的信号量集时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">创建新的共享内存段时，将使用 &lt;code&gt;FLAGS&lt;/code&gt; 设置权限。注意不要设置Sys V IPC实现不允许的任何标志：在某些系统中，设置执行位会使操作失败。</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIO层和PerlIO::*名称空间根的按需加载器。</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">每行上都有两个执行相同操作的表达式。左侧版本在数组 &lt;code&gt;@a&lt;/code&gt; 上操作。右边的版本在 &lt;code&gt;$aref&lt;/code&gt; 所引用的数组上运行。一旦找到要操作的阵列，两个版本会对阵列执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">入职时</target>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">出错时， &lt;code&gt;$out&lt;/code&gt; 将是</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">错误时， &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的行为与select（2）相同：它返回-1并设置 &lt;code&gt;$!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">出现错误时， &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会告诉您无法删除哪些文件。如果您想知道无法删除的文件，请一次尝试一个：</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">错误时， &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 的行为与select（2）相同：它返回-1并设置 &lt;code&gt;$!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">出现错误时， &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 不会告诉您无法删除哪些文件。如果您想知道无法删除的文件，请一次尝试一个：</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">错误时,它返回一个</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">失败时，将返回 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ,并且 &lt;code&gt;$@&lt;/code&gt; 将包含失败的原因。</target>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">失败时,$decoder现在包含一个错误信息,所以整个事情会如下。</target>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">失败时，所有这些值（其余文本除外）均为 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">如果失败，则将 &lt;code&gt;$REGERROR&lt;/code&gt; 变量设置为动词模式的ARG值，如果该动词与匹配失败有关。如果省略了模式的ARG部分，则 &lt;code&gt;$REGERROR&lt;/code&gt; 将设置为最后执行的 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 模式的名称，如果没有，则设置为TRUE。同样， &lt;code&gt;$REGMARK&lt;/code&gt; 变量将设置为FALSE。</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">失败时， &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 调用将返回一个未定义的值，并可能设置 &lt;code&gt;$!&lt;/code&gt; 包含无法绑定文件的原因。</target>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">在输入时,它将指定字符集和编码中预期的字节转换为Perl字符串数据(Unicode和Perl内部的Unicode编码,UTF-8)。在输出时,它将Perl字符串数据转换为指定的字符集和编码。</target>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">在大多数Unix平台上， &lt;code&gt;CHLD&lt;/code&gt; （有时也称为 &lt;code&gt;CLD&lt;/code&gt; ）信号相对于 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 值具有特殊的行为。设置 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 以 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 时，父进程没有这样的平台上还没有创建僵尸进程的影响 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 在其子进程（即子进程会自动收获）。调用 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; 的使用 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; 设置为 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 通常返回 &lt;code&gt;-1&lt;/code&gt; 在这样的平台。</target>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">在大多数操作系统上,分配给程序的内存永远不能返回给系统。这就是为什么长期运行的程序有时会重新执行自己。一些操作系统(特别是使用mmap(2)来分配大块内存的系统)可以回收不再使用的内存,但是在这样的系统中,perl必须被配置和编译成使用操作系统的malloc,而不是perl的。</target>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">在大多数系统上，频繁且连续地创建和销毁线程可能导致Perl解释器的内存占用量不断增加。虽然仅启动线程然后 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 或 &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; 很简单，但对于寿命长的应用程序，最好维护线程池，并使用&lt;a href=&quot;thread/queue&quot;&gt;队列&lt;/a&gt;将其重新用于需要的工作通知线程即将进行的工作。此模块的CPAN分发包含一个简单的示例（</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">在大多数系统中,除非你是超级用户,否则你不允许改变文件的所有权,尽管你应该能够将组改为你的任何一个辅助组。在不安全的系统中,这些限制可能会被放宽,但这不是一个可移植的假设。在POSIX系统上,你可以这样检测这种情况。</target>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">在较新的64位版本的OpenVMS上,进程设置现在可以控制是否需要引用来保留命令行参数的大小写。</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">在较早版本的perl上，已知负epoch（ &lt;code&gt;time_t&lt;/code&gt; ）值在某些系统上不起作用，而负epoch（time_t）值尚未得到POSIX标准的正式支持。这些包括MacOS（pre-OSX）和Win32。</target>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">在有卷的概念的操作系统上,文件://的第二个元素被认为是文件的卷规格。因此,在Win32上,这个例程返回卷,而在其他操作系统上,它不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">在perl 5.12.0和更新的版本中,完全支持负的epoch值。</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">在低于5.12.0的perl版本中，可以实际处理的日期范围取决于给定平台上 &lt;code&gt;time_t&lt;/code&gt; （通常是带符号整数）的大小。目前，对于大多数系统来说，这是32位，大约范围是1901年12月到2038年1月。</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">在 &lt;code&gt;need_prelink()&lt;/code&gt; 返回true的平台上， &lt;code&gt;prelink()&lt;/code&gt; 将被自动调用。</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">在重要的平台上，请确保在传递给Storable函数的描述符上调用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">在C99之前的编译器上， &lt;code&gt;bool&lt;/code&gt; 定义为等效于 &lt;code&gt;char&lt;/code&gt; 。因此，将任何较大的类型分配给 &lt;code&gt;bool&lt;/code&gt; 都是不安全的，并且可能会被截断。该 &lt;code&gt;cBOOL&lt;/code&gt; 宏的存在是为了正确地投放。</target>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">在极少数情况下,如数据库读取,你可能会得到需要解码的编码文本。</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">返回时,引用将覆盖*some_hash typeglob指定的符号表中的哈希槽。当你不希望必须记住显式去引用变量时,这是一种廉价传递引用的有点棘手的方法。</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">在简单的组中，例如模式 &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; ，可以通过负前瞻实现类似的效果，如 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; 。对于1000000 &lt;code&gt;a&lt;/code&gt; s 的字符串，这仅慢4倍。</target>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">在某些（但不是全部）操作系统上，分配给 &lt;code&gt;$0&lt;/code&gt; 会修改 &lt;code&gt;ps&lt;/code&gt; 程序看到的参数区域。在某些平台上，您可能必须使用特殊的 &lt;code&gt;ps&lt;/code&gt; 选项或其他 &lt;code&gt;ps&lt;/code&gt; 来查看更改。修改 &lt;code&gt;$0&lt;/code&gt; 作为指示当前程序状态的一种方法，比隐藏您正在运行的程序更有用。</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">在某些操作系统上,.有特殊含义的VERSION_SYM可以用来代替VERSION。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
