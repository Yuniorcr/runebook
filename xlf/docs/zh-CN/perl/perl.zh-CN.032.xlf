<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="77df0281a5c47be5d00ae61a57ff00e23d9d5e5b" translate="yes" xml:space="preserve">
          <source>EXPORTABLE FUNCTIONS</source>
          <target state="translated">可扩展的功能</target>
        </trans-unit>
        <trans-unit id="22d0596dab83a0920d66ad899d3e61f47464b88e" translate="yes" xml:space="preserve">
          <source>EXPORTABLE VARIABLES</source>
          <target state="translated">外销品种</target>
        </trans-unit>
        <trans-unit id="43aade251566381046f1d9dd6f51422fde3c0fbd" translate="yes" xml:space="preserve">
          <source>EXPORTED FUNCTIONS</source>
          <target state="translated">导出的功能</target>
        </trans-unit>
        <trans-unit id="8b30e3050a39fae8e0c617ff76ab8d47b5f0b044" translate="yes" xml:space="preserve">
          <source>EXPORTED SYMBOLS</source>
          <target state="translated">出口符号</target>
        </trans-unit>
        <trans-unit id="e9e012170f2df7cb18fa26019e2b46cbf4a91319" translate="yes" xml:space="preserve">
          <source>EXPORTS</source>
          <target state="translated">EXPORTS</target>
        </trans-unit>
        <trans-unit id="7b479848a0ec11ad7c3ba1025f3ac20068015bb9" translate="yes" xml:space="preserve">
          <source>EXPORTS (by request only)</source>
          <target state="translated">出口(应要求)</target>
        </trans-unit>
        <trans-unit id="6b6562ec1f5d1b67f0bbd288b913382cd128ba1e" translate="yes" xml:space="preserve">
          <source>EXPORT_LIST: name of a file that is passed to linker to define symbols to be exported.</source>
          <target state="translated">EXPORT_LIST:传递给链接器的文件名,用于定义要导出的符号。</target>
        </trans-unit>
        <trans-unit id="a6fc3ffe71e48b679d9c5609def42ab3c69aa49f" translate="yes" xml:space="preserve">
          <source>EXPORT_OK</source>
          <target state="translated">EXPORT_OK</target>
        </trans-unit>
        <trans-unit id="f817892a6b7b040f6bf499b1ab6645711184a4f1" translate="yes" xml:space="preserve">
          <source>EXPR</source>
          <target state="translated">EXPR</target>
        </trans-unit>
        <trans-unit id="62af5da98ccf954a1bd12d8422eab969d058949e" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; in &lt;a href=&quot;english&quot;&gt;English&lt;/a&gt;)). This is the internal function implementing the &lt;code&gt;qx/EXPR/&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;qx/EXPR/&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&quot;&lt;code&gt;qx/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;&quot; in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3499643610f3dd44dae6eb02d7fed2d648b428d9" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR作为系统命令执行。返回所收集命令的标准输出。在标量上下文中，它作为单个（可能是多行）字符串返回。在列表上下文中，返回行列表（但是您已经使用 &lt;code&gt;$/&lt;/code&gt; 或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 定义了行）。这是实现 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。的 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 操作者进行更详细讨论的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f586c420e6eaf4cfbda37e4566d4c88b6984ca54" translate="yes" xml:space="preserve">
          <source>EXPR is executed as a system command. The collected standard output of the command is returned. In scalar context, it comes back as a single (potentially multi-line) string. In list context, returns a list of lines (however you've defined lines with &lt;code&gt;$/&lt;/code&gt; or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; ). This is the internal function implementing the &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator, but you can use it directly. The &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; operator is discussed in more detail in &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;. If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPR作为系统命令执行。返回所收集命令的标准输出。在标量上下文中，它作为单个（可能是多行）字符串返回。在列表上下文中，返回行列表（但是您已经使用 &lt;code&gt;$/&lt;/code&gt; 或 &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 定义了行）。这是实现 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 运算符的内部函数，但是您可以直接使用它。的 &lt;code&gt;&lt;a href=&quot;qx&quot;&gt;qx/EXPR/&lt;/a&gt;&lt;/code&gt; 操作者进行更详细讨论的&lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I / O算perlop得到&lt;/a&gt;。如果省略EXPR，则使用 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="891bbd450e125f5b1ee12d035ddc1a7eef7a872c" translate="yes" xml:space="preserve">
          <source>EXPRESSION</source>
          <target state="translated">EXPRESSION</target>
        </trans-unit>
        <trans-unit id="6f64d0b0e54fcf9769746a65fbf9b2ecb163ee70" translate="yes" xml:space="preserve">
          <source>EXTEND</source>
          <target state="translated">EXTEND</target>
        </trans-unit>
        <trans-unit id="105f8f5f3c21e49b28c3216ab6b37ce1503d78bf" translate="yes" xml:space="preserve">
          <source>EXTEND this, count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a4d24b33941bccd86ff7ba0c19dc15933e36a4" translate="yes" xml:space="preserve">
          <source>EXTENDED CONSTRUCTS</source>
          <target state="translated">扩建工程</target>
        </trans-unit>
        <trans-unit id="b070e356144357fb71137b31e2e89f09d2f73b53" translate="yes" xml:space="preserve">
          <source>EXTERN.h</source>
          <target state="translated">EXTERN.h</target>
        </trans-unit>
        <trans-unit id="92f627e6114fde8ec8e85f5dc7eb0d8548926fd9" translate="yes" xml:space="preserve">
          <source>EXTERNAL</source>
          <target state="translated">EXTERNAL</target>
        </trans-unit>
        <trans-unit id="21d7721c8d41e278d11d43cf30b3f64d4c13b7f4" translate="yes" xml:space="preserve">
          <source>EXTRA</source>
          <target state="translated">EXTRA</target>
        </trans-unit>
        <trans-unit id="13ae0f4e98553c4041bca1bd5b70b21a5aa6d865" translate="yes" xml:space="preserve">
          <source>EXTRALIBS</source>
          <target state="translated">EXTRALIBS</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="64713135c29a168f621e3cd6c59750f2ec3360d2" translate="yes" xml:space="preserve">
          <source>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</source>
          <target state="translated">每一个&quot;=over&quot;.&quot;=back &quot;区域应该是下列之一:&quot;=回 &quot;区域应是下列之一:</target>
        </trans-unit>
        <trans-unit id="8573b03d1dbd851733546c18897b586541b26327" translate="yes" xml:space="preserve">
          <source>Each &lt;b&gt;File&lt;/b&gt; section reports on a single file. Each &lt;b&gt;Subroutine&lt;/b&gt; section reports on a single subroutine apart from the special cases &quot;(definitions)&quot; and &quot;(main)&quot;. These report, respectively, on subroutine definitions found by the initial symbol table walk and on the main part of the program or module external to all subroutines.</source>
          <target state="translated">每个&amp;ldquo; &lt;b&gt;文件&amp;rdquo;&lt;/b&gt;部分报告一个文件。除了特殊情况&amp;ldquo;（定义）&amp;rdquo;和&amp;ldquo;（主）&amp;rdquo;以外，每个子&lt;b&gt;例程&lt;/b&gt;节均报告单个子例程。这些报告分别报告了由初始符号表walk找到的子例程定义以及所有子例程外部的程序或模块的主要部分。</target>
        </trans-unit>
        <trans-unit id="c3f67868071b09e484f931abe029f1f8f7b5dc16" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt; . If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt; , as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="translated">每个 &lt;code&gt;--$source-option&lt;/code&gt; 选项必须指定由 &lt;code&gt;=&lt;/code&gt; 分隔的键/值对。如果一个选项可以采用多个值，则只需多次指定它，就像上面的 &lt;code&gt;extensions=&lt;/code&gt; 示例一样。如果该选项应为哈希引用，则将该值指定为第二对值，并用a &lt;code&gt;=&lt;/code&gt; 分隔，如上述 &lt;code&gt;pset=&lt;/code&gt; 示例（带有反斜杠的escape &lt;code&gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="72aa1e6906c5ec0ac410f03e5bee3a9d52fb4bb1" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;--$source-option&lt;/code&gt; option must specify a key/value pair separated by an &lt;code&gt;=&lt;/code&gt;. If an option can take multiple values, just specify it multiple times, as with the &lt;code&gt;extensions=&lt;/code&gt; examples above. If the option should be a hash reference, specify the value as a second pair separated by a &lt;code&gt;=&lt;/code&gt;, as in the &lt;code&gt;pset=&lt;/code&gt; examples above (escape &lt;code&gt;=&lt;/code&gt; with a backslash).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114f01b386e99faf35799463e66245b3c628986d" translate="yes" xml:space="preserve">
          <source>Each C type is represented by an entry in the typemap file that is responsible for converting perl variables (SV, AV, HV, CV, etc.) to and from that type. The following sections list all XS types that come with perl by default.</source>
          <target state="translated">每个C类型都由tyemap文件中的一个条目来表示,它负责将perl变量(SV、AV、HV、CV等)转换为该类型。下面的章节列出了默认情况下perl自带的所有XS类型。</target>
        </trans-unit>
        <trans-unit id="45fe11f5c5ad8666badf6e1b74648061569fd2e9" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt; , to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="translated">每个CV都有一个指向其词汇包围的CV 的指针 &lt;code&gt;CvOUTSIDE()&lt;/code&gt; （如果有）。由于指向匿名子原型的指针存储在 &lt;code&gt;&amp;amp;&lt;/code&gt; pad插槽中，因此有可能获得循环引用，父对象指向子对象，反之亦然。为了避免随之而来的内存泄漏，我们不会增加由指着CV的引用计数 &lt;code&gt;CvOUTSIDE&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="0a552f3c9f394752d19b918c33b1679413791b25" translate="yes" xml:space="preserve">
          <source>Each CV has a pointer, &lt;code&gt;CvOUTSIDE()&lt;/code&gt;, to its lexically enclosing CV (if any). Because pointers to anonymous sub prototypes are stored in &lt;code&gt;&amp;amp;&lt;/code&gt; pad slots, it is a possible to get a circular reference, with the parent pointing to the child and vice-versa. To avoid the ensuing memory leak, we do not increment the reference count of the CV pointed to by &lt;code&gt;CvOUTSIDE&lt;/code&gt; in the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877f690dc448228c6c71438f034057615156195d" translate="yes" xml:space="preserve">
          <source>Each INPUT or OUTPUT typemap entry is a double-quoted Perl string that will be evaluated in the presence of certain variables to get the final C code for mapping a certain C type.</source>
          <target state="translated">每个INPUT或OUTPUT类型映射条目都是一个双引号的Perl字符串,它将在某些变量的存在下被评估,以获得映射某个C类型的最终C代码。</target>
        </trans-unit>
        <trans-unit id="fb013f151204036ffe28cd6f1b7420c85313acfd" translate="yes" xml:space="preserve">
          <source>Each NAME is assumed to be in the calling package. See share_from for an alternative method (which &lt;code&gt;share&lt;/code&gt; uses).</source>
          <target state="translated">假定每个名称都在调用包中。有关替代方法（ &lt;code&gt;share&lt;/code&gt; 使用），请参见share_from 。</target>
        </trans-unit>
        <trans-unit id="5c9985ee57f0e8b2c8e51c7278e3d4c3d9b47d87" translate="yes" xml:space="preserve">
          <source>Each NAME must be the &lt;b&gt;name&lt;/b&gt; of a non-lexical variable, typically with the leading type identifier included. A bareword is treated as a function name.</source>
          <target state="translated">每个NAME必须是非词法变量的&lt;b&gt;名称&lt;/b&gt;，通常包括前导类型标识符。裸字被视为函数名称。</target>
        </trans-unit>
        <trans-unit id="2d1afe9f64b8afc5ff5d1587bde457161df361bb" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">每个数组 &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 保留由Perl编译的文件的$ filename行。对于包含子例程或当前正在执行的 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4542f557bdf7a70f332f8c5d8d58355f058485ae" translate="yes" xml:space="preserve">
          <source>Each array &lt;code&gt;@{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; holds the lines of $filename for a file compiled by Perl. The same is also true for &lt;code&gt;eval&lt;/code&gt;ed strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f0c2f3d8605c13877f68e54dd82f6341b8fae0" translate="yes" xml:space="preserve">
          <source>Each class can define its &lt;b&gt;attributes&lt;/b&gt;. When we instantiate an object, we assign values to those attributes. For example, every &lt;code&gt;File&lt;/code&gt; object has a path. Attributes are sometimes called &lt;b&gt;properties&lt;/b&gt;.</source>
          <target state="translated">每个类都可以定义其&lt;b&gt;属性&lt;/b&gt;。当实例化一个对象时，我们将值分配给那些属性。例如，每个 &lt;code&gt;File&lt;/code&gt; 对象都有一个路径。属性有时称为&lt;b&gt;属性&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="64bf8b278b40ceb1457596f928446c91560cdf44" translate="yes" xml:space="preserve">
          <source>Each compartment has an associated &quot;operator mask&quot;. Recall that perl code is compiled into an internal format before execution. Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. Code evaluated in a compartment compiles subject to the compartment's operator mask. Attempting to evaluate code in a compartment which contains a masked operator will cause the compilation to fail with an error. The code will not be executed.</source>
          <target state="translated">每个隔间都有一个相关的 &quot;操作者掩码&quot;。回顾一下,perl代码在执行前会被编译成内部格式。评估perl代码(例如通过 &quot;eval &quot;或 &quot;do 'file'&quot;)会导致代码被编译成内部格式,然后在编译过程中没有错误的情况下,被执行。在一个分格中评估的代码会根据分格的操作符掩码进行编译。试图评估包含掩码操作符的分格中的代码将导致编译失败,并出现错误。代码将不会被执行。</target>
        </trans-unit>
        <trans-unit id="c6c4ed2bbcee866615b18a5377b47f14999fe9bd" translate="yes" xml:space="preserve">
          <source>Each context entry is labelled with a context type, &lt;code&gt;cx_type&lt;/code&gt;. Typical context types are &lt;code&gt;CXt_SUB&lt;/code&gt;, &lt;code&gt;CXt_EVAL&lt;/code&gt; etc., as well as &lt;code&gt;CXt_BLOCK&lt;/code&gt; and &lt;code&gt;CXt_NULL&lt;/code&gt; which represent a basic scope (as pushed by &lt;code&gt;pp_enter&lt;/code&gt;) and a sort block. The type determines which part of the context union are valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035a2860cc641f9a6aba917e368a923359692185" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="translated">结构数据中的每个元素都有一个访问器方法，该方法用于分配给该元素并获取其值。可以通过在包中声明一个相同名称的 &lt;code&gt;&lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 来覆盖默认访问器。 （请参见示例2。）</target>
        </trans-unit>
        <trans-unit id="79c8cb706f1fcfacc217858c7c85ae02ae2f4052" translate="yes" xml:space="preserve">
          <source>Each element in the struct data has an accessor method, which is used to assign to the element and to fetch its value. The default accessor can be overridden by declaring a &lt;code&gt;sub&lt;/code&gt; of the same name in the package. (See Example 2.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1373d9ec88c46f95e3a35afb96af5418baf7f3" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt; ; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). To check if a particular key is meaningful on your system, use &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;
$!{the_key}&lt;/code&gt; ; for a list of legal keys, use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24!&quot;&gt;$!&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%!&lt;/code&gt; 每个元素！仅在 &lt;code&gt;$!&lt;/code&gt; 时才具有真实值！设置为该值。例如，当且仅当 &lt;code&gt;$!&lt;/code&gt; 的当前值时， &lt;code&gt;$!{ENOENT}&lt;/code&gt; 为true 。是 &lt;code&gt;ENOENT&lt;/code&gt; ; 也就是说，如果最近的错误是&amp;ldquo;没有这样的文件或目录&amp;rdquo;（或其道德上的等同：并非所有操作系统都给出该确切错误，当然也不是所有语言）。要检查特定键在您的系统上是否有意义，请使用 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt; $!{the_key}&lt;/code&gt; ；有关合法密钥的列表，请使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %!&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;，另请参见&lt;a href=&quot;#%24!&quot;&gt;$！&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3f755ecf95a73dbcb1fefb62d992d2bd88e203f" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;%!&lt;/code&gt; has a true value only if &lt;code&gt;$!&lt;/code&gt; is set to that value. For example, &lt;code&gt;$!{ENOENT}&lt;/code&gt; is true if and only if the current value of &lt;code&gt;$!&lt;/code&gt; is &lt;code&gt;ENOENT&lt;/code&gt;; that is, if the most recent error was &quot;No such file or directory&quot; (or its moral equivalent: not all operating systems give that exact error, and certainly not all languages). The specific true value is not guaranteed, but in the past has generally been the numeric value of &lt;code&gt;$!&lt;/code&gt;. To check if a particular key is meaningful on your system, use &lt;code&gt;exists $!{the_key}&lt;/code&gt;; for a list of legal keys, use &lt;code&gt;keys %!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; for more information, and also see &lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a2d451f571f682ca87c1d143e9cc5d9cc9752a" translate="yes" xml:space="preserve">
          <source>Each element of the &lt;code&gt;@tests&lt;/code&gt; array is either:</source>
          <target state="translated">&lt;code&gt;@tests&lt;/code&gt; 数组的每个元素是：</target>
        </trans-unit>
        <trans-unit id="d55ab66461652be4398995f0bc7395b92cdadc85" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="translated">右侧的每个元素都必须是对正确类型的基准的引用。直接在数组周围加上括号（可能还有 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; ）将使数组的每个元素成为右侧引用的对应标量的别名：</target>
        </trans-unit>
        <trans-unit id="73d053df17de770313a9997b0c6b33ddac74a8d7" translate="yes" xml:space="preserve">
          <source>Each element on the right-hand side must be a reference to a datum of the right type. Parentheses immediately surrounding an array (and possibly also &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;state&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt;/&lt;code&gt;local&lt;/code&gt;) will make each element of the array an alias to the corresponding scalar referenced on the right-hand side:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684b159123c6d2eb2be5f3fb5fb6b32cbd2c836" translate="yes" xml:space="preserve">
          <source>Each element's type can be scalar, array, hash, or class.</source>
          <target state="translated">每个元素的类型可以是标量、数组、哈希或类。</target>
        </trans-unit>
        <trans-unit id="4a18db593068986b02fcc2822d10b93bd6ae4e04" translate="yes" xml:space="preserve">
          <source>Each engine is supposed to provide access to a constant structure of the following format:</source>
          <target state="translated">每个引擎都应该提供对以下格式的常量结构的访问。</target>
        </trans-unit>
        <trans-unit id="df21f7171545bb80d42912cbb46608328ace6052" translate="yes" xml:space="preserve">
          <source>Each field in a picture line starts with either &quot;@&quot; (at) or &quot;^&quot; (caret), indicating what we'll call, respectively, a &quot;regular&quot; or &quot;special&quot; field. The choice of pad characters determines whether a field is textual or numeric. The tilde operators are not part of a field. Let's look at the various possibilities in detail.</source>
          <target state="translated">图片行中的每个字段都以&quot;@&quot;(at)或&quot;^&quot;(caret)开头,分别表示我们所说的 &quot;常规 &quot;或 &quot;特殊 &quot;字段。垫字符的选择决定了一个字段是文本还是数字。符号运算符不是字段的一部分。我们来详细看看各种可能性。</target>
        </trans-unit>
        <trans-unit id="e86751063b4744e62f491d3c6500569d32c72d11" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt; , Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ), or when &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="translated">Perl中的每个文件句柄都会计算从其中读取的行数。（取决于 &lt;code&gt;$/&lt;/code&gt; 的值，Perl关于组成行的想法可能与您的想法不符。）当从文件句柄中读取行（通过 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）时，或者 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek()&lt;/a&gt;&lt;/code&gt; 为呼吁， &lt;code&gt;$.&lt;/code&gt; 成为该文件句柄的行计数器的别名。</target>
        </trans-unit>
        <trans-unit id="8e57c60a3cb6708806cfdda0d69fc8cd46dd15f5" translate="yes" xml:space="preserve">
          <source>Each filehandle in Perl counts the number of lines that have been read from it. (Depending on the value of &lt;code&gt;$/&lt;/code&gt;, Perl's idea of what constitutes a line may not match yours.) When a line is read from a filehandle (via &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), or when &lt;code&gt;tell()&lt;/code&gt; or &lt;code&gt;seek()&lt;/code&gt; is called on it, &lt;code&gt;$.&lt;/code&gt; becomes an alias to the line counter for that filehandle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a9624b1b717a0ce3347c2a7723ee1a1d25abab" translate="yes" xml:space="preserve">
          <source>Each handle can be an &lt;code&gt;IO::Handle&lt;/code&gt; object, an integer or an array reference where the first element is an &lt;code&gt;IO::Handle&lt;/code&gt; or an integer.</source>
          <target state="translated">每个句柄可以是 &lt;code&gt;IO::Handle&lt;/code&gt; 对象，整数或数组引用，其中第一个元素是 &lt;code&gt;IO::Handle&lt;/code&gt; 或整数。</target>
        </trans-unit>
        <trans-unit id="c1d7462289e4cec1a7aa1fe4c855d903202ec597" translate="yes" xml:space="preserve">
          <source>Each hash &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains breakpoints and actions keyed by line number. Individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">每个哈希 &lt;code&gt;%{&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 包含断点和以行号为键的操作。可以设置单个条目（而不是整个散列）。Perl在这里只关心布尔值true，尽管</target>
        </trans-unit>
        <trans-unit id="62cc45eed91752b51404de9ea925a035fb43cbad" translate="yes" xml:space="preserve">
          <source>Each id must be unique within the document.</source>
          <target state="translated">每个ID在文档中必须是唯一的。</target>
        </trans-unit>
        <trans-unit id="667975ad4758db6be064d162ec07e954e503457b" translate="yes" xml:space="preserve">
          <source>Each individual compressed data stream is read until the logical end-of-file is reached. Then &lt;code&gt;nextStream&lt;/code&gt; is called. This will skip to the start of the next compressed data stream and clear the end-of-file flag.</source>
          <target state="translated">读取每个单独的压缩数据流，直到达到逻辑文件结尾。然后 &lt;code&gt;nextStream&lt;/code&gt; 。这将跳到下一个压缩数据流的开始，并清除文件结束标志。</target>
        </trans-unit>
        <trans-unit id="18f2cec26478e04f9b7de7d10fcbddee95e58d2c" translate="yes" xml:space="preserve">
          <source>Each initializer is a pair of values:</source>
          <target state="translated">每个初始化器都是一对值。</target>
        </trans-unit>
        <trans-unit id="16164820a467e235638c757ccfe00052f4c79b5f" translate="yes" xml:space="preserve">
          <source>Each is a reference to an array of hostnames (in order of preference), which should be used for the given protocol</source>
          <target state="translated">每一个都是对主机名数组的引用(按优先级排序),这些主机名应该用于指定的协议。</target>
        </trans-unit>
        <trans-unit id="d29b86c40a3e654b348fa005424d750255213988" translate="yes" xml:space="preserve">
          <source>Each is an instance of a class with the following methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0eab90b97db650ebd8f6bc0b1085529dd6f2a05" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; would return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c5e455da6b08e4d8e8bc9f42db356fdab7233a" translate="yes" xml:space="preserve">
          <source>Each key is the property name in its longest, most descriptive form. The values are what &lt;a href=&quot;#charprop()&quot;&gt;charprop()&lt;/a&gt; would return.</source>
          <target state="translated">每个键都是最长，最具描述性的形式的属性名称。这些值是&lt;a href=&quot;#charprop()&quot;&gt;charprop（）&lt;/a&gt;将返回的值。</target>
        </trans-unit>
        <trans-unit id="47492265b46ae806bb067e9b524f132422627a4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">每个字母后面可以有一个数字，指示重复计数。数字重复计数可以有选择地放在方括号中，如 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 。当与除 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，@以外的所有格式类型一起使用时，重复计数吞噬了LIST中的许多值 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; ，表示其他含义，如下所述。提供 &lt;code&gt;*&lt;/code&gt; 重复计数而不是数字表示要使用，但是剩下很多项目，除了：</target>
        </trans-unit>
        <trans-unit id="f1b93edbbeb731023c3dcd7b867f87661f785306" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; . The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;P&lt;/code&gt; , where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="translated">每个字母后面可以有一个数字，指示重复计数。数字重复计数可以有选择地放在方括号中，如 &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;(&quot;C[80]&quot;, @arr)&lt;/code&gt; 。当与除 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;H&lt;/code&gt; ， &lt;code&gt;@&lt;/code&gt; ，@以外的所有格式类型一起使用时，重复计数吞噬了LIST中的许多值 &lt;code&gt;.&lt;/code&gt; ， &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;P&lt;/code&gt; ，表示其他含义，如下所述。提供 &lt;code&gt;*&lt;/code&gt; 重复计数而不是数字表示要使用，但是剩下很多项目，除了：</target>
        </trans-unit>
        <trans-unit id="0ed7a060f431ab2cc494847effa3cd5278eb7c4f" translate="yes" xml:space="preserve">
          <source>Each letter may optionally be followed by a number indicating the repeat count. A numeric repeat count may optionally be enclosed in brackets, as in &lt;code&gt;pack(&quot;C[80]&quot;, @arr)&lt;/code&gt;. The repeat count gobbles that many values from the LIST when used with all format types other than &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;P&lt;/code&gt;, where it means something else, described below. Supplying a &lt;code&gt;*&lt;/code&gt; for the repeat count instead of a number means to use however many items are left, except for:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2b686ea513abcdcd81b004dc80b72da247c37" translate="yes" xml:space="preserve">
          <source>Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.</source>
          <target state="translated">每个locale键都是对上面形式的哈希的引用,并给出了该特定locale的casing规则,当在该locale中时,这些规则优先于与本地无关的规则。</target>
        </trans-unit>
        <trans-unit id="b81c66f6a67c62b4046a77844c9acd84b539087f" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt; , which will assume a 1 for you, just to be different.</source>
          <target state="translated">每个方法都返回 &lt;code&gt;IO::Handle&lt;/code&gt; 属性的旧值。每个方法都带有一个可选的EXPR，如果提供了EXPR，则为所讨论的 &lt;code&gt;IO::Handle&lt;/code&gt; 属性指定新值。如果未提供，则大多数方法对当前值不执行任何操作-除了 &lt;code&gt;autoflush()&lt;/code&gt; ，它会为您假设1，只是有所不同。</target>
        </trans-unit>
        <trans-unit id="549fa064c8357d58112301aba532e091511a4996" translate="yes" xml:space="preserve">
          <source>Each method returns the old value of the &lt;code&gt;IO::Handle&lt;/code&gt; attribute. The methods each take an optional EXPR, which, if supplied, specifies the new value for the &lt;code&gt;IO::Handle&lt;/code&gt; attribute in question. If not supplied, most methods do nothing to the current value--except for &lt;code&gt;autoflush()&lt;/code&gt;, which will assume a 1 for you, just to be different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a408a79f13c6ec4a0cd81e57c787564393f289b" translate="yes" xml:space="preserve">
          <source>Each name-type pair declares one element of the struct. Each element name will be defined as an accessor method unless a method by that name is explicitly defined; in the latter case, a warning is issued if the warning flag (&lt;b&gt;-w&lt;/b&gt;) is set.</source>
          <target state="translated">每个名称类型对都声明该结构的一个元素。除非显式定义了使用该名称的方法，否则每个元素名称都将被定义为访问器方法。在后一种情况下，如果设置了警告标志（&lt;b&gt;-w&lt;/b&gt;），则发出警告。</target>
        </trans-unit>
        <trans-unit id="bea2fa8177204a00acbe330d65cd373309740d46" translate="yes" xml:space="preserve">
          <source>Each of the &lt;code&gt;$section_spec&lt;/code&gt; arguments should be a section specification as described in &lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS&lt;/a&gt;. The section specifications are parsed by this method and the resulting regular expressions are stored in the invoking object.</source>
          <target state="translated">每个 &lt;code&gt;$section_spec&lt;/code&gt; 参数都应该是&lt;a href=&quot;#SECTION-SPECIFICATIONS&quot;&gt;SECTION SPECIFICATIONS中&lt;/a&gt;所描述的节规范。通过此方法解析节规范，并将所得的正则表达式存储在调用对象中。</target>
        </trans-unit>
        <trans-unit id="9af6792ba1f44d7cb824f7440960f3ef5c01b6ba" translate="yes" xml:space="preserve">
          <source>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</source>
          <target state="translated">POSIX的每一个类都和它们的ASCII范围对应的类完全匹配。</target>
        </trans-unit>
        <trans-unit id="be167c32ebe292b1abf425a82a9d67c142fdc9a5" translate="yes" xml:space="preserve">
          <source>Each of the argument lists above comes out of the &lt;code&gt;normalize_f&lt;/code&gt; function looking exactly the same, like this:</source>
          <target state="translated">上面的每个参数列表都来自 &lt;code&gt;normalize_f&lt;/code&gt; 函数，看起来完全一样，如下所示：</target>
        </trans-unit>
        <trans-unit id="93679dc7d627c4c7a6a3897712645c4450ba1379" translate="yes" xml:space="preserve">
          <source>Each of the commands that produce listings of modules (&lt;code&gt;r&lt;/code&gt; , &lt;code&gt;autobundle&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; ) also return a list of the IDs of all modules within the list.</source>
          <target state="translated">产生模块列表的每个命令（ &lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;autobundle&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; ）也会返回列表中所有模块的ID列表。</target>
        </trans-unit>
        <trans-unit id="36a145ce6b55d2eacd4e152e8b778cb0812f1b4c" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt; ) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt; , &lt;code&gt;S|T&lt;/code&gt; , &lt;code&gt;S*&lt;/code&gt; etc. (in these examples &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; are regular subexpressions).</source>
          <target state="translated">之前描述的每个正则表达式基本项（例如 &lt;code&gt;ab&lt;/code&gt; 或 &lt;code&gt;\Z&lt;/code&gt; ）在输入字符串的给定位置最多可以匹配一个子字符串。但是，在典型的正则表达式中，这些基本部分使用组合运算符 &lt;code&gt;ST&lt;/code&gt; ， &lt;code&gt;S|T&lt;/code&gt; ， &lt;code&gt;S*&lt;/code&gt; 等组合为更复杂的模式（在这些示例中， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;T&lt;/code&gt; 为正则子表达式）。</target>
        </trans-unit>
        <trans-unit id="c1f94498db7cafa14ac711805deae194684f4e3e" translate="yes" xml:space="preserve">
          <source>Each of the elementary pieces of regular expressions which were described before (such as &lt;code&gt;ab&lt;/code&gt; or &lt;code&gt;\Z&lt;/code&gt;) could match at most one substring at the given position of the input string. However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &lt;code&gt;ST&lt;/code&gt;, &lt;code&gt;S|T&lt;/code&gt;, &lt;code&gt;S*&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf85de30bb2350d06139ae6bc58a79af96a26e97" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt; , immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt; ) and will exit with a status of 2:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都将显示&amp;ldquo;语法错误&amp;rdquo;消息。（后跟换行符）到 &lt;code&gt;STDERR&lt;/code&gt; ，紧随其后的是&amp;ldquo; SYNOPSIS&amp;rdquo;部分（也打印到 &lt;code&gt;STDERR&lt;/code&gt; ），并且退出状态为2：</target>
        </trans-unit>
        <trans-unit id="c471e82fa0389f6962922185f6c1c022a3af5d32" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print a message of &quot;Syntax error.&quot; (followed by a newline) to &lt;code&gt;STDERR&lt;/code&gt;, immediately followed by just the &quot;SYNOPSIS&quot; section (also printed to &lt;code&gt;STDERR&lt;/code&gt;) and will exit with a status of 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da247936c8bb95b82240dfbb57e8459e5c728eb2" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print just the &quot;SYNOPSIS&quot; section to &lt;code&gt;STDERR&lt;/code&gt; and will exit with a status of 2:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都只会将&amp;ldquo; SYNOPSIS&amp;rdquo;部分打印到 &lt;code&gt;STDERR&lt;/code&gt; ，并以状态2退出：</target>
        </trans-unit>
        <trans-unit id="c3bf15a510b108560bc55f9dc642118c67f04409" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the &quot;SYNOPSIS&quot; section and any &quot;OPTIONS&quot; and/or &quot;ARGUMENTS&quot; sections to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都会将&amp;ldquo; SYNOPSIS&amp;rdquo;部分以及任何&amp;ldquo; OPTIONS&amp;rdquo;和/或&amp;ldquo; ARGUMENTS&amp;rdquo;部分打印到 &lt;code&gt;STDOUT&lt;/code&gt; ,并且退出状态为1：</target>
        </trans-unit>
        <trans-unit id="8a8549150e98bb7d0199412efeddf54defc2c85f" translate="yes" xml:space="preserve">
          <source>Each of the following invocations of &lt;code&gt;pod2usage()&lt;/code&gt; will print the entire manual page to &lt;code&gt;STDOUT&lt;/code&gt; and will exit with a status of 1:</source>
          <target state="translated">以下对 &lt;code&gt;pod2usage()&lt;/code&gt; 的每次调用都会将整个手册页打印到 &lt;code&gt;STDOUT&lt;/code&gt; 并以状态1退出：</target>
        </trans-unit>
        <trans-unit id="159291495d574283955b7dd83a0159a4cbe57ab7" translate="yes" xml:space="preserve">
          <source>Each of the following methods will return the total number of corresponding tests if called in scalar context. If called in list context, returns the descriptions of the parsers which contain the corresponding tests (see &lt;code&gt;add&lt;/code&gt; for an explanation of description.</source>
          <target state="translated">如果在标量上下文中调用，以下每个方法将返回相应测试的总数。如果在列表上下文中调用，则返回包含相应测试的解析器的描述（有关说明的说明，请参见 &lt;code&gt;add&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4805d0a6e23a882a6f379f5e1aaffac33d67fcd" translate="yes" xml:space="preserve">
          <source>Each of the functions will now be discussed in turn.</source>
          <target state="translated">现在将依次讨论每项职能。</target>
        </trans-unit>
        <trans-unit id="cf8ee854b23795d139b708dbd25340dc64f25e5b" translate="yes" xml:space="preserve">
          <source>Each of the functions will return</source>
          <target state="translated">每个函数都会返回</target>
        </trans-unit>
        <trans-unit id="67d949b14cef9bc96632c4a26c1317dd5c052479" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt; , for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; .)</source>
          <target state="translated">无论您在何处执行程序，每个整数包代码 &lt;code&gt;sSlLqQ&lt;/code&gt; 都会产生固定数量的字节。这对于某些应用程序可能很有用，但是它没有提供一种可移植的方式在Perl和C程序之间传递数据结构（在调用XS扩展名或Perl函数 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 时必定发生），或者在读取或写入二进制文件时会发生这种情况。。在这种情况下，您需要的是模板代码，这些模板代码取决于您在编写 &lt;code&gt;short&lt;/code&gt; 代码或 &lt;code&gt;unsigned long&lt;/code&gt; 代码时本地C编译器的编译内容， 例如。这些代码及其对应的字节长度如下表所示。由于C标准相对于这些数据类型的相对大小还有很多余地，因此实际值可能会有所不同，这就是为什么这些值在C和Perl中以表达式形式给出。 （如果要在程序中使用 &lt;code&gt;%Config&lt;/code&gt; 中的值，则必须 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Config&lt;/code&gt; 导入它。）</target>
        </trans-unit>
        <trans-unit id="6060e81492ddf46249708e305af675d2cd8e4300" translate="yes" xml:space="preserve">
          <source>Each of the integer pack codes &lt;code&gt;sSlLqQ&lt;/code&gt; results in a fixed number of bytes, no matter where you execute your program. This may be useful for some applications, but it does not provide for a portable way to pass data structures between Perl and C programs (bound to happen when you call XS extensions or the Perl function &lt;code&gt;syscall&lt;/code&gt;), or when you read or write binary files. What you'll need in this case are template codes that depend on what your local C compiler compiles when you code &lt;code&gt;short&lt;/code&gt; or &lt;code&gt;unsigned long&lt;/code&gt;, for instance. These codes and their corresponding byte lengths are shown in the table below. Since the C standard leaves much leeway with respect to the relative sizes of these data types, actual values may vary, and that's why the values are given as expressions in C and Perl. (If you'd like to use values from &lt;code&gt;%Config&lt;/code&gt; in your program you have to import it with &lt;code&gt;use Config&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d0d0049982558d7e176e2f3ab3ea596bc6e428" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt; , &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt; , &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt; . Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;ACCURACY and PRECISION&lt;/a&gt; for more information.</source>
          <target state="translated">下面的每个方法（config（），precision（）和precision（）除外）都接受三个附加参数。这些论点 &lt;code&gt;$A&lt;/code&gt; ， &lt;code&gt;$P&lt;/code&gt; 和 &lt;code&gt;$R&lt;/code&gt; 是 &lt;code&gt;accuracy&lt;/code&gt; ， &lt;code&gt;precision&lt;/code&gt; 和 &lt;code&gt;round_mode&lt;/code&gt; 。有关更多信息，请参见&amp;ldquo; &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;精度和精度&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="2d2b46938dbf24928125c2dd236a1a486381e417" translate="yes" xml:space="preserve">
          <source>Each of the methods below (except config(), accuracy() and precision()) accepts three additional parameters. These arguments &lt;code&gt;$A&lt;/code&gt;, &lt;code&gt;$P&lt;/code&gt; and &lt;code&gt;$R&lt;/code&gt; are &lt;code&gt;accuracy&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; and &lt;code&gt;round_mode&lt;/code&gt;. Please see the section about &lt;a href=&quot;#ACCURACY-and-PRECISION&quot;&gt;&quot;ACCURACY and PRECISION&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb55af40d1c4ccf668c4ee509cae7b3650aeb0" translate="yes" xml:space="preserve">
          <source>Each of the methods works identically, and is used to install (or uninstall) a single DBM Filter. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">每一种方法的工作原理都是一样的,都是用来安装(或卸载)一个DBM过滤器。它们之间的唯一区别是过滤器的安装位置。</target>
        </trans-unit>
        <trans-unit id="d70d3afe0fc2fcaf924f4e6c71f92047845119e3" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;&quot;Scratchpads and recursion&quot;&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deb52f34c0e7c886d38c077a6693f8fac31c72b2" translate="yes" xml:space="preserve">
          <source>Each of the targets is created only once (but see &lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads and recursion&lt;/a&gt; below), and when an opcode needs to put an integer, a double, or a string on stack, it just sets the corresponding parts of its</source>
          <target state="translated">每个目标仅创建一次（但请参见下面的&lt;a href=&quot;#Scratchpads-and-recursion&quot;&gt;Scratchpads和递归&lt;/a&gt;），并且当操作码需要在堆栈中放置整数，双精度或字符串时，它只需设置其相应部分即可</target>
        </trans-unit>
        <trans-unit id="61645526a5f8cc5b5b38c365e573e3b9ce2a363a" translate="yes" xml:space="preserve">
          <source>Each of these areas will be discussed in the following sections.</source>
          <target state="translated">以下各节将讨论这些领域中的每一个领域。</target>
        </trans-unit>
        <trans-unit id="4a7e0927366cb3008e3cb582f1225e023afb76ec" translate="yes" xml:space="preserve">
          <source>Each of these functions are called without arguments and return the absolute path of the current working directory.</source>
          <target state="translated">这些函数的调用都没有参数,并返回当前工作目录的绝对路径。</target>
        </trans-unit>
        <trans-unit id="fb6c26bfd690fb609fa0a362b968489c94f785d7" translate="yes" xml:space="preserve">
          <source>Each of these input objects are described in further detail in the sections which follow.</source>
          <target state="translated">这些输入对象中的每一个都将在下面的章节中进一步详细描述。</target>
        </trans-unit>
        <trans-unit id="cd0ac943df3c5c0919c257e9e2ba53e934e28e43" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument, except</source>
          <target state="translated">这些方法都可以修改第一个输入参数,除了</target>
        </trans-unit>
        <trans-unit id="94636e821462a702e9dcf821156451ce10166f58" translate="yes" xml:space="preserve">
          <source>Each of these methods may modify the first input argument.</source>
          <target state="translated">这些方法都可以修改第一个输入参数。</target>
        </trans-unit>
        <trans-unit id="1fd6321d309f67bf764c8af9cff581fae0812fa5" translate="yes" xml:space="preserve">
          <source>Each of these nodes represents an op, a fundamental operation inside the Perl core. The code which implements each operation can be found in the</source>
          <target state="translated">每一个节点都代表一个 op,这是 Perl 内核的一个基本操作。实现每个操作的代码可以在</target>
        </trans-unit>
        <trans-unit id="eb5de442d3b4d44516edecf88d3338777e703e96" translate="yes" xml:space="preserve">
          <source>Each of these objects may be replaced by calling one of these parser methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33d6b2a3cedc47a8c8496247740303b046f066c7" translate="yes" xml:space="preserve">
          <source>Each of these options is optional; you can include some, all, or none of them.</source>
          <target state="translated">这些选项中的每一个都是可选的,你可以包含部分、全部或不包含。</target>
        </trans-unit>
        <trans-unit id="b15a1940399791f7b94602b4451362ab540da911" translate="yes" xml:space="preserve">
          <source>Each of these routines accepts a file specification in either VMS or Unix syntax, and returns the converted file specification, or &lt;code&gt;undef&lt;/code&gt; if an error occurs. The conversions are, for the most part, simply string manipulations; the routines do not check the details of syntax (e.g. that only legal characters are used). There is one exception: when running under VMS, conversions from VMS syntax use the $PARSE service to expand specifications, so illegal syntax, or a relative directory specification which extends above the tope of the current directory path (e.g [---.foo] when in dev:[dir.sub]) will cause errors. In general, any legal file specification will be converted properly, but garbage input tends to produce garbage output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86b7bd343bf185137324ab08afba721e66b470a2" translate="yes" xml:space="preserve">
          <source>Each of these routines is prototyped as taking a single scalar argument, so you can use them as unary operators in complex expressions (as long as you don't use the &lt;code&gt;&amp;amp;&lt;/code&gt; form of subroutine call, which bypasses prototype checking).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fde8ca981b648a0a7df0eccad95608e9bb268d" translate="yes" xml:space="preserve">
          <source>Each op is preceded by two pointers: one points to the next op in the slab, and the other points to the slab that owns it. The next-op pointer is needed so that Perl can iterate over a slab and free all its ops. (Op structures are of different sizes, so the slab's ops can't merely be treated as a dense array.) The slab pointer is needed for accessing a reference count on the slab: when the last op on a slab is freed, the slab itself is freed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f0b67ca5c809a794efbf846b5f11a39a783c34" translate="yes" xml:space="preserve">
          <source>Each operand is considered in a modified scalar context, the modification being that array and hash variables are passed by reference to the operator, which implicitly dereferences them. Both elements of each pair are the same:</source>
          <target state="translated">每个操作数都是在修改后的标量上下文中考虑的,修改的地方是数组和哈希变量是通过对操作数的引用来传递的,而操作数的引用是隐含地对它们进行减引的。每个操作数对的两个元素都是一样的。</target>
        </trans-unit>
        <trans-unit id="76254c26642feac52117b7e65ad2b643499a9d47" translate="yes" xml:space="preserve">
          <source>Each operator has both a terse name (its opname) and a more verbose or recognisable descriptive name. The opdesc function can be used to return a list of descriptions for a list of operators.</source>
          <target state="translated">每个操作符都有一个简洁的名称(它的opname)和一个更简洁的或可识别的描述性名称。opdesc函数可以用来返回一个操作符列表的描述列表。</target>
        </trans-unit>
        <trans-unit id="0ffccbf8d7d785427858064bfe414c9a343b8478" translate="yes" xml:space="preserve">
          <source>Each option specifier consists of two parts: the name specification and the argument specification.</source>
          <target state="translated">每个选项指定器由两部分组成:名称规格和参数规格。</target>
        </trans-unit>
        <trans-unit id="49dbe9df44df46422e8ed79c89a972f7e0a049b6" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; . The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="translated">每个软件包都包含一个称为 &lt;code&gt;@ISA&lt;/code&gt; 的特殊数组。该 &lt;code&gt;@ISA&lt;/code&gt; 数组包含类的父类的列表，如果有的话。当Perl执行方法解析时，将检查此数组，我们将在后面讨论。</target>
        </trans-unit>
        <trans-unit id="ddf57d8082b4349ec2c54b6a8bdc282825375550" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt; which contains a list of that class's parent classes, if any. This array is simply a list of scalars, each of which is a string that corresponds to a package name. The array is examined when Perl does method resolution, which is covered in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9236fa90d77c1443c1fcc30f0eb2e90c48b3b452" translate="yes" xml:space="preserve">
          <source>Each package contains a special array called &lt;code&gt;@ISA&lt;/code&gt;. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of that class's parent classes, if any. This array is examined when Perl does method resolution, which we will cover later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56746947dceb1b1ebf83666e64df3d893f0573" translate="yes" xml:space="preserve">
          <source>Each pair is an array reference with two elements - namely the</source>
          <target state="translated">每一对都是一个有两个元素的数组引用,分别是</target>
        </trans-unit>
        <trans-unit id="79339b4554cd8ab3b93700df12bacff7c6d9a530" translate="yes" xml:space="preserve">
          <source>Each pathname that is a directory that matches the pattern has a slash appended.</source>
          <target state="translated">每个符合模式的目录的路径名都有一个斜杠。</target>
        </trans-unit>
        <trans-unit id="20b56d27482026f6b453dfe18f7f652ebd744ed0" translate="yes" xml:space="preserve">
          <source>Each plugin should register itself by providing the following structure</source>
          <target state="translated">每个插件都应该通过提供以下结构来注册自己。</target>
        </trans-unit>
        <trans-unit id="4bc675eeb53212d68aff2215974b513fa9d0ff3e" translate="yes" xml:space="preserve">
          <source>Each programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.</source>
          <target state="translated">当然,每个程序员在格式方面都有自己的偏好,但有一些通用的准则可以让你的程序更容易阅读、理解和维护。</target>
        </trans-unit>
        <trans-unit id="e2d7e5e3cbcd85e0f15e433073f3c09c16649807" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual environment. Modifications to %ENV affect the virtual environment, and are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it.</source>
          <target state="translated">每个伪进程都会维护自己的虚拟环境,对%ENV的修改会影响到虚拟环境,而且只有在该伪进程内以及从它启动的任何进程(或伪进程)中才能看到。对%ENV的修改会影响虚拟环境,并且只在该伪进程内以及从它启动的任何进程(或伪进程)中可见。</target>
        </trans-unit>
        <trans-unit id="25a97b930031adadf111787667688ded94505539" translate="yes" xml:space="preserve">
          <source>Each pseudo-process maintains its own virtual idea of the current directory. Modifications to the current directory using chdir() are only visible within that pseudo-process, and in any processes (or pseudo-processes) launched from it. All file and directory accesses from the pseudo-process will correctly map the virtual working directory to the real working directory appropriately.</source>
          <target state="translated">每个伪进程都维护着它自己对当前目录的虚拟概念。使用chdir()对当前目录的修改仅在该伪进程内以及从它启动的任何进程(或伪进程)中可见。所有来自伪进程的文件和目录访问都会正确地将虚拟工作目录适当地映射到真实工作目录。</target>
        </trans-unit>
        <trans-unit id="8f4f1268e7fb63f76b0f62897f0f8014b138b792" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">每个结果位都基于相应输入字符的最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 生成位0和1，字符 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abf39ff7c44d3c8c17f0be2056a001c031f6f08e" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt; .</source>
          <target state="translated">每个结果位都基于相应输入字符的最低有效位，即基于 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)%2&lt;/a&gt;&lt;/code&gt; 。特别是，字符 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 生成位0和1，字符 &lt;code&gt;&quot;\000&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;\001&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1993b5736422a8ea772061042ca6c62dead2e8c" translate="yes" xml:space="preserve">
          <source>Each result bit is based on the least-significant bit of the corresponding input character, i.e., on &lt;code&gt;ord($char)%2&lt;/code&gt;. In particular, characters &lt;code&gt;&quot;0&quot;&lt;/code&gt; and &lt;code&gt;&quot;1&quot;&lt;/code&gt; generate bits 0 and 1, as do characters &lt;code&gt;&quot;\000&quot;&lt;/code&gt; and &lt;code&gt;&quot;\001&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1801d81c7323468b4de78bc480016b6092b96d8e" translate="yes" xml:space="preserve">
          <source>Each result fetched is a result object of a different type. There are common methods to each result object and different types may have methods unique to their type. Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</source>
          <target state="translated">获取的每个结果都是一个不同类型的结果对象。每个结果对象都有共同的方法,不同类型可能有其类型特有的方法。有时一个类型的方法可能会在子类中被重写,但保证其用法是相同的。</target>
        </trans-unit>
        <trans-unit id="4e19bf2bd96e365232fc6a017a9d4e2f9f8f058b" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca0f4c2c0d0f6d5b588e090e9018c1d20041904" translate="yes" xml:space="preserve">
          <source>Each result returned is a &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; subclass, referred to as</source>
          <target state="translated">返回的每个结果都是&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;子类，称为</target>
        </trans-unit>
        <trans-unit id="ce5b6f7b029d0c88c7f3bdd0a0914e98b5dca329" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1f92895a8d5d3bca2a476a0ec322b95e7589a" translate="yes" xml:space="preserve">
          <source>Each result returned is a subclass of &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt;. See that module and related classes for more information on how to use them.</source>
          <target state="translated">返回的每个结果都是&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;的子类。请参阅该模块和相关类，以获取有关如何使用它们的更多信息。</target>
        </trans-unit>
        <trans-unit id="8f5ef808a290d77bcb78c1a52baf58c7827e311b" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; . This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">每个标量 &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; 包含 &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt; 。对于包含子例程或当前正在执行的已评估字符串，情况也是如此。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 字符串的$ filename 看起来像 &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccc94bfc366f53a70874613dffa08986828d80a8" translate="yes" xml:space="preserve">
          <source>Each scalar &lt;code&gt;${&quot;_&amp;lt;$filename&quot;}&lt;/code&gt; contains &lt;code&gt;&quot;_&amp;lt;$filename&quot;&lt;/code&gt;. This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b759249474717644d66332dcc04eba32c6b818f" translate="yes" xml:space="preserve">
          <source>Each semaphore has a counter attached to it. By default, semaphores are created with the counter set to one, &lt;code&gt;down()&lt;/code&gt; decrements the counter by one, and &lt;code&gt;up()&lt;/code&gt; increments by one. However, we can override any or all of these defaults simply by passing in different values:</source>
          <target state="translated">每个信号量都有一个附加的计数器。默认情况下，信号量是在将计数器设置为1的情况下创建的， &lt;code&gt;down()&lt;/code&gt; 将计数器递减1，而 &lt;code&gt;up()&lt;/code&gt; 递增1。但是，我们可以简单地通过传递不同的值来覆盖任何或所有这些默认值：</target>
        </trans-unit>
        <trans-unit id="9e3598640cb6381c253bcf070a1e62dc7e9d0823" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;|  1:  STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="translated">每个步骤的形式为 &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; 匹配的字符串部分和 &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; 尚未匹配的部分。该 &lt;code&gt;| 1: STAR&lt;/code&gt; 表示Perl在上面的编译列表中位于第1行。有关更多详细信息，请参见&lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;perldebguts中的调试正则表达式&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="621b92ce1167d60ce7eabc3bf97a2ce373df3b42" translate="yes" xml:space="preserve">
          <source>Each step is of the form &lt;code&gt;n &amp;lt;x&amp;gt; &amp;lt;y&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; the part of the string matched and &lt;code&gt;&amp;lt;y&amp;gt;&lt;/code&gt; the part not yet matched. The &lt;code&gt;| 1: STAR&lt;/code&gt; says that Perl is at line number 1 in the compilation list above. See &lt;a href=&quot;perldebguts#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebguts&lt;/a&gt; for much more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f223fa7c50954c6826a1fdb18aaf28328cfda343" translate="yes" xml:space="preserve">
          <source>Each test can be given a little descriptive name as the second argument to &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdc8ff98493a9f7ade9d6296926319855358f97" translate="yes" xml:space="preserve">
          <source>Each thread (except the main thread) is started using the C locale. The main thread is started like all other Perl programs; see &lt;a href=&quot;perllocale#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot; in perllocale&lt;/a&gt;. You can switch locales in any thread as often as you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3defe21495aad5ab5041830fd4fe29198a67142" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; is called, the iterator returns one of two possible values:</source>
          <target state="translated">每次调用 &lt;code&gt;$finder-&amp;gt;next&lt;/code&gt; ，迭代器都会返回以下两个可能值之一：</target>
        </trans-unit>
        <trans-unit id="54bbe29b947a5618329ec98194ec80f8aabe46b6" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; . Blank lines are generally ignored.</source>
          <target state="translated">每种类型的节都可以出现任意次，并且根本不必出现。例如，如果类型映射仅需要将其他C类型与核心XS类型（如T_PTROBJ）相关联，则通常可能缺少 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 部分。以 &lt;code&gt;TYPEMAP&lt;/code&gt; &lt;code&gt;#&lt;/code&gt; 开头的行在TYPEMAP部分中被视为注释，并被忽略，但在 &lt;code&gt;INPUT&lt;/code&gt; 和 &lt;code&gt;OUTPUT&lt;/code&gt; 中被认为是重要的。空行通常被忽略。</target>
        </trans-unit>
        <trans-unit id="b8ab41b525aa7b7c38e4e3da5cf8193e961a308c" translate="yes" xml:space="preserve">
          <source>Each type of section can appear an arbitrary number of times and does not have to appear at all. For example, a typemap may commonly lack &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections if all it needs to do is associate additional C types with core XS types like T_PTROBJ. Lines that start with a hash &lt;code&gt;#&lt;/code&gt; are considered comments and ignored in the &lt;code&gt;TYPEMAP&lt;/code&gt; section, but are considered significant in &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt;. Blank lines are generally ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99826defe1aa3e0e7dfa632ce9b50c12211fd46" translate="yes" xml:space="preserve">
          <source>Each typedef has specific routines that manipulate the various data types.</source>
          <target state="translated">每个typedef都有特定的例程来操作各种数据类型。</target>
        </trans-unit>
        <trans-unit id="a786e808038f24779f10721b5785e1d471731d02" translate="yes" xml:space="preserve">
          <source>Each value in the results list will be a hash reference containing the following fields:</source>
          <target state="translated">结果列表中的每个值将是一个包含以下字段的哈希引用:</target>
        </trans-unit>
        <trans-unit id="d6fa3b1f2df46de4d0da0473d7f7df5be8fdd538" translate="yes" xml:space="preserve">
          <source>Each version of Perl comes with the documentation that was current at the time of release. This poses a problem for content such as book lists. There are probably very nice books published after this list was included in your Perl release, and you can check the latest released version at &lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html&lt;/a&gt; .</source>
          <target state="translated">每个版本的Perl都带有发行时最新的文档。这给诸如书单之类的内容带来了问题。在您的Perl版本中包含此列表之后，可能会出版非常好的书籍，您可以在&lt;a href=&quot;http://perldoc.perl.org/perlbook.html&quot;&gt;http://perldoc.perl.org/perlbook.html上&lt;/a&gt;查看最新发行的版本。</target>
        </trans-unit>
        <trans-unit id="a017204ca793ea63195213655418d18b5e46cf36" translate="yes" xml:space="preserve">
          <source>Earlier Mac OS X releases (10.2 &quot;Jaguar&quot; and older) did not include a completely thread-safe libc, so threading is not fully supported. Also, earlier releases included a buggy libdb, so some of the DB_File tests are known to fail on those releases.</source>
          <target state="translated">早期的Mac OS X版本(10.2 &quot;Jaguar &quot;和更早的版本)没有包含一个完全线程安全的libc,所以线程没有得到完全支持。此外,早期的版本包含了一个错误的libdb,所以一些DB_File测试在这些版本上会失败。</target>
        </trans-unit>
        <trans-unit id="a252186ae05a758597f2268019d7fe33e7216333" translate="yes" xml:space="preserve">
          <source>Earlier releases caveats</source>
          <target state="translated">早期版本的注意事项</target>
        </trans-unit>
        <trans-unit id="8144bf937e246b0c3995f39e74e8340a0ff57aa1" translate="yes" xml:space="preserve">
          <source>Earlier than Perl 5.10, you have a bit of work to do. You want to avoid compiling a regular expression every time you want to match it. In this example, perl must recompile the regular expression for every iteration of the &lt;code&gt;foreach&lt;/code&gt; loop since it has no way to know what &lt;code&gt;$pattern&lt;/code&gt; will be:</source>
          <target state="translated">在Perl 5.10之前，您需要做一些工作。您希望避免每次想要匹配时都编译正则表达式。在此示例中，perl必须为 &lt;code&gt;foreach&lt;/code&gt; 循环的每次迭代重新编译正则表达式，因为它无法知道 &lt;code&gt;$pattern&lt;/code&gt; 是什么：</target>
        </trans-unit>
        <trans-unit id="2412eca1a81df7ff0f1d8fd57bf151a2e60cb6ee" translate="yes" xml:space="preserve">
          <source>Earlier versions of Perl accepted almost all the 6.1 names. These were most extensively documented in the v5.14 version of this pod: &lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&lt;/a&gt;.</source>
          <target state="translated">Perl的早期版本几乎接受所有6.1名称。这些内容在此pod的v5.14版本中得到了最广泛的记录：&lt;a href=&quot;http://perldoc.perl.org/5.14.0/charnames.html#ALIASES&quot;&gt;http&lt;/a&gt; ://perldoc.perl.org/5.14.0/charnames.html#ALIASES 。</target>
        </trans-unit>
        <trans-unit id="041f750894a2130f024fa1d40c0e0cb8140d53b7" translate="yes" xml:space="preserve">
          <source>Earlier versions of Storable would immediately croak if they encountered a file with a higher internal version number than the reading Storable knew about. Internal version numbers are increased each time new data types (such as restricted hashes) are added to the vocabulary of the file format. This meant that a newer Storable module had no way of writing a file readable by an older Storable, even if the writer didn't store newer data types.</source>
          <target state="translated">早期版本的Storable如果遇到一个内部版本号高于Storable所知道的读取的文件,就会立即呱呱叫。每当新的数据类型(如限制性哈希)被添加到文件格式的词汇中时,内部版本号就会增加。这意味着,一个新的Storable模块没有办法写入一个旧的Storable可读的文件,即使写入者没有存储新的数据类型。</target>
        </trans-unit>
        <trans-unit id="e4b297dbcd2a6bb824d7c2a7ee2008800dedb8e3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641edf650debd12f3350ba77247f6ae399c9cef3" translate="yes" xml:space="preserve">
          <source>Earlier, we mentioned that the &lt;code&gt;File&lt;/code&gt; class's &lt;code&gt;last_mod_time&lt;/code&gt; accessor could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object. This is a perfect example of composition. We could go even further, and make the &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; accessors return objects as well. The &lt;code&gt;File&lt;/code&gt; class would then be &lt;b&gt;composed&lt;/b&gt; of several other objects.</source>
          <target state="translated">之前，我们提到 &lt;code&gt;File&lt;/code&gt; 类的 &lt;code&gt;last_mod_time&lt;/code&gt; 访问器可以返回&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;对象。这是构图的完美示例。我们可以走得更远，并使 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; 访问器也返回对象。然后， &lt;code&gt;File&lt;/code&gt; 类将由其他几个对象&lt;b&gt;组成&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0f33a9394c2fcd538084772b52d2341a61de3e00" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22 and 5.24, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e2d95ddabd105e29656829184c35d2859c555dc" translate="yes" xml:space="preserve">
          <source>Early Perl versions worked on some EBCDIC machines, but the last known version that ran on EBCDIC was v5.8.7, until v5.22, when the Perl core again works on z/OS. Theoretically, it could work on OS/400 or Siemens' BS2000 (or their successors), but this is untested. In v5.22, not all the modules found on CPAN but shipped with core Perl work on z/OS.</source>
          <target state="translated">早期的Perl版本可以在一些EBCDIC机器上工作,但最后一个在EBCDIC上运行的已知版本是v5.8.7,直到v5.22,Perl核心又可以在z/OS上工作。理论上,它可以在OS/400或西门子的BS2000(或它们的后续产品)上工作,但这是未经测试的。在v5.22中,并不是所有在CPAN上找到的模块都能在z/OS上工作,而是随核心Perl一起提供的。</target>
        </trans-unit>
        <trans-unit id="59b164194e7edb2e85034e9b78794d560a716b37" translate="yes" xml:space="preserve">
          <source>Ease testing test modules built with Test::Builder</source>
          <target state="translated">轻松测试用Test::Builder构建的测试模块。</target>
        </trans-unit>
        <trans-unit id="dae7ef5eb7ee790d1fea0c60a9c1de322881c27f" translate="yes" xml:space="preserve">
          <source>Easier to test new testing tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a188f6f02161d17a281a3ef192ea2346304b188" translate="yes" xml:space="preserve">
          <source>Easily interact with CPAN from the command line</source>
          <target state="translated">通过命令行轻松与CPAN互动</target>
        </trans-unit>
        <trans-unit id="45fc6c80b5f40c599a9996e4565f6c3c0441f578" translate="yes" xml:space="preserve">
          <source>Eclipse</source>
          <target state="translated">Eclipse</target>
        </trans-unit>
        <trans-unit id="995f14f2d2d8a63a7a9da7579e9e95a2acf52319" translate="yes" xml:space="preserve">
          <source>Ed Avis</source>
          <target state="translated">Ed Avis</target>
        </trans-unit>
        <trans-unit id="9b2f1a6097a83d57a9f13c69653ee867428c4309" translate="yes" xml:space="preserve">
          <source>Ed Avis &amp;lt;eda@linux01.wcl.local&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00837140532ce93fe6f2a0b0f08779867c4ee055" translate="yes" xml:space="preserve">
          <source>Ed J &amp;lt;mohawk2@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="528c45b93e145146f93473cbaa4675f9b54b16c1" translate="yes" xml:space="preserve">
          <source>Edgar &quot;Trizor&quot; Bering &amp;lt;trizor@gmail.com&amp;gt;</source>
          <target state="translated">埃德加&amp;ldquo; Trizor&amp;rdquo;白令&amp;lt;trizor@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f7a7e23b64ce5747c4a63c4739d2a868d6ca53c" translate="yes" xml:space="preserve">
          <source>Edit the GNUmakefile, makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76b3763dae70623eb55885995406de6279fdb6e" translate="yes" xml:space="preserve">
          <source>Edit the Makefile.PL file so that the corresponding line looks like this:</source>
          <target state="translated">编辑Makefile.PL文件,使相应的行看起来像这样。</target>
        </trans-unit>
        <trans-unit id="f7940347fff54108cd46081728a5cf85408a717b" translate="yes" xml:space="preserve">
          <source>Edit the files generated. You don't have to if you have no time AND no intention to give it to someone else. But it is a good idea to edit the pod and to add more tests.</source>
          <target state="translated">编辑生成的文件。如果你没有时间,也不打算把它给别人,你就不必这样做。但是,编辑pod和添加更多的测试是个好主意。</target>
        </trans-unit>
        <trans-unit id="954ea018e0a987091c4440d55ba64f48e0cccfe8" translate="yes" xml:space="preserve">
          <source>Edit the makefile.mk (or Makefile, if you're using nmake) and change the values of INST_DRV and INST_TOP. You can also enable various build flags. These are explained in the makefiles.</source>
          <target state="translated">编辑makefile.mk (或者Makefile,如果你使用的是nmake),并修改INST_DRV和INST_TOP的值。你也可以启用各种构建标志。这些在 makefile 中有解释。</target>
        </trans-unit>
        <trans-unit id="b93bb818c85552f3fcd19e172c258ef9c6aad22d" translate="yes" xml:space="preserve">
          <source>Editor Support for Debugging</source>
          <target state="translated">调试的编辑器支持</target>
        </trans-unit>
        <trans-unit id="68575b9eb0c3bb98d30a72178c5ff21f9fae81f0" translate="yes" xml:space="preserve">
          <source>Editor to use.</source>
          <target state="translated">小编要用。</target>
        </trans-unit>
        <trans-unit id="77cd7c3d29d911531fb7afe572b99c8c5ba4e8b7" translate="yes" xml:space="preserve">
          <source>Editorial adjustments by Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;</source>
          <target state="translated">Gurusamy Sarathy &amp;lt;gsar@ActiveState.com&amp;gt;的编辑调整</target>
        </trans-unit>
        <trans-unit id="e5b26fe0f2ccbc86d51353217407910ecc40ac72" translate="yes" xml:space="preserve">
          <source>Edward Zborowski &amp;lt;ed@rubensteintech.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73be54c86084c8c273a09c1c9821e5a9131296dd" translate="yes" xml:space="preserve">
          <source>Effect:</source>
          <target state="translated">Effect:</target>
        </trans-unit>
        <trans-unit id="8117456b097c6d57fb7d1f1dab282a3702937b2f" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. &lt;code&gt;SvPOK(sv)&lt;/code&gt;, or at least &lt;code&gt;SvPOKp(sv)&lt;/code&gt;, must be true and &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &lt;code&gt;OOK&lt;/code&gt; hack. On return, only &lt;code&gt;SvPOK(sv)&lt;/code&gt; and &lt;code&gt;SvPOKp(sv)&lt;/code&gt; among the &lt;code&gt;OK&lt;/code&gt; flags will be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7ac9002bbe557a0e89e8f9ac76410e740b68c3" translate="yes" xml:space="preserve">
          <source>Efficient removal of characters from the beginning of the string buffer. SvPOK(sv), or at least SvPOKp(sv), must be true and the &lt;code&gt;ptr&lt;/code&gt; must be a pointer to somewhere inside the string buffer. The &lt;code&gt;ptr&lt;/code&gt; becomes the first character of the adjusted string. Uses the &quot;OOK hack&quot;. On return, only SvPOK(sv) and SvPOKp(sv) among the OK flags will be true.</source>
          <target state="translated">从字符串缓冲区的开头有效删除字符。SvPOK（sv）或至少SvPOKp（sv）必须为true，并且 &lt;code&gt;ptr&lt;/code&gt; 必须为指向字符串缓冲区内部某处的指针。在 &lt;code&gt;ptr&lt;/code&gt; 成为调整字符串的第一个字符。使用&amp;ldquo; OOK hack&amp;rdquo;。返回时，只有OK标志中的SvPOK（sv）和SvPOKp（sv）为真。</target>
        </trans-unit>
        <trans-unit id="f18b25f084ce81b950168aedca18f94cb1425062" translate="yes" xml:space="preserve">
          <source>Efficiently compute time from local and GMT time</source>
          <target state="translated">高效地计算当地时间和GMT时间。</target>
        </trans-unit>
        <trans-unit id="654f6a3bdd1d9e4bdcf155781a2de9b4ed80c132" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;IO::String&lt;/code&gt; or &lt;code&gt;perlio&lt;/code&gt; support is needed to support writing stringified archives. Currently, &lt;code&gt;perlio&lt;/code&gt; is the preferred method, if available.</source>
          <target state="translated">需要 &lt;code&gt;IO::String&lt;/code&gt; 或 &lt;code&gt;perlio&lt;/code&gt; 支持来支持编写字符串化的存档。当前， &lt;code&gt;perlio&lt;/code&gt; 是首选方法（如果有）。</target>
        </trans-unit>
        <trans-unit id="85dba161f5ca6a960a7dc8fa1039724a8c09cad4" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (starting in Perl 5.10.0), or &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; (old-style) where</source>
          <target state="translated">任一 &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; （开始在Perl 5.10.0），或 &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; （旧式），其中</target>
        </trans-unit>
        <trans-unit id="52f049aa56476852e6a153929348eb18e7bf1459" translate="yes" xml:space="preserve">
          <source>Either a named or anonymous pipe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb02a27773229541ab59b1944bd46b1d5a6ebed2" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">可以是常规&lt;b&gt;赋值，&lt;/b&gt;也可以是由普通赋值和其他某种&lt;b&gt;运算符&lt;/b&gt;组成的复合&lt;b&gt;运算&lt;/b&gt;符，它们可以在适当位置更改变量的值；相对于其旧值。例如， &lt;code&gt;$a += 2&lt;/code&gt; 增加了 &lt;code&gt;2&lt;/code&gt; 至 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0dd3a0e7d7fd04d60cdb8e08fb04cc78c683756e" translate="yes" xml:space="preserve">
          <source>Either a regular &lt;b&gt;assignment&lt;/b&gt; or a compound &lt;b&gt;operator&lt;/b&gt; composed of an ordinary assignment and some other operator, that changes the value of a variable in place; that is, relative to its old value. For example, &lt;code&gt;$a += 2&lt;/code&gt; adds &lt;code&gt;2&lt;/code&gt; to &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281cd0fa078fd4c1ba948d728426cec878f64c16" translate="yes" xml:space="preserve">
          <source>Either assimilate new technologies, or build bridges to them.</source>
          <target state="translated">要么吸收新技术,要么为新技术搭桥。</target>
        </trans-unit>
        <trans-unit id="616b8deb9c86ed3074fc60088a26151e3856d891" translate="yes" xml:space="preserve">
          <source>Either form above will work. This will return a list of attributes defined on the object. This list is returned in the attribute definition order, parent class attributes are listed before subclass attributes. Duplicate attributes will be removed before the list is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2577d609c330867bbdb6a4c63c0df0f3f5ae7cc8" translate="yes" xml:space="preserve">
          <source>Either have an argumentless =over, or have its argument a strictly positive number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b1d548fa9375ac8cee4b6bb3288cae52feda67" translate="yes" xml:space="preserve">
          <source>Either not implemented or a no-op. (Android)</source>
          <target state="translated">要么不执行,要么不操作。(Android)</target>
        </trans-unit>
        <trans-unit id="9fd8e33d6202aef3ccb0a1588e2309a6eeaf7193" translate="yes" xml:space="preserve">
          <source>Either of &lt;code&gt;LocalService&lt;/code&gt; or &lt;code&gt;PeerService&lt;/code&gt; (or their &lt;code&gt;...Port&lt;/code&gt; synonyms) can be either a service name, a decimal number, or a string containing both a service name and number, in a form such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6aadb20634080f518a8887a688da9b1fee48d93" translate="yes" xml:space="preserve">
          <source>Either of the above forms of &quot;layer&quot; specifications can be made the default for a lexical scope with the &lt;code&gt;use open ...&lt;/code&gt; pragma. See &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47f17b2cb7b7674bb2cbd89473a3cd6f362bf48" translate="yes" xml:space="preserve">
          <source>Either of the following will work instead:</source>
          <target state="translated">以下任何一种方法都可以代替:</target>
        </trans-unit>
        <trans-unit id="e5a6a14049fff21a602c284699a2c9fbe3ca6693" translate="yes" xml:space="preserve">
          <source>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\&lt;/code&gt; the same in a path, you might as well use the one that doesn't clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</source>
          <target state="translated">可以单引号括住您的字符串，或者（最好）使用正斜杠。由于自MS-DOS 2.0之类以来的所有DOS和Windows版本在路径中都将 &lt;code&gt;/&lt;/code&gt; 和 &lt;code&gt;\&lt;/code&gt; 视为相同，因此您最好使用与Perl不冲突的版本-或POSIX shell，ANSI C和C ++，awk，Tcl，Java或Python，仅举几例。POSIX路径也更可移植。</target>
        </trans-unit>
        <trans-unit id="a48425d47cea1024da1aa0b5eb56b9a2e8f4b87c" translate="yes" xml:space="preserve">
          <source>Either stringify the structure yourself (no fun), or else get the MLDBM (which uses Data::Dumper) module from CPAN and layer it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but it can be a bit slow.</source>
          <target state="translated">要么自己对结构进行字符串化 (没意思),要么从 CPAN 获取 MLDBM (它使用 Data::Dumper)模块,然后把它层叠在 DB_File 或 GDBM_File 上。你也可以试试DBM::Deep,但它可能有点慢。</target>
        </trans-unit>
        <trans-unit id="f91179ba5041e3cd11279b2a09e8c8dafe42d600" translate="yes" xml:space="preserve">
          <source>Either the 5.006001 or the 5.6.1 format is acceptable.</source>
          <target state="translated">5.006001或5.6.1格式均可接受。</target>
        </trans-unit>
        <trans-unit id="f3046bc2658fc9703b653ff4f645f1c7f4b09d3a" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="translated">当使用带有单个索引的数组切片时， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 编译指示或&lt;b&gt;-w&lt;/b&gt;标志都会警告您。</target>
        </trans-unit>
        <trans-unit id="175fe2f08cb303f8f8870d3f7cd0357b5f36d7a6" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag will warn you when you use an array slice with a single index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906b6fd14fb2f43afa53be4e9384438767144648" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;warnings::warn&lt;/code&gt; or &lt;code&gt;warnings::warnif&lt;/code&gt; function should be used to actually display the warnings message. This is because they can make use of the feature that allows warnings to be escalated into fatal errors. So in this case</source>
          <target state="translated">任一 &lt;code&gt;warnings::warn&lt;/code&gt; 或 &lt;code&gt;warnings::warnif&lt;/code&gt; 功能应当用于实际显示的警告消息。这是因为他们可以利用允许将警告升级为致命错误的功能。所以在这种情况下</target>
        </trans-unit>
        <trans-unit id="0780376e7962816fa4ff7b6a652f65ef6eadb7db" translate="yes" xml:space="preserve">
          <source>Either use parentheses or the high-precedence variant of the operator.</source>
          <target state="translated">要么使用括号,要么使用运算符的高位变体。</target>
        </trans-unit>
        <trans-unit id="ac2efacdb85d4049866934d48a775a119bbac29d" translate="yes" xml:space="preserve">
          <source>Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6479b4a431808cf309ed8137f781bb957df27d9" translate="yes" xml:space="preserve">
          <source>Either you don't have more than one line in the string you're looking at (probably), or else you aren't using the correct modifier(s) on your pattern (possibly).</source>
          <target state="translated">要不就是你正在查看的字符串中没有多于一行(可能),要不就是你没有在模式上使用正确的修饰符(可能)。</target>
        </trans-unit>
        <trans-unit id="e153f909edaedd24892df1d401944b8821af0128" translate="yes" xml:space="preserve">
          <source>Elapsed Real Time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45775ed8dae80c63b3497b4ea826a44ca2dea3f" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="translated">Elapsed返回一个&lt;a href=&quot;../../benchmark&quot;&gt;Benchmark&lt;/a&gt;对象，该对象表示聚合测试的运行时间。为了使 &lt;code&gt;elapsed&lt;/code&gt; 时间有效，您必须在运行测试之前调用 &lt;code&gt;start&lt;/code&gt; ,然后立即 &lt;code&gt;stop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fb6b6b80655efc89d39c9e3dbc4f534ad641e2d" translate="yes" xml:space="preserve">
          <source>Elapsed returns a &lt;a href=&quot;benchmark&quot;&gt;Benchmark&lt;/a&gt; object that represents the running time of the aggregated tests. In order for &lt;code&gt;elapsed&lt;/code&gt; to be valid you must call &lt;code&gt;start&lt;/code&gt; before running the tests and &lt;code&gt;stop&lt;/code&gt; immediately afterwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685684a16f4001786549b1ab800e18b9d9c7dce4" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the perl5 administrator.</source>
          <target state="translated">perl5管理员的电子邮箱地址。</target>
        </trans-unit>
        <trans-unit id="0206d29187ee24de18ffe8c7060208c783959fc1" translate="yes" xml:space="preserve">
          <source>Electronic mail address of the person who ran Configure. This can be used by units that require the user's e-mail, like</source>
          <target state="translated">运行配置的人的电子邮箱地址。需要用户电子邮箱的单位可以使用此地址,如</target>
        </trans-unit>
        <trans-unit id="fb92ce1ec6eee388978bf1476ef4da0f49ddc2f4" translate="yes" xml:space="preserve">
          <source>Element Types and Accessor Methods</source>
          <target state="translated">元素类型和存取器方法</target>
        </trans-unit>
        <trans-unit id="56be9d95047d3837a8e260ecf6fab5aa5091179f" translate="yes" xml:space="preserve">
          <source>Eliminate the macros in the output to the MMS/MMK file.</source>
          <target state="translated">消除输出到MMS/MMK文件中的宏。</target>
        </trans-unit>
        <trans-unit id="0043730cfa58902fc1eb2bab5c9cf7b854c601fd" translate="yes" xml:space="preserve">
          <source>Eliminates any information in the type-ahead buffer on a read from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372fe5af53dfb10b96df623d9727deb1110a3dd2" translate="yes" xml:space="preserve">
          <source>Email any corrections or questions to me.</source>
          <target state="translated">如有更正或问题,请发邮件给我。</target>
        </trans-unit>
        <trans-unit id="2f6c017bc97bb2714dd0b54f8c31090aba3e0c32" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::SMTP</source>
          <target state="translated">Email::Sender::Transport::SMTP</target>
        </trans-unit>
        <trans-unit id="f4fe0960af2e7da0a8e6abd0220f7fb9ccfc0f82" translate="yes" xml:space="preserve">
          <source>Email::Sender::Transport::Sendmail</source>
          <target state="translated">Email::Sender::Transport::Sendmail</target>
        </trans-unit>
        <trans-unit id="a5bcdc422fa0c0f86b08b10ed2c448b54076951e" translate="yes" xml:space="preserve">
          <source>Embedded Code Execution Frequency</source>
          <target state="translated">嵌入式代码执行频率</target>
        </trans-unit>
        <trans-unit id="1c0d431f261d9feabca2f4bf0f5d2be5226959da" translate="yes" xml:space="preserve">
          <source>Embedded Ctrl-As (octal 001) in the input will be mapped to spaces on output, due to an internal implementation detail.</source>
          <target state="translated">由于内部实施细节,输入中的嵌入式Ctrl-As(八进制001)将被映射到输出中的空格。</target>
        </trans-unit>
        <trans-unit id="b65de96935df088746b85b44766bded2aa4a92cf" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d707633278129886b9180244ca67da739555e" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can also turn off any modifiers already present by using, e.g., &lt;code&gt;(?-i)&lt;/code&gt;. Modifiers can also be combined into a single expression, e.g., &lt;code&gt;(?s-i)&lt;/code&gt; turns on single line mode and turns off case insensitivity.</source>
          <target state="translated">嵌入式修饰符还可以通过使用 &lt;code&gt;(?-i)&lt;/code&gt; 关闭所有已经存在的修饰符。修饰符也可以组合成单个表达式，例如 &lt;code&gt;(?s-i)&lt;/code&gt; 打开单行模式并关闭不区分大小写。</target>
        </trans-unit>
        <trans-unit id="609e053d4c0081ee95d3a87942874703d9f5ab55" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8b1388248a7771ad7a19db052c3e57cdc37002" translate="yes" xml:space="preserve">
          <source>Embedded modifiers can have two important advantages over the usual modifiers. Embedded modifiers allow a custom set of modifiers to</source>
          <target state="translated">嵌入式修改器与通常的修改器相比,有两个重要的优势。嵌入的修饰符允许一组自定义的修饰符,以</target>
        </trans-unit>
        <trans-unit id="77fff13bcd07ad216d2d3e4a9dc81f2e17688911" translate="yes" xml:space="preserve">
          <source>Embedded modifiers may also be added to a non-capturing grouping. &lt;code&gt;(?i-m:regexp)&lt;/code&gt; is a non-capturing grouping that matches &lt;code&gt;regexp&lt;/code&gt; case insensitively and turns off multi-line mode.</source>
          <target state="translated">嵌入的修饰符也可以添加到非捕捉分组中。 &lt;code&gt;(?i-m:regexp)&lt;/code&gt; 是一个非捕获组，它不区分大小写地匹配 &lt;code&gt;regexp&lt;/code&gt; 并关闭多行模式。</target>
        </trans-unit>
        <trans-unit id="b92d8665944f4979bd50de8585ed3b0fd45dfa5f" translate="yes" xml:space="preserve">
          <source>Embedding Functions</source>
          <target state="translated">嵌入功能</target>
        </trans-unit>
        <trans-unit id="dfab320700daa38157038d3e70e9093fcfa26c1f" translate="yes" xml:space="preserve">
          <source>Embedding Perl inside a 64-bit application.</source>
          <target state="translated">在64位应用程序中嵌入Perl。</target>
        </trans-unit>
        <trans-unit id="0694b8bb0407da0c117f25cc81dd5d48908ff82d" translate="yes" xml:space="preserve">
          <source>Embedding Perl under Win32</source>
          <target state="translated">在Win32下嵌入Perl</target>
        </trans-unit>
        <trans-unit id="9cbcae97b606ebda37a4c9c0051aab393c7f7d13" translate="yes" xml:space="preserve">
          <source>Embedding Pods in Perl Modules</source>
          <target state="translated">在Perl模块中嵌入花苞</target>
        </trans-unit>
        <trans-unit id="3332088412158a65b80fc73f2172f27d8031dce4" translate="yes" xml:space="preserve">
          <source>Embedding comments and modifiers in a regular expression</source>
          <target state="translated">在正则表达式中嵌入注释和修饰符。</target>
        </trans-unit>
        <trans-unit id="2f84d71eabfb2db471c3906b955c997d8f2ea42c" translate="yes" xml:space="preserve">
          <source>Emboldened by this, you dive into the second phrase that your software needs to output: &quot;Your query matched 10 files in 4 directories.&quot;. You notice that if you want to treat phrases as indivisible, as the gettext manual wisely advises, you need four cases now, instead of two, to cover the permutations of singular and plural on the two items, $dir_count and $file_count. So you try this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7beea65f566b123cc3fc19969be422b43965af" translate="yes" xml:space="preserve">
          <source>Emit the popular wake-on-lan magic udp packet to wake up a local device. See also &lt;a href=&quot;Net::Wake&quot;&gt;Net::Wake&lt;/a&gt;, but this has the mac address as 1st arg. &lt;code&gt;$host&lt;/code&gt; should be the local gateway. Without it will broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1ebe53d6ccd7815c61ce7589f6b78c18dd612d" translate="yes" xml:space="preserve">
          <source>Emits a warning, usually by printing it to &lt;code&gt;STDERR&lt;/code&gt;. &lt;code&gt;warn&lt;/code&gt; interprets its operand LIST in the same way as &lt;code&gt;die&lt;/code&gt;, but is slightly different in what it defaults to when LIST is empty or makes an empty string. If it is empty and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; already contains an exception value then that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt;. If it is empty and &lt;code&gt;$@&lt;/code&gt; is also empty then the string &lt;code&gt;&quot;Warning: Something's wrong&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d5d024243158295b0b17ef00bb9b23203d9360" translate="yes" xml:space="preserve">
          <source>EmojiSources.txt</source>
          <target state="translated">EmojiSources.txt</target>
        </trans-unit>
        <trans-unit id="182fa8e51f2878e5ebff39e46c9563939a1274d1" translate="yes" xml:space="preserve">
          <source>Empty (?) without any modifiers in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ea7a43c3020a563e25bd1eedc14c28db07661d" translate="yes" xml:space="preserve">
          <source>Empty \%c in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482c748a5823d75ff12d9a6680ae909964eacc76" translate="yes" xml:space="preserve">
          <source>Empty \%c{}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c45054945a8770b05f8103d2a4a0bb1b804cbf85" translate="yes" xml:space="preserve">
          <source>Empty \%c{} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abbe29d0eda029ba0d774099d16a176aaf760777" translate="yes" xml:space="preserve">
          <source>Empty parts of the file/buffer will have NULL (0x00) bytes written to them.</source>
          <target state="translated">文件/缓冲区的空部分将有NULL (0x00)字节写入其中。</target>
        </trans-unit>
        <trans-unit id="bd4ef1b6c1ef24f987c292a748ebade1052ce4dc" translate="yes" xml:space="preserve">
          <source>Empty strings as well as other illegal numbers results in 'NaN'.</source>
          <target state="translated">空字符串以及其他非法数字的结果是'NaN'。</target>
        </trans-unit>
        <trans-unit id="b78fcf2b7184ff747f91ac2d4e85304d73a66a8f" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">清空现有内容的文件，可以在打开要写入的文件时自动清空，也可以通过 &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; 函数明确清空。</target>
        </trans-unit>
        <trans-unit id="f60475c9fb8f070699dc0b6997447641f41933fa" translate="yes" xml:space="preserve">
          <source>Emptying a file of existing contents, either automatically when opening a file for writing or explicitly via the &lt;code&gt;truncate&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3810839f51735c2952e4638769a72e1f188779e" translate="yes" xml:space="preserve">
          <source>Emulate low-level math with BigInt code</source>
          <target state="translated">用BigInt代码模拟低级数学。</target>
        </trans-unit>
        <trans-unit id="eaff5ce9fb66a8294a29b4afda7fa93b8fb7b74b" translate="yes" xml:space="preserve">
          <source>Emulated using multiple interpreters. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;. (Win32)</source>
          <target state="translated">使用多个解释器进行仿真。参见&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;。（Win32的）</target>
        </trans-unit>
        <trans-unit id="a7b07a2e86e21bbe02318bb5339e9e3819d02d9c" translate="yes" xml:space="preserve">
          <source>Emulated using synchronization functions such that it can be interrupted by &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;, and limited to a maximum of 4294967 seconds, approximately 49 days. (Win32)</source>
          <target state="translated">使用同步功能进行仿真，以使其可以被 &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; 中断，并且最长为4294967秒，大约49天。（Win32的）</target>
        </trans-unit>
        <trans-unit id="2fab2548b326a0aed3bd44319bab854e6c0cf455" translate="yes" xml:space="preserve">
          <source>Emulated using timers that must be explicitly polled whenever Perl wants to dispatch &quot;safe signals&quot; and therefore cannot interrupt blocking system calls. (Win32)</source>
          <target state="translated">使用定时器进行仿真,每当Perl要调度 &quot;安全信号 &quot;时,必须对其进行显式轮询,因此不能中断阻塞系统调用。(Win32)</target>
        </trans-unit>
        <trans-unit id="9b1e45abf8f6f88976507fbf984db8d99aa517be" translate="yes" xml:space="preserve">
          <source>Emulates Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; (which considers &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; to indicate an error) by mapping the &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;SS$_ABORT&lt;/code&gt; (&lt;code&gt;44&lt;/code&gt; ). This behavior may be overridden with the pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; . As with the CRTL's &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; function, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; is also mapped to an exit status of &lt;code&gt;SS$_NORMAL&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt; ); this mapping cannot be overridden. Any other argument to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; is used directly as Perl's exit status. On VMS, unless the future POSIX_EXIT mode is enabled, the exit code should always be a valid VMS exit code and not a generic number. When the POSIX_EXIT mode is enabled, a generic number will be encoded in a method compatible with the C library _POSIX_EXIT macro so that it can be decoded by other programs, particularly ones written in C, like the GNV package. (VMS)</source>
          <target state="translated">通过将 &lt;code&gt;1&lt;/code&gt; 映射到 &lt;code&gt;SS$_ABORT&lt;/code&gt; （ &lt;code&gt;44&lt;/code&gt; ）来模拟Unix &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; （认为 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 1&lt;/code&gt; 指示错误）。可以通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'exit'&lt;/code&gt; vmsish'exit'来覆盖此行为。与CRTL的 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 函数一样， &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt; 0&lt;/code&gt; 0也映射到 &lt;code&gt;SS$_NORMAL&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）的出口状态。此映射不能被覆盖。任何其他参数 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; 直接用作Perl的退出状态。在VMS上，除非启用了将来的POSIX_EXIT模式，否则退出代码应始终是有效的VMS退出代码，而不是通用编号。启用POSIX_EXIT模式后，将使用与C库_POSIX_EXIT宏兼容的方法对通用编号进行编码，以便可以由其他程序（尤其是用C编写的程序，如GNV程序包）对其进行解码。（VMS）</target>
        </trans-unit>
        <trans-unit id="2c857b36dcd15d79dca987f0a21532d5543740f0" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8694061aed01e45167cf3a5722aa921d3e6ee71" translate="yes" xml:space="preserve">
          <source>Emulation is provided for &lt;code&gt;runtests&lt;/code&gt; and &lt;code&gt;execute_tests&lt;/code&gt; but the pluggable 'Straps' interface that previous versions of &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; supported is not reproduced here. Straps is now available as a stand alone module: &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;.</source>
          <target state="translated">提供模拟 &lt;code&gt;runtests&lt;/code&gt; 和 &lt;code&gt;execute_tests&lt;/code&gt; 但可插拔&amp;ldquo;绳&amp;rdquo;界面，以前的版本&lt;a href=&quot;harness&quot;&gt;测试::线束&lt;/a&gt;支持不转载。皮带现在可以作为独立模块使用：&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c3201c23058080f5cca7ba534770368c083d322" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all execute options. Equivalent to:</source>
          <target state="translated">启用DUMP和所有执行选项。相当于:</target>
        </trans-unit>
        <trans-unit id="3519927c57abd6568424c455930c1e3320ae7f4f" translate="yes" xml:space="preserve">
          <source>Enable DUMP and all non-extra execute options. Equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3687b13f8be99eb4a1bd7121c185ac6fb0233a5d" translate="yes" xml:space="preserve">
          <source>Enable Verbose mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb7295d3b950c4331c9fe377d6496cd34ea08ee" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS. (To get every single option without exception, use both ALL and EXTRA.)</source>
          <target state="translated">同时启用除OFFSETS、OFFSETSDBG和BUFFERS以外的所有选项。(要想毫无例外地获得每一个选项,请同时使用ALL和EXTRA。)</target>
        </trans-unit>
        <trans-unit id="605ee0c2cc03659c524ca183e1ce55b5400e895c" translate="yes" xml:space="preserve">
          <source>Enable all options at once except OFFSETS, OFFSETSDBG, BUFFERS, WILDCARD, and DUMP_PRE_OPTIMIZE. (To get every single option without exception, use both ALL and EXTRA, or starting in 5.30 on a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter, use the &lt;b&gt;-Drv&lt;/b&gt; command-line switches.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c54f50dbe8b1d2b9d4279a847b1af1e242ac5db" translate="yes" xml:space="preserve">
          <source>Enable caching of timings for the null loop. The time taken for COUNT rounds of the null loop will be calculated only once for each different COUNT used.</source>
          <target state="translated">启用空循环的计时缓存。每使用一个不同的COUNT,null循环的COUNT轮所需时间将只计算一次。</target>
        </trans-unit>
        <trans-unit id="af34a92294247e0324cf9cb4ab7591c0157d3cc4" translate="yes" xml:space="preserve">
          <source>Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.</source>
          <target state="translated">启用偏移量信息的调试。这将发出大量的跟踪信息,并且与其他调试选项不相匹配。</target>
        </trans-unit>
        <trans-unit id="b22eafe66ff9363c232181834545b3e27fc24dda" translate="yes" xml:space="preserve">
          <source>Enable debugging of start-point optimisations.</source>
          <target state="translated">启用启动点优化的调试。</target>
        </trans-unit>
        <trans-unit id="b1ed4094a3f33fb70b77d3ab5d3985c70cad2408" translate="yes" xml:space="preserve">
          <source>Enable debugging of states in the engine.</source>
          <target state="translated">启用引擎中的状态调试。</target>
        </trans-unit>
        <trans-unit id="6cc2f783a9f51a88860f66f38bb6654412ccd3b7" translate="yes" xml:space="preserve">
          <source>Enable debugging of the \G modifier.</source>
          <target state="translated">启用\G修改器的调试。</target>
        </trans-unit>
        <trans-unit id="8b1fc985774fbcf866da54c3c69b513cb35f440c" translate="yes" xml:space="preserve">
          <source>Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</source>
          <target state="translated">启用引擎中递归栈的调试。启用或禁用这个选项也会自动对调试状态进行同样的操作。这其中的输出可能相当大。</target>
        </trans-unit>
        <trans-unit id="ed7bfb6f5b63e62332ddfc6bbbaf1f7a2a0d576b" translate="yes" xml:space="preserve">
          <source>Enable debugging output.</source>
          <target state="translated">启用调试输出。</target>
        </trans-unit>
        <trans-unit id="139048524bc56f6e0f7692e0183c038f5bfd94d8" translate="yes" xml:space="preserve">
          <source>Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</source>
          <target state="translated">在匹配过程中启用调试捕获组存储。警告,这可能会产生非常大的输出。</target>
        </trans-unit>
        <trans-unit id="d009cb1e8dd02879690564369c53161c26ba761e" translate="yes" xml:space="preserve">
          <source>Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</source>
          <target state="translated">启用增强的TRIE调试功能。增强TRIEE和TRIEC的功能。</target>
        </trans-unit>
        <trans-unit id="ef5eb4e7b2447bf19044b39ea2e195cd6618fd76" translate="yes" xml:space="preserve">
          <source>Enable enhanced optimisation debugging and start-point optimisations. Probably not useful except when debugging the regexp engine itself.</source>
          <target state="translated">启用增强的优化调试和起始点优化。除非调试regexp引擎本身,否则可能没什么用。</target>
        </trans-unit>
        <trans-unit id="07e248f2e2b8869e02ee4bbd9a3b445fa1e02104" translate="yes" xml:space="preserve">
          <source>Enable new features</source>
          <target state="translated">启用新功能</target>
        </trans-unit>
        <trans-unit id="82441ac52d9ab4a30896d0bdffedf2a9be220d10" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt; , &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="translated">启用对 &lt;code&gt;IN&lt;/code&gt; ， &lt;code&gt;OUT_LIST&lt;/code&gt; 和 &lt;code&gt;INOUT_LIST&lt;/code&gt; 声明的识别。默认为true。</target>
        </trans-unit>
        <trans-unit id="fdedc1b60d005db3c310868a2b39cafdd59a5eb1" translate="yes" xml:space="preserve">
          <source>Enable recognition of &lt;code&gt;IN&lt;/code&gt;, &lt;code&gt;OUT_LIST&lt;/code&gt; and &lt;code&gt;INOUT_LIST&lt;/code&gt; declarations. Default is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04f3ebaeb9867e3812b1e018ab387d5924f7ef6" translate="yes" xml:space="preserve">
          <source>Enable recognition of ANSI-like descriptions of function signature. Default is true.</source>
          <target state="translated">启用识别类似ANSI的函数签名描述。默认为true。</target>
        </trans-unit>
        <trans-unit id="8fa85b7034e330ca755a5c73c63b76397e087c71" translate="yes" xml:space="preserve">
          <source>Enable simple signal handling</source>
          <target state="translated">启用简单的信号处理</target>
        </trans-unit>
        <trans-unit id="3c3a9e686f47a71d2d2bd49c91054de061662284" translate="yes" xml:space="preserve">
          <source>Enable the breakpoint so it will stop the execution of the program.</source>
          <target state="translated">启用断点,使其停止程序的执行。</target>
        </trans-unit>
        <trans-unit id="4a2a1634a6a3ef06d28edb649a7e0d6a7bf8554f" translate="yes" xml:space="preserve">
          <source>Enable the dumping of the compiled pattern before the optimization phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd4f88c7522d41d4cd111539c1b1db699d331e1" translate="yes" xml:space="preserve">
          <source>Enable the options enabled by &quot;All&quot;, plus STATE, TRIEC, and TRIEM.</source>
          <target state="translated">启用 &quot;全部 &quot;启用的选项,加上STATE、TRIEC和TRIEM。</target>
        </trans-unit>
        <trans-unit id="6607ef3ad5faa3d582896ad07ab9785dae90ca8e" translate="yes" xml:space="preserve">
          <source>Enable this option if you wish all spawned processes to be killed if the initially spawned process (the parent) is killed or dies without waiting for child processes.</source>
          <target state="translated">如果您希望在初始产卵进程(父进程)被杀死或死亡时,无需等待子进程,就能杀死所有产卵进程,请启用此选项。</target>
        </trans-unit>
        <trans-unit id="b7b7c90b9b4e4815dd4d9b7ad285d70eda8ebb7d" translate="yes" xml:space="preserve">
          <source>Enable/disable UTF-8 (or UTF-EBCDIC) in source code</source>
          <target state="translated">在源代码中启用/禁用UTF-8(或UTF-EBCDIC)。</target>
        </trans-unit>
        <trans-unit id="80acee2f67ff4da70c6002b5a0e094b4d2f31c43" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt; . See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">使所有的警告，无论 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; 或 &lt;code&gt;$^W&lt;/code&gt; 。请参阅&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7b9030574fd9ae227a9d9bdb446332c94bd2ab62" translate="yes" xml:space="preserve">
          <source>Enables all warnings regardless of &lt;code&gt;no warnings&lt;/code&gt; or &lt;code&gt;$^W&lt;/code&gt;. See &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1089d1ea88536805f57559da91fba3d7a2761ecb" translate="yes" xml:space="preserve">
          <source>Enables certain optimizations. The only optimization that is currently affected is the use of</source>
          <target state="translated">启用某些优化。目前唯一受影响的优化是使用了</target>
        </trans-unit>
        <trans-unit id="c2846984fdcc8df09665bcc109bb5474af315f7d" translate="yes" xml:space="preserve">
          <source>Enables or disable debugging by setting the &lt;code&gt;$Benchmark::Debug&lt;/code&gt; flag:</source>
          <target state="translated">通过设置 &lt;code&gt;$Benchmark::Debug&lt;/code&gt; 标志启用或禁用调试：</target>
        </trans-unit>
        <trans-unit id="9d480a633ce9bb7aa941c3d98a4cbb4d5ac2bf6a" translate="yes" xml:space="preserve">
          <source>Enables output related to the optimisation phase of compilation.</source>
          <target state="translated">启用与编译的优化阶段相关的输出。</target>
        </trans-unit>
        <trans-unit id="8017ccdfaea2ad3f4aa3c94d96674940233700a6" translate="yes" xml:space="preserve">
          <source>Enables use of the prompt specified by pmt=usr-prmpt on input from the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55c00ee236233e66b2d47bad2c1ced81c03c99b" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;bundling_values&lt;/code&gt; will disable the other two styles of bundling.</source>
          <target state="translated">启用 &lt;code&gt;bundling_values&lt;/code&gt; 将禁用其他两种捆绑样式。</target>
        </trans-unit>
        <trans-unit id="b18f32d5490f57e3f4e0f875c588a069b00f5590" translate="yes" xml:space="preserve">
          <source>Enabling the &lt;code&gt;utf8&lt;/code&gt; pragma has the following effect:</source>
          <target state="translated">启用 &lt;code&gt;utf8&lt;/code&gt; 编译指示具有以下效果：</target>
        </trans-unit>
        <trans-unit id="7fe2071dd005ed63dfae111e383f15806253aa16" translate="yes" xml:space="preserve">
          <source>Enabling this option will allow single-character options to be bundled. To distinguish bundles from long option names, long options</source>
          <target state="translated">启用此选项将允许捆绑单字符选项。为了区别于长选项名称的捆绑,长选项</target>
        </trans-unit>
        <trans-unit id="867d7c3018e88764391a8a8cad25d71d6020f155" translate="yes" xml:space="preserve">
          <source>Encapsulation</source>
          <target state="translated">Encapsulation</target>
        </trans-unit>
        <trans-unit id="2059232562a427f990749c23a8c8ebdde1b9014d" translate="yes" xml:space="preserve">
          <source>Encapsulation is important for several reasons. First, it allows you to separate the public API from the private implementation. This means you can change that implementation without breaking the API.</source>
          <target state="translated">封装很重要,有几个原因。首先,它允许你把公共的API和私有的实现分开。这意味着你可以在不破坏API的情况下改变该实现。</target>
        </trans-unit>
        <trans-unit id="782e817cf07d938d62f7f0517e130f19ec6b4cf1" translate="yes" xml:space="preserve">
          <source>Encode</source>
          <target state="translated">Encode</target>
        </trans-unit>
        <trans-unit id="e276943b90499b3ae3cf8000afe6554906eb7f6a" translate="yes" xml:space="preserve">
          <source>Encode - character encodings in Perl</source>
          <target state="translated">Encode-Perl中的字符编码</target>
        </trans-unit>
        <trans-unit id="3c5a64c26d9e551da565d681ba9a9c2bc735a49c" translate="yes" xml:space="preserve">
          <source>Encode Implementation Base Class</source>
          <target state="translated">编码实现基类</target>
        </trans-unit>
        <trans-unit id="39e91613c24a80edc94f024f6bfb3382d7e896d8" translate="yes" xml:space="preserve">
          <source>Encode a scalar, hash reference or array reference as YAML.</source>
          <target state="translated">将一个标量、哈希引用或数组引用编码为YAML。</target>
        </trans-unit>
        <trans-unit id="a78fa70f2287f5b23c037b4b8025fba5e083909c" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;GB2312&lt;/code&gt; to &lt;code&gt;euc-cn&lt;/code&gt; in full agreement with IANA registration. &lt;code&gt;cp936&lt;/code&gt; is supported separately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09bb3342b0d46392bfdbf9d685c504c20ab444c4" translate="yes" xml:space="preserve">
          <source>Encode aliases &lt;code&gt;KS_C_5601-1987&lt;/code&gt; to &lt;code&gt;cp949&lt;/code&gt; to reflect this common misusage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b3896738d8cf6b15e5278f1369de611febee2e" translate="yes" xml:space="preserve">
          <source>Encode and decode according to the base64 scheme for &quot;URL applications&quot; [1]. This is a variant of the base64 encoding which does not use padding, does not break the string into multiple lines and use the characters &quot;-&quot; and &quot;_&quot; instead of &quot;+&quot; and &quot;/&quot; to avoid using reserved URL characters.</source>
          <target state="translated">根据 &quot;URL应用&quot;[1]的base64方案进行编码和解码。这是base64编码的一个变体,它不使用padding,不将字符串分成多行,并使用字符&quot;-&quot;和&quot;_&quot;代替 &quot;+&quot;和&quot;/&quot;以避免使用保留的URL字符。</target>
        </trans-unit>
        <trans-unit id="3d01d8346257820c445f334ba81d16daa9f20915" translate="yes" xml:space="preserve">
          <source>Encode consists of a collection of modules whose details are too extensive to fit in one document. This one itself explains the top-level APIs and general topics at a glance. For other topics and more details, see the documentation for these modules:</source>
          <target state="translated">Encode由一系列模块组成,这些模块的细节太多,无法在一个文档中体现。这个模块本身就解释了顶层API和一般主题,一目了然。关于其他主题和更多细节,请看这些模块的文档。</target>
        </trans-unit>
        <trans-unit id="90f9c590e83b0f216769d26a64108ee3d5af71e4" translate="yes" xml:space="preserve">
          <source>Encode converts from the beginning to \x7E, leaving \xe3 in the buffer because it is invalid (partial character).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5888dafc03b9c4595a9ef704f5d312540bc3c184" translate="yes" xml:space="preserve">
          <source>Encode data by calling the encode_base64() function. The first argument is the byte string to encode. The second argument is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. The returned encoded string is broken into lines of no more than 76 characters each and it will end with $eol unless it is empty. Pass an empty string as second argument if you do not want the encoded string to be broken into lines.</source>
          <target state="translated">通过调用 encode_base64()函数对数据进行编码。第一个参数是要编码的字节字符串。第二个参数是要使用的行尾序列。它是可选的,默认为&quot;\n&quot;。返回的编码字符串会被分成不超过76个字符的行,除非它是空的,否则会以$eol结尾。如果你不想让编码后的字符串分成几行,可以传一个空字符串作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="41b574dce061d3c694f8cd7218cbb982019874dd" translate="yes" xml:space="preserve">
          <source>Encode method takes a scalar string as its input and uses &lt;a href=&quot;encode#UTF-8-vs.-utf8-vs.-UTF8&quot;&gt;strict UTF-8&lt;/a&gt; encoder for encoding it to UTF-8 bytes. Then a sequence of UTF-8 bytes is encoded into MIME encoded-words (&lt;code&gt;MIME-Header&lt;/code&gt; and &lt;code&gt;MIME-B&lt;/code&gt; use a Base64 variant while &lt;code&gt;MIME-Q&lt;/code&gt; uses a Quoted-Printable variant) where each MIME encoded-word is limited to 75 characters. MIME encoded-words are separated by &lt;code&gt;CRLF SPACE&lt;/code&gt; and joined to one output string. Output string is suitable for unstructured field body of the email header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1878d2d011ae54a82ea1609093ac6e764e131f0" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Big5&lt;/code&gt; and &lt;code&gt;cp950&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f5b904d93724daaede7a0f5d5a6e265bb69f88" translate="yes" xml:space="preserve">
          <source>Encode separately supports &lt;code&gt;Shift_JIS&lt;/code&gt; and &lt;code&gt;cp932&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceff1e1e1923f02a7939b507f33300e3a696eaa2" translate="yes" xml:space="preserve">
          <source>Encode up to 1.86 internally used &quot;local $_&quot; to implement this older form. But consider the code below;</source>
          <target state="translated">Encode到1.86内部使用了 &quot;local $_&quot;来实现这种旧形式。但考虑到下面的代码。</target>
        </trans-unit>
        <trans-unit id="dec95d5717280ac4e0be7dcb9e6fc7bc4a47ecee" translate="yes" xml:space="preserve">
          <source>Encode uses the Unicode Character Map (UCM) format for source character mappings. This format is used by IBM's ICU package and was adopted by Nick Ing-Simmons for use with the Encode module. Since UCM is more flexible than Tcl's Encoding Map and far more user-friendly, this is the recommended format for Encode now.</source>
          <target state="translated">Encode使用Unicode字符映射(UCM)格式进行源字符映射。这种格式被IBM的ICU包使用,并被Nick Ing-Simmons采用,用于Encode模块。由于UCM比Tcl的Encoding Map更灵活,也更方便用户使用,所以现在Encode推荐使用这种格式。</target>
        </trans-unit>
        <trans-unit id="5d2cad9401edfbef92e75be01cb40c4e9ecc4cf6" translate="yes" xml:space="preserve">
          <source>Encode::Alias</source>
          <target state="translated">Encode::Alias</target>
        </trans-unit>
        <trans-unit id="552324ae1eb023be362415291b1291f3f52556a7" translate="yes" xml:space="preserve">
          <source>Encode::Alias - alias definitions to encodings</source>
          <target state="translated">Encode::Alias-编码的别名定义。</target>
        </trans-unit>
        <trans-unit id="cc91ef6d8b4186209599d785324e380db05af545" translate="yes" xml:space="preserve">
          <source>Encode::Byte</source>
          <target state="translated">Encode::Byte</target>
        </trans-unit>
        <trans-unit id="d4b97f8bcca673137fe3a8c4311fa29b1376a129" translate="yes" xml:space="preserve">
          <source>Encode::Byte - Single Byte Encodings</source>
          <target state="translated">Encode::Byte-单字节编码器</target>
        </trans-unit>
        <trans-unit id="930606b772f93c8896784219cc491d7a0cee7e76" translate="yes" xml:space="preserve">
          <source>Encode::Byte -- Extended ASCII</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f240792605e5eac4a6580e33ee29dcc7a428c2" translate="yes" xml:space="preserve">
          <source>Encode::Byte implements most single-byte encodings except for Symbols and EBCDIC. The following encodings are based on single-byte encodings implemented as extended ASCII. Most of them map \x80-\xff (upper half) to non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da29f26c3e55351d546a404e8b09b53f82affc8" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants</source>
          <target state="translated">Encode::CJKConstants</target>
        </trans-unit>
        <trans-unit id="97376755cadc9b08ac2bdcffa80b5c4759e6f7df" translate="yes" xml:space="preserve">
          <source>Encode::CJKConstants.pm -- Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">Encode::CJKConstants.pm --Encode::?:ISO_2022_*内部使用。</target>
        </trans-unit>
        <trans-unit id="44fea5bddc6721fb4b956554b9d88900826d60c7" translate="yes" xml:space="preserve">
          <source>Encode::CN</source>
          <target state="translated">Encode::CN</target>
        </trans-unit>
        <trans-unit id="40f3392265131b672490757c292c084a525d4184" translate="yes" xml:space="preserve">
          <source>Encode::CN - China-based Chinese Encodings</source>
          <target state="translated">Encode::CN-中国的中文编码系统</target>
        </trans-unit>
        <trans-unit id="56aaed97f5a41017265e5458630887666002ff6b" translate="yes" xml:space="preserve">
          <source>Encode::CN -- Continental China</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207660f321fc12762f2e79b28e35fbb26736a3e7" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ</source>
          <target state="translated">Encode::CN::HZ</target>
        </trans-unit>
        <trans-unit id="622d7b0a21ca0c1a08d6dda20da0057e0358570c" translate="yes" xml:space="preserve">
          <source>Encode::CN::HZ -- internally used by Encode::CN</source>
          <target state="translated">Encode::CN::HZ --Encode::CN内部使用。</target>
        </trans-unit>
        <trans-unit id="b24bb381f68ba02b49c4c2cd2767f183910da09e" translate="yes" xml:space="preserve">
          <source>Encode::Config</source>
          <target state="translated">Encode::Config</target>
        </trans-unit>
        <trans-unit id="0b7c024127a98fc8be2586eade5f76bc22701aab" translate="yes" xml:space="preserve">
          <source>Encode::Config -- internally used by Encode</source>
          <target state="translated">Encode::Config --Encode内部使用。</target>
        </trans-unit>
        <trans-unit id="2a8ba6ae9bd0735a827d283930aa3dc28cd2cae3" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC</source>
          <target state="translated">Encode::EBCDIC</target>
        </trans-unit>
        <trans-unit id="3b31a7154f7c03e9be274aacce1e4dc5a66d5ec6" translate="yes" xml:space="preserve">
          <source>Encode::EBCDIC - EBCDIC Encodings</source>
          <target state="translated">Encode::EBCDIC-EBCDIC编码器</target>
        </trans-unit>
        <trans-unit id="a0fb1479e2e68a75a05e36aff16d787758a1778e" translate="yes" xml:space="preserve">
          <source>Encode::Encoder</source>
          <target state="translated">Encode::Encoder</target>
        </trans-unit>
        <trans-unit id="3bfd37620385e094ff5d1811f8a5aaf8e5a7a125" translate="yes" xml:space="preserve">
          <source>Encode::Encoder -- Object Oriented Encoder</source>
          <target state="translated">Encode::Encoder --面向对象的编码器</target>
        </trans-unit>
        <trans-unit id="4551a7e4c9181d379ae1288237c1ebecccd59bb8" translate="yes" xml:space="preserve">
          <source>Encode::Encoding</source>
          <target state="translated">Encode::Encoding</target>
        </trans-unit>
        <trans-unit id="932dfcdaef25e880e85283d712d29f239746970b" translate="yes" xml:space="preserve">
          <source>Encode::Encoding - Encode Implementation Base Class</source>
          <target state="translated">Encode::Encoding-Encode实现基类</target>
        </trans-unit>
        <trans-unit id="77662ad703615bf25ca69905bb6db23d72296bb9" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338</source>
          <target state="translated">Encode::GSM0338</target>
        </trans-unit>
        <trans-unit id="ede01420f58b4c2565b3da82244d84c95da5b4af" translate="yes" xml:space="preserve">
          <source>Encode::GSM0338 -- ESTI GSM 03.38 Encoding</source>
          <target state="translated">Encode::GSM0338 --ESTI GSM 03.38 编码。</target>
        </trans-unit>
        <trans-unit id="e93ed447e10d95864f0386c026ec121cd47c60ab" translate="yes" xml:space="preserve">
          <source>Encode::Guess</source>
          <target state="translated">Encode::Guess</target>
        </trans-unit>
        <trans-unit id="8b1b151431a67a55222cbbcf0270cd834cbd2d46" translate="yes" xml:space="preserve">
          <source>Encode::Guess -- Guesses encoding from data</source>
          <target state="translated">Encode::Guess --从数据中猜测编码。</target>
        </trans-unit>
        <trans-unit id="f460e270f104cac10b54ab28764ae1739d32a63f" translate="yes" xml:space="preserve">
          <source>Encode::Guess does not work on EBCDIC platforms.</source>
          <target state="translated">Encode::Guess不能在EBCDIC平台上工作。</target>
        </trans-unit>
        <trans-unit id="8030a57667933f97cc9c39195dbf244e622a18a0" translate="yes" xml:space="preserve">
          <source>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</source>
          <target state="translated">Encode::Guess 使您能够猜测给定数据的编码,或者至少是尝试猜测。</target>
        </trans-unit>
        <trans-unit id="4c76dcf9e721cd63d6b7c64ae9ac390cd36bca44" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;add_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;add_suspects</target>
        </trans-unit>
        <trans-unit id="e5a679cb789609bd6b4f6bc29c3c93aa2af2b209" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;guess($data)</source>
          <target state="translated">Encode::Guess-&amp;gt;guess($data)</target>
        </trans-unit>
        <trans-unit id="91b94bb51243fdcafbdb22a3d3b975f9b8695d1d" translate="yes" xml:space="preserve">
          <source>Encode::Guess-&amp;gt;set_suspects</source>
          <target state="translated">Encode::Guess-&amp;gt;set_suspects</target>
        </trans-unit>
        <trans-unit id="a0735b72517ca9ff3c7f14337ef1ad3eeea0e3f0" translate="yes" xml:space="preserve">
          <source>Encode::HanExtra -- More Chinese via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f9eb31f93d16c6f8ad3ca48a91dab8c5071fe46" translate="yes" xml:space="preserve">
          <source>Encode::JIS2K -- JIS X 0213 encodings via CPAN</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37ee0e2e550bc3634d116c838f3ba94375b8c47" translate="yes" xml:space="preserve">
          <source>Encode::JP</source>
          <target state="translated">Encode::JP</target>
        </trans-unit>
        <trans-unit id="341afac777ffb0b1e52b3a6aa26c1fcd31687ea1" translate="yes" xml:space="preserve">
          <source>Encode::JP - Japanese Encodings</source>
          <target state="translated">Encode::JP-日文编码器</target>
        </trans-unit>
        <trans-unit id="4d2ce26abda0dd0d175937050c97398037e5cc87" translate="yes" xml:space="preserve">
          <source>Encode::JP -- Japan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6a27be2a727bdf7e4a113a80bef5ed7da8c32a" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z</source>
          <target state="translated">Encode::JP::H2Z</target>
        </trans-unit>
        <trans-unit id="61c842d29f655e9a02cc88f2dfe176c79b0a7ccb" translate="yes" xml:space="preserve">
          <source>Encode::JP::H2Z -- internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::H2Z --Encode::JP::2022_JP*内部使用。</target>
        </trans-unit>
        <trans-unit id="57d3b7cea6d80534a4eab96981ae8b12e91a572d" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7</source>
          <target state="translated">Encode::JP::JIS7</target>
        </trans-unit>
        <trans-unit id="728d78512ef0e5fd10db6af9228f9f55491f142e" translate="yes" xml:space="preserve">
          <source>Encode::JP::JIS7 -- internally used by Encode::JP</source>
          <target state="translated">Encode::JP::JIS7 --Encode::JP内部使用。</target>
        </trans-unit>
        <trans-unit id="9292d6d6d6c3d612ab88b4d0a9b44cce420ff5ea" translate="yes" xml:space="preserve">
          <source>Encode::KR</source>
          <target state="translated">Encode::KR</target>
        </trans-unit>
        <trans-unit id="32eef4f01d06c098fb548d1006c901f52a812e7e" translate="yes" xml:space="preserve">
          <source>Encode::KR - Korean Encodings</source>
          <target state="translated">Encode::KR-韩语编码。</target>
        </trans-unit>
        <trans-unit id="1af58b45e5ddb5840265bad145aa164eaffbeea7" translate="yes" xml:space="preserve">
          <source>Encode::KR -- Korea</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adea371ce7b9ff3c3566f35ac1420ac2e2ede009" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR</source>
          <target state="translated">Encode::KR::2022_KR</target>
        </trans-unit>
        <trans-unit id="3976fa623737771006bbaafdf23430529728651d" translate="yes" xml:space="preserve">
          <source>Encode::KR::2022_KR -- internally used by Encode::KR</source>
          <target state="translated">Encode::KR::2022_KR --Encode::KR内部使用。</target>
        </trans-unit>
        <trans-unit id="e9d431857fb2daca858cf0e24708414e6076d14b" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header</source>
          <target state="translated">Encode::MIME::Header</target>
        </trans-unit>
        <trans-unit id="f2030bc40a6a13ab85bce58de044a451e0f2022a" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME 'B' and 'Q' header encoding</source>
          <target state="translated">Encode::MIME::Header --MIME'B'和'Q'头编码。</target>
        </trans-unit>
        <trans-unit id="8d4bde122083dca41ec16dc22bc309e1ca8f4388" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Header -- MIME encoding for an unstructured email header</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e24530b4b214dbcf404910cce6c40e5661246" translate="yes" xml:space="preserve">
          <source>Encode::MIME::NAME -- internally used by Encode</source>
          <target state="translated">Encode::MIME::NAME --Encode内部使用。</target>
        </trans-unit>
        <trans-unit id="5f4e8291cc2cc181fac6cfb29c5aaebe19ffe8d7" translate="yes" xml:space="preserve">
          <source>Encode::MIME::Name</source>
          <target state="translated">Encode::MIME::Name</target>
        </trans-unit>
        <trans-unit id="28fab0785bc684a2a52d97e53a66b49d5527d9be" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO</source>
          <target state="translated">Encode::PerlIO</target>
        </trans-unit>
        <trans-unit id="41a3b8bb23e3f7b5138303897788011e915cffdf" translate="yes" xml:space="preserve">
          <source>Encode::PerlIO -- a detailed document on Encode and PerlIO</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd20dbfc849a216b8ec8f0aae8d9f22755869e7" translate="yes" xml:space="preserve">
          <source>Encode::Supported</source>
          <target state="translated">Encode::Supported</target>
        </trans-unit>
        <trans-unit id="eb0c5a3a273c3a4c4ad776ddaca0c86b8236ef3c" translate="yes" xml:space="preserve">
          <source>Encode::Supported -- Encodings supported by Encode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="617dc5e07f69ab0016776f02fcae4aa5417d4cf3" translate="yes" xml:space="preserve">
          <source>Encode::Symbol</source>
          <target state="translated">Encode::Symbol</target>
        </trans-unit>
        <trans-unit id="305d6a4ecfbcb83575125920205199ebfad9ecbc" translate="yes" xml:space="preserve">
          <source>Encode::Symbol - Symbol Encodings</source>
          <target state="translated">Encode::Symbol-符号编码器</target>
        </trans-unit>
        <trans-unit id="246710749ac240e0889edf0116d38bdff86ae7a9" translate="yes" xml:space="preserve">
          <source>Encode::Symbols</source>
          <target state="translated">Encode::Symbols</target>
        </trans-unit>
        <trans-unit id="7353083e24fd78826faff9ec9dd3ca1f0abfeb68" translate="yes" xml:space="preserve">
          <source>Encode::TW</source>
          <target state="translated">Encode::TW</target>
        </trans-unit>
        <trans-unit id="169a69c17f2e47c33a2090f250bc6f54465bac9c" translate="yes" xml:space="preserve">
          <source>Encode::TW - Taiwan-based Chinese Encodings</source>
          <target state="translated">Encode::TW-台湾的中文编码公司</target>
        </trans-unit>
        <trans-unit id="0a45467a524b47a94315245ccf968b728241554a" translate="yes" xml:space="preserve">
          <source>Encode::TW -- Taiwan</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f419db0e193bdb95ad1bf1d32e4308acad0add9f" translate="yes" xml:space="preserve">
          <source>Encode::Unicode</source>
          <target state="translated">Encode::Unicode</target>
        </trans-unit>
        <trans-unit id="2ba2c8325c871771b84294002113cdbbccea72d4" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- Various Unicode Transformation Formats</source>
          <target state="translated">Encode::Unicode --各种Unicode转换格式</target>
        </trans-unit>
        <trans-unit id="510f299bed8b57aaad0840b1977677d5faf52278" translate="yes" xml:space="preserve">
          <source>Encode::Unicode -- other Unicode encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24e91aa87151df83dcd6a084acf2bef4fbe28cca" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7</source>
          <target state="translated">Encode::Unicode::UTF7</target>
        </trans-unit>
        <trans-unit id="46189c892fa791248c9e1697ba2bd11d7d60c2a5" translate="yes" xml:space="preserve">
          <source>Encode::Unicode::UTF7 -- UTF-7 encoding</source>
          <target state="translated">Encode::Unicode::UTF7--UTF-7编码。</target>
        </trans-unit>
        <trans-unit id="89d34727747f027f9d8e6303c1a70b2655a0c0fe" translate="yes" xml:space="preserve">
          <source>Encode::decode(&quot;Guess&quot; ...)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca2ce49b12c2ee816a410523ba091dc693a60d6" translate="yes" xml:space="preserve">
          <source>Encodes a scalar, hash reference or array reference as YAMLish.</source>
          <target state="translated">将一个标量、哈希引用或数组引用编码为YAMLish。</target>
        </trans-unit>
        <trans-unit id="225ac8da293afbab880950db9793bf5ef9a811e8" translate="yes" xml:space="preserve">
          <source>Encodes the invocand as a byte string in the given format as specified in IEEE 754-2008. Note that the encoded value is the nearest possible representation of the value. This value might not be exactly the same as the value in the invocand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4c840f47e19e39ed11ebf36e763d836813b7799" translate="yes" xml:space="preserve">
          <source>Encodes the scalar value</source>
          <target state="translated">编码标量值</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="8febd2fa21d6fa8e1d3dfe269d8ca87dc204d2c3" translate="yes" xml:space="preserve">
          <source>Encoding Classification (by Anton Tagunov and Dan Kogai)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33835dcaa05ba53de2779ac501c0b636ae0c061" translate="yes" xml:space="preserve">
          <source>Encoding Names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e649a0b553388aa0aefbd82d8b0f0d1a27873465" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of base64 strings</source>
          <target state="translated">base64字符串的编码和解码。</target>
        </trans-unit>
        <trans-unit id="6b77915998634f10773a65ebf127633caa0903b3" translate="yes" xml:space="preserve">
          <source>Encoding and decoding of quoted-printable strings</source>
          <target state="translated">带引号的可打印字符串的编码和解码。</target>
        </trans-unit>
        <trans-unit id="a998510992fa4d69263beacea1ddcc7415077441" translate="yes" xml:space="preserve">
          <source>Encoding handling assumes that PerlIO is available and does not work properly if it isn't. The &lt;code&gt;utf8&lt;/code&gt; option is therefore not supported unless Perl is built with PerlIO support.</source>
          <target state="translated">编码处理假定PerlIO可用，如果没有，则不能正常工作。该 &lt;code&gt;utf8&lt;/code&gt; 除非Perl是用PerlIO的内置支持，因此不支持的选项。</target>
        </trans-unit>
        <trans-unit id="04cfa3e7800a4d240dc7f677c9407b294c248bcf" translate="yes" xml:space="preserve">
          <source>Encoding layer</source>
          <target state="translated">编码层</target>
        </trans-unit>
        <trans-unit id="b9782d5b4b9e78ce07208ac3d1921ad180cd2fcb" translate="yes" xml:space="preserve">
          <source>Encoding names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680e8d978db89c29bc9f5396c102c8ec2731a094" translate="yes" xml:space="preserve">
          <source>Encoding names are case insensitive. White space in names is ignored. In addition, an encoding may have aliases. Each encoding has one &quot;canonical&quot; name. The &quot;canonical&quot; name is chosen from the names of the encoding by picking the first in the following sequence (with a few exceptions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01cbaf646f7cdfb7eb0fbb21f815c71c722e02c1" translate="yes" xml:space="preserve">
          <source>Encoding via PerlIO</source>
          <target state="translated">通过PerlIO进行编码</target>
        </trans-unit>
        <trans-unit id="46fade9210aeab4b837cd79bdf4256d2a5f65faf" translate="yes" xml:space="preserve">
          <source>Encoding vs. Charset -- terminology</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e06c1fc55b2907153074d333e66853227f2028" translate="yes" xml:space="preserve">
          <source>Encodings are categorized and implemented in several different modules but you don't have to &lt;code&gt;use Encode::XX&lt;/code&gt; to make them available for most cases. Encode.pm will automatically load those modules on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc5b05d5a707cb27dff01159bcf1a3ca6a46e7c" translate="yes" xml:space="preserve">
          <source>Encodings supported by Encode</source>
          <target state="translated">Encode支持的编码</target>
        </trans-unit>
        <trans-unit id="f136f667340e5f4c44804d0073e50a60db219512" translate="yes" xml:space="preserve">
          <source>Encrypted communication channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4ae224ac38c50705eb255694dceb50337fe4c9" translate="yes" xml:space="preserve">
          <source>End of File. Sometimes used metaphorically as the terminating string of a &lt;b&gt;here document&lt;/b&gt;.</source>
          <target state="translated">文件结束。有时隐喻用作&lt;b&gt;here文档&lt;/b&gt;的终止字符串。</target>
        </trans-unit>
        <trans-unit id="e61fae84390da1a34c4b2fbd657622d5073292c7" translate="yes" xml:space="preserve">
          <source>End of file.</source>
          <target state="translated">文件结束。</target>
        </trans-unit>
        <trans-unit id="d1e4562e3c175d8468bb1a01a7952bd0d3b259e1" translate="yes" xml:space="preserve">
          <source>End the sending of data to the remote server. This is done by ensuring that the data already sent ends with CRLF then sending '.CRLF' to end the transmission. Once this data has been sent &lt;code&gt;dataend&lt;/code&gt; calls &lt;code&gt;response&lt;/code&gt; and returns true if &lt;code&gt;response&lt;/code&gt; returns CMD_OK.</source>
          <target state="translated">结束向远程服务器的数据发送。通过确保已发送的数据以CRLF结尾，然后发送&amp;ldquo; .CRLF&amp;rdquo;以结束传输来完成此操作。发送 &lt;code&gt;dataend&lt;/code&gt; 此数据后，数据端将调用 &lt;code&gt;response&lt;/code&gt; ，如果 &lt;code&gt;response&lt;/code&gt; 返回CMD_OK ，则返回true 。</target>
        </trans-unit>
        <trans-unit id="5b395d065aa5966c6da16e4b8c501ca68c3ecd37" translate="yes" xml:space="preserve">
          <source>End-tokens from Pod::Simple::PullParser</source>
          <target state="translated">来自Pod::Simple::PullParser的终端标记。</target>
        </trans-unit>
        <trans-unit id="8676dbbd19637e0c1604c4bcd69f9208a03cfa1a" translate="yes" xml:space="preserve">
          <source>End.U</source>
          <target state="translated">End.U</target>
        </trans-unit>
        <trans-unit id="d1787011d64eb206cd1d2b206a7e53314fc2df0d" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d04612cae76dda50e81f179859b4b712ba14ff" translate="yes" xml:space="preserve">
          <source>Ends a try block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">结束try块。请参阅&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlguts中的异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5ea2083617805ed93273c46ed0c4792fa3da7a0b" translate="yes" xml:space="preserve">
          <source>Enforce type integrity if required</source>
          <target state="translated">如果需要,强制执行类型完整性</target>
        </trans-unit>
        <trans-unit id="286ca1647ce3f25ee107c4a9d50837ecd6b2a964" translate="yes" xml:space="preserve">
          <source>Enforcing redispatch</source>
          <target state="translated">执行重新调度</target>
        </trans-unit>
        <trans-unit id="a1681854c9f0debb40072c691fd6f403e3a9401c" translate="yes" xml:space="preserve">
          <source>Enginsite</source>
          <target state="translated">Enginsite</target>
        </trans-unit>
        <trans-unit id="649df08a448ee3fa90f3746baaf6b0907df42c91" translate="yes" xml:space="preserve">
          <source>English</source>
          <target state="translated">English</target>
        </trans-unit>
        <trans-unit id="256aa1d5dab6cf2100434b619aada1a930ae7c7d" translate="yes" xml:space="preserve">
          <source>English ('en') is</source>
          <target state="translated">英语('en')是</target>
        </trans-unit>
        <trans-unit id="7aa949020d6b22aac250e3885290aa830dd72a15" translate="yes" xml:space="preserve">
          <source>English - use nice English (or awk) names for ugly punctuation variables</source>
          <target state="translated">英语--对丑陋的标点符号变量使用好听的英语(或awk)名称。</target>
        </trans-unit>
        <trans-unit id="34afa6db1cf569bd02a3ffe4f7e6036f1798a631" translate="yes" xml:space="preserve">
          <source>English.pm</source>
          <target state="translated">English.pm</target>
        </trans-unit>
        <trans-unit id="99343727bceed607c32f483621540aee48471580" translate="yes" xml:space="preserve">
          <source>Enough of the definition talk! Let's have a few examples.</source>
          <target state="translated">定义说得够多了! 让我们举几个例子。</target>
        </trans-unit>
        <trans-unit id="d899ea5401439c93a0c8f86febf8bb8f4f088e5d" translate="yes" xml:space="preserve">
          <source>Ensure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8988a13726c59d935ea79d755d1455be0fc83772" translate="yes" xml:space="preserve">
          <source>Ensure that you know what \b really does: it's the boundary between a word character, \w, and something that isn't a word character. That thing that isn't a word character might be \W, but it can also be the start or end of the string.</source>
          <target state="translated">确保你知道 &quot;b &quot;的真正作用:它是一个单词字符,即&quot;/w &quot;和一些不是单词字符的东西之间的界限。那个不是单词字符的东西可能是 \W,但它也可以是字符串的开始或结束。</target>
        </trans-unit>
        <trans-unit id="8680a11001e2d2163c0b3f5d95efb035f3fa7b03" translate="yes" xml:space="preserve">
          <source>Ensure you're following the latest advice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21287dbbbfc03a6ee27ae105b87e32fa291261eb" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="translated">确保您的模块在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;-w&lt;/code&gt; 下&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee84d37b57aec0c02ba775d818a3471f6da99fba" translate="yes" xml:space="preserve">
          <source>Ensure your module works under &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;-w&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3137a5d79c4479978038346bf282e1d45e0aa011" translate="yes" xml:space="preserve">
          <source>Ensures that &lt;code&gt;MoveFileEx&lt;/code&gt; won't return until the operation has finished and been flushed to disk. This is not supported under Windows 95. Only affects file renames to another file system, forcing a buffer flush at the end of the copy operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f974b332a5fa28c86d4229cace8185f73744894" translate="yes" xml:space="preserve">
          <source>Ensures that sv is a SVt_PV and that its SvCUR is 0, and that it is properly null terminated. Equivalent to sv_setpvs(&quot;&quot;), but more efficient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1279af9b58018ff33488efc0656bb62fda8db44f" translate="yes" xml:space="preserve">
          <source>Enter interactive mode by running</source>
          <target state="translated">进入互动模式,运行</target>
        </trans-unit>
        <trans-unit id="74eb99da3b9ba3df5f4be61ae4522068a9b27d10" translate="yes" xml:space="preserve">
          <source>Entire arrays (and slices of arrays and hashes) are denoted by '@', which works much as the word &quot;these&quot; or &quot;those&quot; does in English, in that it indicates multiple values are expected.</source>
          <target state="translated">整个数组(以及数组和散列的切片)用'@'表示,它的作用就像英语中的 &quot;these &quot;或 &quot;those &quot;一样,因为它表示预期有多个值。</target>
        </trans-unit>
        <trans-unit id="d245bbc8252b0b71ede0a2f949fc5b29d829fd5d" translate="yes" xml:space="preserve">
          <source>Entire hashes are denoted by '%':</source>
          <target state="translated">整个哈希值用'%'表示。</target>
        </trans-unit>
        <trans-unit id="4f918189cf78ab84f6519ba2dcb57f2ae316f72b" translate="yes" xml:space="preserve">
          <source>Entries cannot be plain object files, as many Win32 compilers will not handle object files in the place of libraries.</source>
          <target state="translated">条目不能是普通的对象文件,因为很多Win32编译器不会处理对象文件来代替库。</target>
        </trans-unit>
        <trans-unit id="673fba8e1fb3916663891e031f77ca1343408944" translate="yes" xml:space="preserve">
          <source>Entries in &lt;code&gt;$potential_libs&lt;/code&gt; beginning with a colon and followed by alphanumeric characters are treated as flags. Unknown flags will be ignored.</source>
          <target state="translated">&lt;code&gt;$potential_libs&lt;/code&gt; 条目以冒号开头，后跟字母数字字符被视为标志。未知标志将被忽略。</target>
        </trans-unit>
        <trans-unit id="a95d99085680ef5c64c2fe5754604ba2f596d896" translate="yes" xml:space="preserve">
          <source>Entries such as:</source>
          <target state="translated">诸如:</target>
        </trans-unit>
        <trans-unit id="8d07f7a288d3779719c1509961105704b61f4cef" translate="yes" xml:space="preserve">
          <source>Entry in the INPUT section of a typemap</source>
          <target state="translated">类型图INPUT部分的条目</target>
        </trans-unit>
        <trans-unit id="237fc607826e845da2eb03390fed5a45c866b715" translate="yes" xml:space="preserve">
          <source>Entry in the OUTPUT section of a typemap</source>
          <target state="translated">类型图的OUTPUT部分的条目。</target>
        </trans-unit>
        <trans-unit id="81a846de6d38920893fe50bf678fb10abc3847e2" translate="yes" xml:space="preserve">
          <source>Entry in the TYPEMAP section of a typemap</source>
          <target state="translated">在类型图的TYPEMAP部分的条目</target>
        </trans-unit>
        <trans-unit id="f211ac2a755354cfc7e79a205b52eb23e2f010b1" translate="yes" xml:space="preserve">
          <source>Entware-ng comes with a precompiled 5.24.1 (June 2017) that allowes building shared XS code. Note that this installation does &lt;b&gt;not&lt;/b&gt; use a site_perl folder. The available &lt;code&gt;cpan&lt;/code&gt; works. If all required development packages are installed too, also for XS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2562690818adae41c773c584b6f6c09ebb4d39c" translate="yes" xml:space="preserve">
          <source>Env</source>
          <target state="translated">Env</target>
        </trans-unit>
        <trans-unit id="fbbe5fa808eea7f4c74b5ba16db47dab460bc3b9" translate="yes" xml:space="preserve">
          <source>Env - perl module that imports environment variables as scalars or arrays</source>
          <target state="translated">Env-perl模块将环境变量作为标量或数组导入。</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="e19f8816c6f7ccbb7d40a44b81def1ffb731d4e0" translate="yes" xml:space="preserve">
          <source>Environment for Compiling perl on Solaris</source>
          <target state="translated">在Solaris上编译perl的环境</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e160747cc9ac3da385ca9f9c1cb6f2e6810dff" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , and &lt;code&gt;=back&lt;/code&gt; . For example:</source>
          <target state="translated">程序关心的环境变量，通常使用 &lt;code&gt;=over&lt;/code&gt; ， &lt;code&gt;=item&lt;/code&gt; 和 &lt;code&gt;=back&lt;/code&gt; 表示为列表。例如：</target>
        </trans-unit>
        <trans-unit id="047031c84702987a532453c9aba009b3c909ceb6" translate="yes" xml:space="preserve">
          <source>Environment variables that the program cares about, normally presented as a list using &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, and &lt;code&gt;=back&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59ed6121898e672a267f0f15674f039aebf49694" translate="yes" xml:space="preserve">
          <source>Environment variables to be set during the command</source>
          <target state="translated">命令中要设置的环境变量</target>
        </trans-unit>
        <trans-unit id="ec3aedc215415465ba248c2b745d070af96045ef" translate="yes" xml:space="preserve">
          <source>Eof</source>
          <target state="translated">Eof</target>
        </trans-unit>
        <trans-unit id="7264243f4aeaaab7fbb98bd7afd5e953b5900f7b" translate="yes" xml:space="preserve">
          <source>Equality Operators</source>
          <target state="translated">平等操作者</target>
        </trans-unit>
        <trans-unit id="f6a4eb155ac0505cd34f3102780f106892d4662a" translate="yes" xml:space="preserve">
          <source>Equivalence between Decimal and Dotted-Decimal Versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cfd756767e68de5473421aba90c9077344def28" translate="yes" xml:space="preserve">
          <source>Equivalent examples:</source>
          <target state="translated">同等的例子。</target>
        </trans-unit>
        <trans-unit id="c61e2265d123d76133484971263eb3576ac59dd9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; . The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) UTF-8 representation, this function cannot fail.</source>
          <target state="translated">等效于 &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt; 。$ string中的字符以Perl的内部格式编码，结果以八位字节序列返回。由于Perl中所有可能的字符都具有（松散，不严格）的UTF-8表示形式，因此该功能不会失败。</target>
        </trans-unit>
        <trans-unit id="2e78d6f894c7d9e2878d9273592738107eb000e0" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$octets = encode(&quot;utf8&quot;, $string)&lt;/code&gt;. The characters in $string are encoded in Perl's internal format, and the result is returned as a sequence of octets. Because all possible characters in Perl have a (loose, not strict) utf8 representation, this function cannot fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a263a53c5879a617814d231b90b810689cbeec78" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; . The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Because not all sequences of octets are valid UTF-8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;Handling Malformed Data&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt; 。由$ octets表示的八位字节序列从UTF-8解码为逻辑字符序列。由于并非所有八位位组序列都是有效的UTF-8，因此此功能很可能会失败。有关检查，请参阅&lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;处理格式错误的数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98fe51deeaa55823d52414f5281c460f4be56e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&lt;/code&gt;. The sequence of octets represented by $octets is decoded from (loose, not strict) utf8 into a sequence of logical characters. Because not all sequences of octets are valid not strict utf8, it is quite possible for this function to fail. For CHECK, see &lt;a href=&quot;#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032e60eb7c99d19d4d7f40467e50e02c1b3b3e31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; , but more precise for small argument values [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;(x) - 1&lt;/code&gt; ，但对于较小的参数值[C99]更精确。</target>
        </trans-unit>
        <trans-unit id="48506d548803ae745c6c6681b3b6b358f76d6d1f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; , but more stable results for small argument values [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/log&quot;&gt;log&lt;/a&gt;(1 + x)&lt;/code&gt; ，但对于较小的参数值，结果更稳定[C99]。</target>
        </trans-unit>
        <trans-unit id="22c30bad53a9801aa2549ef28438b22b8be2db3e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; ，不同之处在于未附加 &lt;code&gt;$\&lt;/code&gt; （输出记录分隔符）。实际上，FORMAT和LIST被解析为一个列表。列表的第一个参数将被解释为 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 格式。这意味着 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 将使用 &lt;code&gt;$_[0]&lt;/code&gt; 作为格式。有关format参数的说明，请参见&lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt;。如果对 &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 查找此贯穿容器有效，并且已调用POSIX :: setlocale（），则格式化的浮点数中用于十进制分隔符的字符会受到 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境设置。参见&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="200de086c8cd5535e67b47001e5f819da8109f8f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;functions/sqrt&quot;&gt;sqrt&lt;/a&gt;(x * x + y * y)&lt;/code&gt; 除了在非常大或非常小的参数上更稳定[C99]。</target>
        </trans-unit>
        <trans-unit id="0f1d23c2683b2580eee5762a2646e2cfdbd51243" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; , except that &lt;code&gt;$\&lt;/code&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; format. This means that &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; for &lt;code&gt;LC_NUMERIC&lt;/code&gt; Look for this throught pod is in effect and POSIX::setlocale() has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt; FILEHANDLE &lt;a href=&quot;sprintf&quot;&gt;sprintf&lt;/a&gt;(FORMAT, LIST)&lt;/code&gt; ，不同之处在于未附加 &lt;code&gt;$\&lt;/code&gt; （输出记录分隔符）。实际上，FORMAT和LIST被解析为一个列表。列表的第一个参数将被解释为 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 格式。这意味着 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf(@_)&lt;/a&gt;&lt;/code&gt; 将使用 &lt;code&gt;$_[0]&lt;/code&gt; 作为格式。有关format参数的说明，请参见&lt;a href=&quot;#sprintf-FORMAT%2c-LIST&quot;&gt;sprintf&lt;/a&gt;。如果对 &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 查找此贯穿容器有效，并且已调用POSIX :: setlocale（），则格式化的浮点数中用于十进制分隔符的字符会受到 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 语言环境设置。参见&lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;和&lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="756e8875e122c06649638568056dc5b432d11a8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;exp(x) - 1&lt;/code&gt;, but more precise for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c725f59de42f50ead6905d172ab4b7ba28d808a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;log(1 + x)&lt;/code&gt;, but more stable results for small argument values [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3145a78dd9afcf2f738531a37fc2117722087949" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;print FILEHANDLE sprintf(FORMAT, LIST)&lt;/code&gt;, except that &lt;a href=&quot;perlvar#%24%5C&quot;&gt;&lt;code&gt;$\&lt;/code&gt;&lt;/a&gt; (the output record separator) is not appended. The FORMAT and the LIST are actually parsed as a single list. The first argument of the list will be interpreted as the &lt;a href=&quot;#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; format. This means that &lt;code&gt;printf(@_)&lt;/code&gt; will use &lt;code&gt;$_[0]&lt;/code&gt; as the format. See &lt;a href=&quot;#sprintf-FORMAT%2C-LIST&quot;&gt;sprintf&lt;/a&gt; for an explanation of the format argument. If &lt;code&gt;use locale&lt;/code&gt; (including &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect and &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; has been called, the character used for the decimal separator in formatted floating-point numbers is affected by the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale setting. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b67359eada935d408cfee6f1b32b93eb73c3ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x * x + y * y)&lt;/code&gt; except more stable on very large or very small arguments [C99].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b647b2f27ee1659c31db9d984b63f0b9e63a18" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sv_setsv(sv, &amp;amp;PL_sv_undef)&lt;/code&gt;, but more efficient. Doesn't handle set magic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4e0dc744110e721ecf88197993cbcc2b45d001" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; .</source>
          <target state="translated">相当于Perl代码 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; $gv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ac49f4bdd12fc964afb5f8290211f9aa65a79c7" translate="yes" xml:space="preserve">
          <source>Equivalent to Perl code &lt;code&gt;local $gv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="876fc7d247587a71d98917cb3c3453fd65fea359" translate="yes" xml:space="preserve">
          <source>Equivalent to running mktemp() with $dir/$prefixXXXXXXXX (using unix file convention as an example)</source>
          <target state="translated">相当于用$dir/$prefixXXXXXX运行mktemp()(以unix文件惯例为例)</target>
        </trans-unit>
        <trans-unit id="4dba35bcd4ac839e52783da10b5058566f3e3b91" translate="yes" xml:space="preserve">
          <source>Equivalent to specifying a DIR of &quot;File::Spec-&amp;gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.</source>
          <target state="translated">等效于将DIR指定为&amp;ldquo; File :: Spec-&amp;gt; tmpdir&amp;rdquo;，将文件写入与如果完全未指定模板时将使用的相同的临时目录中。</target>
        </trans-unit>
        <trans-unit id="bb3d71a18fde90428e21cf7d4198ea242cfa57c5" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;a href=&quot;#-C-%5Bnumber%2Flist%5D&quot;&gt;-C&lt;/a&gt; switch for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a667e4f94596d8444896d0c578ec8dad154ae9ae" translate="yes" xml:space="preserve">
          <source>Equivalent to the &lt;b&gt;-C&lt;/b&gt; command-line switch. Note that this is not a boolean variable. Setting this to &lt;code&gt;&quot;1&quot;&lt;/code&gt; is not the right way to &quot;enable Unicode&quot; (whatever that would mean). You can use &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &quot;disable Unicode&quot;, though (or alternatively unset PERL_UNICODE in your shell before starting Perl). See the description of the &lt;b&gt;-C&lt;/b&gt; switch for more information.</source>
          <target state="translated">等效于&lt;b&gt;-C&lt;/b&gt;命令行开关。请注意，这不是布尔变量。将此设置为 &lt;code&gt;&quot;1&quot;&lt;/code&gt; 不是&amp;ldquo;启用Unicode&amp;rdquo;的正确方法（无论这意味着什么）。不过，您可以使用 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 来&amp;ldquo;禁用Unicode&amp;rdquo;（或者在启动Perl之前在您的shell中取消设置PERL_UNICODE）。有关更多信息，请参见&lt;b&gt;-C&lt;/b&gt;开关的描述。</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="7cc25c4fa96172ec73030c6c0f3dc9c51687c491" translate="yes" xml:space="preserve">
          <source>Equivalents of</source>
          <target state="translated">等价物</target>
        </trans-unit>
        <trans-unit id="7ebcf33d0a14ddb91ad477ae52a7af6de25e76c9" translate="yes" xml:space="preserve">
          <source>Er, that's it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0256add701298dc7a17e42cc9eb936d630438581" translate="yes" xml:space="preserve">
          <source>Erases one character. Defined by</source>
          <target state="translated">删除一个字符。定义为</target>
        </trans-unit>
        <trans-unit id="7c24401b7c6f89af67334e697241400ad5298e5f" translate="yes" xml:space="preserve">
          <source>Erases the current input. Defined by</source>
          <target state="translated">擦除当前的输入。定义为</target>
        </trans-unit>
        <trans-unit id="2bfde103fe0a2fc7c857d2e77fed8dacf0bc3d48" translate="yes" xml:space="preserve">
          <source>Eric L. Brine,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b196c5d2b8bc0f57dd78e558fed28f0a83be47" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm &amp;lt;ewilhelm@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3053d2e8a81cd1d9716eddc9ced731b4c51383d" translate="yes" xml:space="preserve">
          <source>Eric Wilhelm @ &amp;lt;ewilhelm at cpan dot org&amp;gt;</source>
          <target state="translated">埃里克&amp;middot;威廉（Eric Wilhelm）@ &amp;lt;cpan dot org的ewilhelm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d8bf3fea74cb51ac9ebccafa9b5bfc9e28b1c902" translate="yes" xml:space="preserve">
          <source>Errno</source>
          <target state="translated">Errno</target>
        </trans-unit>
        <trans-unit id="76cf9c662cbb85bc782a4c519361391afd6f8281" translate="yes" xml:space="preserve">
          <source>Errno - System errno constants</source>
          <target state="translated">Errno-系统Errno常数。</target>
        </trans-unit>
        <trans-unit id="27356fe30834096ffaeafbce7b977e0f80915dea" translate="yes" xml:space="preserve">
          <source>Erroneous numbering of =item numbers; they need to ascend consecutively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f2f6a15cf8da2b27e5a4af47b58e7ad71c0b3d9" translate="yes" xml:space="preserve">
          <source>Error</source>
          <target state="translated">Error</target>
        </trans-unit>
        <trans-unit id="6cc16f28f695995f841e32ad9be43613256395fe" translate="yes" xml:space="preserve">
          <source>Error Checking</source>
          <target state="translated">错误检查</target>
        </trans-unit>
        <trans-unit id="ecbd14ea4e6e17d8a2dc17467fb021874d4a82c9" translate="yes" xml:space="preserve">
          <source>Error Variables</source>
          <target state="translated">错误变量</target>
        </trans-unit>
        <trans-unit id="cfb1de7f5665b658bcddfda7619c881aef88520a" translate="yes" xml:space="preserve">
          <source>Error checking is, as usual, left as an exercise for the reader.</source>
          <target state="translated">错误检查一如既往地留给读者去做。</target>
        </trans-unit>
        <trans-unit id="da4e40dd69c1ef29292868ee52af685e14566b19" translate="yes" xml:space="preserve">
          <source>Error checking, as always, has been left as an exercise for the reader.</source>
          <target state="translated">错误检查,一如既往地留给读者去做。</target>
        </trans-unit>
        <trans-unit id="deb19663fe1130ad1a6752c882ecbce1fa91037d" translate="yes" xml:space="preserve">
          <source>Error converting file specification %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e1fae3d7127b124ae1e94579e5dd51376530e7b" translate="yes" xml:space="preserve">
          <source>Error handling and messages</source>
          <target state="translated">错误处理和信息</target>
        </trans-unit>
        <trans-unit id="34660817ebc668307d6b9b58b072f03bc4a8634d" translate="yes" xml:space="preserve">
          <source>Error handling is still a work in progress. If the program encounters a problem reading a zip file it is likely to terminate with an unhelpful error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb7b0a0be7d85a55ee74f50c125415c68cb8808" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;$!&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">当前操作系统特定的错误信息。目前，这与 &lt;code&gt;$!&lt;/code&gt; 有所不同！仅在VMS，OS / 2和Win32（以及MacPerl）下。在所有其他平台上， &lt;code&gt;$^E&lt;/code&gt; 始终与 &lt;code&gt;$!&lt;/code&gt; 相同！。</target>
        </trans-unit>
        <trans-unit id="f630bce8e4480d279f4c43b7f93e39940eec25e0" translate="yes" xml:space="preserve">
          <source>Error information specific to the current operating system. At the moment, this differs from &lt;code&gt;&lt;a href=&quot;#%24%21&quot;&gt;&quot;$!&quot;&lt;/a&gt;&lt;/code&gt; under only VMS, OS/2, and Win32 (and for MacPerl). On all other platforms, &lt;code&gt;$^E&lt;/code&gt; is always just the same as &lt;code&gt;$!&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915cf7d6fb5fed9ebc1249138f0ba313553fae0a" translate="yes" xml:space="preserve">
          <source>Error message &quot;No error definitions found&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36186555ca5a85354d834f18239bd5446de015bb" translate="yes" xml:space="preserve">
          <source>Error message text from the last failed DynaLoader function. Note that, similar to errno in unix, a successful function call does not reset this message.</source>
          <target state="translated">上次DynaLoader函数失败的错误信息。请注意,与unix中的errno类似,成功的函数调用不会重置此信息。</target>
        </trans-unit>
        <trans-unit id="50134ffbfcda43f0c3168aa2876061d57b69c6ae" translate="yes" xml:space="preserve">
          <source>Error results (warning and fatal) contain:</source>
          <target state="translated">错误结果(警告和致命)包含:</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="e722317f0272c736783202d0439c1a84302bd3c9" translate="yes" xml:space="preserve">
          <source>Errors in rendering (non-existent function-name, non-existent coderef) are written to the STDOUT, or wherever you've set it via walk_output().</source>
          <target state="translated">渲染中的错误(不存在的函数名,不存在的coderef)会被写入STDOUT,或者你通过walk_output()设置的任何地方。</target>
        </trans-unit>
        <trans-unit id="da8460251cea0573bc6a64a9a743976f334f7752" translate="yes" xml:space="preserve">
          <source>Errors set by Winsock functions are now put directly into &lt;code&gt;$^E&lt;/code&gt;, and the relevant &lt;code&gt;WSAE*&lt;/code&gt; error codes are now exported from the &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; and &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; modules for testing this against.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0934c88916cf6f7537fb99e4833669f3818f9855" translate="yes" xml:space="preserve">
          <source>Errors using the various *style* calls, and bad args to walk_output(), result in die(). Use an eval if you wish to catch these errors and continue processing.</source>
          <target state="translated">使用各种*style*调用的错误,以及walk_output()的错误参数,都会导致die()。如果你想抓住这些错误并继续处理,请使用eval。</target>
        </trans-unit>
        <trans-unit id="2a3a3e693d223668963c1734745a9c3d61b5507c" translate="yes" xml:space="preserve">
          <source>Eryq (</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b714d8f396c877eacf7d3ad661cfe313a3efe9" translate="yes" xml:space="preserve">
          <source>Escape backslashes (&lt;code&gt;\&lt;/code&gt;) in prototype strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="a95db9b35f0577a2b6c8dd20cb8afa6149f7b7b9" translate="yes" xml:space="preserve">
          <source>Escapes a given code source name (typically a file name but can also be a command that was read from) so that double-quotes and backslashes are escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa6da9272c9b7871ca718b60455b77d2d266044" translate="yes" xml:space="preserve">
          <source>Escapes all &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">转义所有 &lt;code&gt;$&lt;/code&gt; ,以免将它们解释为make变量。</target>
        </trans-unit>
        <trans-unit id="d630054693cd8886f832682006b6bb07e97c811d" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &quot;count&quot; chars of pv and puts the results into dsv such that the size of the escaped string will not exceed &quot;max&quot; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the STRLEN *escaped parameter if it is not null. When the dsv parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="translated">最多转义pv的第一个 &quot;count &quot;chars,并将结果放入dsv中,这样转义字符串的大小不会超过 &quot;max &quot;chars,并且不会包含任何不完整的转义序列。如果参数STRLEN *escaped不是空的,那么被转义的字节数将被返回。当dsv参数为空时,实际上不会发生转义,但会计算出如果它不是空的情况下会被转义的字节数。</target>
        </trans-unit>
        <trans-unit id="e9331784f47985d4023ae09824ecf12ebdf39d50" translate="yes" xml:space="preserve">
          <source>Escapes at most the first &lt;code&gt;count&lt;/code&gt; chars of &lt;code&gt;pv&lt;/code&gt; and puts the results into &lt;code&gt;dsv&lt;/code&gt; such that the size of the escaped string will not exceed &lt;code&gt;max&lt;/code&gt; chars and will not contain any incomplete escape sequences. The number of bytes escaped will be returned in the &lt;code&gt;STRLEN *escaped&lt;/code&gt; parameter if it is not null. When the &lt;code&gt;dsv&lt;/code&gt; parameter is null no escaping actually occurs, but the number of bytes that would be escaped were it not null will be calculated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b73daf05e61c2f4ceabfe0f8dc9e8bd0fe087922" translate="yes" xml:space="preserve">
          <source>Escapes stray &lt;code&gt;$&lt;/code&gt; so they are not interpreted as make variables.</source>
          <target state="translated">转义符是 &lt;code&gt;$&lt;/code&gt; ,因此不会被解释为make变量。</target>
        </trans-unit>
        <trans-unit id="92b417d4a5ce0ac686aeee5640af004624297a4e" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;.</source>
          <target state="translated">特别是&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="51e6f8fb1216de07279b7184fe32486c4afcbbd5" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; .</source>
          <target state="translated">尤其&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;如 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcd99d9147aed607626e5d2c3fbf27fa8eaba872" translate="yes" xml:space="preserve">
          <source>Especially &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; as in &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; and &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt; as in &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; .</source>
          <target state="translated">尤其&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;如 &lt;code&gt;perl -Mbigrat -le 'print 1/3+1/4'&lt;/code&gt; 和&lt;a href=&quot;bignum&quot;&gt;BIGNUM&lt;/a&gt;如 &lt;code&gt;perl -Mbignum -le 'print sqrt(2)'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5485ef59e2abd6d9fec5641c427b8c1a89ee861e" translate="yes" xml:space="preserve">
          <source>Essentially this is the same as the &lt;code&gt;__LINE__&lt;/code&gt; macro, but the &lt;code&gt;line_num(+3)&lt;/code&gt; idiom is arguably nicer.</source>
          <target state="translated">从本质上讲，这与 &lt;code&gt;__LINE__&lt;/code&gt; 宏相同，但是 &lt;code&gt;line_num(+3)&lt;/code&gt; 惯用法可以说更好。</target>
        </trans-unit>
        <trans-unit id="0c6dff48b0f039b109420e87e1e42abbab8710f8" translate="yes" xml:space="preserve">
          <source>Establish an ISA relationship with base classes at compile time</source>
          <target state="translated">在编译时与基类建立ISA关系。</target>
        </trans-unit>
        <trans-unit id="576347ec826f38428d8c8a6f8ec4acb2bceab911" translate="yes" xml:space="preserve">
          <source>Europe</source>
          <target state="translated">Europe</target>
        </trans-unit>
        <trans-unit id="aa9b05a82a74755dccc358002821ca69d31c5e54" translate="yes" xml:space="preserve">
          <source>European Computer Manufacturers Association &lt;a href=&quot;http://www.ecma.ch&quot;&gt;http://www.ecma.ch&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0309a3b568036fa350070f80c5e87dff1124fc90" translate="yes" xml:space="preserve">
          <source>Eval the codeblock, return success or failure, and the error message. This code protects $@ and $!, they will be restored by the end of the run. This code also temporarily blocks $SIG{DIE} handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57720a74163f29f2034ea0831d9223b2072fcf53" translate="yes" xml:space="preserve">
          <source>Eval-group in insecure regular expression</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de6a23b74739863fdcb66dba07f712f221ab630" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed at runtime, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fc4317afc6d18f75173c8034624de946965f7e" translate="yes" xml:space="preserve">
          <source>Eval-group not allowed, use re 'eval' in regex m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15622021802352824cd00f0a03614ec0fdf9d50b" translate="yes" xml:space="preserve">
          <source>Evaluates EXPR and exits immediately with that value. Example:</source>
          <target state="translated">评估EXPR,并以该值立即退出。例子:</target>
        </trans-unit>
        <trans-unit id="c44b93a0add3946a941d2db7675bb524bcd7719a" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="translated">在列表上下文中评估其表达式，并以漂亮的打印方式转储结果。嵌套数据结构以递归方式打印出来，这与Perl中的实际 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能不同。在转储散列时，您可能更喜欢'x \％h'而不是'x％h'。如果您想自己执行此操作，请参见&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5bd312d1ed9e2d998f61c992d1949d05f3189c8" translate="yes" xml:space="preserve">
          <source>Evaluates its expression in list context and dumps out the result in a pretty-printed fashion. Nested data structures are printed out recursively, unlike the real &lt;code&gt;print&lt;/code&gt; function in Perl. When dumping hashes, you'll probably prefer 'x \%h' rather than 'x %h'. See &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; if you'd like to do this yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac54d42c3ebf7c1eb1985e5c37def23568be458" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and composes a list of the results of each such evaluation. Each element of LIST may produce zero, one, or more elements in the generated list, so the number of elements in the generated list may differ from that in LIST. In scalar context, returns the total number of elements so generated. In list context, returns the generated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6b463c629f711f381a6e44374ee5717c9b5851" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eee27e1be9e7d28580a29bfa24323cac2b1efa9" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value composed of the results of each such evaluation. In scalar context, returns the total number of elements so generated. Evaluates BLOCK or EXPR in list context, so each element of LIST may produce zero, one, or more elements in the returned value.</source>
          <target state="translated">评估LIST的每个元素的BLOCK或EXPR（将 &lt;code&gt;$_&lt;/code&gt; 本地设置为每个元素），并返回由每个评估结果组成的列表值。在标量上下文中，返回如此生成的元素总数。在列表上下文中评估BLOCK或EXPR，因此LIST的每个元素可能在返回值中产生零个，一个或多个元素。</target>
        </trans-unit>
        <trans-unit id="e159565a978e2dbd25deef6d431807eb47abbd14" translate="yes" xml:space="preserve">
          <source>Evaluates the BLOCK or EXPR for each element of LIST (locally setting &lt;code&gt;$_&lt;/code&gt; to each element) and returns the list value consisting of those elements for which the expression evaluated to true. In scalar context, returns the number of times the expression was true.</source>
          <target state="translated">计算LIST的每个元素的BLOCK或EXPR（将 &lt;code&gt;$_&lt;/code&gt; 局部设置为每个元素），并返回由表达式评估为true的那些元素组成的列表值。在标量上下文中，返回表达式为真的次数。</target>
        </trans-unit>
        <trans-unit id="cf5a5afbdf639c60540cb29b1afb8482a4c27513" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb27bcd152d36bb6aa40c050f7aa6bc064a148c" translate="yes" xml:space="preserve">
          <source>Evaluates the hash in scalar context and returns the result. Handles magic when the hash is tied.</source>
          <target state="translated">在标量上下文中评估哈希值并返回结果。当哈希值被绑定时,处理魔术。</target>
        </trans-unit>
        <trans-unit id="4e9ac4c1ee356b0a19d18eecf82ac765b9101304" translate="yes" xml:space="preserve">
          <source>Evaluates the passed SV. Result handling is done the same as for &lt;code&gt;call_sv()&lt;/code&gt; etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808c33dddbb9e00ae9c3a4845059fe43368d7b0a" translate="yes" xml:space="preserve">
          <source>Evaluates to 0xFFFD, the code point of the Unicode REPLACEMENT CHARACTER</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c62a6c57ccf104ad2d41815aed270108351d20" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the byte &lt;code&gt;c&lt;/code&gt; represents the same character when encoded in UTF-8 as when not; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="100562c78d7cbca55f4722b4014576ae868df4e3" translate="yes" xml:space="preserve">
          <source>Evaluates to 1 if the representation of code point &lt;code&gt;cp&lt;/code&gt; is the same whether or not it is encoded in UTF-8; otherwise evaluates to 0. UTF-8 invariant characters can be copied as-is when converting to/from UTF-8, saving time. &lt;code&gt;cp&lt;/code&gt; is Unicode if above 255; otherwise is platform-native.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bb14ed1a5da1a7d197c5bfa2c110468f119a341" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f226763df7ae244c2d5731a8cec87c6ad68b9c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when compiling a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a4b1422deea528999a2aea4d2e3abe0a2cb0" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE if, when executing a perl program (including an &lt;code&gt;eval&lt;/code&gt;) if the plain locale pragma without a parameter (&lt;code&gt;use locale&lt;/code&gt;) is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7efdaaae8c2d5acf037415de9e55f35d46853a" translate="yes" xml:space="preserve">
          <source>Evaluates to a list of the words extracted out of</source>
          <target state="translated">评估到的单词列表从</target>
        </trans-unit>
        <trans-unit id="d65f4596e5b21853db6815029e47b4d12178eb0e" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode non-character code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ba361513dd4325cee403415d7567ac05c0deb6" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents one of the Unicode surrogate code points; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b4e5bdfedcccceafa909bcd677f735ead45367" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode code point completely acceptable for open interchange between all applications; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="394362d7a28197545d54a3464886ae1b442e8f27" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8 that represents some Unicode non-surrogate code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c5579ca82ad3ea408feb922437fb3356d093b24" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point, subject to the restrictions given by &lt;code&gt;flags&lt;/code&gt;; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70279dc7ca9469f018e588c174a215d906087c5" translate="yes" xml:space="preserve">
          <source>Evaluates to non-zero if the first few bytes of the string starting at &lt;code&gt;s&lt;/code&gt; and looking no further than &lt;code&gt;e - 1&lt;/code&gt; are well-formed UTF-8, as extended by Perl, that represents some code point; otherwise it evaluates to 0. If non-zero, the value gives how many bytes starting at &lt;code&gt;s&lt;/code&gt; comprise the code point's representation. Any bytes remaining before &lt;code&gt;e&lt;/code&gt;, but beyond the ones needed to form the first code point in &lt;code&gt;s&lt;/code&gt;, are not examined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f4958a116f001f9e79787b5473e92c45467956" translate="yes" xml:space="preserve">
          <source>Evaluating a Perl statement from your C program</source>
          <target state="translated">评估C程序中的Perl语句</target>
        </trans-unit>
        <trans-unit id="fdfaa902629988731ecf820e3310a76ecb105be5" translate="yes" xml:space="preserve">
          <source>Evaluating perl code (e.g. via &quot;eval&quot; or &quot;do 'file'&quot;) causes the code to be compiled into an internal format and then, provided there was no error in the compilation, executed. The internal format is based on many distinct</source>
          <target state="translated">评估perl代码(例如通过 &quot;eval &quot;或 &quot;do 'file'&quot;)会导致代码被编译成内部格式,然后,如果在编译中没有错误,则执行。内部格式是基于许多不同的</target>
        </trans-unit>
        <trans-unit id="e1f930d87a7c101ffac9391f41733ff5b3321f0a" translate="yes" xml:space="preserve">
          <source>Even &lt;code&gt;$x += 5&lt;/code&gt; or &lt;code&gt;$x++&lt;/code&gt; are not guaranteed to be atomic.</source>
          <target state="translated">即使 &lt;code&gt;$x += 5&lt;/code&gt; 或 &lt;code&gt;$x++&lt;/code&gt; 也不能保证是原子的。</target>
        </trans-unit>
        <trans-unit id="459a068431296abdc9a0ee020cbb72e87da92588" translate="yes" xml:space="preserve">
          <source>Even after they stabilize, some tests may fail.</source>
          <target state="translated">即使在它们稳定之后,一些测试也可能失败。</target>
        </trans-unit>
        <trans-unit id="1dd817d2a76ad639afa2f373c6b0e32abc7df4b3" translate="yes" xml:space="preserve">
          <source>Even if a certain letter is tailored, its equivalent would not always tailored as well as it. For example, even though W is tailored, fullwidth W (&lt;code&gt;U+FF37&lt;/code&gt;), W with acute (&lt;code&gt;U+1E82&lt;/code&gt;), etc. are not tailored. The result may depend on whether source strings are normalized or not, and whether decomposed or composed. Thus &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; is less preferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014c0223d524d2f9046bd74912b924b926ef1dba" translate="yes" xml:space="preserve">
          <source>Even if a module is thread-safe, it doesn't mean that the module is optimized to work well with threads. A module could possibly be rewritten to utilize the new features in threaded Perl to increase performance in a threaded environment.</source>
          <target state="translated">即使一个模块是线程安全的,也并不意味着这个模块是经过优化的,可以很好地与线程一起工作。一个模块可能会被重写,以利用线程Perl的新特性来提高线程环境下的性能。</target>
        </trans-unit>
        <trans-unit id="ea9410fd8b85c13558ab2ec195f440b39ef94e1e" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt; ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="translated">即使可以在编译时使用原型，该子例程的主体也不可用（尚未进行 &lt;code&gt;AUTOLOAD&lt;/code&gt; 编程）。perl需要在编译时检查 &lt;code&gt;()&lt;/code&gt; 原型和子例程的主体，以检测其可以用常数值安全地替换对该子例程的调用。</target>
        </trans-unit>
        <trans-unit id="732edb0c232306cf9f713f481702d02637baa9d1" translate="yes" xml:space="preserve">
          <source>Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &lt;code&gt;AUTOLOAD&lt;/code&gt;ed yet). perl needs to examine both the &lt;code&gt;()&lt;/code&gt; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e9d9a1a7409534a2957addc0cb2ac7a35e101e4" translate="yes" xml:space="preserve">
          <source>Even if no</source>
          <target state="translated">即使没有</target>
        </trans-unit>
        <trans-unit id="9a52563c6b228851d7bd722e9df68900d397ecd2" translate="yes" xml:space="preserve">
          <source>Even if there are no groupings in a regexp, it is still possible to find out what exactly matched in a string. If you use them, Perl will set &lt;code&gt;$`&lt;/code&gt; to the part of the string before the match, will set &lt;code&gt;$&amp;amp;&lt;/code&gt; to the part of the string that matched, and will set &lt;code&gt;$'&lt;/code&gt; to the part of the string after the match. An example:</source>
          <target state="translated">即使正则表达式中没有分组，也仍然可以找出字符串中完全匹配的内容。如果使用它们，Perl会将 &lt;code&gt;$`&lt;/code&gt; 设置为匹配之前的字符串部分，将 &lt;code&gt;$&amp;amp;&lt;/code&gt; 设置为匹配的字符串部分，并将 &lt;code&gt;$'&lt;/code&gt; 设置为匹配之后的字符串部分。一个例子：</target>
        </trans-unit>
        <trans-unit id="d0239289e914ec51bf43e7158f9d72ad004bea40" translate="yes" xml:space="preserve">
          <source>Even if you aren't in doubt, consider the mental welfare of the person who has to maintain the code after you, and who will probably put parentheses in the wrong place.</source>
          <target state="translated">即使你没有疑问,也要考虑在你之后要维护代码的人的精神福利,他很可能会把括号放错位置。</target>
        </trans-unit>
        <trans-unit id="2698b39349f79453a318cb744bc9cc6aed1c6f70" translate="yes" xml:space="preserve">
          <source>Even if you don't currently make use of the API interface, it is still worth reading it.</source>
          <target state="translated">即使你目前没有使用API接口,也值得一读。</target>
        </trans-unit>
        <trans-unit id="7c8671eab5d7a940c940da36a9cbcdd6d20bec94" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11193f6fb31e4425ba4f294d83acb0ef83b5308c" translate="yes" xml:space="preserve">
          <source>Even if you don't want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can't extract out the individual arrays. For more on typeglobs, see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt;.</source>
          <target state="translated">即使您不想修改数组，此机制对于在单个LIST中传递多个数组也很有用，因为通常LIST机制将合并所有数组值，因此您无法提取单个数组。有关typeglob的更多信息，请参见&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;perldata中的Typeglob和Filehandles&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="704c6dd5d66c1d05562f24b58fe540e4c1622bbc" translate="yes" xml:space="preserve">
          <source>Even in a pattern that is interpolated and compiled at run-time, literal code blocks will be compiled once, at perl compile time; the following prints &quot;ABCD&quot;:</source>
          <target state="translated">即使是在运行时进行插值和编译的模式中,字面代码块也会在perl编译时被编译一次,下面打印 &quot;ABCD&quot;。</target>
        </trans-unit>
        <trans-unit id="f9a57fec05cf4b4012f5962aa352266b10461d68" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">进程范围更改的更典型示例是 &lt;code&gt;&lt;a href=&quot;functions/chroot&quot;&gt;chroot()&lt;/a&gt;&lt;/code&gt; ：所有线程的根目录都更改了，并且没有线程可以撤消它（与 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; 相对）。</target>
        </trans-unit>
        <trans-unit id="d47488f3c7fd4b4fcceda28125544a987450d2a0" translate="yes" xml:space="preserve">
          <source>Even more drastic example of a process-scope change is &lt;code&gt;chroot()&lt;/code&gt;: the root directory of all the threads changes, and no thread can undo it (as opposed to &lt;code&gt;chdir()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fba46823e424c4e147c0d6ca9c73a6300bf0908c" translate="yes" xml:space="preserve">
          <source>Even numbered minor versions (5.14, 5.16, 5.18) are production versions, and odd numbered minor versions (5.15, 5.17, 5.19) are development versions. Unless you want to try out an experimental feature, you probably never want to install a development version of Perl.</source>
          <target state="translated">偶数的次要版本(5.14、5.16、5.18)是生产版本,奇数的次要版本(5.15、5.17、5.19)是开发版本。除非你想尝试一个实验性的功能,否则你可能永远都不想安装开发版的Perl。</target>
        </trans-unit>
        <trans-unit id="985c32669ab9bb43127ab9478cdf373b1b43c14e" translate="yes" xml:space="preserve">
          <source>Even the fallback for &lt;code&gt;decode&lt;/code&gt; must return octets, which are then decoded with the character encoding that &lt;code&gt;decode&lt;/code&gt; accepts. So for example if you wish to decode octets as UTF-8, and use ISO-8859-15 as a fallback for bytes that are not valid UTF-8, you could write</source>
          <target state="translated">即使是 &lt;code&gt;decode&lt;/code&gt; 后备，也必须返回八位字节，然后再使用 &lt;code&gt;decode&lt;/code&gt; 接受的字符编码对其进行解码。因此，例如，如果您希望将八位字节解码为UTF-8，并使用ISO-8859-15作为无效UTF-8字节的后备，则可以编写</target>
        </trans-unit>
        <trans-unit id="899cce7279e173a144c83044ba4c75852234efbb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regex, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">即使 &lt;code&gt;dog&lt;/code&gt; 是第二个正则表达式中的第一个替代项， &lt;code&gt;cat&lt;/code&gt; 也可以在字符串中更早地进行匹配。</target>
        </trans-unit>
        <trans-unit id="491ac4fd5a527c06bb95d6b29c3d2ceec9e2c0d4" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;dog&lt;/code&gt; is the first alternative in the second regexp, &lt;code&gt;cat&lt;/code&gt; is able to match earlier in the string.</source>
          <target state="translated">即使 &lt;code&gt;dog&lt;/code&gt; 是第二个正则表达式中的第一个替代项， &lt;code&gt;cat&lt;/code&gt; 也可以在字符串中更早地进行匹配。</target>
        </trans-unit>
        <trans-unit id="9e410bea532f43017a3bc057208bf28febe91829" translate="yes" xml:space="preserve">
          <source>Even though HP-UX 10.20 and 11.00 are not actively maintained by HP anymore, updates for the HP ANSI C compiler are still available from time to time, and it might be advisable to see if updates are applicable. At the moment of writing, the latests available patches for 11.00 that should be applied are PHSS_35098, PHSS_35175, PHSS_35100, PHSS_33036, and PHSS_33902). If you have a SUM account, you can use it to search for updates/patches. Enter &quot;ANSI&quot; as keyword.</source>
          <target state="translated">尽管HP-UX 10.20和11.00已经不再由HP主动维护,HP ANSI C编译器的更新仍然时常出现,建议查看是否有适用的更新。在写这篇文章的时候,最新的11.00的可用补丁是PHSS_35098、PHSS_35175、PHSS_35100、PHSS_33036和PHSS_33902)。)如果您有一个SUM帐户,您可以使用它来搜索更新/补丁。输入 &quot;ANSI &quot;作为关键字。</target>
        </trans-unit>
        <trans-unit id="66ef75af64ac05e5f42a2e25f67b5dd40dad7f74" translate="yes" xml:space="preserve">
          <source>Even though VOS allows the slash character to appear in object names, because the VOS port of Perl interprets it as a pathname delimiting character, VOS files, directories, or links whose names contain a slash character cannot be processed. Such files must be renamed before they can be processed by Perl.</source>
          <target state="translated">尽管 VOS 允许在对象名称中出现斜线字符,但由于 Perl 的 VOS port 将其解释为路径名的分隔字符,因此不能处理名称中包含斜线字符的 VOS 文件、 目录或链接。这样的文件在被Perl处理之前必须重新命名。</target>
        </trans-unit>
        <trans-unit id="cdd82719baf99cfe9734df3eaad725f4efdb196d" translate="yes" xml:space="preserve">
          <source>Even though a reference may be declared as a constant, the reference may point to data which may be changed, as this code shows.</source>
          <target state="translated">即使引用可以声明为常量,但引用可能指向可能被改变的数据,如这段代码所示。</target>
        </trans-unit>
        <trans-unit id="6c1ced7503a24a96a968e8abe517680e11868256" translate="yes" xml:space="preserve">
          <source>Even though it doesn't do much, it is still preferable to writing your own classes from scratch.</source>
          <target state="translated">虽然它的作用不大,但还是优于自己从头开始写课。</target>
        </trans-unit>
        <trans-unit id="5d86d002ba38ad23c3e6f35071476718335949c5" translate="yes" xml:space="preserve">
          <source>Even though it looks as though they're the same method calls (uid), they aren't, because a &lt;code&gt;File::stat&lt;/code&gt; object is different from a &lt;code&gt;User::pwent&lt;/code&gt; object.</source>
          <target state="translated">尽管看起来它们是相同的方法调用（uid），但实际上并非如此，因为 &lt;code&gt;File::stat&lt;/code&gt; 对象与 &lt;code&gt;User::pwent&lt;/code&gt; 对象不同。</target>
        </trans-unit>
        <trans-unit id="6dc6e1961fe501af8f7b8e43fd427c0320c933fd" translate="yes" xml:space="preserve">
          <source>Even though some of this section may not be understandable to you on first reading, we think it's important enough to highlight some of the gotchas before delving further, so here goes:</source>
          <target state="translated">尽管这部分内容有些你在初读时可能无法理解,但我们认为,在进一步深入研究之前,强调一下其中的一些要领还是很重要的,所以就这样吧。</target>
        </trans-unit>
        <trans-unit id="a15d3a1eac0736a5f4619bbd0fabeec7d4b2fc07" translate="yes" xml:space="preserve">
          <source>Even though these two matches might be thought of as complements, until v5.20 they were so only on Unicode code points.</source>
          <target state="translated">尽管这两种匹配可能被认为是互补的,但在v5.20之前,它们只是在Unicode码点上如此。</target>
        </trans-unit>
        <trans-unit id="763ed71064b10dfe0eadc8f471bf100bdbc4763d" translate="yes" xml:space="preserve">
          <source>Even though with normal text files a &quot;\n&quot; will do the trick, there is still no unified scheme for terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate</source>
          <target state="translated">尽管对于普通的文本文件来说,一个&quot;\n &quot;就能搞定,但除了在Unix、DOS/Win和Macintosh之间终止行之外,仍然没有一个统一的方案来终止行。</target>
        </trans-unit>
        <trans-unit id="4630d8c85d1750185c25d65fe850b66a19d12625" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt; :</source>
          <target state="translated">即使您从一个完全空的哈希开始，在 &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 该调用之后，您仍然创建了检查 &lt;code&gt;key3&lt;/code&gt; 所需的结构：</target>
        </trans-unit>
        <trans-unit id="65c079978ec4f4cfbd582b4959b8aaf4fe2b2dbe" translate="yes" xml:space="preserve">
          <source>Even though you started with a completely empty hash, after that call to &lt;code&gt;exists&lt;/code&gt; you've created the structure you needed to check for &lt;code&gt;key3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c088010f5560d49366ca00a6983df9e83535cb" translate="yes" xml:space="preserve">
          <source>Even when on a single platform (if you can call Unix a single platform), remember not to count on the existence or the contents of particular system-specific files or directories, like</source>
          <target state="translated">即使是在单一平台上(如果你可以把Unix称为单一平台的话),记住不要指望特定系统特定文件或目录的存在或内容,比如说</target>
        </trans-unit>
        <trans-unit id="1602f4d9817a3dceaa33d17e6c176137283825a5" translate="yes" xml:space="preserve">
          <source>Even with all this work, regexp matching happens remarkably fast. To speed things up, Perl compiles the regexp into a compact sequence of opcodes that can often fit inside a processor cache. When the code is executed, these opcodes can then run at full throttle and search very quickly.</source>
          <target state="translated">即使做了这些工作,regexp 匹配的速度还是非常快。为了加快速度,Perl 将 regexp 编译成一系列紧凑的操作码,这些操作码通常可以放在处理器的缓存中。当代码执行时,这些操作码可以全速运行,并快速搜索。</target>
        </trans-unit>
        <trans-unit id="35946850beee8b541477d17361e646c61666892c" translate="yes" xml:space="preserve">
          <source>Even with the latest version of Perl, it is known that certain constructs with threads may result in warning messages concerning leaked scalars or unreferenced scalars. However, such warnings are harmless, and may safely be ignored.</source>
          <target state="translated">即使是在最新版本的Perl中,人们也知道某些带线程的构造可能会导致关于泄漏标量或未引用标量的警告信息。然而,这种警告是无害的,可以放心地忽略。</target>
        </trans-unit>
        <trans-unit id="878e531bfbade13b1bab65a888ae7d4bdc1140e8" translate="yes" xml:space="preserve">
          <source>Event Log</source>
          <target state="translated">事件日志</target>
        </trans-unit>
        <trans-unit id="d3032d704e23194c50435cf4a6371b080589c4eb" translate="yes" xml:space="preserve">
          <source>Event driven.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1394956111c7856f6f7f78713d6c0aa968cc8b" translate="yes" xml:space="preserve">
          <source>Event for TAP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb79b9266fc643c28f6d3ecc5b6b3731a8786707" translate="yes" xml:space="preserve">
          <source>Event for a simple failed assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd541c73c6d801e12ef6ab2a2ef6eeb8678fe31" translate="yes" xml:space="preserve">
          <source>Event for a simple passing assertion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cbb1e51381ea5f156ee24e974d0e8c3d15bb5e6" translate="yes" xml:space="preserve">
          <source>Event for subtest types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa125b31576ec16d1e191efd5ca768b2aa4efa32" translate="yes" xml:space="preserve">
          <source>Event package name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="3cece53956ddc248529397d0c65ecaab5ebb07b6" translate="yes" xml:space="preserve">
          <source>Events live under this namespace. It is considered acceptable for third party distributions to add new event types in this namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50edb0cf580f75f4a0fea837a24e96eb1cff3aca" translate="yes" xml:space="preserve">
          <source>Events use this facet when they need to set the plan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b8ce2e1404f72b01628a7fbd8afce9a0ca4416" translate="yes" xml:space="preserve">
          <source>Events within a buffered subtest may or may not be sent to the formatter as they happen. If a formatter fails to specify then the default is to &lt;b&gt;NOT SEND&lt;/b&gt; the events as they are generated, instead the formatter can pull them from the &lt;code&gt;subevents&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4538af23a815bef65c32e32809e639186875a9f" translate="yes" xml:space="preserve">
          <source>Eventually, with better documentation and possible some cleanup, this could be part of &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d002601ef62e11979d8b7c94cd10d54da0d3a8e1" translate="yes" xml:space="preserve">
          <source>Ever wanted to know what a regex looked like? You'll need perl compiled with the DEBUGGING flag for this one:</source>
          <target state="translated">想过知道regex是什么样子吗?你需要用 DEBUGGING 标志编译 perl。</target>
        </trans-unit>
        <trans-unit id="d845fa7f9ca71d8879b9cc1aee98930cd966bdbd" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc9126b1847307a5366bc653e3a3467f58a3dfa" translate="yes" xml:space="preserve">
          <source>Every CPAN module has a bug tracker set up in RT, &lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;. You can submit bugs to RT either through its web interface or by email. To email a bug report, send it to bug-&amp;lt;distribution-name&amp;gt;@rt.cpan.org . For example, if you wanted to report a bug in &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, you could send a message to bug-Business-ISBN@rt.cpan.org .</source>
          <target state="translated">每个CPAN模块都在RT中设置了一个错误跟踪器，网址为&lt;a href=&quot;http://rt.cpan.org&quot;&gt;http://rt.cpan.org&lt;/a&gt;。您可以通过其Web界面或通过电子邮件将错误提交给RT。要通过电子邮件发送错误报告，请将其发送到bug- &amp;lt;distribution-name&amp;gt; @ rt.cpan.org。例如，如果您要报告&lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN中&lt;/a&gt;的错误，则可以向bug-Business-ISBN@rt.cpan.org发送一条消息。</target>
        </trans-unit>
        <trans-unit id="b8dc7000ca1bb13ca17faed27406eccbd7bcf88b" translate="yes" xml:space="preserve">
          <source>Every Makefile.PL is run by perl in a separate process. Likewise we run 'make' and 'make install' in separate processes. If you have any parameters (e.g. PREFIX, UNINST or the like) you want to pass to the calls, please specify them here.</source>
          <target state="translated">每个Makefile.PL都是由perl在单独的进程中运行的。同样的,我们也在单独的进程中运行'make'和'make install'。如果你有任何参数 (例如 PREFIX,UNINST 或类似的参数)想传递给调用,请在这里指定它们。</target>
        </trans-unit>
        <trans-unit id="5243f64d154762b9f500ff300bf1242e41c19e00" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="translated">每个Unicode字符都被分配了一个常规类别，这是&amp;ldquo;字符的最常见分类&amp;rdquo;（来自&lt;a href=&quot;http://www.unicode.org/reports/tr44&quot;&gt;http://www.unicode.org/reports/tr44&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="44bc5eca50d1bb33525106b332f679e0c37967c9" translate="yes" xml:space="preserve">
          <source>Every Unicode character is assigned a general category, which is the &quot;most usual categorization of a character&quot; (from &lt;a href=&quot;https://www.unicode.org/reports/tr44&quot;&gt;https://www.unicode.org/reports/tr44&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe5013abe724619f4b95c9d05a2b40a50dbbb59" translate="yes" xml:space="preserve">
          <source>Every YAML document represents a single hash reference. The valid keys in this hash are as follows:</source>
          <target state="translated">每个YAML文档都代表一个单一的哈希引用。这个哈希中的有效键如下:</target>
        </trans-unit>
        <trans-unit id="302f7ff33fa3b90fdd2132b2697fb84f8705e874" translate="yes" xml:space="preserve">
          <source>Every YAML file may contain arbitrary documents according to the YAML specification, and every document is treated as an entity that can specify the treatment of a single distribution.</source>
          <target state="translated">根据YAML规范,每一个YAML文件都可以包含任意的文件,每一个文件都被视为一个实体,可以指定单一分发的处理方式。</target>
        </trans-unit>
        <trans-unit id="08580b590313edf277a406f46fd0c846e6d3947e" translate="yes" xml:space="preserve">
          <source>Every case has a specific application and one or more exceptions, and there is no replacement for running a few tests and finding out which method works best for your particular environment, this is why writing optimal code is not an exact science, and why we love using Perl so much - TMTOWTDI.</source>
          <target state="translated">每一个案例都有一个特定的应用和一个或多个异常,没有任何方法可以替代运行几个测试并找出哪种方法最适合你的特定环境,这就是为什么编写最优代码不是一门精确的科学,也是为什么我们如此喜欢使用Perl的原因--TMTOWTDI。</target>
        </trans-unit>
        <trans-unit id="5d3966578fbc31ddc5c9c823b10c9d09c4de1eb0" translate="yes" xml:space="preserve">
          <source>Every code point can be represented by more than one possible syntactically valid UTF-8 sequence. Early on, both Unicode and Perl considered any of these to be valid, but now, all sequences longer than the shortest possible one are considered to be malformed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e844c7ea0f1cedd3ae0259a6817d00e2a02c10f0" translate="yes" xml:space="preserve">
          <source>Every developer publishing modules on CPAN needs a CPAN ID. Visit &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt;, select &quot;Request PAUSE Account&quot;, and wait for your request to be approved by the PAUSE administrators.</source>
          <target state="translated">CPAN上的每个开发人员发布模块都需要一个CPAN ID。访问 &lt;code&gt;&lt;a href=&quot;http://pause.perl.org/&quot;&gt;http://pause.perl.org/&lt;/a&gt;&lt;/code&gt; ，选择&amp;ldquo;请求PAUSE帐户&amp;rdquo;，然后等待您的请求被PAUSE管理员批准。</target>
        </trans-unit>
        <trans-unit id="e4befbeaf4f0b8eb62e07538a8708d75b3c87445" translate="yes" xml:space="preserve">
          <source>Every element in an arrayref directly below a 'par' key is eligible to be run in parallel, while vavalues directly below a 'seq' key must be run in sequence.</source>
          <target state="translated">在'par'键下面的arrayref中的每个元素都有资格被并行运行,而'seq'键下面的vavalues则必须按顺序运行。</target>
        </trans-unit>
        <trans-unit id="e1c563b6d35c0f4b5118e9474a1d4ce3c52e7bcc" translate="yes" xml:space="preserve">
          <source>Every element node in the parse tree is represented by an arrayref of the form: &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;. See the example tree dump in the Synopsis, above.</source>
          <target state="translated">解析树中的每个元素节点都由以下形式的arrayref表示： &lt;code&gt;[ &lt;i&gt;elementname&lt;/i&gt;, \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt; 。请参见上面的摘要中的示例树转储。</target>
        </trans-unit>
        <trans-unit id="6134bc0f6fbba39ed1a9d9da08c6587b9ff61665" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Finally, it tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="translated">这里的每一行(当然除了括号)都包含一个宏。第一行按照Perl对PP代码的期望设置了函数声明;第3行设置了参数栈和目标变量声明,即操作的返回值。最后,它尝试查看加法运算是否被重载;如果是,则调用相应的子程序。</target>
        </trans-unit>
        <trans-unit id="9871a7eb268ef840aca89ae1947284ed4718351a" translate="yes" xml:space="preserve">
          <source>Every line here (apart from the braces, of course) contains a macro. The first line sets up the function declaration as Perl expects for PP code; line 3 sets up variable declarations for the argument stack and the target, the return value of the operation. Line 4 tries to see if the addition operation is overloaded; if so, the appropriate subroutine is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16573fbf6c4df85710f7971d1598380405b3cf7c" translate="yes" xml:space="preserve">
          <source>Every single tool in the chain from this, to &lt;code&gt;ok&lt;/code&gt;, to anything &lt;code&gt;ok&lt;/code&gt; calls needs to increment the &lt;code&gt;$Level&lt;/code&gt; variable. When an error occurs Test::Builder will do a trace to the stack frame determined by &lt;code&gt;$Level&lt;/code&gt;, and report that file+line as the one where the error occurred. If you or any other tool you use forgets to set &lt;code&gt;$Level&lt;/code&gt; then errors will be reported to the wrong place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07a9740c8c1d7a3f895cbb42b5e873e7ccb12fd" translate="yes" xml:space="preserve">
          <source>Every source stream is associated with only one file.</source>
          <target state="translated">每个源流只与一个文件相关联。</target>
        </trans-unit>
        <trans-unit id="5b61ca48fb706399cd7458bb7c44f76e50b97e70" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="translated">树中的每个文本节点都由一个简单的（非引用）字符串标量表示。因此，您可以测试 &lt;code&gt;&lt;a href=&quot;../../functions/ref&quot;&gt;ref($node)&lt;/a&gt;&lt;/code&gt; 以查看您是否具有元素节点或仅具有文本节点。</target>
        </trans-unit>
        <trans-unit id="4b4dd92417b29f82a4df6cf833806102b2032c12" translate="yes" xml:space="preserve">
          <source>Every text node in the tree is represented by a simple (non-ref) string scalar. So you can test &lt;code&gt;ref($node)&lt;/code&gt; to see whether you have an element node or just a text node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f280cfdb5544f17d8056c7b9960291300e70ff8a" translate="yes" xml:space="preserve">
          <source>Every variable type has its own namespace, as do several non-variable identifiers. This means that you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash--or, for that matter, for a filehandle, a directory handle, a subroutine name, a format name, or a label. This means that $foo and @foo are two different variables. It also means that &lt;code&gt;$foo[1]&lt;/code&gt; is a part of @foo, not a part of $foo. This may seem a bit weird, but that's okay, because it is weird.</source>
          <target state="translated">每个变量类型都有其自己的名称空间，几个非变量标识符也是如此。这意味着您可以在不必担心冲突的情况下，对标量变量，数组或哈希使用相同的名称-或为此，对于文件句柄，目录句柄，子例程名称，格式名称，或标签。这意味着$ foo和@foo是两个不同的变量。这也意味着 &lt;code&gt;$foo[1]&lt;/code&gt; 是@foo的一部分，而不是$ foo的一部分。这看起来可能有点怪异，但是没关系，因为它很怪异。</target>
        </trans-unit>
        <trans-unit id="c6b180367788582d4ac065b82e10c88a1c69b113" translate="yes" xml:space="preserve">
          <source>Every version of perl has some number of features present but considered &quot;experimental.&quot; For much of the life of Perl 5, this was only a designation found in the documentation. Starting in Perl v5.10.0, and more aggressively in v5.18.0, experimental features were placed behind pragmata used to enable the feature and disable associated warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a304f3d76dc1d9d113e9e43b3de43a63253440" translate="yes" xml:space="preserve">
          <source>Everyone needs compound data structures, and in Perl the way you get them is with references. There are four important rules for managing references: Two for making references and two for using them. Once you know these rules you can do most of the important things you need to do with references.</source>
          <target state="translated">每个人都需要复合数据结构,而在Perl中,你获得复合数据结构的方式就是引用。管理引用有四个重要的规则。两条用于制作引用,两条用于使用它们。一旦你知道了这些规则,你就可以用引用来做大多数重要的事情。</target>
        </trans-unit>
        <trans-unit id="d9f3a853f21ee670feb2d57d64386bb213e70924" translate="yes" xml:space="preserve">
          <source>Everything is exported by default</source>
          <target state="translated">所有的东西都是默认导出的</target>
        </trans-unit>
        <trans-unit id="821563e027b1aef4013748dd378d74e1f89659aa" translate="yes" xml:space="preserve">
          <source>Everything that comes with the official</source>
          <target state="translated">伴随着官方的一切</target>
        </trans-unit>
        <trans-unit id="f760e16023bf894abde8086e9d7f6c930e923eae" translate="yes" xml:space="preserve">
          <source>Evolution</source>
          <target state="translated">Evolution</target>
        </trans-unit>
        <trans-unit id="be9e0b5a60df791db5db8c0c5ce8e708153692fd" translate="yes" xml:space="preserve">
          <source>Exact name value matching means you have to specify case, hyphens, underscores, and spaces precisely in the name you want. Loose matching follows the Unicode rules &lt;a href=&quot;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&quot;&gt;https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2&lt;/a&gt;, where these are mostly irrelevant. Except for a few outlier character names, these are the same rules as are already used for any other &lt;code&gt;\p{...}&lt;/code&gt; property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b6ebbed9d8b46f1eee90eb921f0ea47e548b03" translate="yes" xml:space="preserve">
          <source>Exact version of acceptance unclear, but no later than Perl 5.18.</source>
          <target state="translated">具体的接受版本不清楚,但不晚于Perl 5.18。</target>
        </trans-unit>
        <trans-unit id="e38657e86225451957dba5ba0d3e55c8be9b8de9" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; , but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt; . Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="translated">与 &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt; 完全等效，但是比使用 &lt;code&gt;Perl_croak&lt;/code&gt; 生成更简短的目标代码。减少在异常代码路径上使用的代码可以减少CPU缓存压力。</target>
        </trans-unit>
        <trans-unit id="1def74e4170191cc1ecc96e344d4615200db8d79" translate="yes" xml:space="preserve">
          <source>Exactly equivalent to &lt;code&gt;Perl_croak(aTHX_ &quot;%s&quot;, PL_no_modify)&lt;/code&gt;, but generates terser object code than using &lt;code&gt;Perl_croak&lt;/code&gt;. Less code used on exception code paths reduces CPU cache pressure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6053d16ee562b64ba170e6e47fc5857d6aeb0497" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd790b9a98470795c376e22181e112aefbda6acd" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;&quot;gv_fetchmeth_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8b76dc891dae007ee34c3cafc01118a9a75f9f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;完全一样，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="108d410dddfe12b3ba82a3d3c5aded251e31ceaa" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn&quot;&gt;gv_fetchmeth_pvn&lt;/a&gt;完全一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="70cd839834c4360be38cc8d256d0d20412f0b989" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11580dd84621e2b64c36cda28026ace99fe93821" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;&quot;gv_fetchmeth_pvn_autoload&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752e1ac766f2cea599a309e02440f40a97bb8d75" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">与&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;完全一样，但是采用以nul终止的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="a2b3eb60980e277cbebb6619993b224a080d7c7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#gv_fetchmeth_pvn_autoload&quot;&gt;gv_fetchmeth_pvn_autoload&lt;/a&gt;一样，但是采用SV形式的名称字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="0d559e98d13b3a163a9ac6d26cc159b061a846ce" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241177ff9d4a9c2896853e85618eb16dd97a70c1" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca8fa3e370c992adee4f86a24ca37067ce4aaf2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;&quot;pad_add_name_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fed67a8755ba4f29f90415a63203b5925d94458" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">完全类似于&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;，但采用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="08b5afa04635fafa6b86d20073dca412668556d2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;一样，但是使用以nul结尾的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="2ec05cc4ebe9d68aa94cb00389e8f5276b127226" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">完全类似于&lt;a href=&quot;#pad_add_name_pvn&quot;&gt;pad_add_name_pvn&lt;/a&gt;，但采用SV形式的名称字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="721fb60df3440b2db377705e79d6aa33255046e5" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858cd1e7a5bd641a77589913581d976a28b686b2" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c2f18b7b484bc1bcc0d307015d1cb3e5fc9527" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;&quot;pad_findmy_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc43c20a7b147a5aa429b8bfb5b2198f1bee606" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a literal string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是使用文字字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="1f5dc14f0356699ed601763f5b30ea66b583f929" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是使用以nul结尾的字符串而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="381384c344ba8cf1c452502a4a84edc8e962e04a" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#pad_findmy_pvn&quot;&gt;pad_findmy_pvn&lt;/a&gt;一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="18d3309cb57d37bd7fd350ad135bb897c6c3caec" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;&quot;sv_derived_from_pv&quot;&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e2d16336a0ca2ee4b68d73a469a9a7d8cd8bf4" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;, but doesn't take a &lt;code&gt;flags&lt;/code&gt; parameter.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pv&quot;&gt;sv_derived_from_pv&lt;/a&gt;一样，但是不带有 &lt;code&gt;flags&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="3b2c74334223dd3188d999503340448a8a7e5fef" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba2fef806c19d8e36b1b9aa042130a5d1188a1f" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;&quot;sv_derived_from_pvn&quot;&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair. This is the advised form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca422a64172952765c1b42b368f2ea1d836ab7e" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes a nul-terminated string instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;一样，但是采用以nul结尾的字符串，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="89c565bb719c5d7bd5d0a569932a9c743f646c23" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;, but takes the name string in the form of an SV instead of a string/length pair.</source>
          <target state="translated">就像&lt;a href=&quot;#sv_derived_from_pvn&quot;&gt;sv_derived_from_pvn&lt;/a&gt;一样，但是名称字符串采用SV的形式，而不是字符串/长度对。</target>
        </trans-unit>
        <trans-unit id="f536be833f98474874e14c0022645d10cd4c4708" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The</source>
          <target state="translated">就像 &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; 但是效率更高。</target>
        </trans-unit>
        <trans-unit id="ed85a2d94251cb3b70317fcac3c7aa7dfac953f8" translate="yes" xml:space="preserve">
          <source>Exactly like &lt;code&gt;XopENTRY(XopENTRY(Perl_custom_op_xop(aTHX_ o), which)&lt;/code&gt; but more efficient. The &lt;code&gt;which&lt;/code&gt; parameter is identical to &lt;a href=&quot;#XopENTRY&quot;&gt;&quot;XopENTRY&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cb14ad58a1b4462086f211195165ae13adba9c" translate="yes" xml:space="preserve">
          <source>Exactly like C:</source>
          <target state="translated">完全像C。</target>
        </trans-unit>
        <trans-unit id="7525b0bc0e061494669779471f34623f62998790" translate="yes" xml:space="preserve">
          <source>Exactly what the</source>
          <target state="translated">究竟是什么?</target>
        </trans-unit>
        <trans-unit id="738aaf2dccc78981e8b455dca2a194bd2ca3770c" translate="yes" xml:space="preserve">
          <source>Exactly what were the failed locale settings varies. In the above the settings were that the LC_ALL was &quot;En_US&quot; and the LANG had no value. This error means that Perl detected that you and/or your operating system supplier and/or system administrator have set up the so-called locale system but Perl could not use those settings. This was not dead serious, fortunately: there is a &quot;default locale&quot; called &quot;C&quot; that Perl can and will use, and the script will be run. Before you really fix the problem, however, you will get the same error message each time you run Perl. How to really fix the problem can be found in &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; section &lt;b&gt;LOCALE PROBLEMS&lt;/b&gt;.</source>
          <target state="translated">究竟什么是失败的区域设置会有所不同。在上面的设置中，LC_ALL为&amp;ldquo; En_US&amp;rdquo;，而LANG没有值。此错误意味着Perl检测到您和/或您的操作系统供应商和/或系统管理员已经设置了所谓的语言环境系统，但是Perl无法使用这些设置。幸运的是，这并不是很严重：Perl可以并且将使用一个名为&amp;ldquo; C&amp;rdquo;的&amp;ldquo;默认语言环境&amp;rdquo;，并且脚本将运行。但是，在真正解决问题之前，每次运行Perl都会收到相同的错误消息。如何真正解决问题中可以找到&lt;a href=&quot;perllocale&quot;&gt;perllocale手册&lt;/a&gt;节&lt;b&gt;LOCALE问题&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d8b6b2bbc7b58a995a5244483a44038c0c9b80cc" translate="yes" xml:space="preserve">
          <source>Examine signals that are blocked and pending. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;sigset&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigpending&lt;/code&gt; manpage for details.</source>
          <target state="translated">检查被阻止和未决的信号。它将 &lt;code&gt;POSIX::SigSet&lt;/code&gt; 对象用作 &lt;code&gt;sigset&lt;/code&gt; 参数。有关详细信息，请查阅系统的 &lt;code&gt;sigpending&lt;/code&gt; 页。</target>
        </trans-unit>
        <trans-unit id="9cc359cbd82e941e0ce6d56fc00bde6962483e78" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call.</source>
          <target state="translated">检查一个 op,预期它在运行时识别一个子程序,并试图在编译时确定它识别的是哪个子程序。这通常在Perl编译过程中用来确定一个原型是否可以应用到函数调用中。</target>
        </trans-unit>
        <trans-unit id="2816ec163840831fe4101935d11468555274d9b0" translate="yes" xml:space="preserve">
          <source>Examines an op, which is expected to identify a subroutine at runtime, and attempts to determine at compile time which subroutine it identifies. This is normally used during Perl compilation to determine whether a prototype can be applied to a function call. &lt;code&gt;cvop&lt;/code&gt; is the op being considered, normally an &lt;code&gt;rv2cv&lt;/code&gt; op. A pointer to the identified subroutine is returned, if it could be determined statically, and a null pointer is returned if it was not possible to determine statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce88b50818f0436a7682c61cd164aaafa21bdd4b" translate="yes" xml:space="preserve">
          <source>Examines the value of EXPR, expecting it to be a reference, and returns a string giving information about the reference and the type of referent. If EXPR is not specified, &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21009b11f09e3868b5cd364062bd16a01cd87baf" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; functions</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;functions/dump&quot;&gt;dump&lt;/a&gt;&lt;/code&gt; 功能检查内部数据结构</target>
        </trans-unit>
        <trans-unit id="1f9b5ae7207832dd1764b8c81e77154d27039133" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the &lt;code&gt;dump&lt;/code&gt; functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9d648412ff129c07a7aa241744818aaa63c13b" translate="yes" xml:space="preserve">
          <source>Examining internal data structures with the dump functions</source>
          <target state="translated">使用dump函数检查内部数据结构</target>
        </trans-unit>
        <trans-unit id="f25587ebeed31098679dd0a945296052447509f8" translate="yes" xml:space="preserve">
          <source>Examining the tree</source>
          <target state="translated">检查树</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="3ee687a4836f2979219916954f4addd8522f2875" translate="yes" xml:space="preserve">
          <source>Example - a Hexadecimal Handle</source>
          <target state="translated">例子-十六进制手柄</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">例1</target>
        </trans-unit>
        <trans-unit id="d64751054e2d27b855282a556af039128d434ede" translate="yes" xml:space="preserve">
          <source>Example 1: A simple filter.</source>
          <target state="translated">例1:一个简单的过滤器。</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">例二</target>
        </trans-unit>
        <trans-unit id="c9ff53c2379b7cde740f23e7a5efd8af7e83e70f" translate="yes" xml:space="preserve">
          <source>Example 2: Using the context</source>
          <target state="translated">例2:使用上下文</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fa8f292e6f2e8759c24edf270a2f53c96a1766" translate="yes" xml:space="preserve">
          <source>Example 3: Using the context within the filter</source>
          <target state="translated">例3:使用过滤器中的上下文</target>
        </trans-unit>
        <trans-unit id="39e8f452734bc5ce3b169811da6ab1984a676dbf" translate="yes" xml:space="preserve">
          <source>Example 4: Using filter_del</source>
          <target state="translated">示例4:使用 filter_del</target>
        </trans-unit>
        <trans-unit id="82dd29f8b1cca5a0b9d8a8b5b47aff607b15559f" translate="yes" xml:space="preserve">
          <source>Example Distroprefs Files</source>
          <target state="translated">示例Distroprefs文件</target>
        </trans-unit>
        <trans-unit id="1a2aefe8979aba9b8da50d2227d60de10fe393b6" translate="yes" xml:space="preserve">
          <source>Example corrected to show map of maps instead of list of maps (though descriptive text said 'map' even in v1.3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1479866f8111c0730b394a4d0e54b9686736ec4" translate="yes" xml:space="preserve">
          <source>Example hints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c67a372e04bf6d9b9e0054bc94bbe354f79d761" translate="yes" xml:space="preserve">
          <source>Example implementation might be:</source>
          <target state="translated">实施实例可以是:</target>
        </trans-unit>
        <trans-unit id="65cdc590a56f144422e8ab9d8551b4654f6b8393" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt; :</source>
          <target state="translated">使用 &lt;code&gt;%m&lt;/code&gt; 的示例：</target>
        </trans-unit>
        <trans-unit id="1e6115c04f6e10d5d5d6b87e30e1b6023acf08e4" translate="yes" xml:space="preserve">
          <source>Example of use of &lt;code&gt;%m&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">使用实例:</target>
        </trans-unit>
        <trans-unit id="ea87c9b65b6478fdd7882c8529d632b267f39539" translate="yes" xml:space="preserve">
          <source>Example similar to MAN1PODS.</source>
          <target state="translated">与MAN1PODS相似的例子。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用实例。</target>
        </trans-unit>
        <trans-unit id="6f46925524d1c01021e97594cd0f9813ff23d01d" translate="yes" xml:space="preserve">
          <source>Example wrapper function, using a custom stacktrace:</source>
          <target state="translated">使用自定义堆栈跟踪的包装函数示例。</target>
        </trans-unit>
        <trans-unit id="917f746ede8d074c95df4b99d59d955a898465de" translate="yes" xml:space="preserve">
          <source>Example, convert all JSON objects into the integer 5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a0b26277d048bcac5dd947ecabce4cb52276c3" translate="yes" xml:space="preserve">
          <source>Example, decode JSON objects of the form &lt;code&gt;{ &quot;__widget__&quot; =&amp;gt; &amp;lt;id&amp;gt; }&lt;/code&gt; into the corresponding &lt;code&gt;$WIDGET{&amp;lt;id&amp;gt;}&lt;/code&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7278e6c050b8c04dedcbda9af1550657a42fb4fe" translate="yes" xml:space="preserve">
          <source>Example, decode UTF-32LE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdc025886948570c6fbbadab1e6327c7c909d59" translate="yes" xml:space="preserve">
          <source>Example, encode a Perl scalar as JSON value without enabled &lt;code&gt;allow_nonref&lt;/code&gt;, resulting in an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed5be0c52bbf20defd0c9e845ecf60ed4c32045" translate="yes" xml:space="preserve">
          <source>Example, output UTF-16BE-encoded JSON:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70eed4e935f1e0e0b91352974e074471d01f2095" translate="yes" xml:space="preserve">
          <source>Example, space_before and indent disabled, space_after enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78e4fad7b27510e9dff599bdcd34d99787fce83" translate="yes" xml:space="preserve">
          <source>Example, space_before enabled, space_after and indent disabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21504e5520a63c06708e793261e7989f6e598670" translate="yes" xml:space="preserve">
          <source>Example.pm</source>
          <target state="translated">Example.pm</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="2f9aab2ce8a7f69580f3ffba5062983af60212df" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1b656e9d62a39986b515e970fb598d7c6a0a28" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d065a1b59988aa6c329900c3cada65931aeef53b" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module-Build&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="723a51aade7b3dfa260aa71d4fea09d109817345" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;Module::Build version 0.16&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcb81d7d81b9c7defbedc3997e69a4b739f84df6" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;module&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118e06607524b497bf1e00dd9542fcda25763c44" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;perl&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cad6ecdc1416c4a99a21cafbb2b565e4a7ce52ac" translate="yes" xml:space="preserve">
          <source>Example: Altering Concise Renderings</source>
          <target state="translated">例子:改变简洁的渲染</target>
        </trans-unit>
        <trans-unit id="e9234fbd94650af302f3c53c866ca9eab6d98b89" translate="yes" xml:space="preserve">
          <source>Example: At the command prompt Type &quot;nmake nwinstall&quot;. This will install NetWare Perl on the NetWare Server. Similarly, if you type &quot;nmake install&quot;, this will cause the binaries to be installed on the local machine. (Typically under the c:\perl folder)</source>
          <target state="translated">例如:在命令提示符下,输入 &quot;nmake nwinstall&quot;。在命令提示符下键入 &quot;nmake nwinstall&quot;。这将在 NetWare 服务器上安装 NetWare Perl。同样,如果键入 &quot;nmake install&quot;,将在本地计算机上安装二进制文件。(通常是在 c:/perl 文件夹下)</target>
        </trans-unit>
        <trans-unit id="24e5d3a101404316459c21180a1f55d046da675c" translate="yes" xml:space="preserve">
          <source>Example: Encode::ROT13</source>
          <target state="translated">例子:Encode::ROT13 Encode::ROT13</target>
        </trans-unit>
        <trans-unit id="d0830c89a9652382868513b8862db0a3cc84254e" translate="yes" xml:space="preserve">
          <source>Example: Parse some JSON arrays/objects in a given string and return them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0721ccbd9aaee85c90df176a3976ea110912494f" translate="yes" xml:space="preserve">
          <source>Example: The following code</source>
          <target state="translated">例子。以下代码</target>
        </trans-unit>
        <trans-unit id="57772da1cf0c7d363a78ec1c7ba403554cdf5105" translate="yes" xml:space="preserve">
          <source>Example: You can execute the following on the command prompt.</source>
          <target state="translated">例子:你可以在命令提示符下执行以下内容。你可以在命令提示符下执行以下内容。</target>
        </trans-unit>
        <trans-unit id="f2749017763b820ec8a5aab014519f7d7e9831d5" translate="yes" xml:space="preserve">
          <source>Example: base64 transcoder</source>
          <target state="translated">例如:base64转码器</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="1d7dd2b19077ebadaa57d2f6ba2c64d87037ae05" translate="yes" xml:space="preserve">
          <source>Examples (assuming an ASCII platform)</source>
          <target state="translated">例子(假设是ASCII平台</target>
        </trans-unit>
        <trans-unit id="47370b8eea1efa5172e76cf237bd26e7f736ebd6" translate="yes" xml:space="preserve">
          <source>Examples for converting:</source>
          <target state="translated">转换的例子:</target>
        </trans-unit>
        <trans-unit id="386c7abd2323831ffe2716ae79487fcd14a21d5e" translate="yes" xml:space="preserve">
          <source>Examples for rounding:</source>
          <target state="translated">四舍五入的例子。</target>
        </trans-unit>
        <trans-unit id="49d15bdd087c216bc7ae6d4ea03d99c8cec52e40" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="translated">文档中的示例应说明它们正在解释的概念。有时，显示语言功能原理的最佳方法是使用一个小型程序，使读者无需修改即可运行。通常，示例将由仅包含&amp;ldquo;重要&amp;rdquo;位的代码片段组成。 &amp;ldquo;重要&amp;rdquo;的定义因片段而异。有时，声明 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ，初始化所有变量并完全捕获每个错误情况非常重要。但是，这些事情常常使示例所要教的内容模糊不清。</target>
        </trans-unit>
        <trans-unit id="d11119ca6453ac0e54148249adca86e00f07f1e8" translate="yes" xml:space="preserve">
          <source>Examples in documentation should be illustrative of the concept they're explaining. Sometimes, the best way to show how a language feature works is with a small program the reader can run without modification. More often, examples will consist of a snippet of code containing only the &quot;important&quot; bits. The definition of &quot;important&quot; varies from snippet to snippet. Sometimes it's important to declare &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt;, initialize all variables and fully catch every error condition. More often than not, though, those things obscure the lesson the example was intended to teach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a591376177b86768f6394133fb691d5a829d17d6" translate="yes" xml:space="preserve">
          <source>Examples of invalid syntax:</source>
          <target state="translated">无效语法的例子:</target>
        </trans-unit>
        <trans-unit id="0d4621bd6639238b0ab788dd2cc321e39c7fc192" translate="yes" xml:space="preserve">
          <source>Examples of legal names are '$foo' for a scalar, '@foo' for an array, '%foo' for a hash, '&amp;amp;foo' or 'foo' for a subroutine and '*foo' for a glob (i.e. all symbol table entries associated with &quot;foo&quot;, including scalar, array, hash, sub and filehandle).</source>
          <target state="translated">合法名称的示例包括：&amp;ldquo; $ foo&amp;rdquo;（表示标量），&amp;ldquo; @ foo&amp;rdquo;（表示数组），&amp;ldquo;％foo&amp;rdquo;（表示散列），&amp;ldquo;＆foo&amp;rdquo;或&amp;ldquo; foo&amp;rdquo;表示子例程以及&amp;ldquo; * foo&amp;rdquo;表示全局名称（即，所有与&amp;ldquo; foo&amp;rdquo;关联的符号表条目，包括标量，数组，哈希，子和文件句柄）。</target>
        </trans-unit>
        <trans-unit id="d7c5ae33ac348a4d6e7614da1b0d7da380e1b269" translate="yes" xml:space="preserve">
          <source>Examples of use</source>
          <target state="translated">使用实例</target>
        </trans-unit>
        <trans-unit id="1a5dea85313337dc5454525e91430329e3b9eb0f" translate="yes" xml:space="preserve">
          <source>Examples of valid syntax (even though the attributes are unknown):</source>
          <target state="translated">有效语法的例子(即使属性未知):</target>
        </trans-unit>
        <trans-unit id="45b39bd436c5d9cd8f4ca9dd2c7eb59c66eb58b2" translate="yes" xml:space="preserve">
          <source>Examples section another documentation provided by John Heidemann &amp;lt;johnh@ISI.EDU&amp;gt;</source>
          <target state="translated">&amp;ldquo;示例&amp;rdquo;部分提供了John Heidemann提供的另一份文档&amp;lt;johnh@ISI.EDU&amp;gt;</target>
        </trans-unit>
        <trans-unit id="628a5608e1a43ca4bfb86500d847d49e2edd6c80" translate="yes" xml:space="preserve">
          <source>Examples where callbacks are necessary include</source>
          <target state="translated">需要回调的例子包括</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f98a53c84b8d27c6aba2afa49d1eb4984f22de98" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &quot;, which compiles as &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; .</source>
          <target state="translated">示例：&amp;ldquo; [_ 1]&amp;rdquo;和&amp;ldquo; [，_1]&amp;rdquo;，这是同义词；和&amp;ldquo; &lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt; &amp;rdquo;&amp;ldquo;，它们被编译为 &lt;code&gt;&lt;a href=&quot;../functions/join&quot;&gt;join&lt;/a&gt; &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0be9a5482bf17e8c5fe99a02aec7a8cea84f74f4" translate="yes" xml:space="preserve">
          <source>Examples: &quot;[_1]&quot; and &quot;[,_1]&quot;, which are synonymous; and &quot;&lt;code&gt;[,ID-(,_4,-,_2,)]&lt;/code&gt;&quot;, which compiles as &lt;code&gt;join &quot;&quot;, &quot;ID-(&quot;, $_[4], &quot;-&quot;, $_[2], &quot;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4e742ff692e5060c86af7b99c37b81006ce99b" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; , &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="translated">除 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; ，还需要&lt;b&gt;Unicode :: Normalize&lt;/b&gt;（另请参见&lt;b&gt;CAVEAT&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="750b06c4e20cd4bb5392f789eb453ec81bdf0ee9" translate="yes" xml:space="preserve">
          <source>Except &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt;, &lt;b&gt;Unicode::Normalize&lt;/b&gt; is required (see also &lt;b&gt;CAVEAT&lt;/b&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9a44f67c097a553bfa410868c60dd16cabf490e" translate="yes" xml:space="preserve">
          <source>Except being faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7f15d16385003ab5d07150052df64664c66bff" translate="yes" xml:space="preserve">
          <source>Except for &lt;a href=&quot;#The-Basics&quot;&gt;&quot;The Basics&quot;&lt;/a&gt; section, this page assumes you are familiar with regular expression basics, like what is a &quot;pattern&quot;, what does it look like, and how it is basically used. For a reference on how they are used, plus various examples of the same, see discussions of &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;qr//&lt;/code&gt; and &lt;code&gt;&quot;??&quot;&lt;/code&gt; in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b1235f5e6dc422681dc01e8714586f7ad38364" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; , each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="translated">除了 &lt;code&gt;FILTER_ONLY code =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; {...}&lt;/code&gt; ，每个组件过滤器都会重复调用一次，一次是针对源代码中找到的每个组件。</target>
        </trans-unit>
        <trans-unit id="4893191369665d6053617936c829c46737cadf4b" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;FILTER_ONLY code =&amp;gt; sub {...}&lt;/code&gt;, each of the component filters is called repeatedly, once for each component found in the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21a10e7180b4b8a76ea58d012850b5f1c4bcb634" translate="yes" xml:space="preserve">
          <source>Except importing the functions, 'autoload' is same as 'load'.</source>
          <target state="translated">除了导入函数,'autoload'和'load'是一样的。</target>
        </trans-unit>
        <trans-unit id="18f4bd6df6292a6b95734ee2a00973430550afe7" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'autoload_remote' is same as 'load_remote'.</source>
          <target state="translated">除了指定包和引用模块名外,'autoload_remote'和'load_remote'是一样的。</target>
        </trans-unit>
        <trans-unit id="16e04cb1bb937a46789e35dba24fd14a5feb954d" translate="yes" xml:space="preserve">
          <source>Except specifing the package and quoting module name, 'load_remote' is same as 'load'.</source>
          <target state="translated">除了指定包和引用模块名外,'load_remote'和'load'是一样的。</target>
        </trans-unit>
        <trans-unit id="f55cf6c06e02d10efcfcfb37efbd0c881f531275" translate="yes" xml:space="preserve">
          <source>Excepting those listed above, we're currently unable to guarantee that B::Deparse will produce a pragma at the correct point in the program. (Specifically, pragmas at the beginning of a block often appear right before the start of the block instead.) Since the effects of pragmas are often lexically scoped, this can mean that the pragma holds sway over a different portion of the program than in the input file.</source>
          <target state="translated">除了上面列出的那些,我们目前还不能保证 B::Deparse 会在程序的正确位置产生一个 pragma。(具体来说,在程序块开头的pragma经常出现在程序块开始之前。)由于 pragma 的效果通常是词法范围的,这可能意味着 pragma 在程序中的不同部分与在输入文件中的不同部分起作用。</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="826f288dbfc038dead10724f69465c1bfe17a68f" translate="yes" xml:space="preserve">
          <source>Exception Handling (simple) Macros</source>
          <target state="translated">异常处理(简单)宏</target>
        </trans-unit>
        <trans-unit id="c63dbeff42b8bdcfbb58c593ff1bf6b1c3d8a3ca" translate="yes" xml:space="preserve">
          <source>Exception class used by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a349dc2d7ddd050d57ee72af0506a4a2b31cc9" translate="yes" xml:space="preserve">
          <source>Exception event</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa345b763368fc4f9065828d77e9729e19d258cc" translate="yes" xml:space="preserve">
          <source>Exception handing</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="3ab46cd93f74baf3da5f557d5f2997aae41ff3b1" translate="yes" xml:space="preserve">
          <source>Exceptions from &lt;code&gt;max_size&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt; or other errors will result in a pseudo-HTTP status code of 599 and a reason of &quot;Internal Exception&quot;. The content field in the response will contain the text of the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d504b2a99c5e1f8d7e7350318f686e5cbee7a60e" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying functions.</source>
          <target state="translated">自律功能的例外情况。</target>
        </trans-unit>
        <trans-unit id="1242bf8dd433a51fa4c19b0e3a208b834c9fc265" translate="yes" xml:space="preserve">
          <source>Exceptions from autodying system().</source>
          <target state="translated">来自autodying system()的异常。</target>
        </trans-unit>
        <trans-unit id="48741c44a476b90391e45eac22eeaa9b0d399fee" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie/exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="translated">由 &lt;code&gt;autodie&lt;/code&gt; 编译指示产生的异常是&lt;a href=&quot;autodie/exception&quot;&gt;autodie :: exception&lt;/a&gt;类的成员。在Perl 5.10中使用这些异常的首选方法如下：</target>
        </trans-unit>
        <trans-unit id="53d59c8491a17793e5a74a9328b1458c0ce10dc9" translate="yes" xml:space="preserve">
          <source>Exceptions produced by the &lt;code&gt;autodie&lt;/code&gt; pragma are members of the &lt;a href=&quot;autodie::exception&quot;&gt;autodie::exception&lt;/a&gt; class. The preferred way to work with these exceptions under Perl 5.10 is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5986414d0fc4bb9c4ee5d8198af90a5eb243568c" translate="yes" xml:space="preserve">
          <source>Exceptions, error return codes, exit statuses, and errno settings. Typically used for function or module documentation; program documentation uses DIAGNOSTICS instead. The general rule of thumb is that errors printed to &lt;code&gt;STDOUT&lt;/code&gt; or &lt;code&gt;STDERR&lt;/code&gt; and intended for the end user are documented in DIAGNOSTICS while errors passed internal to the calling program and intended for other programmers are documented in ERRORS. When documenting a function that sets errno, a full list of the possible errno values should be given here.</source>
          <target state="translated">异常，错误返回码，退出状态和errno设置。通常用于功能或模块文档；程序文档改用DIAGNOSTICS。一般的经验法则是，打印到 &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 并供最终用户使用的错误在DIAGNOSTICS中记录，而传递给调用程序内部并供其他程序员使用的错误在ERRORS中记录。在记录设置errno的函数时，应在此处给出所有可能的errno值的完整列表。</target>
        </trans-unit>
        <trans-unit id="3e8ef9fa750a38a235f6f5db2c10f6d27bcf66b2" translate="yes" xml:space="preserve">
          <source>Excessive pride, the sort of thing for which Zeus zaps you. Also the quality that makes you write (and maintain) programs that other people won&amp;rsquo;t want to say bad things about. Hence, the third great virtue of a programmer. See also &lt;b&gt;laziness&lt;/b&gt; and &lt;b&gt;impatience&lt;/b&gt;.</source>
          <target state="translated">过度的自豪感，宙斯（Zeus）为您提供的东西。还有使您编写（和维护）其他人不想说坏话的程序的质量。因此，程序员的第三大美德。另请参见&lt;b&gt;懒惰&lt;/b&gt;和&lt;b&gt;急躁&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="a5d912f09e4af174aa651a0745dc7cd68fcf8fd2" translate="yes" xml:space="preserve">
          <source>Excessively long &amp;lt;&amp;gt; operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ff53c1a7c6e7525075531f3d6b8357745fac262" translate="yes" xml:space="preserve">
          <source>Exchanging signed integers between different platforms works only when all platforms store them in the same format. Most platforms store signed integers in two's-complement notation, so usually this is not an issue.</source>
          <target state="translated">在不同平台之间交换有符号的整数,只有当所有平台都以相同的格式存储它们时,才可以进行。大多数平台都是以双补码的方式存储有符号的整数,所以通常这不是一个问题。</target>
        </trans-unit>
        <trans-unit id="6d598c708e755dc53aa35c070da1bc37864ef85e" translate="yes" xml:space="preserve">
          <source>Exclude the given routine and its descendants from the profile.</source>
          <target state="translated">从配置文件中排除给定例程及其子代。</target>
        </trans-unit>
        <trans-unit id="712815e07d58e914b686a30fadb75309ce36dd4f" translate="yes" xml:space="preserve">
          <source>Excommunicated</source>
          <target state="translated">Excommunicated</target>
        </trans-unit>
        <trans-unit id="ce52f407fe57f7ce5f94a6ed1047c07eafabc89f" translate="yes" xml:space="preserve">
          <source>Executables for Perl utilities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8a72f8f7694a401a32218abd4406ae1d283fcc" translate="yes" xml:space="preserve">
          <source>Executables for gzip, zip, and VMStar:</source>
          <target state="translated">gzip、zip和VMStar的可执行文件。</target>
        </trans-unit>
        <trans-unit id="58de6b665842567beab85d292c3b5870de1c65ae" translate="yes" xml:space="preserve">
          <source>Execute a regexp. The arguments are</source>
          <target state="translated">执行一个regexp。参数为</target>
        </trans-unit>
        <trans-unit id="bac595ee7bf88de92060cce1abba1b3d844e6519" translate="yes" xml:space="preserve">
          <source>Execute command as a Perl statement. A trailing semicolon will be supplied. If the Perl statement would otherwise be confused for a Perl debugger, use a leading semicolon, too.</source>
          <target state="translated">以Perl语句的形式执行命令。将提供一个尾部分号。如果 Perl 语句会让 Perl 调试器感到困惑,也请使用前导分号。</target>
        </trans-unit>
        <trans-unit id="ec1ff77553768eb52e9d8af54796c7b0bfee25e2" translate="yes" xml:space="preserve">
          <source>Execute related options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45a9d6764cd8a4584e5070807ab16a657d631e8" translate="yes" xml:space="preserve">
          <source>Execute the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c456233f2824914a52bfceba7c1ea3f220aec8f" translate="yes" xml:space="preserve">
          <source>Execute the given C code and print its results. &lt;b&gt;WARNING&lt;/b&gt;: Perl makes heavy use of macros, and</source>
          <target state="translated">执行给定的C代码并打印其结果。&lt;b&gt;警告&lt;/b&gt;：Perl大量使用宏，并且</target>
        </trans-unit>
        <trans-unit id="9ac88dd7c0b19c435fb63cfe3bac19cbfc350e4d" translate="yes" xml:space="preserve">
          <source>Execute the provided install script from shell or via its icon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061e9bcfa95dc9f2f39332fda78eedc474b39569" translate="yes" xml:space="preserve">
          <source>Execute this statement for a hint about where to find CORE:</source>
          <target state="translated">执行这条语句,以获得关于在哪里可以找到CORE的提示。</target>
        </trans-unit>
        <trans-unit id="a79b5094cc2990d328a2ac30ea62e13817dec0a0" translate="yes" xml:space="preserve">
          <source>Executes a &lt;code&gt;GET&lt;/code&gt; request for the URL and saves the response body to the file name provided. The URL must have unsafe characters escaped and international domain names encoded. If the file already exists, the request will include an &lt;code&gt;If-Modified-Since&lt;/code&gt; header with the modification timestamp of the file. You may specify a different &lt;code&gt;If-Modified-Since&lt;/code&gt; header yourself in the &lt;code&gt;$options-&amp;gt;{headers}&lt;/code&gt; hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2aff22989bc6aeac5d6cd7864aab55a4f7fed20" translate="yes" xml:space="preserve">
          <source>Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST', 'PUT', etc.) on the given URL. The URL must have unsafe characters escaped and international domain names encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574f52d839fd11f8f8f4c4d0ddacf0528556159a" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression 50 times without consuming any input string will result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">在没有消耗任何输入字符串的情况下,执行一个推迟的正则表达式50次,将导致一个致命的错误。最大深度是编译到perl中的,所以改变它需要自定义构建。</target>
        </trans-unit>
        <trans-unit id="92a60b45df076860f644e5d058a8c446b0d5be54" translate="yes" xml:space="preserve">
          <source>Executing a postponed regular expression too many times without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="13709dfa0128b531e84d0b60f2a2419c6bf04dbf" translate="yes" xml:space="preserve">
          <source>Execution of END blocks</source>
          <target state="translated">执行结束块</target>
        </trans-unit>
        <trans-unit id="675e718a6b33ba2b7929f770db612d9a80f9b87e" translate="yes" xml:space="preserve">
          <source>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</source>
          <target state="translated">执行regex一般包括两个阶段,第一个阶段是在字符串中找到我们应该匹配的起始点,第二个阶段是运行regop解释器。</target>
        </trans-unit>
        <trans-unit id="119f08e3cf8da3d7fe34ab1131df979eb14179b1" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">执行任何 &lt;code&gt;CHECK&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="0603019ab35ef11320acde0ed06d6533404cfee9" translate="yes" xml:space="preserve">
          <source>Execution of any &lt;code&gt;END&lt;/code&gt; blocks.</source>
          <target state="translated">执行任何 &lt;code&gt;END&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="f4f82800233d6c7223698c2e187aa3ccc7d2dc01" translate="yes" xml:space="preserve">
          <source>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</source>
          <target state="translated">解释器本身的执行曾经是递归的,但由于Dave Mitchell在5.9.x开发轨道上的努力,这种情况已经发生了改变:现在堆上维护了一个内部栈,例程是完全迭代的。这可能会使它变得很棘手,因为代码对它存储的状态相当保守,结果由于模拟递归,代码中连续的两行实际上可能在完全不同的上下文中运行。</target>
        </trans-unit>
        <trans-unit id="4e9f10726faddb4d512801b20f95c6f56436cea8" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name in scalar context. Returns the same SV that the C function returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc06ef2194671cce285095b6f928f8f2f608822" translate="yes" xml:space="preserve">
          <source>Exercises the C function of the same name. Returns nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b9fcc2702356b63c40509208ebb73f559ce07" translate="yes" xml:space="preserve">
          <source>Exhaustive information on the topic of references can be found in &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;, &lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;, &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;.</source>
          <target state="translated">有关参考主题的详尽信息可以在&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;，&lt;a href=&quot;perllol&quot;&gt;perllol&lt;/a&gt;，&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;和&lt;a href=&quot;perldsc&quot;&gt;perldsc中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76b5089ada110a0136449f09bf11c2275168e2c5" translate="yes" xml:space="preserve">
          <source>Existing 32 bit apps are properly known as LP32, i.e. Longs and Pointers are 32 bit. 64-bit apps are more properly known as LP64. The discriminating feature of a LP64 bit app is its ability to utilise a 64-bit address space. It is perfectly possible to have a LP32 bit app that supports both 64-bit integers (long long) and largefiles (&amp;gt; 2GB), and this is the default for perl-5.6.0.</source>
          <target state="translated">现有的32位应用程序正确地称为LP32，即Longs和Pointers是32位。64位应用程序更恰当地称为LP64。LP64位应用程序的区别性在于它能够利用64位地址空间。一个LP32位应用程序同时支持64位整数（长整型）和大文件（&amp;gt; 2GB）是完全可能的，而这是perl-5.6.0的默认设置。</target>
        </trans-unit>
        <trans-unit id="3ce132dcaab82a474dd839ab951c3eef1631d645" translate="yes" xml:space="preserve">
          <source>Existing syntax and semantics should only be marked for destruction in very limited circumstances. If they are believed to be very rarely used, stand in the way of actual improvement to the Perl language or perl interpreter, and if affected code can be easily updated to continue working, they may be considered for removal. When in doubt, caution dictates that we will favor backward compatibility. When a feature is deprecated, a statement of reasoning describing the decision process will be posted, and a link to it will be provided in the relevant perldelta documents.</source>
          <target state="translated">现有的语法和语义只有在非常有限的情况下才能被标记销毁。如果它们被认为很少被使用,妨碍了Perl语言或perl解释器的实际改进,并且如果受影响的代码可以很容易地更新以继续工作,那么它们可能会被考虑删除。在有疑问的情况下,谨慎的态度决定了我们会倾向于向后兼容。当一个特性被废弃时,我们会发布一份说明理由的声明,描述决策过程,并在相关的perldelta文档中提供链接。</target>
        </trans-unit>
        <trans-unit id="6d9d19533b0fbf724f69a3d7a99a413b54990645" translate="yes" xml:space="preserve">
          <source>Exit Code</source>
          <target state="translated">出口代码</target>
        </trans-unit>
        <trans-unit id="45d746a8ea75007a4818f4a9a13d84ba46bc8da2" translate="yes" xml:space="preserve">
          <source>Exiting eval via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc760fc51ed4d60f1f58db324e3b3ab5637ff7f6" translate="yes" xml:space="preserve">
          <source>Exiting format via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6b6283c09f2fd4cd4d37232a60ec674d66805a" translate="yes" xml:space="preserve">
          <source>Exiting pseudo-block via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a99dd93f7907c63d9f314a53349298ea450b60" translate="yes" xml:space="preserve">
          <source>Exiting subroutine via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eedf12ff192cfbfe7957d4a6c26105640adbff0b" translate="yes" xml:space="preserve">
          <source>Exiting substitution via %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71626cd31b069ac3980d7ed6a6abb80f71225a3" translate="yes" xml:space="preserve">
          <source>Exits</source>
          <target state="translated">Exits</target>
        </trans-unit>
        <trans-unit id="bc031d65eaef8ccada69a0c994a430a53a41354d" translate="yes" xml:space="preserve">
          <source>Exotic Templates</source>
          <target state="translated">异国情调的模板</target>
        </trans-unit>
        <trans-unit id="2c6c990ee216fb59d7ad72ee8d28ebcceeb5a21e" translate="yes" xml:space="preserve">
          <source>Expand and unexpand tabs like unix expand(1) and unexpand(1)</source>
          <target state="translated">展开和展开选项卡,就像unix expand(1)和unexpand(1)一样。</target>
        </trans-unit>
        <trans-unit id="2b116400884e9dbc3a5bf5fe94b7d6faa8b0dd38" translate="yes" xml:space="preserve">
          <source>Expand conventional syntax constructions into equivalent ones that expose their internal operation.</source>
          <target state="translated">将传统的语法结构扩展为暴露其内部操作的等价结构。</target>
        </trans-unit>
        <trans-unit id="a24145087edc62ad61c2e0e0ed9777002b6b1d94" translate="yes" xml:space="preserve">
          <source>Expand double-quoted strings into the corresponding combinations of concatenation, uc, ucfirst, lc, lcfirst, quotemeta, and join. For instance, print</source>
          <target state="translated">将双引号字符串展开为concatenation、uc、ucfirst、lc、lcfirst、quotemeta和join的相应组合。例如,打印</target>
        </trans-unit>
        <trans-unit id="a3cec9741cec0dca8594001a6d2ea842476ee2ac" translate="yes" xml:space="preserve">
          <source>Expand patterns that start with '~' to user name home directories.</source>
          <target state="translated">将以'~'开头的模式扩展为用户名主目录。</target>
        </trans-unit>
        <trans-unit id="6b6e1cee8dd20e696133457bd5f5a86ddd470c1e" translate="yes" xml:space="preserve">
          <source>Expanding on these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc5537d5aa41a3bee835484d8a71db89d04af82" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt; , and returns the result as a file specification in Unix syntax.</source>
          <target state="translated">使用 &lt;code&gt;%$self&lt;/code&gt; 同名元素的内容，在文本字符串中扩展MM [KS] / Make宏，并以Unix语法将结果作为文件规范返回。</target>
        </trans-unit>
        <trans-unit id="bb3eba70260caae42d2a56d669b04a37e9fa0e09" translate="yes" xml:space="preserve">
          <source>Expands MM[KS]/Make macros in a text string, using the contents of identically named elements of &lt;code&gt;%$self&lt;/code&gt;, and returns the result as a file specification in Unix syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5783f703e4997395da1ed4bfbdfa29354401cb" translate="yes" xml:space="preserve">
          <source>Expands a message, intended for the user, to include an indication of the current location in the code, if the message does not already appear to be complete.</source>
          <target state="translated">如果信息看起来还不完整,则扩展一个信息,打算给用户的信息,包括代码中当前位置的指示。</target>
        </trans-unit>
        <trans-unit id="acbbc593d8399af8ae3b5c591c83e4cbee77c103" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= &lt;code&gt;SVt_PV&lt;/code&gt;. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde8be1848474c5303345a29bcef52bb4a7e17d" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV so that it has room for the indicated number of bytes (remember to reserve space for an extra trailing &lt;code&gt;NUL&lt;/code&gt; character). Calls &lt;code&gt;sv_grow&lt;/code&gt; to perform the expansion if necessary. Returns a pointer to the character buffer. SV must be of type &amp;gt;= SVt_PV. One alternative is to call &lt;code&gt;sv_grow&lt;/code&gt; if you are not sure of the type of SV.</source>
          <target state="translated">扩展SV中的字符缓冲区，以便为指定的字节数留出空间（请记住为额外的尾随 &lt;code&gt;NUL&lt;/code&gt; 字符保留空间）。如有必要，调用 &lt;code&gt;sv_grow&lt;/code&gt; 进行扩展。返回指向字符缓冲区的指针。SV的类型必须&amp;gt; = SVt_PV。一种替代方法是，如果不确定SV的类型，则调用 &lt;code&gt;sv_grow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07f45c58aaef41c3cc48eff8856e3deb378b3c7" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt; . Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="translated">扩展SV中的字符缓冲区。如有必要，请使用 &lt;code&gt;sv_unref&lt;/code&gt; 并将SV升级到 &lt;code&gt;SVt_PV&lt;/code&gt; 。返回指向字符缓冲区的指针。请改用 &lt;code&gt;SvGROW&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="bdfec9c6e27c21de38d0ad42245bca4c56a0db95" translate="yes" xml:space="preserve">
          <source>Expands the character buffer in the SV. If necessary, uses &lt;code&gt;sv_unref&lt;/code&gt; and upgrades the SV to &lt;code&gt;SVt_PV&lt;/code&gt;. Returns a pointer to the character buffer. Use the &lt;code&gt;SvGROW&lt;/code&gt; wrapper instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53b55719b11400ab3946110ac0b6da5f10e36cb7" translate="yes" xml:space="preserve">
          <source>Expands_On_NFC</source>
          <target state="translated">Expands_On_NFC</target>
        </trans-unit>
        <trans-unit id="6067c08bd93995f39d3f36483e3f4ef3039e3007" translate="yes" xml:space="preserve">
          <source>Expands_On_NFD</source>
          <target state="translated">Expands_On_NFD</target>
        </trans-unit>
        <trans-unit id="5df7d510e0afb51aa87d43b92bcf880d99423548" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKC</source>
          <target state="translated">Expands_On_NFKC</target>
        </trans-unit>
        <trans-unit id="cc2ac673ebfc4ca4115add5e1d8491f6e16313e9" translate="yes" xml:space="preserve">
          <source>Expands_On_NFKD</source>
          <target state="translated">Expands_On_NFKD</target>
        </trans-unit>
        <trans-unit id="60ad5e3c5be34af787f1a5a9f57ebcde8c336258" translate="yes" xml:space="preserve">
          <source>Expected '=item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0de321b4edfe39f598e66ba458f32fd64da99" translate="yes" xml:space="preserve">
          <source>Expected '=item *'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c7b4c3fe35b49213cdaeefc6c1268989f5da0" translate="yes" xml:space="preserve">
          <source>Expecting a single value is not quite the same as knowing that there will be one. If someone modified</source>
          <target state="translated">期待一个单一的值和知道会有一个值是不太一样的。如果有人修改了</target>
        </trans-unit>
        <trans-unit id="64185a4c949e7204414cf46ff03bc3f1606cbf77" translate="yes" xml:space="preserve">
          <source>Expecting close bracket in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65287be72b978ac388e5b50adfdc25bcb62b5804" translate="yes" xml:space="preserve">
          <source>Expecting interpolated extended charclass in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf72e88f58634dcb4936f677084e0a00acfdd002" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt; . If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="translated">需要名称=&amp;gt;值对的匿名哈希。名称与 &lt;code&gt;new&lt;/code&gt; 中的规则相同。如果未提供任何参数，则将在列表上下文中返回名称=&amp;gt;值对的&amp;ldquo;可见&amp;rdquo;列表。否则，返回对象本身。</target>
        </trans-unit>
        <trans-unit id="4d7959ebdbd1eb9b37094b35dddbe6785e49b443" translate="yes" xml:space="preserve">
          <source>Expects an anonymous hash of name =&amp;gt; value pairs. Same rules apply for names as in &lt;code&gt;new&lt;/code&gt;. If no argument is supplied, will return the &quot;seen&quot; list of name =&amp;gt; value pairs, in a list context. Otherwise, returns the object itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc66b53e07eb3ff24ec3024a45e5d4fb318685f8" translate="yes" xml:space="preserve">
          <source>Experimental %s on scalar is now forbidden</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b17e379ead5f797c5aa37eb9dc9a107df81896" translate="yes" xml:space="preserve">
          <source>Experimental Details on given and when</source>
          <target state="translated">实验细节在给定和当</target>
        </trans-unit>
        <trans-unit id="f6f74c01abe74837a83d80a82742b5139aa6cefe" translate="yes" xml:space="preserve">
          <source>Experimental Support for Sun Studio Compilers for Linux OS</source>
          <target state="translated">对Linux操作系统的Sun Studio编译器的实验性支持</target>
        </trans-unit>
        <trans-unit id="7e049d90ac73798a976f271b4843fd29805765d5" translate="yes" xml:space="preserve">
          <source>Experimental aliasing via reference not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e15651ca047ada36f7efb9c2f8e000cd639262b" translate="yes" xml:space="preserve">
          <source>Experimental features made easy</source>
          <target state="translated">简单的实验功能</target>
        </trans-unit>
        <trans-unit id="ed2ea169fad6a1c0c998398ba26a1941a42d9f93" translate="yes" xml:space="preserve">
          <source>Experimental features must be experimental in two stable releases before being marked non-experimental. Experimental features will only have their experimental status revoked when they no longer have any design-changing bugs open against them and when they have remained unchanged in behavior for the entire length of a development cycle. In other words, a feature present in v5.20.0 may be marked no longer experimental in v5.22.0 if and only if its behavior is unchanged throughout all of v5.21.</source>
          <target state="translated">实验性功能在被标记为非实验性之前,必须在两个稳定版本中成为实验性功能。实验性功能只有在不再有任何改变设计的bug存在,并且在整个开发周期中保持不变的情况下,才会被取消实验性状态。换句话说,一个在 v5.20.0 中存在的特性在 v5.22.0 中可能会被标记为不再是实验性的,前提是它的行为在整个 v5.21 中没有变化。</target>
        </trans-unit>
        <trans-unit id="812cee3839ce593c6e7f8fb81f34a218fc92295b" translate="yes" xml:space="preserve">
          <source>Experimental implementation to deal with optional_features from META.yml. Still needs coordination with installer software and currently works only for META.yml declaring &lt;code&gt;dynamic_config=0&lt;/code&gt; . Use with caution.</source>
          <target state="translated">实验性实现，用于处理META.yml中的optional_features。仍然需要与安装程序软件协调，并且目前仅适用于声明了 &lt;code&gt;dynamic_config=0&lt;/code&gt; 的 META.yml 。请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="134ab6b7ca3f00324871d474fd88846598632c3d" translate="yes" xml:space="preserve">
          <source>Experimental subroutine signatures not enabled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a2e6bb257f27dcbf131f0e4c5090288b803bfa" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build enviroment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="translated">增加了对使用Intel C++编译器的实验性支持。编辑win32/Makefile并为安装了Intel C的Visual C选择正确的CCTYPE。同时取消 __ICC 的注释,以启用 Intel C 对 Visual C 的支持。要设置构建环境,从开始菜单中运行IA-32 Visual Studio 20__模式或Intel 64 Visual Studio 20__模式。然后像通常那样在该提示框中运行 nmake。</target>
        </trans-unit>
        <trans-unit id="910b0326198fc0d6a945d746fbbbc76ed369e62f" translate="yes" xml:space="preserve">
          <source>Experimental support for using Intel C++ Compiler has been added. Edit win32/Makefile and pick the correct CCTYPE for the Visual C that Intel C was installed into. Also uncomment __ICC to enable Intel C on Visual C support. To set up the build environment, from the Start Menu run IA-32 Visual Studio 20__ mode or Intel 64 Visual Studio 20__ mode as appropriate. Then run nmake as usually in that prompt box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512d10cc80bbcc4b910ab34f44eacc0c8a8cab5b" translate="yes" xml:space="preserve">
          <source>Explain how to make a valid fh without going through open()(i.e. apply a layer). For example if the file is not opened through perl, but we want to get back a fh, like it was opened by Perl.</source>
          <target state="translated">解释一下如何在不经过open()(即应用一层)的情况下,做出一个有效的fh。例如,如果文件不是通过perl打开的,但我们想得到一个fh,就像用Perl打开的一样。</target>
        </trans-unit>
        <trans-unit id="c3c57a0034753db204133ffc1a0baecdf062f580" translate="yes" xml:space="preserve">
          <source>Explanation of the error, or the error itself (such as an exception). In perl exceptions may be blessed objects, so this field may contain a blessed object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd7eb7e15c45c52322c743748d0912cc8c1637a0" translate="yes" xml:space="preserve">
          <source>Explicit blessing to '' (assuming package main)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae3abeefc2986f2eb842d3cd9632c0a0316ad1f" translate="yes" xml:space="preserve">
          <source>Explicit context</source>
          <target state="translated">明确的背景</target>
        </trans-unit>
        <trans-unit id="04ff6c95ad88a6e349a482b76bfc08416f18ea96" translate="yes" xml:space="preserve">
          <source>Explicitly forces no carriage control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d335bbeeb032574984b5eec4fdf9e2563d5abb" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; --&lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="translated">明确使用 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; - &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; 配对</target>
        </trans-unit>
        <trans-unit id="6e87a66444e923290e00f1a8b43474c974953b7a" translate="yes" xml:space="preserve">
          <source>Explicitly using the &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt;--&lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pairing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="b04b1d43c804b579fc2179b2b3b449ae1560ae80" translate="yes" xml:space="preserve">
          <source>Export tags defined</source>
          <target state="translated">出口标签定义</target>
        </trans-unit>
        <trans-unit id="a10fabb79509133b618928fd32456dad097bd96f" translate="yes" xml:space="preserve">
          <source>Exportable Functions</source>
          <target state="translated">可导出功能</target>
        </trans-unit>
        <trans-unit id="087b5b3729015829a7b8d0086f8e5125870ab2b2" translate="yes" xml:space="preserve">
          <source>Exportable Methods</source>
          <target state="translated">可导出方法</target>
        </trans-unit>
        <trans-unit id="3fb8ab7d4fdb770897f754d6218d2ea74b86ecf3" translate="yes" xml:space="preserve">
          <source>Exportable constants</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60fa04392e9fbe49aa17d919da35cd7332fea185" translate="yes" xml:space="preserve">
          <source>Exported utility variables</source>
          <target state="translated">输出的效用变量</target>
        </trans-unit>
        <trans-unit id="0cd84bdcb23e59371516a9290d82778263ec9c7c" translate="yes" xml:space="preserve">
          <source>Exporter</source>
          <target state="translated">Exporter</target>
        </trans-unit>
        <trans-unit id="e3272220a019edf889f502d8e939100dd7ba6db5" translate="yes" xml:space="preserve">
          <source>Exporter - Implements default import method for modules</source>
          <target state="translated">Exporter-执行模块的默认导入方法。</target>
        </trans-unit>
        <trans-unit id="9677334ff1544480ffd2a9303280ab252a694823" translate="yes" xml:space="preserve">
          <source>Exporter guts</source>
          <target state="translated">出口商内脏</target>
        </trans-unit>
        <trans-unit id="733f73993629cd5a5a17865554f4f49f3a533105" translate="yes" xml:space="preserve">
          <source>Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:</source>
          <target state="translated">Exporter有一个特殊的方法,'export_to_level',它用于不能直接调用Exporter的导入方法的情况。export_to_level方法看起来像这样。</target>
        </trans-unit>
        <trans-unit id="e3e659931fe986137a62058f2b4abcef03d65202" translate="yes" xml:space="preserve">
          <source>Exporter.pm</source>
          <target state="translated">Exporter.pm</target>
        </trans-unit>
        <trans-unit id="dc76f5ce6b0b38a5f000b46176cc35b9cb43b24a" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy</source>
          <target state="translated">Exporter::Heavy</target>
        </trans-unit>
        <trans-unit id="1d1140249dd08a40f776c20b9ddd54b5796c4a08" translate="yes" xml:space="preserve">
          <source>Exporter::Heavy - Exporter guts</source>
          <target state="translated">Exporter::Heavy-Exporter guts</target>
        </trans-unit>
        <trans-unit id="5212c627287d01ea51f61b228d900e6e7aa1a003" translate="yes" xml:space="preserve">
          <source>Exporting Without Inheriting from Exporter</source>
          <target state="translated">出口不从出口商那里继承</target>
        </trans-unit>
        <trans-unit id="b76a470ae357815e917068bbc5728a8478edaac1" translate="yes" xml:space="preserve">
          <source>Exporting Without Using Exporter's import Method</source>
          <target state="translated">不使用出口商的进口方法出口。</target>
        </trans-unit>
        <trans-unit id="1b7c31e16f36f853e2c6c57c0f5c8d014a8558d8" translate="yes" xml:space="preserve">
          <source>Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance that are too hard to track and to fix. Trust me: they are not worth it.</source>
          <target state="translated">导出变量不是一个好主意。它们可能会在引擎盖下发生变化,在远处引发可怕的影响,而这些影响太难跟踪和修复了。相信我:它们不值得。</target>
        </trans-unit>
        <trans-unit id="071e64c7e24a9d0c7e9058c9548f279b0db62c55" translate="yes" xml:space="preserve">
          <source>Exporting your new function</source>
          <target state="translated">导出您的新功能</target>
        </trans-unit>
        <trans-unit id="0e16537914a0163e01ecd7e0945bc56c50eb3849" translate="yes" xml:space="preserve">
          <source>Exports</source>
          <target state="translated">Exports</target>
        </trans-unit>
        <trans-unit id="78a2a7642c638f47b6ed7502eab44ca9b2bee2ca" translate="yes" xml:space="preserve">
          <source>Exports all the test functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf2ed8b53d5a014c877f2053b8b2d2b823e37e6" translate="yes" xml:space="preserve">
          <source>Exports in this section are not commonly needed. These all have the 'test2_' prefix to help ensure they stand out. You should look at the &lt;a href=&quot;#MAIN-API-EXPORTS&quot;&gt;&quot;MAIN API EXPORTS&quot;&lt;/a&gt; section before looking here. This section is one where &quot;Great power comes with great responsibility&quot;. It is possible to break things badly if you are not careful with these.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a78d15b2b917cc03293d31b108e05ce4d52026f" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use &lt;code&gt;@EXPORT_OK&lt;/code&gt; in preference to &lt;code&gt;@EXPORT&lt;/code&gt; and avoid short or common symbol names to reduce the risk of name clashes.</source>
          <target state="translated">导出会污染模块用户的名称空间。如果必须导出，请尝试使用 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 优先于 &lt;code&gt;@EXPORT&lt;/code&gt; ,并避免使用简短或通用符号名称，以减少名称冲突的风险。</target>
        </trans-unit>
        <trans-unit id="19680f4d8bc35c089321258ed1726974e515bb01" translate="yes" xml:space="preserve">
          <source>Exports pollute the namespace of the module user. If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common names to reduce the risk of name clashes.</source>
          <target state="translated">导出会污染模块用户的命名空间。如果您必须导出,请尽量使用 @EXPORT_OK 而不是 @EXPORT,并且避免使用较短或常见的名称,以减少名称冲突的风险。</target>
        </trans-unit>
        <trans-unit id="991118c2b6b3c16c0bc4bf38a36f6ec2aa05622c" translate="yes" xml:space="preserve">
          <source>Expose the individual bytes of characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b67fdeebc6a730537832b31cf1e590434ac7ad11" translate="yes" xml:space="preserve">
          <source>Exposes the POSIX function getcwd(3) or re-implements it if it's not available.</source>
          <target state="translated">公开 POSIX 函数 getcwd(3)或重新实现它,如果它不可用。</target>
        </trans-unit>
        <trans-unit id="30e13c3f2f4b6a85ea0443e9079e6877bde86d9e" translate="yes" xml:space="preserve">
          <source>Expressing the command as a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848bbebe9b69edd539cf121a71439bdfe81b397c" translate="yes" xml:space="preserve">
          <source>Expressions like this are useful in conditionals:</source>
          <target state="translated">这样的表达式在条件式中很有用。</target>
        </trans-unit>
        <trans-unit id="130f8cc58ed68e3a1fe427428482f60dc97e9301" translate="yes" xml:space="preserve">
          <source>Ext/Ension</source>
          <target state="translated">Ext/Ension</target>
        </trans-unit>
        <trans-unit id="ae4a822ac4b76bc07804416206c3daa608046771" translate="yes" xml:space="preserve">
          <source>ExtUtils</source>
          <target state="translated">ExtUtils</target>
        </trans-unit>
        <trans-unit id="8adb87135c238343780172ae48188681cf370acf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder</source>
          <target state="translated">ExtUtils::CBuilder</target>
        </trans-unit>
        <trans-unit id="0dd29c2a17cfd9dc6e5beb4505e91940187682bf" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder - Compile and link C code for Perl modules</source>
          <target state="translated">ExtUtils::CBuilder-为Perl模块编译和链接C代码。</target>
        </trans-unit>
        <trans-unit id="de9e9dbbe64dfc1f06076f5b598c40c5b97a4f07" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder is maintained as part of the Perl 5 core. Please submit any bug reports via the</source>
          <target state="translated">ExtUtils::CBuilder是作为Perl 5核心的一部分进行维护的。请通过</target>
        </trans-unit>
        <trans-unit id="6d9aae08362d79c65318eda6627f0ab746bbee95" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows</target>
        </trans-unit>
        <trans-unit id="ec8f2943e4d10ff3dad921becf4700a9c605fc5f" translate="yes" xml:space="preserve">
          <source>ExtUtils::CBuilder::Platform::Windows - Builder class for Windows platforms</source>
          <target state="translated">ExtUtils::CBuilder::Platform::Windows-Windows平台的生成器类。</target>
        </trans-unit>
        <trans-unit id="0f5f8c4e317cb9e14dbc99f8c4725e7101d063e0" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command</source>
          <target state="translated">ExtUtils::Command</target>
        </trans-unit>
        <trans-unit id="13685feaf020782447b9941746d4b335bddf0883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command - utilities to replace common UNIX commands in Makefiles etc.</source>
          <target state="translated">ExtUtils::Command-用于替换Makefiles等文件中常见UNIX命令的工具。</target>
        </trans-unit>
        <trans-unit id="1e0e65de42d77495693723755508f19700283291" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM</source>
          <target state="translated">ExtUtils::Command::MM</target>
        </trans-unit>
        <trans-unit id="57baedd89a659e1e0ecff540830bcf69ebde4c0c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM - Commands for the MM's to use in Makefiles</source>
          <target state="translated">ExtUtils::Command::MM-在Makefiles中使用的MM的命令。</target>
        </trans-unit>
        <trans-unit id="e8520d9305bb1b6b30673860c2a9fc7e0bb43af7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Command::MM encapsulates code which would otherwise have to be done with large &quot;one&quot; liners.</source>
          <target state="translated">ExtUtils::Command::MM封装了原本需要用大的 &quot;一 &quot;行来完成的代码。</target>
        </trans-unit>
        <trans-unit id="01aca525aa3b0d3504eab62f629ea7ae316a1df9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant</target>
        </trans-unit>
        <trans-unit id="eb53ab587c5df3bac6d41d873980d0a80f5c155a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant - generate XS code to import C header constants</source>
          <target state="translated">ExtUtils::Constant-生成XS代码来导入C头常量。</target>
        </trans-unit>
        <trans-unit id="2bfb67938397e6eb325051359a5d323e79a220d8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant facilitates generating C and XS wrapper code to allow perl modules to AUTOLOAD constants defined in C library header files. It is principally used by the &lt;code&gt;h2xs&lt;/code&gt; utility, on which this code is based. It doesn't contain the routines to scan header files to extract these constants.</source>
          <target state="translated">ExtUtils :: Constant有助于生成C和XS包装器代码，以允许perl模块自动加载C库头文件中定义的常量。此代码主要由 &lt;code&gt;h2xs&lt;/code&gt; 实用程序使用。它不包含扫描头文件以提取这些常量的例程。</target>
        </trans-unit>
        <trans-unit id="66069119c4474ce5db2c00c2fc5c7ebe74e509d3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base</source>
          <target state="translated">ExtUtils::Constant::Base</target>
        </trans-unit>
        <trans-unit id="a5a92bf27fd8a70fb8d0d04675721591091d31a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant::Base-ExtUtils::Constant对象的基类。</target>
        </trans-unit>
        <trans-unit id="37d28c0e096d851a074af795694f3e4ed605e4fe" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base exports no subroutines. The following methods are available</source>
          <target state="translated">ExtUtils::Constant::Base不输出子程序。以下是可用的方法</target>
        </trans-unit>
        <trans-unit id="cc85f41228edcbb25fda849b24e857773037224e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the constant() subroutine found in many XS modules.</source>
          <target state="translated">ExtUtils::Constant::Base提供了一个基础的实现方法,用来生成C代码,通过命名字符串给出快速的常量值查询。目前主要使用ExtUtils::Constant::XS,它为许多XS模块中的constant()子程序生成查找代码。</target>
        </trans-unit>
        <trans-unit id="01123cf69ee0503631a353722ce7083ea5078bc4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils</source>
          <target state="translated">ExtUtils::Constant::Utils</target>
        </trans-unit>
        <trans-unit id="eb7021c674be1dbbac0f5d2f00a2ee805361885c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils - helper functions for ExtUtils::Constant</source>
          <target state="translated">ExtUtils::Constant::Utils-ExtUtils::Constant的辅助函数。</target>
        </trans-unit>
        <trans-unit id="88fa01ca987de7b887a3c79f4e501e05801215f9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::Utils packages up utility subroutines used by ExtUtils::Constant, ExtUtils::Constant::Base and derived classes. All its functions are explicitly exportable.</source>
          <target state="translated">ExtUtils::Constant::Utils将ExtUtils::Constant,ExtUtils::Constant::Base和派生类使用的实用子程序打包。它的所有功能都是可以明确导出的。</target>
        </trans-unit>
        <trans-unit id="691e427f212f20f1a4e97a292f83b191a9330664" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS</source>
          <target state="translated">ExtUtils::Constant::XS</target>
        </trans-unit>
        <trans-unit id="7b304383401bf8b504f1c4575e883635046c55a8" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS - generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Constant::XS-为XS模块的常量生成C代码。</target>
        </trans-unit>
        <trans-unit id="a134fe12059f0bb9cd89ef6f92c5ae2e9810c57e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Constant::XS overrides ExtUtils::Constant::Base to generate C code for XS modules' constants.</source>
          <target state="translated">ExtUtils::Constant::XS覆盖了ExtUtils::Constant::Base,为XS模块的常量生成C代码。</target>
        </trans-unit>
        <trans-unit id="5fb8ee5bc96080dc35b8c113dc4ab7e19f1f7f22" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed</source>
          <target state="translated">ExtUtils::Embed</target>
        </trans-unit>
        <trans-unit id="939f083947624f21f9b736c75a4f6438e18f6655" translate="yes" xml:space="preserve">
          <source>ExtUtils::Embed - Utilities for embedding Perl in C/C++ applications</source>
          <target state="translated">ExtUtils::Embed-用于在C/C++应用程序中嵌入Perl的实用工具。</target>
        </trans-unit>
        <trans-unit id="66d1280ba3865302835b81bea028e8fe495e808d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install</source>
          <target state="translated">ExtUtils::Install</target>
        </trans-unit>
        <trans-unit id="e1917ee01b8bd661c56eb9ac792b975c3df2f5a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::Install - install files from here to there</source>
          <target state="translated">ExtUtils::Install-将文件从这里安装到那里。</target>
        </trans-unit>
        <trans-unit id="b703bea959a592e6e8e04477edfce4ad8bd309c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed</source>
          <target state="translated">ExtUtils::Installed</target>
        </trans-unit>
        <trans-unit id="3984de1657750a05991b5ea96245f59313691aaf" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed - Inventory management of installed modules</source>
          <target state="translated">ExtUtils::Installed-安装模块的清单管理。</target>
        </trans-unit>
        <trans-unit id="b02212efafd95acf708fbde6c1ea9a18a4ebc3b3" translate="yes" xml:space="preserve">
          <source>ExtUtils::Installed provides a standard way to find out what core and module files have been installed. It uses the information stored in .packlist files created during installation to provide this information. In addition it provides facilities to classify the installed files and to extract directory information from the .packlist files.</source>
          <target state="translated">ExtUtils::Installed 提供了一个标准的方法来查找已经安装了哪些核心和模块文件。它使用安装过程中创建的.packlist文件中存储的信息来提供这些信息。此外,它还提供了对安装的文件进行分类和从.packlist文件中提取目录信息的功能。</target>
        </trans-unit>
        <trans-unit id="42c25bbd2df5e46fa299efe94a0a5ec1d56bc561" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist</source>
          <target state="translated">ExtUtils::Liblist</target>
        </trans-unit>
        <trans-unit id="1c444f69f6d944829dae0bfb3cb19187e41f4b3d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Liblist - determine libraries to use and how to use them</source>
          <target state="translated">ExtUtils::Liblist-确定要使用的库以及如何使用它们。</target>
        </trans-unit>
        <trans-unit id="d6d8f29d2d6c812d8608b7eecff6b50d5b23bb32" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM</source>
          <target state="translated">ExtUtils::MM</target>
        </trans-unit>
        <trans-unit id="d9944867a30cc09571228059a446b44834907174" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM - OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">ExtUtils::MM-操作系统调整后的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="8e1a56d427b6cdce97fbab94a739a6369e0e5125" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; which automatically chooses the appropriate OS specific subclass for you (ie. &lt;a href=&quot;ExtUtils::MM_Unix&quot;&gt;ExtUtils::MM_Unix&lt;/a&gt;, etc...).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5ed850a839f5d75d47dcc96cd13b3666aca25d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM is a subclass of ExtUtils::MakeMaker which automatically chooses the appropriate OS specific subclass for you (ie. ExtUils::MM_Unix, etc...).</source>
          <target state="translated">ExtUtils::MM是ExtUtils::MakeMaker的一个子类,它能自动为你选择合适的操作系统特定子类(即ExtUils::MM_Unix等...)。</target>
        </trans-unit>
        <trans-unit id="f20ad18d2cdfe05b996f3064f2baa9077e90198e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX</source>
          <target state="translated">ExtUtils::MM_AIX</target>
        </trans-unit>
        <trans-unit id="e2c65ab01c23a32d98e8b4e3a0d77782b9a1b0c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_AIX - AIX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_AIX-ExtUtils::MM_Unix的AIX子类。</target>
        </trans-unit>
        <trans-unit id="82f6a9462d97b2eeba15d489f4c29f1201ca8139" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any</source>
          <target state="translated">ExtUtils::MM_Any</target>
        </trans-unit>
        <trans-unit id="28e6e24f25939bb77bd8b0e8b5c1b5591ab0a63a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any - Platform-agnostic MM methods</source>
          <target state="translated">ExtUtils::MM_Any-平台无关的MM方法。</target>
        </trans-unit>
        <trans-unit id="f1beb9206779be8013b3e4a60d1eb3c845414417" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;. The methods noted here override File::Spec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4017c7fd6c6b1a7382d3693845441ec57607400" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a subclass of File::Spec. The methods noted here override File::Spec.</source>
          <target state="translated">ExtUtils::MM_Any 是 File::Spec 的一个子类。这里提到的方法覆盖了File::Spec。</target>
        </trans-unit>
        <trans-unit id="a07e79b177dfcc3d173d4e96906fb19054e96233" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Any is a superclass for the ExtUtils::MM_* set of modules. It contains methods which are either inherently cross-platform or are written in a cross-platform manner.</source>
          <target state="translated">ExtUtils::MM_Any是ExtUtils::MM_*模块集的一个超级类。它包含的方法要么是固有的跨平台,要么是以跨平台的方式编写的。</target>
        </trans-unit>
        <trans-unit id="01e79daa480a30aec67c1c77b38113a2fa75acb1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS</source>
          <target state="translated">ExtUtils::MM_BeOS</target>
        </trans-unit>
        <trans-unit id="ff7047e18f778da31bd8596ebbae3ca3c16815a1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_BeOS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_BeOS-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="32f54e4d1cdff9fa869169ffbe48a1f8a6442f8d" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin</source>
          <target state="translated">ExtUtils::MM_Cygwin</target>
        </trans-unit>
        <trans-unit id="26a23a31e9ae337b30e976cee9bfe04ee8714af5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Cygwin - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Cygwin-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="83b34173b4084fe7b0f1b8e7080f5e44721c1652" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS</source>
          <target state="translated">ExtUtils::MM_DOS</target>
        </trans-unit>
        <trans-unit id="ce09d2a78829bfe3f6e4a91c1fda8bf736e91cd1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_DOS - DOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_DOS-ExtUtils::MM_Unix的DOS子类。</target>
        </trans-unit>
        <trans-unit id="95c4b06cdebc87ea8f0b490c31911c2d3a160085" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin</source>
          <target state="translated">ExtUtils::MM_Darwin</target>
        </trans-unit>
        <trans-unit id="ce3594f7f3d66367be8d04f9a60ed3e5b23e61ae" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Darwin - special behaviors for OS X</source>
          <target state="translated">ExtUtils::MM_Darwin-OS X的特殊行为。</target>
        </trans-unit>
        <trans-unit id="a35d39f1996d06db96e0eb3bc7581c9d1bb37583" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS</source>
          <target state="translated">ExtUtils::MM_MacOS</target>
        </trans-unit>
        <trans-unit id="a75ee91bd51d22344f5f01dea69463550d1b77f8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_MacOS - once produced Makefiles for MacOS Classic</source>
          <target state="translated">ExtUtils::MM_MacOS-曾经为MacOS Classic制作过Makefiles。</target>
        </trans-unit>
        <trans-unit id="05b1c57f6a3a8d6a042ca608dff6a349761c8182" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5</source>
          <target state="translated">ExtUtils::MM_NW5</target>
        </trans-unit>
        <trans-unit id="c8c1829d86b2c857e5650f081f857c1eaf86f3e8" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_NW5 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_NW5-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="e0950761db3807deb0218887807e7b7bff1a358b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2</source>
          <target state="translated">ExtUtils::MM_OS2</target>
        </trans-unit>
        <trans-unit id="9c18e1ac0450cd34c6460b2c5c7a1220fbf998b2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_OS2 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_OS2-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="9754f9a33576ee28f994ec3ff4f6032e292d0ec1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX</source>
          <target state="translated">ExtUtils::MM_QNX</target>
        </trans-unit>
        <trans-unit id="5c959f779c55270f8bb8da4da99da8c51701f934" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_QNX - QNX specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_QNX-ExtUtils::MM_Unix的QNX子类。</target>
        </trans-unit>
        <trans-unit id="d9cffc939c33c81ae491e577ff7a0f67f32115db" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN</source>
          <target state="translated">ExtUtils::MM_UWIN</target>
        </trans-unit>
        <trans-unit id="392dbc1b30426cf86e8bbd0156b4353d7aae576c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_UWIN - U/WIN specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_UWIN-ExtUtils::MM_Unix的U/WIN子类。</target>
        </trans-unit>
        <trans-unit id="6b69e4024267a17dfff2456177fce03e32e171de" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_Unix</target>
        </trans-unit>
        <trans-unit id="c828df98d7850f84de0cbb81d4e4596caa76f94a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Unix-ExtUtils::MakeMaker使用的方法。</target>
        </trans-unit>
        <trans-unit id="2f00201cd4f3a6fbb76802bb39ac7a005b8f24e3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Unix. This is a temporary solution.</source>
          <target state="translated">ExtUtils::MM_Unix。这是一个临时的解决方案。</target>
        </trans-unit>
        <trans-unit id="5bbe314072fa79cbbe64e27d3c034cb7ecbc2df1" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS</source>
          <target state="translated">ExtUtils::MM_VMS</target>
        </trans-unit>
        <trans-unit id="c328e4aa3661448cfc600baf641ce3b368446553" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_VMS-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="cbf6a31d4b30a3697a77d880951a740af6fe002e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS</source>
          <target state="translated">ExtUtils::MM_VOS</target>
        </trans-unit>
        <trans-unit id="248c1927adaa54c68b53917bcd12ca60bc242150" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_VOS - VOS specific subclass of ExtUtils::MM_Unix</source>
          <target state="translated">ExtUtils::MM_VOS-ExtUtils::MM_Unix的VOS子类。</target>
        </trans-unit>
        <trans-unit id="01b2b6f5d2a1e4c4ed0f2cb32046a9a5d606a04c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32</source>
          <target state="translated">ExtUtils::MM_Win32</target>
        </trans-unit>
        <trans-unit id="31634682156707a3a92d7105825df2529eb4f747" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MM_Win32-在ExtUtils::MakeMaker中覆盖UN*X行为的方法。</target>
        </trans-unit>
        <trans-unit id="dd4f189a6328e4d51489c48940b1b07f49808b7b" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95</source>
          <target state="translated">ExtUtils::MM_Win95</target>
        </trans-unit>
        <trans-unit id="ef84388c3c22f4aa37ab1ec6dcdd24ddaa801da4" translate="yes" xml:space="preserve">
          <source>ExtUtils::MM_Win95 - method to customize MakeMaker for Win9X</source>
          <target state="translated">ExtUtils::MM_Win95-为Win9X定制MakeMaker的方法。</target>
        </trans-unit>
        <trans-unit id="2eeeaab10b029e1825f471249451e612175f476c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY</source>
          <target state="translated">ExtUtils::MY</target>
        </trans-unit>
        <trans-unit id="a29677c3a7812ab9e27275d7d315711580baa3c5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY - ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">ExtUtils::MY-用于自定义的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="8c6225988b72e5033c42e6301547dce425e25ee5" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of &lt;a href=&quot;ExtUtils::MM&quot;&gt;ExtUtils::MM&lt;/a&gt;. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="077ce2e66cf34d26fc93548b5aa4b0a365551ad3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY is a subclass of ExtUtils::MM. Its provided in your Makefile.PL for you to add and override MakeMaker functionality.</source>
          <target state="translated">ExtUtils::MY是ExtUtils::MM的一个子类。它提供在你的Makefile.PL中,让你添加和覆盖MakeMaker功能。</target>
        </trans-unit>
        <trans-unit id="a8d99fc9d222321dd1dd6e7c9d39239d74c92fb3" translate="yes" xml:space="preserve">
          <source>ExtUtils::MY might turn out to be a temporary solution, but MY won't go away.</source>
          <target state="translated">ExtUtils::MY可能会变成一个暂时的解决方案,但MY不会消失。</target>
        </trans-unit>
        <trans-unit id="6da8b7232afb53dfdcd9b1c4dde891781d5ce223" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker</target>
        </trans-unit>
        <trans-unit id="b8052cbade448d159716f320bb8b7066c1c35927" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker (EUMM) is object oriented. Each directory below the current directory that contains a Makefile.PL is treated as a separate object. This makes it possible to write an unlimited number of Makefiles with a single invocation of WriteMakefile().</source>
          <target state="translated">ExtUtils::MakeMaker(EUMM)是面向对象的。当前目录下的每个包含Makefile.PL的目录都被视为一个单独的对象。这使得它可以通过调用WriteMakefile()来编写无限数量的Makefile。</target>
        </trans-unit>
        <trans-unit id="6ea38d2404e8bb2fe915619afea85f24fef8c2cc" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker - Create a module Makefile</source>
          <target state="translated">ExtUtils::MakeMaker-创建一个模块Makefile。</target>
        </trans-unit>
        <trans-unit id="e6df2289ed559a450ea26d00c0d0e4cee5508740" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker subclass for customization</source>
          <target state="translated">用于定制的ExtUtils::MakeMaker子类。</target>
        </trans-unit>
        <trans-unit id="c60c158c602a516f81a6ae9bca65b474a071fe74" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config</source>
          <target state="translated">ExtUtils::MakeMaker::Config</target>
        </trans-unit>
        <trans-unit id="d3014ef697f5ada430bc56427a7b9caae4e6e02c" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Config - Wrapper around Config.pm</source>
          <target state="translated">ExtUtils::MakeMaker::Config-围绕Config.pm的封装器。</target>
        </trans-unit>
        <trans-unit id="9ccd57b3ecc86c99f88666a4cbfa65fcc3d9511f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ</target>
        </trans-unit>
        <trans-unit id="30461ff8ef34cae5ca5dc88e0a98e8273138112a" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::FAQ - Frequently Asked Questions About MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker::FAQ-关于MakeMaker的常见问题。</target>
        </trans-unit>
        <trans-unit id="51e7eb76f593803326b81c0b7eddf02ecc2dca1f" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale</source>
          <target state="translated">ExtUtils::MakeMaker::Locale</target>
        </trans-unit>
        <trans-unit id="95b89cbe7015202586c4481ef682b645c3e89ac2" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Locale - bundled Encode::Locale</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ea2c313a203d7ca441511bcd463e56db95e2e" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial</target>
        </trans-unit>
        <trans-unit id="a40c04994e7a37e13af27331a991a5aa646c9b73" translate="yes" xml:space="preserve">
          <source>ExtUtils::MakeMaker::Tutorial - Writing a module with MakeMaker</source>
          <target state="translated">ExtUtils::MakeMaker::Tutorial-使用MakeMaker编写一个模块。</target>
        </trans-unit>
        <trans-unit id="b357eaa10f6891f76e970ffb5f2bf93f495e4a17" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest</source>
          <target state="translated">ExtUtils::Manifest</target>
        </trans-unit>
        <trans-unit id="c2882ccdd5737a1b3d2f4dc3d31014e58dd46653" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - Utilities to write and check a MANIFEST file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3226afa87ddca4ba7171d22b9f2b78d098b58f76" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest - utilities to write and check a MANIFEST file</source>
          <target state="translated">ExtUtils::Manifest-用于编写和检查MANIFEST文件的实用工具。</target>
        </trans-unit>
        <trans-unit id="5668766f97bcd05c6bdb7c965133d9727537b625" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request</source>
          <target state="translated">ExtUtils::Manifest默认不导出任何函数。以下是根据要求导出的函数</target>
        </trans-unit>
        <trans-unit id="bdbe036be435e29a3c3c98d79b72ee067d6d642d" translate="yes" xml:space="preserve">
          <source>ExtUtils::Manifest exports no functions by default. The following are exported on request:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d683dc5b10b650f60d4d9d340eeb5154c9725c7" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl</source>
          <target state="translated">ExtUtils::Miniperl</target>
        </trans-unit>
        <trans-unit id="a62bb061ae9acdfb750b378b1f62a97de2f7165a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for miniperlmain.c and perlmain.c</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc3f091d177ebdf88e70a7d90d1a0e96a9ebda2" translate="yes" xml:space="preserve">
          <source>ExtUtils::Miniperl - write the C code for perlmain.c</source>
          <target state="translated">ExtUtils::Miniperl-为perlmain.c编写C代码。</target>
        </trans-unit>
        <trans-unit id="1c32c7f84e8dc881e25db6f6d50706131d6d8758" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap</source>
          <target state="translated">ExtUtils::Mkbootstrap</target>
        </trans-unit>
        <trans-unit id="bbfa5e60d2823fa64c959ef9034364b18eddc3e9" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mkbootstrap - make a bootstrap file for use by DynaLoader</source>
          <target state="translated">ExtUtils::Mkbootstrap-制作一个引导文件供DynaLoader使用。</target>
        </trans-unit>
        <trans-unit id="6719b923f8e283bd552384bd5af81cadfef85883" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists</source>
          <target state="translated">ExtUtils::Mksymlists</target>
        </trans-unit>
        <trans-unit id="15ab523f4d3c60af2d551125aa18471a39d07e7c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Mksymlists - write linker options files for dynamic extension</source>
          <target state="translated">ExtUtils::Mksymlists-为动态扩展写链接器选项文件。</target>
        </trans-unit>
        <trans-unit id="dac17ac78f3539cbb386b1e56ee2b529662e80e5" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist</source>
          <target state="translated">ExtUtils::Packlist</target>
        </trans-unit>
        <trans-unit id="2fd0b32af3911843b6577751529d4515df509939" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist - manage .packlist files</source>
          <target state="translated">ExtUtils::Packlist-管理.packlist文件。</target>
        </trans-unit>
        <trans-unit id="b6cb6e0433e264b8d9ae4674f7b9ee20c7cc9a0e" translate="yes" xml:space="preserve">
          <source>ExtUtils::Packlist provides a standard way to manage .packlist files. Functions are provided to read and write .packlist files. The original .packlist format is a simple list of absolute pathnames, one per line. In addition, this package supports an extended format, where as well as a filename each line may contain a list of attributes in the form of a space separated list of key=value pairs. This is used by the installperl script to differentiate between files and links, for example.</source>
          <target state="translated">ExtUtils::Packlist提供了一种管理.packlist文件的标准方法。提供了读取和写入.packlist文件的函数。原始的.packlist格式是一个简单的绝对路径名列表,每行一个。此外,这个软件包支持扩展的格式,每行除了文件名之外,还可以包含一个属性列表,以空格分隔的key=value对的形式。例如,installperl 脚本就用它来区分文件和链接。</target>
        </trans-unit>
        <trans-unit id="c27f6826e3e72b1481e238cd590b927b9a8c7674" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS</source>
          <target state="translated">ExtUtils::ParseXS</target>
        </trans-unit>
        <trans-unit id="a0bc42ea6560aea10d0d6a20cba29d9f0d9456c6" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS - converts Perl XS code into C code</source>
          <target state="translated">ExtUtils::ParseXS-将Perl XS代码转换为C代码。</target>
        </trans-unit>
        <trans-unit id="03159689beb1e83556a0d792cc8509ee6422dca5" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants</source>
          <target state="translated">ExtUtils::ParseXS::Constants</target>
        </trans-unit>
        <trans-unit id="cf5795919350a424f2fdddb099257f73945e1a05" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Constants - Initialization values for some globals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34afc1a15abc59a30f0d297ced64f7e5d7089b18" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval</source>
          <target state="translated">ExtUtils::ParseXS::Eval</target>
        </trans-unit>
        <trans-unit id="b114f3881b5796ad889d6328dec9b5e233d60f40" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Eval - Clean package to evaluate code in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd75ce4683a9aa22ba6c700ca353d47d601b2384" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities</source>
          <target state="translated">ExtUtils::ParseXS::Utilities</target>
        </trans-unit>
        <trans-unit id="92bd9c932412ce4f8422b75c6801374ed24acdf2" translate="yes" xml:space="preserve">
          <source>ExtUtils::ParseXS::Utilities - Subroutines used with ExtUtils::ParseXS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244cbf4be92c60aff1ddbf35e6ab53db17abecdd" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps</source>
          <target state="translated">ExtUtils::Typemaps</target>
        </trans-unit>
        <trans-unit id="d3f0982ef48a7ff5c4bec28af01b2fc9c1b9e324" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps - Read/Write/Modify Perl/XS typemap files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f91cda6d284fa20124d5451bc24b51143532bb" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd</source>
          <target state="translated">ExtUtils::Typemaps::Cmd</target>
        </trans-unit>
        <trans-unit id="795fa4eef7e8ecb9427bfc09a6b1dcc43d73ee93" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Cmd - Quick commands for handling typemaps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9969ccb534d5e151d4ccb9e73ab988320ed4b6" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap</source>
          <target state="translated">ExtUtils::Typemaps::InputMap</target>
        </trans-unit>
        <trans-unit id="c325c829d365d7d7a6812090290f7b83b3596b1c" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::InputMap - Entry in the INPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237c9b6dbebb9b4ed396f0dce6a67fb3af72515a" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap</source>
          <target state="translated">ExtUtils::Typemaps::OutputMap</target>
        </trans-unit>
        <trans-unit id="661bb31eef11ca983e8d0917113f95b3a60d7add" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::OutputMap - Entry in the OUTPUT section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feaee53a536421bc2b64881bb22fc287b99e2b4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type</source>
          <target state="translated">ExtUtils::Typemaps::Type</target>
        </trans-unit>
        <trans-unit id="42aba54068b70ea208aa1cd601ae498fb974dba4" translate="yes" xml:space="preserve">
          <source>ExtUtils::Typemaps::Type - Entry in the TYPEMAP section of a typemap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973e953fd629b20b4ca87588491035c2a7556141" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet</source>
          <target state="translated">ExtUtils::XSSymSet</target>
        </trans-unit>
        <trans-unit id="f716c096c97d144856a93624d2a5d5bd094c5cae" translate="yes" xml:space="preserve">
          <source>ExtUtils::XSSymSet - keep sets of symbol names palatable to the VMS linker</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01cb2601da9ca9e6f049c24d0b16efdb7998074" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib</source>
          <target state="translated">ExtUtils::testlib</target>
        </trans-unit>
        <trans-unit id="c819a99ea2471502c8a0521252e569cacdf6e150" translate="yes" xml:space="preserve">
          <source>ExtUtils::testlib - add blib/* directories to @INC</source>
          <target state="translated">ExtUtils::testlib-将blib/*目录添加到@INC中。</target>
        </trans-unit>
        <trans-unit id="1a8525beca2f4f9e103dd4931ef378f407141d6e" translate="yes" xml:space="preserve">
          <source>Extend File Glob to Allow Input and Output Files</source>
          <target state="translated">扩展文件Glob,允许输入和输出文件。</target>
        </trans-unit>
        <trans-unit id="82d26601ba012fb977fae11b9393fa91fb289790" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/x and /xx&quot;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fab77626f5cddcb8bbb657382d4af81d5cdf9048" translate="yes" xml:space="preserve">
          <source>Extend your pattern's legibility by permitting whitespace and comments. Details in &lt;a href=&quot;#%2fx&quot;&gt;/x&lt;/a&gt;</source>
          <target state="translated">通过允许空格和注释来扩展图案的可读性。&lt;a href=&quot;#%2fx&quot;&gt;/ x中的&lt;/a&gt;详细信息</target>
        </trans-unit>
        <trans-unit id="1d44d230ea6fe0935f3b1482cff787c6266b3d3b" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;expect&lt;/code&gt; . This is a hash reference with four allowed keys, &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;reuse&lt;/code&gt; , and &lt;code&gt;talk&lt;/code&gt; .</source>
          <target state="translated">扩展 &lt;code&gt;expect&lt;/code&gt; 。这是具有四个允许的键（ &lt;code&gt;mode&lt;/code&gt; ， &lt;code&gt;timeout&lt;/code&gt; ， &lt;code&gt;reuse&lt;/code&gt; 和 &lt;code&gt;talk&lt;/code&gt; ）的哈希引用。</target>
        </trans-unit>
        <trans-unit id="efc98640815d67fe8a62500e0c5368b07039dddc" translate="yes" xml:space="preserve">
          <source>Extended Bracketed Character Classes</source>
          <target state="translated">扩展括号内的字符类</target>
        </trans-unit>
        <trans-unit id="08ad66702e505f4acfeb7ef02a28aef2a444692f" translate="yes" xml:space="preserve">
          <source>Extended Grapheme Clusters (Logical characters)</source>
          <target state="translated">扩展字词组(逻辑字符)</target>
        </trans-unit>
        <trans-unit id="b408f65a0dc6251545ba8a1cae00a09cef180586" translate="yes" xml:space="preserve">
          <source>Extended Patterns</source>
          <target state="translated">扩展模式</target>
        </trans-unit>
        <trans-unit id="5acbb8b9cc41fceabb939a9490161468292c9ddc" translate="yes" xml:space="preserve">
          <source>Extended Unix Character. See ISO-2022.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57638586a902beff6d532df64e0c7307238ec6d1" translate="yes" xml:space="preserve">
          <source>Extended description and discussion of the program or functions, or the body of the documentation for man pages that document something else. If particularly long, it's a good idea to break this up into subsections &lt;code&gt;=head2&lt;/code&gt; directives like:</source>
          <target state="translated">程序或功能的扩展描述和讨论，或用于记录其他内容的手册页的文档正文。如果特别长，最好将其分解为 &lt;code&gt;=head2&lt;/code&gt; 指令小节，例如：</target>
        </trans-unit>
        <trans-unit id="e1eee637af0775263c15116e6a9a092f2dd1ed43" translate="yes" xml:space="preserve">
          <source>Extended integer, Perl style. This can be either an optional leading plus or minus sign, followed by a sequence of digits, or an octal string (a zero, optionally followed by '0', '1', .. '7'), or a hexadecimal string (&lt;code&gt;0x&lt;/code&gt; followed by '0' .. '9', 'a' .. 'f', case insensitive), or a binary string (&lt;code&gt;0b&lt;/code&gt; followed by a series of '0' and '1').</source>
          <target state="translated">扩展整数，Perl样式。这可以是一个可选的前导加号或减号，后跟一个数字序列，或者一个八进制字符串（零，可以选择后面跟着&amp;ldquo; 0&amp;rdquo;，&amp;ldquo; 1&amp;rdquo;，..&amp;ldquo; 7&amp;rdquo;）或十六进制字符串（ &lt;code&gt;0x&lt;/code&gt; ,后跟&amp;ldquo; 0&amp;rdquo; ..&amp;ldquo; 9&amp;rdquo;，&amp;ldquo; a&amp;rdquo; ..&amp;ldquo; f&amp;rdquo;，不区分大小写）或二进制字符串（ &lt;code&gt;0b&lt;/code&gt; ,后跟一系列&amp;ldquo; 0&amp;rdquo;和&amp;ldquo; 1&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="7f8a27621bd1b83106ef3b26b5852eb1064f0fc5" translate="yes" xml:space="preserve">
          <source>Extended processing of command line options</source>
          <target state="translated">扩展处理命令行选项</target>
        </trans-unit>
        <trans-unit id="5db438e4dc97c2c680eb06228229b5484c1bdab3" translate="yes" xml:space="preserve">
          <source>Extending and Embedding Test::More</source>
          <target state="translated">扩展和嵌入Test::More</target>
        </trans-unit>
        <trans-unit id="8093cc064296db81eb0f5514264d7ee6d955b145" translate="yes" xml:space="preserve">
          <source>Extending it to csh patterns is left as an exercise to the reader.</source>
          <target state="translated">把它扩展到csh模式,留给读者去练习。</target>
        </trans-unit>
        <trans-unit id="4e50bd25f128e6a96c634dc99854b32ea96ab716" translate="yes" xml:space="preserve">
          <source>Extending your Extension</source>
          <target state="translated">扩展您的扩展</target>
        </trans-unit>
        <trans-unit id="4f8331dd312ba43f266e8a83a2d73cbbbec52b3f" translate="yes" xml:space="preserve">
          <source>Extension Layers</source>
          <target state="translated">延伸层</target>
        </trans-unit>
        <trans-unit id="7e80c98508d4f62822b0432554091a536a41d48e" translate="yes" xml:space="preserve">
          <source>Extension Modules</source>
          <target state="translated">扩展模块</target>
        </trans-unit>
        <trans-unit id="bd951e4e9e05b88a206b50063022ae727663d6c9" translate="yes" xml:space="preserve">
          <source>Extension based on</source>
          <target state="translated">在此基础上延长</target>
        </trans-unit>
        <trans-unit id="c6f2131d44d90eead55c47a30930686fccd53dcc" translate="yes" xml:space="preserve">
          <source>Extension based on .h and .c files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67518e197246f71238efe738515b0409050e6007" translate="yes" xml:space="preserve">
          <source>Extension based on _.h_ and _.c_ files</source>
          <target state="translated">基于_.h_和_.c_文件的扩展。</target>
        </trans-unit>
        <trans-unit id="4711cbf045a57cbff83b6f9f271bd795fbb6b53d" translate="yes" xml:space="preserve">
          <source>Extension methods</source>
          <target state="translated">扩展方法</target>
        </trans-unit>
        <trans-unit id="cce4d271f69e77a8f0acdb625f0076753f28069c" translate="yes" xml:space="preserve">
          <source>Extension modules are written in C (or a mix of Perl and C). They are usually dynamically loaded into Perl if and when you need them, but may also be linked in statically. Supported extension modules include Socket, Fcntl, and POSIX.</source>
          <target state="translated">扩展模块是用C语言(或Perl和C语言的混合)编写的。它们通常是在你需要的时候动态加载到Perl中的,但也可能是静态链接的。支持的扩展模块包括Socket、Fcntl和POSIX。</target>
        </trans-unit>
        <trans-unit id="60ffce38ec556078960f77c6601f9f4334d9b141" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5c486c72e2c41ab9d29ece60988b5356674e74f" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of compound statements. These are introduced by a keyword which the extension recognizes, and the syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">扩展模块还可以连接到Perl解析器中，以定义新的复合语句。这些由扩展可以识别的关键字引入，并且关键字后面的语法完全由扩展定义。如果您是实现者，请参见&lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;perlapi中的PL_keyword_plugin&lt;/a&gt;以获取该机制。如果您正在使用这样的模块，请参阅该模块的文档以获取其定义的语法的详细信息。</target>
        </trans-unit>
        <trans-unit id="b6efb310f19bf6564f19089c880a0a0d87286db9" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;&quot;PL_keyword_plugin&quot; in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17db2bf16378aa10db2e67a8c2600f3a25122fec" translate="yes" xml:space="preserve">
          <source>Extension modules can also hook into the Perl parser to define new kinds of keyword-headed expression. These may look like functions, but may also look completely different. The syntax following the keyword is defined entirely by the extension. If you are an implementor, see &lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;PL_keyword_plugin in perlapi&lt;/a&gt; for the mechanism. If you are using such a module, see the module's documentation for details of the syntax that it defines.</source>
          <target state="translated">扩展模块还可以连接到Perl解析器，以定义新的以关键字为标题的表达式。这些可能看起来像函数，但看起来也可能完全不同。关键字后面的语法完全由扩展定义。如果您是实现者，请参见&lt;a href=&quot;perlapi#PL_keyword_plugin&quot;&gt;perlapi中的PL_keyword_plugin&lt;/a&gt;以获取该机制。如果您正在使用这样的模块，请参阅该模块的文档以获取其定义的语法的详细信息。</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="6e975483dac372a5ca9dfd4b8e5e57b37a1180dd" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd
sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; , and anything using quoting.</source>
          <target state="translated">理论上，扩展程序和XS可以由使用免费工具的任何人构建。实际上，由于Acorn平台的用户习惯于使用二进制发行版，因此许多人并不这样做。MakeMaker确实可以运行，但是当前没有可用的make可以处理MakeMaker的makefile。即使应该修正此问题，并且缺乏修正，也将导致makefile规则出现问题，尤其是 &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt; 形式的行以及任何使用引号的问题。</target>
        </trans-unit>
        <trans-unit id="23912b80f63053ec1a446ffda41e3d5c9d541b79" translate="yes" xml:space="preserve">
          <source>Extensions and XS are, in theory, buildable by anyone using free tools. In practice, many don't, as users of the Acorn platform are used to binary distributions. MakeMaker does run, but no available make currently copes with MakeMaker's makefiles; even if and when this should be fixed, the lack of a Unix-like shell will cause problems with makefile rules, especially lines of the form &lt;code&gt;cd sdbm &amp;amp;&amp;amp; make all&lt;/code&gt;, and anything using quoting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8be19ac765682f953ef7dfbb23fec79e7869c76" translate="yes" xml:space="preserve">
          <source>Extensions may be built either using the contents of the perl source directory tree or from the installed perl library. The recommended way is to build extensions after you have run 'make install' on perl itself. You can do that in any directory on your hard disk that is not below the perl source tree. The support for extensions below the ext directory of the perl distribution is only good for the standard extensions that come with perl.</source>
          <target state="translated">扩展可以使用perl源码目录树中的内容或者从安装的perl库中构建。推荐的方法是在perl上运行'make install'之后再建立扩展。你可以在硬盘上任何不在perl源码树下的目录中进行。对perl发行版ext目录以下的扩展的支持只适用于perl自带的标准扩展。</target>
        </trans-unit>
        <trans-unit id="fd1105050ae42d352634f9a22fd2cfbe7c3340ac" translate="yes" xml:space="preserve">
          <source>Extensions.U</source>
          <target state="translated">Extensions.U</target>
        </trans-unit>
        <trans-unit id="8e77bd8de5230e7d94a54f34b54e4ee866ebaf07" translate="yes" xml:space="preserve">
          <source>External Subroutines (XS)</source>
          <target state="translated">外部子程序(XS)</target>
        </trans-unit>
        <trans-unit id="fe58f6fb5713c9d9970ba20c8c7e99ac12d8ebd1" translate="yes" xml:space="preserve">
          <source>External scripts may be called by their basename. Perl will try the same extensions as when processing &lt;b&gt;-S&lt;/b&gt; command-line switch.</source>
          <target state="translated">外部脚本可以通过其基本名称来调用。Perl将尝试与处理&lt;b&gt;-S&lt;/b&gt;命令行开关时相同的扩展名。</target>
        </trans-unit>
        <trans-unit id="ac98225101654b1670f972aaf6165f07d86a4dc2" translate="yes" xml:space="preserve">
          <source>External scripts starting with &lt;code&gt;#!&lt;/code&gt; or &lt;code&gt;extproc &lt;/code&gt; will be executed directly, without calling the shell, by calling the program specified on the rest of the first line.</source>
          <target state="translated">以 &lt;code&gt;#!&lt;/code&gt; 开头的外部脚本！或 &lt;code&gt;extproc &lt;/code&gt; 将通过调用第一行其余部分指定的程序而直接执行，而无需调用shell。</target>
        </trans-unit>
        <trans-unit id="26bf182753057236397eb723fd4891db5f117a3e" translate="yes" xml:space="preserve">
          <source>External subroutines (XSUBs) that maintain their own global state may not work correctly. Such XSUBs will either need to maintain locks to protect simultaneous access to global data from different pseudo-processes, or maintain all their state on the Perl symbol table, which is copied naturally when fork() is called. A callback mechanism that provides extensions an opportunity to clone their state will be provided in the near future.</source>
          <target state="translated">维护自己全局状态的外部子程序(XSUB)可能无法正常工作。这样的XSUB要么需要维护锁来保护不同伪进程对全局数据的同时访问,要么在Perl符号表上维护它们的所有状态,当fork()被调用时,符号表会被自然复制。在不久的将来,将提供一个回调机制,为扩展提供克隆其状态的机会。</target>
        </trans-unit>
        <trans-unit id="fc2399f06f4a8800f1e9f8c63e75b404573137c6" translate="yes" xml:space="preserve">
          <source>Extname</source>
          <target state="translated">Extname</target>
        </trans-unit>
        <trans-unit id="38bd9c2b38d963363075f657df2649a5a865d34f" translate="yes" xml:space="preserve">
          <source>Extra RECNO Methods</source>
          <target state="translated">额外的RECNO方法</target>
        </trans-unit>
        <trans-unit id="080170d5c582217b07d6b630ccf123361bce391b" translate="yes" xml:space="preserve">
          <source>Extra arguments given to &lt;code&gt;subtest&lt;/code&gt; are passed to the callback. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f428c72b95856a35d58cb6523d1d9bf0d7e2e713" translate="yes" xml:space="preserve">
          <source>Extra debugging of how tries execute.</source>
          <target state="translated">额外调试尝试如何执行。</target>
        </trans-unit>
        <trans-unit id="642e34f2d2485598d6a1289983f49ac33667a504" translate="yes" xml:space="preserve">
          <source>Extra debugging options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0f7f868e14cfcf2986def25df2bc4196200327" translate="yes" xml:space="preserve">
          <source>Extra layers can be inserted to process the data as it flows through. This was the driving need for including the scheme in perl 5.7.0+ - we needed a mechanism to allow data to be translated between perl's internal encoding (conceptually at least Unicode as UTF-8), and the &quot;native&quot; format used by the system. This is provided by the &quot;:encoding(xxxx)&quot; layer which typically sits above the buffering layer.</source>
          <target state="translated">当数据流过时,可以插入额外的层来处理数据。这也是在perl 5.7.0+中加入该方案的驱动力--我们需要一个机制来允许数据在perl的内部编码(概念上至少是UTF-8的Unicode)和系统使用的 &quot;本地 &quot;格式之间进行转换。这是由&quot;:encoding(xxxx)&quot;层提供的,它通常位于缓冲层之上。</target>
        </trans-unit>
        <trans-unit id="678bd1bdccc15e114b793e04d18d631885eca63c" translate="yes" xml:space="preserve">
          <source>Extract delimited text sequences from strings.</source>
          <target state="translated">从字符串中提取分隔的文本序列。</target>
        </trans-unit>
        <trans-unit id="7254948dbbd318f1e97d0a1eeb40a1eb2d41c79b" translate="yes" xml:space="preserve">
          <source>Extract it like this</source>
          <target state="translated">像这样提取</target>
        </trans-unit>
        <trans-unit id="05a2f0e61aa11822c7799b10cf19bd9f231551af" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. Don't extract it into the same directory as celib. Make a copy of the &quot;wince-arm-pocket-wce300&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">将它解压到一个无空格的路径,但不要解压到perl的编译源文件中。不要把它解压到与 celib 相同的目录中。复制 &quot;wince-arm-pocket-wce300 &quot;文件夹,并重命名为 &quot;wince-arm-pocket-wce400&quot;。这是一个黑客,所以我们可以通过链接CE 3.0 ARM asm来构建CE 4.0的二进制文件,链接器并不关心。Windows Mobile/WinCE和桌面Windows一样,都是向后兼容机器代码的。</target>
        </trans-unit>
        <trans-unit id="7749ca362c5039000e30519eec908556e69a793e" translate="yes" xml:space="preserve">
          <source>Extract it to a spaceless path but not into the perl build source. I call this directory &quot;celib-palm-3.0&quot; but in the GitHub snapshot it will be called &quot;celib-master&quot;. Make a copy of the &quot;wince-arm-pocket-wce300-release&quot; folder and rename the copy to &quot;wince-arm-pocket-wce400&quot;. This is a hack so we can build a CE 4.0 binary by linking in CE 3.0 ARM asm; the linker doesn't care. Windows Mobile/WinCE are backwards compatible with machine code like Desktop Windows.</source>
          <target state="translated">把它解压到一个无空格的路径,但不解压到perl的构建源文件中。我把这个目录称为 &quot;celib-palm-3.0&quot;,但在GitHub快照中,它将被称为 &quot;celib-master&quot;。复制 &quot;wince-arm-pocket-wce300-release &quot;文件夹,并将其重命名为 &quot;wince-arm-pocket-wce400&quot;。这是一个黑客,所以我们可以通过链接CE 3.0 ARM asm来构建CE 4.0的二进制文件,链接器并不关心。Windows Mobile/WinCE和桌面Windows一样,都是向后兼容机器代码的。</target>
        </trans-unit>
        <trans-unit id="6a5aa60c177bb5d75235a8c111f9e4b6cea8ac1c" translate="yes" xml:space="preserve">
          <source>Extract selected sections of POD from input</source>
          <target state="translated">从输入中提取POD的选定部分</target>
        </trans-unit>
        <trans-unit id="48348ed6315b959bdb6c19c5f46693033fe9a289" translate="yes" xml:space="preserve">
          <source>Extract this object, optionally to an alternative name.</source>
          <target state="translated">提取此对象,可选择使用其他名称。</target>
        </trans-unit>
        <trans-unit id="700d36da6316894ea4553b7a4764bc2e9b2ffb63" translate="yes" xml:space="preserve">
          <source>Extracted from core distribution for publishing on the CPAN by S&amp;eacute;bastien Aperghis-Tramoni &amp;lt;sebastien (at) aperghis.net&amp;gt;.</source>
          <target state="translated">摘录自S&amp;eacute;bastienAperghis-Tramoni &amp;lt;sebastien（at）aperghis.net&amp;gt;的核心发行版，以便在CPAN上发布。</target>
        </trans-unit>
        <trans-unit id="8d01377458bb164941cbab45b0257bce76f2aaf1" translate="yes" xml:space="preserve">
          <source>Extracting Version Numbers from Perl Modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33342b226b64c6cbc40d180e3ba186ad44a5f06f" translate="yes" xml:space="preserve">
          <source>Extracting matches</source>
          <target state="translated">提取火柴</target>
        </trans-unit>
        <trans-unit id="16e9f64b08e09da9325dc889d58611a8376664da" translate="yes" xml:space="preserve">
          <source>Extracts a substring out of EXPR and returns it. First character is at offset zero. If OFFSET is negative, starts that far back from the end of the string. If LENGTH is omitted, returns everything through the end of the string. If LENGTH is negative, leaves that many characters off the end of the string.</source>
          <target state="translated">从EXPR中提取一个子串并返回。第一个字符在偏移量0处。如果OFFSET为负值,则从字符串末尾开始计算。如果省略LENGTH,则返回从字符串末尾开始的所有字符。如果LENGTH为负值,则从字符串结尾处开始返回这么多字符。</target>
        </trans-unit>
        <trans-unit id="7e02013b2bc8b8b15efdd928d9932b054c7620a2" translate="yes" xml:space="preserve">
          <source>Extracts the contents of the tar file. The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference). All relative paths in the tar file will be created underneath the current working directory.</source>
          <target state="translated">提取 tar 文件的内容。第一个参数可以是要创建的 tar 文件的名称,也可以是打开的文件句柄的引用(例如 GLOB 引用)。tar 文件中的所有相对路径都将在当前工作目录下创建。</target>
        </trans-unit>
        <trans-unit id="885f6e090c877a36591aaa902dd00c6dd7b9efec" translate="yes" xml:space="preserve">
          <source>Extras.U</source>
          <target state="translated">Extras.U</target>
        </trans-unit>
        <trans-unit id="f680827447f98b26a0af418fbc0405801d7796f6" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UNICODE_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a686562152550b10f6394ec5f13fc276de5710" translate="yes" xml:space="preserve">
          <source>Extremely high code points were never specified in any standard, and require an extension to UTF-8 to express, which Perl does. It is likely that programs written in something other than Perl would not be able to read files that contain these; nor would Perl understand files written by something that uses a different extension. For these reasons, there is a separate set of flags that can warn and/or disallow these extremely high code points, even if other above-Unicode ones are accepted. They are the &lt;code&gt;UTF8_WARN_PERL_EXTENDED&lt;/code&gt; and &lt;code&gt;UTF8_DISALLOW_PERL_EXTENDED&lt;/code&gt; flags. For more information see &lt;a href=&quot;#UTF8_GOT_PERL_EXTENDED&quot;&gt;&quot;&lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt;&quot;&lt;/a&gt;. Of course &lt;code&gt;UTF8_DISALLOW_SUPER&lt;/code&gt; will treat all above-Unicode code points, including these, as malformations. (Note that the Unicode standard considers anything above 0x10FFFF to be illegal, but there are standards predating it that allow up to 0x7FFF_FFFF (2**31 -1))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f25b6a320c5687fd271f37b1ee97e7d69228f2" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</source>
          <target state="translated">open3()与open2()极为相似,open3()生成给定的$cmd,并连接CHLD_OUT用于从子程序读取,CHLD_IN用于向子程序写入,CHLD_ERR用于错误。如果CHLD_ERR为false,或者与CHLD_OUT的文件描述符相同,那么子程序的STDOUT和STDERR就在同一个文件柄上(这意味着不能为STDERR文件柄使用自变量词库,见SYNOPSIS)。CHLD_IN将开启自动刷新功能。</target>
        </trans-unit>
        <trans-unit id="92eb55a6ceeed67d784ed90769a2d53fa3c77acb" translate="yes" xml:space="preserve">
          <source>Extremely similar to open2(), open3() spawns the given command and connects $chld_out for reading from the child, $chld_in for writing to the child, and $chld_err for errors. If $chld_err is false, or the same file descriptor as $chld_out, then STDOUT and STDERR of the child are on the same filehandle. This means that an autovivified lexical cannot be used for the STDERR filehandle, but gensym from &lt;a href=&quot;symbol&quot;&gt;Symbol&lt;/a&gt; can be used to vivify a new glob reference, see &lt;a href=&quot;#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot;&lt;/a&gt;. The $chld_in will have autoflush turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2122187dffca50e0b79b010ea05ebfa6a4d1181" translate="yes" xml:space="preserve">
          <source>Extshortname</source>
          <target state="translated">Extshortname</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="ade1d38216915151ba7db0ce62f3199d7bf8e743" translate="yes" xml:space="preserve">
          <source>F:/bin</source>
          <target state="translated">F:/bin</target>
        </trans-unit>
        <trans-unit id="16a6231368962f338e8f37dfc91ca30753938154" translate="yes" xml:space="preserve">
          <source>FACET FIELDS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="3f8b9d0d8f1563ce34d8f76abc9faf53ac55bb32" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65569c995a4785c8ee0ddac72f9a5d5496ad6056" translate="yes" xml:space="preserve">
          <source>FAQs, tricks and tips for &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; 常见问题，技巧和提示。</target>
        </trans-unit>
        <trans-unit id="dec5a3344b6b1da0ebe322bd0a2dfc8eb4528955" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt; ), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="translated">致命错误将导致程序停止运行（ &lt;code&gt;croak&lt;/code&gt; ），因为问题非常严重，以至于继续存在危险。（这总是被 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 所困，但这不是一个好主意。在这种情况下，最好死去）。</target>
        </trans-unit>
        <trans-unit id="6b6f2d1eafcc9e88114df946d6ac19bc0f376a0c" translate="yes" xml:space="preserve">
          <source>FATAL errors will cause the program to halt (&lt;code&gt;croak&lt;/code&gt;), since the problem is so severe that it would be dangerous to continue. (This can always be trapped with &lt;code&gt;eval&lt;/code&gt;, but it's not a good idea. Under the circumstances, dying is the best thing to do).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69754788a4c6beb4ec0ff140aa5c158dca3bfa2a" translate="yes" xml:space="preserve">
          <source>FB_CROAK</source>
          <target state="translated">FB_CROAK</target>
        </trans-unit>
        <trans-unit id="b626cf33b4a041c5ce4d521b41bf3a7b58bd485d" translate="yes" xml:space="preserve">
          <source>FB_DEFAULT</source>
          <target state="translated">FB_DEFAULT</target>
        </trans-unit>
        <trans-unit id="757934dd26eb29cb3152a5f387ec3d2edb168405" translate="yes" xml:space="preserve">
          <source>FB_PERLQQ FB_HTMLCREF FB_XMLCREF</source>
          <target state="translated">FB_PERLQQ FB_HTMLCREF FB_XMLCREF</target>
        </trans-unit>
        <trans-unit id="0a74cbd8c5cb0982de1a9bcfa6850e000455346d" translate="yes" xml:space="preserve">
          <source>FB_QUIET</source>
          <target state="translated">FB_QUIET</target>
        </trans-unit>
        <trans-unit id="0dd7f31fe0e5f67c669f4440fb273121e4c806e4" translate="yes" xml:space="preserve">
          <source>FB_WARN</source>
          <target state="translated">FB_WARN</target>
        </trans-unit>
        <trans-unit id="8e8b3f3bb48e9f1566f046dd9abec5d58654f4a5" translate="yes" xml:space="preserve">
          <source>FCNTL</source>
          <target state="translated">FCNTL</target>
        </trans-unit>
        <trans-unit id="47dadeeeb2bc9f5421eaa6bbbe50810a393d4c66" translate="yes" xml:space="preserve">
          <source>FEATURE BUNDLES</source>
          <target state="translated">功能包</target>
        </trans-unit>
        <trans-unit id="ec8e87c2f7d4da8aaca114d6270ea98cb522428f" translate="yes" xml:space="preserve">
          <source>FEATURES = less-&amp;gt;of()</source>
          <target state="translated">特征= less-&amp;gt; of（）</target>
        </trans-unit>
        <trans-unit id="489edc9160737f1f5321c8439e0d90f85d95108c" translate="yes" xml:space="preserve">
          <source>FEEDBACK</source>
          <target state="translated">FEEDBACK</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="a36834b47beb7b8fa9cc177881caffbc9273b059" translate="yes" xml:space="preserve">
          <source>FETCH this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b96ae35c4cdaf0d5015e044df05ffbf062155e" translate="yes" xml:space="preserve">
          <source>FETCH this, index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0417b5bc981c089adeff175d8d240c193a1c5f" translate="yes" xml:space="preserve">
          <source>FETCH this, key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895bf1dc50f257bb516434bac2edbda6ee48875" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; access.</source>
          <target state="translated">FETCHSIZE和STORESIZE用于提供 &lt;code&gt;$#array&lt;/code&gt; 和等效的 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar(@array)&lt;/a&gt;&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="9a55d444e2f42ff3332a7b20892e03b42c0dde45" translate="yes" xml:space="preserve">
          <source>FETCHSIZE and STORESIZE are used to provide &lt;code&gt;$#array&lt;/code&gt; and equivalent &lt;code&gt;scalar(@array)&lt;/code&gt; access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="655cf3f775d1131bb1cd13d50dcc9384058c7e74" translate="yes" xml:space="preserve">
          <source>FETCHSIZE returned a negative value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffdae04b785f3e9a65f525eb253a77d31047f28b" translate="yes" xml:space="preserve">
          <source>FETCHSIZE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845bc45b1b1e5326c244df2ee7648f3ddd776170" translate="yes" xml:space="preserve">
          <source>FETCH_</source>
          <target state="translated">FETCH_</target>
        </trans-unit>
        <trans-unit id="05cf9a52ee9997400d322323b2f4f5f087799c04" translate="yes" xml:space="preserve">
          <source>FIELDS</source>
          <target state="translated">FIELDS</target>
        </trans-unit>
        <trans-unit id="07c257b16606b468b4287bbfd069963fcb6c04a5" translate="yes" xml:space="preserve">
          <source>FIFO</source>
          <target state="translated">FIFO</target>
        </trans-unit>
        <trans-unit id="3f799155fde6a8df0e53471e8ebc22e51aee5205" translate="yes" xml:space="preserve">
          <source>FIFO (named pipe).</source>
          <target state="translated">FIFO(命名管)。</target>
        </trans-unit>
        <trans-unit id="b4915d3a7ef82abdf96f2b5042452a69b2ea344c" translate="yes" xml:space="preserve">
          <source>FILE</source>
          <target state="translated">FILE</target>
        </trans-unit>
        <trans-unit id="188699dbc4f938b6c1d493b9b4e73beaae160b4d" translate="yes" xml:space="preserve">
          <source>FILE may contain Unicode characters outside the system codepage. Once the file has been created you can use Win32::GetANSIPathName() to get a name that can be passed to system calls and external programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1037b28078b931a2bcf7381d1504e913f7749ea4" translate="yes" xml:space="preserve">
          <source>FILEGV</source>
          <target state="translated">FILEGV</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
