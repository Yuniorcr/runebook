<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="5e09c6821154895943bc8dd098914ffb05015157" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt;:</source>
          <target state="translated">还有一个功能可以为 &lt;code&gt;HV&lt;/code&gt; 添加魔术：</target>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">还有一个较大形式的char类结构，用于表示 &lt;code&gt;/l&lt;/code&gt; 匹配下的POSIX char类，称为 &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; ，它具有一个附加的32位位图，用于指示已包括哪些POSIX char类。</target>
        </trans-unit>
        <trans-unit id="76c5f483367def15ac8c922d54c4856b499dee91" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html上&lt;/a&gt;也有此发行版的用户可用的邮件列表。</target>
        </trans-unit>
        <trans-unit id="c5a106d5c5ea059e07db233389f5aaf480ce92ad" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;https://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html上&lt;/a&gt;也有此发行版的用户可用的邮件列表。</target>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">还有一个用Perl编写的基于toyedit文本小部件的编辑器，与CPAN上的Tk模块一起分发。ptkdb（&lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt;）是基于Perl / Tk的调试器，可作为各种开发环境。Perl Composer（&lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt;）是用于创建Perl / Tk GUI的IDE。</target>
        </trans-unit>
        <trans-unit id="d6fbaba8f9d7c369b3de63f57e236ae1dbe1ef42" translate="yes" xml:space="preserve">
          <source>There is also an irc channel available for users of this distribution, at &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;&lt;code&gt;#toolchain&lt;/code&gt; on &lt;code&gt;irc.perl.org&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt; &lt;code&gt;#toolchain&lt;/code&gt; 上的 &lt;code&gt;irc.perl.org&lt;/code&gt; &lt;/a&gt;上，还有一个irc通道可供该发行版的用户使用。</target>
        </trans-unit>
        <trans-unit id="d533bbf93c93c54738d070099b6cc38c79c4b031" translate="yes" xml:space="preserve">
          <source>There is an active user community that provides many software packages for the Synology DSM systems; at the time of writing this document they provide Perl version 5.24.1.</source>
          <target state="translated">有一个活跃的用户社区为Synology DSM系统提供了许多软件包;在撰写本文档时,他们提供了Perl 5.24.1版本。</target>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">在子例程中使用 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 时，存在一个极端情况，该子例程是在与调用它的模块不同的模块中创建的。听起来很复杂，但实际上并非如此。这是一个无法正常工作的示例：</target>
        </trans-unit>
        <trans-unit id="689977e776e24b93188512fdd38744344797e09f" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;next::method&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">在子例程中使用 &lt;code&gt;next::method&lt;/code&gt; 时，存在一个极端的情况，该子例程是在与调用它的模块不同的模块中创建的。听起来很复杂，但实际上并非如此。这是一个无法正常工作的示例：</target>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">还有另一个目录（$ CPAN :: Config-&amp;gt; {keep_source_where}），用于保存原始分发文件。该目录不受高速缓存管理器的限制，必须由用户控制。如果选择与build_dir和keep_source_where目录具有相同的目录，则将使用相同的fifo机制删除源。</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">还有一种方法可以使用,即在回调终止后,只要Perl重新获得控制权,就会让Perl自动为你做这件事。要做到这一点,只需不使用</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">还有一种方法可以用清晰换取紧凑。INPUT部分允许声明不出现在子程序参数列表中的C变量。因此,上面的mutate()代码可以重写为</target>
        </trans-unit>
        <trans-unit id="69c800bd073688bcd19d75ca494a0e096bef464f" translate="yes" xml:space="preserve">
          <source>There is currently no method for going the other way; but I can probably provide one upon request.</source>
          <target state="translated">目前还没有走另一条路的方法;但我也许可以根据要求提供一种方法。</target>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">目前还没有办法关闭试图对未标记的文本进行适当格式化的猜测工作,而且有时不希望这样做(特别是在使用 POD 来记录 Perl 以外的其他内容时)。不过,现在已经完成了大部分的修复工作,还需要的是一个用户界面。</target>
        </trans-unit>
        <trans-unit id="658a8d7bbc3f0f0bd3eee360c95b181c02d32e56" translate="yes" xml:space="preserve">
          <source>There is lots more to bracketed character classes; full details are in &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">方括号中的字符类还有很多。有关详细信息&lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;，请参见perlrecharclass中的&amp;ldquo;括号字符类&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">没有</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">进程大小没有2GB的限制。</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">扩展名没有提供 &lt;code&gt;*.bs&lt;/code&gt; 文件。相反，可能有一个 &lt;code&gt;*_BS&lt;/code&gt; 文件，其中包含特殊情况的代码，例如NeXT上berkeley db的posix。</target>
        </trans-unit>
        <trans-unit id="f9908fb44bd4986c8ec4678f0acbb2e49a902c07" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。&lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt; &lt;/a&gt;使用sysseek（$ fh，0，1）。</target>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">没有 &lt;code&gt;systell&lt;/code&gt; 功能。 &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; 请使用sysseek（FH，0，1）。</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">虽然没有 BNF,但如果你特别勇敢的话,你可以在源码发行版的 perly.y 中摸索 yacc 语法。这个语法依赖于非常聪明的标记化代码,所以也要准备好进入 toke.c。</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">将子例程放在 &lt;code&gt;__DATA__&lt;/code&gt; 令牌之后总是被调用没有好处。</target>
        </trans-unit>
        <trans-unit id="a280984dba8147f4930e83be6fff5dcdd90c3af1" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; function calls the &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method for the package used. See also &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;函数调用的&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;所使用的包装方法。另请参见&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">没有内置的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能。它只是由希望将名称导出到另一个模块的模块定义（或继承）的普通方法（子例程）。在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 函数调用的 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 所使用的包装方法。另请参见&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;和&lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">没有内置的方法可以说:&quot;无论它有多宽,都要把它漂浮到页面的右侧&quot;。你必须指定它的位置。真正绝望的人可以根据当前的列数,在飞行中生成自己的格式,然后eval()它。</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">没有检查可以断言从Perl传递到C的文件句柄是使用正确的 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 模式创建的。</target>
        </trans-unit>
        <trans-unit id="218dbdb05fa2faf351feae2d57dfa67d5a01ea2a" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;open()&lt;/code&gt; mode.</source>
          <target state="translated">没有检查可以断言从Perl传递到C的文件句柄是使用正确的 &lt;code&gt;open()&lt;/code&gt; 模式创建的。</target>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">在压缩数据流之后,没有紧接着的数据。</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">没有解密功能。这个函数对于加密学来说并不是那么有用(关于这个,请查找</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">对于大多数非Perl定义的属性，没有给出描述（有关此&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;信息&lt;/a&gt;，请参见http://www.unicode.org/reports/tr44/）。</target>
        </trans-unit>
        <trans-unit id="f563145f449ff5ee1d2f8e7465d7ae9b5f8c2158" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">没有为大多数非Perl定义的属性提供描述（有关此&lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;信息&lt;/a&gt;，请参见http://www.unicode.org/reports/tr44/）。</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perl中没有双重插值法，因此 &lt;code&gt;$100&lt;/code&gt; 保持不变。</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">在 &lt;code&gt;Archive::Tar&lt;/code&gt; 没有简单的方法来提供此功能，因为tarball可以包含许多文件，并且每个文件都可以以不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="5f678f49ea0f0b1f3db41874eff418b0f56e6c16" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt;, because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">在 &lt;code&gt;Archive::Tar&lt;/code&gt; 没有简单的方法来提供此功能，因为tarball可以包含许多文件，并且每个文件都可以以不同的方式进行编码。</target>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">没有等效的运算符可以强制在列表上下文中插入表达式，因为实际上不需要。但是，如果您确实想这样做，可以使用结构 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; ，但通常只需一个简单的 &lt;code&gt;(some expression)&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="7cb80803d06b14ddbd06119d95cbdefe4be98fc5" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt;, but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">没有等效的运算符来强制在列表上下文中插入表达式，因为在实践中，这是不需要的。但是，如果您确实想这样做，可以使用结构 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; ，但通常只需一个简单的 &lt;code&gt;(some expression)&lt;/code&gt; 就足够了。</target>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">没有 &lt;code&gt;fgets&lt;/code&gt; ; 应该使用 &lt;code&gt;sv_gets&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="9c4f353571f4abb0cafbf257cbbb852b1668ac0d" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt;; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">没有 &lt;code&gt;fgets&lt;/code&gt; 等价的东西; 应该使用 &lt;code&gt;sv_gets&lt;/code&gt; 代替：</target>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">没有防火墙</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">所有这些都没有一般的解决办法。这是一个混乱的问题。</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">这一切都没有一般的解决办法。只是一团糟。</target>
        </trans-unit>
        <trans-unit id="b2b55e890caeb51d36e6b91d2ac8fcb1b35de4f5" translate="yes" xml:space="preserve">
          <source>There is no interface to request alternative CHECK behavior as for decode_argv(). If you need that you need to call encode/decode yourself. For example:</source>
          <target state="translated">没有接口可以像decode_argv()那样请求替代的CHECK行为。如果你需要,你需要自己调用编码/解码。例如</target>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">定义-OR没有低优先运算符。</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">无需从&lt;b&gt;SelfLoader&lt;/b&gt;继承。</target>
        </trans-unit>
        <trans-unit id="6e895b74ce6094374e60e95c58a0d18a65714b5a" translate="yes" xml:space="preserve">
          <source>There is no need to upgrade if you already have it installed.</source>
          <target state="translated">如果你已经安装了它,就不需要升级。</target>
        </trans-unit>
        <trans-unit id="6f9d8d1ae5518832290b8aa40a4082b8960c7be8" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;a href=&quot;sdbm_file&quot;&gt;&lt;code&gt;SDBM_File&lt;/code&gt;&lt;/a&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;a href=&quot;ndbm_file&quot;&gt;&lt;code&gt;NDBM_File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;db_file&quot;&gt;&lt;code&gt;DB_File&lt;/code&gt;&lt;/a&gt; are available.</source>
          <target state="translated">在所有平台上都没有一个DBM模块可用。&lt;a href=&quot;sdbm_file&quot;&gt; &lt;code&gt;SDBM_File&lt;/code&gt; &lt;/a&gt;和其他文件通常在所有Unix和DOSish端口上可用，但在MacPerl中则不可用，在MacPerl中，只有&lt;a href=&quot;ndbm_file&quot;&gt; &lt;code&gt;NDBM_File&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;db_file&quot;&gt; &lt;code&gt;DB_File&lt;/code&gt; &lt;/a&gt;可用。</target>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">在所有平台上都没有一个DBM模块可用。 &lt;code&gt;SDBM_File&lt;/code&gt; 和其他文件通常在所有Unix和DOSish端口上可用，但在MacPerl中则不可用，在MacPerl中只有 &lt;code&gt;NDBM_File&lt;/code&gt; 和 &lt;code&gt;DB_File&lt;/code&gt; 可用。</target>
        </trans-unit>
        <trans-unit id="dc935adca7e5bcb15422e7a69e6858c66da25299" translate="yes" xml:space="preserve">
          <source>There is no provision for delaying a request body using an &lt;code&gt;Expect&lt;/code&gt; header. Unexpected &lt;code&gt;1XX&lt;/code&gt; responses are silently ignored as per the specification.</source>
          <target state="translated">没有提供使用 &lt;code&gt;Expect&lt;/code&gt; 标头来延迟请求正文的规定。根据规范，意外的 &lt;code&gt;1XX&lt;/code&gt; 响应将被静默忽略。</target>
        </trans-unit>
        <trans-unit id="f93f05645168f7a6ce32010423ff327f27468e22" translate="yes" xml:space="preserve">
          <source>There is no public API for popping individual values or items from the save stack. Instead, via the scope stack, the &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; pair form a way to start and stop nested scopes. Leaving a nested scope via &lt;code&gt;LEAVE&lt;/code&gt; will restore all of the saved values that had been pushed since the most recent &lt;code&gt;ENTER&lt;/code&gt;.</source>
          <target state="translated">没有公共API可用于从保存堆栈中弹出单个值或项目。取而代之的是，通过作用域堆栈， &lt;code&gt;ENTER&lt;/code&gt; 和 &lt;code&gt;LEAVE&lt;/code&gt; 对形成启动和停止嵌套作用域的方法。通过 &lt;code&gt;LEAVE&lt;/code&gt; 保留嵌套作用域将恢复自最近的 &lt;code&gt;ENTER&lt;/code&gt; 以来已推入的所有已保存的值。</target>
        </trans-unit>
        <trans-unit id="e7d4d5447e705702a110e831b9f5c50697a0ccfe" translate="yes" xml:space="preserve">
          <source>There is no public API to directly push items to the temporaries stack. Instead, the API function &lt;code&gt;sv_2mortal()&lt;/code&gt; is used to mortalize an xV, adding its address to the temporaries stack.</source>
          <target state="translated">没有公共API可直接将项目推送到临时堆栈。取而代之的是，使用API​​函数 &lt;code&gt;sv_2mortal()&lt;/code&gt; 使xV失效，将其地址添加到临时堆栈中。</target>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">没有量词 &lt;code&gt;{,n}&lt;/code&gt; 。那被解释为文字字符串。</target>
        </trans-unit>
        <trans-unit id="4e5e1c10d207641a72418018f1f75f1613935380" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt;. That's currently illegal.</source>
          <target state="translated">没有量词 &lt;code&gt;{,n}&lt;/code&gt; 。目前是非法的。</target>
        </trans-unit>
        <trans-unit id="b61924ba7fcca566e3d46f3a27c41097477fd32e" translate="yes" xml:space="preserve">
          <source>There is no reason to directly use this package. This package is documented for completeness. This package can change, or go away completely at any time. Directly using, or monkeypatching this package is not supported in any way shape or form.</source>
          <target state="translated">没有理由直接使用这个包。这个包的文档是完整的。这个包可以在任何时候改变,或者完全消失。不支持以任何方式或形式直接使用或修补这个包。</target>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">您没有理由不使用 Perl 作为一种语言将 Unix 工具粘合在一起,或者将 Macintosh 应用程序原型化,或者管理 Windows 注册表。如果出于这样或那样的原因,在一个特定的程序中追求可移植性是没有意义的,那就别费劲了。</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">没有要求转换任何东西。</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">没有set_layers（），也没有get_layers（）返回镜像堆栈的绑定数组，或者类似的东西。这不是偶然的或无意的。PerlIO层堆栈比仅堆栈要复杂一些（例如，参见 &lt;code&gt;:raw&lt;/code&gt; 的行为）。您应该使用open（）和binmode（）来操纵堆栈。</target>
        </trans-unit>
        <trans-unit id="382f006c5b68a9b9a43fcd623fca8e14332f9212" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt;). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">没有set_layers（），也没有get_layers（）返回镜像堆栈的绑定数组，或者类似的东西。这不是偶然的或无意的。 PerlIO层堆栈比仅堆栈要复杂一些（例如，参见 &lt;code&gt;:raw&lt;/code&gt; 的行为）。您应该使用open（）和binmode（）来操纵堆栈。</target>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">没有外壳程序可以处理元字符，本机标准是将以&amp;ldquo; \ n&amp;rdquo;，&amp;ldquo; \ r&amp;rdquo;或&amp;ldquo; \ 0&amp;rdquo;结尾的命令行传递给生成的程序。诸如 &lt;code&gt;&amp;gt; foo&lt;/code&gt; 重定向（如果有的话）由产生的程序的运行时库执行。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">在编译时和运行时创建类之间并没有明显的速度提升,有的只是一个新的、更标准的事件顺序。</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">这个问题没有简单的答案。Perl框架可以运行从基本的文件服务器和小规模的内部网到大规模的多国多语言网站,这些都是国际企业的核心。</target>
        </trans-unit>
        <trans-unit id="300fa34c66267d66af5fbbb27ef916d4adcee2ea" translate="yes" xml:space="preserve">
          <source>There is no simple replacement possible since a qualifier and all its subqualifiers must be considered together, so we use our own utility routine for the replacement.</source>
          <target state="translated">由于一个限定词和它的所有子限定词必须一起考虑,所以不可能进行简单的替换,所以我们使用自己的实用程序进行替换。</target>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">由于printf()的智能有限,没有简单的解决方案,但对于许多类型来说,正确的格式是可用的,例如,后缀为'f'或'_f'。</target>
        </trans-unit>
        <trans-unit id="5540c0e13568fd5e0e7ecd528ea43dc498771d2a" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">没有简单的方法可以访问WPS对象。我知道的唯一方法是通过 &lt;code&gt;OS2::REXX&lt;/code&gt; 和 &lt;code&gt;SOM&lt;/code&gt; 扩展（请参阅&lt;a href=&quot;OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;和&lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;）。但是，我们无法使用Object-REXX的便捷方法。 （有可能吗？我不知道Object-REXX API。） &lt;code&gt;SOM&lt;/code&gt; 扩展名（当前为字母文本）可能最终消除了这一缺点。但是，由于 &lt;code&gt;SOM&lt;/code&gt; 模块不支持DII ，因此使用 &lt;code&gt;SOM&lt;/code&gt; 并不像人们期望的那样方便。</target>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">没有简单的方法来访问WPS对象。我知道的唯一方法是通过 &lt;code&gt;OS2::REXX&lt;/code&gt; 和 &lt;code&gt;SOM&lt;/code&gt; 扩展（请参阅&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;）。但是，我们无法使用Object-REXX的便捷方法。（有可能吗？我不知道Object-REXX API。） &lt;code&gt;SOM&lt;/code&gt; 扩展名（当前为字母文本）可能最终消除了这一缺点。但是，由于 &lt;code&gt;SOM&lt;/code&gt; 模块不支持DII ，因此使用 &lt;code&gt;SOM&lt;/code&gt; 并不像人们期望的那样方便。</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">在Perl中没有特殊的类语法,但是如果一个包提供了作为方法的子程序,那么它可以作为一个类来使用。这样的包也可以通过在它的全局@ISA数组中列出其他包名(必须是包的全局名,而不是词法名),从另一个类(包)中派生出一些方法。</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS上没有专门针对Perl的邮件列表,您可以联系您所在地区的Stratus Technologies客户支持中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。您可以联系您所在地区的Stratus Technologies客户援助中心(CAC),或者使用Stratus匿名FTP站点上的分发文件中的联系信息。</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; 命令后没有格式化程序的规范。</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">对于实数来说,没有网络表示法这种东西,所以如果你想跨计算机边界发送你的实数,你最好坚持使用文本表示法,可能使用十六进制浮点数格式(避免十进制转换损失),除非你绝对确定线的另一端是什么。对于更冒险的人,你可以使用上一节也是关于浮点码的字节序修改器。</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">目前还不支持绑定的@ISA。注意到@ISA的设置所需的魔法条目和实现 &quot;绑定 &quot;所需的魔法条目之间存在潜在的冲突。</target>
        </trans-unit>
        <trans-unit id="8ce7f675d43b056af9ee6718421eba4a7f2bb579" translate="yes" xml:space="preserve">
          <source>There is no support for a Request-URI of '*' for the 'OPTIONS' request.</source>
          <target state="translated">对于'OPTIONS'请求,不支持'*'的Request-URI。</target>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4 不支持动态链接库。</target>
        </trans-unit>
        <trans-unit id="ddb797616f9cbf4b2f8a2cb06d0ccee2c08c8ad1" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; doesn't work well on device files (like ttys) anyway. Use &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; and check for a return value of 0 to decide whether you're done.</source>
          <target state="translated">没有syseof（）函数，没关系，因为&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;无论如何都无法在设备文件（如ttys）上正常工作。使用&lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;sysread&lt;/code&gt; &lt;/a&gt;并检查返回值0以决定是否完成。</target>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">没有syseof()函数,这是好的,因为eof()对设备文件(如ttys)并不好用。使用sysread()并检查返回值为0来决定是否完成。</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">没有技术上的原因,为什么Berkeley DB数据库不能由Perl和C应用程序共享。</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">没有办法可靠地自动检测编码,所以如果人们一直向你发送没有标明字符集的数据,你可能不得不教育他们。</target>
        </trans-unit>
        <trans-unit id="20ec9f83105615b23b9fac938fd715b5bc923fe1" translate="yes" xml:space="preserve">
          <source>There is no way to turn it back on.</source>
          <target state="translated">没有办法再打开它。</target>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize::Expire并没有什么特别之处。它只是一个例子。如果你不喜欢它所实现的策略,你可以自由地编写自己的过期策略模块,实现任何你想要的策略。下面是如何做到这一点。让我们假设你的模块将被命名为MyExpirePolicy。</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">现在有一个 &lt;code&gt;bsstr()&lt;/code&gt; 方法以科学记数法（即 &lt;code&gt;1e+2&lt;/code&gt; 而不是 &lt;code&gt;100&lt;/code&gt; ）获取字符串。请注意，重载的&amp;ldquo; eq&amp;rdquo;始终使用bstr（）进行比较，但是Perl会将某些数字表示为100，而其他数字表示为1e + 308。如有疑问，请将两个参数都转换为Math :: BigInt，然后将它们作为字符串进行比较：</target>
        </trans-unit>
        <trans-unit id="5ae720bb4190ab9bd815350aa7eadedcf7d8ced5" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">现在有一个 &lt;code&gt;bsstr()&lt;/code&gt; 方法以科学记数法（又称为 &lt;code&gt;1e+2&lt;/code&gt; )而不是 &lt;code&gt;100&lt;/code&gt; 来获取字符串。请注意，重载的&amp;ldquo; eq&amp;rdquo;始终使用bstr（）进行比较，但Perl会将一些数字表示为100，而将其他数字表示为1e + 308。如有疑问，请将两个参数都转换为Math :: BigInt，然后将它们作为字符串进行比较：</target>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">当然，还有很多可以发现的东西，这只是表面。了解更多信息的最佳方法是使用perldoc查找有关该语言的更多信息，阅读在线帮助（&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;可能是下一个选择），当然还有实验。</target>
        </trans-unit>
        <trans-unit id="4c5dc52000b85d6cc8d7d71cfdf7a1cf6d094cbc" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one.</source>
          <target state="translated">往往是见仁见智的问题,没有任何一个答案适合所有人。一般来说,你希望使用当前的稳定版,或者紧接着之前的稳定版。</target>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">往往是见仁见智的问题,没有任何一个答案适合所有人。一般来说,你希望使用当前的稳定版本,或者紧接着之前的稳定版本。目前,这些版本分别是perl5.18.x和perl5.16.x。</target>
        </trans-unit>
        <trans-unit id="6fddc6aff8f6804eafbdecf55f8d9d2197b85b37" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">但是，INSTALL_BASE有一个警告，因为它的作用与&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker的&lt;/a&gt;旧版本所倡导的PREFIX和LIB设置不同。INSTALL_BASE不支持在同一目录下为Perl的多个版本或不同体系结构安装模块。您应该考虑您是否真的想要这样做，如果需要，请使用旧的PREFIX和LIB设置。有关更多详细信息，请参见&lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">但是，INSTALL_BASE有一个警告，因为它的作用与&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker的&lt;/a&gt;较早版本主张的PREFIX和LIB设置不同。 INSTALL_BASE不支持在同一目录下为Perl的多个版本或不同体系结构安装模块。您应该考虑是否确实需要，如果需要，请使用旧的PREFIX和LIB设置。有关更多详细信息，请参见&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemaker&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="14196e0aaa427146743d8121cb1facbe4cf5fb5c" translate="yes" xml:space="preserve">
          <source>There is one crucial restriction: the prereqs of an optional feature &lt;b&gt;must not&lt;/b&gt; include &lt;code&gt;configure&lt;/code&gt; phase prereqs.</source>
          <target state="translated">有一个关键限制：可选功能的先决条件&lt;b&gt;不得&lt;/b&gt;包含 &lt;code&gt;configure&lt;/code&gt; 阶段先决条件。</target>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">所有这些都有一个例外。 &lt;code&gt;\p{All}&lt;/code&gt; 看起来像一个Unicode属性，但这是一个Perl扩展，定义为对所有可能的代码点（无论是否为Unicode）都为true，因此，将其与非Unicode代码点进行匹配时不会生成任何警告。（在v5.20之前，它是 &lt;code&gt;\p{Any}&lt;/code&gt; 的确切同义词，匹配代码点 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;0x10FFFF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a280fffe45cedb42744a2a95530fed2f40145dd0" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt;, matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt;.)</source>
          <target state="translated">所有这一切都有一个例外。 &lt;code&gt;\p{All}&lt;/code&gt; 看起来像一个Unicode属性，但这是一个Perl扩展，定义为对于所有可能的代码点（无论是否为Unicode）都为true，因此，将其与非Unicode代码点进行匹配时不会生成任何警告。（在v5.20之前，它是 &lt;code&gt;\p{Any}&lt;/code&gt; 的确切同义词，匹配代码点 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;0x10FFFF&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">这个规则有一个例外。</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">有一个例外,那就是基数2为负数$x。</target>
        </trans-unit>
        <trans-unit id="8cbb7256d41af14511a3636bc506131a71d8c56d" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">有一个例外。如果使用字母数字字符作为模式的定界符（出于可读性原因，您可能不应该这样做），则如果要匹配定界符，则必须转义该定界符。Perl不会发出警告。另请参见&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlop中的&amp;ldquo;解析引用的构造的详细信息&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">有一个例外。如果使用字母数字字符作为模式的定界符（出于可读性原因，您可能不应该这样做），则要匹配定界符，必须对其进行转义。Perl不会发出警告。另请参见&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;在perlop中解析引用的构造的Gory详细信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">有一个微小的区别：如果在 &lt;code&gt;for&lt;/code&gt; 的初始化部分中用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 声明了变量，则这些变量的词法作用域恰好是 &lt;code&gt;for&lt;/code&gt; 循环（循环的主体和控制部分）。</target>
        </trans-unit>
        <trans-unit id="9813dc853a6a86bf5a99b935f981b5a1ed789ab3" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;my&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt;, the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">有一个微小的区别：如果在 &lt;code&gt;for&lt;/code&gt; 的初始化部分中用 &lt;code&gt;my&lt;/code&gt; 声明了变量，则这些变量的词法作用域恰好是 &lt;code&gt;for&lt;/code&gt; 循环（循环的主体和控制部分）。</target>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; 之间只有一个小区别：前者不会影响变量的赋值和某些函数的返回值。 &lt;code&gt;bigint&lt;/code&gt; 也将这些结果截断为整数：</target>
        </trans-unit>
        <trans-unit id="b8649e02d1e449cfaae6e608c7b04929643e83c2" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use bigint&lt;/code&gt;: the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 和 &lt;code&gt;use bigint&lt;/code&gt; 之间只有一个小区别：前者不会影响变量的赋值和某些函数的返回值。 &lt;code&gt;bigint&lt;/code&gt; 也会将这些结果截断为整数：</target>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">以下说法有一个微妙的区别。</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">有一个单利运算符。</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">只有一个 &lt;code&gt;%^H&lt;/code&gt; ，但是任意多个模块想要使用其作用域语义。为了避免踩到对方的脚趾，他们需要确保在哈希中使用不同的键。因此，常规上，模块仅使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。在此模块标识前缀之后，密钥的其余部分完全取决于模块：它可以包含任何字符。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 和 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 。遵循此约定的模块可以很好地相互配合。</target>
        </trans-unit>
        <trans-unit id="3740e3b8de22c29d0f5b6e37bf6c582521c6e016" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt;, but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt;. Modules following this convention all play nicely with each other.</source>
          <target state="translated">只有一个 &lt;code&gt;%^H&lt;/code&gt; ，但是任意多个模块都想使用其作用域语义。为了避免踩到对方的脚趾，他们需要确保在哈希中使用不同的键。因此，常规的是，模块仅使用以模块名称（其主软件包的名称）和&amp;ldquo; /&amp;rdquo;字符开头的键。在此模块标识前缀之后，密钥的其余部分完全取决于模块：它可以包含任何字符。例如，模块 &lt;code&gt;Foo::Bar&lt;/code&gt; 应该使用诸如 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; 和 &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; 。遵循此约定的模块可以很好地相互配合。</target>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">大纲上支持PerlIO与stdio共存。显然,如果PerlIO是用stdio实现的,就没有问题。然而在其他情况下,就必须有机制来创建一个FILE *,它可以传递给要使用stdio调用的库代码。</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">关于 &quot;regexp &quot;还是 &quot;regex&quot;,有一些争论。在本文件中,我们将使用 &quot;regex &quot;一词,除非有特殊原因,在这种情况下,我们将解释原因。</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 在线程Perl下工作的方式存在一些问题，可能是由于 &lt;code&gt;@_&lt;/code&gt; 的词法作用域。这是Perl中的一个错误，在解决之前，已记忆的函数将看到略有不同的 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; ,并且在线程Perl上的执行要比非线程Perl慢一些。</target>
        </trans-unit>
        <trans-unit id="2bcd1c67f3d88bee674b646d4ad741c0978c442b" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;goto &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt;. This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;caller()&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">&lt;code&gt;goto &amp;amp;f&lt;/code&gt; 在线程Perl下工作的方式存在一些问题，可能是由于 &lt;code&gt;@_&lt;/code&gt; 的词法作用域。这是Perl中的一个错误，在解决之前，已记忆的函数将看到略有不同的 &lt;code&gt;caller()&lt;/code&gt; ,并且在线程Perl上的执行要比在非线程Perl上执行得慢一些。</target>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">在看似空的行上有一些空格。POD对此类事物非常敏感，因此将其标记出来。&lt;b&gt;vi&lt;/b&gt;用户打开&lt;b&gt;list&lt;/b&gt;选项可以避免此问题。</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">还有很大一部分的API不支持。</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">从理论上讲，信号仍然有很小的机会会在完成之前中断系统级的 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 操作。即使缓冲区为空，某些STDIO实现也可能会调用多个系统级 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 。在某些系统中，该可能性降低为零，并且使用 &lt;code&gt;:perlio&lt;/code&gt; 而不是系统的STDIO 时无需担心。</target>
        </trans-unit>
        <trans-unit id="0c9adb8b47f26bb800c4b672d40c4761b57cb21d" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;write()&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;write()&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">从理论上讲，信号仍然有很小的机会会在完成之前中断系统级的 &lt;code&gt;write()&lt;/code&gt; 操作。即使缓冲区为空启动，某些STDIO实现也可能会调用多个系统级 &lt;code&gt;write()&lt;/code&gt; 。在某些系统中，该可能性降低为零，并且在使用 &lt;code&gt;:perlio&lt;/code&gt; 而不是系统的STDIO时，无需担心。</target>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">有一个给定的regnode的 &quot;下一个regnode&quot;,这个值很少有用,只是有时它与其他的一个regnode在值上吻合,有时代码会认为总是如此。</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">这是一个给定的regop/regnode的 &quot;下一个regop&quot;。这是由当前regop的大小决定的,物理上位于当前regop之后的regop。这通常是有用的,例如当转储结构时,我们使用这个顺序来遍历。有时,代码会假设 &quot;下一个regnode &quot;和 &quot;下一个regop &quot;是一样的,或者换句话说,假设给定的regop类型的大小总是要大一个regnode。</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">有来自给定regop的&amp;ldquo; regnext&amp;rdquo;。这是regop，可以通过向前跳转 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 的值来达到，或者在某些情况下可以通过 &lt;code&gt;regnode_1&lt;/code&gt; 结构的 &lt;code&gt;arg1&lt;/code&gt; 字段进行更长的跳转。子例程 &lt;code&gt;regnext()&lt;/code&gt; 透明地进行处理。这是节点的逻辑后继者，在某些情况下，像 &lt;code&gt;BRANCH&lt;/code&gt; regop一样，具有特殊的含义。</target>
        </trans-unit>
        <trans-unit id="9aa02419484468b5c8da416f7649906d690c9a05" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt;, or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">有来自给定regop的&amp;ldquo; regnext&amp;rdquo;。这是regop，可以通过向前跳转 &lt;code&gt;NEXT_OFF()&lt;/code&gt; 的值来达到，或者在某些情况下可以通过 &lt;code&gt;regnode_1&lt;/code&gt; 结构的 &lt;code&gt;arg1&lt;/code&gt; 字段进行更长的跳转。子例程 &lt;code&gt;regnext()&lt;/code&gt; 透明地处理此问题。这是节点的逻辑后继者，在某些情况下，像 &lt;code&gt;BRANCH&lt;/code&gt; regop的逻辑后继者一样，具有特殊的含义。</target>
        </trans-unit>
        <trans-unit id="d7e93b59e1cec82fb52bcc021241febda0271114" translate="yes" xml:space="preserve">
          <source>There is unfortunately no way to know whether the current emulator supports more than eight colors, which makes the choice of colors difficult. The most conservative choice is to use only the regular colors, which are at least displayed on all emulators. However, they will appear dark in sixteen-color terminal emulators, including most common emulators in UNIX X environments. If you know the display is one of those emulators, you may wish to use the bright variants instead. Even better, offer the user a way to configure the colors for a given application to fit their terminal emulator.</source>
          <target state="translated">遗憾的是,目前的仿真器是否支持八种以上的颜色,无从得知,这给颜色的选择带来了困难。最保守的选择是只使用常规颜色,至少在所有仿真器上都能显示。但是,在十六色终端仿真器中,包括UNIX X环境中最常见的仿真器中,它们会显得很暗。如果你知道显示器是这些仿真器中的一种,你可能希望使用明亮的变体来代替。更好的做法是,为用户提供一种方法来配置给定应用程序的颜色,以适应他们的终端仿真器。</target>
        </trans-unit>
        <trans-unit id="695fd95569c58aad4ef775aef68eb765f2b01d11" translate="yes" xml:space="preserve">
          <source>There is whitespace at the beginning or the end of the contents of L&amp;lt;...&amp;gt;.</source>
          <target state="translated">L &amp;lt;...&amp;gt;的内容的开头或结尾处都有空格。</target>
        </trans-unit>
        <trans-unit id="95a3b67169b42d8576a9c6b1e3142c83d233d818" translate="yes" xml:space="preserve">
          <source>There is/was a minor twist which makes this scheme fragile: what to do with DLLs loaded from</source>
          <target state="translated">有一个小的转折让这个方案变得很脆弱:如何处理从</target>
        </trans-unit>
        <trans-unit id="3224e59e3b76dce8e510a893a97e615a7718acdb" translate="yes" xml:space="preserve">
          <source>There may be a few system-dependent issues of concern to EBCDIC Perl programmers.</source>
          <target state="translated">对于EBCDIC Perl程序员来说,可能有一些系统依赖性问题值得关注。</target>
        </trans-unit>
        <trans-unit id="74512965a00a9ef27998a0f76a590e7ca4e44a5a" translate="yes" xml:space="preserve">
          <source>There may be a slight performance decrease in the filetest operations when the filetest pragma is in effect, because checking bits is very cheap.</source>
          <target state="translated">当filetest pragma生效时,filetest操作可能会有轻微的性能下降,因为检查位非常便宜。</target>
        </trans-unit>
        <trans-unit id="e5aefd712f7c17e18d56a8092421c803470327d8" translate="yes" xml:space="preserve">
          <source>There may be several other functions that have undefined behavior so this list shouldn't be considered complete.</source>
          <target state="translated">可能还有其他一些函数具有未定义的行为,所以这个列表不应该被认为是完整的。</target>
        </trans-unit>
        <trans-unit id="8f2ee1e9e100e424daf008c17d87249cb596b7da" translate="yes" xml:space="preserve">
          <source>There might be padding bytes between the fields to align the fields - the bytes can be anything</source>
          <target state="translated">字段之间可能会有填充字节来对齐字段--这些字节可以是任何东西。</target>
        </trans-unit>
        <trans-unit id="79bbf613c601df02685a1a8cf9fe8bf41a315d78" translate="yes" xml:space="preserve">
          <source>There must be no space after the &amp;lt;&amp;lt; part.</source>
          <target state="translated">&amp;lt;&amp;lt;部分后面不能有空格。</target>
        </trans-unit>
        <trans-unit id="0027f08c80bd3f13ec2adbb5ed6335850c27dec0" translate="yes" xml:space="preserve">
          <source>There needs to be at least a line separator after the end token.</source>
          <target state="translated">在结束标记后至少需要有一个分行符。</target>
        </trans-unit>
        <trans-unit id="3c0e690d4d9216e705dc85028ebd1bac807095e9" translate="yes" xml:space="preserve">
          <source>There needs to be content inside E, L, and X formatting codes.</source>
          <target state="translated">E、L、X格式码里面需要有内容。</target>
        </trans-unit>
        <trans-unit id="04957b7e4885516ed63d7f8370637e85be797dcc" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overridden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt;, which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">如此长的双重实现似乎存在各种问题。如果Configure检测到此损坏，它将禁用长期双重支持。可以用显式的 &lt;code&gt;-Duselongdouble&lt;/code&gt; （或 &lt;code&gt;-Dusemorebits&lt;/code&gt; ，它同时启用长双精度和64位整数）覆盖。如果您决定启用长双精度，那么对于大多数损坏的事情，Perl都实施了变通方法，但是特殊值infinity和NaN的处理仍然很糟糕：例如，NaN中的infinity加零结果。</target>
        </trans-unit>
        <trans-unit id="8da2d0d0ae5db5c30555083a00bfa8e94e394bba" translate="yes" xml:space="preserve">
          <source>There seem to be various problems in this long double implementation. If Configure detects this brokenness, it will disable the long double support. This can be overriden with explicit &lt;code&gt;-Duselongdouble&lt;/code&gt; (or &lt;code&gt;-Dusemorebits&lt;/code&gt; , which enables both long doubles and 64 bit integers). If you decide to enable long doubles, for most of the broken things Perl has implemented workarounds, but the handling of the special values infinity and NaN remains badly broken: for example infinity plus zero results in NaN.</source>
          <target state="translated">这种长的双重实现似乎存在各种问题。如果Configure检测到此损坏，它将禁用长期双重支持。可以使用显式的 &lt;code&gt;-Duselongdouble&lt;/code&gt; （或 &lt;code&gt;-Dusemorebits&lt;/code&gt; ，它同时启用长双精度和64位整数）来覆盖它。如果您决定启用长双精度，那么对于大多数损坏的事情，Perl都实施了变通方法，但是特殊值infinity和NaN的处理仍然严重中断：例如，NaN中的infinity加零结果。</target>
        </trans-unit>
        <trans-unit id="0335b463034771ce67a8d72b65b51f2c22f06a51" translate="yes" xml:space="preserve">
          <source>There seems to be a broken system header file in HP-UX 11.00 that breaks perl building in 32bit mode with GNU gcc-4.x causing this error. The same file for HP-UX 11.11 (even though the file is older) does not show this failure, and has the correct definition, so the best fix is to patch the header to match:</source>
          <target state="translated">在HP-UX 11.00中似乎有一个系统头文件被破坏了,它破坏了在32位模式下用GNU gcc-4.x进行perl构建,导致了这个错误。HP-UX 11.11的相同文件(尽管该文件较旧)没有显示这个故障,并且有正确的定义,所以最好的修复方法是将头文件修补为匹配。</target>
        </trans-unit>
        <trans-unit id="06ff19d7cd54ce39cc7fc4ec7d77ca64eb5bbd76" translate="yes" xml:space="preserve">
          <source>There should be a second &lt;code&gt;&quot;:&quot;&lt;/code&gt; , like this:</source>
          <target state="translated">应该有第二个 &lt;code&gt;&quot;:&quot;&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="f721ea1c84751a36c3521319fb047aa7a307e4e5" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt; , as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">在 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 之前应该有一个运算符，因为没有指示如何将数字与老挝和泰语脚本中的字符组合在一起。</target>
        </trans-unit>
        <trans-unit id="b71e898307cc5bb054200f4c984f66181569531c" translate="yes" xml:space="preserve">
          <source>There should be an operator before the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, as there's no indication as to how the digits are to be combined with the characters in the Lao and Thai scripts.</source>
          <target state="translated">在 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 之前应该有一个运算符，因为没有指示如何将数字与老挝和泰语脚本中的字符组合在一起。</target>
        </trans-unit>
        <trans-unit id="b4b586b7cb9ac2ab75263a6f83deec69bb4720e3" translate="yes" xml:space="preserve">
          <source>There should be no test failures.</source>
          <target state="translated">不应出现测试失败的情况。</target>
        </trans-unit>
        <trans-unit id="b05734899e6eb6dfc62f93644e8cdfe0e3686a6c" translate="yes" xml:space="preserve">
          <source>There used to be two main passes involved in parsing, the first to calculate the size of the compiled program, and the second to actually compile it. But now there is only one main pass, with an initial crude guess based on the length of the input pattern, which is increased if necessary as parsing proceeds, and afterwards, trimmed to the actual amount used.</source>
          <target state="translated">以前解析过程中主要涉及两个主通道,第一个是计算编译程序的大小,第二个是实际编译。但现在只有一个主通道,根据输入模式的长度进行初步的粗略猜测,随着解析的进行,如果有必要的话,会增加输入模式的长度,之后再根据实际使用的数量进行修剪。</target>
        </trans-unit>
        <trans-unit id="6e7e045068e59967e564a49c6f93bb7b24be5931" translate="yes" xml:space="preserve">
          <source>There we're using the %USER_VARS hash instead of symbolic references. Sometimes this comes up in reading strings from the user with variable references and wanting to expand them to the values of your perl program's variables. This is also a bad idea because it conflates the program-addressable namespace and the user-addressable one. Instead of reading a string and expanding it to the actual contents of your program's own variables:</source>
          <target state="translated">在这里我们使用%USER_VARS哈希来代替符号引用。有时会出现这样的情况,从用户那里读取变量引用的字符串,并希望将它们扩展到你的perl程序的变量值。这也是一个坏主意,因为它混淆了程序可寻址的命名空间和用户可寻址的命名空间。而不是读取一个字符串并将其扩展到你的程序自己的变量的实际内容。</target>
        </trans-unit>
        <trans-unit id="42ff6f078c663dbcc013a189f161b1005798db67" translate="yes" xml:space="preserve">
          <source>There were at least two consecutive &lt;code&gt;=begin&lt;/code&gt; commands without the corresponding &lt;code&gt;=end&lt;/code&gt; . Only one &lt;code&gt;=begin&lt;/code&gt; may be active at a time.</source>
          <target state="translated">至少有两个连续的 &lt;code&gt;=begin&lt;/code&gt; 命令，没有对应的 &lt;code&gt;=end&lt;/code&gt; 。一次只能激活一个 &lt;code&gt;=begin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f453a9d5941f2f68e4cfdb1b1ca5576cad8a3040" translate="yes" xml:space="preserve">
          <source>There were race conditions 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path的 &lt;code&gt;rmtree&lt;/code&gt; 函数存在竞赛条件1.x实现（尽管有时会根据操作系统发行版或平台进行修补）。2.0版本包含避免CVE-2002-0435中提到的问题的代码。</target>
        </trans-unit>
        <trans-unit id="3380503a8405cff6d76d7964b6fbca011946199a" translate="yes" xml:space="preserve">
          <source>There were race conditions in the 1.x implementations of File::Path's &lt;code&gt;rmtree&lt;/code&gt; function (although sometimes patched depending on the OS distribution or platform). The 2.0 version contains code to avoid the problem mentioned in CVE-2002-0435.</source>
          <target state="translated">File :: Path的 &lt;code&gt;rmtree&lt;/code&gt; 函数的1.x实现中存在竞争条件（尽管有时会根据操作系统发行版或平台进行修补）。2.0版本包含避免CVE-2002-0435中提到的问题的代码。</target>
        </trans-unit>
        <trans-unit id="78c41744f80fbb19ebe5f5b692cb01709180e04c" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in a handler because the system</source>
          <target state="translated">知道这一点，您可以做两件事：偏执或务实。偏执狂的做法是在信号处理程序中尽可能少地做。设置一个已经具有值的现有整数变量，然后返回。如果您正在缓慢的系统调用中，这将对您没有帮助，这只会重新启动。这意味着你必须 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 对longjmp（3）从处理程序。即使对于真正的偏执狂来说，这也有点儿麻烦，因为系统会避免 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 处理程序</target>
        </trans-unit>
        <trans-unit id="be42f956d21114ebe79af50776e96bfca65bd05b" translate="yes" xml:space="preserve">
          <source>There were two things you could do, knowing this: be paranoid or be pragmatic. The paranoid approach was to do as little as possible in your signal handler. Set an existing integer variable that already has a value, and return. This doesn't help you if you're in a slow system call, which will just restart. That means you have to &lt;code&gt;die&lt;/code&gt; to longjmp(3) out of the handler. Even this is a little cavalier for the true paranoiac, who avoids &lt;code&gt;die&lt;/code&gt; in a handler because the system</source>
          <target state="translated">知道这一点，您可以做两件事：偏执或务实。偏执狂的做法是在信号处理程序中尽可能少地做。设置一个已经具有值的现有整数变量，然后返回。如果您正在缓慢的系统调用中，这将无济于事，它只会重新启动。这意味着你必须 &lt;code&gt;die&lt;/code&gt; 对longjmp（3）从处理程序。即使对于真正的偏执狂来说，这也有点儿麻烦，因为系统会避免在处理程序中 &lt;code&gt;die&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73d8966c11e67db894b509268c4964e23520f68e" translate="yes" xml:space="preserve">
          <source>There will be less network overhead (and some efficiency in your program) if you specify either the udp or the icmp protocol. The tcp protocol will generate 2.5 times or more traffic for each ping than either udp or icmp. If many hosts are pinged frequently, you may wish to implement a small wait (e.g. 25ms or more) between each ping to avoid flooding your network with packets.</source>
          <target state="translated">如果你指定了udp或icmp协议,会有更少的网络开销(和一些效率)。tcp协议每次ping产生的流量是udp或icmp的2.5倍或更多。如果很多主机经常被ping,你可能希望在每次ping之间实现一个小的等待(例如25ms或更多),以避免你的网络被数据包淹没。</target>
        </trans-unit>
        <trans-unit id="6b418e4f885e0ed1944b1a75c443618ba49e064f" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s More Than One Way To Do It, the Perl Motto. The notion that there can be more than one valid path to solving a programming problem in context. (This doesn&amp;rsquo;t mean that more ways are always better or that all possible paths are equally desirable&amp;mdash;just that there need not be One True Way.)</source>
          <target state="translated">Perl座右铭是不止一种方法。在上下文中解决编程问题可以有多个有效途径。（这并不意味着会有更多的方法总是更好，或者所有可能的路径都是同样可取的-只是不必有一种&amp;ldquo;真正的方法&amp;rdquo;。）</target>
        </trans-unit>
        <trans-unit id="f28bb8331230709c36ed738881be6c54310d8343" translate="yes" xml:space="preserve">
          <source>There's More Than One Way to Do It</source>
          <target state="translated">有不止一种方法可以做到。</target>
        </trans-unit>
        <trans-unit id="4490df2ff2d12a716aa36bd30350a041386f672a" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;a href=&quot;#no-MODULE-VERSION-LIST&quot;&gt;&lt;code&gt;no&lt;/code&gt;&lt;/a&gt; declaration that unimports meanings imported by &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, i.e., it calls &lt;code&gt;Module-&amp;gt;unimport(LIST)&lt;/code&gt; instead of &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;. It behaves just as &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">有一个相应的&lt;a href=&quot;#no-MODULE-VERSION-LIST&quot;&gt; &lt;code&gt;no&lt;/code&gt; &lt;/a&gt;声明，即 &lt;code&gt;Module-&amp;gt;unimport(LIST)&lt;/code&gt; &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;导入的含义，即，它调用Module-&amp;gt; unimport（LIST）而不是&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;。它的行为就像使用VERSION&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;，省略或为空的LIST或未找到未导入方法一样。</target>
        </trans-unit>
        <trans-unit id="2d73bf3d5d8029a31c5c535e944915e019e3d9d2" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">有一个相应的 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 声明，即unimport通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 导入的含义，即调用 &lt;code&gt;unimport Module LIST&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 。它的行为与VERSION， &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; LIST省略或为空或未找到unimport方法的行为相同。</target>
        </trans-unit>
        <trans-unit id="899206f410877415c07b1eae00900c686b6ba014" translate="yes" xml:space="preserve">
          <source>There's a corresponding &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declaration that unimports meanings imported by &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, i.e., it calls &lt;code&gt;unimport Module LIST&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;. It behaves just as &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does with VERSION, an omitted or empty LIST, or no unimport method being found.</source>
          <target state="translated">有一个相应的 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 声明，即unimport通过 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 导入的含义，即调用 &lt;code&gt;unimport Module LIST&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 。它的行为与VERSION， &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; LIST省略或为空或未找到unimport方法的行为相同。</target>
        </trans-unit>
        <trans-unit id="5182f679e917b06933e3121044c80451fb98d666" translate="yes" xml:space="preserve">
          <source>There's a couple of useful ones to know about straight away. You wouldn't think we're using any libraries at all at the moment, but '&lt;b&gt;M&lt;/b&gt;' will show which modules are currently loaded, and their version number, while '&lt;b&gt;m&lt;/b&gt;' will show the methods, and '&lt;b&gt;S&lt;/b&gt;' shows all subroutines (by pattern) as shown below. '&lt;b&gt;V&lt;/b&gt;' and '&lt;b&gt;X&lt;/b&gt;' show variables in the program by package scope and can be constrained by pattern.</source>
          <target state="translated">马上有一些有用的知识。您可能不会在此使用任何库，但是' &lt;b&gt;M&lt;/b&gt; '将显示当前正在加载的模块及其版本号，而' &lt;b&gt;m&lt;/b&gt; '将显示方法，而' &lt;b&gt;S&lt;/b&gt; '将显示所有子例程（按模式），如下所示。&amp;ldquo; &lt;b&gt;V&lt;/b&gt; &amp;rdquo;和&amp;ldquo; &lt;b&gt;X&lt;/b&gt; &amp;rdquo;按程序包范围显示程序中的变量，并且可以受模式约束。</target>
        </trans-unit>
        <trans-unit id="4a1ef6c094aa8fbf90f65e6711f095cef82e3a69" translate="yes" xml:space="preserve">
          <source>There's a great deal of reuse possible for sharing of phrases between modules for related dialects, or for sharing of auxiliary functions between related languages. (By &quot;auxiliary functions&quot;, I mean functions that don't produce phrase-text, but which, say, return an answer to &quot;does this number require a plural noun after it?&quot;. Such auxiliary functions would be used in the internal logic of functions that actually do produce phrase-text.)</source>
          <target state="translated">对于相关方言的模块之间的短语共享,或者相关语言之间的辅助功能共享,有很多重用的可能。(所谓 &quot;辅助函数&quot;,我指的是不产生短语-文本的函数,但比如说,返回 &quot;这个数字后面是否需要一个复数名词?&quot;的答案。这样的辅助函数将被用于实际产生短语-文本的函数的内部逻辑中。)</target>
        </trans-unit>
        <trans-unit id="18ae2cf96b3321649a9e67b52ce3c6b5c29a8066" translate="yes" xml:space="preserve">
          <source>There's a lot more to networking than this, but this should get you started.</source>
          <target state="translated">有很多比这更多的网络,但这应该让你开始。</target>
        </trans-unit>
        <trans-unit id="7dfd5539590f938c8db0768ae08c09cb62cf9574" translate="yes" xml:space="preserve">
          <source>There's a lot to know about character sets, and text encodings. It's probably best to spend a full day learning all this, but the basics can be learned in minutes.</source>
          <target state="translated">关于字符集和文本编码,有很多东西需要了解。也许最好是花一整天的时间来学习这些,但基本的知识可以在几分钟内学会。</target>
        </trans-unit>
        <trans-unit id="99ae85d03f4b582c99ff96216db7d59e44f17f54" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 有一个问题：它返回它创建的管道读取端的文件号，但是无法检索另一端的文件号。您可以通过使用 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 来避免此问题。</target>
        </trans-unit>
        <trans-unit id="66cd02292a787335ff912b7d35685e3ae9e8fbc4" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;syscall&quot;&gt;syscall(&amp;amp;SYS_pipe)&lt;/a&gt;&lt;/code&gt; 有一个问题：它返回它创建的管道读取端的文件号，但是无法检索另一端的文件号。您可以通过使用 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 来避免此问题。</target>
        </trans-unit>
        <trans-unit id="124833fbba9a90584d7cbbd8c3f21d0d1ed7374a" translate="yes" xml:space="preserve">
          <source>There's a problem with &lt;code&gt;syscall(SYS_pipe())&lt;/code&gt;: it returns the file number of the read end of the pipe it creates, but there is no way to retrieve the file number of the other end. You can avoid this problem by using &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;syscall(SYS_pipe())&lt;/code&gt; 有问题：它返回创建的管道读取端的文件号，但是无法检索另一端的文件号。您可以通过使用&lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt;来避免此问题。</target>
        </trans-unit>
        <trans-unit id="e41e3a2378d95f98d33fb21414c6067f31a384cf" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt; : There are actually</source>
          <target state="translated">在 &lt;code&gt;Memoize&lt;/code&gt; 的表象下有一点复杂：实际上有</target>
        </trans-unit>
        <trans-unit id="e606f3dfb543a0539ef72dd37726579bac1b16a8" translate="yes" xml:space="preserve">
          <source>There's a slight complication under the hood of &lt;code&gt;Memoize&lt;/code&gt;: There are actually</source>
          <target state="translated">在 &lt;code&gt;Memoize&lt;/code&gt; 的表象下有一点复杂：实际上有</target>
        </trans-unit>
        <trans-unit id="5de903209b03670bb7672de0c3e9635cd117f5ca" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt; ) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">有一个潜伏的陷阱：打包时可以在短消息后（在 &lt;code&gt;$sm&lt;/code&gt; 变量中）添加另一个字段，但这不能天真地解包：</target>
        </trans-unit>
        <trans-unit id="f66d2e86f53d8e9dfa87109acbd15cc3b1bb44aa" translate="yes" xml:space="preserve">
          <source>There's a subtle trap lurking in the offing: Adding another field after the Short Message (in variable &lt;code&gt;$sm&lt;/code&gt;) is all right when packing, but this cannot be unpacked naively:</source>
          <target state="translated">有一个微妙的陷阱正在潜伏：打包时可以在短消息后（在 &lt;code&gt;$sm&lt;/code&gt; 变量中）添加另一个字段，但这不能天真地解包：</target>
        </trans-unit>
        <trans-unit id="5136f0522d5206778ac4f88d48f4c827076f1a46" translate="yes" xml:space="preserve">
          <source>There's a wiki dedicated to the Test Anything Protocol:</source>
          <target state="translated">有一个维基专门用于测试任何东西协议。</target>
        </trans-unit>
        <trans-unit id="3b112374a474f8a64038b7df632984baece37394" translate="yes" xml:space="preserve">
          <source>There's also</source>
          <target state="translated">还有</target>
        </trans-unit>
        <trans-unit id="40aa0d88671271215389ee01ca5270e38fa18dab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">还有CPAN的&lt;a href=&quot;File::Tail&quot;&gt;File :: Tail&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="58a726895b66eba4d8724a2292f078a4d2648322" translate="yes" xml:space="preserve">
          <source>There's also a &lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File::Tail&lt;/a&gt; module from CPAN.</source>
          <target state="translated">还有来自CPAN 的&lt;a href=&quot;http://search.cpan.org/perldoc/File::Tail&quot;&gt;File :: Tail&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="035e86078ae3280a54d8fc426b353c9ce230b2ad" translate="yes" xml:space="preserve">
          <source>There's also a negated version of it:</source>
          <target state="translated">还有一个被否定的版本。</target>
        </trans-unit>
        <trans-unit id="194f92c1842e4ee102fc7a284b9e315ab368c04c" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt; :</source>
          <target state="translated">还有一个否定的版本，出于同样的原因， &lt;code&gt;unless&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e0601768e9aaa457e7e7ef47834fc2f32a22f940" translate="yes" xml:space="preserve">
          <source>There's also a negated version, for the same reason we have &lt;code&gt;unless&lt;/code&gt;:</source>
          <target state="translated">还有一个否定的版本，出于同样的原因， &lt;code&gt;unless&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ce23f5592e874ac51b717997ee3d4abcaf17d1eb" translate="yes" xml:space="preserve">
          <source>There's an &lt;code&gt;unmemoize&lt;/code&gt; function that you can import if you want to. Why would you want to? Here's an example: Suppose you have your cache tied to a DBM file, and you want to make sure that the cache is written out to disk if someone interrupts the program. If the program exits normally, this will happen anyway, but if someone types control-C or something then the program will terminate immediately without synchronizing the database. So what you can do instead is</source>
          <target state="translated">如果需要，可以导入一个 &lt;code&gt;unmemoize&lt;/code&gt; 功能。你为什么要这是一个示例：假设您已将缓存绑定到DBM文件，并且如果某人中断程序，则要确保将缓存写到磁盘上。如果程序正常退出，则无论如何都会发生，但是如果有人键入control-C或其他内容，则程序将立即终止而不同步数据库。因此，您可以做的是</target>
        </trans-unit>
        <trans-unit id="08ec3c4ec2591dd761c5a485e08fcf45d215a5be" translate="yes" xml:space="preserve">
          <source>There's an effort going on to document the internal functions and automatically produce reference manuals from them -- &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; is one such manual which details all the functions which are available to XS writers. &lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt; is the autogenerated manual for the functions which are not part of the API and are supposedly for internal use only.</source>
          <target state="translated">目前正在努力记录内部功能并自动从中生成参考手册&lt;a href=&quot;perlapi&quot;&gt;-perlapi&lt;/a&gt;是这样的手册，其中详细介绍了XS编写器可用的所有功能。&lt;a href=&quot;perlintern&quot;&gt;perlintern&lt;/a&gt;是针对这些功能的自动生成的手册，这些功能不是API的一部分，并且仅供内部使用。</target>
        </trans-unit>
        <trans-unit id="b109c22c8125d5fbc051e5882994774c0628f7aa" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;). First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;functions/crypt&quot;&gt;crypt中&lt;/a&gt;有一个示例。首先，将终端设置为&amp;ldquo;无回声&amp;rdquo;模式，然后正常读取密码。您可以使用老式的 &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl()&lt;/a&gt;&lt;/code&gt; 函数，POSIX终端控件（请参阅&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;或Camel Book的文档）或对&lt;b&gt;stty&lt;/b&gt;程序的调用来实现此目的，并具有不同程度的可移植性。</target>
        </trans-unit>
        <trans-unit id="e33a4a8215c89473473d7891ce0340be047dd1e2" translate="yes" xml:space="preserve">
          <source>There's an example of this in &lt;a href=&quot;perlfunc#crypt&quot;&gt;&quot;crypt&quot; in perlfunc&lt;/a&gt;. First, you put the terminal into &quot;no echo&quot; mode, then just read the password normally. You may do this with an old-style &lt;code&gt;ioctl()&lt;/code&gt; function, POSIX terminal control (see &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; or its documentation the Camel Book), or a call to the &lt;b&gt;stty&lt;/b&gt; program, with varying degrees of portability.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#crypt&quot;&gt;在perlfunc的&amp;ldquo; crypt&amp;rdquo;中&lt;/a&gt;有一个示例。首先，将终端置于&amp;ldquo;无回声&amp;rdquo;模式，然后正常读取密码。您可以使用老式的 &lt;code&gt;ioctl()&lt;/code&gt; 函数，POSIX终端控件（请参阅&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;或Camel Book的文档）或对&lt;b&gt;stty&lt;/b&gt;程序的调用来实现此目的，并具有不同程度的可移植性。</target>
        </trans-unit>
        <trans-unit id="1ee734c8b4d4a5b72b07450e993a31efdfcc81d2" translate="yes" xml:space="preserve">
          <source>There's an extraordinary number of people out there who don't appear to know anything about using the perl debugger, though they use the language every day. This is for them.</source>
          <target state="translated">有很多人看起来对使用perl调试器一无所知,尽管他们每天都在使用这种语言。这是为他们准备的。</target>
        </trans-unit>
        <trans-unit id="36e675dcb566e351efbc0e3f85ec7104c90a083d" translate="yes" xml:space="preserve">
          <source>There's currently only one class that has a stable interface - CPAN::Shell. All commands that are available in the CPAN shell are methods of the class CPAN::Shell. The arguments on the commandline are passed as arguments to the method.</source>
          <target state="translated">目前只有一个类有稳定的接口--CPAN::Shell。CPAN shell中所有可用的命令都是CPAN::Shell这个类的方法。命令行上的参数作为参数传递给方法。</target>
        </trans-unit>
        <trans-unit id="f60d62cdc295d6cbdfb5f2a35e55c4e958719c10" translate="yes" xml:space="preserve">
          <source>There's even less need to distinguish between EBCDIC code pages, but to do so try looking at one or more of the characters that differ between them.</source>
          <target state="translated">更不需要区分EBCDIC码页,但要区分的话,可以试着看看它们之间的一个或多个不同的字符。</target>
        </trans-unit>
        <trans-unit id="241fd51f25450a5ab0b7ec2c19699d2410027de0" translate="yes" xml:space="preserve">
          <source>There's no builtin way to do this, but &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; has a couple of techniques to make it possible for the intrepid hacker.</source>
          <target state="translated">没有内置的方法可以执行此操作，但是&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;有两种技术可以使强悍的黑客成为可能。</target>
        </trans-unit>
        <trans-unit id="5ace2a9bc7f6a90948438c072e0ce5f8cdc2b9bc" translate="yes" xml:space="preserve">
          <source>There's no feedback from this, but you can see what breakpoints are set by using the list 'L' command:</source>
          <target state="translated">没有任何反馈,但你可以通过使用list 'L'命令查看设置了哪些断点。</target>
        </trans-unit>
        <trans-unit id="f521ff0638ee964aa0ea31d64e9248f45119c41c" translate="yes" xml:space="preserve">
          <source>There's no solution for this problem other than making the custom engine understand a construct like &lt;code&gt;(?:)&lt;/code&gt;.</source>
          <target state="translated">除了使自定义引擎理解 &lt;code&gt;(?:)&lt;/code&gt; 之类的构造之外，没有其他解决方案。</target>
        </trans-unit>
        <trans-unit id="f42438ddafc8a1bac998273822622081c6567570" translate="yes" xml:space="preserve">
          <source>There's no strong security layer in CPAN.pm. CPAN.pm helps you to install foreign, unmasked, unsigned code on your machine. We compare to a checksum that comes from the net just as the distribution file itself. But we try to make it easy to add security on demand:</source>
          <target state="translated">CPAN.pm中没有强大的安全层。CPAN.pm可以帮助你在机器上安装外来的、未屏蔽的、未签名的代码。我们与来自网络的校验和相比,就像发行文件本身一样。但我们尽量使其易于按需添加安全性。</target>
        </trans-unit>
        <trans-unit id="794fc83a38998696363c5b95bfbda5c120c0de13" translate="yes" xml:space="preserve">
          <source>There's no way to tell if a &lt;code&gt;char *&lt;/code&gt; or &lt;code&gt;U8 *&lt;/code&gt; string is UTF-8 or not. But you can tell if an SV is to be treated as UTF-8 by calling &lt;code&gt;DO_UTF8&lt;/code&gt; on it, after stringifying it with &lt;code&gt;SvPV&lt;/code&gt; or a similar macro. And, you can tell if SV is actually UTF-8 (even if it is not to be treated as such) by looking at its &lt;code&gt;SvUTF8&lt;/code&gt; flag (again after stringifying it). Don't forget to set the flag if something should be UTF-8. Treat the flag as part of the PV, even though it's not -- if you pass on the PV to somewhere, pass on the flag too.</source>
          <target state="translated">无法判断 &lt;code&gt;char *&lt;/code&gt; 或 &lt;code&gt;U8 *&lt;/code&gt; 字符串是否为UTF-8。但是，在用 &lt;code&gt;SvPV&lt;/code&gt; 或类似的宏对SV 进行字符串化处理后，可以通过在其上调用 &lt;code&gt;DO_UTF8&lt;/code&gt; 来判断SV是否被视为UTF-8 。并且，通过查看其 &lt;code&gt;SvUTF8&lt;/code&gt; 标志（再次对其进行字符串化处理），可以判断SV是否实际上是UTF-8（即使不应将其视为UTF-8 ）。如果某些内容应为UTF-8，请不要忘记设置标志。即使不将标志视为PV的一部分-如果将PV传递到某个地方，也传递标志。</target>
        </trans-unit>
        <trans-unit id="dcc25cfc8a3ec732d1d2283e554b506992b75eb5" translate="yes" xml:space="preserve">
          <source>There's not a single way to run code in the background so you don't have to wait for it to finish before your program moves on to other tasks. Process management depends on your particular operating system, and many of the techniques are covered in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">没有在后台运行代码的单一方法，因此您无需等待程序完成就可以将程序移至其他任务。流程管理取决于您的特定操作系统，&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;涵盖了许多技术。</target>
        </trans-unit>
        <trans-unit id="d2aa5e3dbb927bd52349be7be623e623e64f5bf0" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">现在，.xs文件中已经添加了一些新的C代码。 &lt;code&gt;constant&lt;/code&gt; 例程的目的是使Perl脚本（通过调用 &lt;code&gt;TESTVAL&lt;/code&gt; 或 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ）可对头文件中#define的值进行访问。还有一些XS代码允许调用 &lt;code&gt;constant&lt;/code&gt; 例程。</target>
        </trans-unit>
        <trans-unit id="31087344a4d97cb3b80b7f78b63485fff944c0b5" translate="yes" xml:space="preserve">
          <source>There's now some new C code that's been added to the .xs file. The purpose of the &lt;code&gt;constant&lt;/code&gt; routine is to make the values that are #define'd in the header file accessible by the Perl script (by calling either &lt;code&gt;TESTVAL&lt;/code&gt; or &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt;). There's also some XS code to allow calls to the &lt;code&gt;constant&lt;/code&gt; routine.</source>
          <target state="translated">现在，.xs文件中已经添加了一些新的C代码。 &lt;code&gt;constant&lt;/code&gt; 例程的目的是使Perl脚本（通过调用 &lt;code&gt;TESTVAL&lt;/code&gt; 或 &lt;code&gt;&amp;amp;Mytest2::TESTVAL&lt;/code&gt; ）可对头文件中#define的值进行访问。还有一些XS代码允许调用 &lt;code&gt;constant&lt;/code&gt; 例程。</target>
        </trans-unit>
        <trans-unit id="e3ac8386164e4284b824a87f18c211196212c066" translate="yes" xml:space="preserve">
          <source>There's one fine point I skipped. Line 5 is unnecessary, and we can get rid of it.</source>
          <target state="translated">有一个细微的地方我跳过了。第5行是不必要的,我们可以把它去掉。</target>
        </trans-unit>
        <trans-unit id="f039a4fa9d9f10c8752271acf6c5252496665e47" translate="yes" xml:space="preserve">
          <source>There's one more item to add to this list. Do &lt;b&gt;not&lt;/b&gt; export variable names. Just because &lt;code&gt;Exporter&lt;/code&gt; lets you do that, it does not mean you should.</source>
          <target state="translated">还有一个项目要添加到此列表中。千万&lt;b&gt;不能&lt;/b&gt;导出变量名。仅仅因为 &lt;code&gt;Exporter&lt;/code&gt; 允许您这样做，并不意味着您应该这样做。</target>
        </trans-unit>
        <trans-unit id="ae8f51d8071cfe43c76f4dc0a54e230b2757479f" translate="yes" xml:space="preserve">
          <source>There's plenty more to Maketext than described above -- for example, there's the details of how language tags (&quot;en-US&quot;, &quot;i-pwn&quot;, &quot;fi&quot;, etc.) or locale IDs (&quot;en_US&quot;) interact with actual module naming (&quot;BogoQuery/Locale/en_us.pm&quot;), and what magic can ensue; there's the details of how to record (and possibly negotiate) what character encoding Maketext will return text in (UTF8? Latin-1? KOI8?). There's the interesting fact that Maketext is for localization, but nowhere actually has a &quot;&lt;code&gt;use locale;&lt;/code&gt;&quot; anywhere in it. For the curious, there's the somewhat frightening details of how I actually implement something like data inheritance so that searches across modules' %Lexicon hashes can parallel how Perl implements method inheritance.</source>
          <target state="translated">Maketext除了上述内容外，还有很多其他功能-例如，有关语言标签（&amp;ldquo; en-US&amp;rdquo;，&amp;ldquo; i-pwn&amp;rdquo;，&amp;ldquo; fi&amp;rdquo;等）或语言环境ID（&amp;ldquo; en_US&amp;rdquo;）如何交互的详细信息实际的模块命名（&amp;ldquo; BogoQuery / Locale / en_us.pm&amp;rdquo;），以及可以产生的魔力；有关如何记录（并可能进行协商）哪种字符编码Maketext将返回文本的详细信息（UTF8，Latin-1和KOI8？）。有一个有趣的事实，Maketext是用于本地化的，但实际上在任何地方都没有&amp;ldquo; &lt;code&gt;use locale;&lt;/code&gt; &amp;rdquo;。出于好奇，我实际上如何实现诸如数据继承之类的东西有些令人恐惧的细节，以便跨模块的％Lexicon哈希进行搜索可以与Perl如何实现方法继承并行。</target>
        </trans-unit>
        <trans-unit id="3157833531a4041a2d11a3ede90a818b20eec8a5" translate="yes" xml:space="preserve">
          <source>There's three possible options: arm-linux-androideabi for ARM, mipsel-linux-android for MIPS, and simply x86 for x86. As of 2014, most Android devices run on ARM, so that is generally a safe bet.</source>
          <target state="translated">有三种可能的选择:ARM的arm-linux-androideabi,MIPS的mipsel-linux-android,以及简单的x86的x86。截至2014年,大多数Android设备都运行在ARM上,所以一般来说这是一个安全的选择。</target>
        </trans-unit>
        <trans-unit id="23be60d3d8e40781087cd39d472decaae39f70d3" translate="yes" xml:space="preserve">
          <source>There, &quot;=shazbot&quot; will be parsed as a Pod command &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;. However, you can express a data paragraph consisting of &quot;=shazbot\n&quot; using this code:</source>
          <target state="translated">在这里,&quot;=shazbot &quot;将被解析为一个Pod命令 &quot;shazbot&quot;,而不是一个数据段&quot;=shazbot\n&quot;。但是,你可以用这个代码来表达一个由&quot;=shazbot/n &quot;组成的数据段。</target>
        </trans-unit>
        <trans-unit id="d934ecae0b30d1837eb15a99e36faf1a189e093b" translate="yes" xml:space="preserve">
          <source>There, the &quot;=begin html&quot;...&quot;=end html&quot; region is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end :biblio&quot; region. Note that the content of the &quot;=begin html&quot;...&quot;=end html&quot; region is data paragraph(s), because the immediately containing region's identifier (&quot;html&quot;)</source>
          <target state="translated">在这里,&quot;=begin html&quot;...&quot;=end html &quot;区域嵌套在较大的&quot;=begin :biblio&quot;...&quot;=end :biblio &quot;区域中。请注意,&quot;=begin html&quot;...&quot;=end html &quot;区域的内容是数据段,因为紧挨着该区域的标识符 (&quot;html&quot;)</target>
        </trans-unit>
        <trans-unit id="4c11e16e3b4c4d1c6c6291b739425f3d103ebc32" translate="yes" xml:space="preserve">
          <source>Therefor, we recommend to only use &lt;code&gt;lynx&lt;/code&gt; as a last resort. This is why it is at the back of our list of methods to try as well.</source>
          <target state="translated">因此，我们建议仅将 &lt;code&gt;lynx&lt;/code&gt; 作为最后的手段。这就是为什么它也在我们尝试的方法列表的后面。</target>
        </trans-unit>
        <trans-unit id="22f5648477726ba3de08027c1e14282ca2d62678" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; . Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt; , &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; .</source>
          <target state="translated">因此，最好避免 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。而是使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ， &lt;code&gt;%Carp::Internal&lt;/code&gt; 和 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51f60bccfa776ffe69d8f053cbc128c1c25657ab" translate="yes" xml:space="preserve">
          <source>Therefore it is best to avoid &lt;code&gt;$Carp::CarpLevel&lt;/code&gt;. Instead use &lt;code&gt;@CARP_NOT&lt;/code&gt;, &lt;code&gt;%Carp::Internal&lt;/code&gt; and &lt;code&gt;%Carp::CarpInternal&lt;/code&gt;.</source>
          <target state="translated">因此，最好避免使用 &lt;code&gt;$Carp::CarpLevel&lt;/code&gt; 。而是使用 &lt;code&gt;@CARP_NOT&lt;/code&gt; ， &lt;code&gt;%Carp::Internal&lt;/code&gt; 和 &lt;code&gt;%Carp::CarpInternal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee230bfa80dc9a35487630711b69781b4de0480c" translate="yes" xml:space="preserve">
          <source>Therefore modules that can install from CPAN to the core library must make sure not to call this pragma when they have done so. Generally this means that the exact logic from the installer must be mirrored inside the module. E.g.:</source>
          <target state="translated">因此,可以从CPAN安装到核心库的模块必须确保在安装时不要调用这个pragma。一般来说,这意味着安装程序的具体逻辑必须在模块内部镜像。例如:。</target>
        </trans-unit>
        <trans-unit id="6d0e80030071251142bc856e7654aae9ae473e69" translate="yes" xml:space="preserve">
          <source>Therefore we can use the &lt;code&gt;O_FILES&lt;/code&gt; variable to tell MakeMaker to use these objects into the shared library.</source>
          <target state="translated">因此，我们可以使用 &lt;code&gt;O_FILES&lt;/code&gt; 变量告诉MakeMaker使用这些对象进入共享库。</target>
        </trans-unit>
        <trans-unit id="bc549460f9ec0f5ba049505f7c5226ae9e2f8140" translate="yes" xml:space="preserve">
          <source>Therefore, if you make changes to $ENV{TZ} from inside a thread other than the main thread then those changes will not be seen by strftime if you subsequently call that with the %Z formatting code. You must change $ENV{TZ} in the main thread to have the desired effect in this case (and you must also call _tzset() in the main thread to register the environment change).</source>
          <target state="translated">因此,如果您在主线程以外的线程中对 $ENV{TZ}进行了修改,那么如果您随后使用 %Z 格式化代码调用该线程,这些修改将不会被 strftime 看到。在这种情况下,你必须在主线程中修改 $ENV{TZ}才能达到预期的效果 (而且你还必须在主线程中调用 _tzset()来注册环境变化)。</target>
        </trans-unit>
        <trans-unit id="a9f8fba915c890e8c346b81a259121ea682217ff" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">因此，如果希望脚本能够在所有版本的Perl上运行，则应显式调用 &lt;code&gt;&lt;a href=&quot;../../functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ,而不要依赖自动关闭。</target>
        </trans-unit>
        <trans-unit id="954446d1274139a67133d250b76f105e02594120" translate="yes" xml:space="preserve">
          <source>Therefore, if you want your scripts to be able to run on all versions of Perl, you should call &lt;code&gt;close&lt;/code&gt; explicitly and not rely on automatic closing.</source>
          <target state="translated">因此，如果希望脚本能够在所有版本的Perl上运行，则应显式调用 &lt;code&gt;close&lt;/code&gt; ,而不要依赖自动关闭。</target>
        </trans-unit>
        <trans-unit id="b60bd02288d8270eaef5b4fd58dd4835333cea91" translate="yes" xml:space="preserve">
          <source>Therefore, populate such variables &lt;b&gt;after&lt;/b&gt; declaring them as shared. (Scalar and scalar refs are not affected by this problem.)</source>
          <target state="translated">因此，&lt;b&gt;在&lt;/b&gt;声明这些变量为共享变量&lt;b&gt;后&lt;/b&gt;，填充它们。（标量和标量引用不受此问题的影响。）</target>
        </trans-unit>
        <trans-unit id="fd4c5f1975f02e1f013464b5926b49a349d976cd" translate="yes" xml:space="preserve">
          <source>Therefore, recursion should normally be avoided, but is nonetheless supported.</source>
          <target state="translated">因此,通常应该避免递归,但还是支持递归。</target>
        </trans-unit>
        <trans-unit id="db068f38c67a6942c06b6242bd31cfce066e66c2" translate="yes" xml:space="preserve">
          <source>Therefore, when both -f and -t are omitted, &lt;b&gt;piconv&lt;/b&gt; just acts like &lt;b&gt;cat&lt;/b&gt;.</source>
          <target state="translated">因此，当同时省略-f和-t时，&lt;b&gt;piconv的&lt;/b&gt;行为就像&lt;b&gt;cat&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2f61899aa2182fe38363f4a728d368f7dbd80080" translate="yes" xml:space="preserve">
          <source>Therefore, when serializing hooks are involved,</source>
          <target state="translated">因此,当涉及到序列化钩子时。</target>
        </trans-unit>
        <trans-unit id="083d92ff42dd743db0e3ca76319637c407df0e2d" translate="yes" xml:space="preserve">
          <source>Therefore, you should bless objects before sharing them.</source>
          <target state="translated">因此,在分享物品之前应该先祝福。</target>
        </trans-unit>
        <trans-unit id="c563bb79b9bbcc9436e0f964c49bd1fc0638d285" translate="yes" xml:space="preserve">
          <source>These #vars represent opcode properties that you may want as part of your rendering. The '#' is intended as a private sigil; a #var's value is interpolated into the style-line, much like &quot;read $this&quot;.</source>
          <target state="translated">这些#vars代表了你在渲染时可能需要的操作码属性。'#'是一个私人的标志;一个#var的值被插入到样式行中,就像 &quot;read $this &quot;一样。</target>
        </trans-unit>
        <trans-unit id="0e7355ac11ba52ff51227da22556bcbc5b08758c" translate="yes" xml:space="preserve">
          <source>These ID's are unique enough for most purposes. For identical ids to be generated you must have 2 processes with the same PID generate IDs at the same time with the same current state of the incrementing integer. This is a perfectly reasonable thing to expect to happen across multiple machines, but is quite unlikely to happen on one machine.</source>
          <target state="translated">这些ID对于大多数目的来说都是唯一的。要想生成相同的ID,你必须让2个具有相同PID的进程同时生成ID,且增量整数的当前状态相同。这在多台机器上发生是完全合理的,但在一台机器上发生的可能性很小。</target>
        </trans-unit>
        <trans-unit id="4fb65d165e3bae5f5ca82f785cf62dfbdc24692e" translate="yes" xml:space="preserve">
          <source>These JSON atoms become &lt;code&gt;JSON::PP::true&lt;/code&gt; and &lt;code&gt;JSON::PP::false&lt;/code&gt;, respectively. They are overloaded to act almost exactly like the numbers &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt;. You can check whether a scalar is a JSON boolean by using the &lt;code&gt;JSON::PP::is_bool&lt;/code&gt; function.</source>
          <target state="translated">这些JSON原子分别变为 &lt;code&gt;JSON::PP::true&lt;/code&gt; 和 &lt;code&gt;JSON::PP::false&lt;/code&gt; 。它们被重载以几乎完全像数字 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 那样起作用。您可以使用 &lt;code&gt;JSON::PP::is_bool&lt;/code&gt; 函数检查标量是否为JSON布尔值。</target>
        </trans-unit>
        <trans-unit id="8f188e4230a9960392a0f6434bcd9cdb687b2105" translate="yes" xml:space="preserve">
          <source>These actually run the tests, analogous to the functions in Test::More.</source>
          <target state="translated">这些实际上是运行测试,类似于Test::More中的函数。</target>
        </trans-unit>
        <trans-unit id="47b609b8bdbe47393836decca9fbf56107eb37fe" translate="yes" xml:space="preserve">
          <source>These all match a single codepoint with the given property. Use &lt;code&gt;\P&lt;/code&gt; in place of &lt;code&gt;\p&lt;/code&gt; to match one codepoint lacking that property.</source>
          <target state="translated">这些都与具有给定属性的单个代码点匹配。使用 &lt;code&gt;\P&lt;/code&gt; 代替 &lt;code&gt;\p&lt;/code&gt; 可以匹配缺少该属性的一个代码点。</target>
        </trans-unit>
        <trans-unit id="14b0e821748bdb374700b2c0b377f04dafebe4c2" translate="yes" xml:space="preserve">
          <source>These all might have problems handling infinity right.</source>
          <target state="translated">这些可能都有问题,处理好无穷大。</target>
        </trans-unit>
        <trans-unit id="f193401280223b6d90ef40113a3483800172634b" translate="yes" xml:space="preserve">
          <source>These are Locale::Maketext's assumptions about the class hierarchy formed by all your language classes:</source>
          <target state="translated">这些是Locale::Maketext对你所有语言类所形成的类层次的假设。</target>
        </trans-unit>
        <trans-unit id="7d93f149b189abdf70833601535a585584795222" translate="yes" xml:space="preserve">
          <source>These are Perl bindings for the Gtk toolkit ( &lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; ). The interface changed significantly between versions 1 and 2 so they have separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently it requires an X server on Mac OS, but a 'native' port is underway), and the widgets look the same on every platform: i.e., they don't match the native widgets. As with Wx, the Perl bindings follow the C API closely, and the documentation requires you to read the C documentation to understand it.</source>
          <target state="translated">这些是Gtk工具包（&lt;a href=&quot;http://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt;）的Perl绑定。接口在版本1和版本2之间发生了显着变化，因此它们具有单独的Perl模块。它可以在Unix，Win32和Mac OS X下运行（当前在Mac OS上需要X服务器，但是正在运行&amp;ldquo;本机&amp;rdquo;端口），并且在每个平台上的小部件都相同：即，它们与本机不匹配小部件。与Wx一样，Perl绑定紧密遵循C API，并且该文档要求您阅读C文档以理解它。</target>
        </trans-unit>
        <trans-unit id="5d378e579f5fbdf2d2f9eeda6201720d39ebacec" translate="yes" xml:space="preserve">
          <source>These are Perl bindings for the Gtk toolkit ( &lt;a href=&quot;https://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt; ). The interface changed significantly between versions 1 and 2 so they have separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently it requires an X server on Mac OS, but a 'native' port is underway), and the widgets look the same on every platform: i.e., they don't match the native widgets. As with Wx, the Perl bindings follow the C API closely, and the documentation requires you to read the C documentation to understand it.</source>
          <target state="translated">这些是Gtk工具包（&lt;a href=&quot;https://www.gtk.org&quot;&gt;http://www.gtk.org&lt;/a&gt;）的Perl绑定。接口在版本1和版本2之间发生了很大变化，因此它们具有单独的Perl模块。它可以在Unix，Win32和Mac OS X下运行（当前在Mac OS上需要X服务器，但是正在运行&amp;ldquo;本机&amp;rdquo;端口），并且在每个平台上的小部件都相同：即，它们与本机不匹配小部件。与Wx一样，Perl绑定紧密遵循C API，并且文档要求您阅读C文档以理解它。</target>
        </trans-unit>
        <trans-unit id="06cca08d46609adb849cad691c3d195ff57274e9" translate="yes" xml:space="preserve">
          <source>These are a few notes describing features peculiar to Plan 9 Perl. As such, it is not intended to be a replacement for the rest of the Perl 5 documentation (which is both copious and excellent). If you have any questions to which you can't find answers in these man pages, contact Luther Huffman at lutherh@stratcom.com and we'll try to answer them.</source>
          <target state="translated">这是一些描述 Plan 9 Perl 特有功能的说明。因此,它并不打算取代 Perl 5 的其它文档(它的文档非常丰富和出色)。如果你有任何在这些手册中找不到答案的问题,请联系 Luther Huffman,地址是 lutherh@stratcom.com,我们会尽力解答。</target>
        </trans-unit>
        <trans-unit id="035e487505e2bd7d2a574e14eebe3b30a69fa1a9" translate="yes" xml:space="preserve">
          <source>These are a hotchpotch of opcodes still waiting to be considered</source>
          <target state="translated">这些都是尚待考虑的操作码的热点。</target>
        </trans-unit>
        <trans-unit id="7deedf4836f35aa67f0c08100f5d4987addf81e4" translate="yes" xml:space="preserve">
          <source>These are a record of the hubs an event passes through. Most recent hub is the first one in the list.</source>
          <target state="translated">这些是一个事件所经过的枢纽的记录。最近的枢纽是列表中的第一个枢纽。</target>
        </trans-unit>
        <trans-unit id="ab597ea19704a4092bef6ea8610d0145fc3acd27" translate="yes" xml:space="preserve">
          <source>These are all &quot;getters&quot; which return the data set for these attributes during object construction.</source>
          <target state="translated">这些都是 &quot;获取器&quot;,在对象构建过程中返回这些属性的数据集。</target>
        </trans-unit>
        <trans-unit id="99670b79a346a2bf9e4cb33dd6b8ba8a01dd0f06" translate="yes" xml:space="preserve">
          <source>These are all imported from &lt;a href=&quot;Test2::Util::Facets2Legacy&quot;&gt;Test2::Util::Facets2Legacy&lt;/a&gt;, see that module or &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; for documentation on what they do.</source>
          <target state="translated">这些都是从&lt;a href=&quot;Test2::Util::Facets2Legacy&quot;&gt;Test2 :: Util :: Facets2Legacy导入的&lt;/a&gt;，请参阅该模块或&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;以获得有关其功能的文档。</target>
        </trans-unit>
        <trans-unit id="c6ad141ea95625d5f83dc60a511981417685e463" translate="yes" xml:space="preserve">
          <source>These are also the typical steps involved in writing a computer program. This makes perfect sense, because regular expressions are essentially programs written in a little computer language that specifies patterns.</source>
          <target state="translated">这些也是编写计算机程序的典型步骤。这是很有意义的,因为正则表达式本质上是用一种指定模式的小计算机语言编写的程序。</target>
        </trans-unit>
        <trans-unit id="c614a56da53c8268e03927a0382855aa589c9ffe" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8',
...)&lt;/code&gt; .</source>
          <target state="translated">这些是备用语法 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 和 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c836f0954439914f97915361085c611a4a6522e" translate="yes" xml:space="preserve">
          <source>These are alternate syntaxes for &lt;code&gt;decode('utf8', ...)&lt;/code&gt; and &lt;code&gt;encode('utf8', ...)&lt;/code&gt;. Do not use these functions for data exchange. Instead use &lt;code&gt;decode('UTF-8', ...)&lt;/code&gt; and &lt;code&gt;encode('UTF-8', ...)&lt;/code&gt;; see &lt;a href=&quot;#What%27s-the-difference-between-UTF-8-and-utf8%3F&quot;&gt;&quot;What's the difference between UTF-8 and utf8?&quot;&lt;/a&gt; below.</source>
          <target state="translated">这些是备用语法 &lt;code&gt;decode('utf8', ...)&lt;/code&gt; 和 &lt;code&gt;encode('utf8', ...)&lt;/code&gt; 。请勿使用这些功能进行数据交换。而是使用 &lt;code&gt;decode('UTF-8', ...)&lt;/code&gt; 和 &lt;code&gt;encode('UTF-8', ...)&lt;/code&gt; ; 请参阅&lt;a href=&quot;#What%27s-the-difference-between-UTF-8-and-utf8%3F&quot;&gt;&amp;ldquo; UTF-8和utf8有什么区别？&amp;rdquo; &lt;/a&gt;以下。</target>
        </trans-unit>
        <trans-unit id="a504c2130962ba4555e63c517df7cfb6c3415a56" translate="yes" xml:space="preserve">
          <source>These are based on what command.com does on Win98. They may be wrong for other Windows shells, I don't know.</source>
          <target state="translated">这些都是基于command.com在Win98上所做的。对于其他的Windows shell,它们可能是错误的,我不知道。</target>
        </trans-unit>
        <trans-unit id="2c07d55f7a2a925e22fec82104bd39d3cabc4301" translate="yes" xml:space="preserve">
          <source>These are called mid-endian, middle-endian, mixed-endian, or just weird.</source>
          <target state="translated">这些被称为中段、中段、混合段,或者只是怪异。</target>
        </trans-unit>
        <trans-unit id="e533ef7489d17854e05259c84118c5f3b5f226af" translate="yes" xml:space="preserve">
          <source>These are called whenever a context is initialized. That means when a new instance is created. These hooks are &lt;b&gt;NOT&lt;/b&gt; called every time something requests a context, just when a new one is created.</source>
          <target state="translated">每当初始化上下文时，就会调用它们。这意味着在创建新实例时。每次有人请求上下文时，即创建新的钩子时，都&lt;b&gt;不会&lt;/b&gt;调用这些钩子。</target>
        </trans-unit>
        <trans-unit id="c0e21c37ef5bc936dc62910a2c3001a6fca894bc" translate="yes" xml:space="preserve">
          <source>These are called whenever a context is released. That means when the last reference to the instance is about to be destroyed. These hooks are &lt;b&gt;NOT&lt;/b&gt; called every time &lt;code&gt;$ctx-&amp;gt;release&lt;/code&gt; is called.</source>
          <target state="translated">每当上下文被释放时，这些被调用。这意味着对实例的最后一个引用即将被销毁。每次调用 &lt;code&gt;$ctx-&amp;gt;release&lt;/code&gt; 时都&lt;b&gt;不会&lt;/b&gt;调用这些钩子。</target>
        </trans-unit>
        <trans-unit id="3a9105b34a20a7fdd4e6d997e3a1e1ad31f3f321" translate="yes" xml:space="preserve">
          <source>These are covered in the following section.</source>
          <target state="translated">这些内容将在下一节中介绍。</target>
        </trans-unit>
        <trans-unit id="7333c3db6eebc965b9acc79a29ea8b8aa13ff1d3" translate="yes" xml:space="preserve">
          <source>These are derived by using &lt;code&gt;strftime()&lt;/code&gt;, and not all versions of that function know about them. &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for these on such systems.</source>
          <target state="translated">这些是通过使用 &lt;code&gt;strftime()&lt;/code&gt; 派生的，并不是该函数的所有版本都知道它们。在此类系统上为这些返回 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="543fcf9df34b75f159b226a9706c32a67f612f3d" translate="yes" xml:space="preserve">
          <source>These are effectively no-ops.</source>
          <target state="translated">这些实际上都是无奈之举。</target>
        </trans-unit>
        <trans-unit id="f6dbfbbee534ca87c61eabe600b034f42390dde5" translate="yes" xml:space="preserve">
          <source>These are equivalent</source>
          <target state="translated">这些都相当于</target>
        </trans-unit>
        <trans-unit id="2c34193d065093cc77699a0d9ca713a7565b5a4e" translate="yes" xml:space="preserve">
          <source>These are fetched from one or more mirrored CPAN (Comprehensive Perl Archive Network) sites and unpacked in a dedicated directory.</source>
          <target state="translated">这些都是从一个或多个CPAN(Comprehensive Perl Archive Network,综合Perl档案网)镜像站点中获取的,并在一个专用目录中解压。</target>
        </trans-unit>
        <trans-unit id="1218c4eafb2ac24b7f5a6bfc47e38d53cda6dbb8" translate="yes" xml:space="preserve">
          <source>These are fprintf()/vfprintf() equivalents.</source>
          <target state="translated">这些都是fprintf()/vfprintf()的等价物。</target>
        </trans-unit>
        <trans-unit id="c9080846b04ed2aaef61ea34f53f7101d2c5f347" translate="yes" xml:space="preserve">
          <source>These are functions for searching through directory trees doing work on each file found similar to the Unix</source>
          <target state="translated">这些功能用于搜索目录树,对找到的每个文件进行工作,类似于Unix的</target>
        </trans-unit>
        <trans-unit id="82d3c39fd0ecabf1c8dc2de9284d7be1c98f1d46" translate="yes" xml:space="preserve">
          <source>These are general guidelines for how to write POD documentation for Perl scripts and modules, based on general guidelines for writing good UNIX man pages. All of these guidelines are, of course, optional, but following them will make your documentation more consistent with other documentation on the system.</source>
          <target state="translated">这些是关于如何为Perl脚本和模块编写POD文档的一般指导原则,这些指导原则是基于编写良好的UNIX手册的一般指导原则。当然,所有这些指导原则都是可选的,但遵循它们将使你的文档与系统中的其他文档更加一致。</target>
        </trans-unit>
        <trans-unit id="a253bda8befb626a9c36c82d1823fdc871bc54a9" translate="yes" xml:space="preserve">
          <source>These are hooks that allow you to add custom behavior to actions taken by Test2 and tools built on top of it.</source>
          <target state="translated">这些都是钩子,允许您添加自定义行为到Test2和在它之上构建的工具所采取的行动。</target>
        </trans-unit>
        <trans-unit id="dad0e81d2d1dfbeb7b354f138de6b73ae95d9158" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl from source. This version of Perl requires the dynamic linking support that is found in OpenVOS Release 17.1 and thus is not supported on OpenVOS Release 17.0 or earlier releases.</source>
          <target state="translated">这些都是关于从源码构建Perl的说明。这个版本的Perl需要OpenVOS 17.1版中的动态链接支持,因此不支持OpenVOS 17.0版或更早的版本。</target>
        </trans-unit>
        <trans-unit id="c8591b5e35cdacaa99ac7aebf4d9655f41e44d08" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under DOS (or w??), using DJGPP v2.03 or later. Under w95 long filenames are supported.</source>
          <target state="translated">这些是在DOS(或w??)下构建Perl的说明,使用DJGPP v2.03或更高版本。在w95下,支持长文件名。</target>
        </trans-unit>
        <trans-unit id="1ebba6a1db0c9a0e274e92574c949eaf7a4b8fb7" translate="yes" xml:space="preserve">
          <source>These are instructions for building Perl under Windows 2000 and later.</source>
          <target state="translated">这些都是在Windows 2000和更高版本下构建Perl的说明。</target>
        </trans-unit>
        <trans-unit id="56039c5fbea93b2739212ecaf27c30cc3edfb9c5" translate="yes" xml:space="preserve">
          <source>These are intended to be services performed by the clients of this API.</source>
          <target state="translated">这些服务旨在由该API的客户端执行。</target>
        </trans-unit>
        <trans-unit id="6d5e58ad94dd8e12f40343c4fe00cb855a20e455" translate="yes" xml:space="preserve">
          <source>These are just the most common definitions of &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; in Perl. There may well be others. For example, on an EBCDIC implementation such as z/OS (OS/390) or OS/400 (using the ILE, the PASE is ASCII-based) the above material is similar to &quot;Unix&quot; but the code numbers change:</source>
          <target state="translated">这些只是Perl中最常见的 &lt;code&gt;\n&lt;/code&gt; 和 &lt;code&gt;\r&lt;/code&gt; 定义。可能还有其他人。例如，在诸如z / OS（OS / 390）或OS / 400之类的EBCDIC实现中（使用ILE，PASE基于ASCII），上述内容类似于&amp;ldquo; Unix&amp;rdquo;，但是代码号有所变化：</target>
        </trans-unit>
        <trans-unit id="e2a1ebead9f267c39fe9da94bb4791dac090d0bc" translate="yes" xml:space="preserve">
          <source>These are low-level functions to extract and use capabilities from a terminal capability (termcap) database.</source>
          <target state="translated">这些是从终端能力(termcap)数据库中提取和使用能力的低级函数。</target>
        </trans-unit>
        <trans-unit id="6e1b104453fcd9be9aa03bca5a6390babe809d8b" translate="yes" xml:space="preserve">
          <source>These are methods that you may find it handy to use, generally from %Lexicon routines of yours (whether expressed as Bracket Notation or not).</source>
          <target state="translated">这些都是你可能会觉得很方便使用的方法,一般来自你的%Lexicon例程(无论是否用括号表示)。</target>
        </trans-unit>
        <trans-unit id="9a95859137ef50d66689fe259453639b6dce722a" translate="yes" xml:space="preserve">
          <source>These are methods which are used in the course of writing a test but are not themselves tests.</source>
          <target state="translated">这些方法是在编写测试的过程中使用的,但其本身并不是测试。</target>
        </trans-unit>
        <trans-unit id="14859e3783966bf81d1767be73584f0ff1e6b683" translate="yes" xml:space="preserve">
          <source>These are methods which help writing cross-platform code.</source>
          <target state="translated">这些方法有助于编写跨平台代码。</target>
        </trans-unit>
        <trans-unit id="10fcdff63f0636b8e542860baaf4e1184f58638e" translate="yes" xml:space="preserve">
          <source>These are methods which produce make targets.</source>
          <target state="translated">这些都是产生使目标的方法。</target>
        </trans-unit>
        <trans-unit id="10849203134f1b9b6877d6c9803884e2fb3562a9" translate="yes" xml:space="preserve">
          <source>These are modules that did not break, but had broken test suites that have since been fixed.</source>
          <target state="translated">这些都是没有坏掉的模块,但有坏掉的测试套件,后来已经修复了。</target>
        </trans-unit>
        <trans-unit id="5242bfa15c97f14acba2cd2d00dbeca39084930f" translate="yes" xml:space="preserve">
          <source>These are most easily explained from the bottom up.</source>
          <target state="translated">这些都是最容易从根本上解释的。</target>
        </trans-unit>
        <trans-unit id="97c6eb63dac1e7db10f1e2e9276ff1ad9b5b7b24" translate="yes" xml:space="preserve">
          <source>These are not supplied by default, but must be explicitly imported. They are lexically scoped.</source>
          <target state="translated">它们不是默认提供的,而是必须明确导入的。它们是词法范围的。</target>
        </trans-unit>
        <trans-unit id="eff3d42df745b107b6d797477e3d4e7f8d24cab3" translate="yes" xml:space="preserve">
          <source>These are not the very basics, though. It is assumed that you already know the difference between bytes and characters, and realise (and accept!) that there are many different character sets and encodings, and that your program has to be explicit about them. Recommended reading is &quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)&quot; by Joel Spolsky, at &lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;.</source>
          <target state="translated">但是，这些都不是最基本的。假定您已经知道字节和字符之间的区别，并意识到（并接受！）有许多不同的字符集和编码，并且您的程序必须对此有明确的说明。推荐读物是Joel Spolsky的&amp;ldquo;绝对绝对肯定地，每个软件开发人员绝对必须了解Unicode和字符集（无借口！）&amp;rdquo;，网址为&lt;a href=&quot;http://joelonsoftware.com/articles/Unicode.html&quot;&gt;http://joelonsoftware.com/articles/Unicode.html&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd6ee1d320e203631c0d3d164abcb5a87fff3dcb" translate="yes" xml:space="preserve">
          <source>These are often used in macro definitions. Note that you can't return a value out of them.</source>
          <target state="translated">这些常用于宏定义中。注意,你不能从它们中返回一个值。</target>
        </trans-unit>
        <trans-unit id="3cbc1741b6d34271e2ec1a26ca7d6418baa0ebb4" translate="yes" xml:space="preserve">
          <source>These are only present when &lt;code&gt;netorder&lt;/code&gt; is FALSE. These are the sizes of various C datatypes of the perl that created this image. These must match the current perl for the image to be readable by Storable.</source>
          <target state="translated">这些仅在 &lt;code&gt;netorder&lt;/code&gt; 为FALSE时出现。这些是创建此映像的perl的各种C数据类型的大小。这些必须与当前perl匹配才能使Storable读取图像。</target>
        </trans-unit>
        <trans-unit id="920887e803f6cf14e09050db36f20df3c6ead9d1" translate="yes" xml:space="preserve">
          <source>These are only supported if your system has &amp;lt;</source>
          <target state="translated">仅当系统具有&amp;lt;</target>
        </trans-unit>
        <trans-unit id="140e31bd5bffd898fd2913825a2d2d23dcf95138" translate="yes" xml:space="preserve">
          <source>These are pairwise exclusive, i.e. compact or loose, vt or ascii.</source>
          <target state="translated">这些都是成对的,即紧凑或松散,vt或ascii。</target>
        </trans-unit>
        <trans-unit id="ee44bfea63f0502e44e3769d9962bf8126742be7" translate="yes" xml:space="preserve">
          <source>These are passed in to your plugin's &lt;code&gt;load()&lt;/code&gt; class method (if it has one), along with a reference to the &lt;code&gt;App::Prove&lt;/code&gt; object that is invoking your plugin:</source>
          <target state="translated">这些将传递给您插件的 &lt;code&gt;load()&lt;/code&gt; 类方法（如果有的话），以及对调用您插件的 &lt;code&gt;App::Prove&lt;/code&gt; 对象的引用：</target>
        </trans-unit>
        <trans-unit id="0a54cca37ec252d12e0edbfcecfc7fffff46a74a" translate="yes" xml:space="preserve">
          <source>These are probematic. The C standard says that these should be considered punctuation in the C locale (and the POSIX standard defers to the C standard), and Unicode is generally considered a superset of the C locale. But Unicode has added an extra category, &quot;Symbol&quot;, and classifies these particular characters as being symbols. Most UTF-8 locales have them treated as punctuation, so that &lt;a href=&quot;http://man.he.net/man2/ispunct&quot;&gt;ispunct(2)&lt;/a&gt; returns non-zero for them. But a few locales have it return 0. Perl takes the first approach, not using &lt;code&gt;ispunct()&lt;/code&gt; at all (see &lt;a href=&quot;perlrecharclass#%5B5%5D&quot;&gt;Note [5] in perlrecharclass&lt;/a&gt;), and this message is raised to notify you that you are getting Perl's approach, not the locale's.</source>
          <target state="translated">这些是探究性的。 C标准说，应该在C语言环境中将它们视为标点符号（而POSIX标准则遵循C语言标准），而Unicode通常被视为C语言环境的超集。但是Unicode增加了一个额外的类别&amp;ldquo; Symbol&amp;rdquo;，并将这些特殊字符分类为符号。大多数UTF-8语言环境将它们视为标点符号，因此&lt;a href=&quot;http://man.he.net/man2/ispunct&quot;&gt;ispunct（2）&lt;/a&gt;为它们返回非零值。但是一些语言环境使它返回 &lt;code&gt;ispunct()&lt;/code&gt; 采取第一种方法，根本不使用ispunct（）（请参见&lt;a href=&quot;perlrecharclass#%5B5%5D&quot;&gt;perlrecharclass中的注[5]&lt;/a&gt;），并且出现此消息是为了通知您您正在使用Perl的方法，而不是语言环境的。</target>
        </trans-unit>
        <trans-unit id="87db38161fab9301a6c38e350a75487ce9dba0c7" translate="yes" xml:space="preserve">
          <source>These are readline issues and can only be fixed by studying readline configuration on your architecture and adjusting the referenced file accordingly. Please make a backup of the &lt;code&gt;/etc/inputrc&lt;/code&gt; or &lt;code&gt;~/.inputrc&lt;/code&gt; and edit them. Quite often harmless changes like uppercasing or lowercasing some arguments solves the problem.</source>
          <target state="translated">这些是readline问题，只能通过研究体系结构上的readline配置并相应地调整引用的文件来解决。请备份 &lt;code&gt;/etc/inputrc&lt;/code&gt; 或 &lt;code&gt;~/.inputrc&lt;/code&gt; 并进行编辑。经常采用无害更改，例如使用大写或小写一些参数来解决问题。</target>
        </trans-unit>
        <trans-unit id="b38ff2c237d2189cfc8068063c988ad558800625" translate="yes" xml:space="preserve">
          <source>These are scripts which will check the source things like ANSI C violations, POD encoding issues, etc.</source>
          <target state="translated">这些脚本会检查源头的东西,比如ANSI C违规,POD编码问题等。</target>
        </trans-unit>
        <trans-unit id="08a1e3d5222d26c7ad00377b2f49dd3e19a69282" translate="yes" xml:space="preserve">
          <source>These are shortcuts for &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt;</source>
          <target state="translated">这些是 &lt;code&gt;$token-&amp;gt;tag() eq &lt;i&gt;somestring&lt;/i&gt;&lt;/code&gt; &lt;i&gt;somestring的&lt;/i&gt;快捷方式&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="34937e959a1c366f5128e5b9fde3a8ddb4bd5e6f" translate="yes" xml:space="preserve">
          <source>These are similar to article(), body() and head(), but rather than returning the requested data directly, they return a tied filehandle from which to read the article.</source>
          <target state="translated">这些方法类似于article()、body()和head(),但它们不是直接返回所请求的数据,而是返回一个绑定的filehandle,用来读取文章。</target>
        </trans-unit>
        <trans-unit id="992979db9b32df20ed312f9df292c8122981c5bf" translate="yes" xml:space="preserve">
          <source>These are the files in the Perl release that contain references to Cygwin. These very brief notes attempt to explain the reason for all conditional code. Hopefully, keeping this up to date will allow the Cygwin port to be kept as clean as possible.</source>
          <target state="translated">这些是Perl版本中包含对Cygwin的引用的文件。这些非常简短的注释试图解释所有条件代码的原因。希望保持这些文件的更新能够使 Cygwin 移植版本尽可能地保持干净。</target>
        </trans-unit>
        <trans-unit id="75ac46c3e2da8e520c552d106b13b25422f4ae84" translate="yes" xml:space="preserve">
          <source>These are the functions that are available, they may either be called as functions or class methods:</source>
          <target state="translated">这些都是可用的函数,它们可以作为函数或类方法被调用。</target>
        </trans-unit>
        <trans-unit id="da1f03a776fe8bedafea0b23935ca2ad13f5c2fe" translate="yes" xml:space="preserve">
          <source>These are the hash data structures that are available:</source>
          <target state="translated">这些都是可用的哈希数据结构。</target>
        </trans-unit>
        <trans-unit id="cf5f4459a98cf4ec50466a764ec50e3aa2bdb1de" translate="yes" xml:space="preserve">
          <source>These are the newest form of versions, and correspond to Perl's own version style beginning with 5.6.0. Starting with Perl 5.10.0, and most likely Perl 6, this is likely to be the preferred form. This method normally requires that the input parameter be quoted, although Perl's after 5.8.1 can use v-strings as a special form of quoting, but this is highly discouraged.</source>
          <target state="translated">这些是版本的最新形式,对应于 Perl 自己从 5.6.0 开始的版本风格。从Perl 5.10.0开始,很可能从Perl 6开始,这可能是首选形式。这种方法通常要求输入参数要加引号,尽管 5.8.1 之后的 Perl 可以使用 v 字符串作为一种特殊的引号形式,但我们非常不鼓励这样做。</target>
        </trans-unit>
        <trans-unit id="321abf696e1ac3f1c7e8ae4631a3e0352eed8069" translate="yes" xml:space="preserve">
          <source>These are the same as color('attribute') and can be used if you prefer typing:</source>
          <target state="translated">这些和color('attribute')一样,如果你喜欢打字,也可以使用。</target>
        </trans-unit>
        <trans-unit id="4187810dcd65ec8ff13d408cac42774a760ce9e6" translate="yes" xml:space="preserve">
          <source>These are the signals which a program might normally expect to encounter and which by default cause it to terminate. They are HUP, INT, PIPE and TERM.</source>
          <target state="translated">这些是程序通常会遇到的信号,默认情况下会导致程序终止。它们是HUP、INT、PIPE和TERM。</target>
        </trans-unit>
        <trans-unit id="50c4067312fedca516066cb81563c6787bf50478" translate="yes" xml:space="preserve">
          <source>These are the signals which were trapped by default by the old &lt;b&gt;sigtrap&lt;/b&gt; interface, they are ABRT, BUS, EMT, FPE, ILL, PIPE, QUIT, SEGV, SYS, TERM, and TRAP. If no signals or signals lists are passed to &lt;b&gt;sigtrap&lt;/b&gt;, this list is used.</source>
          <target state="translated">这些信号是旧的&lt;b&gt;sigtrap&lt;/b&gt;接口默认捕获的信号，它们是ABRT，BUS，EMT，FPE，ILL，PIPE，QUIT，SEGV，SYS，TERM和TRAP。如果没有信号或信号列表传递给&lt;b&gt;sigtrap&lt;/b&gt;，则使用此列表。</target>
        </trans-unit>
        <trans-unit id="cea91aaa564fccd3f4852969e3ebc12f20249663" translate="yes" xml:space="preserve">
          <source>These are the six methods that are exported as default.</source>
          <target state="translated">这是六种作为默认导出的方法。</target>
        </trans-unit>
        <trans-unit id="107044185540681260f831f30270844d122d9842" translate="yes" xml:space="preserve">
          <source>These are the things that you can put in the parameters to plan:</source>
          <target state="translated">这些都是你可以放在参数中规划的东西。</target>
        </trans-unit>
        <trans-unit id="cae5aa495786f78d7786c67162eeac298ded8720" translate="yes" xml:space="preserve">
          <source>These are to do with constructing a language handle:</source>
          <target state="translated">这些都与构建语言句柄有关。</target>
        </trans-unit>
        <trans-unit id="922c34b791a974e411c2469dcdbd7774f0e10924" translate="yes" xml:space="preserve">
          <source>These are used to get/set the 'active' attribute. When true this attribute will force &lt;code&gt;hub-&amp;gt;finalize()&lt;/code&gt; to take action even if there is no plan, and no tests have been run. This flag is useful for plugins that add follow-up behaviors that need to run even if no events are seen.</source>
          <target state="translated">这些用于获取/设置&amp;ldquo;活动&amp;rdquo;属性。如果为true &lt;code&gt;hub-&amp;gt;finalize()&lt;/code&gt; 即使没有计划，也没有运行测试，该属性将强制hub-&amp;gt; finalize（）采取行动。该标志对于添加了即使没有看到事件也需要运行的后续行为的插件很有用。</target>
        </trans-unit>
        <trans-unit id="25e9dcb05d530b0eaaf353a6122269805fd5136a" translate="yes" xml:space="preserve">
          <source>These are useful shortcuts to save on the typing.</source>
          <target state="translated">这些都是有用的快捷键,可以节省打字的时间。</target>
        </trans-unit>
        <trans-unit id="20957167192887677e71195c4861c8a5596fbdd0" translate="yes" xml:space="preserve">
          <source>These are valid only on ASCII platforms. Starting in Perl v5.22, simply changing the octal constants to equivalent &lt;code&gt;\N{U+...}&lt;/code&gt; values makes them portable:</source>
          <target state="translated">这些仅在ASCII平台上有效。从Perl v5.22开始，只需将八进制常量更改为等效的 &lt;code&gt;\N{U+...}&lt;/code&gt; 值，即可使用它们：</target>
        </trans-unit>
        <trans-unit id="121235b5fae01f0300690949bf870a51f4a735f5" translate="yes" xml:space="preserve">
          <source>These are various utility functions for manipulating UTF8-encoded strings. For the uninitiated, this is a method of representing arbitrary Unicode characters as a variable number of bytes, in such a way that characters in the ASCII range are unmodified, and a zero byte never appears within non-zero characters.</source>
          <target state="translated">这些是各种用于操作UTF8编码字符串的实用函数。对于新手来说,这是一种将任意Unicode字符表示为可变字节数的方法,这样一来,ASCII范围内的字符就不会被修改,而且零字节永远不会出现在非零字符中。</target>
        </trans-unit>
        <trans-unit id="a8c3820acf49b8050b73972a9c61ce1cf6f1d9df" translate="yes" xml:space="preserve">
          <source>These are versions of the macros which take an explicit interpreter as an argument.</source>
          <target state="translated">这些都是宏的版本,它们以一个显式解释器作为参数。</target>
        </trans-unit>
        <trans-unit id="b056cc5f487123530dc637016a4d1c22c28e035c" translate="yes" xml:space="preserve">
          <source>These are:</source>
          <target state="translated">这些是:</target>
        </trans-unit>
        <trans-unit id="16d16f3cffc4ac9689654ee5a738c8ecadd74b82" translate="yes" xml:space="preserve">
          <source>These can all be disabled with</source>
          <target state="translated">这些都可以通过</target>
        </trans-unit>
        <trans-unit id="e41fb2d0ecca05f4e2a4a44f51aab35f28ed5c33" translate="yes" xml:space="preserve">
          <source>These can be combined into a single regexp with a three-way alternation:</source>
          <target state="translated">这些都可以组合成一个三向交替的regexp。</target>
        </trans-unit>
        <trans-unit id="172164005a20965708fb5481ccabdedd39caefb5" translate="yes" xml:space="preserve">
          <source>These can be imported, or called as methods on the class.</source>
          <target state="translated">这些都可以被导入,或者作为类的方法被调用。</target>
        </trans-unit>
        <trans-unit id="299d50e1fb824778d0759c0f08b0488ba008e1c8" translate="yes" xml:space="preserve">
          <source>These can be used to add filters. Filters can modify, replace, or remove events before anything else can see them.</source>
          <target state="translated">这些可以用来添加过滤器。过滤器可以在其他任何东西看到它们之前修改、替换或删除事件。</target>
        </trans-unit>
        <trans-unit id="4eeb7ad8186044a1f9cb1af61a0f21c3ae49622d" translate="yes" xml:space="preserve">
          <source>These can be used to remove filters and pre_filters. The &lt;code&gt;$sub&lt;/code&gt; argument is the reference returned by &lt;code&gt;filter()&lt;/code&gt; or &lt;code&gt;pre_filter()&lt;/code&gt;.</source>
          <target state="translated">这些可用于删除过滤器和pre_filters。的 &lt;code&gt;$sub&lt;/code&gt; 参数是由返回的参考 &lt;code&gt;filter()&lt;/code&gt; 或 &lt;code&gt;pre_filter()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3356ead5e79e95f8cf87a7aefe66f6dc48400c35" translate="yes" xml:space="preserve">
          <source>These can be used to turn IPC waiting on and off, or check the current value of the flag.</source>
          <target state="translated">这些可以用来开启和关闭IPC等待,或者检查标志的当前值。</target>
        </trans-unit>
        <trans-unit id="70b66993a553be0939fc1c087fcb0c54c5cdbbb0" translate="yes" xml:space="preserve">
          <source>These cases below violate the &quot;remainder has the sign of the second of the two arguments&quot;, since they wouldn't match up otherwise.</source>
          <target state="translated">下面这些情况违反了 &quot;余者有二辩之征&quot;,因为不这样做就对不上号。</target>
        </trans-unit>
        <trans-unit id="1fd6f63888a958514d8ebfc5074b3f479f8a49f9" translate="yes" xml:space="preserve">
          <source>These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="translated">这些类以明显的方式对应于名称相似的底层C结构。继承层次结构模仿了底层C语言的 &quot;继承&quot;。</target>
        </trans-unit>
        <trans-unit id="5f11a03556aad53a0a7bc63133f793375ad1dc66" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">这些代码块可以使用 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 前缀，以给出子例程的外观（尽管这不是很好的样式）。应该注意的是，这些代码块实际上并不是作为命名子例程存在的（尽管它们看起来很漂亮）。解决这个问题的原因是，您在程序中可以拥有&lt;b&gt;多个&lt;/b&gt;这些代码块，并且它们将在适当的时候&lt;b&gt;全部&lt;/b&gt;执行。因此，您不能按名称执行任何这些代码块。</target>
        </trans-unit>
        <trans-unit id="135b8ae6adb863f81a824e0e084d6f888cb7a313" translate="yes" xml:space="preserve">
          <source>These code blocks can be prefixed with &lt;code&gt;sub&lt;/code&gt; to give the appearance of a subroutine (although this is not considered good style). One should note that these code blocks don't really exist as named subroutines (despite their appearance). The thing that gives this away is the fact that you can have &lt;b&gt;more than one&lt;/b&gt; of these code blocks in a program, and they will get &lt;b&gt;all&lt;/b&gt; executed at the appropriate moment. So you can't execute any of these code blocks by name.</source>
          <target state="translated">这些代码块可以使用 &lt;code&gt;sub&lt;/code&gt; 前缀，以给出子例程的外观（尽管这不是很好的样式）。应该注意的是，这些代码块实际上并不以命名子例程的形式存在（尽管它们看起来很漂亮）。解决这个问题的原因是，您可以在一个程序中拥有&lt;b&gt;多个&lt;/b&gt;这些代码块，并且它们将在适当的时候&lt;b&gt;全部&lt;/b&gt;执行。因此，您不能按名称执行任何这些代码块。</target>
        </trans-unit>
        <trans-unit id="97b3b7dd37ba8a222332eb2984faedc72082d594" translate="yes" xml:space="preserve">
          <source>These commands take any number of arguments and investigate what is necessary to perform the action. Argument processing is as follows:</source>
          <target state="translated">这些命令接受任何数量的参数,并调查执行动作所需的内容。参数处理方法如下。</target>
        </trans-unit>
        <trans-unit id="1935b5d017d485fb4c9165c42281556d84b0d309" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">这些编译阶段关键字记录在&lt;a href=&quot;../perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod&lt;/a&gt;中的BEGIN，UNITCHECK，CHECK，INIT和END中。</target>
        </trans-unit>
        <trans-unit id="cfb52f790e80f5471de59b15936b8e64b57f38e3" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;.</source>
          <target state="translated">这些编译阶段关键字记录在&lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;perlmod&lt;/a&gt;中的&amp;ldquo; BEGIN，UNITCHECK，CHECK，INIT和END&amp;rdquo;中。</target>
        </trans-unit>
        <trans-unit id="d7f96e99d050cd5ba24ce3555c69d5626ea1ddfe" translate="yes" xml:space="preserve">
          <source>These compile phase keywords are documented in &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;.</source>
          <target state="translated">这些编译阶段关键字记录在&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;perlmod&lt;/a&gt;中的BEGIN，UNITCHECK，CHECK，INIT和END中。</target>
        </trans-unit>
        <trans-unit id="97251eb9b01071889514a18b4c3f732daa85a7b2" translate="yes" xml:space="preserve">
          <source>These constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">默认情况下， &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 不导入这些常量。</target>
        </trans-unit>
        <trans-unit id="4a9cdeb250fa9e2cb61227f4240cb75a90c2a763" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; .</source>
          <target state="translated">这些常量也可以与完全限定的名称一起使用，例如。 &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38e4d9e8ffca41ef0f0b08e38acc59353b323e18" translate="yes" xml:space="preserve">
          <source>These constants can also be used with fully qualified names, eg. &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt;.</source>
          <target state="translated">这些常量也可以与完全限定的名称一起使用，例如。 &lt;code&gt;SDBM_File::PAGFEXT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24ced089c50142be624d4fe7279d5e7e8267bf6" translate="yes" xml:space="preserve">
          <source>These conversions are governed by the following general rules:</source>
          <target state="translated">这些转换须遵守以下一般规则:</target>
        </trans-unit>
        <trans-unit id="8ebb9f4990eefbf7af18e7f37f2d673045cd0b59" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt; ) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">根据需要根据上下文调用这些转换。例如，在将重载对象作为 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 的参数传递时，可以使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; （stringify）的子例程，而对于 &lt;code&gt;'bool'&lt;/code&gt; 的子例程可以在流控制语句（如 &lt;code&gt;while&lt;/code&gt; ）的条件下进行测试时使用。或三元 &lt;code&gt;?:&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="380117f70d82e15acd1450b3ca50a68f2d64bbe1" translate="yes" xml:space="preserve">
          <source>These conversions are invoked according to context as necessary. For example, the subroutine for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; (stringify) may be used where the overloaded object is passed as an argument to &lt;code&gt;print&lt;/code&gt;, and that for &lt;code&gt;'bool'&lt;/code&gt; where it is tested in the condition of a flow control statement (like &lt;code&gt;while&lt;/code&gt;) or the ternary &lt;code&gt;?:&lt;/code&gt; operation.</source>
          <target state="translated">根据需要根据上下文调用这些转换。例如，在将重载对象作为 &lt;code&gt;print&lt;/code&gt; 的参数传递时，可以使用 &lt;code&gt;'&quot;&quot;'&lt;/code&gt; （stringify）的子例程，而对于 &lt;code&gt;'bool'&lt;/code&gt; 的子例程可以在流控制语句（例如 &lt;code&gt;while&lt;/code&gt; ）的条件下进行测试时使用。或三元 &lt;code&gt;?:&lt;/code&gt; 操作。</target>
        </trans-unit>
        <trans-unit id="a40ed2255002784d89744404c25a8dfb75189849" translate="yes" xml:space="preserve">
          <source>These correspond (loosely) to fgetpos() and fsetpos(). Rather than stdio's Fpos_t they expect a &quot;Perl Scalar Value&quot; to be passed. What is stored there should be considered opaque. The layout of the data may vary from handle to handle. When not using stdio or if platform does not have the stdio calls then they are implemented in terms of PerlIO_tell() and PerlIO_seek().</source>
          <target state="translated">这些函数与 fgetpos()和 fsetpos()相对应 (宽泛地).它们不是 stdio 的 Fpos_t,而是期望传递 &quot;Perl Scalar Value&quot;.它们期望传递的是一个 &quot;Perl Scalar Value&quot;,而不是stdio的Fpos_t。那里存储的内容应该被认为是不透明的。数据的布局可能因句柄而异。当不使用stdio或如果平台没有stdio调用,那么它们是用PerlIO_tell()和PerlIO_seek()来实现的。</target>
        </trans-unit>
        <trans-unit id="3ab9bc2795a0ea30e5174b44302c5f3390695af2" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt; .</source>
          <target state="translated">这些在功能上对应于fread（）和fwrite（），但参数和返回值不同。PerlIO_read（）和PerlIO_write（）签名已在更合理的低级read（）和write（）函数上建模：相反，首先传递&amp;ldquo; file&amp;rdquo;参数，只有一个&amp;ldquo; count&amp;rdquo;，并且返回值可以区分错误和 &lt;code&gt;EOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6709bb996b1b03a70d9886cbb196b8cf31182557" translate="yes" xml:space="preserve">
          <source>These correspond functionally to fread() and fwrite() but the arguments and return values are different. The PerlIO_read() and PerlIO_write() signatures have been modeled on the more sane low level read() and write() functions instead: The &quot;file&quot; argument is passed first, there is only one &quot;count&quot;, and the return value can distinguish between error and &lt;code&gt;EOF&lt;/code&gt;.</source>
          <target state="translated">这些在功能上对应于fread（）和fwrite（），但参数和返回值不同。 PerlIO_read（）和PerlIO_write（）签名已在更合理的低级read（）和write（）函数上进行了建模：首先传递&amp;ldquo; file&amp;rdquo;参数，只有一个&amp;ldquo; count&amp;rdquo;，并且返回值可以区分错误和 &lt;code&gt;EOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6faed5a4522cd8b94dc864e27b779abb63c4ce78" translate="yes" xml:space="preserve">
          <source>These correspond to fopen()/fdopen() and the arguments are the same. Return &lt;code&gt;NULL&lt;/code&gt; and set &lt;code&gt;errno&lt;/code&gt; if there is an error. There may be an implementation limit on the number of open handles, which may be lower than the limit on the number of open files - &lt;code&gt;errno&lt;/code&gt; may not be set when &lt;code&gt;NULL&lt;/code&gt; is returned if this limit is exceeded.</source>
          <target state="translated">这些对应于fopen（）/ fdopen（），并且参数相同。返回 &lt;code&gt;NULL&lt;/code&gt; 并在出现错误时设置 &lt;code&gt;errno&lt;/code&gt; 。可能有一个打开句柄的实现限制，它可能低于打开文件数的限制- 如果超出此限制，则在返回 &lt;code&gt;NULL&lt;/code&gt; 时可能不会设置 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="85c39d61ce18e7b09b1791e93aa8066eeef62084" translate="yes" xml:space="preserve">
          <source>These correspond to fputs() and fputc(). Note that arguments have been revised to have &quot;file&quot; first.</source>
          <target state="translated">这些对应于fputs()和fputc()。请注意,参数已被修改为先有 &quot;file&quot;。</target>
        </trans-unit>
        <trans-unit id="544fd46c0b10a4444296cac7b81bb5f9a1983a0b" translate="yes" xml:space="preserve">
          <source>These correspond to historical versions of Perl itself prior to 5.6.0, as well as all other modules which follow the Camel rules for the $VERSION scalar. A Decimal version is initialized with what looks like a floating point number. Leading zeros &lt;b&gt;are&lt;/b&gt; significant and trailing zeros are implied so that a minimum of three places is maintained between subversions. What this means is that any subversion (digits to the right of the decimal place) that contains less than three digits will have trailing zeros added to make up the difference, but only for purposes of comparison with other version objects. For example:</source>
          <target state="translated">这些对应于5.6.0之前的Perl本身的历史版本，以及符合$ VERSION标量的Camel规则的所有其他模块。十进制版本使用看起来像浮点数的形式进行初始化。前导零&lt;b&gt;是&lt;/b&gt;有效的，而隐含了尾随零，因此在次版本之间至少要保留三个位置。这意味着任何包含少于三位数的子版本（小数点右边的数字）都将添加尾随零以弥补差异，但这仅是为了与其他版本对象进行比较。例如：</target>
        </trans-unit>
        <trans-unit id="8e90caae28ef06f86a5a7c45f8c354bdfbb310ff" translate="yes" xml:space="preserve">
          <source>These defaults may change once perlio has been better tested and tuned.</source>
          <target state="translated">一旦perlio得到更好的测试和调整,这些默认值可能会改变。</target>
        </trans-unit>
        <trans-unit id="7839c4fa6c5e549c45dd9f01f832d15a81b4f89c" translate="yes" xml:space="preserve">
          <source>These dependencies &lt;b&gt;must&lt;/b&gt; be installed for proper completion of the phase.</source>
          <target state="translated">&lt;b&gt;必须&lt;/b&gt;安装这些依赖项&lt;b&gt;才能&lt;/b&gt;正确完成该阶段。</target>
        </trans-unit>
        <trans-unit id="a282aac2b58f5229db8cb0a3f6d43227938378cc" translate="yes" xml:space="preserve">
          <source>These dependencies are optional, but are suggested for enhanced operation of the described distribution.</source>
          <target state="translated">这些依赖关系是可选的,但建议用于增强所述发行版的操作。</target>
        </trans-unit>
        <trans-unit id="4b42ed96c36dd8480d16597a1b739ba48b433615" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=perl. Defaults to $Config{installman*dir}.</source>
          <target state="translated">如果INSTALLDIRS=perl,这些目录会在'make install'时获取man页面。默认为$Config{installman*dir}。</target>
        </trans-unit>
        <trans-unit id="80d2a82fca268aa8c538c7ef08b93ac2b88facef" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=site (default). Defaults to $(SITEPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">如果INSTALLDIRS=site(默认),这些目录会在'make install'时获取man页面。默认为$(SITEPREFIX)/man/man$(MAN*EXT)。</target>
        </trans-unit>
        <trans-unit id="68e3f1b03dd4e2ce3d50494f40f9bb4bc33a9ff9" translate="yes" xml:space="preserve">
          <source>These directories get the man pages at 'make install' time if INSTALLDIRS=vendor. Defaults to $(VENDORPREFIX)/man/man$(MAN*EXT).</source>
          <target state="translated">如果INSTALLDIRS=vendor,这些目录会在 &quot;make install &quot;时获得man页面。默认为$(VENDORPREFIX)/man/man$(MAN*EXT)。</target>
        </trans-unit>
        <trans-unit id="826d28206d7a0a00e581093b89d5458113f88ed8" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where the items are a list of text &quot;subheadings&quot;, it will produce this event structure:</source>
          <target state="translated">这些事件与其他over-*结构有些不同,至于其内容是什么。当对&quot;=over......=back &quot;块进行解析,其中的项目是一个文本 &quot;小标题 &quot;列表时,会产生这样的事件结构。</target>
        </trans-unit>
        <trans-unit id="e1cc2ff1be108f9b3225e238afe683fc7768cc47" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where there are no items, it will produce this event structure:</source>
          <target state="translated">这些事件与其他over-*结构有些不同,至于其内容是什么。当&quot;=over......=back &quot;块被解析到没有项目的地方时,会产生这个事件结构。</target>
        </trans-unit>
        <trans-unit id="059d0be95b4f0a24081b715eea5d71b4a7804c63" translate="yes" xml:space="preserve">
          <source>These events are somewhat unlike the other over-* structures, as far as what their contents are. When an &quot;=over ... =back&quot; block is parsed where there is no content, it will produce this event structure:</source>
          <target state="translated">这些事件与其他的over-*结构有些不同,至于其内容是什么。当&quot;=over......=back &quot;块被解析到没有内容的地方时,会产生这个事件结构。</target>
        </trans-unit>
        <trans-unit id="697b26f4c2f86a2a70b8343c157814214e1b6619" translate="yes" xml:space="preserve">
          <source>These examples apply for use in the &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; subroutine and when calling &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt;.</source>
          <target state="translated">这些示例适用于在 &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; 子例程中以及在调用 &lt;code&gt;autodie::hints-&amp;gt;set_hints_for()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40c3a72856e79ae11ef7788be093b884c47b09d5" translate="yes" xml:space="preserve">
          <source>These examples are realized in the code below, which could be copied to a file</source>
          <target state="translated">这些例子是在下面的代码中实现的,可以复制到一个文件中去</target>
        </trans-unit>
        <trans-unit id="ea1d8aa8b62f74ea36ff39b0b63b9774953aaca0" translate="yes" xml:space="preserve">
          <source>These examples of attempts to use an ellipsis are syntax errors:</source>
          <target state="translated">这些尝试使用省略号的例子是语法错误。</target>
        </trans-unit>
        <trans-unit id="ad269ea05e73affc724a0326dc3ecea88836b454" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">这些示例通常反映了该文档作者的风格和偏好，并且可能比实际程序中的相应代码行简短。除非另有说明，否则您应假定 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 语句出现在&amp;ldquo;程序&amp;rdquo;的前面，并且已声明了所使用的任何变量，即使已省略这些声明以使示例易于阅读。</target>
        </trans-unit>
        <trans-unit id="d4e7b3ca44c221b3e7c212675f6429495503147e" translate="yes" xml:space="preserve">
          <source>These examples often reflect the style and preference of the author of that piece of the documentation, and may be briefer than a corresponding line of code in a real program. Except where otherwise noted, you should assume that &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; statements appear earlier in the &quot;program&quot;, and that any variables used have already been declared, even if those declarations have been omitted to make the example easier to read.</source>
          <target state="translated">这些示例通常反映了该文档作者的风格和偏好，并且可能比实际程序中的相应代码行更简短。除非另有说明，否则您应假定 &lt;code&gt;use strict&lt;/code&gt; 和 &lt;code&gt;use warnings&lt;/code&gt; 语句出现在&amp;ldquo;程序&amp;rdquo;的前面，并且已声明了所使用的任何变量，即使已省略这些声明以使示例易于阅读。</target>
        </trans-unit>
        <trans-unit id="da4181b23484c1b0366a0256854a440c5eed9952" translate="yes" xml:space="preserve">
          <source>These examples show how to make references to variables with names. Sometimes you want to make an array or a hash that doesn't have a name. This is analogous to the way you like to be able to use the string &lt;code&gt;&quot;\n&quot;&lt;/code&gt; or the number 80 without having to store it in a named variable first.</source>
          <target state="translated">这些示例说明如何使用名称引用变量。有时您想要创建一个没有名称的数组或哈希。这类似于您希望能够使用字符串 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 或数字80而不必先将其存储在命名变量中的方式。</target>
        </trans-unit>
        <trans-unit id="20a65f5d703ea411ed23607c52479559427bdd1b" translate="yes" xml:space="preserve">
          <source>These examples show standard binary, octal, and hexadecimal conversion. All cases return 250.</source>
          <target state="translated">这些例子显示了标准二进制、八进制和十六进制的转换。所有情况都返回250。</target>
        </trans-unit>
        <trans-unit id="3275ce9b816da8fb07d0b0ce58c3254f177b415d" translate="yes" xml:space="preserve">
          <source>These exercise the C calls of the same names. Everything after the flags arg is passed as the args to the called function. They return whatever the C function itself pushed onto the stack, plus the return value from the function; for example</source>
          <target state="translated">这些行使同名的C语言调用。flags arg之后的所有内容都作为args传递给被调用的函数。它们返回的是C函数本身推到堆栈上的任何内容,加上函数的返回值;例如</target>
        </trans-unit>
        <trans-unit id="8154f7f4551172387a5e006af7a44b0eb2db652a" translate="yes" xml:space="preserve">
          <source>These exports lack the 'test2_' prefix because of how important/common they are. Exports in the &lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&quot;OTHER API EXPORTS&quot;&lt;/a&gt; section have the 'test2_' prefix to ensure they stand out.</source>
          <target state="translated">这些导出缺少'test2_'前缀，因为它们非常重要/常见。在出口&lt;a href=&quot;#OTHER-API-EXPORTS&quot;&gt;&amp;ldquo;其他原料药出口&amp;rdquo;&lt;/a&gt;部分有&amp;ldquo;test2_&amp;rdquo;前缀，以确保他们脱颖而出。</target>
        </trans-unit>
        <trans-unit id="7900d790c497c44a25852d75caed60efb96bb183" translate="yes" xml:space="preserve">
          <source>These features are no longer considered experimental and their functionality has disappeared. It's your own fault if you wrote production programs using these features after we explicitly told you not to (see &lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;).</source>
          <target state="translated">这些功能不再被视为实验性功能，它们的功能已消失。如果在我们明确告诉您不要使用这些功能后编写生产程序，这是您自己的错（请参见&lt;a href=&quot;perlpolicy&quot;&gt;perlpolicy&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ecdbc29b6059151fd36541ed2cea90e388fc6071" translate="yes" xml:space="preserve">
          <source>These features were so wildly successful and played so well with others that we decided to remove their experimental status and admit them as full, stable features in the world of Perl, lavishing all the benefits and luxuries thereof. They are also awarded +5 Stability and +3 Charisma.</source>
          <target state="translated">这些特性非常成功,而且与其他特性玩得很好,所以我们决定取消它们的实验性地位,并将其作为 Perl 世界中完整、稳定的特性,并赋予其所有的好处和奢侈品。它们还被授予+5稳定性和+3魅力。</target>
        </trans-unit>
        <trans-unit id="23bca6002a132d6b029d6fafa0db7395943b6806" translate="yes" xml:space="preserve">
          <source>These fields are documented in &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; in the details() function</source>
          <target state="translated">这些字段记录在details（）函数的&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;中</target>
        </trans-unit>
        <trans-unit id="63e6036965bbf4c4737a51a1417b34175db545ac" translate="yes" xml:space="preserve">
          <source>These fields are exclusive to Test::Tester.</source>
          <target state="translated">这些字段是Test::Tester独有的。</target>
        </trans-unit>
        <trans-unit id="436079f5f30dfc97a1a6d7f8ea9906fefeca2983" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</source>
          <target state="translated">这些字段用于跟踪模式中可以匹配多少个父母组,哪个是最后输入的开放父母,哪个是最后输入的关闭父母。</target>
        </trans-unit>
        <trans-unit id="364e8607b9d0b5e1133548655910099e7ea2800f" translate="yes" xml:space="preserve">
          <source>These fields are used to keep track of: how many paren capture groups there are in the pattern; which was the highest paren to be closed (see &lt;a href=&quot;perlvar#%24%2B&quot;&gt;&quot;$+&quot; in perlvar&lt;/a&gt;); and which was the most recent paren to be closed (see &lt;a href=&quot;perlvar#%24%5EN&quot;&gt;&quot;$^N&quot; in perlvar&lt;/a&gt;).</source>
          <target state="translated">这些字段用于跟踪：模式中有多少个paren捕获组；这是要关闭的最高paren（请参阅&lt;a href=&quot;perlvar#%24%2B&quot;&gt;perlvar中的&amp;ldquo; $ +&amp;rdquo;&lt;/a&gt;）；并且这是要关闭的最新paren（请参阅&lt;a href=&quot;perlvar#%24%5EN&quot;&gt;perlvar中的&amp;ldquo; $ ^ N&amp;rdquo;&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="55f6d64891a439ddc08d9e9a7c82712ad5e53094" translate="yes" xml:space="preserve">
          <source>These fields were not always set properly by tools. These are &lt;b&gt;MOSTLY&lt;/b&gt; deprecated by the &lt;a href=&quot;Test2::EventFacet::Hub&quot;&gt;Test2::EventFacet::Hub&lt;/a&gt; facets. These fields are not required, and may only reflect the hub that was current when the event was created, which is not necessarily the same as the hub the event was sent through.</source>
          <target state="translated">这些字段并非总是由工具正确设置的。这些&lt;b&gt;大多&lt;/b&gt;由&lt;a href=&quot;Test2::EventFacet::Hub&quot;&gt;Test2 :: EventFacet :: Hub&lt;/a&gt;构面弃用。这些字段不是必需的，并且可能仅反映创建事件时当前的集线器，而不必与发送事件的集线器相同。</target>
        </trans-unit>
        <trans-unit id="4c8e2d7aa479f62270f36bb981c83130e3ea21ce" translate="yes" xml:space="preserve">
          <source>These files contain information on who maintains which modules. Run &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; to find out more information about a dual-life module.</source>
          <target state="translated">这些文件包含有关谁维护哪些模块的信息。运行 &lt;code&gt;perl Porting/Maintainers -M Module::Name&lt;/code&gt; 来查找有关双寿命模块的更多信息。</target>
        </trans-unit>
        <trans-unit id="7c3add026b4eccbc256b7dbac98ef5e6ce0ff8a8" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">可以在编译期间设置这些标志，以启用 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 运算符中的优化。</target>
        </trans-unit>
        <trans-unit id="ba4786ce1716e79f3dd44cdde2b9934a0474166a" translate="yes" xml:space="preserve">
          <source>These flags can be set during compilation to enable optimizations in the &lt;code&gt;split&lt;/code&gt; operator.</source>
          <target state="translated">可以在编译期间设置这些标志，以启用 &lt;code&gt;split&lt;/code&gt; 运算符中的优化。</target>
        </trans-unit>
        <trans-unit id="e37fe8b518dd14c6463f65c8f4e797fa6141aaa5" translate="yes" xml:space="preserve">
          <source>These flags will be combined with &lt;code&gt;AI_PASSIVE&lt;/code&gt; if the &lt;code&gt;Listen&lt;/code&gt; argument is given. For more information see the documentation about &lt;code&gt;getaddrinfo()&lt;/code&gt; in the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module.</source>
          <target state="translated">如果指定了 &lt;code&gt;Listen&lt;/code&gt; 参数，则这些标志将与 &lt;code&gt;AI_PASSIVE&lt;/code&gt; 组合。欲了解更多信息，请参阅有关文档 &lt;code&gt;getaddrinfo()&lt;/code&gt; 中&lt;a href=&quot;socket&quot;&gt;的Socket&lt;/a&gt;模块。</target>
        </trans-unit>
        <trans-unit id="5ad448cfc75702b92a6132746a47d8bee944a550" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些流控制关键字记录&lt;a href=&quot;../perlsyn#Compound-Statements&quot;&gt;在perlsyn的Composite Statements中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c20b24e4fbc48221510b4bcf4dcbd023da2f2f48" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;&quot;Compound Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些流控制关键字记录&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;在perlsyn的&amp;ldquo;复合语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4f149ae07a8478e188c52361aad3ec711ed1026a" translate="yes" xml:space="preserve">
          <source>These flow-control keywords are documented in &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些流控制关键字记录&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;在perlsyn的Composite Statements中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="309e08bc8a3175c38d05ead911b510e18b559b99" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些与实验性开关功能相关的流量控制关键字记录&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;在perlsyn的&amp;ldquo;开关语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c6ea531d00fc508a3823794aa1be9e23af84e702" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些与实验性开关功能相关的流量控制关键字记录&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;在perlsyn的&amp;ldquo;开关语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a272370ad05edf250f2041efdee62784d465ad39" translate="yes" xml:space="preserve">
          <source>These flow-control keywords related to the experimental switch feature are documented in &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">这些与实验性开关功能相关的流量控制关键字记录&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;在perlsyn的&amp;ldquo;开关语句&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc4036739b5240858c0bf581399bd57e7b5e9c9e" translate="yes" xml:space="preserve">
          <source>These forms may be assigned to, and cause the right-hand side to be evaluated in scalar context:</source>
          <target state="translated">这些形式可能会被分配到,并导致右侧的标量上下文中被评估。</target>
        </trans-unit>
        <trans-unit id="b6a87abeab3fa4b07145fb59b22ed97519f70773" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2013 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">这些免费版的Visual C++2008-2013 Professional包含了与完整版相同的编译器和链接器,还包含了构建Perl所需的所有内容,而不像以前的版本那样需要单独下载Windows SDK。</target>
        </trans-unit>
        <trans-unit id="dd071ab048c765a21e6eb3e509d63da5f9264cc6" translate="yes" xml:space="preserve">
          <source>These free versions of Visual C++ 2008-2019 Professional contain the same compilers and linkers that ship with the full versions, and also contain everything necessary to build Perl, rather than requiring a separate download of the Windows SDK like previous versions did.</source>
          <target state="translated">这些免费版的Visual C++2008-2019 Professional包含了与完整版相同的编译器和链接器,还包含了构建Perl所需的一切,而不像以前的版本那样需要单独下载Windows SDK。</target>
        </trans-unit>
        <trans-unit id="efdfa79cbeb17377a5124b29f2fd31a6e8d98c48" translate="yes" xml:space="preserve">
          <source>These functions allow checksums to be merged. Refer to the</source>
          <target state="translated">这些功能允许合并校验和。请参考</target>
        </trans-unit>
        <trans-unit id="ba57dd2ab74f37811d43a497242362420e4296f0" translate="yes" xml:space="preserve">
          <source>These functions are exported only on request. They each take a single argument and return the absolute pathname for it. If no argument is given they'll use the current working directory.</source>
          <target state="translated">这些函数只有在接到请求时才会输出。它们每个函数都接受一个参数并返回绝对路径名。如果没有给定参数,它们将使用当前的工作目录。</target>
        </trans-unit>
        <trans-unit id="11a75a016614f3f6a49b489f2532217d2dc9b130" translate="yes" xml:space="preserve">
          <source>These functions are interface of character data used internally. If you want only to get Unicode normalization forms, you don't need call them yourself.</source>
          <target state="translated">这些函数是内部使用的字符数据的接口。如果你只想获得Unicode规范化形式,你不需要自己调用它们。</target>
        </trans-unit>
        <trans-unit id="a5805d5b7ed6958150825f5cb6f923e00d36788d" translate="yes" xml:space="preserve">
          <source>These functions are provided for backwards compatibility with common tempfile generation C library functions.</source>
          <target state="translated">这些函数是为了向后兼容常见的tempfile生成C库函数而提供的。</target>
        </trans-unit>
        <trans-unit id="4c85d18231511b3dd1840594c64b0cd5dd02c4fd" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes</source>
          <target state="translated">这些函数与perl类的方法解析顺序有关。</target>
        </trans-unit>
        <trans-unit id="f5dc09684122720f5aa9541567e929d09cbfcab9" translate="yes" xml:space="preserve">
          <source>These functions are related to the method resolution order of perl classes Also see &lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt;.</source>
          <target state="translated">这些功能与perl类的方法解析顺序有关。另请参见&lt;a href=&quot;perlmroapi&quot;&gt;perlmroapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="565eacfa6d391bb1e8f9b310d413202832f4d770" translate="yes" xml:space="preserve">
          <source>These functions are used by the filter to obtain either a line or block from the next filter in the chain or the actual source file if there aren't any other filters.</source>
          <target state="translated">这些函数被过滤器用于从链中的下一个过滤器或实际的源文件(如果没有任何其他过滤器)中获取行或块。</target>
        </trans-unit>
        <trans-unit id="b40856071384296779ffb96483ca0013c6d7f3df" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt; .</source>
          <target state="translated">这些函数通常在 &lt;code&gt;ok()&lt;/code&gt; 内部使用。</target>
        </trans-unit>
        <trans-unit id="e41468bdd006d27480bb97d817c9ffa27e30a0b5" translate="yes" xml:space="preserve">
          <source>These functions are usually used inside an &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">这些函数通常在 &lt;code&gt;ok()&lt;/code&gt; 内部使用。</target>
        </trans-unit>
        <trans-unit id="ad9ddd863a33c4087b2128f800b2bb735b670e0b" translate="yes" xml:space="preserve">
          <source>These functions control the global state of the package.</source>
          <target state="translated">这些函数控制包的全局状态。</target>
        </trans-unit>
        <trans-unit id="524d44a200305a1bdc5134c684c7bc58ebf331b8" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to $AUTOLOAD changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">这些函数授予 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 令牌作为方法名称的前缀。请注意，如果要长时间保留返回的glob，则需要检查它是否为&amp;ldquo; AUTOLOAD&amp;rdquo;，因为稍后由于$ AUTOLOAD更改其值，该调用可能会加载其他子例程。使用作为副作用创建的glob执行此操作。</target>
        </trans-unit>
        <trans-unit id="46e538c266b73e137dc14a5dc62eb4e35a0dc1d7" translate="yes" xml:space="preserve">
          <source>These functions grant &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; token as a prefix of the method name. Note that if you want to keep the returned glob for a long time, you need to check for it being &quot;AUTOLOAD&quot;, since at the later time the call may load a different subroutine due to &lt;code&gt;$AUTOLOAD&lt;/code&gt; changing its value. Use the glob created as a side effect to do this.</source>
          <target state="translated">这些函数授予 &lt;code&gt;&quot;SUPER&quot;&lt;/code&gt; 令牌作为方法名称的前缀。请注意，如果要长时间保留返回的glob，则需要检查它是否为&amp;ldquo; AUTOLOAD&amp;rdquo;，因为稍后由于 &lt;code&gt;$AUTOLOAD&lt;/code&gt; 更改其值，该调用可能会加载其他子例程。使用创建为副作用的glob来执行此操作。</target>
        </trans-unit>
        <trans-unit id="e3b1137b52cacd1fbff911e830d8d14363d490cb" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt; . The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">这些功能与带有 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 具有相同的副作用。禁止将 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 返回的GV传递给 &lt;code&gt;call_sv&lt;/code&gt; 的警告同样适用于这些功能。</target>
        </trans-unit>
        <trans-unit id="2b56f3bac64bb21a82acf1501da762f0c2c856f4" translate="yes" xml:space="preserve">
          <source>These functions have the same side-effects as &lt;code&gt;gv_fetchmeth&lt;/code&gt; with &lt;code&gt;level==0&lt;/code&gt;. The warning against passing the GV returned by &lt;code&gt;gv_fetchmeth&lt;/code&gt; to &lt;code&gt;call_sv&lt;/code&gt; applies equally to these functions.</source>
          <target state="translated">这些功能与带有 &lt;code&gt;level==0&lt;/code&gt; &lt;code&gt;gv_fetchmeth&lt;/code&gt; 具有相同的副作用。禁止将 &lt;code&gt;gv_fetchmeth&lt;/code&gt; 返回的GV传递给 &lt;code&gt;call_sv&lt;/code&gt; 的警告同样适用于这些功能。</target>
        </trans-unit>
        <trans-unit id="98d4aef8dd151e8462fbb3063b8efcb68e0d87b2" translate="yes" xml:space="preserve">
          <source>These functions provide convenient and thread-safe means of manipulating hook variables.</source>
          <target state="translated">这些函数提供了方便和线程安全的方法来操作钩子变量。</target>
        </trans-unit>
        <trans-unit id="a1aa255500a4b04da2dc6b5da9157c66c2e72423" translate="yes" xml:space="preserve">
          <source>These functions return the filehandles that test output should be written to. They are primarily useful when writing a custom formatter and code that turns events into actual output (TAP, etc.). They will return a dupe of the original filehandles that formatted output can be sent to regardless of whatever state the currently running test may have left STDOUT and STDERR in.</source>
          <target state="translated">这些函数返回测试输出应该写入的文件柄。它们主要在编写自定义格式化器和将事件转化为实际输出的代码(TAP等)时有用。它们将返回一个原始文件柄的复制品,格式化后的输出可以被发送至该文件柄,而不管当前运行的测试可能让STDOUT和STDERR处于什么状态。</target>
        </trans-unit>
        <trans-unit id="f738338a9dbfbee4b5a909220a80f41318a9f381" translate="yes" xml:space="preserve">
          <source>These functions simply print $Config{ccflags} and $Config{ccdlflags}</source>
          <target state="translated">这些函数只是简单地打印$Config{ccflags}和$Config{ccdlflags}。</target>
        </trans-unit>
        <trans-unit id="6cd020ca0f66b00dde6a2341717a3dae0fc7c828" translate="yes" xml:space="preserve">
          <source>These functions take a hash as an argument. The recognized keys of this hash are:</source>
          <target state="translated">这些函数以一个哈希值作为参数。这个哈希值的公认键是:</target>
        </trans-unit>
        <trans-unit id="d6359c7691ac9172680cb301b6768d6c5620c165" translate="yes" xml:space="preserve">
          <source>These functions take an input numeric code point in one encoding and return what its equivalent value is in the other.</source>
          <target state="translated">这些函数以一种编码方式接收一个输入的数字码点,并以另一种编码方式返回其等值。</target>
        </trans-unit>
        <trans-unit id="7ebb5ef7a942f7d31cebfd11f8de6228de926c64" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;../perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">还允许这些挂钩设置与其已加载文件相对应的％INC条目。请参见&lt;a href=&quot;../perlvar#%25INC&quot;&gt;perlvar中的％INC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcbca2e2db6c0375d3253e7898e5f5abc5deaab1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the %INC entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;%INC in perlvar&lt;/a&gt;.</source>
          <target state="translated">还允许这些挂钩设置与其已加载文件相对应的％INC条目。请参见&lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar中的％INC&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5503b912c616b1c1dc8b62e0e994ce6da27034d1" translate="yes" xml:space="preserve">
          <source>These hooks are also permitted to set the &lt;a href=&quot;perlvar#%25INC&quot;&gt;&lt;code&gt;%INC&lt;/code&gt;&lt;/a&gt; entry corresponding to the files they have loaded. See &lt;a href=&quot;perlvar#%25INC&quot;&gt;&quot;%INC&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">还允许这些挂钩设置与它们已加载的文件相对应的&lt;a href=&quot;perlvar#%25INC&quot;&gt; &lt;code&gt;%INC&lt;/code&gt; &lt;/a&gt;条目。请参见&lt;a href=&quot;perlvar#%25INC&quot;&gt;perlvar中的&amp;ldquo;％INC&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="78a1c65d2979db94163456cbe8161d55f284997f" translate="yes" xml:space="preserve">
          <source>These instructions almost certainly won't work with older Symbian releases or other SDKs. Patches to get this port running in other releases, SDKs, compilers, platforms, or devices are naturally welcome.</source>
          <target state="translated">这些说明几乎可以肯定不能与旧版Symbian或其他SDK一起使用。当然,我们也欢迎提供补丁,让这个移植版在其他版本、SDK、编译器、平台或设备上运行。</target>
        </trans-unit>
        <trans-unit id="70f079e2e8fde2b1b9c52a64a204e00b961420ae" translate="yes" xml:space="preserve">
          <source>These instructions assume an Unixish build environment on your host system; they've been tested on Linux and OS X, and may work on Cygwin and MSYS. While Google also provides an NDK for Windows, these steps won't work native there, although it may be possible to cross-compile through different means.</source>
          <target state="translated">这些说明假设你的主机系统是在Unix环境下构建的;它们已经在Linux和OS X上测试过,也可能在Cygwin和MSYS上工作。虽然Google也提供了Windows的NDK,但这些步骤在Windows下无法正常工作,尽管可能通过不同的方式进行交叉编译。</target>
        </trans-unit>
        <trans-unit id="7b41cc6de55339f50e9dff758782b5feb169269e" translate="yes" xml:space="preserve">
          <source>These instructions have been tested under various Nokia Series 60 Symbian SDKs (1.2 to 2.6, 2.8 should also work, 1.2 compiles but does not work), Series 80 2.0, and Nokia 7710 (Series 90) SDK. You can get the SDKs from Forum Nokia (&lt;a href=&quot;http://www.forum.nokia.com/&quot;&gt;http://www.forum.nokia.com/&lt;/a&gt;). A very rough port (&quot;it compiles&quot;) to UIQ 2.1 has also been made.</source>
          <target state="translated">这些说明已在各种诺基亚60系列Symbian SDK（1.2至2.6、2.8也可以工作，1.2编译但不起作用），80系列2.0和诺基亚7710（90系列）SDK下进行了测试。您可以从诺基亚论坛（&lt;a href=&quot;http://www.forum.nokia.com/&quot;&gt;http://www.forum.nokia.com/&lt;/a&gt;）获得SDK 。还对UIQ 2.1进行了非常粗糙的移植（&amp;ldquo;编译&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="8243bb38a9870ed902e40da582837671b3b2a2f6" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">这些接口仅在Perl 5.9.5及更高版本中可用。请参阅CPAN上的&lt;a href=&quot;MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt;，以了解较旧的Perls的大多数向前兼容的实现。</target>
        </trans-unit>
        <trans-unit id="2ab8134e6c8ea614a58bbf4cba85fe875f47ac40" translate="yes" xml:space="preserve">
          <source>These interfaces are only available in Perl 5.9.5 and higher. See &lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO::Compat&lt;/a&gt; on CPAN for a mostly forwards compatible implementation for older Perls.</source>
          <target state="translated">这些接口仅在Perl 5.9.5及更高版本中可用。请参阅CPAN上的&lt;a href=&quot;http://search.cpan.org/perldoc/MRO::Compat&quot;&gt;MRO :: Compat&lt;/a&gt;，以了解较旧的Perls的大多数向前兼容的实现。</target>
        </trans-unit>
        <trans-unit id="800024eb93ec8e2e1c9e19ed6e58201379d4f5ea" translate="yes" xml:space="preserve">
          <source>These items are the primitives used to perform indenting, and to select text from amongst alternatives.</source>
          <target state="translated">这些项目是用于执行缩进和从其他选项中选择文本的基元。</target>
        </trans-unit>
        <trans-unit id="3dfe7afbcdb97590e1c6c0085eefd647c7035d88" translate="yes" xml:space="preserve">
          <source>These keys will be populated before any exceptions are thrown should there be an error.</source>
          <target state="translated">这些键将在任何异常抛出之前被填充,如果有错误的话。</target>
        </trans-unit>
        <trans-unit id="a901d1a803d1f1e84cb86c073bdbaefe49dcbe0f" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;../perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">这些关键字记录&lt;a href=&quot;../perldata#Special-Literals&quot;&gt;在perldata的特殊文字中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d6b25a409414e2ca5afbdfa8033c35fbcccb54b" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;&quot;Special Literals&quot; in perldata&lt;/a&gt;.</source>
          <target state="translated">这些关键字记录&lt;a href=&quot;perldata#Special-Literals&quot;&gt;在perldata的&amp;ldquo;特殊文字&amp;rdquo;中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1500951fb5f2dd9eeebd6c439509f1ad3f36d4ce" translate="yes" xml:space="preserve">
          <source>These keywords are documented in &lt;a href=&quot;perldata#Special-Literals&quot;&gt;Special Literals in perldata&lt;/a&gt;.</source>
          <target state="translated">这些关键字记录&lt;a href=&quot;perldata#Special-Literals&quot;&gt;在perldata的特殊文字中&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="017f89666b16c462ff4b71931d55ca635d0ecaed" translate="yes" xml:space="preserve">
          <source>These last two are only valid for pad name SVs. They only existed in the B::NV class before Perl 5.22. In 5.22 they were moved to the B::PADNAME class.</source>
          <target state="translated">后面这两个只对垫名SV有效。在 Perl 5.22 之前,它们只存在于 B::NV 类中。在 5.22 中,它们被移到了 B::PADNAME 类中。</target>
        </trans-unit>
        <trans-unit id="298686bf6c6c117c0e1d2a3856c264e7ccaf286f" translate="yes" xml:space="preserve">
          <source>These let you access, or specify, the IPC system internals.</source>
          <target state="translated">这些让你可以访问或指定IPC系统的内部结构。</target>
        </trans-unit>
        <trans-unit id="a9833d67dc0abefa0216f41f8ee8eb9cce74882f" translate="yes" xml:space="preserve">
          <source>These let you access, or specify, the formatters that can/should be used.</source>
          <target state="translated">这些让您可以访问或指定可以/应该使用的格式。</target>
        </trans-unit>
        <trans-unit id="c5bcc5490ceb9d124e54596118346ed571b24dc1" translate="yes" xml:space="preserve">
          <source>These libraries cannot be installed when the phase is in operation. This is a very rare situation, and the &lt;code&gt;conflicts&lt;/code&gt; relationship should be used with great caution, or not at all.</source>
          <target state="translated">在阶段运行时无法安装这些库。这是非常罕见的情况，应该非常谨慎地使用 &lt;code&gt;conflicts&lt;/code&gt; 关系，或者根本不要使用冲突关系。</target>
        </trans-unit>
        <trans-unit id="ee3476aee9a9c9d8b18c6d57ac8c385c0348f0d4" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些看起来像字符名称，但返回多个代码点。注意 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 中的 &lt;code&gt;%vx&lt;/code&gt; vector-print功能。</target>
        </trans-unit>
        <trans-unit id="3391fc814f15e6deaf725b432b00af48ee0dd251" translate="yes" xml:space="preserve">
          <source>These look just like character names but return multiple codepoints. Notice the &lt;code&gt;%vx&lt;/code&gt; vector-print functionality in &lt;code&gt;printf&lt;/code&gt;.</source>
          <target state="translated">这些看起来像字符名称，但返回多个代码点。注意 &lt;code&gt;printf&lt;/code&gt; 中的 &lt;code&gt;%vx&lt;/code&gt; vector-print功能。</target>
        </trans-unit>
        <trans-unit id="e76a83f91dda3c78158f07c2bcf605e73e782739" translate="yes" xml:space="preserve">
          <source>These loop ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available CPU time).</source>
          <target state="translated">这些循环操作没有包含在:base_core中,因为它们很容易被用来实现资源攻击(例如,消耗所有可用的CPU时间)。</target>
        </trans-unit>
        <trans-unit id="a843eb74986a4e9f839472d2d8d150ea39980b05" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of integer variable &lt;code&gt;i&lt;/code&gt; at the end of enclosing</source>
          <target state="translated">这些宏安排在结束时恢复整数变量 &lt;code&gt;i&lt;/code&gt; 的值的事情</target>
        </trans-unit>
        <trans-unit id="f7a2a9aebcff3586f69f55801776cb23fd4e90a9" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">这些宏安排了恢复指针 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 的值的事情。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 必须是能够在转换成 &lt;code&gt;SV*&lt;/code&gt; 后返回的类型的指针， &lt;code&gt;p&lt;/code&gt; 应该能够在转换成 &lt;code&gt;char*&lt;/code&gt; 后返回的类型。</target>
        </trans-unit>
        <trans-unit id="abe6df67a459b0e2e30bde61ddbbfa6e1689636a" translate="yes" xml:space="preserve">
          <source>These macros arrange things to restore the value of pointers &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt;. &lt;code&gt;s&lt;/code&gt; must be a pointer of a type which survives conversion to &lt;code&gt;SV*&lt;/code&gt; and back, &lt;code&gt;p&lt;/code&gt; should be able to survive conversion to &lt;code&gt;char*&lt;/code&gt; and back.</source>
          <target state="translated">这些宏安排了恢复指针 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 的值的事情。 &lt;code&gt;s&lt;/code&gt; 必须是能够在转换成 &lt;code&gt;SV*&lt;/code&gt; 后返回的类型的指针， &lt;code&gt;p&lt;/code&gt; 应该能够在转换成 &lt;code&gt;char*&lt;/code&gt; 后返回的类型。</target>
        </trans-unit>
        <trans-unit id="593dfba1d3d328349b77f1588cf82c2aaffa0443" translate="yes" xml:space="preserve">
          <source>These may not necessarily cause trouble, but indicate mediocre style.</source>
          <target state="translated">这些未必会引起麻烦,但说明作风平平。</target>
        </trans-unit>
        <trans-unit id="e22b64582fc85ac43b9e96c24337a10a450121a5" translate="yes" xml:space="preserve">
          <source>These memory related ops are not included in :base_core because they can easily be used to implement a resource attack (e.g., consume all available memory).</source>
          <target state="translated">这些与内存相关的操作没有包含在:base_core中,因为它们很容易被用来实现资源攻击(例如,消耗所有可用内存)。</target>
        </trans-unit>
        <trans-unit id="77c1bb576863e90102788a1b3ffe564db0c5c144" translate="yes" xml:space="preserve">
          <source>These messages are classified as follows (listed in increasing order of desperation):</source>
          <target state="translated">这些信息分类如下(按绝望程度增加的顺序排列):</target>
        </trans-unit>
        <trans-unit id="b0bb74426f2aa2733dbc5c5a86f08523cab5f25f" translate="yes" xml:space="preserve">
          <source>These messages may safely be ignored. (Note that for a SunOS4 system, you must use -B/bin/ instead.)</source>
          <target state="translated">这些信息可以被忽略。(注意,对于SunOS4系统,你必须使用-B/bin/来代替。)</target>
        </trans-unit>
        <trans-unit id="5b9f0b892cf28755d89fe7944f868ad5bf940e68" translate="yes" xml:space="preserve">
          <source>These methods all apply to the Ptr type for the structure; additionally two methods are constructed for the structure type itself, &lt;code&gt;_to_ptr&lt;/code&gt; which returns a Ptr type pointing to the same structure, and a &lt;code&gt;new&lt;/code&gt; method to construct and return a new structure, initialised to zeroes.</source>
          <target state="translated">这些方法都适用于结构的Ptr类型。另外，针对结构类型本身构造了两种方法， &lt;code&gt;_to_ptr&lt;/code&gt; 返回指向相同结构的Ptr类型，以及构造和返回初始化为零的新结构的 &lt;code&gt;new&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="833ac724c3c333f81488114a18e12c4a9e975d1a" translate="yes" xml:space="preserve">
          <source>These methods all test the BigInt for being one specific value and return true or false depending on the input. These are faster than doing something like:</source>
          <target state="translated">这些方法都测试BigInt是否是一个特定的值,并根据输入返回true或false。这些方法比做类似的事情要快。</target>
        </trans-unit>
        <trans-unit id="44e7eefb77f18d6db25c4aade77e34563622be4e" translate="yes" xml:space="preserve">
          <source>These methods are called when Math::BigInt encounters an object it doesn't know how to handle. For instance, assume $x is a Math::BigInt, or subclass thereof, and $y is defined, but not a Math::BigInt, or subclass thereof. If you do</source>
          <target state="translated">当Math::BigInt遇到一个不知道如何处理的对象时,就会调用这些方法。例如,假设 $x 是一个 Math::BigInt 或其子类,而 $y 已被定义,但不是一个 Math::BigInt 或其子类。如果你做</target>
        </trans-unit>
        <trans-unit id="2e0a252991a786c320bc1feeb73f0f20e3e9795f" translate="yes" xml:space="preserve">
          <source>These methods are discussed in the section &quot;Bracket Notation Security&quot;.</source>
          <target state="translated">这些方法将在 &quot;括号符号安全 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="92da9e899f4e8b0a6a719a6370a299d62ec6b1c8" translate="yes" xml:space="preserve">
          <source>These methods are for setting up tests and declaring how many there are. You usually only want to call one of these methods.</source>
          <target state="translated">这些方法用于设置测试和声明有多少测试。你通常只想调用其中的一个方法。</target>
        </trans-unit>
        <trans-unit id="98d7c4cb78ffffaf07a8efc77ee2a4a9356ea4d1" translate="yes" xml:space="preserve">
          <source>These methods are intended to be used in the everyday dealing of exceptions.</source>
          <target state="translated">这些方法是为了在日常处理异常时使用。</target>
        </trans-unit>
        <trans-unit id="9725043aadb2020c60801a841d8cbbe42a310c40" translate="yes" xml:space="preserve">
          <source>These methods are not intended to be called by the user, but used or over-ridden by a sub-class of &lt;code&gt;Net::Cmd&lt;/code&gt;</source>
          <target state="translated">这些方法不是要由用户调用的，而是由 &lt;code&gt;Net::Cmd&lt;/code&gt; 的子类使用或覆盖的</target>
        </trans-unit>
        <trans-unit id="c96be7d81aefe7494626f31fbf2d601d47ed4e3e" translate="yes" xml:space="preserve">
          <source>These methods are only testing the sign, and not the value.</source>
          <target state="translated">这些方法只是测试符号,而不是测试数值。</target>
        </trans-unit>
        <trans-unit id="1d5446ceaa2f31e572217b447d4bad05a2bfe863" translate="yes" xml:space="preserve">
          <source>These methods are shorthand for calling &lt;code&gt;request()&lt;/code&gt; for the given method. The URL must have unsafe characters escaped and international domain names encoded. See &lt;code&gt;request()&lt;/code&gt; for valid options and a description of the response.</source>
          <target state="translated">这些方法是为给定方法调用 &lt;code&gt;request()&lt;/code&gt; 的简写形式。该URL必须转义不安全的字符并编码国际域名。有关有效选项和响应的说明，请参见 &lt;code&gt;request()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f55156f755c79786d47317ca2de0a12228b5b4b7" translate="yes" xml:space="preserve">
          <source>These methods are useful when writing your own test methods.</source>
          <target state="translated">这些方法在编写自己的测试方法时很有用。</target>
        </trans-unit>
        <trans-unit id="1371312bc20ca6b06acc065c53943c266c38f79b" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt; , a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt; .</source>
          <target state="translated">这些方法控制Test :: Builder将在何处打印其输出。他们使用一个打开的 &lt;code&gt;$filehandle&lt;/code&gt; ，一个打开并写入的 &lt;code&gt;$filename&lt;/code&gt; 或一个附加的 &lt;code&gt;$scalar&lt;/code&gt; 引用。它将始终返回 &lt;code&gt;$filehandle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6256a8c8405e7801b12616fc7588a653b02503a" translate="yes" xml:space="preserve">
          <source>These methods control where Test::Builder will print its output. They take either an open &lt;code&gt;$filehandle&lt;/code&gt;, a &lt;code&gt;$filename&lt;/code&gt; to open and write to or a &lt;code&gt;$scalar&lt;/code&gt; reference to append to. It will always return a &lt;code&gt;$filehandle&lt;/code&gt;.</source>
          <target state="translated">这些方法控制Test :: Builder将在何处打印其输出。它们采用打开的 &lt;code&gt;$filehandle&lt;/code&gt; ，打开并写入的 &lt;code&gt;$filename&lt;/code&gt; 或追加的 &lt;code&gt;$scalar&lt;/code&gt; 引用。它将始终返回 &lt;code&gt;$filehandle&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dabfc6c3e23d636029050966dc499c5c862fee9" translate="yes" xml:space="preserve">
          <source>These methods get the values of similarly named fields within the OP data structure. See top of &lt;code&gt;op.h&lt;/code&gt; for more info.</source>
          <target state="translated">这些方法获取OP数据结构中名称相似的字段的值。有关更多信息，请参见 &lt;code&gt;op.h&lt;/code&gt; 的顶部。</target>
        </trans-unit>
        <trans-unit id="eac0ba268e5d0e742f5c1a8121218a2683f22449" translate="yes" xml:space="preserve">
          <source>These methods guarantee fast individual tests but require a re-organization of the original list or array. They only pay off if you have to test multiple values against the same array.</source>
          <target state="translated">这些方法保证了快速的单个测试,但需要重新组织原始列表或数组。只有当你必须针对同一个数组测试多个值时,它们才会有回报。</target>
        </trans-unit>
        <trans-unit id="f57ba0d1f35f964a5a1c34d55f9aeead1f7ad788" translate="yes" xml:space="preserve">
          <source>These methods have cycle detection and will throw an exception early if a cycle is detected. &lt;code&gt;uuid()&lt;/code&gt; is currently the only subroutine in this library that has a fallback behavior when cycles are detected.</source>
          <target state="translated">这些方法具有循环检测功能，如果检测到循环，将尽早引发异常。当检测到循环时， &lt;code&gt;uuid()&lt;/code&gt; 当前是该库中唯一具有后备行为的子例程。</target>
        </trans-unit>
        <trans-unit id="7cb3b559e380c719f80028fb428c3eb720e12704" translate="yes" xml:space="preserve">
          <source>These methods install a transparent filter on the I/O stream that converts data from the specified encoding when it is read in from the stream. The result is always Unicode.</source>
          <target state="translated">这些方法在I/O流上安装了一个透明的过滤器,当数据从流中读入时,它会从指定的编码中转换数据。其结果总是Unicode。</target>
        </trans-unit>
        <trans-unit id="f58c6a34e5787c6cc0d22a8ee189b8d36dae62d5" translate="yes" xml:space="preserve">
          <source>These methods modify the invocand object and returns it.</source>
          <target state="translated">这些方法修改invocand对象并返回它。</target>
        </trans-unit>
        <trans-unit id="2d0828193002db36233bc401e0a0e9c0dbb462a1" translate="yes" xml:space="preserve">
          <source>These methods provide a user interface to the &lt;code&gt;Net::Cmd&lt;/code&gt; object.</source>
          <target state="translated">这些方法为 &lt;code&gt;Net::Cmd&lt;/code&gt; 对象提供了一个用户界面。</target>
        </trans-unit>
        <trans-unit id="e225e7aa23799f06f35cd0332e8b4cde6a695883" translate="yes" xml:space="preserve">
          <source>These methods return lists of string values, which might be represented in the distmeta structure as arrayrefs or scalars:</source>
          <target state="translated">这些方法返回字符串值的列表,在distmeta结构中可以用arrayrefs或scalars表示。</target>
        </trans-unit>
        <trans-unit id="ff435d938391d9561763fbcab2d9f747b7f84a93" translate="yes" xml:space="preserve">
          <source>These methods set the size (in half-points, like 52 for 26-point) that these heading levels will appear as.</source>
          <target state="translated">这些方法设置了这些标题级别的大小(以半点为单位,如52为26点)。</target>
        </trans-unit>
        <trans-unit id="abcc7bd5fdde6b4a0c109a19d7071ed04915f8b9" translate="yes" xml:space="preserve">
          <source>These methods use commands that are not part of the RFC977 documentation. Some servers may not support all of them.</source>
          <target state="translated">这些方法使用的命令不属于RFC977文档的一部分。有些服务器可能不支持所有这些方法。</target>
        </trans-unit>
        <trans-unit id="31ccd9bd046a9504a4b8ad4115c9067507a8e143" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; , and you can import the generic bitmask constants via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; .</source>
          <target state="translated">这些模式实际上都是通过位掩码设置的。这是 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 常量的布局方式。您可以导入 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 通过常量 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallbacks)&lt;/code&gt; ，并可以通过导入通用掩码常量 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Encode qw(:fallback_all)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e33c5a40e1debe70ee0e42cb3c084926947443d" translate="yes" xml:space="preserve">
          <source>These modes are all actually set via a bitmask. Here is how the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants are laid out. You can import the &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; constants via &lt;code&gt;use Encode qw(:fallbacks)&lt;/code&gt;, and you can import the generic bitmask constants via &lt;code&gt;use Encode qw(:fallback_all)&lt;/code&gt;.</source>
          <target state="translated">这些模式实际上都是通过位掩码设置的。这是 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 常量的布局方式。您可以导入 &lt;code&gt;FB_&lt;i&gt;XXX&lt;/i&gt;&lt;/code&gt; 通过常量 &lt;code&gt;use Encode qw(:fallbacks)&lt;/code&gt; ，并可以通过导入通用掩码常量 &lt;code&gt;use Encode qw(:fallback_all)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d789a994adbfeec56de6cff1edba3230c60ae5bf" translate="yes" xml:space="preserve">
          <source>These modifiers are restored at the end of the enclosing group. For example,</source>
          <target state="translated">这些修饰符在包围组的末尾被还原。例如:</target>
        </trans-unit>
        <trans-unit id="36a2832964ad1656c58b1143307f7ac9e06be52f" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;))&lt;/code&gt; does not change the case-sensitivity of the</source>
          <target state="translated">这些修饰符不会保留到在封闭组中调用的命名子模式中。换句话说，诸如 &lt;code&gt;((?i)(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;))&lt;/code&gt; 之类的模式不会改变</target>
        </trans-unit>
        <trans-unit id="4b50f0d55e6d3bcc6eb1ad193029b6cf71ad0ceb" translate="yes" xml:space="preserve">
          <source>These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; does not change the case-sensitivity of the &quot;NAME&quot; pattern.</source>
          <target state="translated">这些修饰符不会保留到在封闭组中调用的命名子模式中。换句话说，诸如 &lt;code&gt;((?i)(?&amp;amp;NAME))&lt;/code&gt; 之类的模式不会改变&amp;ldquo; NAME&amp;rdquo;模式的区分大小写。</target>
        </trans-unit>
        <trans-unit id="333ce465cc885bdd43387f970476181f3973f86d" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode,</source>
          <target state="translated">这些修饰符,都是5.14中新增加的,会影响到哪些字符集规则(Unicode,</target>
        </trans-unit>
        <trans-unit id="f5fbd761faf543e63a6416a5e28a730d54795855" translate="yes" xml:space="preserve">
          <source>These modifiers, all new in 5.14, affect which character-set rules (Unicode, etc.) are used, as described below in &lt;a href=&quot;#Character-set-modifiers&quot;&gt;Character set modifiers&lt;/a&gt;.</source>
          <target state="translated">这些修饰符是5.14中的新功能，它们会影响使用哪些字符集规则（Unicode等），如下面的&amp;ldquo; &lt;a href=&quot;#Character-set-modifiers&quot;&gt;字符集修饰符&amp;rdquo;中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2face06edd17affb51aa3f3b2560aa4d1613d318" translate="yes" xml:space="preserve">
          <source>These modules still function correctly, but their test suites will not pass. If you already have these modules installed then you can continue to use them. If you are trying to install them after upgrading Test::Builder you will need to force installation, or bypass the broken tests.</source>
          <target state="translated">这些模块仍能正常运行,但其测试套件将无法通过。如果您已经安装了这些模块,那么您可以继续使用它们。如果您在升级Test::Builder后试图安装它们,您将需要强制安装,或者绕过已损坏的测试。</target>
        </trans-unit>
        <trans-unit id="bb9708d2ade8d02334095230804c31cb6c6f062f" translate="yes" xml:space="preserve">
          <source>These names are case-insensitive. By default (if specification is omitted), 'shifted' is adopted.</source>
          <target state="translated">这些名称是不区分大小写的。默认情况下(如果省略了规格),采用'shifted'。</target>
        </trans-unit>
        <trans-unit id="a2a7bae57c0b7e47324c6368dda30c35ad91dca7" translate="yes" xml:space="preserve">
          <source>These notices must be retained in any copies of any part of this documentation and/or software.</source>
          <target state="translated">本文档和/或软件的任何部分的任何副本都必须保留这些声明。</target>
        </trans-unit>
        <trans-unit id="efbc4f1ae4d272c0d4681905f6fb23798e4783eb" translate="yes" xml:space="preserve">
          <source>These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running under Linux on a P4 2.8 GHz CPU. The last 5 entries differ by being pure perl implementations of the algorithms, which explains why they are so slow.</source>
          <target state="translated">这些数字是在2004年4月用ActivePerl-5.8.3在Linux下的P4 2.8 GHz CPU上实现的。最后5个条目的不同之处在于它们是纯perl算法的实现,这也解释了为什么它们会这么慢。</target>
        </trans-unit>
        <trans-unit id="397e9a46a749c3f6612fa5900c82fbeb3d54197f" translate="yes" xml:space="preserve">
          <source>These old, perl3-era utilities have been deprecated in favour of &lt;code&gt;h2xs&lt;/code&gt; for a long time. As of Perl 5.26, they have been removed.</source>
          <target state="translated">这些老的perl3时代的实用程序已被不推荐使用 &lt;code&gt;h2xs&lt;/code&gt; 了很长一段时间。从Perl 5.26开始，它们已被删除。</target>
        </trans-unit>
        <trans-unit id="b16394db34a86c1309e6f32038763254bbfec1e7" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">这些运算符以&lt;a href=&quot;../perlop&quot;&gt;perlop格式记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="902ffcf3ea51513d56fbec3ce0266f1b87291429" translate="yes" xml:space="preserve">
          <source>These operators are documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">这些运算符以&lt;a href=&quot;perlop&quot;&gt;perlop格式记录&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23835ab35bd3941ef690822a20797ba91ee28d2e" translate="yes" xml:space="preserve">
          <source>These operators are exempt from the &quot;looks like a function rule&quot; described above. That is, an opening parenthesis after the operator does not affect how much of the following code constitutes the argument. Put the opening parentheses before the operator to separate it from code that follows (this applies only to operators with higher precedence than unary operators, of course):</source>
          <target state="translated">这些运算符不受上面描述的 &quot;看起来像函数规则 &quot;的影响。也就是说,运算符后的开头括号并不影响下面的代码构成参数的多少。在运算符前加上开头的小括号,以将其与后面的代码分开(当然,这只适用于优先级高于单数运算符的运算符)。</target>
        </trans-unit>
        <trans-unit id="6b54b9bb627d1cf1404f3b5dab668ec8269f4aa6" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt; . If not, then only the &lt;code&gt;$name&lt;/code&gt; , &lt;code&gt;$uid&lt;/code&gt; , and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">如果您具有通过 &lt;code&gt;sys$getuai&lt;/code&gt; 检索指定用户的UAF信息所必需的特权，则这些运算符将获得&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;描述的信息。如果不是，则仅返回 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 项。在 &lt;code&gt;$dir&lt;/code&gt; 项包含在VMS语法登录目录，而 &lt;code&gt;$comment&lt;/code&gt; 项目包含在Unix中的语法登录目录。在 &lt;code&gt;$gcos&lt;/code&gt; 项目包含从UAF记录的所有者字段。在 &lt;code&gt;$quota&lt;/code&gt; 项不被使用。</target>
        </trans-unit>
        <trans-unit id="67e9c8225d78cd00aa38baba429b7de497a323bb" translate="yes" xml:space="preserve">
          <source>These operators obtain the information described in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, if you have the privileges necessary to retrieve the named user's UAF information via &lt;code&gt;sys$getuai&lt;/code&gt;. If not, then only the &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;$uid&lt;/code&gt;, and &lt;code&gt;$gid&lt;/code&gt; items are returned. The &lt;code&gt;$dir&lt;/code&gt; item contains the login directory in VMS syntax, while the &lt;code&gt;$comment&lt;/code&gt; item contains the login directory in Unix syntax. The &lt;code&gt;$gcos&lt;/code&gt; item contains the owner field from the UAF record. The &lt;code&gt;$quota&lt;/code&gt; item is not used.</source>
          <target state="translated">如果您具有通过 &lt;code&gt;sys$getuai&lt;/code&gt; 检索指定用户的UAF信息所必需的特权，则这些运算符将获得&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;描述的信息。如果不是，则仅返回 &lt;code&gt;$name&lt;/code&gt; ， &lt;code&gt;$uid&lt;/code&gt; 和 &lt;code&gt;$gid&lt;/code&gt; 项。在 &lt;code&gt;$dir&lt;/code&gt; 项包含在VMS语法登录目录，而 &lt;code&gt;$comment&lt;/code&gt; 项目包含在Unix中的语法登录目录。在 &lt;code&gt;$gcos&lt;/code&gt; 项目包含从UAF记录的所有者字段。在 &lt;code&gt;$quota&lt;/code&gt; 项不被使用。</target>
        </trans-unit>
        <trans-unit id="e7e657656c9789c3619d255f79ac9b3a6c835215" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because of the risk of them being used to generate floating point exceptions (which would have to be caught using a $SIG{FPE} handler).</source>
          <target state="translated">这些操作没有被包含在 :base_core 中,因为它们有可能被用来产生浮点异常(必须使用 $SIG{FPE}处理程序来捕获)。</target>
        </trans-unit>
        <trans-unit id="d5ea0da5f8ce978d8d492f686d44331bb4fc3946" translate="yes" xml:space="preserve">
          <source>These ops are not included in :base_core because they have an effect beyond the scope of the compartment.</source>
          <target state="translated">这些操作不包含在:base_core中,因为它们的效果超出了隔间的范围。</target>
        </trans-unit>
        <trans-unit id="dc4dfb8577c0955249e95ba26e17b894dbf4b7a2" translate="yes" xml:space="preserve">
          <source>These ops are related to multi-threading.</source>
          <target state="translated">这些操作与多线程有关。</target>
        </trans-unit>
        <trans-unit id="2901e27ec7bca28af121ed51d6417c782431820f" translate="yes" xml:space="preserve">
          <source>These ops enable</source>
          <target state="translated">这些操作使</target>
        </trans-unit>
        <trans-unit id="e55c6aacfd2933ba2a5d8d99593dbebe1787988f" translate="yes" xml:space="preserve">
          <source>These options affect which handler will be used for subsequently installed signals.</source>
          <target state="translated">这些选项会影响后续安装的信号将使用哪个处理程序。</target>
        </trans-unit>
        <trans-unit id="29c586cad3979b967f1d8c83a031669d4e85f7d5" translate="yes" xml:space="preserve">
          <source>These options control the 'vertical display' of opcodes. The display 'order' is also called 'mode' elsewhere in this document.</source>
          <target state="translated">这些选项控制操作码的 &quot;垂直显示&quot;。显示 &quot;顺序 &quot;在本文档其他地方也称为 &quot;模式&quot;。</target>
        </trans-unit>
        <trans-unit id="b5693ca212dce09ab36fc48e6272f7336e49446b" translate="yes" xml:space="preserve">
          <source>These options select the line-style (or just style) used to render each opcode, and dictates what info is actually printed into each line.</source>
          <target state="translated">这些选项选择了用于渲染每个操作码的行样式(或仅仅是样式),并决定了哪些信息被实际打印到每一行。</target>
        </trans-unit>
        <trans-unit id="822ae20d8832a94dbc806795384f0c1cb46d5024" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以全部下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="a96b412b0738a7917698193862d504e1b28178d5" translate="yes" xml:space="preserve">
          <source>These packages can all be downloaded by searching in the Download Center at &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以全部下载这些软件包。（事实证明，提供与这些软件包的精确链接是没有意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="e00985d023d49949f9c18d4b6917b5fcc1fe8b04" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">可以在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=zh_cn&lt;/a&gt;下载中心中搜索来下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="768a190e5a4a6b2a5a78de898be2b0088fa40b69" translate="yes" xml:space="preserve">
          <source>These packages can be downloaded by searching in the Download Center at &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">可以通过在下载中心（&lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;https://www.microsoft.com/downloads/search.aspx?displaylang=zh_CN）中&lt;/a&gt;搜索来下载这些软件包。（事实证明，提供与这些软件包的精确链接是没有意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="ee6b901a4b16ea8fd5c1a17b0f5f523262d0ae63" translate="yes" xml:space="preserve">
          <source>These packages can both be downloaded by searching in the Download Center at &lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;http://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以下载这些软件包。（事实证明，提供与这些软件包的确切链接是毫无意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="822cd7e5fb1f0c3664355e8d13292add5fdb70f7" translate="yes" xml:space="preserve">
          <source>These packages can both be downloaded by searching in the Download Center at &lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;. (Providing exact links to these packages has proven a pointless task because the links keep on changing so often.)</source>
          <target state="translated">通过在&lt;a href=&quot;https://www.microsoft.com/downloads/search.aspx?displaylang=en&quot;&gt;http://www.microsoft.com/downloads/search.aspx?displaylang=en&lt;/a&gt;的下载中心中搜索，可以下载这些软件包。（事实证明，提供与这些软件包的精确链接是没有意义的，因为链接经常更改。）</target>
        </trans-unit>
        <trans-unit id="b0b087e3db9d0ec8ccf2941b80cf3aaf473d4556" translate="yes" xml:space="preserve">
          <source>These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.</source>
          <target state="translated">目前这些perl例程(在Perl v.5.8.6中)不能处理通过的inf。</target>
        </trans-unit>
        <trans-unit id="5ee158f8c062eca4d28a3ec2d9f8d880c70ecea2" translate="yes" xml:space="preserve">
          <source>These possessive quantifiers represent a special case of a more general concept, the</source>
          <target state="translated">这些占有式定语代表了一个更一般的概念的特殊情况,也就是所谓的 &quot;占有式定语&quot;。</target>
        </trans-unit>
        <trans-unit id="bfd6c7d2c77daf624f0f4dda10d349c1b00557da" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , and all the Posix character classes</source>
          <target state="translated">这些属性是 &lt;code&gt;\b&lt;/code&gt; （不带花括号）， &lt;code&gt;\B&lt;/code&gt; （不带花括号）， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; 和所有Posix字符类</target>
        </trans-unit>
        <trans-unit id="75c6e853336d06e89c7d24890512216ff9df496b" translate="yes" xml:space="preserve">
          <source>These properties are &lt;code&gt;\b&lt;/code&gt; (without braces), &lt;code&gt;\B&lt;/code&gt; (without braces), &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, and all the Posix character classes</source>
          <target state="translated">这些属性是 &lt;code&gt;\b&lt;/code&gt; （不带花括号）， &lt;code&gt;\B&lt;/code&gt; （不带花括号）， &lt;code&gt;\s&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\W&lt;/code&gt; 和所有Posix字符类</target>
        </trans-unit>
        <trans-unit id="ac0cd3dd6b0da7da2a477124699c51a8786143da" translate="yes" xml:space="preserve">
          <source>These provide access to internal state and object instances.</source>
          <target state="translated">这些提供了对内部状态和对象实例的访问。</target>
        </trans-unit>
        <trans-unit id="49d4c7299af6c451da747abf6a31ed43bc6d224c" translate="yes" xml:space="preserve">
          <source>These quantifiers will try to match as much of the string as possible, while still allowing the regex to match. So we have</source>
          <target state="translated">这些量化符会尽量匹配字符串的大部分内容,同时仍允许regex匹配。所以我们有</target>
        </trans-unit>
        <trans-unit id="b9b2f742b1b0fcfd6307ec607f8aee70bbd6ff21" translate="yes" xml:space="preserve">
          <source>These readers return hashrefs of arbitrary unblessed data structures, each described more fully in the specification:</source>
          <target state="translated">这些读取器返回的是任意的无blessed数据结构的hashrefs,每个数据结构在规范中都有更完整的描述。</target>
        </trans-unit>
        <trans-unit id="26153a279914ed6ae972bab9be5035c10687695d" translate="yes" xml:space="preserve">
          <source>These results are &quot;meta&quot; information about the total results of an individual test program.</source>
          <target state="translated">这些结果是关于单个测试项目总结果的 &quot;元 &quot;信息。</target>
        </trans-unit>
        <trans-unit id="2bea10980ed9e4e8701806a5267309dec8b36b3d" translate="yes" xml:space="preserve">
          <source>These results refer to individual tests which are run.</source>
          <target state="translated">这些结果是指运行的单个测试。</target>
        </trans-unit>
        <trans-unit id="8893a5b7811d1faa2be1d81844c471e18cd604f6" translate="yes" xml:space="preserve">
          <source>These round modes always round in the same direction.</source>
          <target state="translated">这些圆形模式总是在同一个方向上圆。</target>
        </trans-unit>
        <trans-unit id="d39fb8588e2e03cf43f722c60791932347b9ede7" translate="yes" xml:space="preserve">
          <source>These rounding modes round to the nearest digit. They differ in how they determine which way to round in the ambiguous case when there is a tie.</source>
          <target state="translated">这些四舍五入模式都是四舍五入到最接近的数字。它们的不同之处在于,当出现平局时,它们如何确定以何种方式进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="f99e408a46643ae41ce4a2a5b658c331ee2d8a0f" translate="yes" xml:space="preserve">
          <source>These routines all create system-specific portability problems. As noted elsewhere, Perl is at the mercy of your C libraries for much of its system behavior. It's probably safest to assume broken SysV semantics for signals and to stick with simple TCP and UDP socket operations; e.g., don't try to pass open file descriptors over a local UDP datagram socket if you want your code to stand a chance of being portable.</source>
          <target state="translated">这些例程都会产生系统特有的可移植性问题。正如在其他地方所提到的,Perl的大部分系统行为都要听命于你的C库。可能最安全的做法是假设信号的 SysV 语义被破坏,并坚持使用简单的 TCP 和 UDP 套接字操作;例如,如果你想让你的代码有机会被移植,就不要试图通过本地 UDP 数据报套接字传递打开的文件描述符。</target>
        </trans-unit>
        <trans-unit id="7accb91a83a147e188cfdb7ea0bdeddeb0f7f3a7" translate="yes" xml:space="preserve">
          <source>These routines allow you to parse file paths into their directory, filename and suffix.</source>
          <target state="translated">这些例程允许你将文件路径解析为它们的目录、文件名和后缀。</target>
        </trans-unit>
        <trans-unit id="b2c49f2650fd89670405ec1fbc536b94e9ae8bdf" translate="yes" xml:space="preserve">
          <source>These routines are all documented in the Locale::Codes::API man page.</source>
          <target state="translated">这些例程都在Locale::Codes::API的man page里有记载。</target>
        </trans-unit>
        <trans-unit id="5bd965d62212a6eeb3c7fb76c8f854332dc29f76" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些例程非常有效，但始终保证与 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 一致。我们通过缓存以前见过的任何几个月的开始时间来管理此问题。如果我们知道一个月的开始时间，我们总是可以计算该月中的任何时间。使用数学公式计算开始时间。与其他算法多次调用 &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="54b6203ba949c1c3d7c2acb41e2e6e57811ab704" translate="yes" xml:space="preserve">
          <source>These routines are quite efficient and yet are always guaranteed to agree with &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;. We manage this by caching the start times of any months we've seen before. If we know the start time of the month, we can always calculate any time within the month. The start times are calculated using a mathematical formula. Unlike other algorithms that do multiple calls to &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="translated">这些例程非常有效，但始终保证与 &lt;code&gt;localtime()&lt;/code&gt; 和 &lt;code&gt;gmtime()&lt;/code&gt; 一致。我们通过缓存以前见过的任何几个月的开始时间来管理此问题。如果我们知道一个月的开始时间，我们总是可以计算该月中的任何时间。开始时间是使用数学公式计算的。与其他算法多次调用 &lt;code&gt;gmtime()&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="e296b7f9a5e96b639ca1839fa4442d3f45e92709" translate="yes" xml:space="preserve">
          <source>These routines are the same as their counterparts in the system C library. In list context, the return values from the various get routines are as follows:</source>
          <target state="translated">这些例程与系统C库中的对应例程相同。在列表上下文中,各种get例程的返回值如下。</target>
        </trans-unit>
        <trans-unit id="cc1ea3e493711677c93d92be2ec1c6ec9a5ee909" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt; , etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">在Perl v5.6.0之前，这些例程以前称为 &lt;code&gt;perl_call_sv&lt;/code&gt; 等，但是现在不赞成使用这些名称。提供相同名称的宏是为了兼容。</target>
        </trans-unit>
        <trans-unit id="93e20f0b82d868c177a926520e899384ae0d6b0f" translate="yes" xml:space="preserve">
          <source>These routines used to be called &lt;code&gt;perl_call_sv&lt;/code&gt;, etc., before Perl v5.6.0, but those names are now deprecated; macros of the same name are provided for compatibility.</source>
          <target state="translated">在Perl v5.6.0之前，这些例程以前被称为 &lt;code&gt;perl_call_sv&lt;/code&gt; 等，但是现在不赞成使用这些名称。提供了相同名称的宏，以实现兼容性。</target>
        </trans-unit>
        <trans-unit id="1fb1fb969b6c77a6565b33ce0e7b7cbfccc95cfb" translate="yes" xml:space="preserve">
          <source>These rules are complicated, but the goal is for them to do what you want (even if you don't quite understand why they are doing it). For example:</source>
          <target state="translated">这些规则很复杂,但目标是让它们做你想要的事情(即使你不太明白它们为什么要这么做)。比如说</target>
        </trans-unit>
        <trans-unit id="c63bc3c15060a430def6be9fa36745fbd5e2304e" translate="yes" xml:space="preserve">
          <source>These rules were designed for compactness of expression, rather than legibility and maintainability. The &lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&quot;/x and /xx&quot;&lt;/a&gt; pattern modifiers allow you to insert white space to improve readability. And use of &lt;code&gt;&lt;a href=&quot;re#%27strict%27-mode&quot;&gt;re 'strict'&lt;/a&gt;&lt;/code&gt; adds extra checking to catch some typos that might silently compile into something unintended.</source>
          <target state="translated">这些规则旨在表达的紧凑性，而不是易读性和可维护性。该&lt;a href=&quot;#%2Fx-and-%2Fxx&quot;&gt;&amp;ldquo;/ X和/ XX&amp;rdquo;&lt;/a&gt;模式修饰符允许你插入空格，以提高可读性。使用 &lt;code&gt;&lt;a href=&quot;re#%27strict%27-mode&quot;&gt;re 'strict'&lt;/a&gt;&lt;/code&gt; 会增加额外的检查，以捕获可能会悄悄地编译为意外内容的某些错别字。</target>
        </trans-unit>
        <trans-unit id="1c39d28608973eadb707da3830a9f4611c69ff29" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt; .</source>
          <target state="translated">这些选择Unicode规则。这意味着在双引号字符串中，该字符串始终会转换为UTF-8以强制执行Unicode解释（如果可能的话，您可以随后将 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 转换回非UTF8）。在正则表达式模式中，转换不会完成，但是如果字符集修饰符否则为 &lt;code&gt;/d&lt;/code&gt; ，则将其更改为 &lt;code&gt;/u&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b576853b18c74e3e57c9d5a616cf25646efde147" translate="yes" xml:space="preserve">
          <source>These select Unicode rules. That means that in double-quotish strings, the string is always converted to UTF-8 to force a Unicode interpretation (you can &lt;code&gt;utf8::downgrade()&lt;/code&gt; afterwards to convert back to non-UTF8, if possible). In regular expression patterns, the conversion isn't done, but if the character set modifier would otherwise be &lt;code&gt;/d&lt;/code&gt;, it is changed to &lt;code&gt;/u&lt;/code&gt;.</source>
          <target state="translated">这些选择Unicode规则。这意味着在双引号字符串中，该字符串始终会转换为UTF-8以强制执行Unicode解释（如果可能的话，您可以随后将 &lt;code&gt;utf8::downgrade()&lt;/code&gt; 转换回非UTF8）。在正则表达式模式中，转换不会完成，但是如果字符集修饰符否则为 &lt;code&gt;/d&lt;/code&gt; ，则将其更改为 &lt;code&gt;/u&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33be304d6b7f8ebe4e43f5c0dfa6aefb4009eb4" translate="yes" xml:space="preserve">
          <source>These sets of one-liners are equivalent:</source>
          <target state="translated">这几组单口相声是相当的。</target>
        </trans-unit>
        <trans-unit id="52c95446c9ca7d3ffaa7ed7da6e1f21bf02cdc2e" translate="yes" xml:space="preserve">
          <source>These settings can be overridden globally too:</source>
          <target state="translated">这些设置也可以全局覆盖。</target>
        </trans-unit>
        <trans-unit id="cbc91f3641f463359dfc31290abbc3a64d30454a" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt; . This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">这些应该是熟悉的操作，但 &lt;code&gt;av_unshift&lt;/code&gt; 除外。此例程在数组的前面添加了 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 值的 &lt;code&gt;num&lt;/code&gt; 个元素。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; （如下所述）为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="e729774b9950231de8aa37e9ccc295a6e06651f9" translate="yes" xml:space="preserve">
          <source>These should be familiar operations, with the exception of &lt;code&gt;av_unshift&lt;/code&gt;. This routine adds &lt;code&gt;num&lt;/code&gt; elements at the front of the array with the &lt;code&gt;undef&lt;/code&gt; value. You must then use &lt;code&gt;av_store&lt;/code&gt; (described below) to assign values to these new elements.</source>
          <target state="translated">这些操作应该是熟悉的操作，但 &lt;code&gt;av_unshift&lt;/code&gt; 除外。此例程在数组的前面添加了 &lt;code&gt;undef&lt;/code&gt; 值的 &lt;code&gt;num&lt;/code&gt; 个元素。然后，您必须使用 &lt;code&gt;av_store&lt;/code&gt; （如下所述）为这些新元素分配值。</target>
        </trans-unit>
        <trans-unit id="8f249c892c517536f796cbacefae284ca0ae8032" translate="yes" xml:space="preserve">
          <source>These should give you an overall feel for how modules are laid out and written.</source>
          <target state="translated">这些应该能让你对模块的布局和编写有一个整体的感觉。</target>
        </trans-unit>
        <trans-unit id="9a888f57551ca71c1272e83f90d05d460b30fbf3" translate="yes" xml:space="preserve">
          <source>These signal to a formatter that if it is to hyphenate &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done as &quot;sig-</source>
          <target state="translated">这些都是给格式化者的信号,如果要连字符 &quot;sigaction &quot;或 &quot;manuscript&quot;,那么就应该用 &quot;sig-&quot;。</target>
        </trans-unit>
        <trans-unit id="a76776d9b84dd64fcd8c2f12ffb416173943a78e" translate="yes" xml:space="preserve">
          <source>These signals usually indicate a serious problem with the Perl interpreter or with your script. They are ABRT, BUS, EMT, FPE, ILL, QUIT, SEGV, SYS and TRAP.</source>
          <target state="translated">这些信号通常表示Perl解释器或你的脚本有严重的问题,它们是ABRT,BUS,EMT,FPE,ILL,QUIT,SEGV,SYS和TRAP。它们是 ABRT,BUS,EMT,FPE,ILL,QUIT,SEGV,SYS 和 TRAP。</target>
        </trans-unit>
        <trans-unit id="7ee071669b1efa68f9a3156de49d5e707921d24a" translate="yes" xml:space="preserve">
          <source>These solutions can have far-reaching effects on your system and on the way you write your CGI programs, so investigate them with care.</source>
          <target state="translated">这些解决方案可能会对你的系统和你编写CGI程序的方式产生深远的影响,所以要仔细研究它们。</target>
        </trans-unit>
        <trans-unit id="b7b244316194399450de143deaa053b425f44f52" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*&lt;i&gt;VERB&lt;/i&gt;:&lt;i&gt;arg&lt;/i&gt;)&lt;/code&gt;. Unless otherwise stated the</source>
          <target state="translated">这些特殊模式通常采用 &lt;code&gt;(*&lt;i&gt;VERB&lt;/i&gt;:&lt;i&gt;arg&lt;/i&gt;)&lt;/code&gt; 形式。除非另有说明，否则</target>
        </trans-unit>
        <trans-unit id="af1c9d3db11663506b814ed4474ccb898e81f0dd" translate="yes" xml:space="preserve">
          <source>These special patterns are generally of the form &lt;code&gt;(*VERB:ARG)&lt;/code&gt;. Unless otherwise stated the ARG argument is optional; in some cases, it is forbidden.</source>
          <target state="translated">这些特殊模式通常采用 &lt;code&gt;(*VERB:ARG)&lt;/code&gt; 的形式。除非另有说明，否则A​​RG参数是可选的；在某些情况下，这是禁止的。</target>
        </trans-unit>
        <trans-unit id="44f08bb0d22471168dee4b6292fc949cf275107b" translate="yes" xml:space="preserve">
          <source>These special values become JSON true and JSON false values, respectively. You can also use &lt;code&gt;\1&lt;/code&gt; and &lt;code&gt;\0&lt;/code&gt; directly if you want.</source>
          <target state="translated">这些特殊值分别变为JSON true和JSON false值。如果需要，也可以直接使用 &lt;code&gt;\1&lt;/code&gt; 和 &lt;code&gt;\0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae6fd84e089df12e602215034c3af5ac8fb7e11a" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; , etc.) are dynamically scoped until the end of the enclosing block or until the next successful match, whichever comes first. (See &lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;Compound Statements in perlsyn&lt;/a&gt;.)</source>
          <target state="translated">这些特殊变量（如 &lt;code&gt;%+&lt;/code&gt; 哈希和编号的匹配变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; 等））会动态范围化，直到封闭块结束或下一次成功匹配为止，以先到者为准。 （请参阅&lt;a href=&quot;perlsyn#Compound-Statements&quot;&gt;perlsyn中的复合语句&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f99b2f0c65b0d18630113afe2aefcc29ab8a0144" translate="yes" xml:space="preserve">
          <source>These special variables, like the &lt;code&gt;%+&lt;/code&gt; hash and the numbered match variables (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;,</source>
          <target state="translated">这些特殊变量，例如 &lt;code&gt;%+&lt;/code&gt; 哈希和编号的匹配变量（ &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ， &lt;code&gt;$3&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="ba4f20c17b5b03a6a3deb3a04503955765039642" translate="yes" xml:space="preserve">
          <source>These strengths make it especially popular with web developers and system administrators. Mathematicians, geneticists, journalists, managers and many other people also use Perl.</source>
          <target state="translated">这些优点使它特别受到网络开发人员和系统管理员的欢迎。数学家、遗传学家、记者、经理人等也都在使用Perl。</target>
        </trans-unit>
        <trans-unit id="a952f4bd002dc5bdafb796a94c6eaa4765c9b45b" translate="yes" xml:space="preserve">
          <source>These strings do not match /\Bam\B/</source>
          <target state="translated">这些字符串与/BamB/不匹配</target>
        </trans-unit>
        <trans-unit id="2125a4453223ddc6316d0fee4d859469467def9f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\b'\b/.</source>
          <target state="translated">这些字符串不符合/b'b/。</target>
        </trans-unit>
        <trans-unit id="8aa64b62307f4ac9360d6b96b7d4a2888dc9ba0f" translate="yes" xml:space="preserve">
          <source>These strings do not match /\bPerl\b/.</source>
          <target state="translated">这些字符串不符合/bPerlb/。</target>
        </trans-unit>
        <trans-unit id="1ece96fea144561ec8d240482b56438a3b8cd021" translate="yes" xml:space="preserve">
          <source>These subroutines are only visible within the block in which they are declared, and only after that declaration:</source>
          <target state="translated">这些子程序只有在它们被声明的区块中才可见,而且只有在声明之后才可见。</target>
        </trans-unit>
        <trans-unit id="5002f9badee48e82e2e716cfadae24bcbea4d597" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Level&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Level&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="de652943440f246885efed6bc50624dc94d59ab4" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Method&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Method&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="4ec9419fff6178cfe016f55595d7a90364f97f63" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;Strategy&lt;/code&gt; option in the constructor.</source>
          <target state="translated">这些符号常量由构造函数中的 &lt;code&gt;Strategy&lt;/code&gt; 选项使用。</target>
        </trans-unit>
        <trans-unit id="09599ebf73a41d7f3fd327344d88fceb70681aab" translate="yes" xml:space="preserve">
          <source>These symbolic constants are used by the &lt;code&gt;flush&lt;/code&gt; method.</source>
          <target state="translated">这些符号常量由 &lt;code&gt;flush&lt;/code&gt; 方法使用。</target>
        </trans-unit>
        <trans-unit id="430e03746fb928435d7aa08e0e3eea945da77d4a" translate="yes" xml:space="preserve">
          <source>These symbols appear before the op-name, and indicate the B:: namespace that represents the ops in your Perl code.</source>
          <target state="translated">这些符号出现在 op-name 之前,表示在你的 Perl 代码中代表 ops 的 B::命名空间。</target>
        </trans-unit>
        <trans-unit id="aded896deefbdaf418ca756d53862b007b01f8b9" translate="yes" xml:space="preserve">
          <source>These terms are interpreted as described in IETF RFC 2119.</source>
          <target state="translated">这些术语的解释如IETF RFC 2119中所述。</target>
        </trans-unit>
        <trans-unit id="2dbd7a997bbaaa84741a5e1fbd14e323c239d540" translate="yes" xml:space="preserve">
          <source>These terms are your choice of any of (1) the Perl Artistic Licence, or (2) version 2 of the GNU General Public License as published by the Free Software Foundation, or (3) any later version of the GNU General Public License.</source>
          <target state="translated">您可以选择(1)Perl Artistic License,或(2)自由软件基金会发布的GNU通用公共许可证第2版,或(3)GNU通用公共许可证的任何更新版本。</target>
        </trans-unit>
        <trans-unit id="5c298e17caacd4174da139fecae9a62cf22ed5cc" translate="yes" xml:space="preserve">
          <source>These tests are expected to succeed. Usually, most or all of your tests are in this category. If a normal test doesn't succeed, then that means that something is</source>
          <target state="translated">这些测试有望成功。通常,你的大部分或全部测试都属于这一类。如果一个正常的测试不成功,那么就意味着有些东西是</target>
        </trans-unit>
        <trans-unit id="07325952f04a521e228140b025365f61c44af25f" translate="yes" xml:space="preserve">
          <source>These three macros are used to change a memory buffer size or to free a piece of memory no longer needed. The arguments to &lt;code&gt;Renew&lt;/code&gt; and &lt;code&gt;Renewc&lt;/code&gt; match those of &lt;code&gt;New&lt;/code&gt; and &lt;code&gt;Newc&lt;/code&gt; with the exception of not needing the &quot;magic cookie&quot; argument.</source>
          <target state="translated">这三个宏用于更改内存缓冲区大小或释放不再需要的内存。 &lt;code&gt;Renew&lt;/code&gt; 和 &lt;code&gt;Renewc&lt;/code&gt; 的参数与 &lt;code&gt;New&lt;/code&gt; 和 &lt;code&gt;Newc&lt;/code&gt; 的参数匹配，但不需要&amp;ldquo;魔术cookie&amp;rdquo;参数。</target>
        </trans-unit>
        <trans-unit id="3b6ba4dd1926405bd4af1077435f09d7c0a86a11" translate="yes" xml:space="preserve">
          <source>These three macros are used to move, copy, or zero out previously allocated memory. The &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; arguments point to the source and destination starting points. Perl will move, copy, or zero out &lt;code&gt;number&lt;/code&gt; instances of the size of the &lt;code&gt;type&lt;/code&gt; data structure (using the &lt;code&gt;sizeof&lt;/code&gt; function).</source>
          <target state="translated">这三个宏用于将先前分配的内存移出，复制或归零。该 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 参数指向源和目标的起点。Perl会移动，复制，或零出 &lt;code&gt;number&lt;/code&gt; 的大小的情况下， &lt;code&gt;type&lt;/code&gt; 数据结构（使用 &lt;code&gt;sizeof&lt;/code&gt; 函数）。</target>
        </trans-unit>
        <trans-unit id="335c760b89ccd866bd4e5cd7ec4e5ef4c599cbd4" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">这两个导出标记会全局修改bsd_glob（）的默认标志，并且在VMS上会修改Perl的内置 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 运算符。 &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 分别打开或关闭。</target>
        </trans-unit>
        <trans-unit id="2f0953e19b1283bac80bee4d4c7b6b45f4e0bf61" translate="yes" xml:space="preserve">
          <source>These two export tags globally modify the default flags that bsd_glob() and, except on VMS, Perl's built-in &lt;code&gt;glob&lt;/code&gt; operator use. &lt;code&gt;GLOB_NOCASE&lt;/code&gt; is turned on or off, respectively.</source>
          <target state="translated">这两个导出标记会全局修改bsd_glob（）的默认标志，并且除VMS以外，还可以使用Perl的内置 &lt;code&gt;glob&lt;/code&gt; 运算符。 &lt;code&gt;GLOB_NOCASE&lt;/code&gt; 分别打开或关闭。</target>
        </trans-unit>
        <trans-unit id="9660fc7e9efd93a7abe465c81de57e11a5045a23" translate="yes" xml:space="preserve">
          <source>These two features are available starting with Perl 5.16.</source>
          <target state="translated">这两个功能从Perl 5.16开始就可以使用。</target>
        </trans-unit>
        <trans-unit id="fa5480402538907c3c246c95ce18885b4ae5225b" translate="yes" xml:space="preserve">
          <source>These two handles are held in the array part of the GLOB until either &lt;code&gt;reader&lt;/code&gt; or &lt;code&gt;writer&lt;/code&gt; is called.</source>
          <target state="translated">这两个句柄保存在GLOB的数组部分中，直到调用 &lt;code&gt;reader&lt;/code&gt; 或 &lt;code&gt;writer&lt;/code&gt; 器为止。</target>
        </trans-unit>
        <trans-unit id="b0f87921e5dc8828d5a6d9ea360bbab6bf450027" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt; s:</source>
          <target state="translated">这两个较低级别的宏已定义，但是仅在处理非 &lt;code&gt;SV*&lt;/code&gt; 的键时才使用：</target>
        </trans-unit>
        <trans-unit id="b2d573ca29281a8113cbc1782d1b335ee12feb43" translate="yes" xml:space="preserve">
          <source>These two lower level macros are defined, but must only be used when dealing with keys that are not &lt;code&gt;SV*&lt;/code&gt;s:</source>
          <target state="translated">这两个较低级别的宏已定义，但仅在处理非 &lt;code&gt;SV*&lt;/code&gt; 的键时才必须使用：</target>
        </trans-unit>
        <trans-unit id="4ca39330e5c20e1239e2de6584e211ecc882f376" translate="yes" xml:space="preserve">
          <source>These two methods are discussed in the section &quot;Controlling Lookup Failure&quot;.</source>
          <target state="translated">这两种方法将在 &quot;控制查找失败 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="0b5a74bc9d562e1d07daa7fdb3ddf9da715c3433" translate="yes" xml:space="preserve">
          <source>These two methods return the pad names, using B::SPECIAL objects for null pointers and B::PADNAME objects otherwise.</source>
          <target state="translated">这两个方法返回pad名称,对于空指针使用B::SPECIAL对象,否则使用B::PADNAME对象。</target>
        </trans-unit>
        <trans-unit id="74ded97cfff6de6cbb1491c5e4159e3babfbcd36" translate="yes" xml:space="preserve">
          <source>These two parameters are used to specify the ambient pragmas in the format used by the special variables $^H and ${^WARNING_BITS}.</source>
          <target state="translated">这两个参数是用来指定环境语法的,格式为特殊变量$^H和${^WARNING_BITS}。</target>
        </trans-unit>
        <trans-unit id="668c2e486db55d10e5d748ec32a4297d24e80364" translate="yes" xml:space="preserve">
          <source>These two values for</source>
          <target state="translated">这两个值为</target>
        </trans-unit>
        <trans-unit id="fded399d428f7e457d56603aa714f9152134fea1" translate="yes" xml:space="preserve">
          <source>These utilities help manage extra Perl modules that don't come with the perl distribution.</source>
          <target state="translated">这些实用程序可以帮助管理额外的Perl模块,这些模块并不包含在perl发行版中。</target>
        </trans-unit>
        <trans-unit id="25a3a72bd29e8059a94921c647bd6ce419cc4377" translate="yes" xml:space="preserve">
          <source>These values will not change for the duration of the tied hash</source>
          <target state="translated">这些值在绑定的哈希期间不会改变。</target>
        </trans-unit>
        <trans-unit id="32b1d023c49a0c39aa9dd2f2164ec0cee979dc1b" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process.</source>
          <target state="translated">这些变量对整个进程来说是全局的,它们被进程中的所有解释器和所有线程共享。它们在一个进程中的所有解释器和所有线程之间共享。</target>
        </trans-unit>
        <trans-unit id="c34e796e9875a610406c8f84f6c6846160af7938" translate="yes" xml:space="preserve">
          <source>These variables are global to an entire process. They are shared between all interpreters and all threads in a process. Any variables not documented here may be changed or removed without notice, so don't use them! If you feel you really do need to use an unlisted variable, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that someone there will point out a way to accomplish what you need without using an internal variable. But if not, you should get a go-ahead to document and then use the variable.</source>
          <target state="translated">这些变量是整个过程的全局变量。它们在进程的所有解释器和所有线程之间共享。此处未记录的任何变量可能会更改或删除，恕不另行通知，因此请不要使用它们！如果您确实需要使用未列出的变量，请首先将电子邮件发送至&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;。可能有人在那里指出了一种无需使用内部变量即可完成您所需要的方法的方法。但是，如果没有，您应该重新编写文档，然后使用该变量。</target>
        </trans-unit>
        <trans-unit id="53f5ad69f1f855f312a7f31903221b231e10b532" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped, unless we note otherwise.</source>
          <target state="translated">除非我们另有说明,否则这些变量是只读和动态范围的。</target>
        </trans-unit>
        <trans-unit id="2a1de91c215bb3911b0f9767ad8cb63c7c66902f" translate="yes" xml:space="preserve">
          <source>These variables are read-only and dynamically-scoped.</source>
          <target state="translated">这些变量是只读和动态范围的。</target>
        </trans-unit>
        <trans-unit id="c7b31baa2b679d0f632af8871cff4bfcc11fe664" translate="yes" xml:space="preserve">
          <source>These variables are used not only to represent Perl-space variables, but also any constants in the code, as well as some structures completely internal to Perl. The symbol table, for instance, is an ordinary Perl hash. Your code is represented by an SV as it's read into the parser; any program files you call are opened via ordinary Perl filehandles, and so on.</source>
          <target state="translated">这些变量不仅用来表示Perl空间的变量,还用来表示代码中的任何常量,以及一些完全属于Perl内部的结构。例如,符号表就是一个普通的Perl哈希。你的代码在被读入解析器时,用SV表示;你调用的任何程序文件都是通过普通的Perl文件柄打开的,以此类推。</target>
        </trans-unit>
        <trans-unit id="82a728707d8b23d45f027d3109e809864b998b05" translate="yes" xml:space="preserve">
          <source>These variables determine the default state of the object created by calling the &lt;code&gt;new&lt;/code&gt; method, but cannot be used to alter the state of the object thereafter. The equivalent method names should be used instead to query or set the internal state of the object.</source>
          <target state="translated">这些变量确定通过调用 &lt;code&gt;new&lt;/code&gt; 方法创建的对象的默认状态，但此后不能用于更改对象的状态。应该使用等效的方法名称来查询或设置对象的内部状态。</target>
        </trans-unit>
        <trans-unit id="21d06b0dd7e2966bcc2949ad21cc8cf11e259059" translate="yes" xml:space="preserve">
          <source>These variables provide information about the current interpreter state.</source>
          <target state="translated">这些变量提供了当前解释器状态的信息。</target>
        </trans-unit>
        <trans-unit id="44c61b22b7df4c04e51047feabc1fcdef03de656" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen(3)&lt;/a&gt; modes of &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;r+&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;w+&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;a+&lt;/code&gt;.</source>
          <target state="translated">这些不同的前缀对应于 &lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;r+&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;w+&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a+&lt;/code&gt; 的&lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（3）&lt;/a&gt;模式。</target>
        </trans-unit>
        <trans-unit id="3ee1fe032de721a344cba89480c67e716abbee89" translate="yes" xml:space="preserve">
          <source>These various prefixes correspond to the fopen(3) modes of &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;r+&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; , &lt;code&gt;w+&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , and &lt;code&gt;a+&lt;/code&gt; .</source>
          <target state="translated">这些不同的前缀对应于 &lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;r+&lt;/code&gt; ， &lt;code&gt;w&lt;/code&gt; ， &lt;code&gt;w+&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;a+&lt;/code&gt; 的fopen（3）模式。</target>
        </trans-unit>
        <trans-unit id="ab874a84fee8b167d507adabcea364962ee19104" translate="yes" xml:space="preserve">
          <source>These vars take 3 forms:</source>
          <target state="translated">这些变量有3种形式。</target>
        </trans-unit>
        <trans-unit id="b607e9f6b449fd1b8f047ca8c774e440f540bc1c" translate="yes" xml:space="preserve">
          <source>These were was released in Test::More 0.82, and first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">这些都是在 Test::More 0.82 中发布的,并在 Test::More 0.92 中作为 Perl 的一部分在 5.10.1 中首次发布。</target>
        </trans-unit>
        <trans-unit id="dbff7e2745b850ca42a72fcb2a24d874bb4460d2" translate="yes" xml:space="preserve">
          <source>These will take care of 64-bit integers and long doubles. For example:</source>
          <target state="translated">这些将处理64位整数和长双数。例如:</target>
        </trans-unit>
        <trans-unit id="ac19dfbee94adc36e2c9732558c6cd8eefc750a8" translate="yes" xml:space="preserve">
          <source>These will tell you if you truly have an integer, double, or string pointer stored in your SV. The &quot;p&quot; stands for private.</source>
          <target state="translated">这些将告诉你,你的SV中是否真的存储了一个整数、双数或字符串指针。p &quot;代表私有。</target>
        </trans-unit>
        <trans-unit id="01c10ede2ffed1b0b1b81928ac4993a2913e0a5d" translate="yes" xml:space="preserve">
          <source>These work as in normal strings.</source>
          <target state="translated">这些工作和普通字符串一样。</target>
        </trans-unit>
        <trans-unit id="187ee14d57ea8ada7fd976b56339ad22b9d5a13e" translate="yes" xml:space="preserve">
          <source>These would be split and each converted to a prerequisite with a minimum version of zero.</source>
          <target state="translated">这些将被拆分,并各自转换为前提条件,最小版本为零。</target>
        </trans-unit>
        <trans-unit id="38675552ee022f79a520bb1f28a37d1e98aa3227" translate="yes" xml:space="preserve">
          <source>They all return true if the test passed, false if the test failed.</source>
          <target state="translated">如果测试通过,它们都返回true,如果测试失败,则返回false。</target>
        </trans-unit>
        <trans-unit id="8c3cf570334019dd16b6da35836503ad0b730443" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt; ), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">它们还返回并接受整个哈希条目（ &lt;code&gt;HE*&lt;/code&gt; ），从而使它们的使用效率更高（因为不必每次都重新计算特定字符串的哈希值）。有关详细说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48ac4e95d836a1020bf0ae83cd70b2eeacf64b7e" translate="yes" xml:space="preserve">
          <source>They also return and accept whole hash entries (&lt;code&gt;HE*&lt;/code&gt;), making their use more efficient (since the hash number for a particular string doesn't have to be recomputed every time). See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions.</source>
          <target state="translated">它们还返回并接受整个哈希条目（ &lt;code&gt;HE*&lt;/code&gt; ），从而使它们的使用效率更高（因为不必每次都重新计算特定字符串的哈希值）。有关详细说明，请参见&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a25c349a57769dbafa1bf807ae04ad1d22921bb7" translate="yes" xml:space="preserve">
          <source>They are not exported and must be addressed using the full package name.</source>
          <target state="translated">它们不会被导出,必须使用完整的包名进行处理。</target>
        </trans-unit>
        <trans-unit id="82e0433b7d59191ca9d6b5b4f7f2c32e84b80d15" translate="yes" xml:space="preserve">
          <source>They are suspected to be compiler errors (at least the shuffle.t failure is known from some IRIX 6 setups) and math library errors (the Trig.t failure), but since IRIX 5 is long since end-of-lifed, further fixes for the IRIX are unlikely. If you can get gcc for 5.3, you could try that, too, since gcc in IRIX 6 is a known workaround for at least the shuffle.t and sort.t failures.</source>
          <target state="translated">它们被怀疑是编译器错误(至少在一些IRIX 6的设置中知道shuffle.t失败)和数学库错误(Trig.t失败),但由于IRIX 5早已寿终正寝,因此不太可能对IRIX进行进一步的修复。如果你能得到5.3版的gcc,你也可以试试,因为在IRIX 6中的gcc是一个已知的解决方法,至少可以解决shuffle.t和sort.t故障。</target>
        </trans-unit>
        <trans-unit id="69688ab534f08d7044475644301b479b2c0aa07a" translate="yes" xml:space="preserve">
          <source>They are type specifiers, as detailed in &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;:</source>
          <target state="translated">它们是类型说明符，如&lt;a href=&quot;perldata&quot;&gt;perldata中所述&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e0af70f00dfa3e42a5613047a29fed35339f3d84" translate="yes" xml:space="preserve">
          <source>They come in handy when you want to print or find the size of data.</source>
          <target state="translated">当你想打印或查找数据的大小时,它们就会派上用场。</target>
        </trans-unit>
        <trans-unit id="af45a4b37483f2a06205c7d3d09277fb7f496321" translate="yes" xml:space="preserve">
          <source>They differ in how they behave if they have the same key as the default metadata. META_ADD will override the default value with its own. META_MERGE will merge its value with the default.</source>
          <target state="translated">它们的不同之处在于,如果它们的键与默认元数据相同,它们的行为就会有所不同。META_ADD将用它自己的值覆盖默认值。META_MERGE将把它的值与默认值合并。</target>
        </trans-unit>
        <trans-unit id="38d5f7d4e163392c98f5f93a608be715596d63d6" translate="yes" xml:space="preserve">
          <source>They exist principally so that you can write code like:</source>
          <target state="translated">它们的存在主要是为了让你可以写出类似的代码。</target>
        </trans-unit>
        <trans-unit id="1d5b76cad965b54d55da4f5003ea6633c3207e12" translate="yes" xml:space="preserve">
          <source>They look like they might have been meant to be the POSIX classes &lt;code&gt;[:alnum:]&lt;/code&gt; or &lt;code&gt;[:digit:]&lt;/code&gt;. If so, they should be written:</source>
          <target state="translated">它们看起来好像应该是POSIX类 &lt;code&gt;[:alnum:]&lt;/code&gt; 或 &lt;code&gt;[:digit:]&lt;/code&gt; 一样。如果是这样，则应将它们写成：</target>
        </trans-unit>
        <trans-unit id="7317b86bbf49f550672235cb05f34f1bf614569a" translate="yes" xml:space="preserve">
          <source>They may be deprecated in future versions.</source>
          <target state="translated">它们在未来的版本中可能会被废弃。</target>
        </trans-unit>
        <trans-unit id="9d9f866ec06430c109794c0b11daa6f4be4c1816" translate="yes" xml:space="preserve">
          <source>They may be expecting something completely different.</source>
          <target state="translated">他们可能期待的是完全不同的东西。</target>
        </trans-unit>
        <trans-unit id="330c7e5216d53f5b33c24e5c7f8fd3d4ead54c44" translate="yes" xml:space="preserve">
          <source>They seem to be caused by broken system header files, and also other open source projects are seeing them. The following HP-UX patches should make the warnings go away:</source>
          <target state="translated">这些警告似乎是由系统头文件损坏引起的,其他开源项目也看到了这些警告。以下的HP-UX补丁应该可以让这些警告消失。</target>
        </trans-unit>
        <trans-unit id="b797d5622b1d1393375da6062407cd69c0ce1eae" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">它们的工作方式有点像编译器指令（pragmata），因为它们会影响程序的编译，因此通常仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 中使用时才能正常工作。其中大多数都在词法范围内，因此内部的BLOCK可以通过说出以下命令来反抗它们：</target>
        </trans-unit>
        <trans-unit id="0fbe1e3187d25099c55738d9668bd711bb597a03" translate="yes" xml:space="preserve">
          <source>They work somewhat like compiler directives (pragmata) in that they tend to affect the compilation of your program, and thus will usually work well only when used within a &lt;code&gt;use&lt;/code&gt;, or &lt;code&gt;no&lt;/code&gt;. Most of these are lexically scoped, so an inner BLOCK may countermand them by saying:</source>
          <target state="translated">它们的工作方式有点像编译器指令（pragmata），因为它们会影响程序的编译，因此通常只有在 &lt;code&gt;use&lt;/code&gt; 内使用或 &lt;code&gt;no&lt;/code&gt; 时才能正常使用。其中大多数都在词法范围内，因此内部的BLOCK可以通过说出以下命令来抵消它们：</target>
        </trans-unit>
        <trans-unit id="6abf5248bc6675a47a3988cb21c2af942a4be9d1" translate="yes" xml:space="preserve">
          <source>They works like the same name operators as theirs.</source>
          <target state="translated">他们的工作原理就像他们的名字运营商一样。</target>
        </trans-unit>
        <trans-unit id="dd7133f0a4178555cc80821515a5b2265342ef9d" translate="yes" xml:space="preserve">
          <source>They're opcode specific, and occur less often than the public ones, so they're represented by short mnemonics instead of single-chars; see B::Op_private and</source>
          <target state="translated">它们是特定于操作码的,比公共的操作码出现的频率要低,所以它们用短记号来表示,而不是单字符;参见B::Op_private和</target>
        </trans-unit>
        <trans-unit id="0131651c3742a3954926cbf8ce6d20cf77a6751b" translate="yes" xml:space="preserve">
          <source>Things not effected by this flag</source>
          <target state="translated">不受此旗帜影响的事物</target>
        </trans-unit>
        <trans-unit id="c1537a4a381e27d6bdd2214d8f21c4c16bc119e0" translate="yes" xml:space="preserve">
          <source>Things that are broken or just don't work quite right.</source>
          <target state="translated">损坏的东西或只是不完全正确的工作。</target>
        </trans-unit>
        <trans-unit id="a528372aced54ab7da812bd13e4c896f3899419e" translate="yes" xml:space="preserve">
          <source>Things that are effected by this flag</source>
          <target state="translated">受此旗帜影响的事物</target>
        </trans-unit>
        <trans-unit id="1e84de00a451ba7e5c811ee4e926df7205dd8b28" translate="yes" xml:space="preserve">
          <source>Things that are formatter dependant</source>
          <target state="translated">依赖于格式器的东西</target>
        </trans-unit>
        <trans-unit id="731699b64ef1b2479598864f867653535a2b0bbe" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">使Perl易于学习的东西：Unix经验，几乎任何类型的编程经验，对正则表达式的理解以及理解其他人的代码的能力。如果您需要做某事，那么可能已经完成了，通常可以免费获得一个可用的示例。也不要忘记Perl模块。它们在本常见问题解答的第3部分中进行了讨论，而&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;CPAN&lt;/a&gt;在第2部分中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="6bcc1ca5e0a5ecd67da294c2c8f1e99255fb0dfb" translate="yes" xml:space="preserve">
          <source>Things that make Perl easier to learn: Unix experience, almost any kind of programming experience, an understanding of regular expressions, and the ability to understand other people's code. If there's something you need to do, then it's probably already been done, and a working example is usually available for free. Don't forget Perl modules, either. They're discussed in Part 3 of this FAQ, along with &lt;a href=&quot;http://www.cpan.org/&quot;&gt;CPAN&lt;/a&gt;, which is discussed in Part 2.</source>
          <target state="translated">使Perl易于学习的东西：Unix经验，几乎任何类型的编程经验，对正则表达式的理解以及理解其他人的代码的能力。如果您需要做某事，那么可能已经完成了，通常可以免费获得一个可用的示例。也不要忘记Perl模块。它们在本常见问题解答的第3部分中进行了讨论，而&lt;a href=&quot;http://www.cpan.org/&quot;&gt;CPAN&lt;/a&gt;在第2部分中进行了讨论。</target>
        </trans-unit>
        <trans-unit id="d9717c58dca00ca4e0fdd51bb342bee53c9f4f98" translate="yes" xml:space="preserve">
          <source>Things that need to be done to improve this document.</source>
          <target state="translated">为改进本文件需要做的事情。</target>
        </trans-unit>
        <trans-unit id="8bbe6bf4aeb5dea432e939ae88abe2437f8000be" translate="yes" xml:space="preserve">
          <source>Things to take special care with, sometimes called WARNINGS.</source>
          <target state="translated">需要特别注意的事情,有时也叫警告。</target>
        </trans-unit>
        <trans-unit id="f330d2b9426f91894c132eec7839a297e7c3f2bb" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; (or &lt;b&gt;-w&lt;/b&gt;) in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">考虑可重用性。当您可能想再次做类似的事情时，为什么要浪费脑力呢？考虑将代码泛化。考虑编写模块或对象类。请考虑使代码 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;严格运行，并有效 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; （或&lt;b&gt;-w&lt;/b&gt;）。考虑放弃您的代码。考虑改变您的整个世界视野。考虑...哦，没关系。</target>
        </trans-unit>
        <trans-unit id="c82b5076931a791a0eeb9910a5bd8e3a5422353a" translate="yes" xml:space="preserve">
          <source>Think about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with &lt;code&gt;use strict&lt;/code&gt; and &lt;code&gt;use warnings&lt;/code&gt; in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.</source>
          <target state="translated">考虑可重用性。当您想再次执行类似的操作时，为什么要浪费脑力呢？考虑泛化您的代码。考虑编写模块或对象类。考虑使代码 &lt;code&gt;use strict&lt;/code&gt; 运行，并有效 &lt;code&gt;use warnings&lt;/code&gt; 。考虑放弃您的代码。考虑改变您的整个世界视野。考虑...哦，没关系。</target>
        </trans-unit>
        <trans-unit id="369cf00ca2016a53c53652dbdfad94b27946d096" translate="yes" xml:space="preserve">
          <source>Think carefully about whether OO is appropriate for your module. Gratuitous object orientation results in complex APIs which are difficult for the average module user to understand or use.</source>
          <target state="translated">仔细思考OO是否适合你的模块。免费的对象导向会导致复杂的API,一般模块用户很难理解或使用。</target>
        </trans-unit>
        <trans-unit id="d05ca6e0d80ee8bcc4977d0ae97da44f7a9ad4e9" translate="yes" xml:space="preserve">
          <source>Think of these macros as working a bit like &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; in Perl to limit the scope of local variables.</source>
          <target state="translated">可以将这些宏视为类似于Perl中的 &lt;code&gt;{&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt; 来限制局部变量的范围。</target>
        </trans-unit>
        <trans-unit id="b798a2f7f99599171fc59b43924703f9a2be020d" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;. You have been warned!</source>
          <target state="translated">想混合 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 和线程？请躺下，等到感觉消失。请注意， &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的语义在平台之间有所不同。例如，某些Unix系统将所有当前线程复制到子进程中，而其他系统仅复制称为 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; 的线程。你被警告了！</target>
        </trans-unit>
        <trans-unit id="d855fc6f4fe4cadf88e9af157138a372400d46cf" translate="yes" xml:space="preserve">
          <source>Thinking of mixing &lt;code&gt;fork()&lt;/code&gt; and threads? Please lie down and wait until the feeling passes. Be aware that the semantics of &lt;code&gt;fork()&lt;/code&gt; vary between platforms. For example, some Unix systems copy all the current threads into the child process, while others only copy the thread that called &lt;code&gt;fork()&lt;/code&gt;. You have been warned!</source>
          <target state="translated">想混合 &lt;code&gt;fork()&lt;/code&gt; 和线程？请躺下，等到感觉消失。请注意， &lt;code&gt;fork()&lt;/code&gt; 的语义在平台之间有所不同。例如，某些Unix系统将所有当前线程复制到子进程中，而其他系统仅复制称为 &lt;code&gt;fork()&lt;/code&gt; 的线程。你被警告了！</target>
        </trans-unit>
        <trans-unit id="55ee5f16e1e054ccf1ec34b584008166d240354f" translate="yes" xml:space="preserve">
          <source>Third Edition, revised by J. C. Dumbreck. Oxford University Press.</source>
          <target state="translated">第三版,由J.C.Dumbreck修订。牛津大学出版社。</target>
        </trans-unit>
        <trans-unit id="b2cb87c02d6ed6f908d60b7b75a5f67020a27ac2" translate="yes" xml:space="preserve">
          <source>Third:</source>
          <target state="translated">Third:</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="b2ba5f429f54422412e8d8cc932f13b88c985b41" translate="yes" xml:space="preserve">
          <source>This &quot;in all contexts&quot; construction is very common, and can be abbreviated, using the 'fail' key. This sets both the &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt; hints to the same value:</source>
          <target state="translated">这种&amp;ldquo;在所有情况下&amp;rdquo;的构造非常普遍，可以使用&amp;ldquo; fail&amp;rdquo;键来缩写。这 &lt;code&gt;scalar&lt;/code&gt; 和 &lt;code&gt;list&lt;/code&gt; 提示设置为相同的值：</target>
        </trans-unit>
        <trans-unit id="3b8ab74e7f407ff0613b1e22c57e79a02a3a70ca" translate="yes" xml:space="preserve">
          <source>This 'cheat sheet' is a handy reference, meant for beginning Perl programmers. Not everything is mentioned, but 195 features may already be overwhelming.</source>
          <target state="translated">这张 &quot;小抄 &quot;是一份方便的参考资料,是为初学 Perl 的程序员准备的。并非所有的功能都会被提及,但195个功能可能已经让人难以承受。</target>
        </trans-unit>
        <trans-unit id="b87ead78f18a2a4de0a885f72703b5402a2fe039" translate="yes" xml:space="preserve">
          <source>This &lt;b&gt;DOES NOT&lt;/b&gt; affect context on other hubs, only the hub used by the context will be affected.</source>
          <target state="translated">这&lt;b&gt;不会&lt;/b&gt;影响其他集线器上的上下文，只会影响上下文使用的集线器。</target>
        </trans-unit>
        <trans-unit id="70790687de96ba2a981057f320692cde5f07c030" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;$coderef&lt;/code&gt; is called before the one specified via &lt;code&gt;filter_json_object&lt;/code&gt;, if any. It gets passed the single value in the JSON object. If it returns a single value, it will be inserted into the data structure. If it returns nothing (not even &lt;code&gt;undef&lt;/code&gt; but the empty list), the callback from &lt;code&gt;filter_json_object&lt;/code&gt; will be called next, as if no single-key callback were specified.</source>
          <target state="translated">该 &lt;code&gt;$coderef&lt;/code&gt; 在通过 &lt;code&gt;filter_json_object&lt;/code&gt; 指定的那个（如果有的话）之前被调用。它在JSON对象中传递了单个值。如果返回单个值，它将被插入到数据结构中。如果它什么也不返回（甚至不是 &lt;code&gt;undef&lt;/code&gt; 而是空列表），那么 &lt;code&gt;filter_json_object&lt;/code&gt; 将调用filter_json_object的回调，就像未指定单键回调一样。</target>
        </trans-unit>
        <trans-unit id="449deebd32ed5eaf74d8aec8711aa290af1210b0" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is somewhat like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt; . However, whilst the C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;). A more C-like &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; (see above).</source>
          <target state="translated">这种 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 操作有点像在C中找到的 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ，因为它与读操作相反。perl &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数的包装器称为 &lt;code&gt;format_write&lt;/code&gt; 。但是，尽管C &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数返回写入的字节数，但是如果成功（例如 &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ），则此 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 函数仅返回true 。更像C的 &lt;code&gt;&lt;a href=&quot;../functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; （请参见上文）。</target>
        </trans-unit>
        <trans-unit id="7f5f153f1937141026057a558986308f5230af60" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;IO::Socket::INET&lt;/code&gt;-style argument is ignored, except if it is defined but false. See the &lt;code&gt;IO::Socket::INET&lt;/code&gt; INCOMPATIBILITES section below.</source>
          <target state="translated">此 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 样式的参数将被忽略，除非已定义但为false。请参见下面的 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 兼容部分。</target>
        </trans-unit>
        <trans-unit id="809a4dea69e66cbb56a6927382a1c7747ff2b245" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;POSIX::SigAction&lt;/code&gt; object is intended for use with the &lt;code&gt;POSIX::sigaction()&lt;/code&gt; function.</source>
          <target state="translated">该 &lt;code&gt;POSIX::SigAction&lt;/code&gt; 对象旨在与 &lt;code&gt;POSIX::sigaction()&lt;/code&gt; 函数一起使用。</target>
        </trans-unit>
        <trans-unit id="4dae482e8849607cb08d3169246c6cbb9eb47f40" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;write&lt;/code&gt; is somewhat like &lt;code&gt;write&lt;/code&gt; found in C, in that it is the opposite of read. The wrapper for the perl &lt;code&gt;write&lt;/code&gt; function is called &lt;code&gt;format_write&lt;/code&gt;. However, whilst the C &lt;code&gt;write&lt;/code&gt; function returns the number of bytes written, this &lt;code&gt;write&lt;/code&gt; function simply returns true if successful (like &lt;code&gt;print&lt;/code&gt;). A more C-like &lt;code&gt;write&lt;/code&gt; is &lt;code&gt;syswrite&lt;/code&gt; (see above).</source>
          <target state="translated">此 &lt;code&gt;write&lt;/code&gt; 有点类似于在C中找到的 &lt;code&gt;write&lt;/code&gt; ，因为它与读取相反。perl &lt;code&gt;write&lt;/code&gt; 函数的包装器称为 &lt;code&gt;format_write&lt;/code&gt; 。但是，尽管C &lt;code&gt;write&lt;/code&gt; 函数返回写入的字节数，但是如果成功（例如 &lt;code&gt;print&lt;/code&gt; ），则此 &lt;code&gt;write&lt;/code&gt; 函数仅返回true 。更加类似于C的 &lt;code&gt;write&lt;/code&gt; 是 &lt;code&gt;syswrite&lt;/code&gt; （请参见上文）。</target>
        </trans-unit>
        <trans-unit id="8a5e4636d7ee396c2538c58facc6d68cb4eb415b" translate="yes" xml:space="preserve">
          <source>This CPAN module lets you create application-level DTrace probes written in Perl.</source>
          <target state="translated">这个CPAN模块可以让您创建用Perl编写的应用级DTrace探针。</target>
        </trans-unit>
        <trans-unit id="511e2864753cd52a1ebcc75d7881ce1d9fb8ec6b" translate="yes" xml:space="preserve">
          <source>This DBM filter allows you to choose the character encoding will be store in the DBM file. The usage is</source>
          <target state="translated">这个DBM过滤器允许你选择将存储在DBM文件中的字符编码。其用法是</target>
        </trans-unit>
        <trans-unit id="8d6cf7bbaf015be1842a3503d362b5db206d9719" translate="yes" xml:space="preserve">
          <source>This DBM filter is used when interoperating with a C/C++ application that uses a C int as either the key and/or value in the DBM file.</source>
          <target state="translated">当与C/C++应用程序进行交互时,使用C int作为DBM文件中的键和/或值时,会用到这个DBM过滤器。</target>
        </trans-unit>
        <trans-unit id="b9afd96c4f0113b4f4a0ca24ef6b7ce1c1eceace" translate="yes" xml:space="preserve">
          <source>This DBM filter will compress all data before it is written to the database and uncompressed it on reading.</source>
          <target state="translated">这个DBM过滤器会在数据写入数据库之前压缩所有数据,并在读取时解压。</target>
        </trans-unit>
        <trans-unit id="b3c940c7a493363dfcc2ec46854ae2f8bf461ebc" translate="yes" xml:space="preserve">
          <source>This Filter will ensure that all data written to the DBM will be encoded in UTF-8.</source>
          <target state="translated">该过滤器将确保所有写入DBM的数据将以UTF-8编码。</target>
        </trans-unit>
        <trans-unit id="fc3e8623db78291ea4659afa55c27a0af1b2fdc1" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getaddrinfo() or inet_pton() instead for IPv6 support.</source>
          <target state="translated">这个只支持IPv4的函数主要是由于传统的原因而提供的,新编写的代码应该使用getaddrinfo(或inet_pton()来支持IPv6。新写的代码应该使用getaddrinfo()或inet_pton()来支持IPv6。</target>
        </trans-unit>
        <trans-unit id="a1b8940a7dbf27c2770dc1f730a7a76eb668b365" translate="yes" xml:space="preserve">
          <source>This IPv4-only function is provided largely for legacy reasons. Newly-written code should use getnameinfo() or inet_ntop() instead for IPv6 support.</source>
          <target state="translated">这个只支持IPv4的函数主要是出于传统的原因。新写的代码应该使用getnameinfo()或inet_ntop()来支持IPv6。</target>
        </trans-unit>
        <trans-unit id="86d1fee384e2c64930f89930b421f43ee54e6dc6" translate="yes" xml:space="preserve">
          <source>This List indicates the person(s) to contact concerning the distribution. The preferred form of the contact string is:</source>
          <target state="translated">该列表指出了有关分发的联系人。联系字符串的首选形式是:</target>
        </trans-unit>
        <trans-unit id="722a81c183f099f4bcdf928fea77c08691faed91" translate="yes" xml:space="preserve">
          <source>This MGVTBL structure is set at compile-time in</source>
          <target state="translated">这个MGVTBL结构是在编译时在</target>
        </trans-unit>
        <trans-unit id="1eec4cedd7f076095ac2a0ca9a9e96a3c88c0b97" translate="yes" xml:space="preserve">
          <source>This Map describes any files, directories, packages, and namespaces that are private to the packaging or implementation of the distribution and should be ignored by indexing or search tools. Note that this is a list of exclusions, and the spec does not define what to</source>
          <target state="translated">这个地图描述了任何文件、目录、包和命名空间,这些文件、目录、包和命名空间对发行版的打包或实现来说是私有的,应该被索引或搜索工具忽略。请注意,这是一个排除项的列表,本规范并没有定义什么是</target>
        </trans-unit>
        <trans-unit id="7caefbceb3b0366d47f8a2872ed9d7c71305e207" translate="yes" xml:space="preserve">
          <source>This Map describes optional features with incremental prerequisites. Each key of the &lt;code&gt;optional_features&lt;/code&gt; Map is a String used to identify the feature and each value is a Map with additional information about the feature. Valid subkeys include:</source>
          <target state="translated">该地图描述了具有先决条件的可选功能。 &lt;code&gt;optional_features&lt;/code&gt; 映射的每个键都是用于标识特征的字符串，每个值都是具有有关该特征的附加信息的映射。有效的子项包括：</target>
        </trans-unit>
        <trans-unit id="afdaa79397a40333f189bcdc4086a9d759ea82a0" translate="yes" xml:space="preserve">
          <source>This Perl can't reset CRTL environ elements (%s)</source>
          <target state="translated">这个Perl不能重置CRTL环境元素(%s)</target>
        </trans-unit>
        <trans-unit id="bb183f03494180e283020e26b8860c5c80cf5dab" translate="yes" xml:space="preserve">
          <source>This Perl can't set CRTL environ elements (%s=%s)</source>
          <target state="translated">这个Perl不能设置CRTL环境元素(%s=%s)</target>
        </trans-unit>
        <trans-unit id="b39321835728914af608511ebd3abfb95683e78c" translate="yes" xml:space="preserve">
          <source>This Perl has not been built with support for randomized hash key traversal but something called Perl_hv_rand_set().</source>
          <target state="translated">这个Perl并没有建立对随机化哈希键遍历的支持,而是建立了一个叫做Perl_hv_rand_set()的东西。</target>
        </trans-unit>
        <trans-unit id="705edfac9681ecc4ad006397ee2bb051d4e6ffce" translate="yes" xml:space="preserve">
          <source>This Perl not built to support threads</source>
          <target state="translated">这个Perl不是为支持线程而设计的</target>
        </trans-unit>
        <trans-unit id="d239471597c0b244a6c849bc4b21df8bfaf5b7db" translate="yes" xml:space="preserve">
          <source>This PerlIO layer opens a filehandle with a transparent encoding filter.</source>
          <target state="translated">这个PerlIO层打开一个带有透明编码过滤器的文件柄。</target>
        </trans-unit>
        <trans-unit id="a75ec57aa7be5f3e457676aa78fd87835feef6b5" translate="yes" xml:space="preserve">
          <source>This README was written by Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;, and subsequently updated by Dominic Dunlop &amp;lt;domo@computer.org&amp;gt; and Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;. The &quot;Starting From Scratch&quot; recipe was contributed by John Montbriand &amp;lt;montbriand@apple.com&amp;gt;.</source>
          <target state="translated">该自述文件由Sherm Pendley &amp;lt;sherm@dot-app.org&amp;gt;编写，随后由Dominic Dunlop &amp;lt;domo@computer.org&amp;gt;和Breno G. de Oliveira &amp;lt;garu@cpan.org&amp;gt;进行了更新。&amp;ldquo;从头开始&amp;rdquo;食谱由John Montbriand &amp;lt;montbriand@apple.com&amp;gt;贡献。</target>
        </trans-unit>
        <trans-unit id="ebd95c4f5ef4e4618995d165e48685abb75f4895" translate="yes" xml:space="preserve">
          <source>This TODO</source>
          <target state="translated">此待办事项</target>
        </trans-unit>
        <trans-unit id="65401762a1d1713b0f2418936baae5413a27fffb" translate="yes" xml:space="preserve">
          <source>This UTF8 flag is not visible in Perl scripts, exactly for the same reason you cannot (or rather, you</source>
          <target state="translated">这个UTF8标志在Perl脚本中是不可见的,这与你不能(或者说,你不能)使用</target>
        </trans-unit>
        <trans-unit id="4052f785cdabbfe61b3039b9711ade7bde52e516" translate="yes" xml:space="preserve">
          <source>This a copy of the $md5 object. It is useful when you do not want to destroy the digests state, but need an intermediate value of the digest, e.g. when calculating digests iteratively on a continuous data stream. Example:</source>
          <target state="translated">这是$md5对象的副本。当你不想破坏摘要状态,但需要一个摘要的中间值时,它是很有用的,例如,当你在一个连续的数据流上迭代计算摘要时。例如:当在连续数据流上迭代计算摘要时,它是有用的。</target>
        </trans-unit>
        <trans-unit id="1a5e99b1d24a191f2d8182b7f2daff87d3990749" translate="yes" xml:space="preserve">
          <source>This a perl class / module to enable you to use ARexx with your perlscript. Creating a function host or executing scripts in other hosts. The API is loosley modeled on the python arexx module supplied by with AmigaOS4.1</source>
          <target state="translated">这是一个perl类/模块,使你能够在你的perlscript中使用ARexx。创建一个函数主机或在其他主机中执行脚本。这个API是以AmigaOS4.1提供的python arexx模块为基础的。</target>
        </trans-unit>
        <trans-unit id="a160f7af224910b6019387f0709ad781bada6850" translate="yes" xml:space="preserve">
          <source>This a perl class / module to enables you to use various low level Amiga features such as waiting on an Exec signal</source>
          <target state="translated">这是一个perl类/模块,使你能够使用各种低级别的Amiga功能,如等待Exec信号。</target>
        </trans-unit>
        <trans-unit id="93d41ee6bf8db4bf77abd4b3d67925380ae0e1a1" translate="yes" xml:space="preserve">
          <source>This aborts parsing of the current document, by switching on the flag that indicates that EOF has been seen. In particularly drastic cases, you might want to do this. It's rather nicer than just calling &lt;code&gt;die&lt;/code&gt;!</source>
          <target state="translated">通过打开指示已经看到EOF的标志，这将中止当前文档的解析。在特别严重的情况下，您可能想要执行此操作。比叫 &lt;code&gt;die&lt;/code&gt; 还好！</target>
        </trans-unit>
        <trans-unit id="80e3860a781a3958ead624c7605f67461e6feac0" translate="yes" xml:space="preserve">
          <source>This action at a distance can be confusing, so you should be careful with your use of weaken. You should weaken the reference in the variable that will go out of scope</source>
          <target state="translated">这个动作在远处可能会引起混淆,所以你应该小心使用weaken。你应该弱化变量中的引用,因为它将超出范围</target>
        </trans-unit>
        <trans-unit id="6a24d0142f914abb864cc53bd42fb39ecd311c30" translate="yes" xml:space="preserve">
          <source>This action at a distance, perhaps a large distance, can lead to Perl silently misinterpreting what you meant, so when you specify that you want extra checking by &lt;code&gt;use re 'strict'&lt;/code&gt;, this warning is generated. If you meant the character as a literal, simply confirm that to Perl by preceding the character with a backslash, or make it into a bracketed character class (like &lt;code&gt;[}]&lt;/code&gt;). If you meant it as closing a corresponding &lt;code&gt;[&lt;/code&gt; or &lt;code&gt;{&lt;/code&gt;, you'll need to look back through the pattern to find out why that isn't happening.</source>
          <target state="translated">如果此操作距离很远，甚至很远，都可能导致Perl默默地误解您的意思，因此，当您指定要 &lt;code&gt;use re 'strict'&lt;/code&gt; 额外检查时，将生成此警告。如果您将字符当作文字使用，只需在字符前面加上反斜杠来确认Perl，或者将其放入方括号字符类中（例如 &lt;code&gt;[}]&lt;/code&gt; ）。如果您将其表示为关闭相应的 &lt;code&gt;[&lt;/code&gt; 或 &lt;code&gt;{&lt;/code&gt; ，那么您需要回顾一下模式以找出未发生这种情况的原因。</target>
        </trans-unit>
        <trans-unit id="bddc211ce6f51988dd46dcc142aadb4340b590dc" translate="yes" xml:space="preserve">
          <source>This adds a new excluded version. For example, you might use these three method calls:</source>
          <target state="translated">这将增加一个新的排除版本。例如,你可以使用以下三个方法调用。</target>
        </trans-unit>
        <trans-unit id="9b2561f6cd7d300e2bc3c36c86f010a9c3614953" translate="yes" xml:space="preserve">
          <source>This adds a new maximum version requirement. If the new requirement is redundant to the existing specification, this has no effect.</source>
          <target state="translated">这将增加一个新的最大版本要求。如果新的要求与现有的规范是多余的,则没有影响。</target>
        </trans-unit>
        <trans-unit id="8012fe61f20e1a816c0a4a7242f87aff7c9fa563" translate="yes" xml:space="preserve">
          <source>This adds a new minimum version requirement. If the new requirement is redundant to the existing specification, this has no effect.</source>
          <target state="translated">这增加了一个新的最低版本要求。如果新的要求与现有的规范是多余的,则没有影响。</target>
        </trans-unit>
        <trans-unit id="885dd09085650ee6eee0bbc42fb708bdc29aeb18" translate="yes" xml:space="preserve">
          <source>This adds your coderef as a follow-up to the root hub after Test2 is finished loading.</source>
          <target state="translated">这将在Test2加载完成后,添加你的coderef作为根中心的后续。</target>
        </trans-unit>
        <trans-unit id="31854231243bab283e1b65fbafa450794c35d551" translate="yes" xml:space="preserve">
          <source>This affects the &quot;udp&quot;, &quot;tcp&quot;, and &quot;syn&quot; protocols.</source>
          <target state="translated">这将影响 &quot;udp&quot;、&quot;tcp &quot;和 &quot;syn &quot;协议。</target>
        </trans-unit>
        <trans-unit id="c5505e253bfc6bced2ca4d4a2dc1f5c2494aeece" translate="yes" xml:space="preserve">
          <source>This affects the &lt;code&gt;CreateFile&lt;/code&gt; and &lt;code&gt;GetVolumeInformation&lt;/code&gt; calls.</source>
          <target state="translated">这会影响 &lt;code&gt;CreateFile&lt;/code&gt; 和 &lt;code&gt;GetVolumeInformation&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="cddee3439343bde4e7f7a86c9eebcbe6c66c9384" translate="yes" xml:space="preserve">
          <source>This affects the &lt;code&gt;ReadFile&lt;/code&gt; and &lt;code&gt;WriteFile&lt;/code&gt; calls.</source>
          <target state="translated">这会影响 &lt;code&gt;ReadFile&lt;/code&gt; 和 &lt;code&gt;WriteFile&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="873bbf87a172d66b10ad3b61904a0d639ca9b860" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt; . See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">这使Math :: BigInt可以从子类正确检索包全局变量，例如 &lt;code&gt;$SubClass::precision&lt;/code&gt; 。请参阅t / Math / BigInt / Subclass.pm或t / Math / BigFloat / SubClass.pm完整功能的子类示例。</target>
        </trans-unit>
        <trans-unit id="fa3309366ca565335ff8288304c30cc7b99e923e" translate="yes" xml:space="preserve">
          <source>This allows Math::BigInt to correctly retrieve package globals from the subclass, like &lt;code&gt;$SubClass::precision&lt;/code&gt;. See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.</source>
          <target state="translated">这使Math :: BigInt可以从子类正确地检索包全局变量，例如 &lt;code&gt;$SubClass::precision&lt;/code&gt; 。请参阅t / Math / BigInt / Subclass.pm或t / Math / BigFloat / SubClass.pm完整功能的子类示例。</target>
        </trans-unit>
        <trans-unit id="55b11d71facfcee62095e950521946dac7a2b9c8" translate="yes" xml:space="preserve">
          <source>This allows a reference to a variable to be declared with &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, our &lt;code&gt;our&lt;/code&gt;, or localized with &lt;code&gt;local&lt;/code&gt;. It is intended mainly for use in conjunction with the &quot;refaliasing&quot; feature. See &lt;a href=&quot;perlref#Declaring-a-Reference-to-a-Variable&quot;&gt;&quot;Declaring a Reference to a Variable&quot; in perlref&lt;/a&gt; for examples.</source>
          <target state="translated">这允许一个变量的引用与声明 &lt;code&gt;my&lt;/code&gt; ， &lt;code&gt;state&lt;/code&gt; ，我们的 &lt;code&gt;our&lt;/code&gt; ，或局部的 &lt;code&gt;local&lt;/code&gt; 。它主要用于与&amp;ldquo;重混音&amp;rdquo;功能一起使用。有关示例，请参见&lt;a href=&quot;perlref#Declaring-a-Reference-to-a-Variable&quot;&gt;perlref中的&amp;ldquo;声明对变量的引用&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d5501a126d7bcccb962537b6328418e9a9cd85d" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; , and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">这允许用户为目录为 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 和 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 的某些软件设置目录树，然后上述示例将允许使用lib目录中的模块，而无需知道软件树的安装位置。</target>
        </trans-unit>
        <trans-unit id="27816f401d954ec072345f1b707e0f267b956d02" translate="yes" xml:space="preserve">
          <source>This allows a user to setup a directory tree for some software with directories &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; and &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt;, and then the above example will allow the use of modules in the lib directory without knowing where the software tree is installed.</source>
          <target state="translated">这允许用户为目录为 &lt;code&gt;&amp;lt;root&amp;gt;/bin&lt;/code&gt; 和 &lt;code&gt;&amp;lt;root&amp;gt;/lib&lt;/code&gt; 的某些软件设置目录树，然后上述示例将允许使用lib目录中的模块，而无需知道软件树的安装位置。</target>
        </trans-unit>
        <trans-unit id="f2d1ac05408a326c089b0ec60746ba54464b2076" translate="yes" xml:space="preserve">
          <source>This allows for a more traditional use of sockatmark() as a procedural socket function. If your system does not support sockatmark(), the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="translated">这允许将sockatmark（）更传统地用作过程套接字函数。如果您的系统不支持sockatmark（），则 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 声明将在编译时失败。</target>
        </trans-unit>
        <trans-unit id="5c4bf55b527390af875f220a6a455b96b2cc2be5" translate="yes" xml:space="preserve">
          <source>This allows one to specify the</source>
          <target state="translated">这使得人们可以指定</target>
        </trans-unit>
        <trans-unit id="dd0d07d0d3a6167b29dae996bfd8a33bb4d04031" translate="yes" xml:space="preserve">
          <source>This allows the ability to provide an extra pointer (called the &quot;host&quot; environment) for all the system calls. This makes it possible for all the system stuff to maintain their own state, broken down into seven C structures. These are thin wrappers around the usual system calls (see</source>
          <target state="translated">这使得能够为所有的系统调用提供一个额外的指针(称为 &quot;主机 &quot;环境)。这使得所有的系统东西都可以保持自己的状态,分解为七个C结构。这些都是通常的系统调用的瘦包装器(见</target>
        </trans-unit>
        <trans-unit id="f2d9de12c87f7e2eb33ce435c5af882982d468fe" translate="yes" xml:space="preserve">
          <source>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</source>
          <target state="translated">这使得引擎可以复制其私有数据,但如果真的要修改最终结构,也可以在必要时进行修改。</target>
        </trans-unit>
        <trans-unit id="afb3f86b59b2eab9a83b014b190ee8244b9d77c6" translate="yes" xml:space="preserve">
          <source>This allows the programmer to look at the execution stack and variables to find out the cause of the exception. As the debugger is being invoked as the Perl interpreter is about to do a fatal exit, continuing the execution in debug mode is usually not practical.</source>
          <target state="translated">这使得程序员可以查看执行堆栈和变量,找出异常的原因。由于调试器是在Perl解释器即将进行致命退出时被调用的,因此在调试模式下继续执行通常是不现实的。</target>
        </trans-unit>
        <trans-unit id="0db2b07707171b33eaecb29767724fb7ef4d27b3" translate="yes" xml:space="preserve">
          <source>This allows the use of the &lt;code&gt;isa&lt;/code&gt; infix operator, which tests whether the scalar given by the left operand is an object of the class given by the right operand. See &lt;a href=&quot;perlop#Class-Instance-Operator&quot;&gt;&quot;Class Instance Operator&quot; in perlop&lt;/a&gt; for more details.</source>
          <target state="translated">这允许使用 &lt;code&gt;isa&lt;/code&gt; infix运算符，该运算符测试左操作数给定的标量是否是右操作数给定的类的对象。有关更多详细信息，请参见&lt;a href=&quot;perlop#Class-Instance-Operator&quot;&gt;perlop中的&amp;ldquo;类实例运算符&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1baefaa51fc7ed599ce445dad500d37cb72bf43c" translate="yes" xml:space="preserve">
          <source>This allows you to add a prefix to the backup file, instead of (or in addition to) a suffix:</source>
          <target state="translated">这允许您在备份文件中添加前缀,而不是(或附加)后缀。</target>
        </trans-unit>
        <trans-unit id="08c156e263d5342084a6b014f45a9a0f0a51e994" translate="yes" xml:space="preserve">
          <source>This allows you to add callbacks that will trigger every time a context for this hub is released. The only argument to the sub will be the &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; instance that was released. These will run in reverse order.</source>
          <target state="translated">这使您可以添加回调，该回调将在每次释放该中心的上下文时触发。子的唯一参数将是已发布的&lt;a href=&quot;Test2::API::Context&quot;&gt;Test2 :: API :: Context&lt;/a&gt;实例。这些将以相反的顺序运行。</target>
        </trans-unit>
        <trans-unit id="c13b99696d30cbc25087da7c60f284a4111dd701" translate="yes" xml:space="preserve">
          <source>This allows you to add callbacks that will trigger every time a new context is created for the hub. The only argument to the sub will be the &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; instance that was created.</source>
          <target state="translated">这样，您便可以添加将在每次为中心创建新上下文时触发的回调。子的唯一参数将是创建的&lt;a href=&quot;Test2::API::Context&quot;&gt;Test2 :: API :: Context&lt;/a&gt;实例。</target>
        </trans-unit>
        <trans-unit id="8c9c79134ff2ae5aa3b781af2dbc70121d4e03bb" translate="yes" xml:space="preserve">
          <source>This allows you to check that your test module is setting the correct value for $Test::Builder::Level and thus giving the correct file and line number when a test fails. It is calculated by looking at caller() and $Test::Builder::Level. It should count how many subroutines there are before jumping into the function you are testing. So for example in</source>
          <target state="translated">这允许你检查你的测试模块是否为$Test::Builder::Level设置了正确的值,从而在测试失败时给出正确的文件和行号。它是通过查看caller()和$Test::Builder::Level来计算的。它应该计算在跳入你要测试的函数之前有多少个子程序。因此,例如在</target>
        </trans-unit>
        <trans-unit id="3e47154414d862007ad5f643f15fef0b3978ca2c" translate="yes" xml:space="preserve">
          <source>This allows you to intermix your source code and your documentation text freely, as in</source>
          <target state="translated">这允许你自由地混合你的源代码和你的文档文本,如在</target>
        </trans-unit>
        <trans-unit id="56e637a731a56d0d223f91be743e436a188835e3" translate="yes" xml:space="preserve">
          <source>This allows you to pass a reference to a scalar, in which the data will be stored:</source>
          <target state="translated">这允许你传递一个对标量的引用,数据将被存储在标量中。</target>
        </trans-unit>
        <trans-unit id="56546e50a57dfe022838ff689d536d5a9d34e4c4" translate="yes" xml:space="preserve">
          <source>This allows you to provide a UUID generator. If provided UUIDs will be attached to all events, hubs, and contexts. This is useful for storing, tracking, and linking these objects.</source>
          <target state="translated">这允许你提供一个UUID生成器。如果提供了UUID,UUID将被附加到所有事件、中心和上下文。这对于存储、跟踪和链接这些对象很有用。</target>
        </trans-unit>
        <trans-unit id="ae11cd12869687833116af8fabb9e16d79564d09" translate="yes" xml:space="preserve">
          <source>This allows you to specify &lt;code&gt;constants&lt;/code&gt; in your template. ie, they keys that are not allowed to be altered by the user. It pretty much allows you to keep all your &lt;code&gt;configurable&lt;/code&gt; data in one place; the &lt;code&gt;Params::Check&lt;/code&gt; template.</source>
          <target state="translated">这使您可以在模板中指定 &lt;code&gt;constants&lt;/code&gt; 。即，它们不允许用户更改键。它几乎可以让您将所有可 &lt;code&gt;configurable&lt;/code&gt; 数据保存在一个地方。在 &lt;code&gt;Params::Check&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="02527ae1bd59af5a043ac93acd05be3d0f9bb884" translate="yes" xml:space="preserve">
          <source>This allows you to update your local repository by pulling from &lt;code&gt;origin&lt;/code&gt;, which is faster and doesn't require you to authenticate, and to push your changes back with the &lt;code&gt;camel&lt;/code&gt; remote:</source>
          <target state="translated">这使您可以通过从 &lt;code&gt;origin&lt;/code&gt; 提取来更新本地存储库，这更快，不需要身份验证，并且可以使用 &lt;code&gt;camel&lt;/code&gt; 遥控器将更改推回原位：</target>
        </trans-unit>
        <trans-unit id="fb3de596529e48bc02f1d5b4c0a477a1da824e62" translate="yes" xml:space="preserve">
          <source>This allows your code to set hints without relying on &lt;code&gt;autodie&lt;/code&gt; and &lt;code&gt;autodie::hints&lt;/code&gt; being loaded, or even installed. In this way your code can do the right thing when &lt;code&gt;autodie&lt;/code&gt; is installed, but does not need to depend upon it to function.</source>
          <target state="translated">这使您的代码可以设置提示，而无需依赖于 &lt;code&gt;autodie&lt;/code&gt; 和 &lt;code&gt;autodie::hints&lt;/code&gt; 加载甚至安装。这样，当安装了 &lt;code&gt;autodie&lt;/code&gt; 时，您的代码可以做正确的事情，而不必依赖于它来起作用。</target>
        </trans-unit>
        <trans-unit id="ec9cd2ea84115168b54e6b0797c0f572af954da0" translate="yes" xml:space="preserve">
          <source>This almost definitely doesn't do what you expect:</source>
          <target state="translated">这几乎肯定达不到你预期的效果。</target>
        </trans-unit>
        <trans-unit id="5ba2015dbd8b7d90bb6da319e60421ccbe89f224" translate="yes" xml:space="preserve">
          <source>This also applies to integers that look like floating point constants:</source>
          <target state="translated">这也适用于看起来像浮点常数的整数。</target>
        </trans-unit>
        <trans-unit id="636185aa1476a4214e4b7454bccd1f721aa5d7e5" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt; :</source>
          <target state="translated">这也具有相似的行为，但是分配给词法变量而不是 &lt;code&gt;$_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="40e97092dc934ec326d1ea3e202dbbdcd5300d45" translate="yes" xml:space="preserve">
          <source>This also behaves similarly, but assigns to a lexical variable instead of to &lt;code&gt;$_&lt;/code&gt;:</source>
          <target state="translated">这也具有相似的行为，但是分配给词法变量而不是 &lt;code&gt;$_&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cd00f9f641aead2aa10c5260267b8df1c16f1dcf" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">这在XS AUTOLOAD子程序中也有特殊用途。请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;perlguts中的&amp;ldquo;使用XSUB自动加载&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77df2183cb5ed8fa6c016243494c2444f23d3c09" translate="yes" xml:space="preserve">
          <source>This also has a special use with XS AUTOLOAD subs. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt;.</source>
          <target state="translated">这在XS AUTOLOAD子程序中也有特殊用途。请参见&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;在perlguts中使用XSUB自动加载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d3d548e6c0ea6757b5bd736b5e0dc177ac6e6019" translate="yes" xml:space="preserve">
          <source>This also has implications for the use of the SUPER:: qualifier (see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;).</source>
          <target state="translated">这也对使用SUPER ::限定符&lt;a href=&quot;perlobj&quot;&gt;有影响&lt;/a&gt;（请参阅perlobj）。</target>
        </trans-unit>
        <trans-unit id="f8da07f35c437fa97e844be13f7f26224b7e80d0" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">这也意味着检查某些特定的软件包是一个坏主意，因为$ x的实际内容可能是意外的。由于bignum的透明方式，无论如何都不需要 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49deec483222c26dba8014be17034c32d563f691" translate="yes" xml:space="preserve">
          <source>This also means it is a bad idea to check for some specific package, since the actual contents of $x might be something unexpected. Due to the transparent way of bignum &lt;code&gt;ref()&lt;/code&gt; should not be necessary, anyway.</source>
          <target state="translated">这也意味着检查某些特定的软件包是一个坏主意，因为$ x的实际内容可能是意外的。由于bignum的透明方式，无论如何都不需要 &lt;code&gt;ref()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f046ba2ed5c45f32bb7d779ddd434216adcb9e9" translate="yes" xml:space="preserve">
          <source>This also means that a first argument hash reference now becomes the second argument:</source>
          <target state="translated">这也意味着,第一个参数的哈希引用现在变成了第二个参数。</target>
        </trans-unit>
        <trans-unit id="53e0f20ff4a10e2905e391319be8b9814ea5ca78" translate="yes" xml:space="preserve">
          <source>This also returns the file format version. If the version is &quot;2.7&quot; then major would be 2 and minor would be 7. The minor element is missing for when major is less than 2.</source>
          <target state="translated">这也返回文件格式版本。如果版本是 &quot;2.7&quot;,那么major是2,minor是7。当major小于2时,则缺少minor元素。</target>
        </trans-unit>
        <trans-unit id="61c52be3ac150c6eed66b2a1ead6f0d851e682d3" translate="yes" xml:space="preserve">
          <source>This also works for other subclasses, like Math::String.</source>
          <target state="translated">这也适用于其他子类,比如 Math::String。</target>
        </trans-unit>
        <trans-unit id="8203581310d6a334ec8562f54f521a19e2fc01d8" translate="yes" xml:space="preserve">
          <source>This also works for ranges in &lt;code&gt;tr///&lt;/code&gt; starting in Perl v5.24.</source>
          <target state="translated">从Perl v5.24开始，这也适用于 &lt;code&gt;tr///&lt;/code&gt; 中的范围。</target>
        </trans-unit>
        <trans-unit id="8468a87cfa0204ff52a567b1eaf4b66d1ee547eb" translate="yes" xml:space="preserve">
          <source>This always means your main memory, not your disk. Clouding the issue is the fact that your machine may implement &lt;b&gt;virtual&lt;/b&gt; memory; that is, it will pretend that it has more memory than it really does, and it&amp;rsquo;ll use disk space to hold inactive bits. This can make it seem like you have a little more memory than you really do, but it&amp;rsquo;s not a substitute for real memory. The best thing that can be said about virtual memory is that it lets your performance degrade gradually rather than suddenly when you run out of real memory. But your program can die when you run out of virtual memory, too&amp;mdash;if you haven&amp;rsquo;t thrashed your disk to death first.</source>
          <target state="translated">这始终意味着您的主内存，而不是磁盘。问题的根源在于您的计算机可能实现了&lt;b&gt;虚拟&lt;/b&gt;内存。也就是说，它会假装它具有比实际更多的内存，并且它将使用磁盘空间来保存不活动的位。这可以使您看起来好像比实际拥有更多的内存，但是它不能代替真实的内存。关于虚拟内存的最好的说法是，当您用完实际内存时，它会使性能逐渐降低，而不是突然降低。但是，如果您的虚拟内存用完了，您的程序也会死掉-如果您没有先将磁盘砸死。</target>
        </trans-unit>
        <trans-unit id="295dde8c4391c2b969f714a71c16980aac7c0b67" translate="yes" xml:space="preserve">
          <source>This and &lt;code&gt;PERL_INT_MIN&lt;/code&gt;, &lt;code&gt;PERL_LONG_MAX&lt;/code&gt;, &lt;code&gt;PERL_LONG_MIN&lt;/code&gt;, &lt;code&gt;PERL_QUAD_MAX&lt;/code&gt;, &lt;code&gt;PERL_SHORT_MAX&lt;/code&gt;, &lt;code&gt;PERL_SHORT_MIN&lt;/code&gt;, &lt;code&gt;PERL_UCHAR_MAX&lt;/code&gt;, &lt;code&gt;PERL_UCHAR_MIN&lt;/code&gt;, &lt;code&gt;PERL_UINT_MAX&lt;/code&gt;, &lt;code&gt;PERL_ULONG_MAX&lt;/code&gt;, &lt;code&gt;PERL_ULONG_MIN&lt;/code&gt;, &lt;code&gt;PERL_UQUAD_MAX&lt;/code&gt;, &lt;code&gt;PERL_UQUAD_MIN&lt;/code&gt;, &lt;code&gt;PERL_USHORT_MAX&lt;/code&gt;, &lt;code&gt;PERL_USHORT_MIN&lt;/code&gt;, &lt;code&gt;PERL_QUAD_MIN&lt;/code&gt; give the largest and smallest number representable in the current platform in variables of the corresponding types.</source>
          <target state="translated">这和 &lt;code&gt;PERL_INT_MIN&lt;/code&gt; ， &lt;code&gt;PERL_LONG_MAX&lt;/code&gt; ， &lt;code&gt;PERL_LONG_MIN&lt;/code&gt; ， &lt;code&gt;PERL_QUAD_MAX&lt;/code&gt; ， &lt;code&gt;PERL_SHORT_MAX&lt;/code&gt; ， &lt;code&gt;PERL_SHORT_MIN&lt;/code&gt; ， &lt;code&gt;PERL_UCHAR_MAX&lt;/code&gt; ， &lt;code&gt;PERL_UCHAR_MIN&lt;/code&gt; ， &lt;code&gt;PERL_UINT_MAX&lt;/code&gt; ， &lt;code&gt;PERL_ULONG_MAX&lt;/code&gt; ， &lt;code&gt;PERL_ULONG_MIN&lt;/code&gt; ， &lt;code&gt;PERL_UQUAD_MAX&lt;/code&gt; ， &lt;code&gt;PERL_UQUAD_MIN&lt;/code&gt; ， &lt;code&gt;PERL_USHORT_MAX&lt;/code&gt; ， &lt;code&gt;PERL_USHORT_MIN&lt;/code&gt; ， &lt;code&gt;PERL_QUAD_MIN&lt;/code&gt; 给当前平台中的最大和最小数可表示在相应类型的变量。</target>
        </trans-unit>
        <trans-unit id="165f78228b9bb880f61927fda978ad6714cce456" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">这种异常源于Perl试图不打扰未使用Unicode的旧程序的尝试，以及Perl希望无缝添加Unicode支持的愿望。但是结果却并非完美无缺。（顺便说一句，您可以选择在发生这种情况时发出警告。请参见 &lt;code&gt;&lt;a href=&quot;encoding/warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="a34b4613636352dc25268cf3fddbf1e4e87cbb09" translate="yes" xml:space="preserve">
          <source>This anomaly stems from Perl's attempt to not disturb older programs that didn't use Unicode, along with Perl's desire to add Unicode support seamlessly. But the result turned out to not be seamless. (By the way, you can choose to be warned when things like this happen. See &lt;code&gt;&lt;a href=&quot;encoding::warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">这种异常源于Perl试图不打扰那些不使用Unicode的较旧程序的尝试，以及Perl希望无缝添加Unicode支持的愿望。但是结果却并非完美无缺。（顺便说一句，您可以选择在发生这种情况时发出警告。请参见 &lt;code&gt;&lt;a href=&quot;encoding::warnings&quot;&gt;encoding::warnings&lt;/a&gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="8c246570729105a65f6bd289985b0b62d1e1f94f" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt; , and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; .</source>
          <target state="translated">这出现在perl 5.10.0中。 &lt;code&gt;\K&lt;/code&gt; 左边匹配的任何内容都不会包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中，如果在替换中使用了模式，则不会被替换。这使您可以写 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 而不是 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 或 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbd3493b1232a9c4de7dc8bb2c9b05a2159dd5ec" translate="yes" xml:space="preserve">
          <source>This appeared in perl 5.10.0. Anything matched left of &lt;code&gt;\K&lt;/code&gt; is not included in &lt;code&gt;$&amp;amp;&lt;/code&gt;, and will not be replaced if the pattern is used in a substitution. This lets you write &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; instead of &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; or &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt;.</source>
          <target state="translated">这出现在perl 5.10.0中。 &lt;code&gt;\K&lt;/code&gt; 左边匹配的任何内容都不会包含在 &lt;code&gt;$&amp;amp;&lt;/code&gt; 中，如果在替换中使用该模式，则不会替换任何内容。这使您可以写 &lt;code&gt;s/PAT1 \K PAT2/REPL/x&lt;/code&gt; 而不是 &lt;code&gt;s/(PAT1) PAT2/${1}REPL/x&lt;/code&gt; 或 &lt;code&gt;s/(?&amp;lt;=PAT1) PAT2/REPL/x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cbb4716327acfc3309af9888218e1b2879b1c27" translate="yes" xml:space="preserve">
          <source>This applies as well to &lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N::Langinfo&lt;/a&gt;.</source>
          <target state="translated">这也适用于&lt;a href=&quot;I18N::Langinfo&quot;&gt;I18N :: Langinfo&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9e79001ab117c0cf333336e9232ddbb9a00de3d" translate="yes" xml:space="preserve">
          <source>This applies equally to method names, parameter names, and anything else which is visible to the user (and most things that aren't!)</source>
          <target state="translated">这同样适用于方法名,参数名,以及其他任何对用户可见的东西(以及大多数不可见的东西!)。</target>
        </trans-unit>
        <trans-unit id="70dd8476567c22ea231857d01ff4db7f81b73be8" translate="yes" xml:space="preserve">
          <source>This applies only to lexical variables, by the way. Dynamic variables continue to work as they have always worked. Closure is not something that most Perl programmers need trouble themselves about to begin with.</source>
          <target state="translated">顺便说一下,这只适用于词法变量。动态变量可以像以前一样继续工作。大多数Perl程序员一开始就不需要为关闭而烦恼。</target>
        </trans-unit>
        <trans-unit id="4e13602141364999d0474f62de688119ccaf7274" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; .</source>
          <target state="translated">这仅适用于perlio系统。对于5.7之前的版本， &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 等效于 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e11371aac7dd3f528873ed555dfe591da9dcfa07" translate="yes" xml:space="preserve">
          <source>This applies to the perlio system only. For versions before 5.7, &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; is equivalent to &lt;code&gt;PerlIO_findFILE()&lt;/code&gt;.</source>
          <target state="translated">这仅适用于perlio系统。对于5.7之前的版本， &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 等效于 &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88ab6b9c73082204ae0542a65f9bf2f5c23ef207" translate="yes" xml:space="preserve">
          <source>This approach also works for comparing hashes. Here we'll demonstrate two different answers:</source>
          <target state="translated">这种方法同样适用于比较哈希值。这里我们将演示两种不同的答案。</target>
        </trans-unit>
        <trans-unit id="e5cff3b77039edbd80551481c46e471aeea07633" translate="yes" xml:space="preserve">
          <source>This approach is useful if I need to convert my TAP based test results into some other representation. See TAP::Convert::TET (http://search.cpan.org/dist/TAP-Convert-TET/) for an example of this approach.</source>
          <target state="translated">如果我需要将基于TAP的测试结果转换为其他的表示方式,这种方法是很有用的。参见TAP::Convert::TET (http://search.cpan.org/dist/TAP-Convert-TET/)来了解这种方法的例子。</target>
        </trans-unit>
        <trans-unit id="684f52e2ad132a8d50a850505a18c8cf67adca2e" translate="yes" xml:space="preserve">
          <source>This approach makes it comparatively easy to write code preprocessors without worrying about the form or contents of strings, regexes, etc.</source>
          <target state="translated">这种方法使得编写代码预处理程序比较容易,不用担心字符串、regexes等的形式和内容。</target>
        </trans-unit>
        <trans-unit id="21941c4a2190129983b70fab8729b6e9162dfa7f" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">这种将 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 像对象方法调用一样对待的方法不适用于菱形运算符。那是因为它是一个真正的运算符，而不仅仅是带有无逗号参数的函数。假设您已经像上面一样在结构中存储了typeglob，则可以像 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 一样使用名为 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 的内置函数读取记录。给定上面显示的@fd初始化，这将起作用，但这仅是因为readline（）需要一个typeglob。它不适用于对象或字符串，这可能是我们尚未修复的错误。</target>
        </trans-unit>
        <trans-unit id="8f83a93621698a2bcf6c863d26ca6660360038ba" translate="yes" xml:space="preserve">
          <source>This approach of treating &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt; like object methods calls doesn't work for the diamond operator. That's because it's a real operator, not just a function with a comma-less argument. Assuming you've been storing typeglobs in your structure as we did above, you can use the built-in function named &lt;code&gt;readline&lt;/code&gt; to read a record just as &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn't work with objects or strings, which might be a bug we haven't fixed yet.</source>
          <target state="translated">这种将 &lt;code&gt;print&lt;/code&gt; 和 &lt;code&gt;printf&lt;/code&gt; 像对象方法调用一样对待的方法不适用于菱形运算符。那是因为它是一个真正的运算符，而不仅仅是带有无逗号参数的函数。假设您已经像上面一样在结构中存储了typeglob，则可以像 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 一样使用名为 &lt;code&gt;readline&lt;/code&gt; 的内置函数读取记录。给定上面显示的@fd初始化，这将起作用，但是仅是因为readline（）需要一个typeglob。它不适用于对象或字符串，这可能是我们尚未修复的错误。</target>
        </trans-unit>
        <trans-unit id="5d9254d4c73a18d06483f51c6d39891d7febc4dc" translate="yes" xml:space="preserve">
          <source>This approach will preserve links in the installation without creating duplicate binaries.</source>
          <target state="translated">这种方法将保留安装中的链接,而不会创建重复的二进制文件。</target>
        </trans-unit>
        <trans-unit id="8edd7ed16ccf46b65b081f4b967d5eb2691395f1" translate="yes" xml:space="preserve">
          <source>This argument is &lt;b&gt;required&lt;/b&gt;. All other arguments are optional.</source>
          <target state="translated">此参数是&lt;b&gt;必需的&lt;/b&gt;。所有其他参数都是可选的。</target>
        </trans-unit>
        <trans-unit id="f95f50481ff3516b07bb9d7865830ab6c1ff5648" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the beginnings of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$-[0]&lt;/code&gt; is the offset into the string of the beginning of the entire match. The</source>
          <target state="translated">该数组保存当前活动动态范围中最后一次成功子匹配的开始的偏移量。 &lt;code&gt;$-[0]&lt;/code&gt; 是整个比赛开始处字符串的偏移量。的</target>
        </trans-unit>
        <trans-unit id="e96381bdcc284e80585b7b54b1e289040c1f9efb" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">该数组保存当前活动动态范围中最后一次成功子匹配的结尾的偏移量。 &lt;code&gt;$+[0]&lt;/code&gt; 是整个比赛结束时字符串的偏移量。该值与 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 函数在匹配的变量上调用时返回的值相同。的</target>
        </trans-unit>
        <trans-unit id="7e3b87670db2d70a8b725b5f6afad0e3488c0499" translate="yes" xml:space="preserve">
          <source>This array holds the offsets of the ends of the last successful submatches in the currently active dynamic scope. &lt;code&gt;$+[0]&lt;/code&gt; is the offset into the string of the end of the entire match. This is the same value as what the &lt;code&gt;pos&lt;/code&gt; function returns when called on the variable that was matched against. The</source>
          <target state="translated">该数组保存当前活动动态范围中最后一个成功子匹配的结尾的偏移量。 &lt;code&gt;$+[0]&lt;/code&gt; 是整个比赛结束时字符串的偏移量。该值与 &lt;code&gt;pos&lt;/code&gt; 函数在匹配的变量上调用时返回的值相同。这</target>
        </trans-unit>
        <trans-unit id="de9df0444460b118bc16cc7a6647d43831c503da" translate="yes" xml:space="preserve">
          <source>This array of function pointers is a convenient place to hook into the compilation process. An XS module can put its own custom check function in place of any of the standard ones, to influence the compilation of a particular type of op. However, a custom check function must never fully replace a standard check function (or even a custom check function from another module). A module modifying checking must instead &lt;b&gt;wrap&lt;/b&gt; the preexisting check function. A custom check function must be selective about when to apply its custom behaviour. In the usual case where it decides not to do anything special with an op, it must chain the preexisting op function. Check functions are thus linked in a chain, with the core's base checker at the end.</source>
          <target state="translated">此函数指针数组是插入编译过程的方便位置。 XS模块可以使用其自己的自定义检查功能代替任何标准功能，以影响特定类型的op的编译。但是，自定义检查功能绝对不能完全取代标准检查功能（甚至是其他模块的自定义检查功能）。相反，修改检查的模块必须&lt;b&gt;包装&lt;/b&gt;先前存在的检查功能。自定义检查功能必须对何时应用其自定义行为具有选择性。在通常情况下，如果它决定不对op执行任何特殊操作，则它必须链接先前存在的op函数。因此，检查功能是链式链接的，最后是核心的基础检查器。</target>
        </trans-unit>
        <trans-unit id="b8dc273368b99545f08bf93846a0eeb46f2d8f07" translate="yes" xml:space="preserve">
          <source>This article is about a little-known feature of Perl called</source>
          <target state="translated">本文介绍的是Perl中一个鲜为人知的特性,叫做</target>
        </trans-unit>
        <trans-unit id="31e9f3bedf523d7ebb982ebf37f1569db684a386" translate="yes" xml:space="preserve">
          <source>This article originally appeared in</source>
          <target state="translated">本文原载于</target>
        </trans-unit>
        <trans-unit id="290ae5b40be8703f5e688eadedc6451a7fcb95b4" translate="yes" xml:space="preserve">
          <source>This article originally appeared in The Perl Journal #11, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文原载于 The Perl Journal #11,版权归 The Perl Journal 1998 所有。本文由 Jon Orwant 和 The Perl Journal 提供。本文档可以在与Perl本身相同的条款下发布。</target>
        </trans-unit>
        <trans-unit id="8c193374e77ca7493defa36cbb4f120e07e0e033" translate="yes" xml:space="preserve">
          <source>This article points out cases where gettext (a common system for localizing software interfaces -- i.e., making them work in the user's language of choice) fails because of basic differences between human languages. This article then describes Maketext, a new system capable of correctly treating these differences.</source>
          <target state="translated">本文指出了由于人类语言之间的基本差异而导致gettext(一种常用的软件界面本地化系统--即使其以用户选择的语言运行)失败的案例。然后本文介绍了Maketext,一个能够正确处理这些差异的新系统。</target>
        </trans-unit>
        <trans-unit id="f5ced083e00b961f0ed9ea00cb4d87f96f2e0533" translate="yes" xml:space="preserve">
          <source>This assertion may be used as the condition in a</source>
          <target state="translated">这个断言可以作为一个条件在</target>
        </trans-unit>
        <trans-unit id="0000b51c42222ffe097e200394d62769ca419cbc" translate="yes" xml:space="preserve">
          <source>This assumes that we saw the locale &quot;en_US.ISO8859-1&quot; using the commands discussed above. We decided to try that instead of the above faulty locale &quot;En_US&quot;--and in Cshish shells (&lt;b&gt;csh&lt;/b&gt;, &lt;b&gt;tcsh&lt;/b&gt;)</source>
          <target state="translated">假设我们使用上面讨论的命令看到了语言环境&amp;ldquo; en_US.ISO8859-1&amp;rdquo;。我们决定尝试使用上述错误的语言环境&amp;ldquo; En_US&amp;rdquo;，并使用Cshish shells（&lt;b&gt;csh&lt;/b&gt;，&lt;b&gt;tcsh&lt;/b&gt;）</target>
        </trans-unit>
        <trans-unit id="c0dee2f933f09058dd9bf3765b7f846ec57f52d7" translate="yes" xml:space="preserve">
          <source>This attribute is not a search parameter, but is used to report the result of &lt;code&gt;survey&lt;/code&gt; method, as discussed in the next section.</source>
          <target state="translated">该属性不是搜索参数，而是用于报告 &lt;code&gt;survey&lt;/code&gt; 方法的结果，如下一节所述。</target>
        </trans-unit>
        <trans-unit id="9c687ced37405f8cf67c894463cfe3d86f5b0e65" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. It is currently only used by OS/2 and Win32.</source>
          <target state="translated">此属性用于指定要导入扩展的名称。目前只在OS/2和Win32中使用。</target>
        </trans-unit>
        <trans-unit id="a3e8362900ead72447d5c4ebf2182285972d3847" translate="yes" xml:space="preserve">
          <source>This attribute is used to specify names to be imported into the extension. Takes a hash ref.</source>
          <target state="translated">此属性用于指定要导入扩展的名称。取一个哈希值。</target>
        </trans-unit>
        <trans-unit id="1878c97024e58d679f418b8cab0863e53682e594" translate="yes" xml:space="preserve">
          <source>This attribute isn't overridden from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;'s implementation. However, since we turn it on by default, it's worth mentioning here.</source>
          <target state="translated">不会从&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt;的实现中重写此属性。但是，由于我们默认情况下将其打开，因此在这里值得一提。</target>
        </trans-unit>
        <trans-unit id="767e4d21fb47d7f73037ece0977c12a97d29d46d" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL EXCLUDE_EXT='Socket Safe'</source>
          <target state="translated">当在命令行中指定为字符串时,这个属性可能是最有用的:perl Makefile.PL EXCLUDE_EXT='Socket Safe'。</target>
        </trans-unit>
        <trans-unit id="79f89eca0caacc11c08af6c151f34570659a105e" translate="yes" xml:space="preserve">
          <source>This attribute may be most useful when specified as a string on the command line: perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'</source>
          <target state="translated">当在命令行中指定为字符串时,这个属性可能是最有用的:perl Makefile.PL INCLUDE_EXT='POSIX Socket Devel::Peek'。</target>
        </trans-unit>
        <trans-unit id="f063de8522828eff3b84027f3f1f4329111a6d6f" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt; .)</source>
          <target state="translated">此属性意味着，每次此搜索看到匹配的Pod文件时，都应调用此回调例程。用两个参数调用该例程：当前文件的filespec及其pod名称。（例如：（ &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 位于 &lt;code&gt;@_&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="b18ca20df7bd3e30c21736b41cee34c8a2b8e2a6" translate="yes" xml:space="preserve">
          <source>This attribute means that every time this search sees a matching Pod file, it should call this callback routine. The routine is called with two parameters: the current file's filespec, and its pod name. (For example: &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; would be in &lt;code&gt;@_&lt;/code&gt;.)</source>
          <target state="translated">此属性意味着，每次此搜索看到匹配的Pod文件时，都应调用此回调例程。用两个参数调用该例程：当前文件的filespec及其pod名称。 （例如：（ &lt;code&gt;(&quot;/etc/perljunk/File/Crunk.pm&quot;, &quot;File::Crunk&quot;)&lt;/code&gt; 将位于 &lt;code&gt;@_&lt;/code&gt; 中。）</target>
        </trans-unit>
        <trans-unit id="d1d55a165f99ccc6289583795c82aceb24ceabae" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false, meaning that no callback is called.</source>
          <target state="translated">这个属性的默认值是false,意味着不调用回调。</target>
        </trans-unit>
        <trans-unit id="bcee703f93ae24f2cb5be27baf6a28edef44800c" translate="yes" xml:space="preserve">
          <source>This attribute's default value is false; and normally you won't need to turn it on.</source>
          <target state="translated">这个属性的默认值是false,一般情况下你不需要打开它。</target>
        </trans-unit>
        <trans-unit id="56b03f0333e5f7d53de3d13aaa7c296581e96eb6" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">如果将此属性设置为非零正值，它将使搜索输出（通过 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; ）记录它们在执行操作时的状态。此选项对于调试与Pod相关的模块可能很有用。该属性的默认值为零，表示不生成任何 &lt;code&gt;&lt;a href=&quot;../../functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 消息。 （将verbose设置为1会打开某些消息，将verbose设置为2会打开更多消息，即，使以下搜索比1更加冗长。）</target>
        </trans-unit>
        <trans-unit id="0c5539e5a1f8b4ae98bcf6660273088727acad03" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a nonzero positive value, will make searches output (via &lt;code&gt;warn&lt;/code&gt;) notes about what they're doing as they do it. This option may be useful for debugging a pod-related module. This attribute's default value is zero, meaning that no &lt;code&gt;warn&lt;/code&gt; messages are produced. (Setting verbose to 1 turns on some messages, and setting it to 2 turns on even more messages, i.e., makes the following search(es) even more verbose than 1 would make them.)</source>
          <target state="translated">如果将此属性设置为非零正值，它将使搜索输出（通过 &lt;code&gt;warn&lt;/code&gt; ）记录它们在执行操作时的状态。此选项对于调试与Pod相关的模块可能很有用。该属性的默认值为零，表示不生成任何 &lt;code&gt;warn&lt;/code&gt; 消息。（将verbose设置为1会打开某些消息，将verbose设置为2会打开更多消息，即，使以下搜索比1更加冗长。）</target>
        </trans-unit>
        <trans-unit id="9a5ab376fb5b92c88b226665b3b3189f69774bb5" translate="yes" xml:space="preserve">
          <source>This attribute, if set to a true value, means that searches should implicitly add perl's</source>
          <target state="translated">这个属性,如果设置为true,意味着搜索应该隐式地添加perl的</target>
        </trans-unit>
        <trans-unit id="cb9b1d7b2cb6a7fd551e138029c10c2929f9890c" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true will send complaints to STDERR. The default value is false -- i.e., complaints do not go to STDERR.</source>
          <target state="translated">此属性如果设置为 &quot;true&quot;,将把投诉发送到STDERR。默认值为false --即投诉不会发送到STDERR。</target>
        </trans-unit>
        <trans-unit id="b61204e83fba97c2ca8def6dbf1ab66670d89867" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true, will suppress generation of an errata section. The default value is false -- i.e., an errata section will be generated.</source>
          <target state="translated">此属性如果设置为 &quot;true&quot;,将抑制勘误部分的生成。默认值为false ----即会生成勘误部分。</target>
        </trans-unit>
        <trans-unit id="571c6c575be741c0ccb3900f5d3e71326d82d454" translate="yes" xml:space="preserve">
          <source>This attribute, if set to true, will suppress reports of non-fatal error messages. The default value is false, meaning that complaints</source>
          <target state="translated">如果将此属性设置为 &quot;true&quot;,则将抑制非致命性错误消息的报告。默认值为false,意味着投诉</target>
        </trans-unit>
        <trans-unit id="a182f040f9812e41854866431a64ba79744c6637" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (and it is false by default) ignores any &quot;X&amp;lt;...&amp;gt;&quot; sequences in the document being parsed. Many formats don't actually use the content of these codes, so have no reason to process them.</source>
          <target state="translated">将此属性设置为true值（默认情况下为false）时，将忽略要分析的文档中的任何&amp;ldquo; X &amp;lt;...&amp;gt;&amp;rdquo;序列。许多格式实际上并不使用这些代码的内容，因此没有理由对其进行处理。</target>
        </trans-unit>
        <trans-unit id="b434a6b0cc83e10e398b4286a85f3e17ab1066b8" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (and it is false by default) makes sure that only one event (or token, or node) will be created for any single contiguous sequence of text. For example, consider this somewhat contrived example:</source>
          <target state="translated">这个属性,当设置为true时(默认为false),确保对任何一个连续的文本序列只创建一个事件(或标记,或节点)。例如,考虑一下这个有点儿造作的例子。</target>
        </trans-unit>
        <trans-unit id="2a15dcae492825f898078cd25d1654376a0c6156" translate="yes" xml:space="preserve">
          <source>This attribute, when set to a true value (it is false by default) will keep &lt;code&gt;=encoding&lt;/code&gt; and its content in the event structure. Most formats don't actually need to process the content of an &lt;code&gt;=encoding&lt;/code&gt; directive, even when this directive sets the encoding and the processor makes use of the encoding information. Indeed, it is possible to know the encoding without processing the directive content.</source>
          <target state="translated">当将此属性设置为true值（默认情况下为false）时，它将在事件结构中保留 &lt;code&gt;=encoding&lt;/code&gt; 及其内容。大多数格式实际上不需要处理 &lt;code&gt;=encoding&lt;/code&gt; 指令的内容，即使该指令设置了编码并且处理器使用了编码信息也是如此。实际上，无需处理指令内容就可以知道编码。</target>
        </trans-unit>
        <trans-unit id="696114490e2efba39fd9f36eac6a38a5d07a8aca" translate="yes" xml:space="preserve">
          <source>This became fatal in Perl 5.32.</source>
          <target state="translated">这在Perl 5.32中成为致命的问题。</target>
        </trans-unit>
        <trans-unit id="b39a84ee1b444ad72be8b273ce2aa43be2362f55" translate="yes" xml:space="preserve">
          <source>This behavior can be overridden by supplying your own set of files to search. PL_FILES accepts a hash ref, the key being the file to run and the value is passed in as the first argument when the PL file is run.</source>
          <target state="translated">这个行为可以通过提供你自己的文件集来重写。PL_FILES接受一个hash ref,key是要运行的文件,当运行PL文件时,其值作为第一个参数传递进来。</target>
        </trans-unit>
        <trans-unit id="fa4bb1602ab15283bd3eccd436e14ac034642f38" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; modifiers. &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">此行为很方便，因为在计数和匹配一行中的字符时，我们通常希望忽略换行符。但是，有时我们想跟踪换行符。我们甚至可能希望 &lt;code&gt;'^'&lt;/code&gt; 和 &lt;code&gt;'$'&lt;/code&gt; 锚定在字符串中各行的开头和结尾，而不只是锚定在字符串的开头和结尾。 Perl允许我们使用 &lt;code&gt;/s&lt;/code&gt; 和 &lt;code&gt;/m&lt;/code&gt; 修饰符在忽略和注意换行之间进行选择。 &lt;code&gt;/s&lt;/code&gt; 和 &lt;code&gt;/m&lt;/code&gt; 代表单行和多行，它们确定将一个字符串视为一个连续的字符串还是视为一组行。这两个修饰符影响着正则表达式的解释的两个方面：1） &lt;code&gt;'.'&lt;/code&gt; 定义了字符类，以及2）锚点 &lt;code&gt;'^'&lt;/code&gt; 和 &lt;code&gt;'$'&lt;/code&gt; 能够匹配的地方。以下是四种可能的组合：</target>
        </trans-unit>
        <trans-unit id="31de598976c4af9df58fa731498e0e725fcefe91" translate="yes" xml:space="preserve">
          <source>This behavior is convenient, because we usually want to ignore newlines when we count and match characters in a line. Sometimes, however, we want to keep track of newlines. We might even want &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to anchor at the beginning and end of lines within the string, rather than just the beginning and end of the string. Perl allows us to choose between ignoring and paying attention to newlines by using the &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; modifiers. &lt;code&gt;//s&lt;/code&gt; and &lt;code&gt;//m&lt;/code&gt; stand for single line and multi-line and they determine whether a string is to be treated as one continuous string, or as a set of lines. The two modifiers affect two aspects of how the regexp is interpreted: 1) how the &lt;code&gt;'.'&lt;/code&gt; character class is defined, and 2) where the anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are able to match. Here are the four possible combinations:</source>
          <target state="translated">这种行为很方便，因为当我们计算和匹配一行中的字符时，我们通常希望忽略换行符。但是，有时我们想跟踪换行符。我们甚至可能希望 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 锚定在字符串中各行的开头和结尾，而不仅仅是锚定字符串的开头和结尾。 Perl允许我们使用 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 修饰符在忽略和注意换行之间进行选择。 &lt;code&gt;//s&lt;/code&gt; 和 &lt;code&gt;//m&lt;/code&gt; 代表单行和多行，它们确定将一个字符串视为一个连续的字符串还是一组线。这两个修饰符影响着正则表达式的解释的两个方面：1） &lt;code&gt;'.'&lt;/code&gt; 定义了字符类，以及2）锚点 &lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 能够匹配的地方。这是四种可能的组合：</target>
        </trans-unit>
        <trans-unit id="3d6ebadd3063ef053971debc9b4e78f1e936126e" translate="yes" xml:space="preserve">
          <source>This behavior is more &quot;Do what I mean&quot; than in earlier Perls for most applications. But it catches fewer issues for code that needs to be strictly Unicode compliant. Therefore there is an additional mode of operation available to accommodate such code. This mode is enabled if a regular expression pattern is compiled within the lexical scope where the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; warning class has been made fatal, say by:</source>
          <target state="translated">对于大多数应用程序，此行为比早期的Perls更具&amp;ldquo;执行我的意思&amp;rdquo;。但是对于需要严格遵守Unicode的代码，它捕获的问题更少。因此，存在可用于容纳此类代码的其他操作模式。如果在 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; 警告类设为致命的词汇范围内编译了正则表达式模式，则启用此模式，例如：</target>
        </trans-unit>
        <trans-unit id="092eaaecfde2fe8092e286b99e012b8ea81cec11" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">这种 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 行为应与POSIX行为兼容，而不是与传统的VMS行为兼容。</target>
        </trans-unit>
        <trans-unit id="76845e7cfd2a36561cb45a7adf71017bb1774b07" translate="yes" xml:space="preserve">
          <source>This behavior of &lt;code&gt;unlink&lt;/code&gt; is to be compatible with POSIX behavior and not traditional VMS behavior.</source>
          <target state="translated">&lt;code&gt;unlink&lt;/code&gt; 行为应与POSIX行为兼容，而不是与传统VMS行为兼容。</target>
        </trans-unit>
        <trans-unit id="353b3ac3017572fed965aadb9e085377b2c9e20d" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; pragma.</source>
          <target state="translated">此行为提供了词法作用域的语义，例如在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 杂注中使用。</target>
        </trans-unit>
        <trans-unit id="96dcd6333752f9f98479a9189f9fc8dc00af90ba" translate="yes" xml:space="preserve">
          <source>This behavior provides the semantic of lexical scoping, and is used in, for instance, the &lt;code&gt;use strict&lt;/code&gt; pragma.</source>
          <target state="translated">此行为提供了词法作用域的语义，例如在 &lt;code&gt;use strict&lt;/code&gt; 杂注中使用。</target>
        </trans-unit>
        <trans-unit id="902d9db5da6a9d0d90bec88dd7435e3d3036822b" translate="yes" xml:space="preserve">
          <source>This behaviour is identical to that of the actual compiler.</source>
          <target state="translated">这种行为与实际编译器的行为相同。</target>
        </trans-unit>
        <trans-unit id="6e8dc928034c49a32a9b32094d6524d49150a39e" translate="yes" xml:space="preserve">
          <source>This behviour is copied inspired by &lt;code&gt;IO::Socket::INET&lt;/code&gt;; for more fine grained control over connection timeouts, consider performing a nonblocking connect directly.</source>
          <target state="translated">这种行为是受 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 启发而复制的；为了更精细地控制连接超时，请考虑直接执行无阻塞连接。</target>
        </trans-unit>
        <trans-unit id="6aea6026d60fc1fd0c7a4849c08ac16e1e32fc6e" translate="yes" xml:space="preserve">
          <source>This binds a &lt;a href=&quot;http://man.he.net/man3/dbm&quot;&gt;dbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/ndbm&quot;&gt;ndbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/sdbm&quot;&gt;sdbm(3)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/gdbm&quot;&gt;gdbm(3)&lt;/a&gt;, or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, the first argument is</source>
          <target state="translated">此结合一个&lt;a href=&quot;http://man.he.net/man3/dbm&quot;&gt;DBM（3） &lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/ndbm&quot;&gt;NDBM（3） &lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/sdbm&quot;&gt;SDBM（3） &lt;/a&gt;，&lt;a href=&quot;http://man.he.net/man3/gdbm&quot;&gt;GDBM（3） &lt;/a&gt;，或伯克利DB文件的散列。HASH是哈希的名称。（与常&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;不同，第一个参数是</target>
        </trans-unit>
        <trans-unit id="fd9ffc9da0934423cf7a8b2a8167c734225e00ac" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">这会将dbm（3），ndbm（3），sdbm（3），gdbm（3）或Berkeley DB文件绑定到哈希。HASH是哈希的名称。（与常 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 不同，第一个参数是</target>
        </trans-unit>
        <trans-unit id="2616a24dba48e4df35dec143fa3cabdfd81fd386" translate="yes" xml:space="preserve">
          <source>This binds a dbm(3), ndbm(3), sdbm(3), gdbm(3), or Berkeley DB file to a hash. HASH is the name of the hash. (Unlike normal &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, the first argument is</source>
          <target state="translated">这会将dbm（3），ndbm（3），sdbm（3），gdbm（3）或Berkeley DB文件绑定到哈希。HASH是哈希的名称。（与常 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 不同，第一个参数是</target>
        </trans-unit>
        <trans-unit id="a6324526e82c2b2028f79347525bf2bc78810ebd" translate="yes" xml:space="preserve">
          <source>This block modifies all the &lt;code&gt;.c&lt;/code&gt; files in the current directory, leaving a backup of the original data from each file in a new &lt;code&gt;.c.orig&lt;/code&gt; file.</source>
          <target state="translated">此块修改当前目录中的所有 &lt;code&gt;.c&lt;/code&gt; 文件，并将来自每个文件的原始数据备份保留在新的 &lt;code&gt;.c.orig&lt;/code&gt; 文件中。</target>
        </trans-unit>
        <trans-unit id="ba453fd403a510bef4a413f0d9ec2dc3165244e0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt; , it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">该样板使用低开销的 &lt;code&gt;XSLoader&lt;/code&gt; (如果有）；如果与没有 &lt;code&gt;XSLoader&lt;/code&gt; 的古董Perl 一起使用，它将退回到使用 &lt;code&gt;DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed948443998fb2b43bd30eac485b18baa935c1f0" translate="yes" xml:space="preserve">
          <source>This boilerplate uses the low-overhead &lt;code&gt;XSLoader&lt;/code&gt; if present; if used with an antique Perl which has no &lt;code&gt;XSLoader&lt;/code&gt;, it falls back to using &lt;code&gt;DynaLoader&lt;/code&gt;.</source>
          <target state="translated">该样板使用低开销的 &lt;code&gt;XSLoader&lt;/code&gt; (如果有）；如果与没有 &lt;code&gt;XSLoader&lt;/code&gt; 的古董Perl一起使用，它将退回到使用 &lt;code&gt;DynaLoader&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac1b6bd4290dbb1a12be2a600f9520d51970c2a" translate="yes" xml:space="preserve">
          <source>This breaks tests that do string comparison of TAP output.</source>
          <target state="translated">这打破了对TAP输出进行字符串比较的测试。</target>
        </trans-unit>
        <trans-unit id="1469fe949bc40a4de2b7dea78ef9ae09eb5856f4" translate="yes" xml:space="preserve">
          <source>This brings up a very important lesson. Code has bugs. Tests are code. Ergo, tests have bugs. A failing test could mean a bug in the code, but don't discount the possibility that the test is wrong.</source>
          <target state="translated">这带来了一个非常重要的教训。代码有bug。测试就是代码。因此,测试是有bug的。一个失败的测试可能意味着代码中的一个bug,但不要忽视测试出错的可能性。</target>
        </trans-unit>
        <trans-unit id="090e5f02457ce14eed85483c0b931f07be2bd405" translate="yes" xml:space="preserve">
          <source>This bug only affects closures that are generated by the block but used afterwards. Lexical variables that are only used during the lifetime of the block's execution will take their individual values for each invocation, as normal.</source>
          <target state="translated">这个bug只影响由块生成但在之后使用的闭包。只在代码块执行期间使用的词法变量将在每次调用时取各自的值,就像正常情况一样。</target>
        </trans-unit>
        <trans-unit id="68e1e1f3b09649c408f4196cd0038c9420b69124" translate="yes" xml:space="preserve">
          <source>This bug was deprecated in Perl 5.004, has been rectified in Perl 5.28 by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt;s.</source>
          <target state="translated">此错误已在Perl 5.004中弃用，已在Perl 5.28中通过仅对方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 使用方法查找进行了纠正。</target>
        </trans-unit>
        <trans-unit id="3fb23a96de018295d436dfc71b478c2f496e60be" translate="yes" xml:space="preserve">
          <source>This bug was fixed in Perl 5.18, but may still trip you up if you are using older versions:</source>
          <target state="translated">这个错误在Perl 5.18中得到了修复,但如果你使用的是旧版本,可能还是会被绊倒。</target>
        </trans-unit>
        <trans-unit id="ca44502c3ed83912a6b5db8a967d8fd6b852bc6b" translate="yes" xml:space="preserve">
          <source>This bug will be rectified in future by using method lookup only for methods' &lt;code&gt;AUTOLOAD&lt;/code&gt; s. However, there is a significant base of existing code that may be using the old behavior. So, as an interim step, Perl currently issues an optional warning when non-methods use inherited &lt;code&gt;AUTOLOAD&lt;/code&gt; s.</source>
          <target state="translated">以后将通过仅对方法的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 使用方法查找来纠正此错误。但是，现有代码有相当大的基础可能在使用旧行为。因此，作为过渡步骤，当非方法使用继承的 &lt;code&gt;AUTOLOAD&lt;/code&gt; 时，Perl当前会发出可选警告。</target>
        </trans-unit>
        <trans-unit id="3151c00be9f916508bc5bf705b67d1e4b35d8229" translate="yes" xml:space="preserve">
          <source>This call extracts the next single substring that is a valid Perl quotelike operator (and removes it from $text):</source>
          <target state="translated">这个调用提取下一个有效的Perl quotelike操作符的单个子串(并将其从$text中删除)。</target>
        </trans-unit>
        <trans-unit id="ced21c2bd0a49aeaa42731431a2edf3632b44a97" translate="yes" xml:space="preserve">
          <source>This call will allow &lt;code&gt;--l&lt;/code&gt; and &lt;code&gt;--L&lt;/code&gt; for the length option, but requires a least &lt;code&gt;--hea&lt;/code&gt; and &lt;code&gt;--hei&lt;/code&gt; for the head and height options.</source>
          <target state="translated">此调用将为长度选项允许 &lt;code&gt;--l&lt;/code&gt; 和 &lt;code&gt;--L&lt;/code&gt; ，但对于头和高度选项至少需要 &lt;code&gt;--hea&lt;/code&gt; 和 &lt;code&gt;--hei&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc74026b11403dd05d9d70bf8ec94212f671778f" translate="yes" xml:space="preserve">
          <source>This callback is where Perl untaints its own capture variables under taint mode (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). See the &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; function in</source>
          <target state="translated">该回调是Perl在taint模式下释放其自己的捕获变量的地方（请参见&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;）。请参见中的 &lt;code&gt;Perl_reg_numbered_buff_fetch&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="34608b82ee2af981743bfaea1702ca89b064619d" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;../term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">始终将调用此回调，并且在上述回调之一被调用后，对于每个结果都会发生此回调。例如，如果加载了&lt;a href=&quot;../term/ansicolor&quot;&gt;Term :: ANSIColor，&lt;/a&gt;则可以使用以下内容为测试输出着色：</target>
        </trans-unit>
        <trans-unit id="f9cffd244aaaaeed6cac7d9924c6db108cbddbfb" translate="yes" xml:space="preserve">
          <source>This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked. For example, if &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; is loaded, you could use the following to color your test output:</source>
          <target state="translated">该回调将始终被调用，并且在上述回调之一被调用后，对于每个结果都会发生这种情况。例如，如果加载了&lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor，&lt;/a&gt;则可以使用以下内容为测试输出着色：</target>
        </trans-unit>
        <trans-unit id="367b3e398988397a700bd743e801d4bc7d9d9445" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;&lt;a href=&quot;#sv_collxfrm_flags&quot;&gt;&quot;sv_collxfrm_flags&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这将使用SV_GMAGIC标志调用 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 。请参阅 &lt;code&gt;&lt;a href=&quot;#sv_collxfrm_flags&quot;&gt;&quot;sv_collxfrm_flags&quot;&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a84240a7c3c6fb058597f6d953d7900c399c1c57" translate="yes" xml:space="preserve">
          <source>This calls &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; with the SV_GMAGIC flag. See &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; .</source>
          <target state="translated">这将使用SV_GMAGIC标志调用 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 。请参阅 &lt;code&gt;sv_collxfrm_flags&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3061d1429b373972a7ca085f04de1fcdc079ed5" translate="yes" xml:space="preserve">
          <source>This calls the &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; syscall with the bit masks specified, which can be constructed using &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt;, along these lines:</source>
          <target state="translated">这将使用指定的位掩码调用&lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select（2）&lt;/a&gt; syscall，可以使用&lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt; &lt;code&gt;fileno&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt; &lt;code&gt;vec&lt;/code&gt; &lt;/a&gt;沿以下行进行构造：</target>
        </trans-unit>
        <trans-unit id="5732bf6668134ab56787956038f1ef3e84c0d62a" translate="yes" xml:space="preserve">
          <source>This calls the &lt;code&gt;bark&lt;/code&gt; method from class &lt;code&gt;Dog&lt;/code&gt; on an object of class &lt;code&gt;Tree&lt;/code&gt;, even if the two classes are completely unrelated. Use this with great care.</source>
          <target state="translated">即使两个类完全不相关，这也会从 &lt;code&gt;Tree&lt;/code&gt; 类的对象上的 &lt;code&gt;Dog&lt;/code&gt; 类调用 &lt;code&gt;bark&lt;/code&gt; 方法。请谨慎使用。</target>
        </trans-unit>
        <trans-unit id="86657828dc4b39c2a031e8feb96e30aa836f7063" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">这将使用指定的位掩码调用select（2）syscall，可以使用 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 沿以下行进行构造：</target>
        </trans-unit>
        <trans-unit id="6030aab04889f87b188edddb787660db9b1b144a" translate="yes" xml:space="preserve">
          <source>This calls the select(2) syscall with the bit masks specified, which can be constructed using &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, along these lines:</source>
          <target state="translated">这将使用指定的位掩码调用select（2）syscall，可以使用 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; 沿以下行进行构造：</target>
        </trans-unit>
        <trans-unit id="9bc12c1e6a592155ae29365e5d2b2a31283e6dd9" translate="yes" xml:space="preserve">
          <source>This can also be a problem with intermediate subprocesses in more complicated code, which will call waitpid() on all open filehandles during global destruction--in no predictable order.</source>
          <target state="translated">在更复杂的代码中,这也是一个中间子进程的问题,因为在全局销毁期间,所有打开的文件柄都会调用waitpid()--没有可预测的顺序。</target>
        </trans-unit>
        <trans-unit id="62869b1f9b57cb9d79e8730408b0c95ddf4b16ac" translate="yes" xml:space="preserve">
          <source>This can also be called with a null first argument to indicate that &lt;code&gt;oldstash&lt;/code&gt; has been deleted.</source>
          <target state="translated">也可以使用空的first参数来调用它，以指示 &lt;code&gt;oldstash&lt;/code&gt; 已被删除。</target>
        </trans-unit>
        <trans-unit id="d43bae30188acac82d7e357353fabe7bc6c40a81" translate="yes" xml:space="preserve">
          <source>This can be accomplished by adding a repeat specifier to the option specification. Repeat specifiers are very similar to the &lt;code&gt;{...}&lt;/code&gt; repeat specifiers that can be used with regular expression patterns. For example, the above command line would be handled as follows:</source>
          <target state="translated">这可以通过在选项规范中添加重复说明符来实现。重复说明符与可以与正则表达式模式一起使用的 &lt;code&gt;{...}&lt;/code&gt; 重复说明符非常相似。例如，上面的命令行将按以下方式处理：</target>
        </trans-unit>
        <trans-unit id="372e8345a480f344b8fa12b55e0c07a688e7200f" translate="yes" xml:space="preserve">
          <source>This can be accomplished with a destination routine:</source>
          <target state="translated">这可以通过一个目的例程来实现。</target>
        </trans-unit>
        <trans-unit id="464c830ff985dea25fcd843d007b91d51ce2d2e9" translate="yes" xml:space="preserve">
          <source>This can be called as an object method with no arguments, in which case the &lt;code&gt;facet_data()&lt;/code&gt; method will be called to get the facet data to be validated.</source>
          <target state="translated">可以将其称为不带参数的对象方法，在这种情况下，将调用 &lt;code&gt;facet_data()&lt;/code&gt; 方法来获取要验证的构面数据。</target>
        </trans-unit>
        <trans-unit id="c3e3779b19d94c38ed3503cfda1db4bf067d5a3d" translate="yes" xml:space="preserve">
          <source>This can be conveniently combined with precalculation of keys as given above.</source>
          <target state="translated">这可以方便地与上面给出的键的预计算相结合。</target>
        </trans-unit>
        <trans-unit id="9aa85730df925d52e0fdb1ee3b214c2aec4f3fb3" translate="yes" xml:space="preserve">
          <source>This can be especially useful when combined with the &lt;code&gt;sockhost_service&lt;/code&gt; or &lt;code&gt;peerhost_service&lt;/code&gt; methods.</source>
          <target state="translated">与 &lt;code&gt;sockhost_service&lt;/code&gt; 或 &lt;code&gt;peerhost_service&lt;/code&gt; 方法结合使用时，这尤其有用。</target>
        </trans-unit>
        <trans-unit id="7cf76472161d915f784b473af79b1bc9fd8e3268" translate="yes" xml:space="preserve">
          <source>This can be used by subclasses to generate a starting facet data hashref. This will populate the hashref with the trace, meta, amnesty, and about facets. These facets are nearly always produced the same way for all events.</source>
          <target state="translated">这可以被子类用来生成一个起始的facet数据hashref。这将用trace、meta、amnesty和about面来填充hashref。这些facet几乎总是以相同的方式为所有事件生成。</target>
        </trans-unit>
        <trans-unit id="e45e565a182719c4b0dabf0a12cdb967109b4b28" translate="yes" xml:space="preserve">
          <source>This can be used even on systems that do not support forking, but this possibly allows code intended to read files to unexpectedly execute programs. If one can be sure that a particular program is a Perl script expecting filenames in @ARGV using the two-argument form of open() or the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, the clever programmer can write something like this:</source>
          <target state="translated">即使在不支持分支的系统上也可以使用它，但这可能允许旨在读取文件的代码意外地执行程序。如果可以确定特定程序是Perl脚本，并且使用open（）或 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 运算符的两个参数形式使用@ARGV中的文件名，那么聪明的程序员可以编写如下代码：</target>
        </trans-unit>
        <trans-unit id="a0b4de28313d2cd5bd8f3c8a3bcc24922ad427d0" translate="yes" xml:space="preserve">
          <source>This can be used to add a callback that is called after all testing is done. This is too late to add additional results, the main use of this callback is to set the exit code.</source>
          <target state="translated">这个可以用来添加一个回调,在所有测试完成后调用。这时再添加额外的结果已经来不及了,这个回调的主要用途是设置退出代码。</target>
        </trans-unit>
        <trans-unit id="f3ad3a6dca3eb7d856d39662d5cd0dcb078d6c2d" translate="yes" xml:space="preserve">
          <source>This can be used to add amnesty to this event. Amnesty only effects failing assertions in most cases, but some formatters may display them for passing assertions, or even non-assertions as well.</source>
          <target state="translated">这可以用来给这个事件添加特赦。在大多数情况下,赦免只对失败的断言有效,但有些格式化器可能会对通过的断言,甚至是非断言也显示赦免。</target>
        </trans-unit>
        <trans-unit id="dee9c9bfb944617270087476daa04080c698fb3a" translate="yes" xml:space="preserve">
          <source>This can be used to change the</source>
          <target state="translated">这可以用来改变</target>
        </trans-unit>
        <trans-unit id="748558e1f1395a2c9a926433d579682f2842ae42" translate="yes" xml:space="preserve">
          <source>This can be used to change the encoding from this event onward.</source>
          <target state="translated">这可以用来改变从这个事件开始的编码。</target>
        </trans-unit>
        <trans-unit id="d06a37a2d3a4148b6ee21e32af3a875ef2d651aa" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; .</source>
          <target state="translated">这可以用于确定模式的哪个分支匹配，而无需为每个分支使用单独的捕获组，这又可以导致性能提高，因为perl无法优化 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; 就像 &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0743ccbc8c558ff3b1e6409093d7b93b4731ff66" translate="yes" xml:space="preserve">
          <source>This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; as efficiently as something like &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt;.</source>
          <target state="translated">这可以用于确定模式的哪个分支匹配，而无需为每个分支使用单独的捕获组，这又可以导致性能提高，因为perl无法优化 &lt;code&gt;/(?:(x)|(y)|(z))/&lt;/code&gt; 就像 &lt;code&gt;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="346fd0e78230a9b57890db54a4f1c29bc084f4d0" translate="yes" xml:space="preserve">
          <source>This can be used to disable auto-ending behavior for a hub. The auto-ending behavior is triggered by an end block and is used to cull IPC events, and output the final plan if the plan was 'NO PLAN'.</source>
          <target state="translated">这可以用来禁用集线器的自动结束行为。自动结束行为由结束块触发,用于剔除IPC事件,并在计划为 &quot;NO PLAN &quot;时输出最终计划。</target>
        </trans-unit>
        <trans-unit id="866129af074a2494eb93f1a1e7f5ceba61d1bdd7" translate="yes" xml:space="preserve">
          <source>This can be used to get/set the no_wait status. Waiting is turned on by default. Waiting will cause the parent process/thread to wait until all child processes and threads are finished before exiting. You will almost never want to turn this off.</source>
          <target state="translated">这可以用来获取/设置no_wait状态。默认情况下,等待是开启的。等待会使父进程/线程等待所有子进程和线程完成后再退出。你几乎永远不会想关闭这个功能。</target>
        </trans-unit>
        <trans-unit id="c6b6a0827f222037bfd74f5afc449218b3d32dc4" translate="yes" xml:space="preserve">
          <source>This can be used to provide overridable configuration defaults:</source>
          <target state="translated">这可以用来提供可覆盖的配置默认值。</target>
        </trans-unit>
        <trans-unit id="4da1a803fb62b25b77cf251408452655ad68be2a" translate="yes" xml:space="preserve">
          <source>This can be used to reliably link multiple events created by the same tool. For instance a failing test like &lt;code&gt;ok(0, &quot;fail&quot;&lt;/code&gt; will generate 2 events, one being a &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;, the other being a &lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2::Event::Diag&lt;/a&gt;, both of these events are related having been created under the same context and by the same initial tool (though multiple tools may have been nested under the initial one).</source>
          <target state="translated">这可用于可靠地链接同一工具创建的多个事件。例如，像 &lt;code&gt;ok(0, &quot;fail&quot;&lt;/code&gt; 类的失败测试将生成2个事件，一个是&lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt;，另一个是&lt;a href=&quot;Test2::Event::Diag&quot;&gt;Test2 :: Event :: Diag&lt;/a&gt;，这两个事件都已创建在相同的上下文和相同的初始工具下（尽管可能在初始工具下嵌套了多个工具）。</target>
        </trans-unit>
        <trans-unit id="6d94a2783d9c9eae4add9e504e9f74c8f2268eac" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context acquire hook.</source>
          <target state="translated">这可以用来删除上下文获取钩子。</target>
        </trans-unit>
        <trans-unit id="78bcfb4fcf149daa8d598288ab8cfd7c250fe9bc" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context init hook.</source>
          <target state="translated">这可以用来删除一个上下文init钩子。</target>
        </trans-unit>
        <trans-unit id="576301f79d31775925cb858d92533113a213c854" translate="yes" xml:space="preserve">
          <source>This can be used to remove a context release hook.</source>
          <target state="translated">这可以用来删除上下文释放钩子。</target>
        </trans-unit>
        <trans-unit id="7302fe67fb868f202093521caa858978f0b6a28c" translate="yes" xml:space="preserve">
          <source>This can be used to see the effect of/bugs in the various layers e.g.</source>
          <target state="translated">这可以用来查看各层的效果/bug,如</target>
        </trans-unit>
        <trans-unit id="574eac6f70577b288bd89928d8641a1fc45055d3" translate="yes" xml:space="preserve">
          <source>This can be used to send an &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; event. This event usually takes either a number of tests you expect to run. Optionally you can set the expected count to 0 and give the 'SKIP' directive with a reason to cause all tests to be skipped.</source>
          <target state="translated">这可以用来发送一个&lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2 :: Event :: Plan&lt;/a&gt;事件。此事件通常会进行您希望运行的许多测试。（可选）您可以将期望计数设置为0，并给'SKIP'指令提供导致所有测试被跳过的原因。</target>
        </trans-unit>
        <trans-unit id="5bfa5c255aef0fa01c834c7ba10a888fee1030c4" translate="yes" xml:space="preserve">
          <source>This can be used to set the template for the IPC temp dir. The template should follow template specifications from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">这可用于设置IPC临时目录的模板。模板应遵循&lt;a href=&quot;File::Temp&quot;&gt;File :: Temp中的&lt;/a&gt;模板规范。</target>
        </trans-unit>
        <trans-unit id="20e14da8dfc2bfdf2f71fc590d8fe2a63e1000ea" translate="yes" xml:space="preserve">
          <source>This can be used to store bytes in the string component of the SV. Here the representation of the data is irrelevant to perl and the bytes themselves are just stored in the SV. It is assumed that the C variable is a pointer (the bytes are copied from that memory location). If the pointer is pointing to something that is represented by 8 bytes then those 8 bytes are stored in the SV (and length() will report a value of 8). This entry is similar to T_OPAQUE.</source>
          <target state="translated">这可以用来在SV的字符串组件中存储字节。这里数据的表示方式与perl无关,字节本身只是存储在SV中。假设C变量是一个指针(字节是从该内存位置复制过来的)。如果指针指向一个由8个字节表示的东西,那么这8个字节就会被存储在SV中(length()会报告一个8的值)。此条目与T_OPAQUE类似。</target>
        </trans-unit>
        <trans-unit id="0410f2327d86bdf0fdae05f37687269ec62b9fe1" translate="yes" xml:space="preserve">
          <source>This can be used to store data from non-pointer types in the string part of an SV. It is similar to T_OPAQUEPTR except that the typemap retrieves the pointer directly rather than assuming it is being supplied. For example, if an integer is imported into Perl using T_OPAQUE rather than T_IV the underlying bytes representing the integer will be stored in the SV but the actual integer value will not be available. i.e. The data is opaque to perl.</source>
          <target state="translated">它可以用来在SV的字符串部分存储非指针类型的数据。它与T_OPAQUEPTR类似,只是类型映射直接检索指针,而不是假设它是被提供的。例如,如果使用 T_OPAQUE 而不是 T_IV 将一个整数导入到 Perl 中,代表整数的底层字节将被存储在 SV 中,但实际的整数值将不可用,即数据对 perl 是不透明的。</target>
        </trans-unit>
        <trans-unit id="89bc9efe11bbc18be53fe6f2369d301f92011919" translate="yes" xml:space="preserve">
          <source>This can be useful when carrying out batch operations on multiple files that have both an input filename and output filename and the output file can be derived from the input filename. Examples of operations where this can be useful include, file renaming, file copying and file compression.</source>
          <target state="translated">当对多个文件进行批处理操作时,这很有用,因为这些文件既有输入文件名,又有输出文件名,而且输出文件可以从输入文件名导出。这很有用的操作例子包括:文件重命名、文件复制和文件压缩。</target>
        </trans-unit>
        <trans-unit id="7ee5530e46592bdd5b18c5d4e4adf9c1e149be67" translate="yes" xml:space="preserve">
          <source>This can easily be demonstrated by using a module, such as the Socket module, which uses eval &quot;...&quot; as part of an AUTOLOAD function. You can 'use' the module outside the compartment and share an (autoloaded) function with the compartment. If an autoload is triggered by code in the compartment, or by any code anywhere that is called by any means from the compartment, then the eval in the Socket module's AUTOLOAD function happens in the namespace of the compartment. Any variables created or used by the eval'd code are now under the control of the code in the compartment.</source>
          <target state="translated">这可以通过使用一个模块,比如Socket模块,它使用eval&quot;...&quot;作为AUTOLOAD函数的一部分来轻松演示。你可以在隔间之外 &quot;使用 &quot;这个模块,并与隔间共享一个(自动加载)函数。如果自动加载是由隔间中的代码触发的,或者是由任何地方的代码以任何方式从隔间中调用的,那么Socket模块的AUTOLOAD函数中的eval就发生在隔间的命名空间中。由 eval'd 代码创建或使用的任何变量现在都在分格中的代码的控制之下。</target>
        </trans-unit>
        <trans-unit id="aaf34cf4f37f54a5f64557a3e90c8cf5a33d7a99" translate="yes" xml:space="preserve">
          <source>This can fail to be unique if a process generates an id, calls exec, and does it again after the exec and it all happens in less than a second. It can also happen if the systems process id's cycle in less than a second allowing 2 different programs that use this generator to run with the same PID in less than a second. Both these cases are sufficiently unlikely. If you need universally unique ids, or ids that are unique in these conditions, look at &lt;a href=&quot;Data::UUID&quot;&gt;Data::UUID&lt;/a&gt;.</source>
          <target state="translated">如果一个进程生成一个id，调用exec，并在exec之后再次执行它，而这一切都在不到一秒钟的时间内完成，则这可能是唯一的。如果系统在不到一秒的时间内处理id的周期，并且允许使用该生成器的2个不同程序在不到一秒的时间内以相同的PID运行，也会发生这种情况。这两种情况都不太可能发生。如果需要通用唯一的ID或在这些情况下唯一的ID，请查看&lt;a href=&quot;Data::UUID&quot;&gt;Data :: UUID&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33eb1b5384e732b374fa6a2eb81b539c4ef372da" translate="yes" xml:space="preserve">
          <source>This can give a serious performance boost to your threaded program, since more than one thread will be executing at the same time. As a tradeoff, though, any of those nagging synchronization issues that might not have shown with basic kernel threads will appear with a vengeance.</source>
          <target state="translated">这可以给你的线程程序带来严重的性能提升,因为不止一个线程会同时执行。不过,作为一种权衡,任何那些在基本的内核线程中可能没有表现出来的烦人的同步问题都会报复性地出现。</target>
        </trans-unit>
        <trans-unit id="56f625d37a903c20859d631591a0773b6d672cf7" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt; , Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">这可能导致一些歧义。当 &lt;code&gt;\N&lt;/code&gt; 不紧跟左括号时，Perl将采用 &lt;code&gt;[^\n]&lt;/code&gt; 含义。另外，如果括号形成有效的量词，例如 &lt;code&gt;\N{3}&lt;/code&gt; 或 &lt;code&gt;\N{5,}&lt;/code&gt; ，则Perl假定这意味着要匹配给定数量的非换行符（在这些示例中为3； 5或更多，分别）。在所有其他情况下，如果有 &lt;code&gt;\N{&lt;/code&gt; 和匹配的 &lt;code&gt;}&lt;/code&gt; ，Perl假定需要一个字符名称。</target>
        </trans-unit>
        <trans-unit id="723464c11a99a5463e5bccf086f2c836d4ccab19" translate="yes" xml:space="preserve">
          <source>This can lead to some ambiguities. When &lt;code&gt;\N&lt;/code&gt; is not followed immediately by a left brace, Perl assumes the &lt;code&gt;[^\n]&lt;/code&gt; meaning. Also, if the braces form a valid quantifier such as &lt;code&gt;\N{3}&lt;/code&gt; or &lt;code&gt;\N{5,}&lt;/code&gt;, Perl assumes that this means to match the given quantity of non-newlines (in these examples, 3; and 5 or more, respectively). In all other case, where there is a &lt;code&gt;\N{&lt;/code&gt; and a matching &lt;code&gt;}&lt;/code&gt;, Perl assumes that a character name is desired.</source>
          <target state="translated">这可能会导致一些歧义。当 &lt;code&gt;\N&lt;/code&gt; 不紧跟左括号时，Perl会采用 &lt;code&gt;[^\n]&lt;/code&gt; 含义。另外，如果括号形成有效的量词，例如 &lt;code&gt;\N{3}&lt;/code&gt; 或 &lt;code&gt;\N{5,}&lt;/code&gt; ，则Perl假定这意味着要匹配给定数量的非换行符（在这些示例中为3； 5或更多，分别）。在所有其他情况下，如果有 &lt;code&gt;\N{&lt;/code&gt; 和匹配的 &lt;code&gt;}&lt;/code&gt; ，Perl假定需要一个字符名称。</target>
        </trans-unit>
        <trans-unit id="959b6fc0ff47607dd43aa724268206e3f29dd78b" translate="yes" xml:space="preserve">
          <source>This can lead to unexpected results. For example, a string's semantics can suddenly change if a code point above 255 is appended to it, which changes the rules from ASCII to Unicode. As an example, consider the following program and its output:</source>
          <target state="translated">这可能导致意想不到的结果。例如,如果在一个字符串中附加一个高于255的码点,那么它的语义就会突然发生变化,从而改变了从ASCII到Unicode的规则。作为一个例子,考虑以下程序及其输出。</target>
        </trans-unit>
        <trans-unit id="85608589698ca117deecc9b9804cdf91bb5ea3e0" translate="yes" xml:space="preserve">
          <source>This can result from a bug in emx sprintf which was fixed in 0.9d fix 03.</source>
          <target state="translated">这可能是由于emx sprintf的一个bug造成的,这个bug在0.9d修复03中得到了修复。</target>
        </trans-unit>
        <trans-unit id="a0068e1ff0325fa89c18995ccdfd4bec0d4d0e1c" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using a (non-gcc) vendor cc, this variable may contain a version for the compiler.</source>
          <target state="translated">这可以通过提示文件或Configure来设置,如果使用(非gcc)厂商的cc,这个变量可能包含编译器的版本。如果使用的是(非gcc)供应商cc,这个变量可能包含编译器的版本。</target>
        </trans-unit>
        <trans-unit id="b497dc3b646a186b11a326e1c1c02e389336f453" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt; .</source>
          <target state="translated">可以通过提示文件或&amp;ldquo;配置&amp;rdquo;进行设置。如果使用gcc，则为gcc，否则，通常等于cc，效果不佳，不是吗？但是，某些平台通过存储此处使用的C编译器的样式来充分利用此功能。例如，如果使用Sun WorkShop套件，则ccname将为 &lt;code&gt;workshop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69cabf4ea065c9fd2da62cddd5444eb3ffe5f2f7" translate="yes" xml:space="preserve">
          <source>This can set either by hints files or by Configure. If using gcc, this is gcc, and if not, usually equal to cc, unimpressive, no? Some platforms, however, make good use of this by storing the flavor of the C compiler being used here. For example if using the Sun WorkShop suite, ccname will be &lt;code&gt;workshop&lt;/code&gt;.</source>
          <target state="translated">这可以通过提示文件或&amp;ldquo;配置&amp;rdquo;进行设置。如果使用gcc，则为gcc，否则，通常等于cc，效果不佳，不是吗？但是，某些平台通过存储此处使用的C编译器的样式来充分利用此功能。例如，如果使用Sun WorkShop套件，则ccname将为 &lt;code&gt;workshop&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a6e8fb26d6f44c6d09abe16fd5950ff26dfa1ef" translate="yes" xml:space="preserve">
          <source>This category includes</source>
          <target state="translated">这一类包括</target>
        </trans-unit>
        <trans-unit id="268887449daa89d9e6e6591c09f61433e4f65428" translate="yes" xml:space="preserve">
          <source>This causes Attribute::Handlers to define the &lt;code&gt;Roo&lt;/code&gt; attribute in the package that imports the Tie::Me::Kangaroo:Down::Sport module.</source>
          <target state="translated">这将导致Attribute :: Handlers 在导入Tie :: Me :: Kangaroo：Down :: Sport模块的包中定义 &lt;code&gt;Roo&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="102ace81a524208492f6e027d89b5645163151f6" translate="yes" xml:space="preserve">
          <source>This causes perl to load your module but does not import any symbols.</source>
          <target state="translated">这将导致perl加载你的模块,但不导入任何符号。</target>
        </trans-unit>
        <trans-unit id="c30feda4a3a3684c859a87888367dce95a5f76b5" translate="yes" xml:space="preserve">
          <source>This causes the redispatcher to only visit each distinct &lt;code&gt;method&lt;/code&gt; method once. That is, to skip any classes in the hierarchy that it has already visited during redispatch. So, for example, if the previous example were rewritten:</source>
          <target state="translated">这将导致redispatcher只能访问每个不同的 &lt;code&gt;method&lt;/code&gt; ，一旦方法。也就是说，跳过重新分发期间已访问的层次结构中的任何类。因此，例如，如果先前的示例被重写：</target>
        </trans-unit>
        <trans-unit id="592a0947cedbbcf96e6c431161a1536bd9ea5fd0" translate="yes" xml:space="preserve">
          <source>This certainly works on Android 8.1 (Oreo) at least...</source>
          <target state="translated">这当然可以在Android 8.1 (奥利奥)至少......。</target>
        </trans-unit>
        <trans-unit id="582cc40cbf8b3547920ee86c914be4717f134b16" translate="yes" xml:space="preserve">
          <source>This change was made because it was found that various commercial tools like editors, or for things like source code control, had been written so that they would not handle program files that used these code points, effectively precluding their use almost entirely! And that was never the intent. They've always been meant to be usable within an application, or cooperating set of applications, at will.</source>
          <target state="translated">之所以做出这样的改变,是因为发现各种商业工具,比如编辑器,或者是源代码控制之类的工具,在编写的时候,它们不会处理使用这些代码点的程序文件,实际上几乎完全排除了这些代码点的使用!而这从来都不是本意。而这从来不是我们的本意。它们一直都是为了在一个应用程序或合作的应用程序集内可以随意使用的。</target>
        </trans-unit>
        <trans-unit id="70a94d66ba03d51816f1be0f440a820bbe8643da" translate="yes" xml:space="preserve">
          <source>This change was originally scheduled for 5.30, but was delayed until 5.32.</source>
          <target state="translated">这一变化原定于5.30,但被推迟到5.32。</target>
        </trans-unit>
        <trans-unit id="c679de889cc139bb514d15d08372653b38479f14" translate="yes" xml:space="preserve">
          <source>This changes the sentence to &quot;this is a SUcCess case.&quot;</source>
          <target state="translated">这就把句子改成了 &quot;这是一个诉讼案件&quot;。</target>
        </trans-unit>
        <trans-unit id="806d9541617fb633252bc021124ba56dfb002ae1" translate="yes" xml:space="preserve">
          <source>This changes the string that this token holds. You probably won't need to do this.</source>
          <target state="translated">这将改变这个标记所持有的字符串。你可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="1b4ce31991e674e8d238b692a9312c922759283b" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this end-token object. You probably won't need to do this.</source>
          <target state="translated">这将改变这个结束标记对象的 tagname。您可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="05c1f4e6ea1fd867b5212d7916e4ce924dd15d97" translate="yes" xml:space="preserve">
          <source>This changes the tagname for this start-token object. You probably won't need to do this.</source>
          <target state="translated">这将改变这个起始标记对象的 tagname。你可能不需要这样做。</target>
        </trans-unit>
        <trans-unit id="642eb07575d1344323a97b06a777777ad1321fc4" translate="yes" xml:space="preserve">
          <source>This chart is sorted from slowest to fastest, and shows the percent speed difference between each pair of tests.</source>
          <target state="translated">这张图从最慢到最快排序,并显示每对测试之间的速度差异百分比。</target>
        </trans-unit>
        <trans-unit id="7da28c0924cf2fc297ae57e942274584c8adbeb4" translate="yes" xml:space="preserve">
          <source>This checks that every file listed in the .packlist actually exists. If an argument which evaluates to true is given, any missing files will be removed from the internal hash. The return value is a list of the missing files, which will be empty if they all exist.</source>
          <target state="translated">这将检查 .packlist 中列出的每个文件是否真实存在。如果给定一个参数为true,任何丢失的文件将从内部哈希中删除。返回值是一个缺失文件的列表,如果它们都存在,则为空。</target>
        </trans-unit>
        <trans-unit id="f55eba663917d253b044988b2b6ee903ef6a93dc" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;../simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">此类（很小，请阅读源代码）重写Pod :: Simple的_handle_element_start，_handle_text和_handle_element_end方法，以便将解析器事件转换为方法调用。（否则，这是&lt;a href=&quot;../simple&quot;&gt;Pod :: Simple&lt;/a&gt;的子类，并继承其所有方法。）</target>
        </trans-unit>
        <trans-unit id="b03d667c22f13241e3a139f207cffaeb024c8e82" translate="yes" xml:space="preserve">
          <source>This class (which is very small -- read the source) overrides Pod::Simple's _handle_element_start, _handle_text, and _handle_element_end methods so that parser events are turned into method calls. (Otherwise, this is a subclass of &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; and inherits all its methods.)</source>
          <target state="translated">此类（很小，请阅读源代码）重写Pod :: Simple的_handle_element_start，_handle_text和_handle_element_end方法，以便将解析器事件转换为方法调用。（否则，这是&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple&lt;/a&gt;的子类，并继承其所有方法。）</target>
        </trans-unit>
        <trans-unit id="494e46870d49e2dc3a5f9a64f75952ec99423e9a" translate="yes" xml:space="preserve">
          <source>This class defines several methods for setting (and, occasionally, reading) the contents of an object. With two exceptions (discussed at the end of this section), these attributes are just for controlling the way searches are carried out.</source>
          <target state="translated">这个类定义了几种方法,用于设置(偶尔也用于读取)对象的内容。除了两个例外(在本节最后讨论),这些属性只是用来控制搜索的方式。</target>
        </trans-unit>
        <trans-unit id="10596a84cc3ac1cc04ef71cd92099faf5ee0b3a2" translate="yes" xml:space="preserve">
          <source>This class inherits from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;.</source>
          <target state="translated">此类从&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;继承。</target>
        </trans-unit>
        <trans-unit id="2163bae8bf6b5d5c2d8787321d0be16cd6ab8a00" translate="yes" xml:space="preserve">
          <source>This class inherits from &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;.</source>
          <target state="translated">此类从&lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt;继承。</target>
        </trans-unit>
        <trans-unit id="1d32aad8f8251ef1db7bcc4b8f3feb324d9d1213" translate="yes" xml:space="preserve">
          <source>This class is NOT a subclass of Pod::Simple::HTML (nor of bad old Pod::Html) -- although it uses Pod::Simple::HTML for doing the conversion of each document.</source>
          <target state="translated">这个类不是Pod::Simple::HTML的子类(也不是旧的Pod::Html的子类)--尽管它使用Pod::Simple::HTML来完成每个文档的转换。</target>
        </trans-unit>
        <trans-unit id="b711767b4a974da1a1509d38f153220b0d62949c" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as RTF, good for viewing/printing in MSWord, WordPad/write.exe, TextEdit, etc.</source>
          <target state="translated">这个类是一个格式化器,它将Pod转换成RTF格式,适合在MSWord,WordPad/write.exe,TextEdit等软件中查看/打印。</target>
        </trans-unit>
        <trans-unit id="138981ec5228a60a4f53dbf829b51f5efd9f8a75" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as XHTML validating HTML.</source>
          <target state="translated">这个类是一个formatter,它接受Pod并将其渲染为XHTML验证的HTML。</target>
        </trans-unit>
        <trans-unit id="3d4c24315ad07b2a992c0858db0b7be768d0cc0b" translate="yes" xml:space="preserve">
          <source>This class is a formatter that takes Pod and renders it as wrapped plaintext.</source>
          <target state="translated">这个类是一个格式化器,它接收Pod并将其渲染为包装的明文。</target>
        </trans-unit>
        <trans-unit id="abf165bcb49a87540f63e8d80594894213b097e7" translate="yes" xml:space="preserve">
          <source>This class is a stack of hooks to be called in the right order as scopes go away. The stack is only useful when inserted into &lt;code&gt;%^H&lt;/code&gt; and will pop hooks as their &quot;scope&quot; is popped. This is useful for uninstalling or reinstalling subs in a namespace as a pragma goes out of scope.</source>
          <target state="translated">此类是一堆钩子，随着作用域的消失，将以正确的顺序调用这些钩子。堆栈仅在插入 &lt;code&gt;%^H&lt;/code&gt; 时才有用，并且会在弹出&amp;ldquo;范围&amp;rdquo;时弹出钩子。当编译指示超出范围时，这对于在命名空间中卸载或重新安装子程序很有用。</target>
        </trans-unit>
        <trans-unit id="62abaee97c33098880e266351ef2fc532bf53875" translate="yes" xml:space="preserve">
          <source>This class is an internal interface only.</source>
          <target state="translated">该类只是一个内部接口。</target>
        </trans-unit>
        <trans-unit id="a096fe03bdd3c99f0e3aefd253d422021e7447e7" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;Pod::Simple::Text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">此类用于检查Pod的语法有效性。它的工作原理基本上就像是&lt;a href=&quot;Pod::Simple::Text&quot;&gt;Pod :: Simple :: Text的简单&lt;/a&gt;版本，仅格式化&amp;ldquo; Pod Errors&amp;rdquo;部分的格式（如果Pod :: Simple甚至为给定文档生成一个）。</target>
        </trans-unit>
        <trans-unit id="5e43c4bd22a6b18d8bc78626e236eaa142e2b822" translate="yes" xml:space="preserve">
          <source>This class is for checking the syntactic validity of Pod. It works by basically acting like a simple-minded version of &lt;a href=&quot;text&quot;&gt;Pod::Simple::Text&lt;/a&gt; that formats only the &quot;Pod Errors&quot; section (if Pod::Simple even generates one for the given document).</source>
          <target state="translated">此类用于检查Pod的语法有效性。它的工作原理基本上就像是&lt;a href=&quot;text&quot;&gt;Pod :: Simple :: Text的简单&lt;/a&gt;版本，仅格式化&amp;ldquo; Pod Errors&amp;rdquo;部分的格式（如果Pod :: Simple甚至为给定文档生成一个）。</target>
        </trans-unit>
        <trans-unit id="9b791e36572b7d483165e52086de0aff10cad7ba" translate="yes" xml:space="preserve">
          <source>This class is for dumping, as text, the events gotten from parsing a Pod document. This class is of interest to people writing Pod formatters based on Pod::Simple. It is useful for seeing exactly what events you get out of some Pod that you feed in.</source>
          <target state="translated">该类用于以文本形式转储从解析Pod文档中得到的事件。这个类对基于Pod::Simple编写Pod格式器的人很有兴趣。它对于查看你从一些Pod中得到的事件非常有用。</target>
        </trans-unit>
        <trans-unit id="a18cdad26fb8d235532c57fb43aa60327d80a50a" translate="yes" xml:space="preserve">
          <source>This class is for making an HTML rendering of a Pod document.</source>
          <target state="translated">该类用于制作Pod文档的HTML渲染。</target>
        </trans-unit>
        <trans-unit id="fd75675624091c3742f49bbeb8bbfb0c06a37c0a" translate="yes" xml:space="preserve">
          <source>This class is for using Pod::Simple to build a Pod processor -- but one that uses an interface based on a stream of token objects, instead of based on events.</source>
          <target state="translated">这个类是用来使用Pod::Simple来构建一个Pod处理器--但它使用的是基于token对象流的接口,而不是基于事件。</target>
        </trans-unit>
        <trans-unit id="44761047bfaa4c6cc438e77b4bb92131ad714c01" translate="yes" xml:space="preserve">
          <source>This class is inspired by XML::Parser's &quot;Tree&quot; parsing-style, although it doesn't use exactly the same LoL format.</source>
          <target state="translated">这个类的灵感来自于XML::Parser的 &quot;树 &quot;解析风格,尽管它没有使用完全相同的LoL格式。</target>
        </trans-unit>
        <trans-unit id="a9698adab813e0c4fae21452c7598015f3935b3d" translate="yes" xml:space="preserve">
          <source>This class is not of interest to general users.</source>
          <target state="translated">一般用户对这门课不感兴趣。</target>
        </trans-unit>
        <trans-unit id="2f2f6048d2f61aa8645bcc5ebd42e19fc8c8aea4" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing Pod formatters based on Pod::Simple.</source>
          <target state="translated">这门课对基于Pod::Simple编写Pod格式器的人很感兴趣。</target>
        </trans-unit>
        <trans-unit id="f63f889f338653b4ee33eb44dc0ee1133ee852ae" translate="yes" xml:space="preserve">
          <source>This class is of interest to people writing a Pod processor/formatter.</source>
          <target state="translated">这门课是编写Pod处理器/格式的人感兴趣的。</target>
        </trans-unit>
        <trans-unit id="6dca4f8907e7dbb28751ea149d9af37422c91f32" translate="yes" xml:space="preserve">
          <source>This class is that parses Pod and dumps just the text content. It is mainly meant for use by the Pod::Simple test suite, but you may find some other use for it.</source>
          <target state="translated">这个类是用来解析Pod和转储文本内容的。它主要用于Pod::Simple测试套件,但你可能会发现它的其他用途。</target>
        </trans-unit>
        <trans-unit id="5a51d38f10e103a9903a5853a79eae683ff646eb" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;../../parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; , then you have a bunch of methods at your disposal.</source>
          <target state="translated">此类是&lt;a href=&quot;../../parser&quot;&gt;TAP :: Parser&lt;/a&gt;系统的主力军。大多数TAP行都是测试行，如果 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; ，那么您可以使用许多方法。</target>
        </trans-unit>
        <trans-unit id="77ad00f96e4fc79112ecce425a98459f96769eb3" translate="yes" xml:space="preserve">
          <source>This class is the workhorse of the &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; system. Most TAP lines will be test lines and if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt;, then you have a bunch of methods at your disposal.</source>
          <target state="translated">此类是&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;系统的主力军。大多数TAP行将是测试行，如果 &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; ，那么您可以使用许多方法。</target>
        </trans-unit>
        <trans-unit id="cb2f9188e79ee28d20f325b48fe2bf4717272a64" translate="yes" xml:space="preserve">
          <source>This class is used to bless perl subs so that they are invoked when they are destroyed. This is mostly useful for ensuring the code is invoked at end of scope. This module is not a part of autodie's public API.</source>
          <target state="translated">这个类用来祝福perl子类,使它们在被销毁时被调用。这主要是为了确保代码在作用域结束时被调用。这个模块不是autodie的公共API的一部分。</target>
        </trans-unit>
        <trans-unit id="6f581c5cd9d5c7598c0dcb3ca6436c9bd821c2c4" translate="yes" xml:space="preserve">
          <source>This class might turn out to be a temporary solution, but MM won't go away.</source>
          <target state="translated">这个班级可能会变成一个暂时的解决方案,但MM不会消失。</target>
        </trans-unit>
        <trans-unit id="24195eb4cea8857a411b60273a35c873f422dbe0" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt; . It takes no parameters:</source>
          <target state="translated">此类提供一个构造函数，称为 &lt;code&gt;new&lt;/code&gt; 。它不带任何参数：</target>
        </trans-unit>
        <trans-unit id="3cdd607371055ba28bceb9607eba0f99a8092ae1" translate="yes" xml:space="preserve">
          <source>This class provides the one constructor, called &lt;code&gt;new&lt;/code&gt;. It takes no parameters:</source>
          <target state="translated">此类提供了一个名为 &lt;code&gt;new&lt;/code&gt; 的构造函数。它不带任何参数：</target>
        </trans-unit>
        <trans-unit id="3b0678c7cdb712a22e1337039fd311842e231f0c" translate="yes" xml:space="preserve">
          <source>This class represents a subtest. This class is a subclass of &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt;.</source>
          <target state="translated">此类表示一个子测试。此类是&lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt;的子类。</target>
        </trans-unit>
        <trans-unit id="548ad953daf93abd12a978fa239d01a039bfc535" translate="yes" xml:space="preserve">
          <source>This class returns a copy of its input, translated into Perl's internal encoding (UTF-8), and with all the non-Pod lines removed.</source>
          <target state="translated">该类返回其输入的副本,翻译成Perl的内部编码(UTF-8),并删除所有非Pod行。</target>
        </trans-unit>
        <trans-unit id="0460fe0f3a1a52c6921164fb6520b6ae745aaf17" translate="yes" xml:space="preserve">
          <source>This class strives to return the Pod lines of the input completely unchanged, except for any necessary translation into Perl's internal encoding, and it makes no effort to return trailing spaces on lines; these likely will be stripped. If the input pod is well-formed with no warnings nor errors generated, the extracted pod should generate the same documentation when formatted by a Pod formatter as the original file does.</source>
          <target state="translated">除了任何必要的翻译成Perl的内部编码外,该类力争完全不变地返回输入的Pod行,而且它不努力返回行上的尾部空格;这些可能会被剥离。如果输入的pod格式良好,没有产生任何警告或错误,那么提取的pod在被pod格式化时应该会产生与原始文件相同的文档。</target>
        </trans-unit>
        <trans-unit id="f30e23715125a3d5360cef7bf3e4022849622110" translate="yes" xml:space="preserve">
          <source>This class takes Pod and parses it, returning a parse tree made just of arrayrefs, and hashrefs, and strings.</source>
          <target state="translated">这个类接受Pod并对其进行解析,返回一个只由arrayrefs、hashrefs和字符串组成的解析树。</target>
        </trans-unit>
        <trans-unit id="9dbee182dfa76d92a94c69cd0858c1622ac2f770" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">这个客户端比到目前为止我们做过的两个客户端要复杂得多，但是如果您使用的系统支持强大的 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 调用，则解决方案并不那么困难。一旦建立了您想与之聊天的任何服务的连接，就可以调用 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 来克隆您的进程。这两个相同的过程中的每一个都有一个非常简单的工作：父级将所有内容从套接字复制到标准输出，而子级同时将所有内容从标准输入复制到套接字。仅使用一个过程即可完成同一件事</target>
        </trans-unit>
        <trans-unit id="bb7d2aab86d534bfc6e56a8de0ba001be898cbe5" translate="yes" xml:space="preserve">
          <source>This client is more complicated than the two we've done so far, but if you're on a system that supports the powerful &lt;code&gt;fork&lt;/code&gt; call, the solution isn't that rough. Once you've made the connection to whatever service you'd like to chat with, call &lt;code&gt;fork&lt;/code&gt; to clone your process. Each of these two identical process has a very simple job to do: the parent copies everything from the socket to standard output, while the child simultaneously copies everything from standard input to the socket. To accomplish the same thing using just one process would be</source>
          <target state="translated">这个客户端比到目前为止我们已经完成的两个客户端要复杂得多，但是如果您使用的系统支持强大的 &lt;code&gt;fork&lt;/code&gt; 调用，则解决方案并不那么困难。一旦建立了您想与之聊天的任何服务的连接，就可以调用 &lt;code&gt;fork&lt;/code&gt; 来克隆您的进程。这两个相同过程中的每一个都有一个非常简单的工作：父级将所有内容从套接字复制到标准输出，而子级同时将所有内容从标准输入复制到套接字。只需使用一个过程即可完成同一件事</target>
        </trans-unit>
        <trans-unit id="ceec53b2ebb7603eb9ee71d9bde01119b83707cb" translate="yes" xml:space="preserve">
          <source>This clones the repository and makes a local copy in the</source>
          <target state="translated">这将克隆版本库,并在本机的</target>
        </trans-unit>
        <trans-unit id="53ac61605ac32344cb2fde8cb4e762d87b323ee2" translate="yes" xml:space="preserve">
          <source>This code has to jump through a few hoops to achieve this because</source>
          <target state="translated">这段代码必须跳过几个圈才能实现,因为</target>
        </trans-unit>
        <trans-unit id="5330da17cfc7cfcf64aab224d5b574c934e7ac2c" translate="yes" xml:space="preserve">
          <source>This code heavily adapted from an early version of perl5db.pl attributable to Larry Wall and the Perl Porters.</source>
          <target state="translated">这段代码大量改编自早期的 perl5db.pl 版本,归功于 Larry Wall 和 Perl Porters。</target>
        </trans-unit>
        <trans-unit id="20e0786f01d076b98983216819824cb18ece543e" translate="yes" xml:space="preserve">
          <source>This code is derived from software contributed to Berkeley by Guido van Rossum.</source>
          <target state="translated">这段代码来源于Guido van Rossum贡献给Berkeley的软件。</target>
        </trans-unit>
        <trans-unit id="847d9232033c7120d3555ace79f29fd71ad7ef18" translate="yes" xml:space="preserve">
          <source>This code is in Github in the CPAN.pm repository:</source>
          <target state="translated">这段代码在Github的CPAN.pm仓库里。</target>
        </trans-unit>
        <trans-unit id="11c4fc183eca8652881b1cb5b12c6ea249b79ebe" translate="yes" xml:space="preserve">
          <source>This code is intended for development only, and may not be portable even to all Unix variants. Also, it is an 80% solution, in that it isn't able to make all ops read only. Specifically it does not apply to op slabs belonging to &lt;code&gt;BEGIN&lt;/code&gt; blocks.</source>
          <target state="translated">该代码仅用于开发，甚至不能移植到所有Unix变体。另外，它是80％的解决方案，因为它不能使所有操作都只读。特别是，它不适用于属于 &lt;code&gt;BEGIN&lt;/code&gt; 块的操作平板。</target>
        </trans-unit>
        <trans-unit id="4a8e4db5444d8620ae9620bb90f970a958584613" translate="yes" xml:space="preserve">
          <source>This code is unusual in that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt;. Whether or not it complains, the</source>
          <target state="translated">该代码是不寻常的，因为它不应该包含任何内容。也就是说，如果处理器看到 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 则可能会抱怨。无论是否抱怨，</target>
        </trans-unit>
        <trans-unit id="443071b2d9d382ee44392d30a6c9cc6944390654" translate="yes" xml:space="preserve">
          <source>This code is unusual in that most formatters completely discard this code and its content. Other formatters will render it with invisible codes that can be used in building an index of the current document.</source>
          <target state="translated">这段代码很不寻常,因为大多数格式化程序会完全丢弃这段代码及其内容。其他格式化程序会用不可见的代码来呈现它,这些代码可以用来建立当前文档的索引。</target>
        </trans-unit>
        <trans-unit id="ed77ac1105bfebc895982f70abdb5f07d0f61471" translate="yes" xml:space="preserve">
          <source>This code is unusual is that it should have no content. That is, a processor may complain if it sees &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; . Whether or not it complains, the</source>
          <target state="translated">此代码不寻常，因为它不应该包含任何内容。也就是说，如果处理器看到 &lt;code&gt;Z&amp;lt;potatoes&amp;gt;&lt;/code&gt; 则可能会抱怨。无论是否抱怨，</target>
        </trans-unit>
        <trans-unit id="9f748555f0c218e80f371f8622c90719bdf4c3e1" translate="yes" xml:space="preserve">
          <source>This code resides primarily in</source>
          <target state="translated">这个代码主要存在于</target>
        </trans-unit>
        <trans-unit id="b4ca79218fad07abe234bb2cecfbf2b9daaa8186" translate="yes" xml:space="preserve">
          <source>This code tries to return a new SV (which contains the value 42) if it should return a real value, or undef otherwise. Instead it has returned a NULL pointer which, somewhere down the line, will cause a segmentation violation, bus error, or just weird results. Change the zero to &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in the first line and all will be well.</source>
          <target state="translated">如果此代码应返回实值，则尝试返回新的SV（包含值42），否则返回undef。取而代之的是，它返回了一个NULL指针，该指针在行的某处将导致分段违规，总线错误或只是奇怪的结果。在第一行中将零更改为 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; ，一切都会好起来。</target>
        </trans-unit>
        <trans-unit id="706270f16eed93ab30bcb6ac5dad9c206e0d53d4" translate="yes" xml:space="preserve">
          <source>This code will behave identically under both &lt;code&gt;IO::Socket::INET&lt;/code&gt; and &lt;code&gt;IO::Socket::IP&lt;/code&gt;.</source>
          <target state="translated">此代码在 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 和 &lt;code&gt;IO::Socket::IP&lt;/code&gt; 下的行为相同。</target>
        </trans-unit>
        <trans-unit id="6b0496da28a3ec6a32260558d3028edcf275c0a4" translate="yes" xml:space="preserve">
          <source>This combination of options may also be specified thus</source>
          <target state="translated">这种选项的组合也可以这样指定</target>
        </trans-unit>
        <trans-unit id="738a4e0887c40771b0a61f4f0df6d45e56b8d5cf" translate="yes" xml:space="preserve">
          <source>This combination performs the work of the legacy functions gethostbyname() and inet_ntoa().</source>
          <target state="translated">这个组合执行了传统函数gethostbyname()和inet_ntoa()的工作。</target>
        </trans-unit>
        <trans-unit id="72e5e8c3a2d9fab681c4b573c92998cd66dd340c" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;About =over...=back Regions&quot;&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">此命令指示列表中的项目从此处开始。格式化代码已处理。本段其余部分中（可选）文本的语义在下面的&lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&amp;ldquo;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。例子：</target>
        </trans-unit>
        <trans-unit id="d728ee6330c55e20ceb083fe7c0710810e2932ca" translate="yes" xml:space="preserve">
          <source>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Examples:</source>
          <target state="translated">此命令指示列表中的项目从此处开始。格式化代码已处理。本段其余部分中（可选）文本的语义在下面的&amp;ldquo; &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。例子：</target>
        </trans-unit>
        <trans-unit id="4a355ff290cc8d5e2710e8069a06d654602bb061" translate="yes" xml:space="preserve">
          <source>This command indicates that the text in the remainder of the paragraph is a heading. That text may contain formatting codes. Examples:</source>
          <target state="translated">该命令表示该段其余部分的文字为标题。该文本可能包含格式代码。例如:</target>
        </trans-unit>
        <trans-unit id="c6da60e4854fba0e9da1ba094a38fc435654e60e" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the end of the region begun by the most recent &quot;=over&quot; command. It permits no text after the &quot;=back&quot; command.</source>
          <target state="translated">该命令表示最近的&quot;=over &quot;命令开始的区域结束。在&quot;=back &quot;命令之后不允许有任何文字。</target>
        </trans-unit>
        <trans-unit id="91bf180a009e30184b54f49645009694bbe3b151" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&quot;About =over...=back Regions&quot;&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">此命令指示这是列表/缩进区域的开始。如果在&amp;ldquo; = over&amp;rdquo;之后有任何文本，则该文本必须仅包含一个非零的正数。该数字的语义在下面的&lt;a href=&quot;#About-%3Dover...%3Dback-Regions&quot;&gt;&amp;ldquo;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。格式代码不会扩展。例子：</target>
        </trans-unit>
        <trans-unit id="19be29c945bbd16c098b73b780bb343e863492ff" translate="yes" xml:space="preserve">
          <source>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;About =over...=back Regions&lt;/a&gt; section, further below. Formatting codes are not expanded. Examples:</source>
          <target state="translated">此命令指示这是列表/缩进区域的开始。如果在&amp;ldquo; = over&amp;rdquo;之后有任何文本，则该文本必须仅包含一个非零的正数。该数字的语义在下面的&amp;ldquo; &lt;a href=&quot;#About-%3dover...%3dback-Regions&quot;&gt;关于= over ... = back区域&amp;rdquo;&lt;/a&gt;部分中进行了说明。格式代码不会扩展。例子：</target>
        </trans-unit>
        <trans-unit id="7ff4d3408bd7bdb5ab335d1f0aa8564e21d93c8d" translate="yes" xml:space="preserve">
          <source>This command indicates that this line is the end of this previously started Pod block. If there is any text after &quot;=cut&quot; on the line, it must be ignored. Examples:</source>
          <target state="translated">这条命令表示这一行是之前启动的这个Pod块的结束。如果该行&quot;=cut &quot;后面有任何文字,必须忽略。例子</target>
        </trans-unit>
        <trans-unit id="3f41d49fdd2a10822f19964c9959582847611ffe" translate="yes" xml:space="preserve">
          <source>This command indicates that this paragraph begins a Pod block. (If we are already in the middle of a Pod block, this command has no effect at all.) If there is any text in this command paragraph after &quot;=pod&quot;, it must be ignored. Examples:</source>
          <target state="translated">这个命令表示这一段开始一个Pod块。如果我们已经在一个Pod块的中间,这条命令就没有任何效果)。如果该命令段中&quot;=pod &quot;之后有任何文字,必须忽略。例子</target>
        </trans-unit>
        <trans-unit id="8a99ea1513aed41e6edc9e12797ae7dfeaac42f6" translate="yes" xml:space="preserve">
          <source>This command is used for declaring the encoding of a document. Most users won't need this; but if your encoding isn't US-ASCII, then put a &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; command very early in the document so that pod formatters will know how to decode the document. For</source>
          <target state="translated">此命令用于声明文档的编码。大多数用户将不需要它。但是，如果您的编码不是US-ASCII，则可以在文档的最前面放置 &lt;code&gt;=encoding &lt;i&gt;encodingname&lt;/i&gt;&lt;/code&gt; 命令，以便Pod格式化程序知道如何解码文档。对于</target>
        </trans-unit>
        <trans-unit id="57e6471f2b7a0cc0bc2732ccfe6cc2a1d67b9a5e" translate="yes" xml:space="preserve">
          <source>This command will fail only if you pass it an address in a domain the server directly delivers for, and that address does not exist.</source>
          <target state="translated">只有当你把服务器直接交付的域名中的地址传给它,并且该地址不存在时,该命令才会失败。</target>
        </trans-unit>
        <trans-unit id="2f65eb1b23b31e9c4fc56a4656f09eda25784a44" translate="yes" xml:space="preserve">
          <source>This command will produce as output a description of the current state of the repository, including modified files and unignored untracked files, and in addition it will show things like what files have been staged for the next commit, and usually some useful information about how to change things. For instance the following:</source>
          <target state="translated">这条命令会输出当前版本库状态的描述,包括修改过的文件和未被忽略的未跟踪文件,此外,它还会显示诸如哪些文件已经被暂存到下一次提交中,以及通常一些关于如何修改的有用信息。比如下面的内容。</target>
        </trans-unit>
        <trans-unit id="cc900c104077e4a6a7ca5f06e5d70661d00910f9" translate="yes" xml:space="preserve">
          <source>This command, which should occur early in the document (at least before any non-US-ASCII data!), declares that this document is encoded in the encoding</source>
          <target state="translated">这条命令应该出现在文档的早期(至少在任何非US-ASCII数据之前!),它声明这个文档是用编码的</target>
        </trans-unit>
        <trans-unit id="a044d113549cfc62bab49938c5d884a6268cf948" translate="yes" xml:space="preserve">
          <source>This commands provides a statistical overview over recent download activities. The data for this is collected in the YAML file &lt;code&gt;FTPstats.yml&lt;/code&gt; in your &lt;code&gt;cpan_home&lt;/code&gt; directory. If no YAML module is configured or YAML not installed, no stats are provided.</source>
          <target state="translated">此命令提供有关最近下载活动的统计概述。此数据收集在 &lt;code&gt;cpan_home&lt;/code&gt; 目录的YAML文件 &lt;code&gt;FTPstats.yml&lt;/code&gt; 中。如果未配置YAML模块或未安装YAML，则不会提供任何统计信息。</target>
        </trans-unit>
        <trans-unit id="8ea20acdc8121360e07a3ca6ca2abb72ed9a4374" translate="yes" xml:space="preserve">
          <source>This compiler backend prints the internal OPs of a Perl program's syntax tree in one of several space-efficient text formats suitable for debugging the inner workings of perl or other compiler backends. It can print OPs in the order they appear in the OP tree, in the order they will execute, or in a text approximation to their tree structure, and the format of the information displayed is customizable. Its function is similar to that of perl's &lt;b&gt;-Dx&lt;/b&gt; debugging flag or the &lt;b&gt;B::Terse&lt;/b&gt; module, but it is more sophisticated and flexible.</source>
          <target state="translated">该编译器后端以适合于调试Perl或其他编译器后端内部工作的几种节省空间的文本格式之一，打印Perl程序语法树的内部OP。它可以按照它们在OP树中出现的顺序，执行顺序或与它们的树结构近似的文本来打印OP，并且所显示信息的格式是可自定义的。它的功能类似于perl的&lt;b&gt;-Dx&lt;/b&gt;调试标志或&lt;b&gt;B :: Terse&lt;/b&gt;模块的功能，但是它更加复杂和灵活。</target>
        </trans-unit>
        <trans-unit id="66cedc315e88b39d6383c0d5ddbb722e7566fdc1" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">该编译器通常由&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;创建的生成文件或&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt;或其他Perl模块生成工具运行。</target>
        </trans-unit>
        <trans-unit id="49048e5c36c04df148e3cdcc3f896c82e8922e40" translate="yes" xml:space="preserve">
          <source>This compiler is typically run by the makefiles created by &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or by &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module::Build&lt;/a&gt; or other Perl module build tools.</source>
          <target state="translated">该编译器通常由&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;创建的makefile 或&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Build&quot;&gt;Module :: Build&lt;/a&gt;或其他Perl模块构建工具运行。</target>
        </trans-unit>
        <trans-unit id="bcbcc146e176c69e94f98d46491b2b165f6959c5" translate="yes" xml:space="preserve">
          <source>This completely resets the incremental parser, that is, after this call, it will be as if the parser had never parsed anything.</source>
          <target state="translated">这将完全重置增量解析器,也就是说,在这个调用之后,将像解析器从未解析过任何东西一样。</target>
        </trans-unit>
        <trans-unit id="811fc2387a18f3ccb2c99535bb74afa37f5a7e14" translate="yes" xml:space="preserve">
          <source>This condition is called a deadlock, and it occurs whenever two or more threads are trying to get locks on resources that the others own. Each thread will block, waiting for the other to release a lock on a resource. That never happens, though, since the thread with the resource is itself waiting for a lock to be released.</source>
          <target state="translated">这种情况称为死锁,每当两个或多个线程试图获得其他线程拥有的资源的锁时,就会发生死锁。每个线程都会阻塞,等待对方释放资源上的锁。不过这种情况永远不会发生,因为拥有资源的线程本身也在等待锁被释放。</target>
        </trans-unit>
        <trans-unit id="faa53aa7f128fff59cd7dcb34623ce5e613b1979" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; , which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; ，这表明编译器支持__builtin_choose_expr（x，y，z）。此内置函数类似于C中的 &lt;code&gt;x?y:z&lt;/code&gt; 运算符，不同之处在于返回的表达式的类型不受升级规则的影响。此外，内置函数不会评估未选择的表达式。</target>
        </trans-unit>
        <trans-unit id="32d20e57f63d06cdf92bb912dada7350665e3c8b" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt;, which indicates that the compiler supports __builtin_choose_expr(x,y,z). This built-in function is analogous to the &lt;code&gt;x?y:z&lt;/code&gt; operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that was not chosen.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_CHOOSE_EXPR&lt;/code&gt; ，这表明编译器支持__builtin_choose_expr（x，y，z）。此内置函数类似于C中的 &lt;code&gt;x?y:z&lt;/code&gt; 运算符，不同之处在于返回的表达式的类型不受升级规则的影响。此外，内置函数不会评估未选择的表达式。</target>
        </trans-unit>
        <trans-unit id="8177d32c94f6808dc1bba5e1e003e2e654d1454a" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; , which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; ，这表明编译器支持__builtin_expect（exp，c）。您可以使用__builtin_expect为编译器提供分支预测信息。</target>
        </trans-unit>
        <trans-unit id="18781d872ee7a71c6a67e62943c1d602bc39dcb9" translate="yes" xml:space="preserve">
          <source>This conditionally defines &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt;, which indicates that the compiler supports __builtin_expect(exp,c). You may use __builtin_expect to provide the compiler with branch prediction information.</source>
          <target state="translated">这有条件地定义了 &lt;code&gt;HAS_BUILTIN_EXPECT&lt;/code&gt; ，这表明编译器支持__builtin_expect（exp，c）。您可以使用__builtin_expect为编译器提供分支预测信息。</target>
        </trans-unit>
        <trans-unit id="3e85ff206a230f535cdc1e1b660d9e31b004675c" translate="yes" xml:space="preserve">
          <source>This construct cannot be used within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier).</source>
          <target state="translated">不能在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （或 &lt;code&gt;/l&lt;/code&gt; regex修饰符）的范围内使用此构造。</target>
        </trans-unit>
        <trans-unit id="7feaf5d14c2affa83679ada3f6337ec8bf394406" translate="yes" xml:space="preserve">
          <source>This construct is a Perl expression.</source>
          <target state="translated">这个构造是一个Perl表达式。</target>
        </trans-unit>
        <trans-unit id="f54050082dcc8b4fbf44ab08f61165f7a87bfb06" translate="yes" xml:space="preserve">
          <source>This construct is a complete Perl statement. (No semicolon should follow the closing brace.)</source>
          <target state="translated">这个结构是一个完整的Perl语句。(结尾括号后面不应该有分号。)</target>
        </trans-unit>
        <trans-unit id="9f08b82a682504266e85cc2574b23244cf7a9af7" translate="yes" xml:space="preserve">
          <source>This construct is non-capturing. You can add parentheses to</source>
          <target state="translated">这个结构是非捕捉性的。您可以在</target>
        </trans-unit>
        <trans-unit id="f8fed69726a17c92a263e748b2d7fa3336a3e37f" translate="yes" xml:space="preserve">
          <source>This construct is useful when you want to capture one of a number of alternative matches.</source>
          <target state="translated">当你想捕捉多个备选匹配中的一个时,这个结构很有用。</target>
        </trans-unit>
        <trans-unit id="89cfaa9b31ac24d949cb1a2ef0db748a527694e4" translate="yes" xml:space="preserve">
          <source>This construction is</source>
          <target state="translated">这种结构是</target>
        </trans-unit>
        <trans-unit id="78c7683a763192abf9645014c7b058753006e735" translate="yes" xml:space="preserve">
          <source>This constructor lets its parent class do the actual object construction.</source>
          <target state="translated">这个构造函数让它的父类进行实际的对象构造。</target>
        </trans-unit>
        <trans-unit id="221e3f3f658bcd2c65eb9bb5043326230edb5f59" translate="yes" xml:space="preserve">
          <source>This constructor returns a new HTTP::Tiny object. Valid attributes include:</source>
          <target state="translated">这个构造函数返回一个新的HTTP::Tiny对象。有效的属性包括</target>
        </trans-unit>
        <trans-unit id="4bf27879428ff426e547cd9ab897b5c2de43f4ae" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">这构造了一个语言句柄。您通常&lt;b&gt;不&lt;/b&gt;直接调用它，而是让 &lt;code&gt;get_handle&lt;/code&gt; 查找要 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 的语言类，然后调用-&amp;gt; new on。</target>
        </trans-unit>
        <trans-unit id="7de3cef882fe04932a0a01ad2c579e42f49a5693" translate="yes" xml:space="preserve">
          <source>This constructs a language handle. You usually &lt;b&gt;don't&lt;/b&gt; call this directly, but instead let &lt;code&gt;get_handle&lt;/code&gt; find a language class to &lt;code&gt;use&lt;/code&gt; and to then call -&amp;gt;new on.</source>
          <target state="translated">这构造了一个语言句柄。您通常&lt;b&gt;不&lt;/b&gt;直接调用它，而是让 &lt;code&gt;get_handle&lt;/code&gt; 查找要 &lt;code&gt;use&lt;/code&gt; 的语言类，然后调用-&amp;gt; new on。</target>
        </trans-unit>
        <trans-unit id="753e5c4d4e4edeead3be592de94817a6410aff17" translate="yes" xml:space="preserve">
          <source>This contains a list of directories, separated by colons. The entire list is prepended to &lt;code&gt;@INC&lt;/code&gt; in one go. This:</source>
          <target state="translated">这包含目录列表，以冒号分隔。整个列表一次性添加到 &lt;code&gt;@INC&lt;/code&gt; 之前。这：</target>
        </trans-unit>
        <trans-unit id="81b45e36338257a29107f2604a1399d771205b40" translate="yes" xml:space="preserve">
          <source>This contains a space separated list of switches. We only consider the effects of &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-I&lt;/code&gt; in this section.</source>
          <target state="translated">这包含用空格分隔的开关列表。在本节中，我们仅考虑 &lt;code&gt;-M&lt;/code&gt; 和 &lt;code&gt;-I&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="a3f30289e8821786015ec39ecff118638d73ac1e" translate="yes" xml:space="preserve">
          <source>This contains a textual description of the field.</source>
          <target state="translated">这包含对该领域的文字描述。</target>
        </trans-unit>
        <trans-unit id="df9999edc7b466975d9df29327a002bca6f3a58f" translate="yes" xml:space="preserve">
          <source>This contains information about the event itself such as the event package name. The &lt;code&gt;details&lt;/code&gt; field for this facet is an overall summary of the event.</source>
          <target state="translated">它包含有关事件本身的信息，例如事件包名称。此方面的 &lt;code&gt;details&lt;/code&gt; 字段是事件的整体摘要。</target>
        </trans-unit>
        <trans-unit id="5e5ca9139234bfdd98010f7db0884779bff191ff" translate="yes" xml:space="preserve">
          <source>This contains the offset from the start of the file in hex.</source>
          <target state="translated">这包含从文件开始的偏移量,以十六进制表示。</target>
        </trans-unit>
        <trans-unit id="3edc7f7dd753392a74ab3c329050e0ec08dcdba9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">这控制了批量转换过程中的详细程度，就STDOUT（或 &lt;code&gt;&lt;a href=&quot;../../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 'd）所做的转换进行了说明。如果为0，则不打印进度信息。如果为1（默认值），则会打印一些进度信息。较高的值将打印更多信息。</target>
        </trans-unit>
        <trans-unit id="e9775b2b0eddb211aedfd45019b3edf6207e64a9" translate="yes" xml:space="preserve">
          <source>This controls how verbose to be during batch conversion, as far as notes to STDOUT (or whatever is &lt;code&gt;select&lt;/code&gt;'d) about how the conversion is going. If 0, no progress information is printed. If 1 (the default value), some progress information is printed. Higher values print more information.</source>
          <target state="translated">这控制了批量转换过程中的详细程度，就STDOUT（或 &lt;code&gt;select&lt;/code&gt; 'd）有关转换进行情况的注释而言。如果为0，则不打印进度信息。如果为1（默认值），则会打印一些进度信息。较高的值将打印更多信息。</target>
        </trans-unit>
        <trans-unit id="ff7a4f63a01fbc1cdd9d161f843ad25c0052f17f" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt; , if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">这控制是否 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 检查是否已弃用双寿命核心模块。如果设置为true &lt;code&gt;check_install&lt;/code&gt; 将返回false， &lt;code&gt;uptodate&lt;/code&gt; ，如果发现双寿命模块从中加载 &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f473e55e3f05fdf8b7207839e3e128669c6830a4" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks if a dual-life core module has been deprecated. If this is set to true &lt;code&gt;check_install&lt;/code&gt; will return false to &lt;code&gt;uptodate&lt;/code&gt;, if a dual-life module is found to be loaded from &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</source>
          <target state="translated">这控制是否 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 检查是否已弃用双寿命核心模块。如果设置为true &lt;code&gt;check_install&lt;/code&gt; 将返回false， &lt;code&gt;uptodate&lt;/code&gt; ，如果发现双寿命模块从中加载 &lt;code&gt;$Config{privlibexp}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b4114328d4769af34ebf3741b18df472503df04" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt; . Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">这控制 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 是否检查您的 &lt;code&gt;%INC&lt;/code&gt; 哈希值以查看模块是否可用。默认情况下，仅扫描 &lt;code&gt;@INC&lt;/code&gt; 来查看模块是否在文件系统上，或者可以通过 &lt;code&gt;@INC-hook&lt;/code&gt; 。将此变量设置为 &lt;code&gt;true&lt;/code&gt; 将信任 &lt;code&gt;%INC&lt;/code&gt; 中的所有条目并为您返回它们。</target>
        </trans-unit>
        <trans-unit id="f4a2bb6249279fc9e40ac723ad2544e4cf6f2b93" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; checks your &lt;code&gt;%INC&lt;/code&gt; hash to see if a module is available. By default, only &lt;code&gt;@INC&lt;/code&gt; is scanned to see if a module is physically on your filesystem, or available via an &lt;code&gt;@INC-hook&lt;/code&gt;. Setting this variable to &lt;code&gt;true&lt;/code&gt; will trust any entries in &lt;code&gt;%INC&lt;/code&gt; and return them for you.</source>
          <target state="translated">这控制 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; 是否检查您的 &lt;code&gt;%INC&lt;/code&gt; 哈希值以查看模块是否可用。默认情况下，仅扫描 &lt;code&gt;@INC&lt;/code&gt; 来查看模块是否在文件系统上，或者可以通过 &lt;code&gt;@INC-hook&lt;/code&gt; 。将此变量设置为 &lt;code&gt;true&lt;/code&gt; 将信任 &lt;code&gt;%INC&lt;/code&gt; 中的所有条目并为您返回它们。</target>
        </trans-unit>
        <trans-unit id="9c3ce0db041dad858d8e24ff2601618761d3793d" translate="yes" xml:space="preserve">
          <source>This controls whether &lt;code&gt;Module::Load::Conditional&lt;/code&gt; sanitises &lt;code&gt;@INC&lt;/code&gt; by removing &quot;&lt;code&gt;.&lt;/code&gt;&quot;. The current default setting is &lt;code&gt;0&lt;/code&gt;, but this may change in a future release.</source>
          <target state="translated">这种控制是否 &lt;code&gt;Module::Load::Conditional&lt;/code&gt; sanitises &lt;code&gt;@INC&lt;/code&gt; 通过删除&amp;ldquo; &amp;rdquo;。当前的默认设置为 &lt;code&gt;0&lt;/code&gt; ，但是在将来的版本中可能会更改。 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4381fad7d89f422c37ccba3ee1b2f92eba8443" translate="yes" xml:space="preserve">
          <source>This controls whether IPC::Cmd will print any output from the commands to the screen or not. The default is 0.</source>
          <target state="translated">此项控制 IPC::Cmd 是否将命令的任何输出打印到屏幕上。默认值为 0。</target>
        </trans-unit>
        <trans-unit id="c156076360b54f8a8977c57dc77de47486be1ac3" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Module::Load::Conditional will not output any warnings. The default is 0;</source>
          <target state="translated">这控制了 Module::Load::Conditional 是否会发出警告和解释,说明某些事情为什么会失败。如果将其设置为 0,则 Module::Load::Conditional 不会输出任何警告。默认值为0。</target>
        </trans-unit>
        <trans-unit id="b49fb12849ceb3c435af21ba21b9e8d24214fd70" translate="yes" xml:space="preserve">
          <source>This controls whether Module::Load::Conditional will try to parse (and eval) the version from the module you're trying to load.</source>
          <target state="translated">这控制了 Module::Load::Conditional 是否会尝试解析(和评估)您正在尝试加载的模块的版本。</target>
        </trans-unit>
        <trans-unit id="d9aae25fb78fe9990ffb44145098a21f55aa720e" translate="yes" xml:space="preserve">
          <source>This controls whether Params::Check will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Params::Check will not output any warnings.</source>
          <target state="translated">这控制了Params::Check是否会发出警告和解释为什么某些事情会失败。如果你把它设置为0,Params::Check将不会输出任何警告。</target>
        </trans-unit>
        <trans-unit id="a6e244d9b4c4b3e3b7164ac6b7f4cae7e7da9c75" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">这控制了命令的所有输出是否也应该打印到STDOUT / STDERR还是仅应困在缓冲区中（注意：缓冲区需要安装&lt;a href=&quot;IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt;或系统能够与&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3一起使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8aa3d4d74657a46a0b2bcece8a25683b9b4d5103" translate="yes" xml:space="preserve">
          <source>This controls whether all output of a command should also be printed to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers require &lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC::Run&lt;/a&gt; to be installed, or your system able to work with &lt;a href=&quot;open3&quot;&gt;IPC::Open3&lt;/a&gt;).</source>
          <target state="translated">这控制了命令的所有输出是否也应该打印到STDOUT / STDERR还是仅应困在缓冲区中（注意：缓冲区需要安装&lt;a href=&quot;http://search.cpan.org/perldoc/IPC::Run&quot;&gt;IPC :: Run&lt;/a&gt;或系统能够与&lt;a href=&quot;open3&quot;&gt;IPC :: Open3一起使用&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="732d2e4b2658c0a2ec91db3c054e26236d0390f1" translate="yes" xml:space="preserve">
          <source>This controls whether imports the functions of a loaded modules to the caller package. The default is no importing any functions.</source>
          <target state="translated">控制是否将加载模块的函数导入到调用包中。默认值是不导入任何函数。</target>
        </trans-unit>
        <trans-unit id="eb78f49655da0a3543996010fb5198aba12c2274" translate="yes" xml:space="preserve">
          <source>This controls whether or not each HTML page is liable to have a little table of contents at the top (which we call an &quot;index&quot; for historical reasons). This is true by default.</source>
          <target state="translated">这控制了每个HTML页面是否会在顶部有一个小目录(由于历史原因,我们称之为 &quot;索引&quot;)。默认情况下,这是真的。</target>
        </trans-unit>
        <trans-unit id="d18f8fcaf7759aa328d11a1f1e92e835b3d9557f" translate="yes" xml:space="preserve">
          <source>This controls whether warnings should be printed if a module failed to load. The default is to use the value of $Module::Load::Conditional::VERBOSE.</source>
          <target state="translated">控制是否在模块加载失败时打印警告。默认值是使用$Module::Load::Conditional::VERBOSE。</target>
        </trans-unit>
        <trans-unit id="4ff7f0c70685518180af334112b2fe58a44a4fdd" translate="yes" xml:space="preserve">
          <source>This copyright does not prohibit distribution of any version of Perl containing this extension under the terms of the GNU or Artistic licenses.</source>
          <target state="translated">此版权不禁止在GNU或艺术许可证的条款下发布包含此扩展的任何Perl版本。</target>
        </trans-unit>
        <trans-unit id="e07ca9a36ef5f49f5e95795b2568b38574fd37e2" translate="yes" xml:space="preserve">
          <source>This corresponds to clearerr(), i.e., clears 'error' and (usually) 'eof' flags for the &quot;stream&quot;. Does not return a value.</source>
          <target state="translated">这与clearerr()相对应,即清除 &quot;流 &quot;的'error'和(通常)'eof'标志。不返回一个值。</target>
        </trans-unit>
        <trans-unit id="a832f3c37512b00bc489449027088839617ff5af" translate="yes" xml:space="preserve">
          <source>This corresponds to feof(). Returns a true/false indication of whether the handle is at end of file. For terminal devices this may or may not be &quot;sticky&quot; depending on the implementation. The flag is cleared by PerlIO_seek(), or PerlIO_rewind().</source>
          <target state="translated">这与feof()相对应。返回句柄是否在文件末尾的真/假指示。对于终端设备来说,这可能是或不是 &quot;粘性 &quot;的,这取决于实现。这个标志会被PerlIO_seek()或PerlIO_rewind()清除。</target>
        </trans-unit>
        <trans-unit id="baeb66e5af4f3d77be2f1ed10348f03a4ed016a5" translate="yes" xml:space="preserve">
          <source>This corresponds to ferror(). Returns a true/false indication of whether there has been an IO error on the handle.</source>
          <target state="translated">这与ferror()相对应。返回句柄上是否存在IO错误的真/假指示。</target>
        </trans-unit>
        <trans-unit id="bb12a0ca3665432e7ae210e2f30b098e3c60f423" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt; , and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">这对应于fflush（）。将所有缓冲的写数据发送到基础文件。如果使用 &lt;code&gt;NULL&lt;/code&gt; 调用，则可能会刷新所有打开的流（或使用某些USE_STDIO实现的核心转储）。调用为只读而打开的句柄，或对其进行最后一次操作的某种类型的读取，可能会导致某些USE_STDIO实现上的未定义行为。 USE_PERLIO（层）实现尝试表现得更好：在传递 &lt;code&gt;NULL&lt;/code&gt; 时，它将刷新所有打开的流，并尝试通过缓冲区或通过查找当前逻辑位置的句柄来保留读取流上的数据。</target>
        </trans-unit>
        <trans-unit id="4d9dcb6de62439562f514cb79a1863a8cc7b8b20" translate="yes" xml:space="preserve">
          <source>This corresponds to fflush(). Sends any buffered write data to the underlying file. If called with &lt;code&gt;NULL&lt;/code&gt; this may flush all open streams (or core dump with some USE_STDIO implementations). Calling on a handle open for read only, or on which last operation was a read of some kind may lead to undefined behaviour on some USE_STDIO implementations. The USE_PERLIO (layers) implementation tries to behave better: it flushes all open streams when passed &lt;code&gt;NULL&lt;/code&gt;, and attempts to retain data on read streams either in the buffer or by seeking the handle to the current logical position.</source>
          <target state="translated">这对应于fflush（）。将所有缓冲的写数据发送到基础文件。如果使用 &lt;code&gt;NULL&lt;/code&gt; 调用，则可能会刷新所有打开的流（或使用某些USE_STDIO实现的核心转储）。调用打开为只读的句柄，或对其进行最后一次操作的某种读取，可能会导致某些USE_STDIO实现上的未定义行为。 USE_PERLIO（层）实现尝试表现得更好：在传递 &lt;code&gt;NULL&lt;/code&gt; 时，它将刷新所有打开的流，并尝试在缓冲区中或通过查找当前逻辑位置的句柄来保留读取流上的数据。</target>
        </trans-unit>
        <trans-unit id="9e414890b7f22b1b4083f4007de6555d9d071db1" translate="yes" xml:space="preserve">
          <source>This corresponds to fileno(), note that on some platforms, the meaning of &quot;fileno&quot; may not match Unix. Returns -1 if the handle has no open descriptor associated with it.</source>
          <target state="translated">这与fileno()相对应,注意在某些平台上,&quot;fileno &quot;的含义可能与Unix不一致。如果句柄没有与之相关联的开放描述符,则返回-1。</target>
        </trans-unit>
        <trans-unit id="5f4554adde4cea2591eaa99c7438bd7a745a0b3f" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">这对应于fseek（）。将缓冲的写数据发送到基础文件，或丢弃所有缓冲的读数据，然后按&lt;b&gt;offset&lt;/b&gt;和&lt;b&gt;whence&lt;/b&gt;（sic）指定的位置&lt;b&gt;放置&lt;/b&gt;文件描述符。当在同一句柄上进行读写之间切换时，这是正确的做法（请参见上面的PerlIO_flush（）问题）。偏移量为 &lt;code&gt;Off_t&lt;/code&gt; 类型，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="9bd7cfe67b5d59fef2229cadd453ea0901b8f7eb" translate="yes" xml:space="preserve">
          <source>This corresponds to fseek(). Sends buffered write data to the underlying file, or discards any buffered read data, then positions the file descriptor as specified by &lt;b&gt;offset&lt;/b&gt; and &lt;b&gt;whence&lt;/b&gt; (sic). This is the correct thing to do when switching between read and write on the same handle (see issues with PerlIO_flush() above). Offset is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt;.</source>
          <target state="translated">这对应于fseek（）。将缓冲的写数据发送到基础文件，或丢弃所有缓冲的读数据，然后按&lt;b&gt;offset&lt;/b&gt;和&lt;b&gt;whence&lt;/b&gt;（sic）指定的位置&lt;b&gt;放置&lt;/b&gt;文件描述符。在同一句柄上的读写之间进行切换时，这是正确的做法（请参见上面的PerlIO_flush（）问题）。偏移量为 &lt;code&gt;Off_t&lt;/code&gt; 类型，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="dd9bee6b04c387fd0085a9f7aa8ff48a5f034283" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt; .</source>
          <target state="translated">这对应于ftell（）。返回当前文件位置，如果出错则返回（Off_t）-1。可能只是返回值系统&amp;ldquo;知道&amp;rdquo;而没有进行系统调用或检查基础文件描述符（因此，在没有PerlIO_seek（）的情况下，在共享文件描述符上使用是不安全的）。返回值的类型为 &lt;code&gt;Off_t&lt;/code&gt; ，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="7e3cecdb4fa297b5ce6bf2a831e2cb59bd3601f2" translate="yes" xml:space="preserve">
          <source>This corresponds to ftell(). Returns the current file position, or (Off_t) -1 on error. May just return value system &quot;knows&quot; without making a system call or checking the underlying file descriptor (so use on shared file descriptors is not safe without a PerlIO_seek()). Return value is of type &lt;code&gt;Off_t&lt;/code&gt; which is a perl Configure value which may not be same as stdio's &lt;code&gt;off_t&lt;/code&gt;.</source>
          <target state="translated">这对应于ftell（）。返回当前文件位置，或在错误时返回（Off_t）-1。可能只是返回值系统&amp;ldquo;知道&amp;rdquo;而没有进行系统调用或检查基础文件描述符（因此，如果没有PerlIO_seek（），在共享文件描述符上使用是不安全的）。返回值的类型为 &lt;code&gt;Off_t&lt;/code&gt; ，这是一个Perl配置值，可能与stdio的 &lt;code&gt;off_t&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="a3583e8644f865d149cd4eb31d670f437a6e26eb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error.</source>
          <target state="translated">这对应于getc（）。尽管名称中为c，但仅支持字节范围0..0xFF。返回读取的字符或错误时返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="95c0f809b22c7c0dae9af22f03c13f59aaa59bfb" translate="yes" xml:space="preserve">
          <source>This corresponds to getc(). Despite the c in the name only byte range 0..0xFF is supported. Returns the character read or -1 (&lt;code&gt;EOF&lt;/code&gt;) on error.</source>
          <target state="translated">这对应于getc（）。尽管名称中为c，但仅支持字节范围0..0xFF。返回读取的字符或错误时返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e1cbd65b62177115f422eaf8fe4754328fbc6b9b" translate="yes" xml:space="preserve">
          <source>This corresponds to rewind(). It is usually defined as being</source>
          <target state="translated">这与rewind()相对应。它通常被定义为</target>
        </trans-unit>
        <trans-unit id="93c7ee35566034261e1234fcee65abc1e334abb8" translate="yes" xml:space="preserve">
          <source>This corresponds to setlinebuf(). Does not return a value. What constitutes a &quot;line&quot; is implementation dependent but usually means that writing &quot;\n&quot; flushes the buffer. What happens with things like &quot;this\nthat&quot; is uncertain. (Perl core uses it</source>
          <target state="translated">这与setlinebuf()相对应。不返回一个值。什么是 &quot;行&quot;,取决于实现,但通常意味着写&quot;\n &quot;会刷新缓冲区。像 &quot;this/nthat &quot;这样的东西会发生什么是不确定的。(Perl核心使用它</target>
        </trans-unit>
        <trans-unit id="c130282a86007cfef5f589b0d598e97fc7e10899" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">这对应于tmpfile（），即在错误时返回匿名PerlIO或NULL。关闭后，系统将尝试自动删除文件。在Unix上，文件通常在创建后立即 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 因此它的关闭方式无关紧要。在其他系统上，只有通过PerlIO_close（）关闭文件和/或通过 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 退出程序时，才可以删除文件。取决于实现方式，可能存在&amp;ldquo;竞争条件&amp;rdquo;，该条件允许其他进程访问文件，尽管通常在这方面比广告更安全。临时计划。</target>
        </trans-unit>
        <trans-unit id="0510a97fbd4cfa5a066aad9bda9c89da0469e9d9" translate="yes" xml:space="preserve">
          <source>This corresponds to tmpfile(), i.e., returns an anonymous PerlIO or NULL on error. The system will attempt to automatically delete the file when closed. On Unix the file is usually &lt;code&gt;unlink&lt;/code&gt;-ed just after it is created so it does not matter how it gets closed. On other systems the file may only be deleted if closed via PerlIO_close() and/or the program exits via &lt;code&gt;exit&lt;/code&gt;. Depending on the implementation there may be &quot;race conditions&quot; which allow other processes access to the file, though in general it will be safer in this regard than ad. hoc. schemes.</source>
          <target state="translated">这对应于tmpfile（），即在发生错误时返回匿名PerlIO或NULL。关闭后，系统将尝试自动删除文件。在Unix上，文件通常在创建后立即 &lt;code&gt;unlink&lt;/code&gt; 因此它的关闭方式无关紧要。在其他系统上，只有通过PerlIO_close（）关闭文件和/或通过 &lt;code&gt;exit&lt;/code&gt; 退出程序时，才可以删除文件。取决于实现方式，可能存在允许其他进程访问文件的&amp;ldquo;竞争条件&amp;rdquo;，尽管通常在这方面比广告更安全。临时计划。</target>
        </trans-unit>
        <trans-unit id="327b626f972edcc8578bc2302697191125c0290f" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt; ) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">这对应于ungetc（）。请注意，参数已修改为首先具有&amp;ldquo;文件&amp;rdquo;。安排下一次读取操作将返回字节&lt;b&gt;c&lt;/b&gt;。尽管名称中暗含了&amp;ldquo;字符&amp;rdquo;，但仅定义了0..0xFF范围内的值。成功返回字节&lt;b&gt;c&lt;/b&gt;，错误返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。可以&amp;ldquo;回退&amp;rdquo;的字节数可能会有所不同，只有1个字符是确定的，然后才是从句柄中读取的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="c9249d1b24ff827efbf0b09c581b3316583a595e" translate="yes" xml:space="preserve">
          <source>This corresponds to ungetc(). Note that arguments have been revised to have &quot;file&quot; first. Arranges that next read operation will return the byte &lt;b&gt;c&lt;/b&gt;. Despite the implied &quot;character&quot; in the name only values in the range 0..0xFF are defined. Returns the byte &lt;b&gt;c&lt;/b&gt; on success or -1 (&lt;code&gt;EOF&lt;/code&gt;) on error. The number of bytes that can be &quot;pushed back&quot; may vary, only 1 character is certain, and then only if it is the last character that was read from the handle.</source>
          <target state="translated">这对应于ungetc（）。请注意，参数已修改为首先具有&amp;ldquo;文件&amp;rdquo;。安排下一次读取操作将返回字节&lt;b&gt;c&lt;/b&gt;。尽管名称中隐含了&amp;ldquo;字符&amp;rdquo;，但仅定义了0..0xFF范围内的值。如果成功，则返回字节&lt;b&gt;c&lt;/b&gt;；如果错误，则返回-1（ &lt;code&gt;EOF&lt;/code&gt; ）。可以&amp;ldquo;回退&amp;rdquo;的字节数可能会有所不同，只有1个字符是确定的，然后才是从句柄中读取的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="d8f57342ffddc378f45e967d08a4b40a9028441d" translate="yes" xml:space="preserve">
          <source>This could, of course, be more legibly written with the &lt;code&gt;/x&lt;/code&gt; modifier, adding whitespace and comments. Here it is expanded, courtesy of Fred Curtis.</source>
          <target state="translated">当然，可以使用 &lt;code&gt;/x&lt;/code&gt; 修饰符，添加空格和注释，使其更清晰易读。此处由Fred Curtis进行了扩展。</target>
        </trans-unit>
        <trans-unit id="ac65bf824b65194ff0a99fd92e3e036111f8e8a9" translate="yes" xml:space="preserve">
          <source>This counterintuitive behavior has been fixed in perl v5.8.1.</source>
          <target state="translated">这个反直觉的行为在perl v5.8.1中得到了修正。</target>
        </trans-unit>
        <trans-unit id="ee88470233c1da8717b5bd9acaba39e40089d0b6" translate="yes" xml:space="preserve">
          <source>This creates a &lt;code&gt;VMS::DCLsym&lt;/code&gt; object which can be used as a handle for later method calls. The single optional argument specifies the symbol table used by default in future method calls, in the same way as the optional argument to &lt;code&gt;tie&lt;/code&gt; described above.</source>
          <target state="translated">这将创建一个 &lt;code&gt;VMS::DCLsym&lt;/code&gt; 对象，该对象可用作以后方法调用的句柄。单个可选参数指定在将来的方法调用中默认使用的符号表，其方式与上述要 &lt;code&gt;tie&lt;/code&gt; 的可选参数相同。</target>
        </trans-unit>
        <trans-unit id="1645aaa3f3c32e20d8c02b43f04eac07a2fcc5a3" translate="yes" xml:space="preserve">
          <source>This creates a CPAN::Meta::Merge object. It takes one mandatory named argument, &lt;code&gt;version&lt;/code&gt;, declaring the version of the meta-spec that must be used for the merge. It can optionally take an &lt;code&gt;extra_mappings&lt;/code&gt; argument that allows one to add additional merging functions for specific elements.</source>
          <target state="translated">这将创建一个CPAN :: Meta :: Merge对象。它带有一个强制性的命名参数 &lt;code&gt;version&lt;/code&gt; ，用于声明必须用于合并的meta-spec的版本。它可以选择采用 &lt;code&gt;extra_mappings&lt;/code&gt; 参数，该参数允许为特定元素添加其他合并功能。</target>
        </trans-unit>
        <trans-unit id="4d26884badcfad89a2f88ee752f4bee54862ec7a" translate="yes" xml:space="preserve">
          <source>This creates a handler for the attribute &lt;code&gt;:Loud&lt;/code&gt; in the class LoudDecl. Thereafter, any subroutine declared with a &lt;code&gt;:Loud&lt;/code&gt; attribute in the class LoudDecl:</source>
          <target state="translated">这将为类LoudDecl中的 &lt;code&gt;:Loud&lt;/code&gt; 属性创建一个处理程序。此后，在类LoudDecl中使用 &lt;code&gt;:Loud&lt;/code&gt; 属性声明的任何子例程：</target>
        </trans-unit>
        <trans-unit id="8263a46fdb04b7977692de514f9404e4c18b81b5" translate="yes" xml:space="preserve">
          <source>This creates a local branch named &lt;code&gt;maint-5.005&lt;/code&gt;, which tracks the remote branch &lt;code&gt;origin/maint-5.005&lt;/code&gt;. Then you can pull, commit, merge and push as before.</source>
          <target state="translated">这将创建一个名为 &lt;code&gt;maint-5.005&lt;/code&gt; 的本地分支，该分支将跟踪远程分支 &lt;code&gt;origin/maint-5.005&lt;/code&gt; 。然后，您可以像以前一样拉，提交，合并和推动。</target>
        </trans-unit>
        <trans-unit id="9bc82066bd7f21b4bcc5fd329fc91ce1111d9d09" translate="yes" xml:space="preserve">
          <source>This creates a new batch converter. The method doesn't take parameters. To change the converter's attributes, use the &quot;ACCESSOR METHODS&quot;&quot; in &quot; below.</source>
          <target state="translated">这将创建一个新的批量转换器。该方法不接受参数。要改变转换器的属性,请使用下面的 &quot;附件方法&quot;&quot;。</target>
        </trans-unit>
        <trans-unit id="87fa03371108789e3d1ff265f81c30f8fb7e2b16" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt; ) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt; ). This is shorthand for the following:</source>
          <target state="translated">这将创建一个新线程（ &lt;code&gt;$thr2&lt;/code&gt; ），该线程继承现有线程（ &lt;code&gt;$thr1&lt;/code&gt; ）的堆栈大小。这是以下各项的简写：</target>
        </trans-unit>
        <trans-unit id="47788aa7839e22479a971854bcf1abe7b0acfb25" translate="yes" xml:space="preserve">
          <source>This creates a new thread (&lt;code&gt;$thr2&lt;/code&gt;) that inherits the stack size from an existing thread (&lt;code&gt;$thr1&lt;/code&gt;). This is shorthand for the following:</source>
          <target state="translated">这将创建一个新线程（ &lt;code&gt;$thr2&lt;/code&gt; ），该线程继承现有线程（ &lt;code&gt;$thr1&lt;/code&gt; ）的堆栈大小。这是以下内容的简写：</target>
        </trans-unit>
        <trans-unit id="c13be50d55b544b4c8283f535832e9b6392a885b" translate="yes" xml:space="preserve">
          <source>This creates a working sysroot that we can feed to Configure later.</source>
          <target state="translated">这就创建了一个工作的sysroot,我们可以在以后将其反馈给Configure。</target>
        </trans-unit>
        <trans-unit id="0d5e9ac144b79f7c4865c5f4daf815fdb24b2e3d" translate="yes" xml:space="preserve">
          <source>This currently means that all code points in the sequence have been assigned by Unicode to be characters that aren't private use nor surrogate code points.</source>
          <target state="translated">目前这意味着序列中的所有码点都被Unicode指定为不是私人使用也不是代用码点的字符。</target>
        </trans-unit>
        <trans-unit id="0ee76e6a741e92139c43f1e221ed11b509991786" translate="yes" xml:space="preserve">
          <source>This database type allows arbitrary key/value pairs to be stored in data files. This is equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files created using DB_HASH are not compatible with any of the other packages mentioned.</source>
          <target state="translated">这种数据库类型允许在数据文件中存储任意的键/值对。这相当于其他哈希包提供的功能,如DBM、NDBM、ODBM、GDBM和SDBM。但请记住,使用DB_HASH创建的文件与上述任何其他包都不兼容。</target>
        </trans-unit>
        <trans-unit id="3807b81d9c773a6c5335f9e71e920114a654bcff" translate="yes" xml:space="preserve">
          <source>This debugger prints a number which increments for each statement encountered and waits for you to hit a newline before continuing to the next statement.</source>
          <target state="translated">这个调试器会打印一个数字,每遇到一条语句都会递增,并等待你打一个新行后再继续下一条语句。</target>
        </trans-unit>
        <trans-unit id="67c09da3f20ea7878643178c10aa0a6e33cc924b" translate="yes" xml:space="preserve">
          <source>This declares a block of tests that might be skipped, $how_many tests there are, $why and under what $condition to skip them. An example is the easiest way to illustrate:</source>
          <target state="translated">这声明了一个可能被跳过的测试块,$how_many测试,$why以及在什么条件下$跳过它们。一个例子是最简单的说明方式。</target>
        </trans-unit>
        <trans-unit id="9e3fa8a7f8cc69e16dc88141cf1567bb93e3d7ad" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">该分解可以是中间分解，其组分也可分解。使用&lt;a href=&quot;Unicode::Normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;一步一步就能得到最终的分解结果。</target>
        </trans-unit>
        <trans-unit id="44521e30f7e690cd5dc65c30814c4cee699cd60e" translate="yes" xml:space="preserve">
          <source>This decomposition may be an intermediate one whose components are also decomposable. Use &lt;a href=&quot;normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; to get the final decomposition in one step.</source>
          <target state="translated">该分解可以是中间分解，其组分也可分解。使用&lt;a href=&quot;normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;一步完成最终分解。</target>
        </trans-unit>
        <trans-unit id="97bd528541645ff3d464e572f5a4805e2ee9bc4c" translate="yes" xml:space="preserve">
          <source>This default can be overridden on a per-number basis by calling the &lt;code&gt;display_format&lt;/code&gt; method instead. As before, not supplying any argument returns the current display style for this number. Otherwise whatever you specify will be the new display style for</source>
          <target state="translated">可以通过调用 &lt;code&gt;display_format&lt;/code&gt; 方法来逐个覆盖此默认值。和以前一样，不提供任何参数将返回此数字的当前显示样式。否则，您指定的任何内容都将是的新显示样式</target>
        </trans-unit>
        <trans-unit id="b13fed4037708b058149d6d54239c3578805f852" translate="yes" xml:space="preserve">
          <source>This demonstrates how &lt;code&gt;SUPER&lt;/code&gt; is resolved. Even though the object is blessed into the &lt;code&gt;C&lt;/code&gt; class, the &lt;code&gt;speak()&lt;/code&gt; method in the &lt;code&gt;B&lt;/code&gt; class can still call &lt;code&gt;SUPER::speak()&lt;/code&gt; and expect it to correctly look in the parent class of &lt;code&gt;B&lt;/code&gt; (i.e the class the method call is in), not in the parent class of &lt;code&gt;C&lt;/code&gt; (i.e. the class the object belongs to).</source>
          <target state="translated">这说明了如何解决 &lt;code&gt;SUPER&lt;/code&gt; 。即使对象被祝福到 &lt;code&gt;C&lt;/code&gt; 类中， &lt;code&gt;B&lt;/code&gt; 类中的 &lt;code&gt;speak()&lt;/code&gt; 方法仍然可以调用 &lt;code&gt;SUPER::speak()&lt;/code&gt; 并期望它正确地查看 &lt;code&gt;B&lt;/code&gt; 的父类（即该方法调用所在的类） ），而不是在 &lt;code&gt;C&lt;/code&gt; 的父类（即对象所属的类）中。</target>
        </trans-unit>
        <trans-unit id="5a18b47e8bc86d748a4aab67a43edef686b92a3f" translate="yes" xml:space="preserve">
          <source>This depends on the tied hash's implementation of EXISTS(). For example, there isn't the concept of undef with hashes that are tied to DBM* files. It also means that exists() and defined() do the same thing with a DBM* file, and what they end up doing is not what they do with ordinary hashes.</source>
          <target state="translated">这取决于绑定的哈希对 EXISTS()的实现。例如,与DBM*文件绑定的哈希就没有undef的概念。这也就意味着,exist()和defined()对DBM*文件做的事情是一样的,它们最终做的事情和对普通哈希做的事情是不一样的。</target>
        </trans-unit>
        <trans-unit id="9d4bc0de5af18f612ccd2a5cae826c99487fcbf8" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt; ; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">这取决于您的程序在哪个操作系统上运行。对于Unix，可以通过 &lt;code&gt;/dev&lt;/code&gt; 中的文件访问串行端口。在其他系统上，设备名称无疑会有所不同。以下是所有设备交互所共有的几个问题区域：</target>
        </trans-unit>
        <trans-unit id="03ee5b714e2ad9827ab9f706d0156780edac87fe" translate="yes" xml:space="preserve">
          <source>This depends on which operating system your program is running on. In the case of Unix, the serial ports will be accessible through files in &lt;code&gt;/dev&lt;/code&gt;; on other systems, device names will doubtless differ. Several problem areas common to all device interaction are the following:</source>
          <target state="translated">这取决于您的程序在哪个操作系统上运行。对于Unix，可以通过 &lt;code&gt;/dev&lt;/code&gt; 中的文件访问串行端口。在其他系统上，设备名称无疑会有所不同。以下是所有设备交互所共有的几个问题区域：</target>
        </trans-unit>
        <trans-unit id="5becff50f569cb27ece95ac48841bd7838bbbdf8" translate="yes" xml:space="preserve">
          <source>This describes all packages provided by this distribution. This information is used by distribution and automation mechanisms like PAUSE, CPAN, metacpan.org and search.cpan.org to build indexes saying in which distribution various packages can be found.</source>
          <target state="translated">这描述了这个发行版所提供的所有软件包。这些信息被发行版和自动化机制(如 PAUSE、CPAN、metacpan.org 和 search.cpan.org)用来建立索引,说明在哪个发行版中可以找到各种软件包。</target>
        </trans-unit>
        <trans-unit id="a20078d60a6a97424e04254a5fa4e6e526ad17dd" translate="yes" xml:space="preserve">
          <source>This describes the namespace layout for the Test2 ecosystem. Not all the namespaces listed here are part of the Test2 distribution, some are implemented in &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">这描述了Test2生态系统的名称空间布局。并非此处列出的所有名称空间都是Test2发行版的一部分，有些是在&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;中实现的。</target>
        </trans-unit>
        <trans-unit id="d5829cc9fcaba21dee6f9d7f5a98f9ac945f1487" translate="yes" xml:space="preserve">
          <source>This description is not updated often (since 5.6.1?), see</source>
          <target state="translated">这个描述不经常更新(自5.6.1?</target>
        </trans-unit>
        <trans-unit id="d6d22f28f156ae5e9b48e8de5b3d3fde4d59d03e" translate="yes" xml:space="preserve">
          <source>This differs slightly from the &lt;code&gt;accept&lt;/code&gt; function in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">这与&lt;a href=&quot;perlfunc&quot;&gt;perlfunc中&lt;/a&gt;的 &lt;code&gt;accept&lt;/code&gt; 函数略有不同。</target>
        </trans-unit>
        <trans-unit id="20322d80a32c4020d9ededc57d341d0284daf471" translate="yes" xml:space="preserve">
          <source>This directive is supported with ANSI-type function declarations only.</source>
          <target state="translated">该指令仅支持ANSI类型的函数声明。</target>
        </trans-unit>
        <trans-unit id="0bdb96acaa7aac7424045042159548f85c9ab53b" translate="yes" xml:space="preserve">
          <source>This directly modifies the stored filehandles, it does not create new ones.</source>
          <target state="translated">这将直接修改存储的文件柄,而不是创建新的文件柄。</target>
        </trans-unit>
        <trans-unit id="a18a04a1fb981c46cc90618271edcb18e99ed305" translate="yes" xml:space="preserve">
          <source>This directory contains dual-life modules where the CPAN module is canonical. Do not patch these modules directly! Changes to these modules should be submitted to the maintainer of the CPAN module. Once those changes are applied and released, the new version of the module will be incorporated into the core.</source>
          <target state="translated">本目录包含双生模块,其中CPAN模块是规范的。不要直接给这些模块打补丁! 对这些模块的修改应该提交给CPAN模块的维护者。一旦这些更改被应用并发布,新版本的模块将被纳入核心。</target>
        </trans-unit>
        <trans-unit id="8f5f151207fd145f47cd0f164782d7d714aa8988" translate="yes" xml:space="preserve">
          <source>This directory contains pure-Perl modules which are only released as part of the core. This directory contains</source>
          <target state="translated">本目录包含纯Perl模块,这些模块只作为核心的一部分发布。本目录包含</target>
        </trans-unit>
        <trans-unit id="ff88cb5fa00bc50f7151a1d4596e477618c8bcec" translate="yes" xml:space="preserve">
          <source>This directory is for dual-life modules where the blead source is canonical. Note that some modules in this directory may not yet have been released separately on CPAN. Modules under</source>
          <target state="translated">本目录是为双生模块提供的,其中blead源是规范的。请注意,这个目录中的一些模块可能还没有在CPAN上单独发布。在此目录下的模块</target>
        </trans-unit>
        <trans-unit id="62002fdbbc82dfdecab897397921252b1a422691" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt; .</source>
          <target state="translated">该目录最好放在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="53f8085abd01c50ea807b424c7fb70d06b9d9336" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;BOOKSHELF&lt;/code&gt;.</source>
          <target state="translated">该目录最好放在 &lt;code&gt;BOOKSHELF&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="333fd828a086a8d956340a5925aba972db5faa95" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。你需要工作</target>
        </trans-unit>
        <trans-unit id="7a7d8abb15dd5ddcab335f051e15e631ee76c9a7" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt; . You need to have a working man to access these files.</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。您需要一个工作人员来访问这些文件。</target>
        </trans-unit>
        <trans-unit id="3bfbc8178767aed118a078c916238d08187f8c32" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt;. You need to have a working</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。你需要工作</target>
        </trans-unit>
        <trans-unit id="7f768384fb45192f416d43b226b88f4f7ac434db" translate="yes" xml:space="preserve">
          <source>This directory should better be on &lt;code&gt;MANPATH&lt;/code&gt;. You need to have a working man to access these files.</source>
          <target state="translated">该目录最好放在 &lt;code&gt;MANPATH&lt;/code&gt; 上。您需要一个工作人员来访问这些文件。</target>
        </trans-unit>
        <trans-unit id="efd449ffe16a462d28e76469ef21ea9f7d571513" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&quot;Magic Autogeneration&quot;&lt;/a&gt;.</source>
          <target state="translated">这将禁用&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;&amp;ldquo;魔术自动生成&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="170ad9fea04adcf28e5b84faabd5cf2954a187d9" translate="yes" xml:space="preserve">
          <source>This disables &lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;.</source>
          <target state="translated">这将禁用&lt;a href=&quot;#Magic-Autogeneration&quot;&gt;Magic Autogeneration&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b3a0993d47177782fe70afdd82bfb741c3d7395" translate="yes" xml:space="preserve">
          <source>This disables the poetry optimization, generating a compile-time error if you try to use a bareword identifier that's not a subroutine, unless it is a simple identifier (no colons) and that it appears in curly braces or on the left hand side of the &lt;code&gt;=&amp;gt;&lt;/code&gt; symbol.</source>
          <target state="translated">如果您尝试使用不是子例程的裸字标识符，除非它是一个简单的标识符（无冒号）并且出现在花括号或左手大括号中，否则这会禁用诗歌优化，并产生编译时错误。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 符号。</target>
        </trans-unit>
        <trans-unit id="bbfb3ce32af84903cf3730d9cf51595fc0554060" translate="yes" xml:space="preserve">
          <source>This distribution directly accesses the hash keys in the &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; singleton. It also approaches the problem from the wrong angle, please consider using &lt;a href=&quot;Test2::Aggregate&quot;&gt;Test2::Aggregate&lt;/a&gt; for similar functionality and &lt;a href=&quot;Test2::Harness&quot;&gt;Test2::Harness&lt;/a&gt; which allows module preloading at the harness level.</source>
          <target state="translated">该分布直接访问&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;单例中的哈希键。它还从错误的角度解决了该问题，请考虑使用&lt;a href=&quot;Test2::Aggregate&quot;&gt;Test2 :: Aggregate&lt;/a&gt;来实现类似的功能，并考虑使用&lt;a href=&quot;Test2::Harness&quot;&gt;Test2 :: Harness&lt;/a&gt;来允许在线束级别进行模块预加载。</target>
        </trans-unit>
        <trans-unit id="a5b7ba8215c0f4757732a3f14c729963fc274aea" translate="yes" xml:space="preserve">
          <source>This doc</source>
          <target state="translated">本文件</target>
        </trans-unit>
        <trans-unit id="34ff219b627159fe6cfa93920427dc7e601e7134" translate="yes" xml:space="preserve">
          <source>This document aims to provide an overview of the vast perl community, which is far too large and diverse to provide a detailed listing. If any specific niche has been forgotten, it is not meant as an insult but an omission for the sake of brevity.</source>
          <target state="translated">本文档旨在为广大的perl社区提供一个概述,这个社区太过庞大和多样化,无法提供一个详细的列表。如果忘记了任何特定的利基,这并不是一种侮辱,而是为了简洁起见而省略的。</target>
        </trans-unit>
        <trans-unit id="1ba7340d966579fbb753302864000cf7b2972014" translate="yes" xml:space="preserve">
          <source>This document assumes that the executable named &quot;perl&quot; is Perl version 5. Some systems may have installed Perl version 5 as &quot;perl5&quot;.</source>
          <target state="translated">本文档假设名为 &quot;perl &quot;的可执行文件是Perl 5版本。有些系统可能将Perl 5版安装为 &quot;perl5&quot;。</target>
        </trans-unit>
        <trans-unit id="3a2742d9b73b97368bfc5521e9515184f408ef85" translate="yes" xml:space="preserve">
          <source>This document assumes that you already understand the basics of Perl syntax, variable types, operators, and subroutine calls. If you don't understand these concepts yet, please read &lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt; first. You should also read the &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;, &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;, and &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; documents.</source>
          <target state="translated">本文档假定您已经了解Perl语法，变量类型，运算符和子例程调用的基础知识。如果您还不了解这些概念，请先阅读&lt;a href=&quot;perlintro&quot;&gt;perlintro&lt;/a&gt;。您还应该阅读&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;，&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;和&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="8f596bd16fedee538f262d0de64e96d996439fb3" translate="yes" xml:space="preserve">
          <source>This document attempts to describe how to use the Perl API, as well as to provide some info on the basic workings of the Perl core. It is far from complete and probably contains many errors. Please refer any questions or comments to the author below.</source>
          <target state="translated">这篇文档试图描述如何使用Perl API,以及提供一些关于Perl核心的基本工作原理的信息。它远非完整,可能包含许多错误。如果有任何问题或意见,请向下面的作者提出。</target>
        </trans-unit>
        <trans-unit id="7e01fbc0bc773f9d24734cb30bab33bda7d5f6af" translate="yes" xml:space="preserve">
          <source>This document attempts to describe the Perl Community's &quot;best practice&quot; for writing Perl modules. It extends the recommendations found in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt; , which should be considered required reading before reading this document.</source>
          <target state="translated">本文档试图描述Perl社区编写Perl模块的&amp;ldquo;最佳实践&amp;rdquo;。它扩展了&lt;a href=&quot;perlstyle&quot;&gt;perlstyle中&lt;/a&gt;的建议，在阅读本文档之前，应将其视为必读内容。</target>
        </trans-unit>
        <trans-unit id="bab11f45369409b96d7bf2180484dc0f685d2683" translate="yes" xml:space="preserve">
          <source>This document briefly describes Perl under Mac OS X.</source>
          <target state="translated">本文档简要介绍了Mac OS X下的Perl。</target>
        </trans-unit>
        <trans-unit id="083d82552ef9adb2b16dbbdc73ee6cb2d3adb7be" translate="yes" xml:space="preserve">
          <source>This document codifies the support and maintenance commitments that the Perl community should expect from Perl's developers:</source>
          <target state="translated">本文档规定了Perl社区应该从Perl的开发者那里得到的支持和维护承诺。</target>
        </trans-unit>
        <trans-unit id="ee4356257bf892096131087eff39fae084e3b0fb" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt; ) 3.13_01.</source>
          <target state="translated">本文档介绍了 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; （也称为 &lt;code&gt;xsubpp&lt;/code&gt; ）3.13_01支持的功能。</target>
        </trans-unit>
        <trans-unit id="6622e622368097560175e65713355ba452a435bc" translate="yes" xml:space="preserve">
          <source>This document covers features supported by &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; (also known as &lt;code&gt;xsubpp&lt;/code&gt;) 3.13_01.</source>
          <target state="translated">本文档介绍了 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; （也称为 &lt;code&gt;xsubpp&lt;/code&gt; ）3.13_01支持的功能。</target>
        </trans-unit>
        <trans-unit id="5d19d436c676e82c5de62fa2d93b31ad146ee5c7" translate="yes" xml:space="preserve">
          <source>This document defines a standard generic interface to the dynamic linking mechanisms available on many platforms. Its primary purpose is to implement automatic dynamic loading of Perl modules.</source>
          <target state="translated">本文档定义了一个标准的通用接口,用于连接许多平台上的动态链接机制。其主要目的是实现Perl模块的自动动态加载。</target>
        </trans-unit>
        <trans-unit id="f9a30c0ae237ad22360e4681ed6256da44062757" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.05</source>
          <target state="translated">本文档描述了Thread::Queue 3.05版本。</target>
        </trans-unit>
        <trans-unit id="672f477a960d9d97a53477316665e103fc6bcb55" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Queue version 3.14</source>
          <target state="translated">本文档描述了Thread::Queue 3.14版本。</target>
        </trans-unit>
        <trans-unit id="c32625e21916315b56d3d555dca5fa14529f5283" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.12</source>
          <target state="translated">本文档描述了Thread::Semaphore 2.12版本。</target>
        </trans-unit>
        <trans-unit id="5e19eb2d41d244928aeeec5e1174bef98f47a6c8" translate="yes" xml:space="preserve">
          <source>This document describes Thread::Semaphore version 2.13</source>
          <target state="translated">本文档描述了Thread::Semaphore 2.13版本。</target>
        </trans-unit>
        <trans-unit id="0a25c4c9828d0f58970f77b7ac6aa566b68c27f1" translate="yes" xml:space="preserve">
          <source>This document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.</source>
          <target state="translated">本文档介绍了所有的反斜杠和转义序列。在解释了反斜杠的作用之后,它列出了所有在Perl正则表达式中具有特殊意义的序列(按字母顺序排列),然后描述了每一个序列。</target>
        </trans-unit>
        <trans-unit id="76ff3a8588f27b8cdd8cc7d51db810e080d05732" translate="yes" xml:space="preserve">
          <source>This document describes all of Perl's object-oriented (OO) features from the ground up. If you're just looking to write some object-oriented code of your own, you are probably better served by using one of the object systems from CPAN described in &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">本文档从头开始描述Perl的所有面向对象（OO）功能。如果您只是想编写自己的一些面向对象的代码，则最好使用&lt;a href=&quot;perlootut&quot;&gt;perlootut中&lt;/a&gt;描述的CPAN对象系统之一。</target>
        </trans-unit>
        <trans-unit id="50f134817136be6999dd57e5d22bbefe3d37d2f5" translate="yes" xml:space="preserve">
          <source>This document describes how Perl internally handles numeric values.</source>
          <target state="translated">本文档介绍了Perl内部如何处理数值。</target>
        </trans-unit>
        <trans-unit id="013bbee9fd51be8302723130fd1f7000b8b03cb8" translate="yes" xml:space="preserve">
          <source>This document describes how to set up your host environment when attempting to build Perl for Android.</source>
          <target state="translated">本文档介绍了在尝试构建Perl for Android时如何设置主机环境。</target>
        </trans-unit>
        <trans-unit id="8453dae2d904ec94b51a4ae275d589cad1fe0302" translate="yes" xml:space="preserve">
          <source>This document describes the behavior and implementation of the PerlIO abstraction described in &lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt; when &lt;code&gt;USE_PERLIO&lt;/code&gt; is defined.</source>
          <target state="translated">本文档中描述的行为和实施中所描述的PerlIO的抽象&lt;a href=&quot;perlapio&quot;&gt;perlapio&lt;/a&gt;时 &lt;code&gt;USE_PERLIO&lt;/code&gt; 被定义。</target>
        </trans-unit>
        <trans-unit id="a866d5af85544e7e4f21ddcd952a6d5892f7ea0f" translate="yes" xml:space="preserve">
          <source>This document describes the layout of the Perl source tree. If you're hacking on the Perl core, this will help you find what you're looking for.</source>
          <target state="translated">这个文档描述了Perl源代码树的布局。如果你正在对Perl核心进行黑客攻击,这将帮助你找到你要找的东西。</target>
        </trans-unit>
        <trans-unit id="327aacce5b60fcb7f0492805932fe1dec841e5bb" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.01</source>
          <target state="translated">本文档描述了线程2.01版本</target>
        </trans-unit>
        <trans-unit id="fa650f02e8b505bbf05cadb48d318189989235e1" translate="yes" xml:space="preserve">
          <source>This document describes threads version 2.25</source>
          <target state="translated">本文档介绍了线程2.25版本</target>
        </trans-unit>
        <trans-unit id="469ac48c0f559cb018049645e8c6431b0895b43b" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.48</source>
          <target state="translated">本文档介绍了线程::共享的1.48版本。</target>
        </trans-unit>
        <trans-unit id="6bdb3bba8e288e79f3b2d24456bd5e0dd45bb944" translate="yes" xml:space="preserve">
          <source>This document describes threads::shared version 1.61</source>
          <target state="translated">本文档介绍了线程::共享1.61版本。</target>
        </trans-unit>
        <trans-unit id="645bafb8d9dd20a3e1fad46cb6f3fa997de6c937" translate="yes" xml:space="preserve">
          <source>This document describes various features of FreeBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">这篇文档描述了FreeBSD的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="321b1b1331ddd1b908bf07373d4048f86b3fa9c7" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's (formerly Compaq's, formerly Digital's) Unix operating system (Tru64) that will affect how Perl version 5 (hereafter just Perl) is configured, compiled and/or runs.</source>
          <target state="translated">本文档描述了HP(原Compaq,原Digital)Unix操作系统(Tru64)的各种特性,这些特性将影响Perl第5版(以下简称Perl)的配置、编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="d268ac5a2d19120ce76c77eb58b90ecc6824f4a2" translate="yes" xml:space="preserve">
          <source>This document describes various features of HP's Unix operating system (HP-UX) that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了惠普Unix操作系统(HP-UX)的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="2eba298a6bc6800370faf3fd81957d6c988953ae" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's OS/400 operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了IBM的OS/400操作系统的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="1043854dc3d305d1c7397cad00b2c0693b02060a" translate="yes" xml:space="preserve">
          <source>This document describes various features of IBM's UNIX operating system AIX that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了IBM的UNIX操作系统AIX的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="0e732732feb0181fd46f9c9188d35cc9910b00cf" translate="yes" xml:space="preserve">
          <source>This document describes various features of Irix that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Irix的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="180f34cce99d47d99da56406605f0fb9ba8ddd90" translate="yes" xml:space="preserve">
          <source>This document describes various features of Linux that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Linux的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行方式。</target>
        </trans-unit>
        <trans-unit id="cd165af2963c8b766b7c027487cbd05b923f2018" translate="yes" xml:space="preserve">
          <source>This document describes various features of OpenBSD that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">这篇文档描述了OpenBSD的各种特性,这些特性将影响Perl版本5(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="bc5bdb1f6483dddcfcf934a3487da7243a97f3cc" translate="yes" xml:space="preserve">
          <source>This document describes various features of Sun's Solaris operating system that will affect how Perl version 5 (hereafter just perl) is compiled and/or runs. Some issues relating to the older SunOS 4.x are also discussed, though they may be out of date.</source>
          <target state="translated">本文档描述了Sun公司Solaris操作系统的各种特性,这些特性将影响Perl第5版(以下简称perl)的编译和/或运行。本文档还讨论了一些与旧版SunOS 4.x有关的问题,尽管这些问题可能已经过时。</target>
        </trans-unit>
        <trans-unit id="fedada57f7519909ad611f81430777abe7e58861" translate="yes" xml:space="preserve">
          <source>This document describes various features of Synology DSM operating system that will affect how Perl 5 (hereafter just Perl) is configured, compiled and/or runs. It has been compiled and verified by Johan Vromans for the Synology DS413 (QorIQ), with feedback from H.Merijn Brand (DS213, ARMv5tel and RS815, Intel Atom x64).</source>
          <target state="translated">本文档描述了 Synology DSM 操作系统的各种特性,这些特性将影响 Perl 5(以下简称 Perl)的配置、编译和/或运行。本文档由 Johan Vromans 为 Synology DS413 (QorIQ)编译和验证,并参考了 H.Merijn Brand (DS213,ARMv5tel and RS815,Intel Atom x64)的意见。</target>
        </trans-unit>
        <trans-unit id="757712086ab3b4685f19333593ba82a0d48290a1" translate="yes" xml:space="preserve">
          <source>This document describes various features of the Symbian operating system that will affect how Perl version 5 (hereafter just Perl) is compiled and/or runs.</source>
          <target state="translated">本文档描述了Symbian操作系统的各种特性,这些特性将影响Perl第5版(以下简称Perl)的编译和/或运行。</target>
        </trans-unit>
        <trans-unit id="fc69a8a87860da299a32df2a5c45e5d6bec2f8df" translate="yes" xml:space="preserve">
          <source>This document describes version 0.13 of encoding::warnings, released June 20, 2016.</source>
          <target state="translated">本文档介绍了2016年6月20日发布的编码::警告的0.13版本。</target>
        </trans-unit>
        <trans-unit id="a4d121d0bfe8a3c1aa6015bd2c8760d53592dff9" translate="yes" xml:space="preserve">
          <source>This document describes version 0.18 of Locale::Maketext::Simple, released Septermber 8, 2006.</source>
          <target state="translated">本文档介绍了Locale::Maketext::Simple的0.18版本,2006年9月8日发布。</target>
        </trans-unit>
        <trans-unit id="5e0659e04f3d9f2056b337b0739a67684597732b" translate="yes" xml:space="preserve">
          <source>This document describes version 0.97 of Attribute::Handlers.</source>
          <target state="translated">本文档介绍了Attribute::Handlers的0.97版本。</target>
        </trans-unit>
        <trans-unit id="1605f5eccb40dc73f78c393c35eb29bd098cfb8f" translate="yes" xml:space="preserve">
          <source>This document describes version 1.0 of the</source>
          <target state="translated">本文件介绍了1.0版本的</target>
        </trans-unit>
        <trans-unit id="2bf780daf1c016bbf9b8bf7bcea84f2fe69f237a" translate="yes" xml:space="preserve">
          <source>This document describes version 1.01 of Attribute::Handlers.</source>
          <target state="translated">本文档介绍了Attribute::Handlers的1.01版本。</target>
        </trans-unit>
        <trans-unit id="f171b9809b51bd5f94dba6d702fe833dee48017f" translate="yes" xml:space="preserve">
          <source>This document describes version 1.1 of the</source>
          <target state="translated">本文件介绍了1.1版的</target>
        </trans-unit>
        <trans-unit id="11f0cf5695cdecc42b0a56163e7c761e8f4e34ac" translate="yes" xml:space="preserve">
          <source>This document describes version 1.2 of the</source>
          <target state="translated">本文件介绍了1.2版的</target>
        </trans-unit>
        <trans-unit id="3fcccd87344b9b0105f05a1d3b78e62bdfe07a5e" translate="yes" xml:space="preserve">
          <source>This document describes version 1.3 of the</source>
          <target state="translated">本文件介绍了1.3版本的</target>
        </trans-unit>
        <trans-unit id="06ad1cd2f74484f836eb1d92be8f1677db4c49d0" translate="yes" xml:space="preserve">
          <source>This document describes version 1.4 of the</source>
          <target state="translated">本文件介绍了1.4版本的</target>
        </trans-unit>
        <trans-unit id="d70b159fef5698128cc2ba778d3b9f8c4402065a" translate="yes" xml:space="preserve">
          <source>This document describes version 2 of the CPAN distribution metadata specification, also known as the &quot;CPAN Meta Spec&quot;.</source>
          <target state="translated">本文档描述了CPAN发布元数据规范的第2版,也称为 &quot;CPAN元规范&quot;。</target>
        </trans-unit>
        <trans-unit id="00291624b11a3514d125571e1eabaca275507a74" translate="yes" xml:space="preserve">
          <source>This document describes version 2.09 of File::Path, released 2013-01-17.</source>
          <target state="translated">本文档介绍了2013-01-17发布的File::Path的2.09版本。</target>
        </trans-unit>
        <trans-unit id="e958fa3bffae7851375960acacad749b89480be8" translate="yes" xml:space="preserve">
          <source>This document differs from &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; in that it is a style guide rather than a tutorial on creating CPAN modules. It provides a checklist against which modules can be compared to determine whether they conform to best practice, without necessarily describing in detail how to achieve this.</source>
          <target state="translated">该文档与&lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod的&lt;/a&gt;不同之处在于，它是样式指南，而不是有关创建CPAN模块的教程。它提供了一个清单，可以将其与模块进行比较以确定它们是否符合最佳实践，而不必详细描述如何实现。</target>
        </trans-unit>
        <trans-unit id="f6d0bfb69bb5025df2e411b7c26b2866134bc607" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perl bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">这篇文档解释了 Perl 的开发方式。它包括有关Perl 5 Porters电子邮件列表、Perl资源库、Perl错误跟踪器、补丁指南以及Perl开发理念的评论等细节。</target>
        </trans-unit>
        <trans-unit id="1c365d03a0d07def2d5f697a7dff266e86bfcaee" translate="yes" xml:space="preserve">
          <source>This document explains how Perl development works. It includes details about the Perl 5 Porters email list, the Perl repository, the Perlbug bug tracker, patch guidelines, and commentary on Perl development philosophy.</source>
          <target state="translated">这篇文档解释了 Perl 的开发工作原理,包括 Perl 5 Porters 电子邮件列表、Perl 仓库、Perlbug 错误跟踪器、补丁指南以及 Perl 开发理念的评论。它包括关于 Perl 5 Porters 电子邮件列表、Perl 仓库、Perlbug 错误跟踪器、补丁指南以及关于 Perl 开发理念的评论。</target>
        </trans-unit>
        <trans-unit id="1a4e728f85569353c5be0c8060d949669e83dbf4" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical or almost identical to Perl's builtin functions.</source>
          <target state="translated">本文档简要列出了POSIX模块中可用的功能。有关大多数功能的常规信息，请查阅操作系统的手册页。有关被认为与Perl内置函数相同或几乎相同的功能，请咨询&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="448289ec7a46caaf1d68d5b7cd3ab508bea55402" translate="yes" xml:space="preserve">
          <source>This document gives a condensed list of the features available in the POSIX module. Consult your operating system's manpages for general information on most features. Consult &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for functions which are noted as being identical to Perl's builtin functions.</source>
          <target state="translated">本文档简要列出了POSIX模块中可用的功能。有关大多数功能的常规信息，请查阅操作系统的手册页。有关与Perl的内置函数相同的功能，请咨询&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3a9755b0632840622eb25f31414e4542c2feca7" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;&quot;Further Resources&quot;&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">本文档给出了Unicode的一般概念以及如何在Perl中使用Unicode。有关对Unicode进行更深入处理的参考，请参见&lt;a href=&quot;#Further-Resources&quot;&gt;&amp;ldquo;其他资源&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2fce74951001e7bfa538197dd8bb5ec9f0e07bc5" translate="yes" xml:space="preserve">
          <source>This document gives a general idea of Unicode and how to use Unicode in Perl. See &lt;a href=&quot;#Further-Resources&quot;&gt;Further Resources&lt;/a&gt; for references to more in-depth treatments of Unicode.</source>
          <target state="translated">本文档给出了Unicode的一般概念以及如何在Perl中使用Unicode。请参阅&amp;ldquo; &lt;a href=&quot;#Further-Resources&quot;&gt;其他资源&amp;rdquo;&lt;/a&gt;以获取对Unicode的更深入处理的参考。</target>
        </trans-unit>
        <trans-unit id="3a55afa937d8de565fbacea117f04c55c4f3d03c" translate="yes" xml:space="preserve">
          <source>This document gives instructions for building Perl for RISC OS. It is complicated by the need to cross compile. There is a binary version of perl available from &lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/&lt;/a&gt; which you may wish to use instead of trying to compile it yourself.</source>
          <target state="translated">本文档提供了有关为RISC OS构建Perl的说明。需要交叉编译使它变得复杂。您可以使用&lt;a href=&quot;http://www.cp15.org/perl/&quot;&gt;http://www.cp15.org/perl/中&lt;/a&gt;的perl二进制版本，而不是自己尝试对其进行编译。</target>
        </trans-unit>
        <trans-unit id="15f232a362787f4ceadbadf19dad93be195a4a8a" translate="yes" xml:space="preserve">
          <source>This document gives you some suggestions about how to go about writing Perl modules, preparing them for distribution, and making them available via CPAN.</source>
          <target state="translated">这篇文档为你提供了一些关于如何编写Perl模块的建议,为发布它们做准备,并通过CPAN提供它们。</target>
        </trans-unit>
        <trans-unit id="132f8081c1f83d30c54e1dd1f8a6c29026e0459f" translate="yes" xml:space="preserve">
          <source>This document has provided several way to go about identifying hot-spots, and checking whether any modifications have improved the runtime of the code.</source>
          <target state="translated">本文档提供了几种识别热点的方法,并检查是否有任何修改改进了代码的运行时间。</target>
        </trans-unit>
        <trans-unit id="1d1186d2059259c57e212c2e5f26480c6a04dbbf" translate="yes" xml:space="preserve">
          <source>This document is about using Pod::Simple to write a Pod processor, generally a Pod formatter. If you just want to know about using an existing Pod formatter, instead see its documentation and see also the docs in &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt;.</source>
          <target state="translated">本文档是关于使用Pod :: Simple编写Pod处理器（通常是Pod格式化程序）的。如果您只是想了解有关使用现有Pod格式化程序的信息，请参阅其文档，以及&lt;a href=&quot;Pod::Simple&quot;&gt;Pod :: Simple中&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="2f9e9ade072c3d9b2906bfd078f37006fde1b348" translate="yes" xml:space="preserve">
          <source>This document is an attempt to shine some light on the guts of the regex engine and how it works. The regex engine represents a significant chunk of the perl codebase, but is relatively poorly understood. This document is a meagre attempt at addressing this situation. It is derived from the author's experience, comments in the source code, other papers on the regex engine, feedback on the perl5-porters mail list, and no doubt other places as well.</source>
          <target state="translated">这篇文档试图让大家了解一下regex引擎的内涵和工作原理。regex引擎在perl代码中占了很大的比重,但人们对它的理解相对较少。本文档是针对这种情况的一个微不足道的尝试。它来自于作者的经验、源代码中的评论、其他关于 regex 引擎的论文、perl5-porters 邮件列表中的反馈,毫无疑问还有其他地方。</target>
        </trans-unit>
        <trans-unit id="e2f799b102440b11497f30f8301310792802f29f" translate="yes" xml:space="preserve">
          <source>This document is authored and maintained by Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;.</source>
          <target state="translated">本文档由Gurusamy Sarathy &amp;lt;gsar@activestate.com&amp;gt;编写和维护。</target>
        </trans-unit>
        <trans-unit id="deb0c7f47e4494d30a1aab35b9ec321b01a2ec44" translate="yes" xml:space="preserve">
          <source>This document is available under the same terms as Perl itself. Code examples in all the perlfaq documents are in the public domain. Use them as you see fit (and at your own risk with no warranty from anyone).</source>
          <target state="translated">本文档与Perl本身的条款相同。所有 perlfaq 文档中的代码示例都是公共领域的。你可以根据自己的需要使用它们(风险自负,任何人都不保证)。</target>
        </trans-unit>
        <trans-unit id="3ad8de5a753a60df1918818ee7a3cda366409476" translate="yes" xml:space="preserve">
          <source>This document is broken into two sections; those methods that are most useful to the end-developer, and those methods for anyone wishing to subclass or get very familiar with &lt;code&gt;autodie::exception&lt;/code&gt;.</source>
          <target state="translated">本文档分为两部分：那些对最终开发人员最有用的方法，以及那些希望 &lt;code&gt;autodie::exception&lt;/code&gt; 或非常熟悉autodie :: exception的人的方法。</target>
        </trans-unit>
        <trans-unit id="931cd9f92a3e4b725c73c5f241d6c52b01e63f35" translate="yes" xml:space="preserve">
          <source>This document is detailed notes on the Pod markup language. Most people will only have to read &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; to know how to write in Pod, but this document may answer some incidental questions to do with parsing and rendering Pod.</source>
          <target state="translated">本文档是有关Pod标记语言的详细说明。大多数人只需要阅读&lt;a href=&quot;perlpod&quot;&gt;Perlpod&lt;/a&gt;即可知道如何用Pod编写，但是此文档可能会回答一些与解析和渲染Pod有关的附带问题。</target>
        </trans-unit>
        <trans-unit id="030bf2a8075ca167ab3cef3833507c2f42453664" translate="yes" xml:space="preserve">
          <source>This document is distributed with the libnet distribution, and is also available on the libnet web page at</source>
          <target state="translated">本文档与libnet发行版一起发布,也可在libnet网页上查阅,网址为</target>
        </trans-unit>
        <trans-unit id="bf5499e713f269332b5a031b1d5ec104878d26d5" translate="yes" xml:space="preserve">
          <source>This document is intended to give you a quick overview of the Perl programming language, along with pointers to further documentation. It is intended as a &quot;bootstrap&quot; guide for those who are new to the language, and provides just enough information for you to be able to read other peoples' Perl and understand roughly what it's doing, or write your own simple scripts.</source>
          <target state="translated">这篇文档的目的是让你快速了解Perl编程语言,以及指向更多文档的指针。它的目的是为那些刚接触这门语言的人提供一个 &quot;引导 &quot;指南,并提供足够的信息,让你能够阅读其他人的Perl,并大致了解它的工作,或者编写你自己的简单脚本。</target>
        </trans-unit>
        <trans-unit id="04d450fbf5761325924f000d871533277846798f" translate="yes" xml:space="preserve">
          <source>This document is maintained by Jan Dubois.</source>
          <target state="translated">本文件由Jan Dubois维护。</target>
        </trans-unit>
        <trans-unit id="6ad1ca1a9c1e0e6df1be4b460cdb832dc533d65a" translate="yes" xml:space="preserve">
          <source>This document is meant to be a detailed but understandable treatment of the many different sorts of data structures you might want to develop. It should also serve as a cookbook of examples. That way, when you need to create one of these complex data structures, you can just pinch, pilfer, or purloin a drop-in example from here.</source>
          <target state="translated">本文档的目的是对你可能想要开发的许多不同类型的数据结构进行详细但易懂的处理。它还应该作为一个例子的烹饪书。这样一来,当你需要创建这些复杂的数据结构时,你就可以从这里摘取、偷窃或掠夺一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="9bf997dd7f7e98ee160d1fffa9d041813ac9f4bb" translate="yes" xml:space="preserve">
          <source>This document is meant to help you to find out what constitutes portable Perl code. That way once you make a decision to write portably, you know where the lines are drawn, and you can stay within them.</source>
          <target state="translated">这篇文档的目的是帮助您了解什么是可移植的 Perl 代码。这样一来,一旦你决定要写可移植的代码,你就会知道界限在哪里,而且你可以不受界限的限制。</target>
        </trans-unit>
        <trans-unit id="9d9f3d95216c84aa89657f351bb6eefc71ea99a0" translate="yes" xml:space="preserve">
          <source>This document is provided in the hope that it will be useful, but without any warranty; without even the implied warranty of accuracy, authoritativeness, completeness, merchantability, or fitness for a particular purpose.</source>
          <target state="translated">提供本文件的目的是希望本文件有用,但不作任何保证,甚至不暗示保证本文件的准确性、权威性、完整性、适销性或对某一特定目的的适用性。</target>
        </trans-unit>
        <trans-unit id="c3a1d5c913f755b58160ddd4ac8b4f8158d38b0a" translate="yes" xml:space="preserve">
          <source>This document is the master document which records all written policies about how the Perl 5 Porters collectively develop and maintain the Perl core.</source>
          <target state="translated">本文档是一份主文档,它记录了所有关于 Perl 5 Porters 如何共同开发和维护 Perl 核心的书面政策。</target>
        </trans-unit>
        <trans-unit id="6445b4e91fdc1237d3a1bc4a31d98919bdef331e" translate="yes" xml:space="preserve">
          <source>This document lists the current and past experimental features in the perl core. Although all of these are documented with their appropriate topics, this succinct listing gives you an overview and basic facts about their status.</source>
          <target state="translated">这篇文档列出了perl core中当前和过去的实验性特性。尽管所有这些特性都有相应的主题文档,但这个简洁的列表为你提供了关于它们状态的概述和基本事实。</target>
        </trans-unit>
        <trans-unit id="e04379014fdbc8385dc766fdec2dc2ab609657d0" translate="yes" xml:space="preserve">
          <source>This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">本文档可以按照与Perl本身相同的条款发布。</target>
        </trans-unit>
        <trans-unit id="68809e455146d4d0b2eb575625c0befbf01b3e91" translate="yes" xml:space="preserve">
          <source>This document may be incomplete in some respects.</source>
          <target state="translated">本文件在某些方面可能不完整。</target>
        </trans-unit>
        <trans-unit id="0888583782e9e5c64acf12be9464dec48a946068" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">本文档仅列出了所有可用的属性，而没有试图解释每个属性的真正含义。每个Perl扩展都有一个简短的描述。有关这些的更多信息，请参见&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode中的&amp;ldquo;其他属性&amp;rdquo;&lt;/a&gt;。在perlunicode中有一些有关Blocks，Scripts，General_Category和Bidi_Class的&lt;a href=&quot;perlunicode&quot;&gt;详细信息&lt;/a&gt;，但是要了解官方Unicode属性的复杂性，请参考Unicode标准。&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;是一个很好的起点。</target>
        </trans-unit>
        <trans-unit id="2bd1436fd8999891ab1bb5e064947b34794db6eb" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">本文档仅列出了所有可用的属性，而没有试图解释每个属性的真正含义。每个Perl扩展都有一个简短的描述。有关这些的更多信息，请参见&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode中的&amp;ldquo;其他属性&amp;rdquo;&lt;/a&gt;。在perlunicode中有一些有关Blocks，Scripts，General_Category和Bidi_Class的&lt;a href=&quot;perlunicode&quot;&gt;详细信息&lt;/a&gt;，但是要了解官方Unicode属性的复杂性，请参考Unicode标准。&lt;a href=&quot;https://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;是一个很好的起点。</target>
        </trans-unit>
        <trans-unit id="d40e2bd179554762718d2c8f40e4558baafd8315" translate="yes" xml:space="preserve">
          <source>This document merely lists all available properties and does not attempt to explain what each property really means. There is a brief description of each Perl extension; see &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt; for more information on these. There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard. A good starting place is &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;.</source>
          <target state="translated">本文档仅列出所有可用的属性，而不试图解释每个属性的真正含义。每个Perl扩展都有一个简短的描述。有关这些的更多信息，请参见&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;perlunicode中的&amp;ldquo;其他属性&amp;rdquo;&lt;/a&gt;。在perlunicode中有一些有关Blocks，Scripts，General_Category和Bidi_Class的&lt;a href=&quot;perlunicode&quot;&gt;详细信息&lt;/a&gt;，但是要了解官方Unicode属性的复杂性，请参考Unicode标准。&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;是一个很好的起点。</target>
        </trans-unit>
        <trans-unit id="69e6772a5d46653631303f536faddc78ecd15c3a" translate="yes" xml:space="preserve">
          <source>This document mostly explains the</source>
          <target state="translated">本文件主要解释了</target>
        </trans-unit>
        <trans-unit id="a7ddd5955e611e8402df676dc922c52fe96687d9" translate="yes" xml:space="preserve">
          <source>This document needs a rewrite that separates the tutorial content from the reference content.</source>
          <target state="translated">这个文档需要重写,把教程内容和参考内容分开。</target>
        </trans-unit>
        <trans-unit id="c5434f0b9e2b7cf484cc38556a1c3be222c03edd" translate="yes" xml:space="preserve">
          <source>This document provides a general overview of the capabilities and limitations of the fork() emulation. Note that the issues discussed here are not applicable to platforms where a real fork() is available and Perl has been configured to use it.</source>
          <target state="translated">这篇文档提供了fork()仿真的功能和局限性的总体概述。请注意,这里讨论的问题并不适用于真正的fork()可用且Perl已被配置为使用它的平台。</target>
        </trans-unit>
        <trans-unit id="93c5711ad21bddf8f27384e848494d1a512f01be" translate="yes" xml:space="preserve">
          <source>This document provides a reference for Perl's object orientation features. If you're looking for an introduction to object-oriented programming in Perl, please see &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">本文档为Perl的面向对象功能提供了参考。如果您正在寻找Perl中的面向对象编程的介绍，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46a94276417126d2ba57635546eac62791e072d3" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">本文档介绍了Perl中的面向对象编程。它首先简要介绍了面向对象设计背后的概念。然后，它介绍了基于&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org&quot;&gt;CPAN的&lt;/a&gt;几种不同的OO系统，它们基于Perl提供的功能。</target>
        </trans-unit>
        <trans-unit id="32fbffb9ed2f7371e868fa4e9fc51a003e559b60" translate="yes" xml:space="preserve">
          <source>This document provides an introduction to object-oriented programming in Perl. It begins with a brief overview of the concepts behind object oriented design. Then it introduces several different OO systems from &lt;a href=&quot;https://www.cpan.org&quot;&gt;CPAN&lt;/a&gt; which build on top of what Perl provides.</source>
          <target state="translated">本文档介绍了Perl中的面向对象编程。它首先简要介绍了面向对象设计背后的概念。然后，它介绍了基于&lt;a href=&quot;https://www.cpan.org&quot;&gt;CPAN的&lt;/a&gt;几种不同的OO系统，它们基于Perl提供的功能。</target>
        </trans-unit>
        <trans-unit id="6876a82e12e5ab947f419b2c224d987985e1ad19" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the Perl interpreter works at the level of C code, along with pointers to the relevant C source code files.</source>
          <target state="translated">本文档概述了Perl解释器在C代码层面的工作方式,以及指向相关C源代码文件的指针。</target>
        </trans-unit>
        <trans-unit id="37c6cecf4b6aa297d30eab95a37418764fe60217" translate="yes" xml:space="preserve">
          <source>This document provides details on using git to develop Perl. If you are just interested in working on a quick patch, see &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; first. This document is intended for people who are regular contributors to Perl, including those with write access to the git repository.</source>
          <target state="translated">该文档提供了有关使用git开发Perl的详细信息。如果您只对快速补丁感兴趣，&lt;a href=&quot;perlhack&quot;&gt;请先&lt;/a&gt;参阅perlhack。本文档面向的是Perl的定期撰稿人，包括那些具有git存储库写权限的人。</target>
        </trans-unit>
        <trans-unit id="7278c04f4b33c2701db9eb4b58232b8395cf3c28" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;&quot;Other information in the Unicode data base&quot;&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">本文档提供了有关Unicode数据库中处理字符属性的部分的信息，即在单个代码点上定义的部分。（下面的&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;&amp;ldquo; Unicode数据库中的其他信息&amp;rdquo;&lt;/a&gt;简要提到了Unicode提供的其他数据。）</target>
        </trans-unit>
        <trans-unit id="98ef42b4ebd0391f6b1eb2c007891c9540cce7bb" translate="yes" xml:space="preserve">
          <source>This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points. (&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;Other information in the Unicode data base&lt;/a&gt; below briefly mentions other data that Unicode provides.)</source>
          <target state="translated">本文档提供了有关Unicode数据库中处理字符属性的部分的信息，即在单个代码点上定义的部分。（下面&lt;a href=&quot;#Other-information-in-the-Unicode-data-base&quot;&gt;的Unicode数据库中的其他信息&lt;/a&gt;简要提到了Unicode提供的其他数据。）</target>
        </trans-unit>
        <trans-unit id="e7cfd37a5d8539271a047f292c9b12d8fd7d71db" translate="yes" xml:space="preserve">
          <source>This document reconstructs the history of the CPAN Meta Spec based on change logs, repository commit messages and the published HTML files. In some cases, particularly prior to version 1.2, the exact version when certain fields were introduced or changed is inconsistent between sources. When in doubt, the published HTML files for versions 1.0 to 1.4 as they existed when version 2 was developed are used as the definitive source.</source>
          <target state="translated">本文档根据变更日志、版本库提交信息和发布的HTML文件重建了CPAN元规范的历史。在某些情况下,特别是在1.2版本之前,某些字段被引入或更改的确切版本在不同的来源之间是不一致的。当有疑问时,以1.0至1.4版本的已发布HTML文件作为最终的来源,因为它们是在2版本开发时存在的。</target>
        </trans-unit>
        <trans-unit id="b2a79746685de57fddf566ba23eb18f1694b69ba" translate="yes" xml:space="preserve">
          <source>This document serves as both a specification for anyone wishing to implement the DynaLoader for a new platform and as a guide for anyone wishing to use the DynaLoader directly in an application.</source>
          <target state="translated">本文档既是希望在新平台上实现DynaLoader的规范,也是希望在应用程序中直接使用DynaLoader的指南。</target>
        </trans-unit>
        <trans-unit id="4c2fd7fb88b1605d6c1c01cd882956329e66498d" translate="yes" xml:space="preserve">
          <source>This document takes you through a simple patch example.</source>
          <target state="translated">本文档将带您了解一个简单的补丁示例。</target>
        </trans-unit>
        <trans-unit id="482b84044bf12cbb74ce5534dc67232a2bb4bcd3" translate="yes" xml:space="preserve">
          <source>This document varies from difficult to understand to completely and utterly opaque. The wandering prose riddled with jargon is hard to fathom in several places.</source>
          <target state="translated">这份文件从难以理解到完全和完全不透明不等。漫无边际的散文中充满了行话,有几处地方难以理解。</target>
        </trans-unit>
        <trans-unit id="e494f5a4ef902fd5cb4de9dfa1a90e73e0fc46e2" translate="yes" xml:space="preserve">
          <source>This document walks through the creation of a small patch to Perl's C code. If you're just getting started with Perl core hacking, this will help you understand how it works.</source>
          <target state="translated">本文档讲解了如何为Perl的C代码创建一个小补丁。如果你刚开始接触Perl核心黑客,这将有助于你理解它是如何工作的。</target>
        </trans-unit>
        <trans-unit id="6e368b4b82da174b5c34f4ad74472953966358bf" translate="yes" xml:space="preserve">
          <source>This document was created in February, 2011, and the last major revision was in February, 2013.</source>
          <target state="translated">本文件创建于2011年2月,最后一次重大修订是在2013年2月。</target>
        </trans-unit>
        <trans-unit id="8a3b26fb452c67444e8240d5b8d2d39b95224d76" translate="yes" xml:space="preserve">
          <source>This document was last revised 8-DEC-2007, for Perl 5.10.0</source>
          <target state="translated">本文档最后一次修订是2007年12月8日,适用于Perl 5.10.0。</target>
        </trans-unit>
        <trans-unit id="2e05bb5aa5ec020b9cd05ba44bd1e5b7d8efd585" translate="yes" xml:space="preserve">
          <source>This document was last revised on 13-Oct-1998, for Perl 5.004, 5.005, and 5.6.0.</source>
          <target state="translated">本文档最后一次修订是在1998年10月13日,适用于Perl 5.004、5.005和5.6.0。</target>
        </trans-unit>
        <trans-unit id="e89c4ac20e63934f15f4f06f3bdf35dc35e9054b" translate="yes" xml:space="preserve">
          <source>This document was originally written by David Fiander for the 5.005 release of Perl.</source>
          <target state="translated">这个文档最初是由David Fiander为Perl的5.005版本编写的。</target>
        </trans-unit>
        <trans-unit id="44116b950aea8406dc1d009e3e7e8df16d0f1901" translate="yes" xml:space="preserve">
          <source>This document was originally written by Nathan Torkington, and is maintained by the perl5-porters mailing list.</source>
          <target state="translated">这个文档最初是由Nathan Torkington写的,由perl5-porters邮件列表维护。</target>
        </trans-unit>
        <trans-unit id="cb57f1783ae5d9d11a07aa4ee9a4142c141dd869" translate="yes" xml:space="preserve">
          <source>This document was originally written by Thomas Dorner for the 5.005 release of Perl.</source>
          <target state="translated">这个文档最初是由Thomas Dorner为Perl的5.005版本编写的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
