<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">应用 &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; 被返回的值 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; ，如果你想随机整数，而不是随机小数。例如，</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">应用Perl特有的启发式方法来寻找正确的POD。这包括剥离类似Perl的扩展,省略那些是数字的子目录,但确实是这样。</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">将开关选项列表应用于状态,结果更新内部对象状态。不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">将 &lt;code&gt;autodie&lt;/code&gt; 应用于 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 会导致特殊形式的 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; 被视为语法错误，直到词法范围结束。如果确实需要使用奇异形式，则可以调用 &lt;code&gt;CORE::system&lt;/code&gt; 或 &lt;code&gt;CORE::exec&lt;/code&gt; 代替，或者在调用奇异形式之前 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; 使用autodie qw（system exec）。</target>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">Perl近似值： &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">Perl近似值： &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">1997年04月04日-07日:由Jarkko Hietaniemi编写,增加了运行时的功能。</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">任意大有理数</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">任意大小的浮点数学包。</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">任意大小的整数/浮点数数学包。</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archive::Tar-用于操作tar存档的模块。</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar 为处理 tar 文件提供了一个面向对象的机制。它提供了快速和简单的文件处理类方法,同时也允许创建tar文件对象进行自定义操作。如果您安装了 IO::Zlib 模块,Archive::Tar 也将支持压缩或 gzipped 的 tar 文件。</target>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Archive::Tar 会在你试图传递一个 bzip2 压缩文件,而 IO::Zlib/IO::Uncompress::Bunzip2 模块不可用时发出警告,并简单地返回。</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">存档:: Tar-&amp;gt; create_archive（$ file，$ compressed，@filelist）</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">存档:: Tar-&amp;gt; extract_archive（$ file，$ compressed）</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">存档:: Tar-&amp;gt; iter（$ filename，[$ compressed，{opt =&amp;gt; $ val}]）</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">存档：： Tar-&amp;gt; list_archive（$ file，$ compressed，[\ @properties]）</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">存档：： Tar-&amp;gt; new（[$ file，$ compressed]）</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archive::Tar::File-从 Archive::Tar 中提取内存文件的子类。</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（chunk =&amp;gt; $ chunk）</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（data =&amp;gt; $ path，$ data，$ opt）</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">存档:: Tar :: File-&amp;gt; new（file =&amp;gt; $ path）</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archive::Tar::Files 为内存中提取的文件提供了一个整洁的小对象层。它主要是在 Archive::Tar 中被内部用来整理代码,但用户没有理由不使用这个 API。</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">归档和压缩</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">Perl 的 regexes 是 DFAs 还是 NFAs?它们是否符合 POSIX 标准?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">这些线是一样的吗?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">尚未执行。</target>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">你是否在运行Windows,你是否写了</target>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">你使用的是非常老版本的Perl吗?</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">可以说，这是从C程序中执行Perl代码段的唯一例程。您的代码可以是您想要的任何时间；它可以包含多个语句；它可以使用&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;，&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;和&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;来包含外部Perl文件。</target>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">参数回调</target>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">参数堆栈</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">内核中的参数堆栈操作与&lt;a href=&quot;perlguts&quot;&gt;XSUB&lt;/a&gt;中的参数完全相同-有关堆栈操作中使用的宏的详细说明，请参见&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;，&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和perlguts。</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">参数不分大小写。</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">如果参数不是字符串,则强制采用整数格式。</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">使用参数堆栈 &lt;code&gt;ST&lt;/code&gt; 将参数传递到PP代码并从PP代码返回。处理参数的典型方法是将其弹出堆栈，按照需要进行处理，然后将结果推回堆栈。例如，余弦运算符的工作方式如下：</target>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">参数通常被格式化为仅显示给定值所需的宽度。您可以通过在此处放置数字来覆盖宽度，或者从下一个参数（带有 &lt;code&gt;*&lt;/code&gt; ）或从指定的参数（例如带有 &lt;code&gt;*2$&lt;/code&gt; ）获取宽度：</target>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">该参数的 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 指示是（键，值）对。有关完整的合法密钥集，请参阅下面的可&lt;a href=&quot;#Overloadable-Operations&quot;&gt;重载操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">不以连字符开头的参数被视为要渲染的子例程的名称或格式。如果未指定此类功能，则将呈现程序的主体（在任何子例程之外，并且不包括use'或require'd文件）。传递 &lt;code&gt;BEGIN&lt;/code&gt; ， &lt;code&gt;UNITCHECK&lt;/code&gt; ， &lt;code&gt;CHECK&lt;/code&gt; ， &lt;code&gt;INIT&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 将导致所有相应的特殊块被打印。参数必须遵循选项。</target>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">&lt;b&gt;不&lt;/b&gt;检查 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 的参数是否有污点。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">测试的参数</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">要添加到命令行的参数</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">这些命令的参数要么是与对象的标识字符串完全匹配的字符串,要么是与对象的各种属性不分大小写地匹配的正则表达式。只有当你用斜杠括住正则表达式时,解析器才会识别它。</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">参数。COUNT是要运行循环的次数,CODE是要运行的代码。CODE可以是一个代码引用,也可以是一个字符串,无论哪种方式,它都会在调用者的包中运行。</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">参数。TIME是运行CODE的最小时间长度,CODE是要运行的代码。CODE可以是一个代码引用,也可以是一个待评估的字符串;无论哪种方式,它都将在调用者的包中运行。</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">Arnold,Ken 和 James Gosling.The Java Programming Language,2nd ed.Addison-Wesley,1998,ISBN 0-201-31006-6.Addison-Wesley,1998年,ISBN 0-201-31006-6。</target>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">安排在运行时库区分二进制文件和文本文件的系统上以&amp;ldquo;二进制&amp;rdquo;或&amp;ldquo;文本&amp;rdquo;模式读取或写入FILEHANDLE。如果FILEHANDLE是一个表达式，则将该值作为文件句柄的名称。成功返回true，否则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">安排在运行时库区分二进制文件和文本文件的系统上以&amp;ldquo;二进制&amp;rdquo;或&amp;ldquo;文本&amp;rdquo;模式读取或写入FILEHANDLE。如果FILEHANDLE是一个表达式，则将该值作为文件句柄的名称。成功返回true，否则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 并设置 &lt;code&gt;$!&lt;/code&gt; （errno）。</target>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">如果加载了合适的模块,安排在sv上获得互斥锁。</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">如果加载了合适的模块,安排线程之间共享sv。</target>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">在经过指定数目的壁钟秒后，安排将SIGALRM交付给该过程。如果未指定SECONDS，则使用 &lt;code&gt;$_&lt;/code&gt; 存储的值。（不幸的是，在某些机器上，经过的时间可能比您指定的时间少一秒或更长时间，因为秒数是如何计算的，并且进程调度可能会进一步延迟信号的传递。）</target>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">阵列插值</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">阵列操作函数</target>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">在进行静态构建时要包含的扩展名的数组。当进行静态构建时,MakeMaker通常会与所有已安装的扩展一起构建,这通常是所需的行为。如果存在INCLUDE_EXT,那么MakeMaker将只构建那些明确提及的扩展。(例如[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">进行静态构建时要排除的扩展名数组。如果存在INCLUDE_EXT,则会被忽略。更多细节请参考INCLUDE_EXT。(例如:[qw(Socket POSIX )])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">包含包作者姓名(和电子邮件地址)的字符串数组。在 CPAN Meta 文件 (META.yml 或 META.json)和 PPM (Perl Package Manager)的 PPD (Perl Package Description)文件中使用。</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">变量的符号名称阵列,可作为通用符号使用。目前只在AIX、OS/2、VMS和Win32下使用。默认值为[]。(例如:[qw(Foo_version Foo_numstreams Foo_tree )])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">更改标量，重新排列标量或添加或减去某些标量的数组操作仅适用于数组。这些不能在固定的列表上使用。数组操作包括 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">阵列大小可以通过做。</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">在编译Perl代码的过程中,在建立optree的 &quot;检查 &quot;阶段会被调用的函数数组,以opcode为索引。对于大多数(但不是所有)类型的 op,一旦 op 被初始化并填充了子 op,就会通过这个数组中相应元素所引用的检查函数进行过滤。新的op作为唯一的参数传递给检查函数,检查函数返回完成的op。检查函数可以(顾名思义)检查 op 的有效性并发出错误信号。它也可以初始化或修改部分操作,或进行更彻底的手术,如添加或删除子操作,甚至扔掉操作并返回另一个操作。</target>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref。例如，[qw（archname manext）]从config.sh定义ARCHNAME和MANEXT。MakeMaker仍将向CONFIG添加以下值：ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Arrayref.例如[qw(name1 name2)]跳过(不写)Makefile的部分。注意!不要使用SKIP属性来达到可以忽略不计的速度。不要为了可以忽略的速度而使用 SKIP 属性。它可能会严重损坏生成的 Makefile。只有在真正需要的时候才使用它。</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">通过将元素与 &lt;code&gt;$&quot;&lt;/code&gt; 变量中指定的定界符（ &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; 如果指定为&amp;rdquo; use English;&amp;ldquo;）连接在一起，将数组和切片插入双引号字符串中，默认情况下为空格。</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">数组是零索引的。下面是如何获取数组中的元素。</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">同样,在substr()和index()中的字符串位置也是如此。</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">箭头规则</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">关于软件本地化的文章</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">有关&lt;b&gt;DB_File&lt;/b&gt;或使用它的文章。</target>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;sky AT至关重要的DOT网络&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman，&amp;ldquo;巫师惧怕的地方&amp;rdquo;，2002年6月11日，&lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http：//www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">与&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;或&lt;a href=&quot;../functions/lstat&quot;&gt;lstat一样，&lt;/a&gt;但是如果操作系统和文件系统均支持此类时间戳，则访问/修改/更改文件时间戳的分辨率为亚秒级。要覆盖标准stat（）：</target>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">与&lt;b&gt;-nok一样，&lt;/b&gt;除了它将在较旧的系统上报告。</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">与&lt;b&gt;-ok一样，&lt;/b&gt;除了它将在较旧的系统上报告。</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">作为 &lt;code&gt;$form_name&lt;/code&gt; ，必须提供以下名称之一。</target>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">由于 &lt;code&gt;-Dm&lt;/code&gt; 使用PerlIO层进行输出，因此它本身将分配大量的SV，这些SV被隐藏以避免递归。如果使用 &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; 提供的SV日志记录，则可以绕过PerlIO层。</target>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">由于Perl是由全球志愿者团队开发的,所以我们的文档中经常会出现一些在我们看来很有趣的拼写。</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">由于Storable既不知道也不关心字符集(尽管它知道字符的宽度可能超过8位),因此,主机和目标系统在字符代码的解释上的任何差异都是你的问题。尤其是,如果主机和目标系统使用不同的代码点来表示浮点数字的文本表示,那么即使使用nstore(),也无法交换浮点数据。</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">作为一个初级的Perl程序员,你最常见的OOPerl的使用将是在使用第三方模块,下面将对这些模块进行说明。</target>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">由于 &lt;code&gt;:raw&lt;/code&gt; 通常会弹出图层，因此通常只有将其作为图层规范中的唯一元素或第一个元素才有意义。当用作第一个元素时，它提供了构建的已知基础，例如</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">因此， &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 忽略任何数字或 &lt;code&gt;*&lt;/code&gt; 后， &lt;code&gt;P&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">因此,操作符%的行为与Perl内置的%操作符的行为一致(如perlop手册中所描述的),而等式是</target>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">为方便起见，&lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt;的setsockopt（）方法会将数字转换为打包的字节缓冲区，而getsockopt（）会将正确大小的字节缓冲区解压缩回数字。</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">为了方便起见,如果只传递一个参数,那么这个参数被认为是测试的名称(如上面的例子)。</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">作为调试的辅助手段,你可以强行把呱呱当做告白,把鲤鱼当做对面的线索</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">作为Pod :: Parser的派生类，Pod :: PlainText支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt;。简要地说，用 &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; 创建一个新的解析器，然后调用parse_from_filehandle（）或parse_from_file（）。</target>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Man支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">作为Pod :: Simple的派生类，Pod :: Text支持相同的方法和接口。有关所有详细信息，请参见&lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt;。简要地说，使用 &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; 创建一个新的解析器，然后通常调用parse_file（）。</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">最后,请注意,可以用以下方法填充%subr</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">最后想说的是,请记住,(在写这篇文章的时候)不可能产生一个有用的程序,它将在零时间或负时间内运行,这个基本原则可以写成。</target>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">再举一个例子，这意味着如果您想将这些代码以 &lt;code&gt;C&lt;/code&gt; （代码）样式放置：</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">再举一个例子:在编写本报告时,不支持 &quot;书目 &quot;标识符。在编写本报告时,不支持 &quot;biblio &quot;标识符,但假设编写一些处理程序,将其识别为表示书目参考资料的一种方式(必须包含普通段落的格式代码)。在每个 &quot;书目 &quot;标识符前加一个冒号,就可以表明 &quot;书目 &quot;段落是用于普通处理的。</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">作为进一步的优化，在从 &lt;code&gt;FETCH&lt;/code&gt; 中的eval块退出时，仍在内部循环中继续执行该块之后的代码。引发异常时， &lt;code&gt;docatch&lt;/code&gt; 会将 &lt;code&gt;JMPENV&lt;/code&gt; 级别与 &lt;code&gt;CxEVAL&lt;/code&gt; 进行 &lt;code&gt;PL_top_env&lt;/code&gt; ，如果它们不同，则仅重新引发该异常。这样，任何内部循环都会弹出。</target>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">一般来说,你的提交信息应该能够帮助了解 Perl 核心的程序员快速理解你要做什么,你是如何做的,以及为什么这个改变对 Perl 很重要。</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">一般情况下,你应该</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">通常，如果模块试图面向对象，则不导出任何内容。如果只是函数的集合，则 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 除了使用 &lt;code&gt;@EXPORT&lt;/code&gt; 时要小心。对于函数名和方法名，在导出列表中使用裸字优先于以&amp;ldquo;＆&amp;rdquo;开头的名称。</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">一般来说,如果模块想面向对象,那么什么都不要导出。如果它只是一个函数的集合,那么@EXPORT_OK什么都可以,但是要谨慎使用@EXPORT。</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">通常，如果模块试图面向对象，则不要导出任何内容。如果它只是函数和变量的集合，则可以通过另一个数组 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 导出它们。除非用户明确要求这样做，否则该数组不会自动将其子例程和变量名放入名称空间。</target>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">然而,作为最后的手段。</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">作为最后的手段,你可以使用perl单行本。</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">作为最后的选择，您还可以使用 &lt;code&gt;PERL5DB&lt;/code&gt; 通过直接设置内部变量或调用调试器函数来定制调试器。</target>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">作为名词，一种语法由较小的部分组成。作为及物动词，使用&lt;b&gt;构造函数&lt;/b&gt;创建&lt;b&gt;对象&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">由于这些问题,从v5.20开始,Perl所做的是将非Unicode码点视为典型的未分配Unicode字符,并进行相应的匹配。(注:Unicode有非典型的未分配码点。例如,它有一些非字符码点,而且当它们被分配时,注定要从右到左书写,就像阿拉伯语和希伯来语一样。Perl假设非Unicode码点没有任何非典型属性)。)</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">结果， &lt;code&gt;$?&lt;/code&gt; 如果子进程的退出状态指示成功完成，则将始终为零；如果发生警告或错误，或者运行了符合_POSIX_EXIT编码值的程序并设置了状态，则该值将始终为零。</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">作为一个标量运算符。</target>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">作为快捷方式 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 可以写为 &lt;code&gt;(*:NAME)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">作为一个快捷方式,单参数调用从与文件柄同名的全局标量变量中获取文件名。</target>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">作为快捷方式，您可以使用模块&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">副作用是，由于 &lt;code&gt;_&lt;/code&gt; 不起作用，所以堆栈 &lt;code&gt;-f -w $file&lt;/code&gt; 测试运算符（-f -w $ file）也将不起作用。</target>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">作为副作用，呼叫键（）复位的HASH或ARRAY的内部迭代（见&lt;a href=&quot;#each&quot;&gt;各&lt;/a&gt;）。特别是，在void上下文中调用keys（）会重置迭代器，而不会产生其他开销。</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">作为副作用，呼叫键（）复位的HASH或ARRAY的内部迭代（见&lt;a href=&quot;each&quot;&gt;各&lt;/a&gt;）。特别是，在void上下文中调用keys（）会重置迭代器，而不会产生其他开销。</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">作为副作用，调用values（）会重置HASH或ARRAY的内部迭代器，请参见&lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;。 （特别是，在void上下文中调用values（）不会重置其他迭代器。除了重置迭代器之外，列表上下文中的 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;值&lt;/a&gt;与普通 &lt;code&gt;@array&lt;/code&gt; 相同。（我们建议您使用void上下文 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 为此，但是有理由认为，将 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;functions/values&quot;&gt;值&lt;/a&gt;取出来比将其保留下来需要更多的文档。）</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">作为副作用，调用values（）会重置HASH或ARRAY的内部迭代器，请参见&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;。 （特别是，在void上下文中调用values（）不会重置其他迭代器。除了重置迭代器之外，列表上下文中的 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;与普通 &lt;code&gt;@array&lt;/code&gt; 相同。（我们建议您使用void上下文 &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; 为此，但是有理由认为，将 &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; &lt;a href=&quot;values&quot;&gt;值&lt;/a&gt;取出来比将其保留下来需要更多的文档。）</target>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">作为一种特殊情况</target>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的一种特殊情况，&lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;匹配运算符&lt;/a&gt;语法（ &lt;code&gt;//&lt;/code&gt; ）中给出的空模式专门匹配空字符串，这与通常将其解释为最后一次成功匹配相反。</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">作为 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 的一种特殊情况，&lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;匹配运算符&lt;/a&gt;语法（ &lt;code&gt;//&lt;/code&gt; ）中给出的空模式专门匹配空字符串，这与通常将其解释为最后一次成功匹配相反。</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">在特殊情况下，如果重载返回对象本身，则将直接使用它。返回该对象的重载转换可能是一个错误，因为您可能会看到类似 &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">作为特殊情况，具有读/写模式的三参数形式，而第三参数为 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">作为特殊情况，具有读/写模式的三参数形式，而第三参数为 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">作为一种特殊情况， &lt;code&gt;\(@foo)&lt;/code&gt; 返回一个对 &lt;code&gt;@foo&lt;/code&gt; 内容的引用列表，而不是对 &lt;code&gt;@foo&lt;/code&gt; 本身的引用。与 &lt;code&gt;%foo&lt;/code&gt; 相似，除了键引用是对副本的引用（因为键只是字符串而不是完整的标量）。</target>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">作为一种特殊情况，如果 &lt;code&gt;for&lt;/code&gt; 循环（或相应的 &lt;code&gt;while&lt;/code&gt; 循环）中的测试为空，则将其视为true。也就是说，两者</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">作为特殊情况，如果此变量的值以空格分隔，则可以通过将尾部设置为 &lt;code&gt;o=0&lt;/code&gt; 或 &lt;code&gt;ornaments=0&lt;/code&gt; 来使用尾部来禁用装饰。头部应该如上所述，例如</target>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">作为特殊情况，如果指定模块名称 &lt;code&gt;Unicode&lt;/code&gt; ，则将获得与请求的perl版本捆绑在一起的Unicode字符数据库的版本号。</target>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">作为一种特殊的情况,当调用访问器时,将哈希引用作为唯一的参数,这会导致整个哈希元素的赋值。对象引用会被返回。</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">作为一种特殊情况,当访问器被调用时,唯一的参数是一个数组引用,这会导致整个数组元素的赋值。对象引用被返回。</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">作为一个特殊的例外,当你对一个列表(但不是数组或哈希)进行分片时,如果列表评估为空,那么对这个空列表进行分片总是会反过来产生空列表。因此。</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">作为供应商，您可能需要将安全修复程序反向移植到我们3年的支持承诺范围之外。我们会在您这样做时为您提供有限的支持和建议，并且在可能的情况下，我们将尝试将这些补丁应用于git中相关的-maint分支，尽管我们可能会或可能不会选择提供编号的发行版或&amp;ldquo;官方&amp;rdquo;补丁。通过&amp;lt;perl5-security-report@perl.org&amp;gt;与我们联系以开始该过程。</target>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">作为一个志愿者组织,我们所做的承诺在很大程度上依赖于那些没有义务为 Perl 做贡献的个人的善意和努力工作。</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">同上,但链接的目的节点文字。</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">当所有值均评估为true时，简单的 &lt;code&gt;if&lt;/code&gt; 测试足以确定是否存在扩展。</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">如前所述,如果内联子的主体由一个没有其他引用的词法范围标量组成,你也可以在begin时动态声明内联子。这里只有第一个例子会被内联。</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">作为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的替代 当用于控制流时，Perl提供 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运算符（请参见下文）。短路行为是相同的。但是， &lt;code&gt;&quot;and&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 的优先级要低得多，因此您可以在列表运算符之后安全地使用它们，而无需括号：</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">和Perl一样,有不止一种方法可以做到。下面是一些在数字表示法之间进行常见转换的方法的例子。这是为了表示而不是详尽的。</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">和往常一样,如果有任何一个被官方宣布为bug,它们将被修复和删除。</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">与往常一样，设置服务器比运行客户端要复杂得多。该模型是服务器创建一种特殊的套接字，该套接字除了在特定端口上侦听传入连接外什么也不做。它通过调用 &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; 方法来实现此目的，该方法的参数与客户端的参数略有不同。</target>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">作为一个额外的方便,Digest::SHA模块提供了使用HMAC-SHA-1/224/256/384/512算法计算密钥哈希的例程。这些服务仅以功能形式存在,并且模仿了HMAC-SHA-1/224/256/384/512算法的风格和行为。</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">作为重置颜色的辅助工具,colored()将一个标量作为第一个参数,将任意数量的属性字符串作为第二个参数,并返回用转义码包装的标量,这样属性将在字符串之前按要求设置,并在字符串之后重置为正常。或者,你可以传递一个数组的引用作为第一个参数,然后这个数组的内容将被当作属性和颜色代码,其余的参数将被当作文本进行着色。</target>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">作为上述方法的替代方案,你可能更喜欢使用Error模块来抛出异常。</target>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">作为替代，重载常量（请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;）提供了一种简单的方法，可以通过用一种模式替换另一种模式来扩展RE引擎的功能。</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">或者，指定数字而不是字母列表（例如，&lt;b&gt;-D14&lt;/b&gt;等效于&lt;b&gt;-Dtls&lt;/b&gt;）：</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">作为一个替代方案,如果替换的单词比原来的单词长,你可以使用Jeff Pinyan的这个代码来保留它的大小写。</target>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">例如，模式在 &lt;code&gt;&quot;strict'&lt;/code&gt; 下被捕获，但在其他情况下没有被捕获</target>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">以这种情况为例,这段代码打印了 &quot;Perl退出,有活动线程。2个线程正在运行且未连接&quot;。</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">作为一个适合使用占位定量符的例子,我们考虑匹配一个引号字符串,因为它出现在几种编程语言中。反斜杠作为一个转义字符,表示下一个字符将被按字面意思理解,作为字符串的另一个字符。因此,在开头的引号之后,我们希望有一个(可能是空的)替代序列:除了未转义的引号或反斜线或转义字符之外的一些字符。</target>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">例如，当Perl看到 &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; ，它将字符编码为UTF-8并将其存储在$ x中。然后将其标记为字符数据，例如， &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。但是，在 &lt;code&gt;bytes&lt;/code&gt; 编译指示的范围内，$ x被视为一系列字节-组成UTF8编码的字节- &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; 返回 &lt;code&gt;2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">作为一项临时措施,你可以修改你的脚本中的#!行来特别引用旧的perl版本,例如在Solaris 9上使用#!/usr/perl5/5.00503/bin/perl来使用Solaris 8的默认perl版本,或者如果你有大量的脚本,将旧版本的perl作为系统的默认版本可能会更方便。您可以通过修改/usr/perl5下的相应符号链接来实现这一目的,具体如下(Solaris 9的例子)。</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">作为优化，不得调用 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 指定的命令外壳。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; 产生一个外部进程并立即返回其进程指示符，而无需等待其终止。随后可以在 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 中使用返回值。设置 &lt;code&gt;$?&lt;/code&gt; 表示未能 &lt;code&gt;spawn()&lt;/code&gt; 子进程。改为 &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; 。 &lt;code&gt;$?&lt;/code&gt; 设置与Unix兼容的方式（即子进程的exitstatus通过 &lt;code&gt;&quot;$?&lt;/code&gt; 8&amp;rdquo; &amp;gt;&amp;gt;获得，如文档中所述）。 （Win32的）</target>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">作为另一种特殊情况，当省略PATTERN或使用a时， &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 模拟命令行工具&lt;b&gt;awk&lt;/b&gt;的默认行为。</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">作为另一种特殊情况，当省略PATTERN或使用a时， &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 模拟命令行工具&lt;b&gt;awk&lt;/b&gt;的默认行为。</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">作为解决此问题的另一种方法，Perl 5.10.0引入了 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，它们等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; ，&lt;b&gt;只是&lt;/b&gt;它们只能保证在使用 &lt;code&gt;/p&lt;/code&gt; （保留）修饰符执行的成功匹配之后定义。与标点字符等效项不同，使用这些变量不会引起全局性能损失，但是要权衡取舍，当您要使用它们时必须告诉perl。从Perl 5.20开始，这三个变量等效于 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$&amp;amp;&lt;/code&gt; 和 &lt;code&gt;$'&lt;/code&gt; 以及 &lt;code&gt;/p&lt;/code&gt; 被忽略。</target>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">如所描述的&lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;上面&lt;/a&gt;，Perl中可能需要运营商等方法 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;&amp;amp;&lt;/code&gt; 在执行像丢失操作过程 &lt;code&gt;++&lt;/code&gt; ， &lt;code&gt;+=&lt;/code&gt; ，和 &lt;code&gt;&amp;amp;=&lt;/code&gt; 。尽管这些方法可以通过测试第三个参数的定义来检测这种用法，但它们在所有情况下都应避免更改其操作数。这是因为Perl在调用这些方法之前不会调用复制构造函数。</target>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">正如在其他地方所讨论的那样,Perl 在两个世界中各安插了一只脚(两只蹄子?):旧世界的 ASCII 和单字节编码,以及新世界的 Unicode,并在必要时进行升级。如果你的遗留代码没有明确使用Unicode,就不应该自动切换到Unicode。</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">如上所述,一个匿名函数在编译时可以访问该函数可见的词法变量,它创建了一个闭包。它保留了对这些变量的访问权,即使它直到后来才被运行,比如在信号处理程序或Tk回调中。</target>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">如&lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII规则和Unicode规则中所述&lt;/a&gt;，在ASCII规则下，它们被视为未分配的字符。</target>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">如&lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist（）中所述&lt;/a&gt;，代码点是否在列表中取决于索引是偶数（in）还是奇数（not in）。并且如&lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap（）&lt;/a&gt;中所述，索引与返回的并行数组一起使用以查找映射。</target>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">对于其他操作，实现'='的子例程传递了三个参数，尽管最后两个始终是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;''&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">好像所有这些类还不够，Perl还定义了POSIX样式的字符类。这些具有形式 &lt;code&gt;[:name:]&lt;/code&gt; ，具有 &lt;code&gt;name&lt;/code&gt; 的POSIX类的名称。 POSIX类是 &lt;code&gt;alpha&lt;/code&gt; ， &lt;code&gt;alnum&lt;/code&gt; ， &lt;code&gt;ascii&lt;/code&gt; ， &lt;code&gt;cntrl&lt;/code&gt; ， &lt;code&gt;digit&lt;/code&gt; ， &lt;code&gt;graph&lt;/code&gt; ， &lt;code&gt;lower&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;punct&lt;/code&gt; ， &lt;code&gt;space&lt;/code&gt; ， &lt;code&gt;upper&lt;/code&gt; 和 &lt;code&gt;xdigit&lt;/code&gt; ，以及两个扩展名： &lt;code&gt;word&lt;/code&gt; （匹配 &lt;code&gt;\w&lt;/code&gt; 的Perl扩展名）和 &lt;code&gt;blank&lt;/code&gt; （GNU扩展名） ）。该 &lt;code&gt;//a&lt;/code&gt; 修饰符将它们限制为仅在ASCII范围内匹配；否则它们可以在同一匹配它们相应的Perl的Unicode类： &lt;code&gt;[:upper:]&lt;/code&gt; 是相同的 &lt;code&gt;\p{IsUpper}&lt;/code&gt; ，等。（有一些例外和陷阱与此;参见&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;一个完整的讨论。）的 &lt;code&gt;[:digit:]&lt;/code&gt; ， &lt;code&gt;[:word:]&lt;/code&gt; 和 &lt;code&gt;[:space:]&lt;/code&gt; 对应于熟悉的 &lt;code&gt;\d&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\s&lt;/code&gt; 字符类。要取消POSIX类，请在名称前加上 &lt;code&gt;^&lt;/code&gt; ，以便 &lt;code&gt;[:^digit:]&lt;/code&gt; 对应于 &lt;code&gt;\D&lt;/code&gt; ，而在Unicode下则对应 &lt;code&gt;\P{IsDigit}&lt;/code&gt; 。Unicode和POSIX字符类可以像 &lt;code&gt;\d&lt;/code&gt; 一样使用，但POSIX字符类只能在字符类内部使用：</target>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">如上所述，通过 &lt;code&gt;%ENV&lt;/code&gt; 访问的环境是全局的，并且约定是特定于程序的环境变量的形式为 &lt;code&gt;Program$Name&lt;/code&gt; 。每个文件系统都维护一个当前目录，而当前文件系统的当前目录是&lt;b&gt;全局&lt;/b&gt;当前目录。因此，社交程序不会更改当前目录，而是依赖完整的路径名，并且程序（和Makefiles）不能假定它们可以生成可以更改当前目录而不影响其父目录（以及其他所有人）的子进程。 。</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">就像在某些shell中一样,你可以将变量名用大括号括起来,以便与后面的字母数字(和下划线)区分开来。当你把一个变量插值到一个字符串中时,你也必须这样做,以便把变量名与后面的双引号或省略号分开,因为它们会被当作包的分隔符。</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">就目前而言,它比version.pm更早,但有同样的目标:使版本字符串可见且可比较。</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">顾名思义，如果您的代码遇到了强制性警告，则无论您是否需要它都会收到警告。例如，下面的代码将始终产生有关&amp;ldquo; 2：&amp;rdquo;的&amp;ldquo; &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; 警告。</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">如前所述，默认情况下，所有变量都是线程局部的。要使用共享变量，您还需要加载&lt;a href=&quot;threads/shared&quot;&gt;thread :: shared&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">由于锁是咨询性的,它们并不能阻止另一个线程访问或修改数据,而这个线程本身并没有试图获得变量的锁。</target>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某些输出，即使该输出包含勘误表（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 部分），&lt;b&gt;pod2man&lt;/b&gt;也将以状态0退出。如果任何正在处理的文档都不会导致输出文档，&lt;b&gt;pod2man&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中存在语法错误，并且错误处理样式设置为默认值 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，则&lt;b&gt;pod2man&lt;/b&gt;将立即退出，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">只要所有已处理的文档都产生某些输出，即使该输出包含勘误（使用 &lt;code&gt;--errors=pod&lt;/code&gt; 生成的 &lt;code&gt;POD ERRORS&lt;/code&gt; 节），&lt;b&gt;pod2text&lt;/b&gt;也会以状态0退出。如果任何正在处理的文档都不会导致输出文档&lt;b&gt;pod2text&lt;/b&gt;将以状态1退出。如果正在处理的POD文档中存在语法错误，并且错误处理样式设置为默认值 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ，则&lt;b&gt;pod2text&lt;/b&gt;将立即终止，退出状态为255。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">只要这个引用从未被模块内的任何函数返回,任何外部模块都无法看到这个子程序,因为它的名字不在任何包的符号表中。请记住,它不是</target>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">如所提到的&lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;上面&lt;/a&gt;，当增变被施加到参考该操作被称为共享其与一些其它参考对象。例如，如果 &lt;code&gt;$b&lt;/code&gt; 是数学的，并且 &lt;code&gt;'++'&lt;/code&gt; 被 &lt;code&gt;'incr'&lt;/code&gt; 重载，并且 &lt;code&gt;'='&lt;/code&gt; 被 &lt;code&gt;'clone'&lt;/code&gt; 重载，则代码</target>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">如上文在&lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;下所述，Unicode 6.1为某些代码点定义了额外的名称（同义词或别名），其中大多数已作为Perl扩展提供。 &lt;code&gt;\N{...}&lt;/code&gt; 和该模块中的其他功能都接受所有这些，但是要通过 &lt;code&gt;viacode&lt;/code&gt; 必须为给定的输入代码点选择要返回的名称，因此它返回&amp;ldquo;最佳&amp;rdquo;名称。要了解它是如何工作的，更多地了解Unicode名称属性将很有帮助。实际上，所有代码点都只有一个名称，一旦将字符分配给代码点，该名称（从Unicode 2.0开始）将永远不会更改。但是在分配名称时出现了错误，例如，有时在标准发布期间发生了文书错误，导致单词拼写错误，并且无法纠正这些错误。最终创建了Name_Alias属性来处理这些情况。如果名称错误，将使用Name_Alias为它发布更正的同义词。 &lt;code&gt;viacode&lt;/code&gt; 将返回该更正的同义词作为代码点的&amp;ldquo;最佳&amp;rdquo;名称。 （即使还没有发生，甚至有可能需要更正本身，因此可以为该代码点创建另一个Name_Alias； &lt;code&gt;viacode&lt;/code&gt; 将返回最近的更正。）</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">如上所述，UTF-8使用可变数量的字节来存储字符。值0 ... 127的字符存储在一个字节中，就像ASCII一样。字符128被存储为 &lt;code&gt;v194.128&lt;/code&gt; ;这一直持续到字符191，即 &lt;code&gt;v194.191&lt;/code&gt; 。现在我们已经用完了（191是二进制 &lt;code&gt;10111111&lt;/code&gt; ），所以我们继续；字符192是 &lt;code&gt;v195.128&lt;/code&gt; 。如此下去，移动到字符2048处的三个字节&lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;。perlunicode中的Unicode编码&lt;/a&gt;提供了有关其工作原理的图片。</target>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">如上所述,在Perl中,你可以通过使用</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">正如本文档顶部所提到的,如果你在使用这些示例扩展时遇到了问题,你可以看看这些是否对你有帮助。</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">如前所述,Perl可以用三种格式中的任何一种来存储一个数字,但大多数运算符通常只理解其中的一种格式。当一个数值作为参数传递给这样的运算符时,它将被转换为运算符理解的格式。</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">如前所述，可以将&amp;ldquo;回调&amp;rdquo;键添加到 &lt;code&gt;TAP::Parser&lt;/code&gt; 构造函数。如果存在，则使用给定结果类型的每个回调将被调用，并且如果使用 &lt;code&gt;run&lt;/code&gt; 方法，则将结果作为参数。该回调应该是一个子例程引用（或匿名子例程），该引用将以解析器结果作为其参数来调用。</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">如前所述，在默认引擎的情况下， &lt;code&gt;pprivate&lt;/code&gt; 将是指向regexp_internal结构的指针，该结构保存已编译的程序以及regex引擎实现专用的任何其他数据。</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">如&lt;a href=&quot;../encode&quot;&gt;Encode中所述&lt;/a&gt;，编码（至少在当前实现中）被定义为对象。编码名称到对象的映射是通过 &lt;code&gt;%Encode::Encoding&lt;/code&gt; 哈希值进行的。尽管您可以直接操纵此哈希，但强烈建议您使用此基类模块并添加encode（）和encode（）方法。</target>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">正如上一条所提到的,当在Unix和Macintosh之间使用socket I/O时,这仍然是行不通的。在这种情况下,你需要硬编码你的行结束符。</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">如前所述,动态加载目前还没有,MakeMaker也没有。两者都是高优先级的项目。</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">如前所述，如果代码点的名称未知，该函数将返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。在Unicode中，这些名称的正确名称是空字符串， &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 定义为该字符串。（如果您请求的代码点超出了未为其指定别名的合法Unicode最大U + 10FFFF，则将得到 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 加警告。）</target>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">由于错误流的大多数剩余预期输出将由&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;的 &lt;code&gt;diag&lt;/code&gt; 函数创建，因此&lt;a href=&quot;tester&quot;&gt;Test :: Builder :: Tester&lt;/a&gt;提供了一个便捷函数 &lt;code&gt;test_diag&lt;/code&gt; ，您可以使用它代替 &lt;code&gt;test_err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">如上所述,如果文件还不存在,那么append-mode open将为你创建它。但如果文件确实已经存在,它的内容就不会受到伤害,因为你将在旧文本的结尾处添加新文本。</target>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">如本文前面所述,列表赋值的标量意义是赋值右侧的元素数。空列表不包含任何元素,所以当密码文件用完后,结果是0,而不是2。</target>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">如&lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES中&lt;/a&gt;所述，当 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 语言环境生效时， &lt;code&gt;cmp&lt;/code&gt; 会根据当前的整理语言环境进行比较，但会回退到语言环境相等的字符串的逐字符比较。如果您不希望发生这种情况，可以使用 &lt;code&gt;POSIX::strcoll()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">如&lt;a href=&quot;perlhack#TESTING&quot;&gt;perlhack的TESTING中所述&lt;/a&gt;，编写测试脚本时，该文件</target>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">从1.37_02开始，install（）支持使用一系列模式来过滤掉不应安装的文件。如果$ skip被省略或未定义，则安装将尝试从CWD中的INSTALL.SKIP中读取列表。该文件是一个正则表达式列表，就像&lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt;使用的MANIFEST.SKIP文件一样。</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">从3.10开始,所有类型代码的内部数据都可以修改。</target>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">从5.14版本开始，如果您的平台不支持它们，则没有一个会引发异常。但是，如果启用了警告，则会在不支持的转换标志上发出 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告类的警告。如果您更喜欢例外，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">从5.14版本开始，如果您的平台不支持它们，则没有一个会引发异常。但是，如果启用了警告，则会在不支持的转换标志上发出 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 警告类的警告。如果您更喜欢例外，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">从5.14开始,也可以这样写。</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">从5.19.9开始，将 &lt;code&gt;$/&lt;/code&gt; 设置为任何其他形式的引用将引发致命异常。这是为支持将来设置 &lt;code&gt;$/&lt;/code&gt; 新方法做准备。</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">从5.8.1开始,如果你使用Sun编译器,长倍数就可以工作了(libm中没有包含的额外数学例程需要)。</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">从5.8.1开始，&lt;b&gt;-C&lt;/b&gt;后面可以跟数字或选项字母列表。字母，它们的数值和效果如下：列出字母等于将数字相加。</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版开始，伪指令 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; re'debug '及其等效项在词法范围内，其他伪指令也是如此。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">从5.9.5版本开始，该指令 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; re'debug '及其等效项与其他指令一样在词法范围内。但是，它们同时具有编译时和运行时效果。</target>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">从 &lt;code&gt;Encode&lt;/code&gt; 2.12开始， &lt;code&gt;CHECK&lt;/code&gt; 也可以是一个代码引用，它以未映射字符的序数值作为参数并返回代表后备字符的八位字节。例如：</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">从 &lt;code&gt;Encode&lt;/code&gt; 版本2.21开始，因此添加了新方法 &lt;code&gt;mime_name()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">从CPAN 1.9463开始，如果您无权编写默认的perl库目录，则CPAN的配置过程将询问您是否要引导&amp;lt;local :: lib&amp;gt;，这使保持个人perl库目录变得容易。</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">从Encode 1.87开始,老式的</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">从2002年7月开始（Perl版本5.8.0），以下平台能够从&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/上&lt;/a&gt;提供的标准源代码发行版中构建Perl 。</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">从Perl 5.10开始，可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 变量。仅当存在 &lt;code&gt;/p&lt;/code&gt; 修饰符时才设置。因此，它们不会惩罚程序的其余部分。在Perl 5.20中，无论是否使用 &lt;code&gt;/p&lt;/code&gt; （忽略修饰符），都可以使用 &lt;code&gt;${^PREMATCH}&lt;/code&gt; ， &lt;code&gt;${^MATCH}&lt;/code&gt; 和 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; ，而 &lt;code&gt;$`&lt;/code&gt; ， &lt;code&gt;$'&lt;/code&gt; 和 &lt;code&gt;$&amp;amp;&lt;/code&gt; 则不可用造成任何速度差异。</target>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">从Perl 5.10开始，此编译指示在词法范围内有效，并在编译时生效。在早期版本中，它的影响是全局的，并在运行时生效。该文档建议使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 来更改行为：</target>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">从Perl 5.10开始，您可以使用递归模式将平衡文本与正则表达式匹配。在Perl 5.10之前，您必须诉诸各种技巧，例如在 &lt;code&gt;(??{})&lt;/code&gt; 序列中使用Perl代码。</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">从Perl 5.10.0开始,Perl支持几种Python/PCRE专用的扩展来扩展regex语法。我们鼓励Perl程序员使用Perl特有的语法,同时也接受以下语法。</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">从Perl 5.10.0开始，作为一种纯粹的语法糖，您可以使用 &lt;code&gt;-f -w -x $file&lt;/code&gt; 等效于 &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; 的方式来堆叠文件测试运算符。（这只是花哨的语法：如果将 &lt;code&gt;-f $file&lt;/code&gt; 的返回值用作另一个filetest运算符的参数，则不会发生特殊的魔术。）</target>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">从Perl 5.10.0开始，可以创建自定义正则表达式引擎。这不是出于胆小，因为他们必须在C级别插入。有关更多详细信息，请参见&lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">从Perl 5.10.0开始，还可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 修饰符强制使用大尾数字节顺序。例如，如果要存储带符号整数或64位整数，此功能将非常有用。</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">从 Perl 5.10.1 开始,有了一个新的接口,用于插入和使用除默认值(线性深度优先搜索)以外的方法解析顺序。5.10.0中添加的C3方法解析顺序已经作为一个插件重新实现,而没有改变它的Perl空间接口。</target>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.12开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.12开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸 &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; ，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">从Perl 5.12开始,废弃的功能和模块在使用时都会向用户发出警告。当一个模块被弃用时,它也会在CPAN上被提供。从CPAN上安装它,将使该模块的废弃警告沉默。</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">从Perl 5.18开始,每个哈希都有自己的哈希遍历顺序,而且这个顺序在每次有新元素插入哈希时都会改变。这个功能是通过维护一个无符号整数掩码 (U32)来提供的,这个掩码在使用 keys()、value()或 each()对哈希桶进行遍历时与实际的桶 ID 进行 xor'ed。</target>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.18开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸露的 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 循环，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">从Perl 5.18开始，您可以在 &lt;code&gt;while&lt;/code&gt; 循环中使用裸露的 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 循环，这将在每次迭代中设置 &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">从Perl 5.20开始，代替 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 您可以使用：</target>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">从Perl 5.22开始，此循环有一个实验变体，它接受一个变量，在VAR之前加一个反斜杠，在这种情况下，LIST中的项目必须是引用。反斜杠变量将成为LIST中每个引用项目的别名，该项目的类型必须正确。在这种情况下，变量不必是标量，反斜杠后面可以加上 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。要使用此表单，您必须通过 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; feature启用 &lt;code&gt;refaliasing&lt;/code&gt; 功能。 （请参阅&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;。另请参见&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;在perlref中分配给引用&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">从Perl 5.22开始,这种错误的行为虽然是为了向后兼容而保留的,但会被检测到并发出废弃警告。如果你想让子程序内联(没有警告),请确保变量没有被用于除了声明的地方之外的其他地方。</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">从Perl 5.22开始，您还可以使用 &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; 代替 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。（您也可以执行 &lt;code&gt;($x) x 2&lt;/code&gt; ，这没什么用，因为它两次分配给同一变量两次，破坏了第一个分配的值。）</target>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">在Perl 5.6中,你可以用标量变量来表示filehandle,你可以像对待其他标量一样对待它。</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">从使用此模块的Perl 5.8.0开始，您不能将隐式 &lt;code&gt;$_&lt;/code&gt; 或特殊文件句柄 &lt;code&gt;_&lt;/code&gt; 与stat（）或lstat（）一起使用，尝试这样做会导致奇怪的错误。解决方法是使 &lt;code&gt;$_&lt;/code&gt; 明确</target>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">在Perl 5.8.0中,&quot;Full &quot;的大小写折叠为</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">从Perl 5.8.0开始，您可以将 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 与多个参数一起使用。就像 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; 的列表形式一样，不会发生外壳转义。</target>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">在Perl 5.8.1中,动态加载库(DynaLoader、XSLoader)的功能在SunOS 4.x中似乎也被破坏了,因此默认是静态地构建Perl。</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">从Perl 5.8.1开始，&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;还具有 &lt;code&gt;utf8::is_utf8&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">在Perl 5.9.5中,除了默认的正则表达式引擎外,还有一个新的接口用于插入和使用正则表达式引擎。</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">从Perl Symbian 0.4.1版本开始,Perl标准回归测试套件的任何部分都没有在使用移植Perl的真实Symbian设备上运行过,所以可能会有无数的错误在等待。因此,我们绝对不作任何保证。</target>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">从Perl v5.16.0开始，它由&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;模块实现。有关其行为的更多详细信息，请参见&lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">从OSS的R2.5 / OS / 390版本和VM / ESA的2.3版开始，这些Unix子系统不支持 &lt;code&gt;#!&lt;/code&gt; shebang脚本调用技巧。因此，在OS / 390和VM / ESA上，可以使用类似于以下简单脚本的标头执行Perl脚本：</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">在Unicode 6.0中,这个值总是空的。</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">从 1.18 版开始,所有 IO::Socket 对象的自动刷新功能默认为开启。在早期的版本中不是这样的。</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">从db-4.2.x开始,不再需要手工操作了。Sleepycat已经改变了配置过程,在HP-UX上自动添加+z。</target>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">从perl 5.14开始，可以使用 &lt;code&gt;Perl_blockhook_register&lt;/code&gt; 挂接到编译时词法范围机制。这样使用：</target>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">从perl 5.9.5开始,'re'debug包含了一些实用函数,这些函数可以选择导出到调用者的命名空间中。下面列出了这些函数。</target>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">从 perl5.6 开始,如果你传给它一个未初始化的标量变量,open()会自动将文件和目录句柄作为引用。然后你可以像传递其他标量一样传递这些引用,并在命名句柄的位置使用它们。</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">从perl5.7.2开始,所有的测试都通过了下。</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">截止到perl5.8.1,至少还有一个测试失败。</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">从Perl的第5版开始，分配给 &lt;code&gt;$[&lt;/code&gt; 被视为编译器指令，并且不会影响任何其他文件的行为。（这就是为什么您只能为其分配编译时常量的原因。）强烈建议不要使用它。</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">从5.003_01版本开始,perl与多线程的C RTL DLL链接。如果perl本身没有编译为多线程启用,所以不会被perl的malloc()。但是,扩展可以使用多线程,风险自负。</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">目前,如果路径是绝对的,有体积,则返回2,如果是绝对的,没有体积,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">截至本文档最后一次更新之日,以下系统包含PA-RISC 2.0芯片。</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">截至本文档发布之日,Perl在HP-UX 11.00及以上版本的cc-和gcc构建中已经完全兼容64位。如果你准备用GNU gcc构建64位的Perl,请仔细阅读gcc部分。</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">在本文档最后一次修订时,下列 Perl 函数在 Perl 的 VMS port 中实现了(标有*的函数将在下面详细讨论)。</target>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">在5.14版本中,Perl区分了三个UTF-8警告的子类。</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">从v5.18.0开始， &lt;code&gt;%ENV&lt;/code&gt; 中存储的键和值都被字符串化。</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">从AutoSplit模块的1.01版本开始,它可以在一个文件中拥有多个包。支持以下两种情况。</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">从1.02版开始（由Perl 5.12提供），该对象提供了 &lt;code&gt;&quot;-X&quot;&lt;/code&gt; 重载，因此您可以在其上调用文件测试运算符（ &lt;code&gt;-f&lt;/code&gt; ， &lt;code&gt;-x&lt;/code&gt; 等）。它还提供了 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; 方法，称为</target>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">从1.04版本(Perl 5.10)开始,strict验证了它是作为 &quot;strict &quot;来使用的,以避免在对大小写不敏感的文件系统上出现可怕的Strict陷阱。</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">从本模块的1.32版本开始,常量可以在调用者之外的包中定义,只要在常量的名称中加入包名即可。</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">从1.47版本开始,安装界面增加了以下内容。请注意,建议使用新的参数样式和%result hash。</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">从2.12版开始， &lt;code&gt;Encode&lt;/code&gt; 支持 &lt;code&gt;CHECK&lt;/code&gt; 的 coderef值；见下文。</target>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">从2.32版本开始,Getopt::Long提供了自动帮助,这是一种快速和简单的方法,可以将选项--help和--?添加到你的程序中,并处理它们。</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">从5.00305版本开始,OS/2 perl二进制发行版被分成了11个组件。不幸的是,为了实现可配置的二进制安装,压缩文件中的文件路径不是绝对的,而是相对于某个目录的。</target>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">从5.12.0版本开始,perl已经不再使用它所运行的操作系统的底层时间库,而是有了自己的这些例程的实现,安全范围至少是+/2**52(约1.42亿年)。</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">截至编写本报告时(2010-09),只有</target>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">根据&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;，在标量上下文中，它应该返回下一行，或者为没有更多数据的 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。在列表上下文中，它应该返回所有剩余的行，或者返回一个空列表以容纳更多数据。返回的字符串应包括输入记录分隔符 &lt;code&gt;$/&lt;/code&gt; （请参阅&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;），除非它是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （表示&amp;ldquo; slurp&amp;rdquo;模式）。</target>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">和get()一样,但返回一个绑定的文件柄。从这个filehandle中读取会返回请求的消息。该filehandle将在消息结束时返回EOF,不应重复使用。</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">由于perl没有使用它,所以不好测试。</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">与其他模块一样， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; 实现为模块时，请使用 myint；变成</target>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">如前所述，&amp;ldquo;开关&amp;rdquo;功能被认为是高度实验性的。它可能随时更改，恕不另行通知。特别是， &lt;code&gt;when&lt;/code&gt; 具有棘手的行为，并且这种行为有望在将来变得越来越棘手。不要依赖它的当前（错误）实现。 Perl的5.18之前， &lt;code&gt;given&lt;/code&gt; 也有棘手的行为，你还是应该提防如果你的代码必须在旧版本的Perl的运行。</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">如前所述,单个条目(而不是整个哈希)是可以设置的。Perl在这里只关心布尔值true,虽然</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">作为设置,考虑这个(公认的相当造作的)平局的例子;它所做的就是使用一个文件来保存分配给一个标量的值的日志。</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">在出厂时,唯一提供的命令行历史记录是一个简单的检查前导感叹号的记录。然而,如果您安装了 CPAN 的 Term::ReadKey 和 Term::ReadLine 模块 (如 Term::ReadLine::Gnu,Term::ReadLine::Perl,...),您将拥有完整的编辑功能,就像那些 GNU 的模块一样。</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">如上图所示,无论是否真的改变了任何输出,Perl都会创建备份文件。所以这只是一种花哨的复制文件的方式。</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">如本例所示， &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 不受&amp;ldquo;看起来像函数&amp;rdquo;规则的约束。它后面的一对括号不会（必要）界定其参数。 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 。此外，与大多数命名运算符不同，此优先级与赋值相同。</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">如本例所示， &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; 不受&amp;ldquo;看起来像函数&amp;rdquo;规则的约束。它后面的一对括号不会（必要）界定其参数。 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; 。此外，与大多数命名运算符不同，此优先级与赋值相同。</target>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">这样，通常不适合在 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 命令中使用的信号（例如， &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ）可以与 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 方法一起使用（同样，如上所示） 。</target>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">由于系统库(最主要的是glibc)也会触发错误,valgrind允许使用抑制文件来抑制这些错误。valgrind默认的抑制文件已经捕捉到了很多错误。一些额外的抑制文件被定义在</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">因为那是多条C语句,很常见,所以请看这个成语代替。</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">由于 &lt;code&gt;__WARN__&lt;/code&gt; 不支持 &lt;code&gt;'IGNORE'&lt;/code&gt; 挂钩，因此可以使用空子例程禁用警告：</target>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">由于Perl解释器只有在即将执行一个新的操作码时才会查看信号标志,所以在一个长期运行的操作码期间(例如对一个很大的字符串进行正则表达式操作)到达的信号将在当前操作码完成之前不会被看到。</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">由于PerlIO层内部使用的是原始IO(字节),所有这些完全忽略了诸如你的文件系统类型(ASCII或EBCDIC)。</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">由于PerlIO层在内部使用原始IO,所有这些都完全忽略了你的文件系统的类型(ASCII或EBCDIC)和IO_CONVERSION环境变量。如果你想获得旧的行为,即BS2000 IO函数根据文件系统决定转换,PerlIO仍然是你的朋友。你可以像往常一样使用IO_CONVERSION,并告诉Perl,它应该使用本地IO层。</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">正如评论所言，这不是实现访问器的好方法。到目前为止，它很慢而且太聪明了。但是，您可能会将此视为以较旧的Perl代码提供访问器的方法。有关Perl中OO编码的建议，请参见&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">如本例所示,如果第二个参数是一个空字符串,那么类别的locale将返回到相应环境变量所指定的默认值。一般来说,这样做的结果是返回到Perl启动时有效的默认值:应用程序在启动后对环境的改变可能会被注意到,也可能不会被注意到,这取决于你系统的C库。</target>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">如上面的最后两个示例所示，您可以通过使用 &lt;code&gt;\N{...}&lt;/code&gt; 形式的范围端点来实现对非ASCII平台的可移植性。这些指示将使用Unicode值解释指定范围，因此 &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; 表示要匹配 &lt;code&gt;\N{U+27}&lt;/code&gt; ， &lt;code&gt;\N{U+28}&lt;/code&gt; ， &lt;code&gt;\N{U+29}&lt;/code&gt; ，...， &lt;code&gt;\N{U+3D}&lt;/code&gt; ， &lt;code&gt;\N{U+3E}&lt;/code&gt; 和 &lt;code&gt;\N{U+3F}&lt;/code&gt; ，无论它们的本机代码点版本如何。这些称为&amp;ldquo; Unicode&amp;rdquo;范围。如果两端采用 &lt;code&gt;\N{...}&lt;/code&gt; 格式，则该范围被视为Unicode。一个 &lt;code&gt;regexp&lt;/code&gt; 警告下提出的 &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; 如果非便携式地指定了另一个端点：</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">作为原型的最后一个字符，或者在分号前 &lt;code&gt;@&lt;/code&gt; 或 &lt;code&gt;%&lt;/code&gt; 之前，可以使用 &lt;code&gt;_&lt;/code&gt; 代替 &lt;code&gt;$&lt;/code&gt; ：如果未提供此参数，则将使用 &lt;code&gt;$_&lt;/code&gt; 代替。</target>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">如上一个例子所示,一个处理程序可以被设置为在两个或多个阶段中被(重新)调用。阶段名称作为处理程序的最后参数被传递。</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">解析器从源流中读取第二行和后续行时，将在处理它们之前将这些行馈送通过 &lt;code&gt;cpp&lt;/code&gt; 源过滤器。该 &lt;code&gt;cpp&lt;/code&gt; 滤波器简单地通过实际C预处理器的每一行。然后，C预处理器的输出由过滤器插入回到源流中。</target>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">当解析器理解一个Perl程序时,它建立了一个操作树,供解释器在执行过程中执行。构建和连接各种操作的例程可以在</target>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">由于有各种语法不兼容的Make程序,这些程序使用的是操作系统的shell,同样也是语法不兼容,因此,对于本模块的用户来说,知道一个Makefile是为哪种味道而写的是很重要的,这样他们就会使用正确的Makefile,而不用面对因为使用错误的Makefile而可能产生的令人困惑的错误。</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">因为在使用的错误数字之间有重叠。</target>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">如上所述，Perl 5.6.1在AmigaOS中仍然不错，在5.7.2中也是如此。在Perl 5.7.2（更改为＃11423，请参阅&amp;ldquo;更改&amp;rdquo;文件，以及文件pod / perlhack.pod以获取有关如何进行单个更改）之后，Perl放弃了对vfork（）的内部支持，这很可能是打破了这一步AmigaOS（因为ixemul库只有vfork）。当构建ext / DynaLoader时，构建最终失败，并且PERL在生成的Makefile中最终显示为&amp;ldquo; 0&amp;rdquo;，试图运行&amp;ldquo; 0&amp;rdquo;并不太起作用。同样，在反引号中执行miniperl似乎什么也不会产生：很可能与（v）fork问题有关。&lt;b&gt;修复损坏需要熟悉ixemul库的人员，以及如何在不使用fork（）的情况下在AmigaOS中运行外部命令。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">像往常一样，从 &lt;code&gt;PL_restartop&lt;/code&gt; 中提取 &lt;code&gt;CxEVAL&lt;/code&gt; ，并完成 &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ，这会将C堆栈弹出回docatch：</target>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">像往常一样,运行</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">正如我们在上面看到的,原则0优先于其他原则。regexp将尽可能早地被匹配,其他原则决定了regexp在该最早字符位置的匹配方式。</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">正如我们之前提到的,Perl的内置OO系统非常简陋,但也相当灵活。多年来,很多人开发的系统都是建立在Perl内置系统的基础上,提供更多的功能和便利。</target>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">如前所述，角色提供了继承的替代方法，但是Perl没有任何内置的角色支持。如果您选择使用Moose，则它带有完整的角色实现。但是，如果您使用我们推荐的其他其他OO模块之一，则仍可以将角色与&lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny一起使用&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">正如我们前面提到的,Perl没有提供特殊的构造函数语法。这意味着一个类必须实现自己的构造函数。构造函数只是一个返回新对象引用的类方法。</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">由于我们返回的是一个空列表,所以一切正常。</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">正如我们之前所说,Perl的最小OO系统导致了CPAN上OO系统的泛滥。虽然你仍然可以降到最底层,用手写你的类,但对于现代Perl来说,真的没有理由这么做。</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">如前所述，大多数Perl对象都是散列，但是对象可以是任何Perl数据类型（标量，数组等）的实例。通过使用Perl的 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数&lt;b&gt;祝福&lt;/b&gt;该数据结构，可以将一个普通的数据结构变成一个对象。</target>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">如前所述，对象只是通过 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数被祝福为类的数据结构。该 &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 函数可以接受一个或两个参数：</target>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">正如我们已经展示的， &lt;code&gt;call_sv&lt;/code&gt; 可用于调用匿名子例程。但是，我们的示例显示了Perl脚本调用XSUB来执行此操作。让我们看看如何在我们的C代码中完成它：</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">除了使用绑定的哈希或数组访问Berkeley DB外,还可以直接使用Berkeley DB文档中定义的大部分API函数。</target>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">除了释放哈希的所有元素(像 hv_clear()一样),这也释放了与哈希相关的任何辅助数据和存储。</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">除了分组外，括号还有第二个目的。它们可用于捕获regexp匹配的部分结果以供以后使用。结果以 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; 等结束。</target>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">除了这两个之外,还有一个转换器。</target>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairfirst&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 为列表元素别名 &lt;code&gt;$_&lt;/code&gt; ， &lt;code&gt;pairgrep&lt;/code&gt; 为给定列表元素别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">正如 &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; 别名 &lt;code&gt;$_&lt;/code&gt; 到列表中的元素， &lt;code&gt;pairmap&lt;/code&gt; 别名 &lt;code&gt;$a&lt;/code&gt; 和 &lt;code&gt;$b&lt;/code&gt; 给定列表的元素。代码块对其的任何修改对调用者都是可见的。</target>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">与 &lt;code&gt;gzerror()&lt;/code&gt; 一样,它在数字上下文中返回错误号，在字符串上下文中返回错误消息。但是与 &lt;code&gt;gzerror()&lt;/code&gt; 不同，错误消息将与</target>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">与上面的 &lt;code&gt;mro::get_linear_isa&lt;/code&gt; ， &lt;code&gt;UNIVERSAL&lt;/code&gt; 也很特殊。即使所有类都是有效地继承方法的子类， &lt;code&gt;UNIVERSAL&lt;/code&gt; （和父母的）isarev列表也不包括每个存在的类。</target>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">和G_SCALAR一样,这个标志有2个效果。</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">与GetOptionsFromArray一样,第一个参数哈希引用现在变成了第二个参数。</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">与所有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 指令一样，定义常量发生在编译时。因此，将常量声明放在条件语句内可能是不正确的（例如 &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">和所有编译器后台选项一样,这些选项必须直接跟在'-MO=Deparse'后面,用逗号隔开,但不能用空格。</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">与所有的标准命令一样,如果有的话,单字符开关可以与下面的开关聚在一起。</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">和Perl中的所有东西一样。</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">与任何咨询锁定方案一样，仅当您系统地使用 &lt;code&gt;lock_store&lt;/code&gt; 和 &lt;code&gt;lock_retrieve&lt;/code&gt; 时，该保护才起作用。如果您的应用程序的一侧使用 &lt;code&gt;store&lt;/code&gt; ,而另一侧使用 &lt;code&gt;lock_retrieve&lt;/code&gt; ，那么您将一无所获。</target>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">与构造函数一样,Perl也没有提供特殊的访问器声明语法,所以类必须提供显式编写的访问器方法。有两种常见的访问器类型,只读和读写。</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">与许多 unix 端口一样,该端口依赖于一些 &quot;标准 &quot;unix 实用程序,但这些程序不一定是 QNX4 的标准程序。</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">与普通的Perl数组一样,RECNO数组可以使用负数索引来访问。索引-1指的是数组的最后一个元素,-2指的是第二个最后的元素,以此类推。如果试图在数组开始之前访问一个元素,会引发一个致命的运行时错误。</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">与postfix数组一样,postfix值分片去参照。</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">与子程序一样,从线程的入口点函数返回的值的类型可以由线程的</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">如同在《公约》中一样。</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">与DB_HASH格式一样,可以提供一个用户定义的Perl例程来执行键的比较。但默认情况下,键是按词法顺序存储的。</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与附加模式一样，当您以只写模式打开文件时，现在可以使用 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 之一写入该文件句柄。</target>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">与match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 运算符一样， &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 可以使用其他定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; ，甚至 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。如果使用单引号 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; ，则将regexp和replace视为单引号字符串，并且不存在变量替换。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 在列表上下文中返回的内容与在标量上下文中相同，即匹配数。</target>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">与匹配运算符一样，正则表达式引用可以使用不同的定界符，例如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; 。撇号作为定界符（ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ）禁止任何插值。</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">与其他类型的关系，当这种方法被称为 &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; 发生。发生这种情况时，最好使用&amp;ldquo;自动关闭&amp;rdquo;。请参阅&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;下面的解开陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">和其他类型的绑定一样,当绑定的句柄即将被销毁时,这个方法将被调用。这对调试和可能的清理很有用。</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">与返回栈一样,在将数据推入返回数组之前,可以预先扩展返回数组(而且在性能上也有小的优势),因为我们知道我们将返回多少元素。</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">与外壳程序一样，在Perl中， &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 用于以只读模式打开文件。如果成功，Perl将为您分配一个全新的文件句柄，并使用对该句柄的引用来填充以前未定义的 &lt;code&gt;$handle&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">如您所见，已使用密钥 &lt;code&gt;Wall&lt;/code&gt; 成功创建了3条记录-唯一的是，从数据库中检索它们时，</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">如您所见，这两个模块的结构大致相似。它们都使用 &lt;code&gt;Filter::Util::Call&lt;/code&gt; 模块，并且都有 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 方法。它们之间的区别在于</target>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">正如你在简介中看到的,根据你的模板,提供的参数将被验证。</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">如你所见。</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">如您所见，已经创建了一个新流，用于从 &lt;code&gt;Fred.pm&lt;/code&gt; 读取源。在解析 &lt;code&gt;Fred.pm&lt;/code&gt; 所有Fred.pm之前，此流将保持活动状态。对于源流 &lt;code&gt;cpp_test&lt;/code&gt; 将仍然存在，但处于非活动状态。一旦解析器完成读取Fred.pm，与之关联的源流将被销毁。然后， &lt;code&gt;cpp_test&lt;/code&gt; 的源流再次变为活动状态，并且解析器从 &lt;code&gt;cpp_test&lt;/code&gt; 读取第4行和后续行。</target>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">如您所见，即使我们解析出一个分支和一个片段，最终它也只是一个原子。最终程序向我们展示了事情是如何工作的。我们有一个 &lt;code&gt;EXACT&lt;/code&gt; 规则，然后是一个 &lt;code&gt;END&lt;/code&gt; 规则。括号中的数字表示节点的 &lt;code&gt;regnext&lt;/code&gt; 。该 &lt;code&gt;regnext&lt;/code&gt; 一个的 &lt;code&gt;END&lt;/code&gt; regop是未使用的，因为 &lt;code&gt;END&lt;/code&gt; regops意味着我们已经成功匹配。左侧的数字表示regop在regnode数组中的位置。</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">如你所见,它变得有点复杂。所以有时候在你的路上临时抱佛脚是比较容易的。</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">如您所见，箭头的&amp;ldquo;大头&amp;rdquo;触及 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; ，这是记住 &lt;code&gt;&amp;gt;&lt;/code&gt; 是big-endian修饰符的好方法。显然，对于 &lt;code&gt;&amp;lt;&lt;/code&gt; ，这同样适用，其中&amp;ldquo;小头&amp;rdquo;触及代码。</target>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">如您所见，连续字节都以 &lt;code&gt;&quot;10&quot;&lt;/code&gt; 开头，起始字节的前导位表明编码字符中有多少个字节。</target>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">正如你所看到的,我们已经将路径和文件数据存储在对象本身。请记住,在外壳下,这个对象仍然只是一个哈希。稍后,我们将编写访问器来操作这些数据。</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">正如你可以一目了然的告诉&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;时，L &amp;lt;...&amp;gt;代码是最复杂的波德格式化代码。以下几点有望阐明其含义以及处理器应如何处理。</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">当你精心设计你打算提交给 Perl 核心的每个补丁时,写好提交信息是很重要的。如果你的提交是由一系列的提交组成,那么这一点尤其重要。</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">从上面的文档和示例中可以推断出， &lt;code&gt;ok&lt;/code&gt; 的原型是 &lt;code&gt;($;$$)&lt;/code&gt; （顺便说一下， &lt;code&gt;skip&lt;/code&gt; 的是 &lt;code&gt;($;$$$)&lt;/code&gt; ）。例如，这意味着您可以执行 &lt;code&gt;ok @foo, @bar&lt;/code&gt; 来比较</target>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">正如你可能已经注意到的,FETCH方法(等)的名称对于所有的访问都是一样的,尽管构造函数的名称不同(TIESCALAR与TIEARRAY)。虽然理论上你可以让同一个类为多个绑定类型服务,但实际上这样做会变得很麻烦,最简单的做法是每个类只保留一个绑定类型。</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">您可能知道，这会在编译时使用以下参数调用 &lt;code&gt;attributes&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能：&amp;ldquo;属性&amp;rdquo;，调用方的程序包名称，对代码的引用和&amp;ldquo;方法&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">从这些示例中可以看到， &lt;code&gt;STDOUT&lt;/code&gt; 和 &lt;code&gt;STDERR&lt;/code&gt; 是输出句柄，而 &lt;code&gt;STDIN&lt;/code&gt; 和 &lt;code&gt;ARGV&lt;/code&gt; 是输入句柄。它们全部用大写字母表示，因为它们保留给了Perl，就像 &lt;code&gt;@ARGV&lt;/code&gt; 数组和 &lt;code&gt;%ENV&lt;/code&gt; 哈希一样。它们的外部关联由您的shell设置。</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">正如你所看到的,这很容易让人感到困惑。虽然这其中有一小部分原因是由于基于参考的实现,但实际上更多的是由于缺乏为初学者设计的例子的现有文档。</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">正如你所看到的,它与Internet域TCP服务器非常相似,事实上,我们省略了几个重复的函数--spawn()、logmsg()、ctime()和REAPER()--这些函数与其他服务器中的函数相同。</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">如你所见,包的名称就是结构的名称。常规字段只是自己的名字。另外,为了方便大家,还提供了以下访问函数。</target>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">如您所见，有一个例外：ASCII。这样，您可以假设目标1。使用 &lt;code&gt;Encode&lt;/code&gt; 时，假设目标为＃2，但在上面&lt;b&gt;CAVEAT&lt;/b&gt;段落中提到的情况下，您仍然必须小心。</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">如你所见,这可能有点棘手。重要的是要意识到正则表达式只是一组断言,它给出了成功的定义。可能有 0、1 或几种不同的方式让这个定义对一个特定的字符串成功。而如果有多种可能成功的方式,你需要了解回溯,以知道你将实现哪种品种的成功。</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">如您所料，此修饰符会导致 &lt;code&gt;\D&lt;/code&gt; 与 &lt;code&gt;[^0-9]&lt;/code&gt; 含义相同；事实上，所有非ASCII字符匹配 &lt;code&gt;\D&lt;/code&gt; ， &lt;code&gt;\S&lt;/code&gt; ，和 &lt;code&gt;\W&lt;/code&gt; 。 &lt;code&gt;\b&lt;/code&gt; 仍然意味着以匹配之间的边界 &lt;code&gt;\w&lt;/code&gt; 和 &lt;code&gt;\W&lt;/code&gt; ，使用 &lt;code&gt;/a&lt;/code&gt; 它们的定义（类似地对于 &lt;code&gt;\B&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">当你在写一个应用程序的时候,你要决定你需要发出什么消息。通常你会去写这个。</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">如您所见，您可以通过传递空字符串或以卷名开头的路径作为第一个参数来强制 &lt;code&gt;catdir()&lt;/code&gt; 创建绝对路径。但是，强烈建议您不要这样做，因为这样做只是为了向后兼容。 File :: Spec的较新版本附带一个名为 &lt;code&gt;catpath()&lt;/code&gt; 的方法（请参见下文），该方法旨在为创建绝对路径提供一种可移植的解决方案。它需要卷，目录和文件部分，并返回完整路径。尽管 &lt;code&gt;catdir()&lt;/code&gt; 仍然适合于</target>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">除了实验设施（请参见下面的&lt;a href=&quot;#Signatures&quot;&gt;签名&lt;/a&gt;）之外，Perl还没有命名形式参数。实际上，您要做的只是分配给这些的 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; 列表。未声明为私有的变量是全局变量。有关创建私有变量的详细信息，请参见&lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;通过my（）的私有变量&lt;/a&gt;和&lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;通过local（）的临时值&lt;/a&gt;。要在单独的程序包（可能是单独的文件）中为一组功能创建受保护的环境，请参见&lt;a href=&quot;perlmod#Packages&quot;&gt;perlmod中的程序包&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">要求它创建新的Perl可执行文件。</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">要求当前的维护者让你成为共同维护者,或者将模块转移给你。</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">向服务器询问它所接受的命令的 &quot;有用信息&quot;(这是RFC的说法)。</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">问他们要。有这么多的电子邮件提供商,本地系统不可能知道如何确定用户的电子邮件地址。</target>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">断言是必须为真的条件,它们实际上并不匹配子串的部分。有六个断言被写成反斜杠序列。</target>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">分配魔法</target>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">分配和取消引用变量。</target>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">分配给参考资料</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">赋值给私有变量列表来命名你的参数。</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">分配给哈希中的一个条目将导致文件的时间戳被修改。如果文件不存在,那么它将被创建。给哈希元素分配一个整数将导致访问和修改时间都改变为该值。另外,也可以传递一个包含两个值的数组的引用。第一个数组元素将用于设置访问时间,第二个元素将用于设置修改时间。</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">赋值给特殊变量$[</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">分配操作者</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">赋值有点特殊,它使用左参数来决定右参数的上下文。对一个标量的赋值是在标量上下文中评估右侧,而对一个数组或哈希的赋值是在列表上下文中评估右侧。对一个 list(或 slice,反正就是一个 list)的赋值也是在 list 上下文中评估右手边。</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">赋值运算符的工作原理与C中一样,即。</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">赋值给一个类型球,执行一个别名操作,即。</target>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">对引用和非引用的赋值可以结合在列表和条件三元表达式中,只要右侧的值是左侧每个元素的正确类型,尽管这可能会使代码变得模糊不清。</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">&lt;b&gt;向后引用&lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; ， &lt;code&gt;\g2&lt;/code&gt; ，... 与匹配变量 &lt;code&gt;$1&lt;/code&gt; ， &lt;code&gt;$2&lt;/code&gt; ，...相关联... &lt;b&gt;向后引用&lt;/b&gt;是可以使用的匹配变量</target>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">假定有关结构的&lt;b&gt;任何&lt;/b&gt;内容（尤其是您不控制的结构，例如来自系统头文件的结构）</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">假设每个句子的结尾都有两个空格,并尽量保留这个间距。如果没有这个选项,非逐字记录段落中所有连续的空白都会被压缩成一个空格。</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">假设有A，B，C和D四类。</target>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">不假设 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 数值（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; ，chr）。不要使用显式代码点范围（例如 &lt;code&gt;\xHH-\xHH)&lt;/code&gt; 。但是，从Perl v5.22开始，指定的正则表达式模式括起来的字符类范围如 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; 是可移植的。您可以方便地使用 &lt;code&gt;[:print:]&lt;/code&gt; 之类的符号字符类。</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">假设一个整数不能占用少于20个字节的内存,一个浮点数不能占用少于24个字节,一个字符串不能占用少于32个字节(所有这些例子都是假设32位架构,在64位架构上的结果要差不少)。如果一个变量被以三种不同的方式中的两种方式访问(需要一个整数、一个浮点数或一个字符串),内存占用可能会再增加20个字节。一个粗心的 malloc(3)实现会使这些数字急剧膨胀。</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">假设旧的DLL名为</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">假设你是一个经验丰富的搬运工,所以确信所有必要的工具都已经存在于你的系统中,并且你知道如何获得Perl的源代码发行版。解除tar,换到解压目录,然后</target>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">假定此TAP版本是&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;而不是默认的TAP版本12。</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">对字符集的假设非常少。</target>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">假设PL_op是最初触发错误的op,并且PL_comppad/PL_curpad指向当前执行的pad。</target>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">假设可以为任何类型的数据派生出任何类型的指针。</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">假设 sizeof(int)==sizeof(long)</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">假定将 &lt;code&gt;man&lt;/code&gt; 文件放在适当的位置，这将完成最小Perl系统的安装。（二进制发行版还包含许多其他模块，以及INF格式的文档。）</target>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">假设我们必须匹配可能以yyy-mm-dd、mm/dd/yyyy或dd.mm.yyyy三种格式之一给出的日历日期,我们可以写出三种合适的模式,分别使用'd'、'm'和'y'作为捕获日期相关组件的组名。匹配操作将这三种模式结合起来作为备选方案。</target>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">假设你不关心 &quot;NaN &quot;或 &quot;Infinity &quot;这样的IEEE符号,你可能只想使用一个正则表达式。</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">假设字符集是ASCII码</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">假设字符集只是ASCII码</target>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">假定由Perl包装器的C库函数的返回值指向的静态内存的内容不变。许多C库函数将指针返回到静态存储，该指针可被后续对相同或相关函数的调用所覆盖。 Perl具有一些这类功能的轻量级包装器，并且不会复制静态内存。一个很好的例子是对程序有效的环境变量的接口。 Perl有 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 从环境中获取价值。但是返回的是指向C库中静态内存的指针。如果您使用该值立即测试某些东西，那很好，但是如果您保存该值并期望它在以后的处理中保持不变，那将是错误的，但也许您不会知道，因为不同的C库实现会表现出来与此不同，您正在测试的平台上的那个可能会适合您的情况。但是在某些平台上，随后对 &lt;code&gt;PerlEnv_getenv&lt;/code&gt; 或相关函数的调用将覆盖您的第一个调用所指向的内存。这导致了一些难以调试的问题。&lt;a href=&quot;perlapi#savepv&quot;&gt;在Perlapi中&lt;/a&gt;做一个savepv进行复制，从而避免了这些问题。完成操作后，您将必须释放副本以避免内存泄漏。如果您无法控制何时释放它，则需要使用凡人的标量制作该副本，如下所示：</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">假设是上一例的数据库。</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">假设它们的行为类似于Perl的 &lt;code&gt;++&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; ，则需要对这些运算符的重载实现进行突变。</target>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">假设你调用你的类Projname::L10N,创建一个类,最小包括:。</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">假设你有很好的测试覆盖率,你的测试应该会失败,因为缺失的依赖关系会更强烈地告知用户有问题。你可以写一个</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">假设您知道要处理的是UTF-8字符串，则可以使用 &lt;code&gt;UTF8SKIP&lt;/code&gt; 宏找出其中的第一个字符多长时间：</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">假设您在足够的权限下运行，则应该能够通过运行 &lt;code&gt;date(1)&lt;/code&gt; 程序来设置系统范围的日期和时间。（无法在每个进程的基础上设置时间和日期。）该机制适用于Unix，MS-DOS，Windows和NT。VMS等效 &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 是设置时间。</target>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">假设您的系统支持这些功能，只需向进程发送适当的信号即可（请参见&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;）。通常先发送一个TERM信号，稍等片刻，然后发送一个KILL信号来完成它。</target>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">在10:23，此函数生成数据文件的第10行。在下午3:45，它将生成第15行。默认情况下， &lt;code&gt;Memoize&lt;/code&gt; 将仅看到$ problem_type参数。要解决此问题，请在规范化器中包括当前时间：</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">在给定的字符位置上,第一个让 regex 匹配成功的选项将是匹配的选项。在这里,所有的选项都在第一个字符串位置匹配,所以第一个匹配。</target>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">在任何时候,这些修饰符中只有一个是有效的。它们的存在使得 Perl 能够保持正则表达式最初的编译行为,而不管实际执行时是什么规则在起作用。如果它被插值到一个更大的 regex 中,原始规则将继续适用于它,而且只适用于它。</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">无论如何，对于Unicode字符， &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 使用非常成问题，因为您必须考虑字符宽度（即表意文字为双倍宽度）和方向（即BIDI对于阿拉伯语和希伯来语）。</target>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">在反序列化的时候,你会得到同样的LIST,但所有额外的引用都会指向反序列化的结构。</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">在每个堆栈级别，子例程的名称及其参数都会显示出来。对于简单的标量，这就足够了。对于复杂的数据类型，例如对象和其他引用，这可以简单地显示 &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在perl的入口点，例如 &lt;code&gt;perl_parse()&lt;/code&gt; ， &lt;code&gt;perl_run()&lt;/code&gt; 和 &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; 各自执行 &lt;code&gt;JMPENV_PUSH&lt;/code&gt; ，然后进入runops循环或其他操作，并处理可能的异常返回。对于2返回，将执行最终清除，例如弹出堆栈并调用 &lt;code&gt;CHECK&lt;/code&gt; 或 &lt;code&gt;END&lt;/code&gt; 块。除其他事项外，这就是在 &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 期间仍然进行范围清理的方式。</target>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">乍一看，您会认为它不应该打印，因为显然 &lt;code&gt;ddd&lt;/code&gt; 不会与目标字符串匹配。但是看这个例子：</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">至少为了与WinNT保持一致,你应该保持推荐值。</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">至少在Unix中，您可以通过增加进程数据大小限制来解决此问题：在csh / tcsh中，使用 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;limit datasize n&lt;/code&gt; （其中 &lt;code&gt;n&lt;/code&gt; 是千字节数）来检查当前限制并更改它们，在ksh中/ bash / zsh分别使用 &lt;code&gt;ulimit -a&lt;/code&gt; 和 &lt;code&gt;ulimit -d n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">至少在不做什么事的情况下,它是向后兼容的。</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; 和 &lt;code&gt;s2&lt;/code&gt; 中的至少一个必须有一个目标（ &lt;code&gt;l1&lt;/code&gt; 和 &lt;code&gt;l2&lt;/code&gt; 中的至少一个必须为非零），并且如果两者均存在，则必须同时达到一个目标才能成功进行比赛。同样，如果一个字符的折痕是多个字符，则所有字符都必须匹配（有关折叠的信息，请参见下面的tr21参考）。</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">至少三个内建函数 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; ，以及 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; 。如果我们想到它们，有一天我们可能会在以后添加更多。</target>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">在第4行是一个有用的指针,它告诉你现在你在哪里。要查看更多的代码,再次输入'v'。</target>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">目前这个列表是:weaken,isweak,dualvar,isvstring,set_prototype。</target>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">目前IO::Compress::Zip支持三种压缩方式,分别是Store(完全不压缩)、Deflate、Bzip2和LZMA。</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">目前，第一次使用 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 遍历％ENV 时，由于要完全填充％ENV会读取所有逻辑名称，因此会产生时间损失。随后的迭代将不会重新读取逻辑名，因此它们不会那么慢，但是它们也不会反映其他程序对逻辑名表的任何更改。</target>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">在运行时,每一个列出的插件都会被实例化为一个单人对象,运行相当于这个伪代码。</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">在运行时,你可以使用。</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">在某个时刻,建成可能会死掉,报告一个</target>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">在2008年奥斯陆的QA Hackathon上,Perl模块工具链的维护者同意使用CPAN Meta格式来沟通工具链组件之间的配置后需求。这些文件。</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">您可能会花费一些头开销，但可以使用 &lt;code&gt;store_fd&lt;/code&gt; 例程将其存储到已打开的文件描述符中，然后通过 &lt;code&gt;fd_retrieve&lt;/code&gt; 从文件中检索。这些名称默认情况下不会被导入，因此如果需要这些例程，则必须明确地执行此操作。您提供的文件描述符必须已经打开，如果要检索则要读取，如果要存储则要写入。</target>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">在结束时</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">在所有 &lt;code&gt;when&lt;/code&gt; 块的末尾，都有一个隐式的 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 。如果您仅对第一个比赛感兴趣，则可以用明确的 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 一个覆盖。</target>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">在解析结束时，调用 &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; 以获取树的顶部节点。</target>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">在最底层,宏new_SV()和del_SV()抓取并释放一个SV头。(如果使用-DD调试,del_SV()调用函数S_del_sv()将SV返回到空闲列表并进行错误检查。)new_SV()调用more_sv()/sv_add_arena()在空闲列表中增加一个额外的竞技场。空闲列表中的SV的SvTYPE字段被设置为所有的。</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">在撰写本文时，AIX支持两种不同的本机C编译器，您必须付费：&lt;b&gt;xlC&lt;/b&gt;和&lt;b&gt;vac&lt;/b&gt;。如果您决定使用这两种方法中的一种（比使用gcc容易得多），请确保升级到最新的可用补丁程序级别。目前：</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">冒昧地说一句,模块的目的是模块化的。一个Perl开发者应该能够使用模块来组合他们应用程序的构件。然而,重要的是模块的形状要正确,当开发者需要的是一个小模块时,他们不应该使用一个大模块。</target>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">在写这篇文章的时候(2009-03),有三个YAML的实现在工作。YAML,YAML::Syck,和 YAML::XS。后两者速度更快,但需要在你的系统上安装一个C编译器。可能还有更多符合YAML的替代模块。当我尝试了另外两个播放器,YAML::Tiny和YAML::Perl,它们似乎不够强大,无法与CPAN.pm一起工作。在这期间,这种情况可能已经改变了。</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">在撰写本文时（2002年6月），当不使用&amp;ldquo; e&amp;rdquo;表示法时，长双打的Tru64 libc打印中存在一个已知的错误。该值是正确且可用的，但是除非使用 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; 等强制执行该问题，否则您只会显示有限的数字。对于Tru64版本V5.0A到V5.1A，预计在perl 5.8.0发布之后的某个时间会有补丁。如果您的libc尚未打补丁，则在选择长双打时会从Configure收到警告。</target>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">在写这篇文章的时候,Perl 5.18.0被认为可以很好地抵御对其哈希实现的算法复杂性攻击。这主要归功于以下减轻攻击的措施。</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">在最后清理的时候,从perl_destruct()调用sv_free_arenas()来物理释放从解释器开始分配的所有区域。</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">在f被创建时,它不能捕获当前的 &quot;a &quot;子,因为匿名子程序还没有被创建。相反,下面的内容不会给出警告,因为匿名子程序现在已经被创建并且是实时的。</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">在f被创建的时候,它不能捕捉到$a的当前值,因为匿名子程序还没有被创建。相反,下面的内容不会给出警告,因为匿名子程序现在已经被创建并且是实时的。</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">在本文档最后更新时,Cygwin 1.7.16是最新版本。</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">至少,这对查看SelfLoader认为哪些是存根是有用的--为了确保未来版本的SelfStubber与SelfLoader保持一致,SelfStubber实际上是使用SelfLoader来确定需要哪些存根。</target>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">至少，任何子类都需要提供自己的 &lt;code&gt;new()&lt;/code&gt; 并可以在对象中存储其他哈希键。还必须定义一些程序包全局变量，例如：</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">此时,如果你使用的是</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">到此为止,我们已经涵盖了所有基本的regexp概念,那么我们来举一个更复杂的正则表达式的例子。我们将建立一个匹配数字的regexp。</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">在这一点上,xsubpp做的工作很少--Mytest.xs和Mytest.c之间的差别很小。</target>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">在撰写本文时， &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; 值有两种类型：Pod页面的名称，例如 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; （它可能是@ INC / PATH目录中的真实Perl模块或程序，或者.pod文件）；或Unix手册页的名称，例如 &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; 。从理论上讲， &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; 在称为&amp;ldquo; chmod&amp;rdquo;的Pod页面或Unix手册页&amp;ldquo; chmod&amp;rdquo;之间（在任何man-section中）都是模棱两可的。但是，如&amp;ldquo; crontab（5）&amp;rdquo;中的那样，parens中存在字符串就足以表明正在讨论的内容不是Pod页面，因此大概是Unix手册页。对于许多Pod处理器而言，这种区别并不重要，但是某些渲染为超文本格式的处理器可能需要区分它们，以便知道如何渲染给定的 &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; 代码。</target>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">将ID标识的共享内存段附加到调用进程的地址空间。参见&lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">将 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; 附加到数组是允许的，但无效。</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">尝试SASL认证。</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">试图进行SASL认证。需要 Authen::SASL 模块。</target>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">尝试将目录更改为 &lt;code&gt;$dir&lt;/code&gt; 给定的目录。如果 &lt;code&gt;$dir&lt;/code&gt; 是 &lt;code&gt;&quot;..&quot;&lt;/code&gt; ，则FTP &lt;code&gt;CDUP&lt;/code&gt; 命令用于尝试向上移动一个目录。如果未提供目录，则尝试将目录更改为根目录。</target>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">试图将绝对文件规范转换为相对规范。</target>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">试图摧毁所有尚未释放的物体。</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">尝试评估当前主机的互联网名称和域名。</target>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">如果运行被SIGINT(Ctrl-C)打断,则尝试打印摘要信息。</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">试图产生彩色输出。</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">尝试将 &lt;code&gt;$length&lt;/code&gt; 个字节的未压缩数据读入 &lt;code&gt;$buffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">试图从自己那里继承会产生一个警告。</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">尝试将特殊的浮点值 &lt;code&gt;Inf&lt;/code&gt; 和 &lt;code&gt;NaN&lt;/code&gt; （无穷大，也为负数，不是一个数字）压缩为压缩整数值（例如 &lt;code&gt;&quot;L&quot;&lt;/code&gt; ）是一个致命错误。这样做的原因是，对于这些特殊值到整数，根本没有任何明智的映射。</target>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">试图在不关闭数据库的情况下重新打开数据库。</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">尝试几种获取系统主机名的方法，然后缓存结果。它尝试C库的gethostname（）， &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; ，uname（2）， &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;`hostname`&lt;/code&gt; ， &lt;code&gt;`uname -n`&lt;/code&gt; 和文件中的第一个可用</target>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">尝试连接到远程套接字，就像connect（2）一样。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">尝试连接到远程套接字，就像connect（2）一样。如果成功，则返回true，否则返回false。NAME应该是套接字的适当类型的压缩地址。请参阅&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;perlipc&lt;/a&gt;中的套接字：客户端/服务器通信中的示例。</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">试图在原地转换编码为</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">尝试将SV的PV从字符转换为字节。如果PV包含不能容纳在字节中的字符，则此转换将失败；否则，转换将失败。在这种情况下，返回false，或者，如果 &lt;code&gt;fail_ok&lt;/code&gt; 不为true，则返回错误。</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">试图确定某个主机是否在您的防火墙之外。可能的返回值是:</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">尝试阅读LENGTH</target>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">尝试使用read（2）从指定的FILEHANDLE将LENGTH个字节的数据读取到变量SCALAR中。它会绕过缓冲的IO，因此将其与其他类型的读取， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用会引起混乱，因为Perlio或stdio层通常会缓冲数据。返回实际读取的字节数，在文件末尾返回 &lt;code&gt;0&lt;/code&gt; ，如果出现错误则返回undef（在后一种情况下，还设置了 &lt;code&gt;$!&lt;/code&gt; ）。 SCALAR将增长或缩小，以便实际读取的最后一个字节是读取后标量的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">尝试使用read（2）从指定的FILEHANDLE将LENGTH个字节的数据读取到变量SCALAR中。它会绕过缓冲的IO，因此将其与其他类型的读取， &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用会引起混乱，因为Perlio或stdio层通常会缓冲数据。返回实际读取的字节数，在文件末尾返回 &lt;code&gt;0&lt;/code&gt; ，如果出现错误则返回undef（在后一种情况下，还设置了 &lt;code&gt;$!&lt;/code&gt; ）。 SCALAR将增长或缩小，以便实际读取的最后一个字节是读取后标量的最后一个字节。</target>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">尝试使用write（2）将变量SCALAR的LENGTH个字节写入指定的FILEHANDLE。如果未指定LENGTH，则写入整个SCALAR。它绕过缓冲的IO，因此将其与读取（而不是 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用可能会造成混乱，因为perlio和stdio层通常会缓冲数据。返回实际写入的字节数，如果有错误，则返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （在这种情况下，还将设置errno变量 &lt;code&gt;$!&lt;/code&gt; ）。如果偏移后的长度大于标量中的可用数据，则只会写入尽可能多的数据。</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">尝试使用write（2）将变量SCALAR的LENGTH个字节写入指定的FILEHANDLE。如果未指定LENGTH，则写入整个SCALAR。它绕过缓冲的IO，因此将其与读取（而不是 &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; 混合使用可能会造成混乱，因为perlio和stdio层通常会缓冲数据。返回实际写入的字节数，如果有错误，则返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （在这种情况下，还将设置errno变量 &lt;code&gt;$!&lt;/code&gt; ）。如果偏移后的长度大于标量中的可用数据，则只会写入尽可能多的数据。</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">试图完成单词。不能更改。</target>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Attribute::Handlers-简化属性处理程序的定义。</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers努力地将数据参数（ &lt;code&gt;$_[4]&lt;/code&gt; ）转换为可用形式，然后再将其传递给处理程序（但请参阅&lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;非解释性属性处理程序&lt;/a&gt;）。如果这些努力成功，则将解释后的数据传递到数组引用中；否则，将失败。如果它们失败，则原始数据将作为字符串传递。例如，所有这些：</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">属性通常存储在对象本身中。例如,如果对象是一个匿名哈希,我们可以使用属性名作为键,在哈希中存储属性值。</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">属性通常被定义为只读或读写。只读属性只能在第一次创建对象时设置,而读写属性可以在任何时候改变。</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">属性作为 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 界面</target>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">属性作为连接接口</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">属性是一个很好的、直观的界面,通过它来绑定变量。例如:</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">属性一旦设置，将一直持续到取消设置为止（通过将属性打印为 &lt;code&gt;clear&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ）。请小心执行此操作，否则，在脚本运行完成后，属性将继续存在，并且人们对将提示和键入更改为怪异的颜色感到非常恼火。</target>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">唐（Audrey Tang）&amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">使用密码 &lt;code&gt;PASS&lt;/code&gt; 与标识为 &lt;code&gt;USER&lt;/code&gt; 的服务器进行身份验证。与&lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;相似，但密码不是以明文形式发送。</target>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">使用提供的用户名和密码对服务器进行身份验证(使用 RFC2980 中定义的原始 AUTHINFO USER/AUTHINFO PASS 表格)。请注意,密码是以明文形式发送给服务器的。除非与服务器的连接受到某种程度的保护,否则这个命令不应该与有价值的密码一起使用。</target>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">使用提供的用户名和密码对服务器进行身份验证（使用建议的NNTP V2 AUTHINFO SIMPLE表单，该表单在RFC2980中定义和弃用）。与&lt;a href=&quot;#authinfo&quot;&gt;authinfo一样&lt;/a&gt;，密码以明文形式发送。</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">认证、安全和加密</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">作者和维护者：Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">作者和修改历史</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">本软件的作者对本产品的适用性、可靠性、可编辑性、可用性不作任何声明,对因使用本产品而造成的任何损失不应承担任何责任。如果你能使用它,那是你的幸运,如果不能,我不应该承担任何责任。备用磁带随身携带。</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">作者：Plover Systems的Mark Jason Dominus（ &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">作者不得嵌套L &amp;lt;...&amp;gt;代码。例如，&amp;ldquo; L &amp;lt;L &amp;lt;Foo :: Bar&amp;gt;手册页&amp;gt;&amp;rdquo;应被视为错误。</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">提醒Pod格式化程序的作者，&amp;ldquo; = over&amp;rdquo; ...&amp;ldquo; = back&amp;rdquo;可能会映射到您输出格式中的几种不同结构。例如，在将Pod转换为（X）HTML时，它可以映射到&amp;lt;ul&amp;gt; ... &amp;lt;/ ul&amp;gt;，&amp;lt;ol&amp;gt; ... &amp;lt;/ ol&amp;gt;，&amp;lt;dl&amp;gt; ... &amp;lt;/ dl&amp;gt;中的任何一个或&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;。同样，&amp;ldquo; = item&amp;rdquo;可以映射到&amp;lt;li&amp;gt;或&amp;lt;dt&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">花苞格式化的作者应该注意到这个构造。</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Pod格式化/处理器的作者应尽力避免编写自己的Pod解析器。在CPAN中已经有好几个,有各种不同的界面风格--其中一个Pod::Parser,是与现代版本的Perl一起出现的。</target>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">formatter子类的作者可能会发现,这些方法对你还没有开始从解析器对象中提取标记的解析器对象的调用很有用。</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">自动递减SV中的值,必要时进行字符串到数字的转换。处理'get'魔术和操作符重载。</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">自动递减SV中的值,必要时进行字符串到数字的转换。处理运算符重载。跳过处理 &quot;get &quot;魔法。</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">自动递增和自动递减。</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">自动递增SV中的值,必要时进行字符串到数字的转换。处理'get'魔术和操作符重载。</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">自动递增SV中的值,必要时进行字符串到数字的转换。处理运算符重载。跳过处理 &quot;get &quot;魔法。</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">自动加载器--只在需要时加载子程序。</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;@INC&lt;/code&gt; 包含相对路径，&lt;b&gt;并且&lt;/b&gt;程序执行 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; ，则AutoLoader可能无法找到自动分割的文件（甚至找不到错误的文件）。</target>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Perl 5.002之前的AutoLoader界面略有不同。任何使用&lt;b&gt;AutoLoader的&lt;/b&gt;旧模块都应更改为新的调用样式。通常，这仅意味着将需求更改为使用，如果需要，添加显式的 &lt;code&gt;'AUTOLOAD'&lt;/code&gt; 导入，并从 &lt;code&gt;@ISA&lt;/code&gt; 删除&lt;b&gt;AutoLoader&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-分割一个包以实现自动加载。</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">自动创建常量</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie使用一组简单的类别将相似的内置组件组合在一起。请求类别类型（以冒号开头）将为该类别下的所有内置插件启用自动diedie。例如，request &lt;code&gt;:file&lt;/code&gt; 将启用autodie的 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 返回false以及其他任何错误，则自动染色的 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; 将生成异常。</target>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">自动加载和包词法</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">用XSUBs自动加载</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">自动安装二进制文件</target>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">根据头文件中的函数声明自动生成XSUB。应该安装软件包 &lt;code&gt;C::Scan&lt;/code&gt; 。如果指定了此选项，则头文件的名称可能类似于 &lt;code&gt;NAME1,NAME2&lt;/code&gt; 。在这种情况下，将使用NAME1代替指定的字符串，但是仅针对文件NAME2中包含的声明发射XSUB。</target>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">自动为&lt;b&gt;--help&lt;/b&gt;和&lt;b&gt;-？&lt;/b&gt;提供支持 如果应用程序未为此选项本身指定处理程序，则为options。</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">如果应用程序未为此选项本身指定处理程序，则自动为&lt;b&gt;--version&lt;/b&gt;选项提供支持。</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">自动性通常在它们实际绑定的模块中最常用，并且需要将其属性导出到调用它们的任何模块。为方便 &lt;code&gt;__CALLER__&lt;/code&gt; ，Attribute :: Handlers识别一个特殊的&amp;ldquo;伪类&amp;rdquo; __CALLER__，可以将其指定为属性的限定符：</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">可用的插件</target>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">可用的子程序</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">现有出口</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">在Perls 5.8.1和更高版本中可用。如果设置为 &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; ，则将还原Perl-5.8.0之前的信号行为（立即但不安全）。如果设置为 &lt;code&gt;safe&lt;/code&gt; ，则使用安全（但延迟）信号。请参阅&lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;perlipc中的延迟信号（安全信号）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">可在2.22及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">可在2.32及以上版本中使用</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">可在2.66及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">可在2.77及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">可在2.99及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">可在3.00及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">可在6.31及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">可在6.46及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">可在6.48及以上版本中使用。</target>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">可在6.52及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">可在6.5503及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">可在6.64及以上版本使用。</target>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">可在64位OpenVMS 8.2及以上版本上使用。(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">仅适用于套接字句柄，它执行Winsock API中的 &lt;code&gt;ioctlsocket()&lt;/code&gt; 调用。（Win32的）</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">仅适用于插座手柄。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">该函数仅在线程构建中可用，该函数在 &lt;code&gt;PL_stashpad&lt;/code&gt; 中为传递给它的存储空间分配一个条目。</target>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">避免使用/usr/ucb/cc。</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">避免在使用 &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; 和 &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; 情况下使用 &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">避免在条件条件中进行赋值，但是如果不可避免，请使用额外的括号，例如&amp;ldquo; if（a &amp;amp;&amp;amp;（b = c））...&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">尽量避免使用裸词,尤其是所有小写的裸词。仅仅看一眼,你就无法判断一个裸词是函数还是字符串。通过在字符串上使用引号,在函数调用上使用括号,你就不会把它们弄混了。</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">避免类名称测试，例如： &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; 。通常，您可以删除 &lt;code&gt;eq 'FOO'&lt;/code&gt; 部分而完全没有伤害。让物体照顾自己！通常，请尽量避免使用硬连线的类名。</target>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">避免在你的软件包中保留任何状态信息。这使得其他多个包难以使用你的包。将状态信息保存在对象中。</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">避免libucb。</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">避免建立一个新的顶层结构,特别是如果已经有一个合适的层次结构存在,你可以把你的模块放在这个层次结构下。</target>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">避免在无效的上下文中使用 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; （或 &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ）或`backticks`，即当您丢弃它们的返回值时。这些函数都有返回值，因此请使用它们。否则，请改用 &lt;code&gt;foreach()&lt;/code&gt; 循环或 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">尽可能避免使用硬编码的测试号(在t/op/tie.t中找到的EXPECTED/GOT更容易维护,并且提供更好的故障报告)。</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">避免使用qx//和system(),除非你正在测试它们。如果你确实使用了它们,请确保你覆盖了所有的perl平台。</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">避免管道僵局</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">避免重复</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">Awk Traps</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-Perl编译器后端</target>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.拆包</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B::AV方法</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B::BINOP方法</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B::BM方法</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B::COP方法</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B::CV方法</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Concise-漫步Perl语法树,打印关于操作的简洁信息。</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Debug-漫步Perl语法树,打印关于OPS的调试信息。</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Perl编译器后端生成perl代码。</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Deparse 也可以在其他 perl 程序的基础上逐一使用。</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse是Perl编译器的后端模块，它基于perl自身在解析程序后创建的内部编译结构，生成perl源代码。 B :: Deparse的输出将与原始源不完全相同，因为perl不会跟踪注释或空格，并且perl的语法结构与其编译后的结构之间不存在一一对应的关系。形式，但通常会很接近。使用&lt;b&gt;-p&lt;/b&gt;选项时，即使优先级不需要括号，输出也会包含括号，这样可以很容易地查看perl是否按照您希望的方式解析表达式。</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B::GV方法</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B::HV方法</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B::IO方法</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::IO对象派生自IO对象,你将从IO对象本身获得更多信息。</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B::IV方法</target>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B::IV、B::NV、B::RV、B::PV、B::PVIV、B::PVNV、B::PVMG、B::BM(5.9.5及更早)、B::PVLV、B::AV、B::HV、B::CV、B::GV、B::FM、B::IO。这些类以明显的方式对应于名称相似的底层C结构。继承层次结构模仿了底层C语言的 &quot;继承&quot;。对于5.10.x分支,(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B::LISTOP方法</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B::LOGOP方法</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B::LOOP方法</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B::MAGIC方法</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B::METHOP 方法 (自 Perl 5.22 起)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B::NV方法</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B::OP方法</target>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B::PADLIST方法</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B::PADNAME方法</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B::PADNAMELIST方法</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B::PADOP方法</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B::PMOP方法</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B::PV方法</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B::PVLV方法</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B::PVMG方法</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B::PVOP方法</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B::REGEXP方法</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B::RV方法</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B::SV方法</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B::SVOP方法</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-显示函数或文件中使用的词法变量。</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Terse-漫步在Perl语法树上,打印关于操作的简明信息。</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B::UNOP方法</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B::UNOP_AUX 方法 (自 5.22)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-为Perl程序生成交叉引用报告。</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">逆向相容性和去掉性</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">逆向兼容性</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">基本方法</target>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">在你开始写一个模块之前。</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">BEGIN、UNITCHECK、CHECK、INIT和END。</target>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">最佳实践</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = less-&amp;gt; of（FEATURE）</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">BRACKET NOTATION</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX不支持shebang表示法（ &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ），因此您必须使用以下几行：</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">Solaris 上的 BSD::资源</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">早于 1.09 的 BSD::Resource 版本不能在 Solaris 的 perl 5.6.0 或更高版本上编译,原因与 Proc::ProcessTable 相同。从 1.09 开始的 BSD::Resource 版本有一个解决这个问题的方法。</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">另外。也要小心来自经理的压力,他们看到你把一个程序的运行速度提高了50%一次,一个月后却又接到要求做同样的事情(真实的故事)--你只要指出你只是人,即使你是Perl程序员,你也要看看自己的能力......</target>
        </trans-unit>
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">错误报告</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">缺陷和故障</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">缺陷和限制</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">错误和警告</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWIN上的错误</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">缺点和缺陷</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS是用于发布错误报告的电子邮件或URL。对于具有UPSTREAM =&amp;gt;'blead'的模块，请使用perl5-porters@perl.org。rt.cpan.org似乎会自动为CPAN模块提供URL；此处给出的任何值都将覆盖默认值：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http:&lt;/a&gt; //rt.cpan.org/Public/Dist/Display.html?Name= $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">建造和安装</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">建造新的扩建项目</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">在DOS上构建和安装模块。</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">为OPENVOS建立PERL</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">在AMIGAOS上建造PERL大楼。</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">在Perl拥有用于与C库连接的XS系统之前，程序员通常通过读取C头文件来获取库常量。您可能仍会看到 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; 或类似内容-</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">那时，未分配范围0xD800-0xDFFF。让我们将该范围分成两半，使用前半部分代表 &lt;code&gt;upper half of a character&lt;/code&gt; 的上半部分，使用下半部分代表字符的 &lt;code&gt;lower half of a character&lt;/code&gt; 。这样，您可以表示更多的1024 * 1024 = 1048576个字符。现在，即使使用16位编码，我们也可以存储最大\ x {10ffff}的字符范围。这对半字符现在称为</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">回到转换数据。如果你有(或想要)系统的本机8位编码的数据(如Latin-1、EBCDIC等),你可以使用pack/unpack来转换为/从Unicode。</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">构建测试库的后端</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">背景过程</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">背景和PERL_IMPLICIT_CONTEXT。</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">自己的背景是这样的。</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">向后引用到命名捕获组。等效于 &lt;code&gt;\g{NAME}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">在替换中使用&quot;$&quot;而不是&quot;\&quot;进行反向引用。</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">反斜杠序列</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">反斜杠一样平常用于转义下一个字符。</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">反斜杠序列字符类不能构成一个范围的端点之一。因此,你不能说。</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">反斜杠序列</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">反斜杠字符可以替换为相应的文字字符串（如 &lt;code&gt;\{&lt;/code&gt; ），也可以在有限自动机中生成特殊节点（如 &lt;code&gt;\b&lt;/code&gt; ）。 RE引擎专用的字符（例如 &lt;code&gt;|&lt;/code&gt; ）会生成相应的节点或节点组。 &lt;code&gt;(?#...)&lt;/code&gt; 注释将被忽略。其余的所有内容都将转换为文本字符串以匹配，否则将被忽略（如果存在 &lt;code&gt;/x&lt;/code&gt; ,则将空格和 &lt;code&gt;#&lt;/code&gt; 样式注释也是如此）。</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perl中的反斜杠元字符是字母数字，例如 &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\w&lt;/code&gt; ， &lt;code&gt;\n&lt;/code&gt; 。与其他一些正则表达式语言不同，没有不是字母数字的反斜杠符号。因此，任何看起来像\\，\（，\），\ [，\]，\ {或\}的东西始终被解释为文字字符，而不是元字符。曾经在一个常见的习惯用法中使用它来禁用或引用要用于模式的字符串中正则表达式元字符的特殊含义。只需引用所有非&amp;ldquo;单词&amp;rdquo;字符：</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">命令行参数中的反斜杠括号 &lt;code&gt;()&lt;/code&gt; 。不处理递归的Makefile &lt;code&gt;$(...)&lt;/code&gt; 构造，但处理简单的构造。</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">反引号 &lt;code&gt;``&lt;/code&gt; （请参阅perlop中的&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I / O运算符&lt;/a&gt;），该命令包含重定向或shell元字符;</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">反引号创建一个子进程，并将附带的字符串传递给它，以作为DCL命令执行。由于子过程是通过 &lt;code&gt;lib$spawn()&lt;/code&gt; 直接创建的，因此可以指定任何有效的DCL命令字符串。</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">回溯控制动词</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">在无情的搜索匹配过程中,回溯可能会浪费时间,特别是当匹配必然失败时。考虑一下简单的模式</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">回溯比使用不同正则表达式的重复尝试更有效。如果有多个正则表达式，并且与它们中的任何一个匹配都是可接受的，则可以将它们组合为一组替代项。如果各个表达式是输入数据，则可以通过对联接操作进行编程来完成。我们将在 &lt;code&gt;simple_grep&lt;/code&gt; 程序的改进版本中利用这一思想：该程序可匹配多种模式：</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">后向兼容性</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">向后兼容的模板</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">向后兼容性</target>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">坏的例子。</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">保释金结果名物。</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zsSzab&amp;oacute;（dLux），dlux @ kapu.hu</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">裸词不在重载字符串常量的范围内。</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress模块的基类</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress模块的基类</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">基础结构</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">绑定手柄的基础类定义</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">绑定哈希的基类定义</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">绑定标量的基类定义</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">所有类的基础类(祝福引用)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN外壳扩展的基础类</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant对象的基类。</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAP源迭代器的基类</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser输出对象的基类。</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">用于创建POD过滤器和翻译器的基础类。</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">不同TAP源处理程序的基础类</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">驾驭输出代表的基类</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">测试模块的基础类</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">绑定数组的基类</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">为&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser&lt;/a&gt;提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">为所有 &lt;code&gt;TAP::*&lt;/code&gt; 模块提供通用功能的基类</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldoc formatters的基础。</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">基于Stevan Little的&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;课程：: C3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;Pod :: Text :: pod2text（）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;Pod :: Text :: pod2text（1）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen（tchrist@mox.perl.com）编写的&lt;b&gt;Pod :: Text&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;pod2text（1）的&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">基于Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;编写的&lt;b&gt;pod2text&lt;/b&gt;代码</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">基于山口重雄编写的代码。</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">基于最初添加到MIME::QuotedPrint.pm中的Perl 5.8.0版本的例子。</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">基于Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;的想法，以及</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">基于 &lt;code&gt;:perlio&lt;/code&gt; 层。</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">基于Larry Wall和Perl 5 Porters 的 &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; 代码，该代码在相同的许可条款下发布。</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">根据《术语表》。</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">基于xsubpp代码,由Larry Wall编写。</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">基本模块</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">基本的IO操作</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">基本多语种平面</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">基本结构</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">基本线程支持</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">程序员的基本工具</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">基本命令。</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本方法</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">基本读操作。</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">基本信号词</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">基本语法概述</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">编写测试的基本工具。</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">基本的写操作。</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">基本上,Intel和VAX的CPU都是小迭代的,而其他人,包括Motorola m68k/88k、PPC、Sparc、HP PA、Power和Cray,都是大迭代的。Alpha和MIPS都可以。Digital/Compaq公司用的是(好吧,用过的)小迭代模式,但SGI/Cray公司用的是大迭代模式。</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">基本上,你从TAP中获取个别结果。六种类型以及每种类型的例子如下。</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">要注意两个重要点。</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">要知道,所有从File::Glob返回的文件名都有污点。</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">请注意，设置 &lt;code&gt;@DB::args&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">请注意,digest例程会默默地将UTF-8输入转换为等价的本地编码字节序列(参见utf8::downgrade)。这个副作用只影响Perl内部存储数据的方式,但在其他情况下,数据的实际值是不变的。</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">请注意,文件的类型/创建者和资源分叉会丢失,这通常是你在跨平台存档中想要的。</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">请注意，此模块的主要价值在于其简单性。请注意，那里已经有更多雄心勃勃的模块，例如&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;和&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">请注意，在 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 有机会获取信息之前，优化器可能已经优化了呼叫帧。这意味着，对于 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 可能不会返回有关您期望的呼叫帧的信息。特别是， &lt;code&gt;@DB::args&lt;/code&gt; 可能具有来自上一次 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">请注意，在 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 有机会获取信息之前，优化器可能已经优化了呼叫帧。这意味着，对于 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; 可能不会返回有关您期望的呼叫帧的信息。特别是， &lt;code&gt;@DB::args&lt;/code&gt; 可能具有来自上一次 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 信息。</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">请注意，遵循符号链接的选项可能很危险。根据目录树的结构（包括目录的符号链接），您可能会多次遍历给定的（物理）目录（仅当 &lt;code&gt;follow_fast&lt;/code&gt; 生效时）。此外，由于删除或更改了未知目录中的文件，因此删除或更改符号链接目录中的文件可能会引起非常不愉快的意外。</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">请注意,这些操作是完全的Unix分叉,这意味着它们可能无法在所有外来系统上正确实现。</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">请注意，使用此选项时，除非是US-ASCII或Latin-1，否则必须正确声明POD源的输入编码。没有 &lt;code&gt;=encoding&lt;/code&gt; 命令的POD输入将被假定为Latin-1，如果实际上是UTF-8，则输出将被双重编码。看到</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">此外,要知道,即使是在Unix左右的系统中,也存在着差异。</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">要注意语法。</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">如果在图片两边加上双引号，请小心，因为 &lt;code&gt;@&lt;/code&gt; 字符可能表示数组名称的开头。 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 始终返回true。有关其他示例，请参见&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">如果在图片两边加上双引号，请小心，因为 &lt;code&gt;@&lt;/code&gt; 字符可能表示数组名称的开头。 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; 始终返回true。有关其他示例，请参见&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">在随模块或程序提供的测试中要小心。模块代码可能是完全可移植的，但其测试却可能不是。当测试派生其他进程或调用外部程序以帮助测试时，或者（如上文所述）测试假设文件系统和路径有某些规定时，通常会发生这种情况。注意不要依赖特定的输出样式来检查错误，例如在检查 &lt;code&gt;$!&lt;/code&gt; 时。系统调用失败后。使用 &lt;code&gt;$!&lt;/code&gt; 除了将其显示为输出外，其他任何方面都值得怀疑（尽管请参见 &lt;code&gt;Errno&lt;/code&gt; 模块以合理地移植其错误值）。一些平台期望某种输出格式，并且那些平台上的Perl可能已经进行了相应的调整。最具体地说，在测试错误值时不要锚定正则表达式。</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">注意检查你传递给chdir()的内容是否被定义,而不是空白,否则你可能会发现自己的主目录。</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">要注意检查open()和close()的返回值。如果你是</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">注意每次重新编译扩展时都要重复这个过程,除非你确定AFS安装目录仍然有效。</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">当将分支重置模式与命名捕获结合使用时要小心。命名捕获的实现是对持有捕获的编号组的别名,这干扰了分支复位模式的实现。如果您在分支重置模式中使用命名捕获,最好在每一次交替中使用相同的名称,顺序相同。</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">但要注意,千万不要将文本字符串与二进制字符串结合起来。如果你需要二进制流中的文本,请先使用适当的编码对文本字符串进行编码,然后用二进制字符串加入它们。另请参见 &quot;如果我不编码怎么办?&quot;.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">小心:qx()、system()和一些调用外部命令的模块会先做fork(),然后等待()结果。这样,你的信号处理程序就会被调用。因为wait()已经被system()或qx()调用了,所以信号处理程序中的wait()不会再看到僵尸,因此会阻塞。</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">与现有模块保持一致。</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">要保持一致。</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">要有描述性(即准确描述模块的目的);</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">无论是 &lt;code&gt;Compress::Zlib&lt;/code&gt; ， &lt;code&gt;Apache::Request&lt;/code&gt; 还是任何联机帮助页中未提及Unicode的扩展，都需要确保删除了UTF8标志。请注意，在撰写本文时（2012年1月），提到的模块尚不支持UTF-8。请检查文档以确认是否仍然正确。</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">乖一点</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">一定不要使用裸词作为信号处理程序的名称,以免无意中调用它。</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">请确认您的yacc已经安装到位,包括任何必要的解析器模板文件。如果您还没有安装,请务必安装。</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">一定要对你的代码进行充分的注释。虽然没有必要对每一行都进行注释,但任何利用运算符的副作用、在被修补的函数之外产生变化、或者其他人可能会感到困惑的东西都应该被记录下来。如果你要出错,最好是在添加太多注释的一边出错,而不是太少。</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">请确保包括&lt;b&gt;确切的&lt;/b&gt;错误消息（如果有）。&amp;ldquo; Perl提供了错误&amp;rdquo;不是确切的错误消息。</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">如果您的Pod包含非ASCII字符，请务必阅读&lt;a href=&quot;#ENCODING&quot;&gt;编码&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">请务必仔细阅读makefiles顶部附近的说明。</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">确保在Makefile.PL或Build.PL中以及 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; 或类似版本中指定Perl版本要求。查看部分 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; 的&lt;a href=&quot;functions/require&quot;&gt;要求&lt;/a&gt;了解详情。</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">请务必使用在 Solaris 下编译的 tar 程序(不是 SunOS 4.x)来解压缩 perl-5.x.x.tar.gz 文件。不要在 Solaris 上使用为 SunOS4 编译的 GNU tar 程序。当你在 Solaris 上运行 SunOS4 二进制文件时,运行时系统会神奇地改变与 m#lib/locale#匹配的路径名,因此当 tar 尝试创建 lib/locale.pm 时,会创建一个名为 lib/oldlocale.pm 的文件。如果你发现这个建议太晚了,而且还是使用了 SunOS4 编译的 tar,你必须找到那个重命名错误的文件,并把它移回 lib/locale.pm。</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">请确保使用正在测试的版本所附带的库和模块,而不是那些已经安装的库和模块。</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">对于改变变量值的Perl操作要非常小心。例如,在变量中添加一些东西,可能需要重新分配它的存储空间,让你的指针进入无人之境。</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">请注意,无论是创建还是删除文件,都不能保证在NFS上是一个原子操作。也就是说,两个进程可能会同时成功地创建或解除同一个文件的链接。因此O_EXCL并不像你希望的那样具有排他性。</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">请注意,一些格式化程序不能可靠地渲染32-126以外的字符;许多格式化程序能够处理32-126和160-255,但不能处理255以上的字符。</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">请注意,此功能被认为是试验性的,可能会在不通知的情况下进行更改。</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">但是请注意，与正则表达式不同，如果 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 模板与传入的数据不匹配，Perl将会尖叫并死亡。</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">请注意:就像C-预处理器不懂C一样,Debug过滤器也不懂Perl。它很容易被愚弄。</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS就是BeOS。</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">因为 &quot;perlio.h &quot;是一个薄层(为了提高效率),这些函数的语义在某种程度上取决于底层的实现。在理解这些变化的情况下,它们在下面被指出。</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">由于&lt;b&gt;perldoc&lt;/b&gt;运行不正常，并且存在安全问题，因此当以超级用户身份运行时，它将尝试通过将有效和真实ID设置为任何人或nouser的帐户或-2（如果不可用）来放弃特权。如果它不能放弃其特权，它将不会运行。</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">由于 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 触发插值，因此您需要使用 &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 之类的字面值。</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">由于在应用 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 运算符时 &lt;code&gt;$sv&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此音译将不会真正执行，程序也不会 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 。这与5.8和更早版本的行为方式不同，因为捕获变量当时是READONLY变量。现在，在默认引擎中将它们分配给它们时，它们只会死亡。</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">因为当任何一个操作数为 &lt;code&gt;NaN&lt;/code&gt; （非数字）时 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，所以在使用类似 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 类的比较函数进行排序时，请小心任何可能包含 &lt;code&gt;NaN&lt;/code&gt; 的列表。以下示例利用 &lt;code&gt;NaN != NaN&lt;/code&gt; 来从输入列表中消除任何 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">因为当任何一个操作数为 &lt;code&gt;NaN&lt;/code&gt; （非数字）时 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，所以在使用类似 &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; 类的比较函数进行排序时，请小心任何可能包含 &lt;code&gt;NaN&lt;/code&gt; 的列表。以下示例利用 &lt;code&gt;NaN != NaN&lt;/code&gt; 来从输入列表中消除任何 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">因为 &lt;code&gt;.&lt;/code&gt; 在正则表达式中是特殊的，并且可以匹配任何单个字符，正则表达式 &lt;code&gt;P.&lt;/code&gt; 此处已匹配原始字符串中的&amp;lt;Pl&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">因为 &lt;code&gt;.&lt;/code&gt; 用作目录分隔符，并且不能假定文件名在10个字符后是唯一的，Acorn实现了C编译器，从源代码中指定的文件名中删除结尾的 &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; 和 &lt;code&gt;.o&lt;/code&gt; 后缀并存储相应的文件在以后缀命名的子目录中。因此文件被翻译为：</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 是运行时运算符，所以每次都会通过循环执行它。因此，将变量本地化到循环外会更有效。</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 是一元运算符，因此，如果您不小心在EXPR上使用了带括号的列表，则它的行为就像是标量逗号表达式，对空上下文中除最后一个元素以外的所有元素求值，并返回在标量上下文中求值的最终元素。这很少是您想要的。</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 在编译时生效，所以它不尊重正在编译的代码的普通流控制。特别是，将 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 置于条件的false分支内不会阻止对其进行处理。如果仅需要有条件地加载模块或编译指示，则可以使用&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;编译指示来完成：</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 是一元运算符，因此，如果您不小心在EXPR上使用了带括号的列表，则它的行为就像是标量逗号表达式，对空上下文中除最后一个元素以外的所有元素求值，并返回在标量上下文中求值的最终元素。这很少是您想要的。</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 在编译时生效，所以它不尊重正在编译的代码的普通流控制。特别是，将 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 置于条件的false分支内不会阻止对其进行处理。如果仅需要有条件地加载模块或编译指示，则可以使用&lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt;编译指示来完成：</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">因为可以随时调用 &lt;code&gt;DESTROY&lt;/code&gt; 方法，所以您应该本地化可能在 &lt;code&gt;DESTROY&lt;/code&gt; 中更新的所有全局变量。特别是，如果您使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ，则应本地化 &lt;code&gt;$@&lt;/code&gt; ；如果使用 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 或反引号，则应本地化 &lt;code&gt;$?&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">因为在测试过程中经常使用 &lt;code&gt;PERL5LIB&lt;/code&gt; 将构建目录添加到 &lt;code&gt;@INC&lt;/code&gt; ， &lt;code&gt;PERL5LIB&lt;/code&gt; 将-I开关传递在PERL5LIB中找到的任何目录的名称。这样做的净效果是，即使在污点模式下运行证明， &lt;code&gt;PERL5LIB&lt;/code&gt; 也会受到尊重。</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">因为在测试期间经常使用 &lt;code&gt;PERL5LIB&lt;/code&gt; 将构建目录添加到 &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 会在-I切换时传递在 &lt;code&gt;PERL5LIB&lt;/code&gt; 中找到的任何目录的名称。这样做的最终结果是，即使在异味模式下， &lt;code&gt;PERL5LIB&lt;/code&gt; 也能获得荣誉。</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">因为 &lt;code&gt;PL_restartop&lt;/code&gt; 不为null， &lt;code&gt;run_body&lt;/code&gt; 启动一个新的runops循环并继续执行。</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">因为 &lt;code&gt;STORABLE_attach&lt;/code&gt; 是通过类（而不是对象）传递的，所以它也直接返回对象，而不是修改传递的对象。</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">因为像橡树一样，橡子在文本文件中将ASCII和换行符（ &lt;code&gt;\n&lt;/code&gt; ）像 &lt;code&gt;\012&lt;/code&gt; 一样使用Unix，并且因为Unix文件名仿真默认情况下处于打开状态，所以大多数简单的脚本都可能&amp;ldquo;开箱即用&amp;rdquo;地工作。本机文件系统是模块化的，各个文件系统可以自由区分大小写或不区分大小写，并且通常保持大小写不变。某些本机文件系统具有名称长度限制，这些文件和目录名称会被自动截断以适合。脚本应注意，标准文件系统当前的名称长度限制为&lt;b&gt;10个&lt;/b&gt;字符，一个目录中最多可包含77个项目，但其他文件系统可能未施加此类限制。</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">因为C语言没有内置的整数指数函数,所以我们让Perl的**运算符为它所用(这比听起来要有用,因为Perl用C语言的</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">因为Perl允许您将裸词用于程序包名称和子例程名称，所以有时它会错误地解释裸词的含义。例如，构造 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 可以解释为 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; 或 &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; 。用英语来说，第二种解释为&amp;ldquo;调用一个名为Class（）的子例程，然后将new（）作为对Class（）返回值的方法进行调用&amp;rdquo;。如果当前名称空间中有一个名为 &lt;code&gt;Class()&lt;/code&gt; 的子例程，Perl将始终将 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 解释为第二种选择：对 &lt;code&gt;Class()&lt;/code&gt; 的调用返回的对象上的 &lt;code&gt;new()&lt;/code&gt; 的调用</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">由于Perl在显示之前对未捕获的异常消息进行了字符串化，因此您可能希望在异常对象上重载字符串化操作。有关详细信息，请参见&lt;a href=&quot;../overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">由于Perl在显示之前对未捕获的异常消息进行了字符串化，因此您可能希望在异常对象上重载字符串化操作。有关详细信息，请参见&lt;a href=&quot;overload&quot;&gt;重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">由于Perl内部使用双精度（或长双精度，如果已配置）进行所有数值计算，因此从double转换为float并因此再次变为double会失去精度，因此 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ）不会通常等于$ foo。</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">因为UTF-8是Perl的内部格式之一,所以你可以直接跳过编码或解码步骤,直接操作UTF8标志。</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">由于UTF-EBCDIC与UTF-8非常相似，因此差异几乎对您不可见。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; （不是像 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ）声明脚本在统一的平台的&amp;ldquo;原生&amp;rdquo;的8位编码。（类似于 &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; 层。）</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">因为VMS的退出代码和其他宇宙的退出代码有很大的不同,而且perl对它们进行了可怕的篡改,妨碍了我的工作,所以它在VMS上是这样工作的。</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">因为XS模块需要重新链接perl二进制文件,所以你需要perl二进制文件和perl源代码文件来构建XS扩展模块。此外,你必须从源码发行版中构建你的perl二进制文件,这样perl二进制文件的所有组件都可以用于所需的链接步骤。</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">因为失败的 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 匹配不会重置偏移量，所以在这种情况下 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 的返回值也不会改变。参见&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;和&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">因为失败的 &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 匹配不会重置偏移量，所以在这种情况下 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 的返回值也不会改变。参见&lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt;和&lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">因为返回了潜在候选者列表，所以 &lt;code&gt;while&lt;/code&gt; 循环依次尝试每个候选者，直到找到同时调用socket（）和connect（）的候选者。</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">由于将来的Unicode版本中可能会添加名称更正，因此 &lt;code&gt;viacode&lt;/code&gt; 返回的名称可能会随之更改。这是罕见的事件，但是确实发生了。</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">由于句点是元字符，因此需要对其进行转义以使其与普通句点匹配。例如，因为 &lt;code&gt;\d&lt;/code&gt; 和 &lt;code&gt;\w&lt;/code&gt; 是字符集，所以将 &lt;code&gt;[^\d\w]&lt;/code&gt; 视为 &lt;code&gt;[\D\W]&lt;/code&gt; 是不正确的；实际上 &lt;code&gt;[^\d\w]&lt;/code&gt; 与 &lt;code&gt;[^\w]&lt;/code&gt; 相同，也与 &lt;code&gt;[\W]&lt;/code&gt; 相同。想想德摩根的定律。</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">因为access（）不会调用stat（）（至少不是以Perl可见的方式），&lt;b&gt;所以未设置stat结果缓存&amp;ldquo; _&amp;rdquo;&lt;/b&gt;。这意味着以下两个测试的结果是不同的。第一个具有stat位</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">因为对 typeglob 的引用的赋值会创建一个别名,所以可以用来创建一个有效的本地函数,或者至少是一个本地别名。</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">因为反向标记不影响标准错误,如果你关心这个问题,请使用shell文件描述符语法(假设shell支持这个)。要把一个命令的STDERR和STDOUT一起捕获。</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">因为CRLF和LF都以LF结尾,所以可以将输入记录分隔符设置为LF,之后再剥离任何CR。最好写。</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">由于花括号（花括号）还用于其他一些功能，包括BLOCK，因此有时可能需要在语句的开头通过在前面加上 &lt;code&gt;+&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; 来消除花括号的歧义，以使Perl意识到开头的花括号不是在开始BLOCK。 。使用冰壶的经济性和助记符的价值被认为值得这个偶尔的额外麻烦。</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">因为依赖一个目录来确保它的存在并不是太好用(修改时间变化太频繁),dir_target()在创建的目录中创建一个.exces文件。你应该依赖这个文件。为了便于移植,你应该使用$(DIRFILESEP)宏而不是'/'来分隔目录和文件。</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">因为每个操作数都以整数形式求值，所以 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; 将在列表上下文中返回两个元素。</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">因为即使在非Unix端口上，Perl的glob函数也遵循标准的Unix globlob语义。您需要 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; 来获取所有（非隐藏）文件。这使得glob（）甚至可以移植到旧系统。您的端口可能还包括专有的globing函数。查看其文档以了解详细信息。</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">因为历史上有些操作系统默默地砍掉了 &lt;code&gt;#!&lt;/code&gt; 内核解释！在32个字符后的行中，某些开关可能会在命令行中传递，而有些则不会。如果您不小心的话，甚至可以得到一个不带字母的&amp;ldquo;-&amp;rdquo;。您可能要确保所有开关都落在该32个字符的边界之前或之后。大多数开关实际上并不关心是否进行了冗余处理，但是获得&amp;ldquo;-&amp;rdquo;而不是完整的开关可能会导致Perl尝试执行标准输入而不是程序。而部分&lt;b&gt;-I&lt;/b&gt;开关也可能导致奇怪的结果。</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">因为如果_1为1，则会得到&amp;ldquo; 1个文档&lt;b&gt;已&lt;/b&gt;匹配&amp;rdquo;。可以接受的修改方法如下：</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">由于无法可靠地从本地8位编码中分辨出UTF-8，因此您需要在源代码的开头使用字节顺序标记，或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; ，以指导perl。</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">因为它是一个模块,而不是解释器的一个组成部分,NEXT.pm必须猜测周围的调用在方法查找序列中的位置。在存在钻石继承模式的情况下,它偶尔会猜错。</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">因为在 &lt;code&gt;IO::Handle&lt;/code&gt; 类中加载是一项昂贵的操作，所以您应该学习如何使用常规的内置变量。</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">由于许多操作系统允许对Perl程序文件具有读取访问权限的任何人制作该文件的副本，修补该副本，然后执行该副本，因此，具有安全意识的Perl程序员应注意调用已安装的Perl副本，而不是调用Perl副本。 &lt;code&gt;$^X&lt;/code&gt; 引用的副本。以下语句可实现此目标，并产生可作为命令调用或作为文件引用的路径名。</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">因为本机操作系统文件句柄是全局的，并且当前是从255向下分配的，而0是保留值，所以Unix仿真库将模拟Unix文件句柄。因此，您不能依赖于将 &lt;code&gt;STDIN&lt;/code&gt; ， &lt;code&gt;STDOUT&lt;/code&gt; 或 &lt;code&gt;STDERR&lt;/code&gt; 传递给孩子。</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">因为Perl中的对象是以引用的形式实现的,所以也可以用对象进行循环引用。想象一个TreeNode类,每个节点都会引用它的父节点和子节点。任何有父节点的节点都将是循环引用的一部分。</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">由于DST的更改，在许多时间段中，同一天的同一本地时间发生在同一天的两个不同的GMT时间。例如，在&amp;ldquo;欧洲/巴黎&amp;rdquo;时区中，2001-10-28 02:30:00的本地时间可以表示格林尼治标准时间2001-10-28 00:30:00 &lt;b&gt;或&lt;/b&gt; 2001-10-28 01：格林尼治标准时间30:00。</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">由于perl（＃19213）中的错误，至少在5.6.1版中，我们必须对路径分隔符进行硬编码，以使Win32上的require为 &lt;code&gt;/&lt;/code&gt; ，例如在Unix而不是Win32 &lt;code&gt;\&lt;/code&gt; 上。否则，如果再次需要，或者在最坏的情况下是核心转储，则perl将无法读取其自己的％INC准确地将其加倍加载文件。</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">由于缺乏更好的东西,这个模块使用自己的例程来打包和解压ICMP数据包。最好是编写一个单独的模块,了解所有不同种类的ICMP数据包。</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">由于这些问题,从 v5.22 开始,如果在单字节的语言环境中使用多字节(因此是 Unicode)代码点,Perl 会发出警告。(尽管如果这样做会不合理地减慢执行速度,它不会检查这个问题。)</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">由于与传统编码的向后兼容性,&quot;每个字符都有一个唯一的数字 &quot;的想法有点崩溃:相反,&quot;每个字符至少有一个数字&quot;。同一个字符在几种遗留编码中可以有不同的表示。反之则不然:有些码点没有分配的字符。首先,在本来使用的块内有未分配的码点。其次,有一些特殊的Unicode控制字符不代表真正的字符。</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">因为在 &lt;code&gt;$$x&lt;/code&gt; 的简单情况下可以省略掉curly，所以人们经常会犯错误，即将反引用符号视为适当的运算符，并对其优先级感到疑惑。如果是这样，则可以使用括号代替大括号。事实并非如此。考虑下面的区别；案例0是案例1的简写版本</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">由于时钟的粒度，到期时间可能比您预期的要早一秒。例如，假设您存储一个生命周期为十秒的值，并将其存储在特定日期的12：00：00.998。备忘录将查看时钟并看到12:00:00。然后9.01秒后，在12：00：10.008，您尝试将其读回。 Memoize将查看时钟并看到12:00:10，并得出该值已过期的结论。如果您安装了 &lt;code&gt;Time::HiRes&lt;/code&gt; 则可能不会发生。</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">由于OS/2的特殊性,我们不可能把所有的鸡蛋放在同一个篮子里(尽管EMX环境努力克服这种限制,所以这种情况可能会有所改善)。发行版中提供了4个Perl的可执行文件。</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">由于它的全局效果,这个设置不应该在模块等内部使用。</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">由于我们的原生 yacc 存在问题,我们使用 GNU bison 为 perly.y 生成了一个纯粹的 (=reentrant)解析器,所以我们的 yacc 其实就是下面的脚本。</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">由于采用了&amp;ldquo;文本&amp;rdquo;模式转换，DOSish perls在使用以&amp;ldquo;文本&amp;rdquo;模式访问的文件上 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 时存在局限性。坚持 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; （而没有其他人）得到的位置，通常即使在&amp;ldquo;文本&amp;rdquo;模式下，您也可以自由使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 。使用 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 或其他文件操作可能是不可移植的。但是，如果在文件上使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; ，通常可以安全地 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 任意值。</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">由于UTF-16是16位的,所以UTF-16是依赖于字节顺序的,它本身可以用于内存计算,但如果需要存储或传输,则必须选择UTF-16BE(big-endian)或UTF-16LE(little-endian)编码。UTF-16本身可以用于内存计算,但如果需要存储或传输,则必须选择UTF-16BE(big-endian)或UTF-16LE(little-endian)编码。</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">由于使用的算法,ISO-8859系列和其他单字节编码都不好用,除非ISO-8859中的任何一个都有嫌疑(除了ascii和utf8)。</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">由于与这个修改器相关的意外行为,你可能只应该用它来保持奇怪的后向兼容性。</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">由于变量$a和$b在sort()中的特殊用途,它们被免除了这个检查。</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">由于这种机制是很重要的&lt;b&gt;自动装载&lt;/b&gt;总是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; d，而不是 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d。</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">因为这两点,在基于ucm的Encoding中使用的代码分页方法SOMETIMES失败,所以写了这个模块。</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">因为模式是作为双引号字符串处理的,所以下面也可以使用。</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">因为perl在应用此编译指示之前需要分析脚本，所以Shift_JIS和Big-5之类的编码在第二个字节中可能包含 &lt;code&gt;'\'&lt;/code&gt; （BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ）失败，因为第二个字节可能不小心转义了后面的引号字符。</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">因为指针大小不一定等于整数大小,所以要用下面的宏来做好。</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">因为脚本的方向性不同（例如，希伯来语和阿拉伯语是从右到左书写的），所以Unicode提供了 &lt;code&gt;Bidi_Class&lt;/code&gt; 属性。该属性可以具有的一些值是：</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">因为污损与每个标量值相关联，所以可以污染数组或哈希的某些元素，而其他则不可以。哈希键&lt;b&gt;永远不会&lt;/b&gt;被污染。</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">因为 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ed值写回文件时将重新附加分隔符。无法创建缺少尾随记录分隔符字符串的文件。</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 函数会在文件末尾或出现错误时返回 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ，因此有时您会看到它以这种方式使用：</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">由于 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句暗含一个 &lt;code&gt;BEGIN&lt;/code&gt; 块，因此语义的导入是在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 语句编译后即文件的其余部分编译之前进行的。这就是它如何充当杂注机制的方式，以及模块如何能够声明子例程，这些子例程随后对于列表的剩余部分或一元运算符可见。如果使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ,则此方法将不起作用。使用 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 可以解决这个问题：</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">由于 &lt;code&gt;here&lt;/code&gt; 位置在模式中的 &lt;code&gt;.*&lt;/code&gt; 之前，因此可以精确确定其位置。这是不正确的，但是，对于 &lt;code&gt;there&lt;/code&gt; ; 它可能出现在锚定字符串出现后的任何位置。Perl出于优化目的同时使用这两种方法，它们倾向于使用更长的时间，或者，如果相等，则选择浮动。</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">由于分配复制值，因此还具有将按引用调用转换为按值调用的效果。否则，函数可以随意对 &lt;code&gt;@_&lt;/code&gt; 进行就地修改并更改其调用者的值。</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">因为转换发生在原地,所以要转换的数据不能是字符串常量:必须是标量变量。</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">由于目前的实现使用表和密钥大小来进行散列算法,所以没有办法动态地改变任何初始化参数的值。</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">因为这个功能的目的主要是让你定义像内置函数一样工作的子程序,这里有一些其他函数的原型,它们的解析几乎和相应的内置函数完全一样。</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">因为内部格式通常是UTF-8,所以这些bug很难被发现,因为UTF-8通常是你想要的编码! 但是不要偷懒,不要利用Perl的内部格式是UTF-8这个事实来为自己谋取利益。明确地进行编码以避免奇怪的错误,并向维护程序员表明你已经考虑到了这一点。</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">由于该模式同时包含文件类型及其权限，因此如果要查看实际权限，应使用 &lt;code&gt;&quot;%o&quot;&lt;/code&gt; 屏蔽文件类型部分和（s）printf 。</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">由于 &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; 具有所有引号，因此无法在 &lt;code&gt;\Q\E&lt;/code&gt; 对中插入文字 &lt;code&gt;$&lt;/code&gt; 或 &lt;code&gt;@&lt;/code&gt; 。如果受 &lt;code&gt;\&lt;/code&gt; 保护，则 &lt;code&gt;$&lt;/code&gt; 将引用为 &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ；如果不是，则将其解释为插值标量的开始。</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">因为smartmatch操作符在嵌套数组上递归,这仍然会报告 &quot;红色 &quot;在数组中。</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">因为&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;每次测试失败时都会产生标准失败消息，这是您测试错误输出中的常见现象，并且因为它在Test :: Builder版本之间发生了变化，而不是强迫您使用字符串all 来调用 &lt;code&gt;test_err&lt;/code&gt; 。像这样的时间</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">因为目标是重用的,所以在堆栈上推送多个值时一定要小心。下面的代码不会像你想象的那样。</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">因为翻译表是在编译时建立的,所以在编译时,无论是</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">因为 &lt;code&gt;$Config{archname}&lt;/code&gt; 的值可能取决于硬件体系结构，所以它的变化可能大于 &lt;code&gt;$^O&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">因为values行可能包含任意表达式(对于at字段,而不是caret字段),你可以把更复杂的处理工作交给其他函数,比如sprintf()或你自己的函数。例如,你可以将更复杂的处理工作交给其他函数,比如sprintf()或你自己的函数。</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">因为在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 情况下变量立即合法，所以只要范围内没有该名称的变量，就可以在同一条语句中再次引用包变量。</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">因为在 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; 情况下变量立即合法，所以只要范围内没有该名称的变量，就可以在同一条语句中再次引用包变量。</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">因为open()有三个以上的参数,所以将ps(1)命令打成叉。</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">因为有些人对谁可以在@INC路径中的哪个位置以及谁使用哪个@INC数组有确切的期望。在微调的环境中， &lt;code&gt;UNINST=1&lt;/code&gt; 可能会造成损坏。</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">因为这些资源对象被认为是整个进程/系统的所有者，而不是序列化的任何东西的&amp;ldquo;属性&amp;rdquo;，所以序列化的字符串中不应包含对象下面的引用。因此，在任何实现 &lt;code&gt;STORABLE_attach&lt;/code&gt; 的类中， &lt;code&gt;STORABLE_freeze&lt;/code&gt; 方法无法返回任何引用，如果 &lt;code&gt;STORABLE_freeze&lt;/code&gt; 尝试返回引用，则 &lt;code&gt;Storable&lt;/code&gt; 将引发错误。</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">因为此命令在某种意义上是新命令，所以如果您似乎意外输入了一个块，则会发出警告。如果这就是您要执行的操作，请使用 &lt;code&gt;;{ ... }&lt;/code&gt; 甚至 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; 编写。</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">因为这个函数使用了mktemp(),所以它可能会受到竞赛条件的影响。</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">因为这些信息并不存储在perl可执行文件本身,所以这些信息有可能(但不太可能)与实际的perl二进制文件无关。</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">因为这是一个开放的接口,所以pragmas(编译器指令)也是这样实现的。目前实现的pragmas有:</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">因为这个操作符会产生一个可赋值的结果,所以使用没有括号的赋值会给你带来麻烦。例如,这个。</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">因为这样可以促进远距离的行动,这种反直觉的行为可能会在未来的版本中得到修正。</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">因为线程创建和线程连接可能发生在不同的上下文中，所以可能需要将上下文明确声明给线程的入口点函数。这可以通过使用哈希引用作为第一个参数调用 &lt;code&gt;-&amp;gt;create()&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">因为变量引用总是以'$'、'@'或'%'开头,所以 &quot;保留 &quot;的字样实际上并不是对变量名的保留。它们</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">因为我们现在关注的是来自于</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">因为我们是用一个SV来调用</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">因为我们创建了临时值(通过调用sv_2mortal()),所以我们必须整理Perl堆栈,并处理死亡的SV。</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">因为我们指定了G_DISCARD,所以不需要检查从G_DISCARD返回的值。</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">因为禁用 &lt;code&gt;autochomp&lt;/code&gt; 时， &lt;code&gt;$a[10]&lt;/code&gt; 将读为 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; （或任何记录分隔符字符串）。</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">因为您只是将现有&lt;b&gt;标准输出&lt;/b&gt;移动到其他地方。</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">因为你正在使用类似这样的东西,它截断文件</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">在Perl 5.10.0和5.8.8之前，运行外部命令时未对PERL5SHELL进行污染检查。在Windows下以异味模式运行时，建议您显式设置（或删除） &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">在Perl 5.14之前，对 &lt;code&gt;$@&lt;/code&gt; 的赋值发生在恢复本地化变量之前，这意味着要使代码在较旧版本上运行，如果要掩盖部分但不是全部错误，则需要一个临时变量：</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">在Perl 5.14之前,超载和tie()ing之间的关系被打破了。超载的触发与否是基于</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">在Perl 5.18之前， &lt;code&gt;given(EXPR)&lt;/code&gt; 分配了</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">在Perl 5.6之前，您必须使用 &lt;code&gt;*FH&lt;/code&gt; 或 &lt;code&gt;\*FH&lt;/code&gt; 表示法。这些是&amp;ldquo; typeglobs&amp;rdquo;- 有关更多信息，请参见&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;perldata中的Typeglobs&lt;/a&gt;和Filehandles，尤其是&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsub中的&amp;ldquo;按引用传递&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">在Perl 5.8.0之前,安装处理信号的Perl代码会让你面临两方面的危险。首先,很少有系统库函数是重入的。如果信号在 Perl 执行一个函数的时候中断(比如 malloc(3)或 printf(3)),而你的信号处理程序又调用了同一个函数,你可能会得到不可预知的行为--通常是核心转储。其次,Perl本身并不是在最低层重入的。如果在Perl改变自己内部数据结构的时候,信号中断了Perl,那么同样会导致不可预测的行为。</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">在Perl v5.8.0之前， &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 来声明当前块或文件中的操作将支持Unicode。发现该模型是错误的，或至少是笨拙的：&amp;ldquo; Unicodeness&amp;rdquo;现在随数据一起携带，而不是附加到操作中。从Perl v5.8.0开始，只有一种情况需要显式 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; ：如果您的Perl脚本本身是以UTF-8编码的，则可以在标识符名称以及字符串和正则表达式文字中使用UTF-8，通过说 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 。这不是默认设置，因为其中包含旧式8位数据的脚本会中断。参见&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">在Unicode之前,大多数编码使用8位(一个字节)来编码每个字符。因此,一个字符就是一个字节,一个字节就是一个字符,而且只能有256个或更少的可能字符。本节标题中的 &quot;字节语义 &quot;指的就是这种行为。没有必要区分 &quot;字节 &quot;和 &quot;字符&quot;。</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">在Unicode之前，当一个字符是一个字节即一个字符时，Perl仅知道ASCII定义的128个字符，代码点为0到127（ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 除外）。剩下的代码点128至255未分配，并且可用于程序可能需要的任何用途。它们唯一的语义是它们的序数，并且它们都不是非负字符类的成员。无被视为匹配 &lt;code&gt;\w&lt;/code&gt; 的例子，但全部匹配 &lt;code&gt;\W&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">在执行任何命令之前或如果发生意外错误， &lt;code&gt;code()&lt;/code&gt; 将返回&amp;ldquo; 421&amp;rdquo;（临时连接失败），而 &lt;code&gt;message()&lt;/code&gt; 将返回undef。</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">在任何其他事情之前,你需要一个测试计划。这基本上声明了你的脚本要运行多少次测试以防止过早失败。</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">在给IBM C-编译器安装补丁之前,你需要知道操作系统的补丁级别。IBM的命令'oslevel'会显示基础,但并不总是完整的(在这个例子中oslevel显示4.3.NULL,而系统可能会运行4.3.THREE的大部分)。</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">在perl5.6之前,你必须处理各种tyeglob习语,这些习语你可能会在旧代码中看到。</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">在Perl第5版之前,表示复杂的数据结构是很困难的,因为所有的引用都必须是符号的--即使如此,也很难引用一个变量而不是一个符号表项。现在,Perl 不仅使变量的符号引用变得更加容易,而且还允许你对任何数据或代码进行 &quot;硬 &quot;引用。任何标量都可以持有一个硬引用。因为数组和散列包含标量,所以你现在可以轻松地构建数组的数组、数组的散列、数组的散列、函数的散列等。</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">在提交bug之前,请确认从shell中按照软件包的安装说明来构建Perl模块包的传统方法在你的环境中仍然有效。</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">在终止之前， &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 功能必须通过调用 &lt;code&gt;filter_add&lt;/code&gt; 显式安装过滤器。</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">在Perl解释器可以执行Perl脚本之前，它必须首先将其从文件中读取到内存中以进行解析和编译。如果该脚本本身包括带有 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 语句的其他脚本，则每个脚本也必须从各自的文件中读取。</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">在Perl中引入Unicode支持之前， &lt;code&gt;eq&lt;/code&gt; 运算符仅比较了两个标量表示的字符串。从Perl 5.8开始， &lt;code&gt;eq&lt;/code&gt; 比较两个字符串，同时考虑</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">在引入词法警告之前,Perl有两类警告:强制警告和可选警告。</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">在我们开始刮出代码之前,有几件事我们要提前做。</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">在我们进行下一步之前，您将需要知道如何退出调试器：仅使用字母&amp;ldquo; &lt;b&gt;q&lt;/b&gt; &amp;rdquo;，而不要使用&amp;ldquo; quit&amp;rdquo;或&amp;ldquo; exit&amp;rdquo;一词：</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">在编写XS之前，请阅读下面的&lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt;部分。</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">在您考虑发布错误报告之前,请咨询,并可能在讨论区发布消息,看看您遇到的是否是已知问题。</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">在继续之前，请注意变量的排序顺序。一般情况下，我们首先列表不区分大小写，几乎lexigraphical顺序变量（忽略 &lt;code&gt;{&lt;/code&gt; 或 &lt;code&gt;^&lt;/code&gt; 前述词语，如 &lt;code&gt;${^UNICODE}&lt;/code&gt; 或 &lt;code&gt;$^T&lt;/code&gt; ），虽然 &lt;code&gt;$_&lt;/code&gt; 和 &lt;code&gt;@_&lt;/code&gt; 向上移动到顶部一堆 对于具有相同标识符的变量，我们按标量，数组，哈希和裸字的顺序列出。</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">在决定合并两个哈希值之前,你必须决定如果两个哈希值都包含相同的键,以及是否要保持原来的哈希值不变,该怎么做。</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">在执行其他任何操作之前，可以通过确保让Perl告诉您代码中的问题区域来帮助自己。通过打开警告和约束，您可以避免许多问题变得太大。您可以在&lt;a href=&quot;strict&quot;&gt;严格&lt;/a&gt;和&lt;a href=&quot;warnings&quot;&gt;警告中&lt;/a&gt;找到更多关于这些的信息。</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">在执行此操作之前，请首先使用 &lt;code&gt;resolve_alias()&lt;/code&gt; 确保别名不存在，该别名将返回其规范名称。例如：</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">在开始阅读本文档的其余部分之前，先阅读以下两个文档（&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;和&lt;a href=&quot;perlguts&quot;&gt;perlguts）&lt;/a&gt;是一个好主意。</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">在您惊慌失措之前，请知道许多人确实将 &lt;code&gt;Moose&lt;/code&gt; 用于命令行工具和其他对启动敏感的代码。我们建议您在担心启动速度之前先尝试 &lt;code&gt;Moose&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">在你开始之前</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">在你开始之前,知道一些事情很重要。</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">在你开始之前,你应该先浏览一下在解压Perl发行版的顶层目录中找到的README文件。确保你阅读并理解本软件发布的条款。</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">在你开始之前,你应该先浏览一下在解压Perl发行版的顶层目录中找到的README文件。确保你阅读并理解本软件发布的条款。</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">开始从远程服务器检索名为 &lt;code&gt;FILE&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">初学者注意：在示例2中， &lt;code&gt;$columns&lt;/code&gt; 以上的元素被导入到本地名称空间，并在本地设置。在示例3中， &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; 在其自身的名称空间中设置，而无需导入。</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">初学者往往认为要让一个变量包含一个变量的名称。</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">从Perl 5.12开始，Perl接受省略号&amp;ldquo; &lt;code&gt;...&lt;/code&gt; &amp;rdquo;作为尚未实现的代码的占位符。这种形式的省略号（未实现的语句）不应与二进制 &lt;code&gt;...&lt;/code&gt; 操作符混淆。一个是语句，另一个是运算符。（Perl通常不会混淆它们，因为通常Perl可以告诉它是想要运算符还是语句，但是请参阅下文以了解异常。）</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">从v5.20.0开始，提供了使用引用的后缀语法。它的行为如《&lt;a href=&quot;#Using-References&quot;&gt;使用参考》中所述&lt;/a&gt;，但使用前缀后缀的sigil-and-star代替前缀的sigil。</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">从v5.22.0开始,引用操作符可以被分配到。它执行了一个别名操作,这样左手边引用的变量名就变成了右手边引用的东西的别名。</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">从HP-UX 11.00开始,在HP-UX下编译的程序可以利用LP64编程环境(LP64的意思是Longs和Pointers是64位宽),其中标量变量将可以完全精确地容纳大于2^32的数字。自5.8.1以来,Perl在所有HP-UX 11.xx上被证明在64位模式下是稳定可靠的。</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">从HP-UX 10.20版本开始,可以创建和操作大于2GB(2^31字节)的文件。有三种不同的方法可以做到这一点。在这些方法中,对于Perl来说,最好的方法是使用配置的-Duselargefiles标志进行编译。这将导致 Perl 使用 64 位宽的结构和函数进行编译,而不是 32 位宽。(注意,这只适用于 HP 的 ANSI C 编译器。如果你想用gcc编译Perl,你必须得到一个支持64位操作的编译器版本。参见上文,哪里可以找到它)。)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">从Perl 5.10.0开始，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字声明变量来代替 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 。但是，要使该功能正常工作，您必须预先启用该功能，方法是使用 &lt;code&gt;feature&lt;/code&gt; 杂注或在 &lt;code&gt;-E&lt;/code&gt; 上使用-E（请参阅&lt;a href=&quot;feature&quot;&gt;功能&lt;/a&gt;）。从Perl 5.16开始， &lt;code&gt;CORE::state&lt;/code&gt; 表单不需要 &lt;code&gt;feature&lt;/code&gt; 编译指示。</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">从Perl 5.18开始，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 声明一个私有子例程。与状态变量一样， &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 关键字仅在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 或更高版本时可用。</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">从perl 5.10.0开始，您还可以使用 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 变量来具有仅初始化一次的词法（请参阅&lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">从5.004版本开始,还支持以下功能。</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">行为类似于系统上的wait（2）：它等待子进程终止并返回已故进程的pid，如果没有子进程则返回 &lt;code&gt;-1&lt;/code&gt; 。状态以 &lt;code&gt;$?&lt;/code&gt; 返回？和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。请注意，返回值 &lt;code&gt;-1&lt;/code&gt; 可能意味着正在自动获得子进程，如&lt;a href=&quot;../perlipc&quot;&gt;perlipc中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">行为类似于系统上的wait（2）：它等待子进程终止并返回已故进程的pid，如果没有子进程则返回 &lt;code&gt;-1&lt;/code&gt; 。状态以 &lt;code&gt;$?&lt;/code&gt; 返回？和 &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。请注意，返回值 &lt;code&gt;-1&lt;/code&gt; 可能意味着正在自动获得子进程，如&lt;a href=&quot;perlipc&quot;&gt;perlipc中所述&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">除了返回类型外，其他行为与&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;相同。仅应在需要 &lt;code&gt;OP *&lt;/code&gt; 返回类型的地方使用。该函数实际上不会返回。</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">除了返回类型外，其他行为与&lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;相同。仅应在需要 &lt;code&gt;OP *&lt;/code&gt; 返回类型的地方使用。该函数实际上不会返回。</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">其他Perl特性在分叉伪进程中的行为。</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">这个功能的行为根据你的系统实现而大相径庭。例如,它通常不会跨文件系统边界工作,即使系统的</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">2.11版本以来的行为</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">幕后花絮</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">在后台， &lt;code&gt;globmap&lt;/code&gt; 函数对文件glob进行组合以匹配现有的文件名，然后通过替换来创建新的文件名。</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">作为Perl特有的函数,这个函数已经随着时间的推移而发展。目前,它的调用方式如下。</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">作为一个机械过程,pl2pm并不是防弹的。转换后的代码需要仔细检查,特别是任何包的声明。在新的.pm工作之前,不要删除原来的.pl文件。</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">例如在某些情况下依赖于文件描述符时，例如在文件句柄上使用flock（）锁定，则在文件句柄上保持同等也很有用。如果仅 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; ，文件句柄A将与B没有相同的文件描述符，因此flock（A）不会flock（B），反之亦然。但是在 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; ，文件句柄将共享相同的基础系统文件描述符。</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">例如在某些情况下依赖于文件描述符时，例如在文件句柄上使用flock（）锁定，则在文件句柄上保持同等也很有用。如果仅 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; ，文件句柄A将与B没有相同的文件描述符，因此flock（A）不会flock（B），反之亦然。但是在 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; ，文件句柄将共享相同的基础系统文件描述符。</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">当单词完成失败时,会发出铃声。</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">以下是几个环球地图的例子</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">以下是</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">以下是一些框架的列表,并附有评论,这可能会帮助你做出决定,这取决于你的具体要求。从阅读文档开始,然后在相关的邮件列表或IRC频道上提问。</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">下面是Perl目前没有使用的Unicode数据库中的文件列表,以及对它们用途的简要描述。其中一些文件的名称与Unicode使用的文件名称相比有所缩短,以使它们能够与文件系统中类似名称的文件区分开来,因为对这些文件来说,名称的前8个字符才是重要的。</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">以下是可用的方法列表。</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">以下是有效选项的列表。</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">以下是在有条件的情况下,哪些公用事业将按什么顺序用于什么计划的图谱。</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">以下是执行重命名的脚本的一个可能的实现(省略了错误情况)</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">下面是一个使用 &lt;code&gt;gzreadline&lt;/code&gt; 的脚本。它实现了一个非常简单的</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">下面是一个简单的&amp;ldquo;重命名&amp;rdquo;脚本，该脚本使用 &lt;code&gt;globmap&lt;/code&gt; 确定源文件名和目标文件名。</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">下面是一个使用宏的例子模块。</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">下面是一个示例程序 &lt;code&gt;cpp_test&lt;/code&gt; ，它使用了此过滤器。添加了行号，以便可以轻松引用特定的行。</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">以下仅是一个示例，说明了控制动词 &lt;code&gt;(*FAIL)&lt;/code&gt; ，可以将其缩写为 &lt;code&gt;(*F)&lt;/code&gt; 。如果将其插入到正则表达式中，将导致它失败，就像在模式和字符串之间不匹配时一样。正则表达式的处理将像在任何&amp;ldquo;正常&amp;rdquo;失败之后一样继续进行，因此，例如，将尝试字符串中的下一个位置或其他替换方式。由于不匹配不会保留捕获组或产生结果，因此可能有必要将其与嵌入式代码结合使用。</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">以下是我的机器上重现配置的示例。在</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">以下是显示如何使用 &lt;code&gt;LimitOutput&lt;/code&gt; 的典型代码。</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">Ben Tilly</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">基准 -Perl代码的基准运行时间。</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">基准对象</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Benchmark不继承其他类,当然除了Exporter。</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl代码的基准运行时间</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Benjamin Holzman 贡献了绑定变量支持,Andrew Ford 贡献了哈希的规范顺序,Gisle Aas 修正了我对 perl 内部的一些误解,并优化了输出流中 &quot;标签 &quot;的发射,只对对象进行计数而不是标记(导致 Storable 图像从 0.6 版本开始出现二进制不兼容--当然,旧的图像仍然可以正确理解)。Murray Nesbitt 使 Storable 成为线程安全的。Marc Lehmann 增加了重载和对绑定项的引用支持。Benjamin Holzman 增加了对重载类的性能改进;感谢 Grant Street Group 的支持。</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB允许使用NULL（即C中的 &lt;code&gt;(char *)0&lt;/code&gt; ）代替文件名来创建内存数据库。&lt;b&gt;DB_File&lt;/b&gt;使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 而不是NULL来提供此功能。</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB是一个C库，它为许多数据库格式提供一致的接口。&lt;b&gt;DB_File&lt;/b&gt;提供了Berkeley DB当前支持的所有三种数据库类型的接口。</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DB使用函数dbopen()来打开或创建一个数据库。这里是dbopen()的C语言原型。</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">BerkeleyDB可用于Cygwin。</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">除了import()和AUTOLOAD()之外,只有其他几个方法。</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">除了&lt;a href=&quot;#decode&quot;&gt;解码&lt;/a&gt;和&lt;a href=&quot;#encode&quot;&gt;编码外&lt;/a&gt;，其他方法也可用。例如， &lt;code&gt;name()&lt;/code&gt; 返回编码对象的规范名称。</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">除了检查现有的XS代码外，该脚本还可用于使用 &lt;code&gt;--api-info&lt;/code&gt; 命令行开关检索各种API调用的兼容性信息。例如：</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">除了许多其他的测试,它还会测试它在你的系统中找到的每一个locale,看看它们是否符合POSIX标准。如果有任何错误,它将会在输出的结尾处包含一个总结,说明哪些locale通过了所有的测试,哪些失败了,以及原因。</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">除了将交叉编译器和其他工具链放在 PATH 中,还将提供 QNX_TARGET 变量,我们将通过 -Dsysroot 将其传递给配置。</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">除了将这些哈希另存为hashref属性 &lt;code&gt;name2path&lt;/code&gt; 和 &lt;code&gt;path2name&lt;/code&gt; 之外，调用此函数还返回这些hashref。在列表上下文中， &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; 的返回值是列表 &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; 。在标量上下文中，返回值为 &lt;code&gt;\%name2path&lt;/code&gt; 。或者，您可以仅在无效上下文中调用它。</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">除了 &lt;code&gt;$|&lt;/code&gt; 特殊变量，您可以使用 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; 为文件句柄提供一个 &lt;code&gt;:unix&lt;/code&gt; 层，该层是无缓冲的：</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">除了上面讨论的NBSP字符外，还提醒实现者拉丁语1中存在另一个&amp;ldquo;特殊&amp;rdquo;字符，即&amp;ldquo;软连字符&amp;rdquo;字符，也称为&amp;ldquo;自由连字符&amp;rdquo;，即 &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ）。此字符表示可选的连字符点。就是说，它通常不显示任何内容，但是如果格式化程序在该点中断了单词，则可能显示为&amp;ldquo;-&amp;rdquo;。 Pod格式化程序应适当地执行以下操作之一：1）使用具有相同含义的代码（例如RTF中的&amp;ldquo; \-&amp;rdquo;）渲染此代码，2）期望格式化程序将其理解为以下字符：或3）删除它。</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">除了普通的数组索引循环外， &lt;code&gt;for&lt;/code&gt; 还可用于许多其他有趣的应用程序。如果您在交互式文件描述符上显式测试文件结束时导致程序看上去挂起，那么这可以避免您遇到的问题。</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">除了显而易见的文件外,源代码也是有指导意义的。一些使用参考资料的病态例子可以在《》中找到。</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">除了明显的pod转换之外，Pod :: Man还负责格式化func（），func（3）以及$ foo或@bar之类的简单变量引用，因此您不必为它们使用代码转义符。不过，仍然需要转义 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 类的复杂表达式。它还会将不用作连字符的破折号转换为破折号，将长破折号（如此类）转换为适当的破折号，修复&amp;ldquo;成对的引号&amp;rdquo;，使C ++看起来正确，在双下划线之间留一点空格，使ALLCAPS &lt;b&gt;troff的&lt;/b&gt;小一些，并且转义了* roff认为特殊的东西，因此您不必这样做。</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">除了显而易见的pod转换之外，Pod :: Man和因此pod2man还负责格式化func（），func（n）以及$ foo或@bar之类的简单变量引用，因此您不必为其使用代码转义符; 不过，仍然需要转义 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; 类的复杂表达式。它还将不用作连字符的破折号转换为破折号，将长破折号（如此类）转换为适当的破折号，修复&amp;ldquo;成对的引号&amp;rdquo;，并处理其他一些针对troff的调整。有关完整的信息，请参见&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">除了众所周知的小于和大于的&amp;ldquo; E &amp;lt;lt&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;gt&amp;gt;&amp;rdquo;代码外，Pod解析器还必须将&amp;ldquo; /&amp;rdquo;（固线，斜杠）和&amp;ldquo; E &amp;lt;verbar&amp;gt;&amp;ldquo;代表&amp;rdquo; |&amp;ldquo; （垂直杆，管道）。 Pod解析器还应该将&amp;ldquo; E &amp;lt;lchevron&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;rchevron&amp;gt;&amp;rdquo;理解为字符171和187的旧代码，即&amp;ldquo;左指向双角引号&amp;rdquo; =&amp;ldquo;左指向吉尔梅特&amp;rdquo;和&amp;ldquo;右指向双精度&amp;rdquo;角引号&amp;rdquo; =&amp;ldquo;右指向吉尔梅特&amp;rdquo;。 （这些看起来有点像&amp;ldquo; &amp;lt;&amp;lt;&amp;rdquo;和&amp;ldquo; &amp;gt;&amp;gt;&amp;rdquo;，现在最好用HTML / XHTML代码&amp;ldquo; E &amp;lt;laquo&amp;gt;&amp;rdquo;和&amp;ldquo; E &amp;lt;raquo&amp;gt;&amp;rdquo;表示。）</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">除此之外，上述所有Unicode字符属性（Perl标记为供内部使用的那些字符属性除外）也可以通过&lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;Unicode :: UCD中的prop_invlist（）&lt;/a&gt;访问。</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">除了用于输出的整个短语之外,任何与语言相关的东西都应该放在 Projname::L10N::en_us 类中,无论是作为方法,还是作为词典条目 --这在上面的 &quot;每个词典中的条目 &quot;一节中讨论。</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">制作新模块的最佳做法。</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">在Mac OS X 10.3 &quot;Panther &quot;和10.6 &quot;Snow Leopard &quot;之间,&quot;命令行工具 &quot;包被称为 &quot;unix工具&quot;,通常与Mac OS安装DVD一起提供。</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">在 &lt;code&gt;%&lt;/code&gt; 和格式字母之间，您可以指定几个其他属性来控制格式的解释。这些是：</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">还要注意比较复杂的表达方式的顺序,比如。</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">小心简单的 &quot;投掷 &quot;整个表达式,这样只会转换已经计算好的结果。</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">小心:</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">请注意，如果在 &lt;code&gt;\Q&lt;/code&gt; 和 &lt;code&gt;\E&lt;/code&gt; 之间放置文字反斜杠（那些不在插入变量内），则双引号反斜杠插值可能会导致混淆。如果你</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">请注意,一些命令壳可能会对命令行的长度进行限制。你必须确保你的字符串在进行任何必要的插值后不超过这个限制。关于你的特定环境的更多细节,请参见特定平台的发布说明。</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">注意，与 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 不会将模式作为其第一个参数。比较&lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">注意，与 &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 不会将模式作为其第一个参数。比较&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">小心。这个功能还没有完全实现。</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">小心。这个名单并不完整。</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">当心：此函数返回后， &lt;code&gt;ptr&lt;/code&gt; 和SvPVX_const（sv）可能不再引用同一数据块。</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">超越Unicode码点</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">超越测试</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">除了这些帮助,urllist配置参数就是你的了。你可以随意添加和删除站点。你应该找出哪些网站的更新速度、带宽、可靠性等都是最好的,并且在拓扑上离你很近。有些人喜欢快速下载,有些人喜欢最新的,有些人喜欢可靠性。你决定按哪种顺序去尝试。</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">除此之外，最简单的调试器是 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 功能。在运行程序时使用它查看值：</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">除此之外,你还要考虑几件事,并决定哪件事情最适合你。</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">除了描述的使一般Perl程序更快或更小的常规措施之外，CGI程序还存在其他问题。它可能每秒运行几次。考虑到每次运行它都需要重新编译，并且通常会分配一兆字节或更多的系统内存，这可能是一个杀手.。编译为C &lt;b&gt;不会对您有帮助，&lt;/b&gt;因为过程启动开销是瓶颈所在。</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">除了赋予系统像脚本一样灵活的特殊权限所产生的明显问题之外,在许多版本的Unix上,set-id脚本从一开始就是不安全的。问题是内核中的一个竞赛条件。从内核打开文件看看要运行哪个解释器,到(现在的set-id)解释器转过身来重新打开文件进行解释,这段时间里,文件可能已经发生了变化,尤其是当你的系统上有符号链接的时候。</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">与另一进程的双向通信</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">与自己的双向沟通</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigInt的bcmp（）例程当前返回undef，以表示比较中涉及NaN。但是，重载代码将其变为1或&amp;rdquo;，因此 &lt;code&gt;NaN != NaN&lt;/code&gt; 可能返回错误的值。</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">更大的数字</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">如果左参数在数值上不等于右参数，则二进制 &lt;code&gt;&quot;!=&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 类似于 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 只是返回值在逻辑上取反。</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">具有无损替换（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ）或音译（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ）的二进制 &lt;code&gt;&quot;!~&quot;&lt;/code&gt; 是语法错误。</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 是取模运算符，它计算第一个参数相对于第二个参数的除法余数。给定整数操作数 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; ：如果 &lt;code&gt;$n&lt;/code&gt; 为正数，则 &lt;code&gt;$m % $n&lt;/code&gt; 为 &lt;code&gt;$m&lt;/code&gt; 减去 &lt;code&gt;$n&lt;/code&gt; 的最大倍数小于或等于 &lt;code&gt;$m&lt;/code&gt; 。如果 &lt;code&gt;$n&lt;/code&gt; 为负，则 &lt;code&gt;$m % $n&lt;/code&gt; 为 &lt;code&gt;$m&lt;/code&gt; 减去 &lt;code&gt;$n&lt;/code&gt; 的不小于 &lt;code&gt;$m&lt;/code&gt; 的最小倍数（也就是说，结果将小于或等于零）。如果操作数 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; 是浮点值，并且 &lt;code&gt;$n&lt;/code&gt; 的绝对值（即 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）小于 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; ，操作中仅使用 &lt;code&gt;$m&lt;/code&gt; 和 &lt;code&gt;$n&lt;/code&gt; 的整数部分（注意：此处 &lt;code&gt;UV_MAX&lt;/code&gt; 表示无符号整数类型的最大值）。如果右操作数的绝对值（ &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）大于或等于 &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; ，则 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 将计算公式中的浮点余数 &lt;code&gt;$r&lt;/code&gt; &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; 其中 &lt;code&gt;$i&lt;/code&gt; 是使 &lt;code&gt;$r&lt;/code&gt; 与右操作数具有相同符号的特定整数 &lt;code&gt;$n&lt;/code&gt; （&lt;b&gt;不&lt;/b&gt;作为左操作数 &lt;code&gt;$m&lt;/code&gt; 象C函数 &lt;code&gt;fmod()&lt;/code&gt; ）和绝对值小于的 &lt;code&gt;$n&lt;/code&gt; 。请注意，当在范围内 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 时， &lt;code&gt;&quot;%&quot;&lt;/code&gt; 使您可以直接访问由C编译器实现的模运算符。没有为负操作数定义此运算符，但执行速度更快。</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; 返回其操作数，并一点一点地相加在一起。尽管当前未发出警告，但是当对既不是数字（请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;）又不是&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;位字符串&lt;/a&gt;（请参阅按位字符串运算符）的操作数执行此操作时，结果定义不明确。</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; 执行短路逻辑&amp;ldquo;与&amp;rdquo;运算。也就是说，如果左操作数为false，则甚至不会评估右操作数。如果评估标量或列表上下文，则向下传播到正确的操作数。</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">如果左参数在数值上大于右参数，则Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 返回true。</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">二进制 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 返回其左参数的值，该值向右偏移右参数指定的位数。参数应为整数。（另请参阅&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算术&lt;/a&gt;。）</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
